
var xmjd = mstrmojo && mstrmojo.descriptors;

var mstrmojo = {


    
    descriptors: xmjd || {},

    
    meta: {
        TP: "t",     
        STP: "st"    
    },

    emptyFn: function () {},

    
    now: function now() {
        return new Date().getTime();
    },

    
    usesFrames: false
};



mstrmojo.gmaps = {};

(function () {
    var $mojo = mstrmojo;

    
    $mojo.global = (function () {
        var f = function () {
            return this;
        };
        return f.call(null);
    }());

    
    $mojo.dbg = $mojo.emptyFn;
    $mojo.dbg_stack = $mojo.emptyFn;
    $mojo.dbg_xhr = $mojo.emptyFn;
    $mojo.dbg_profile = $mojo.emptyFn;


    
    $mojo.platform = {};
    $mojo.prompt = {};
    $mojo.settings = {};
    $mojo.ui = {};
    $mojo.ACL = {};
    $mojo.storage = {};
    $mojo.utils = {};
    $mojo.maps = {};
    $mojo.maps.androidmap = {};
    $mojo.maps.jsmap = {};
    $mojo.graph = {};
    $mojo.IPA = {};
    $mojo.ME = {};
    $mojo.Architect = {};
    $mojo.plugins = {};
    $mojo.gmaps = {};
    $mojo.DI = {};
    $mojo.qb = {};
    $mojo.WH = {};
    $mojo.txEditor = {};

    
    $mojo.express = {
        ui: {}
    };

    
    $mojo.android = {
        controllers: {},
        factories: {},
        inputControls: {},
        large: {
            controllers: {},
            factories: {},
            ui: {}
        },
        medium: {
            controllers: {},
            factories: {},
            ui: {}
        },
        selectors: {},
        ui: {}
    };

    
    $mojo.iphone = {};

    
    $mojo.winphone = {};

    
    $mojo.mstr = {};


    
    $mojo.err = function err(e) {
        
        var s = e.name + ': "' + e.message + '"';

        if ($mojo.debug) {
            if (e.fileName) {
                s += ' at\n    ' + e.fileName;
            }
            if (e.hasOwnProperty('lineNumber')) {
                s += ': ' + e.lineNumber;
            } else if (e.hasOwnProperty('line') && e.sourceURL) { 
                var a = e.sourceURL.split('/');
                s += '(' + a[a.length > 1 ? a.length - 1 : 0] + ':' + e.line + ')';
            }
        }

        
        this.dbg(s);
 

        
        if ($mojo.Dialog) {
            $mojo.alert(e.message, null, e.name);
        } else {
            window.alert(s);
        }
    };

    
    $mojo.confirm = function confirm(msg) {
        return window.confirm(msg);
    };

    
    $mojo.alert = function alrt(msg) {
        window.alert(msg);
    };

    
    var canParseFuncs = !!(/return true/.test(function () {
        return true;
    }));

    
    $mojo.mixin = function mixin(src, dest) {
        if (src) {
            dest = dest || {};
            var funcCallsSuper = /this\.\_super/;

            
            var fnWrapMethod = function (overwriting, inher) {
                return function superwrap() {
                    var tmp = this._super;
                    this._super = inher;
                    var ret = overwriting.apply(this, arguments || []);
                    this._super = tmp;
                    return ret;
                };
            };

            
            var fnOnMixin = src.__onmixin__;
            if (fnOnMixin) {
                delete src.__onmixin__;
            }

            var n;
            for (n in src) {
                
                
                if ((typeof src[n]  === 'function') && (!canParseFuncs || funcCallsSuper.test(src[n]))) {
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    dest[n] = fnWrapMethod(src[n], dest[n]);
                } else {
                    
                    dest[n] = src[n];
                }
            }

            
            if (fnOnMixin) {
                src.__onmixin__ = fnOnMixin;
            }
        }
        return dest;
    };
}());

(function () {

    
    var _xhr;

    
    var _missing = {};

    var _G = mstrmojo.global,
        _app = _G.mstrApp || {},
        _jsRoot = _app.jsRoot || "../javascript/",
        _jsMojoRoot = _app.jsMojoRoot || "../javascript/mojo/js/source/",
        _isIE = !!document.all;     

    
    function _fqcn2File(fqcn) {
        if (fqcn.match(/^mstrmojo\.plugins\./)) {
            var pluginName = fqcn.substring(17, fqcn.indexOf(".", 17));
            fqcn = '../plugins/' + pluginName + '/javascript/' + _jsMojoRoot + fqcn.replace("mstrmojo.plugins." + pluginName + '.', "").replace(/\./gm, '/');
        } else if (fqcn.match(/^mstrmojo\./)) {
            fqcn = _jsMojoRoot + fqcn.replace("mstrmojo.", "").replace(/\./gm, '/');
        } else {
            fqcn = _jsRoot + fqcn.replace(/\./gm, '/');
        }
        return fqcn + '.js';
    }

    function _getXHR() {
        
        
        _xhr = self.XMLHttpRequest ? new XMLHttpRequest() : (self.ActiveXObject ? new ActiveXObject("Microsoft.XMLHTTP") : null);
    }
    
    function _syncGet(file) {
        var result = null;

        if (!_xhr) {
            _getXHR();
        }
        if (_xhr) {
            try {
                
                _xhr.open("GET", file, false);
                _xhr.send(null);
                
                result = _xhr.responseText || null;
            } catch (localerr) {}

            
            
            if (!_isIE && _xhr.abort) {
                _xhr.abort();
            }

        }
        return result;
    }

    
    function encodeParams(params) {
        var x = -1,
            url = [],
            p;

        if (params) {
            for (p in params) {
                url[++x] = p + '=' + encodeURIComponent(params[p]);
            }
        }

        return url.join('&');
    }

    
    function appendUrlParams(method, baseUrl, params) {
        if (method !== 'GET' || !params) {
            return baseUrl;
        }

        return baseUrl + '?' + encodeParams(params);
    }

    function _syncXHR(method, baseUrl, params) {
        var result = null;

        
        method = method.toUpperCase();
        if (!_xhr) {
            _getXHR();
        }
        if (_xhr) {
            try {
                var config = mstrConfig,
                    m = null;

                if (window.microstrategy !== undefined && microstrategy) {
                    m = microstrategy;
                }

                
                params.taskContentType = params.taskContentType || 'json';
                params.taskEnv = 'xhr';
                params.xts = mstrmojo.now();

                params = mstrmojo.addCSRFTokenToTaskParams(params);

                
                var ptp = (config && config.persistTaskParams) || (m && m.persistParams);
                if (ptp) {
                    mstrmojo.requiresCls("mstrmojo.hash");
                    mstrmojo.hash.copy(ptp, params);
                }

                _xhr.open(method, appendUrlParams(method, baseUrl, params), false);

                if (method !== 'POST') {
                    params = null;
                } else {
                    params = encodeParams(params);
                    _xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                }

                _xhr.send(params);
                
                result = _xhr.responseText || null;
            } catch (localerr) {
                window.console.log(localerr);
            }
        }
        return result;
    }
    
    function _jsGet(file, nullCheck) {
        var js = _syncGet(file);
        if (js) {
            try {
                eval(js);

                return nullCheck ?
                        !!eval(nullCheck) :
                        true;
            } catch (localerr) {
                window.alert('JavaScript compile error:\n\nFile: ' + file + '\n\nError: ' + localerr.message);
            }
        }
        return false;
    }

    
    mstrmojo.loader = {
        
        loaded: {
            mstrmojo: true,
            "mstrmojo.loader": true
        },

        
        isLoaded: function isLd(fqcn) {
            var o;
            try {
                o = eval(fqcn);
            } catch (localerr) {}
            if (o) {
                this.loaded[fqcn] = true;
            }
            return !!o;
        },

        
        load: function ld(fqcn) {
            
            if (_missing[fqcn]) {
                return false;
            }
            
            if (this.loaded[fqcn] || this.isLoaded(fqcn)) {
                return true;
            }
            
            if (_jsGet(_fqcn2File(fqcn), fqcn)) {
                this.loaded[fqcn] = true;
                return true;
            }

            _missing[fqcn] = true;
            return false;
        }
    };

    var _L = mstrmojo.loader,
        _LL = _L.loaded;

    
    var _reqCache = {};

    
    mstrmojo.requiresCls = function reqCls() {
        
        var as = arguments,
            ns = [],
            len = as.length,
            i;

        
        for (i = 0; i < len; i++) {

            
            var n = as[i];
            if (!n || _LL[n] || _reqCache[n] || _missing[n]) {
                continue;
            }

            if (!n.match(/^mstrmojo\.plugins\./)) {
                
                var ps = n.split('.'),
                    klen = ps.length,
                    k;

                for (k = 1; k < klen; k++) {
                    var s = ps.slice(0, k).join('.');
                    if (!_reqCache[s]) {
                        ns.push(s);
                        _reqCache[s] = true;
                    }
                }
            }
            
            ns.push(n);
            _reqCache[n] = true;
        }
        
        var jlen = ns.length,
            j;
        for (j = 0; j < jlen; j++) {
            if (!_L.load(ns[j])) {
                window.alert('Warning: Javascript class not found:\n' + ns[j]);
                break;
            }
        }
        return true;
    };

    
    var _D = mstrmojo.descriptors,
        _dPrefix = 'mstrWeb.';

    
    function populateDescriptors(ds) {
        if (ds) {
            var dlen = ds.length,
                di;
            for (di = 0; di < dlen; di++) {
                var d = ds[di];
                _D[d.key] = d.v;
            }
        }
    }

    mstrmojo.populateDescriptors = populateDescriptors;

    
    if (window.mstrConfig !== undefined) {
        populateDescriptors(mstrConfig.mstrDescs && mstrConfig.mstrDescs.descriptors);

    
        mstrConfig.mstrDescs = null;
    }
    if (typeof mstrApp != 'undefined') {
        populateDescriptors(mstrApp.mstrDescs && mstrApp.mstrDescs.descriptors);
    }

    
    if (typeof mstrApp != 'undefined') {
        populateDescriptors(mstrApp.mstrDescs && mstrApp.mstrDescs.descriptors);
    }

    
    var _reqDesc = function (prefix, ids) {
        
        var as = ids,
            ns = [],
            len = as.length,
            i;

        for (i = 0; i < len; i++) {
            var k = as[i];
            if (k && !(_D.hasOwnProperty(prefix + k))) {
                ns.push(k);
            }
        }
        if (ns.length > 0) {
            var response = _syncXHR('POST', (window.mstrConfig && mstrConfig.taskURL) || 'taskProc', {
                taskId: 'getDescriptors',
                keys: ns.join(','),
                prefix: prefix
            });

            if (response) {
                var r = eval('(' + response + ')');
                populateDescriptors(r && r.descriptors);
            }
        }
    };

    
    mstrmojo.requiresDescsWPrefix = function reqDescP(prefix) {
        var p = prefix,
            args = [].slice.call(arguments);

        args[0] = null;
        _reqDesc(p, args);
    };

    
    mstrmojo.requiresDescs = function reqDesc() {
        
        
        if (window.mstrConfig !== undefined && !mstrConfig.onMobileDevice) {
            _reqDesc(_dPrefix, arguments);
        }
    };

    
    mstrmojo.desc = function desc(descID, defText) {
        
        if (descID !== null && descID !== undefined) {
            
            mstrmojo.requiresDescs(descID);

            
            if (_D.hasOwnProperty(_dPrefix + descID)) {
                return _D[_dPrefix + descID];
            }

            
            defText = defText || "No string descriptor found for descID=" + descID;
        }

        
        var decDefText = "[" + defText + "]";

        
        _D[_dPrefix + descID] = decDefText;

        return decDefText;
    };

    
    mstrmojo.descP = function descP(prefix, descID, defText) {
        
        mstrmojo.requiresDescsWPrefix(prefix, descID);

        
        if (_D.hasOwnProperty(prefix + descID)) {
            return _D[prefix + descID];
        }

        
        defText = defText || "No string descriptor found for descID=" + descID;

        
        var decDefText = "*" + defText + "*";

        
        _D[prefix + descID] = decDefText;

        return decDefText;
    };

    

    
    mstrmojo.provide = function prv(fqcn, cls) {
        _LL[fqcn] = !!cls;
        return cls;
    };

       
    
    mstrmojo.invalidateCls = function rel(fqcn) {
        _reqCache[fqcn] = false;
        _LL[fqcn] = false;

        eval(fqcn + " = null");
    };

    var mx = mstrmojo.mixin;

    
    mstrmojo.declare = function dcl(SuperCls, mixins, config) {
        
        function constr(props) {
            if ((!props || !props.dontInit) && this.init) {
                this.init(props);
            }
        }

        
        
        
        
        
        
        
        if (SuperCls) {
            constr.prototype = new SuperCls({dontInit: true});
            constr.prototype.constructor = constr;
        }

        var proto = constr.prototype;

        
        var cnt = (mixins && mixins.length) || 0,
            i;
        for (i = 0; i < cnt; i++) {
            mx(mixins[i], proto);
        }

        
        if (config) {
            mx(config, proto);
            if (config.scriptClass) {
                _LL[config.scriptClass] = true;
            }
        }

        return constr;
    };

    
    mstrmojo.findAncestor = function findAncestor(src, property, value, limitClass) {
        var ancestor = src && src.parent;
        while (ancestor && (!limitClass || !(ancestor instanceof limitClass))) {
            var targetProperty = ancestor[property];
            if (targetProperty !== undefined) {
                if (value !== undefined && value !== null) {
                    if (targetProperty === value) {
                        return ancestor;
                    }
                } else {
                    return ancestor;
                }
            }

            ancestor = ancestor.parent;
        }

        return null;
    };

    
    mstrmojo.isDescendant = function isDescendant(parent, child) {
        var ancestor;

        if(!child || !parent) {
            return false;
        }
        ancestor = child.parent;
        
        while(ancestor) {
            
            if(ancestor === parent) {
                return true;
            }
            
            ancestor = ancestor.parent;
        }
        return false;
    };

    
    mstrmojo.getCSRFToken = function getVRN(url) {
        var tkn = null;

        try {
            if (url) { 
                if (url.indexOf('validateRandNum=') >= 0) { 
                    return tkn;
                }

                var curURL = window.location.href;
                var servletName = window.mstrApp && mstrApp.name,
                    taskProcName = window.mstrConfig.taskURL && mstrConfig.taskURL,
                    isSameWebApp = (url.indexOf(servletName) === 0 || 
                        url.indexOf('./' + servletName) === 0 || 
                        url.indexOf(taskProcName) === 0 || 
                        url.indexOf('./' + taskProcName) === 0 || 
                        url.indexOf(curURL) === 0 || 
                        ((curURL.indexOf('?') > 0) && (url.indexOf(curURL.substring(0, curURL.indexOf('?'))) === 0))); 
                if (!isSameWebApp) { 
                    return tkn;
                }
            }
            if (window.mstrApp && mstrApp.validateRandNum) {
                tkn = mstrApp.validateRandNum;
            } else if (window.mstrConfig && mstrConfig.validateRandNum) {
                tkn = mstrConfig.validateRandNum;
            } else if (window.microstrategy !== undefined && microstrategy && microstrategy.validateRandNum) {
                tkn = microstrategy.validateRandNum;
            }
        } catch (err) {
            
        }
        return tkn;
    };

    
    mstrmojo.addCSRFTokenToURL = function addCSRFTknToURL(url) {
        if (!url) {
            return '';
        }
        var tkn = mstrmojo.getCSRFToken(url);
        if (tkn && tkn.length > 0) {
            if (url.indexOf('?') > 0) {
                url += "&";
            } else {
                url += "?";
            }
            url += "validateRandNum=" + tkn;
        }
        return url;
    };

    
    mstrmojo.addCSRFTokenToTaskParams = function addCSRFTknToTaskParams(params) {
        if (params) {
            var tkn = mstrmojo.getCSRFToken();
            if (tkn && tkn.length > 0) {
                params.validateRandNum = tkn;
            }
        }
        return params;
    };

    
    mstrmojo.getInstance = function getInstance(config) {
        var Clazz = mstrmojo.hash.walk(config.scriptClass, window);
        if (Clazz) {
            return new Clazz(config);
        }

        return null;
    };

}());

















































function printStackTrace(options) {
    var ex = (options && options.e) ? options.e : null;
    var guess = (options && options.guess) ? options.guess : true;
    
    var p = new printStackTrace.implementation();
    var result = p.run(ex);
    return (guess) ? p.guessFunctions(result) : result;
}

printStackTrace.implementation = function() {};

printStackTrace.implementation.prototype = {
    run: function(ex) {
        
        var mode = this._mode || this.mode();
        if (mode === 'other') {
            return this.other(arguments.callee);
        }
        else {
            ex = ex ||
                (function() {
                    try {
                        (0)();
                    } catch (e) {
                        return e;
                    }
                })();
            return this[mode](ex);
        }
    },
    
    mode: function() {
        try {
            (0)();
        } catch (e) {
            if (e.arguments) {
                return (this._mode = 'chrome');
            } else if (e.stack) {
                return (this._mode = 'firefox');
            } else if (window.opera && !('stacktrace' in e)) { 
                return (this._mode = 'opera');
            }
        }
        return (this._mode = 'other');
    },
    
    chrome: function(e) {
        return e.stack.replace(/^.*?\n/, '').
                replace(/^.*?\n/, '').
                replace(/^.*?\n/, '').
                replace(/^[^\(]+?[\n$]/gm, '').
                replace(/^\s+at\s+/gm, '').
                replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@').
                split("\n");
    },
    
    firefox: function(e) {
        return e.stack.replace(/^.*?\n/, '').
                replace(/(?:\n@:0)?\s+$/m, '').
                replace(/^\(/gm, '{anonymous}(').
                split("\n");
    },
    
    
    opera: function(e) {
        var lines = e.message.split("\n"), ANON = '{anonymous}', 
            lineRE = /Line\s+(\d+).*?script\s+(http\S+)(?:.*?in\s+function\s+(\S+))?/i, i, j, len;
        
        for (i = 4, j = 0, len = lines.length; i < len; i += 2) {
            if (lineRE.test(lines[i])) {
                lines[j++] = (RegExp.$3 ? RegExp.$3 + '()@' + RegExp.$2 + RegExp.$1 : ANON + '()@' + RegExp.$2 + ':' + RegExp.$1) +
                ' -- ' +
                lines[i + 1].replace(/^\s+/, '');
            }
        }
        
        lines.splice(j, lines.length - j);
        return lines;
    },
    
    
    other: function(curr) {
        var ANON = "{anonymous}", fnRE = /function\s*([\w\-$]+)?\s*\(/i, stack = [], j = 0, fn, args;
        
        var maxStackSize = 10;
        while (curr && stack.length < maxStackSize) {
            fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;
            args = Array.prototype.slice.call(curr['arguments']);
            stack[j++] = fn + '(' + printStackTrace.implementation.prototype.stringifyArguments(args) + ')';
            
            
            if (curr === curr.caller && window.opera) {
	            
                break;
            }
            curr = curr.caller;
        }
        return stack;
    },
    
    stringifyArguments: function(args) {
        for (var i = 0; i < args.length; ++i) {
            var argument = args[i];
            if (typeof argument == 'object') {
                args[i] = '#object';
            } else if (typeof argument == 'function') {
                args[i] = '#function';
            } else if (typeof argument == 'string') {
                args[i] = '"' + argument + '"';
            }
        }
        return args.join(',');
    },
    
    sourceCache: {},
    
    ajax: function(url) {
        var req = this.createXMLHTTPObject();
        if (!req) {
            return;
        }
        req.open('GET', url, false);
        req.setRequestHeader("User-Agent", "XMLHTTP/1.0");
        req.send('');
        return req.responseText;
    },
    
    createXMLHTTPObject: function() {
	    
        var xmlhttp, XMLHttpFactories = [
            function() {
                return new XMLHttpRequest();
            }, function() {
                return new ActiveXObject("Msxml2.XMLHTTP");
            }, function() {
                return new ActiveXObject("Msxml3.XMLHTTP");
            }, function() {
                return new ActiveXObject("Microsoft.XMLHTTP");
            }
        ];
        for (var i = 0; i < XMLHttpFactories.length; i++) {
            try {
                xmlhttp = XMLHttpFactories[i]();
                
                this.createXMLHTTPObject = XMLHttpFactories[i];
                return xmlhttp;
            } catch (e) {}
        }
    },
    
    getSource: function(url) {
        if (!(url in this.sourceCache)) {
            this.sourceCache[url] = this.ajax(url).split("\n");
        }
        return this.sourceCache[url];
    },
    
    guessFunctions: function(stack) {
        for (var i = 0; i < stack.length; ++i) {
            var reStack = /{anonymous}\(.*\)@(\w+:\/\/([-\w\.]+)+(:\d+)?[^:]+):(\d+):?(\d+)?/;
            var frame = stack[i], m = reStack.exec(frame);
            if (m) {
                var file = m[1], lineno = m[4]; 
                if (file && lineno) {
                    var functionName = this.guessFunctionName(file, lineno);
                    stack[i] = frame.replace('{anonymous}', functionName);
                }
            }
        }
        return stack;
    },
    
    guessFunctionName: function(url, lineNo) {
        try {
            return this.guessFunctionNameFromLines(lineNo, this.getSource(url));
        } catch (e) {
            return 'getSource failed with url: ' + url + ', exception: ' + e.toString();
        }
    },
    
    guessFunctionNameFromLines: function(lineNo, source) {
        var reFunctionArgNames = /function ([^(]*)\(([^)]*)\)/;
        var reGuessFunction = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*(function|eval|new Function)/;
        
        
        var line = "", maxLines = 10;
        for (var i = 0; i < maxLines; ++i) {
            line = source[lineNo - i] + line;
            if (line !== undefined) {
                var m = reGuessFunction.exec(line);
                if (m) {
                    return m[1];
                }
                else {
                    m = reFunctionArgNames.exec(line);
                }
                if (m && m[1]) {
                    return m[1];
                }
            }
        }
        return "(?)";
    }
};
(function(){

    var DEFAULT_COLOR = "#000000";
        
    
    mstrmojo.color = mstrmojo.provide(
        "mstrmojo.color",
        
        
        {
            
             
            hexChars: '0123456789ABCDEF',

            
            toHex: function C_toHex(n) {
                n = n || 0;
                n = Math.max(Math.min(isNaN(n) ? 0 : parseInt(n, 10), 255), 0);
        
                return this.hexChars.charAt((n - n % 16) / 16)
                        + this.hexChars.charAt(n % 16);
            },

            toDec: function C_toDec(h) {
                return this.hexChars.indexOf(h.toUpperCase());
            },

            
            rgbStr2rgb: function C_rgbStr2rgb(color) {
                var rgb = [ 0, 0, 0 ];
                color = color.replace(/ /g, ''); 
                var i = color.indexOf('rgb');
                if (i >= 0) {
                    color = color.substring(i + 4, color.length - 1);
                    rgb = color.split(',');
                }
                return rgb;
            },

            
            rgbStr2hex: function C_rgbStr2hex(color) {
                
                if (color.indexOf('rgb') >= 0) {
                    var rgb = this.rgbStr2rgb(color);
                    return "#" + this.rgb2hex(rgb[0], rgb[1], rgb[2]);
                }
                return color;
            },

            rgb2hex: function C_rgb2hex(r, g, b) {
                return this.toHex(r) + this.toHex(g)
                        + this.toHex(b);
            },

            rgb2hsv: function C_rgb2hsv(r, g, b) {
                var rgb = [ r, g, b ];
                rgb.sort( function(a, b) {
                    return a - b;
                });
        
                var h, s, v = 0;
                var min = rgb[0];
                var max = rgb[2];
        
                v = max / 255.0;
                s = (max != 0) ? (parseFloat(max) - parseFloat(min)) / parseFloat(max)
                        : 0;
        
                if (s == 0) {
                    h = 0;
                } else {
                    var d = max - min;
                    var red = (max - r) / d;
                    var green = (max - g) / d;
                    var blue = (max - b) / d;
        
                    if (r == max)
                        h = blue - green;
                    else if (g == max)
                        h = 2.0 + red - blue;
                    else
                        h = 4.0 + green - red;
        
                    h = h / 6.0;
                    if (h < 0)
                        h = h + 1.0;
                }
        
                return [ Math.round(h * 360), Math.round(s * 100), Math.round(v * 100) ];
            },

            hex2rgb: function C_hex2rgb(s) {
                var color = (s.charAt(0) == '#') ? s.substr(1) : s;
                var l = color.length !== 3;
                var rgb = [ 0, 0, 0 ];
                if (l) {
                    rgb[0] = (this.toDec(color.substr(0, 1)) * 16)
                            + (this.toDec(color.substr(1, 1)));
                    rgb[1] = (this.toDec(color.substr(2, 1)) * 16)
                            + (this.toDec(color.substr(3, 1)));
                    rgb[2] = (this.toDec(color.substr(4, 1)) * 16)
                            + (this.toDec(color.substr(5, 1)));
                } else {
                    rgb[0] = (this.toDec(color.substr(0, 1)) * 16)
        	            + (this.toDec(color.substr(0, 1)));
                    rgb[1] = (this.toDec(color.substr(1, 1)) * 16)
                	    + (this.toDec(color.substr(1, 1)));
                    rgb[2] = (this.toDec(color.substr(2, 1)) * 16)
        		    + (this.toDec(color.substr(2, 1)));
	     }        
                return rgb;
            },

            hex2hsv: function (s) {
                var rgb = this.hex2rgb(s);
                return this.rgb2hsv(rgb[0], rgb[1], rgb[2]);
            },

            hsv2rgb: function (h, s, v) {
                h = h / 360;
                s = s / 100;
                v = v / 100;
        
                var r, g, b;
                if (s == 0) {
                    r = v * 255;
                    g = v * 255;
                    b = v * 255;
                } else {
                    var th = h * 6;
                    if (th == 6)
                        th = 0;
        
                    var i = Math.floor(th);
                    var p = v * (1 - s);
                    var q = v * (1 - s * (th - i));
                    var t = v * (1 - s * (1 - (th - i)));
        
                    var tr, tg, tb;
        
                    switch (i) {
                    case 0:
                        tr = v;
                        tg = t;
                        tb = p;
                        break;
        
                    case 1:
                        tr = q;
                        tg = v;
                        tb = p;
                        break;
        
                    case 2:
                        tr = p;
                        tg = v;
                        tb = t;
                        break;
        
                    case 3:
                        tr = p;
                        tg = q;
                        tb = v;
                        break;
        
                    case 4:
                        tr = t;
                        tg = p;
                        tb = v;
                        break;
        
                    default:
                        tr = v;
                        tg = p;
                        tb = q;
                        break;
                    }
        
                    r = tr * 255;
                    g = tg * 255;
                    b = tb * 255;
                }
                return [ Math.round(r), Math.round(g), Math.round(b) ];
        
            },

            hsv2hex: function (h, s, v) {
                var rgb = this.hsv2rgb(h, s, v);
                return this.rgb2hex(rgb[0], rgb[1], rgb[2]);
            },
            
            getContrastingColor : function C_getContrastingColor(hex, colors) {
                var rgb = this.hex2rgb(hex);
                return (((rgb[0] * 299) + (rgb[1] * 587) + (rgb[2] * 114)) / 1000 < 125) ? colors[0] : colors[1];
            },
            
            getHighlightColor: function C_getHighlightColor(rgb, moreDim) {
                var r, g, b, luminosity,
                    refRGB = this.hex2rgb(!moreDim ? '#FFCE7F' : '#EFE6D8'),
                    R1 = parseInt(rgb[0], 10),
                    G1 = parseInt(rgb[1], 10),
                    B1 = parseInt(rgb[2], 10),
                    R2 = parseInt(refRGB[0], 10),
                    G2 = parseInt(refRGB[1], 10),
                    B2 = parseInt(refRGB[2], 10);
                
                    r = (R1 * R2) / 255;
                    g = (G1 * G2) / 255;
                    b = (B1 * B2) / 255;
                    
                    luminosity = R1 * 0.3 + G1 * 0.59 + B1 * 0.11;
                    if (luminosity < 85) {
                        r = r + (63 * (85 - luminosity) / 85); 
                        r = r > 255 ? 255 : r;
                        g = g + (63 * (85 - luminosity) / 85); 
                        g = g > 255 ? 255 : g;
                        b = b + (63 * (85 - luminosity) / 85); 
                        b = b > 255 ? 255 : b;
                    }

                return "#" + this.rgb2hex(Math.round(r), Math.round(g), Math.round(b));
            },
            
            
            get3DBorderColor: function C_get3DBorderColor(bgRGB, stroke) {
                var lum = parseInt(bgRGB[0],10) * 0.3 + parseInt(bgRGB[1],10) * 0.59
                    + parseInt(bgRGB[2],10) * 0.11;

                var r = parseInt(bgRGB[0],10);
                var g = parseInt(bgRGB[1],10);
                var b = parseInt(bgRGB[2],10);

                switch (stroke) {
                case 'light': 
                    if (lum > 150) {
                        r = r * 0.9;
                        g = g * 0.9;
                        b = b * 0.9;
                    } else {
                        r = r * 0.6 + 102;
                        g = g * 0.6 + 102;
                        b = b * 0.6 + 102;
                    }
                    break;
                case 'dark': 
                    if (lum > 10) {
                        r = r * 0.4;
                        g = g * 0.4;
                        b = b * 0.4;
                    } else {
                        r = r * 0.8 + 30;
                        g = g * 0.8 + 30;
                        b = b * 0.8 + 30;
                    }
                }

                return "#" + this.rgb2hex(Math.round(r), Math.round(g), Math.round(b));
            },
            
            
            
            encodeColor: function (v, d) { 
                    if (d != undefined && (v == null || v.length == 0 || v == 'undefined')) {
                        v = d;
                    }
                    if (v == 'transparent') {
                        return -1;
                    } else if (v == -2) {
                        return -2;
                    } else {
                        
                        if (v.substring(0,1) == '#') {
                            v = v.substring(1);
                        }
                        
                        
                        return parseInt(v.substring(4) + v.substring(2,4) + v.substring(0,2), 16); 
                    }
            },
            
            
            decodeColor: function(vbColor) {
                var color = parseInt(vbColor, 10);
                
                if (color == 0) {
                    return  DEFAULT_COLOR;
                } 

                
                var rgb = 0x1000000 + (color & 0xff) * 0x10000 + (color & 0xff00) + (color & 0xff0000) / 0x10000;
                
                
                return '#' + rgb.toString(16).substring(1).toUpperCase();
            }
            
        }
    ); 

 })();
(function(){
    
    mstrmojo.func = mstrmojo.provide(
            
        "mstrmojo.func",
       
        {
            
            composite: function c(fn) {
                
                if (!fn || !fn.length) {
                    
                    return function(){};
                }
        
                return function() {
                    for (var i = 0, len = fn.length; i < len; i++) {
                        fn[i].apply(this, arguments);
                    }
                };
           },
           
           
           wrapMethods: function wrapMethods(source, destination) {
               
               destination = destination || {};

               
               
               mstrmojo.hash.forEach(source, function(fn, fnName) {
                   destination[fnName] = (fnName in destination && typeof(fn) == 'function') ? mstrmojo.func.composite( [ fn, destination[fnName] ]) : fn;
               });
               
               return destination;
           }, 
           
           addMethods: function addMethods(source, destination) {
               
               destination = destination || {};

               
               
               mstrmojo.hash.forEach(source, function(fn, fnName) {
                   if ( ! (fnName in destination) && typeof(fn) == 'function') {
                       destination[fnName] = fn;
                   }
               });
               
               return destination;
           }           
           
        });
})();

mstrmojo.EnumRWUnitType = {
	LAYOUT: 0,			
	HEADER: 2,
	FOOTER: 3,
	SUBSECTION: 4,		
	DETAILS: 5,
	PAGEHEADER: 6,
	PAGEFOOTER: 7,
	PANELSTACK: 8,
	PANEL: 9,

    
    
	GRID: 521,
	GRAPH: 522,
	GRIDGRAPH: 527,
    
	RECTANGLE: 101,
	IMAGE: 102,
	LINE: 105,
	TEXTFIELD: 106,
	HTMLCONTAINER: 107,
	SELECTOR: 111,
    ROUNDEDRECTANGLE: 112,
	VISUALIZATION: 114,
	MOJOVISUALIZATION: 115
};
(function() {
    
    
    mstrmojo._IsSelectorTarget = 
        
        {
            _mixinName: 'mstrmojo._IsSelectorTarget', 
            
            
            setDirty: function setDirty(isDirty) {
                
                var mth = ((isDirty) ? 'add' : 'remove') + 'DirtyKey';
                if (this.parent && this.parent[mth]) {
                    this.parent[mth](this.k);
                }
            }
                
        };
    
})();
(function(){

    
    mstrmojo.all = {};
    
    var _A = mstrmojo.all;
    
    
    var _freeIdCounter = 0;

    
    function _freeId() {
        for (;_freeIdCounter++;) {
            if (!_A["mstr" + _freeIdCounter]) {
                break;
            }
        }
        return "mstr" + _freeIdCounter;
    }
    
    
    mstrmojo.registry = mstrmojo.provide(
    "mstrmojo.registry",
    
    {
        
        add: function add(obj) {
            if (!obj) {
                return;
            }
            
            var id = obj.id;
            if (id == null) {   
                id = _freeId();
                obj.id = id;
            } else if (_A[id]) {
                throw new Error("Tried to register 2 objects with same id: " + id);
            }
            _A[id] = obj;
        },
        
        
        remove: function rmv(obj) {
            if (obj && obj.id != null) {    
                delete _A[obj.id];
            }
        },

        
                
        dumpAll: function() {
            for(var o in _A ) {
                if ( _A[o].id != null ) {
                    mstrmojo.dbg(_A[o].id + "(" + (_A[o].scriptClass || "[unknown class]") + ")");
                } 
            }
        },
                        
        
        ref: function ref(config, flags){
            if (!config) {
                return null;
            }
            if (!flags) {
                flags = {};
            }
            var C = config;
            while(C) {
                switch(typeof(C)) {
                    case "string":
                        
                        if (flags.skipLoadChecks !== true) {
                            mstrmojo.requiresCls(config);
                        }
                        C = eval(C);
                        break;
                    case "function":                        
                        
                        return (flags.dontInst !== true) ? new C() : C;
                    case "object":
                        if (C.constructor === Object) {
                            
                            var sc = C.scriptClass;
                            if (sc) {
                                
                                if (flags.skipLoadChecks !== true) {
                                    mstrmojo.requiresCls(sc);
                                }
                                var cls = eval(sc);
                                if (cls) {
                                    
                                    return new cls((flags.clone === true) ? 
                                                    mstrmojo.hash.clone(C) : 
                                                    C);
                                }
                                
                                return null;
                            } else {
                                
                                return C;
                            }
                        } else {
                            
                            return C;
                        }
                        break;
                    default:
                        return null;
                }
            }
        }
    });

    
    mstrmojo.insert = mstrmojo.registry.ref;
    
})();


mstrmojo.mstr.EnumWebFunctionType = {

    
    WebFunctionTypeReserved: 0,

    
    WebFunctionTypeGeneric: 1,

    
    WebFunctionTypeRankQual: 2,

    
    WebFunctionTypePercentQual: 3
};


(function(){
    
    
    mstrmojo.url = mstrmojo.provide(
    "mstrmojo.url", 
    {
        
        isAbsoluteURL: function(url) {
            return /^(http|https|ftp|file):\/\//i.test(url);
        },    
        
        
        getAbsoluteURL: function(url, baseUrl) {
            if(this.isAbsoluteURL(url)) {
                return url;
            } else {
                if(baseUrl) {
                    return baseUrl + (/\/$/.test(baseUrl) ? '' : '/') + url;
                } else {
                    return 'http://' + url;
                }
            }
        }
    });
})();

mstrmojo.mstr.EnumNodeType = {

    
    NodeReserved: 0,

    
    NodeFormShortcut: 1,

    
    NodeElementsObject: 2,

    
    NodeConstant: 3,

    
    NodeOperator: 4,

    
    NodeShortcut: 5,

    
    NodeTime: 6,

    
    NodeRelationship: 7,

    
    NodeResidue: 8,

    
    NodeMe: 9,

    
    NodeBigDecimal: 10,

    
    NodeGroup: 14,

    
    NodeRef: 15
};

mstrmojo.DPIManager = {

    
    classes: [],

    
    registerClass: function registerClass(clz, dimension, slot, dpiValues) {
        
        this.classes.push({
            c: clz,
            d: dimension,
            s: slot,
            v: dpiValues
        });
    },

    
    setDPI: function () {
        
        var dpi = mstrMobileApp.getDeviceDPI();

        
        mstrmojo.array.forEach(this.classes, function (clz) {
            
            clz.c.prototype.layoutConfig[clz.d][clz.s] = clz.v[dpi] + 'px';
        });

        
        this.classes = [];
    }
};

(function () {

    
    function calcChildDimension(child, dimension, onlyPercentageSlots) {
        var dim = this._layoutWidgets[dimension],
            slot = child.slot,
            fixedSlots = dim.f,
            percentageSlots = dim.p,
            isFixed = (fixedSlots && fixedSlots[slot] !== undefined),
            isPercent = (percentageSlots && percentageSlots[slot] !== undefined);

        
        if (slot && ((!onlyPercentageSlots && isFixed) || isPercent)) {
            
            return isFixed ? fixedSlots[slot] : (dim.x * parseInt(percentageSlots[slot], 10) / 100) + 'px';
        }

        return child[(dimension === 'h') ? 'height' : 'width'];
    }

    
    function applyChildDimensions(child, h, w) {
        
        if (child.ignoreLayout) {
            
            return;
        }

        
        if (child.setDimensions) {
            
            child.setDimensions(h, w);
        } else {
            
            if (child.set) {
                child.set('height', h);
                child.set('width', w);
            }
        }
    }

    
    function applyDimensions(onlyPercentageSlots) {
        var ch = this.children,
            i,
            len;

        
        for (i = 0, len = (ch && ch.length) || 0; i < len; i++) {
            var child = ch[i],
                slot = child.slot;

            
            if (slot) {
                
                var h = calcChildDimension.call(this, child, 'h', onlyPercentageSlots),
                    w = calcChildDimension.call(this, child, 'w', onlyPercentageSlots);

                
                this.setSlotDimensions(slot, h, w);

                
                applyChildDimensions(child, h, w);

                
                var zh = calcChildDimension.call(this, child, 'h', onlyPercentageSlots),
                    zw = calcChildDimension.call(this, child, 'w', onlyPercentageSlots);

                
                if (zh !== h || zw !== w) {
                    
                    applyChildDimensions(child, zh, zw);
                }

                
                this.setSlotDimensions(slot, zh, zw);
            }
        }

        
        this.afterLayout();
    }

    
    function adjustDimension(child, lw, d) {
        
        var slot = child.slot,
            autoSlots = lw && lw.a;

        
        if (!autoSlots || autoSlots[slot] === undefined) {
            
            return;
        }

        
        var x = this[slot]['offset' + d],
            size = autoSlots[slot];

        
        if (x === size) {
            
            return;
        }

        
        lw.x -= (x - size);

        
        autoSlots[slot] = x;
    }

    
    function adjustLayout(evt) {
        
        this.beforeLayout();

        var lw = this._layoutWidgets,
            child = evt.src;

        
        adjustDimension.call(this, child, lw.h, 'Height');
        adjustDimension.call(this, child, lw.w, 'Width');

        
        applyDimensions.call(this, true);
    }

    
    function calculateDimension(dimensionConfig, dimension) {
        
        if (!dimensionConfig) {
            
            return null;
        }

        var ch = this.children,
            lcDimension = dimension.toLowerCase(),
            widgetDimensionValue = parseInt(this[lcDimension], 10),                     
            fixedSlots,
            percentageSlots,
            autoSlots,
            autoSlotValues,
            i,
            len,
            child,
            v,
            slot;

        
        for (slot in dimensionConfig) {

            
            v = dimensionConfig[slot];

            
            if (v.match(/px$/)) {
                
                widgetDimensionValue -= parseInt(v, 10);

                
                fixedSlots = fixedSlots || {};
                fixedSlots[slot] = v;

            
            } else if (v.match(/\%$/)) {
                
                percentageSlots = percentageSlots || {};
                percentageSlots[slot] = v;

            
            } else {
                autoSlots = autoSlots || {};
                autoSlots[slot] = v;
            }
        }

        
        if (autoSlots && percentageSlots) {

            
            for (i = 0, len = (ch && ch.length) || 0; i < len; i++) {
                child = ch[i];
                slot = child.slot;

                
                if (child.slot && autoSlots[slot] && !child.ignoreLayout) {

                    autoSlotValues = autoSlotValues || {};

                    
                    if (child.hasRendered) {
                        autoSlotValues[slot] = this[child.slot]['offset' + dimension];

                        
                        widgetDimensionValue -= autoSlotValues[slot];

                    } else {
                        
                        autoSlotValues[slot] = 0;

                        
                        child.attachEventListener((child instanceof mstrmojo.Container) ? 'childrenRendered' : 'renderComplete', this.id, adjustLayout);
                    }
                }
            }
        }

        
        return {
            f: fixedSlots,
            p: percentageSlots,
            a: autoSlotValues,
            x: widgetDimensionValue
        };
    }

    
    mstrmojo._HasLayout =
        
        {
            _mixinName: 'mstrmojo._HasLayout',

            
            height: 'auto',

            
            width: 'auto',

            
            beforeLayout: mstrmojo.emptyFn,

            
            afterLayout: mstrmojo.emptyFn,

            
            layoutConfig: null,

            init: function init(props) {
                this._super(props);

                
                this.layoutConfig = mstrmojo.hash.clone(this.layoutConfig);
            },

            preBuildRendering: function preBuildRendering() {
                var cssText = this.cssText || '';

                var height = this.height;
                if (height && height !== 'auto') {
                    cssText += 'height:' + this.height + ';';
                }

                var width = this.width;
                if (width && width !== 'auto') {
                    cssText += 'width:' + this.width + ';';
                }

                this.cssText = cssText;

                return (this._super) ? this._super() : true;
            },

            postBuildRendering: function postBuildRendering() {
                
                this.doLayout();

                return this._super();
            },

            
            doLayout: function doLayout() {
                
                var lc = this.layoutConfig;
                if (!lc) {
                    return;
                }

                
                this.beforeLayout();

                
                this._layoutWidgets = {
                    h: calculateDimension.call(this, lc.h, 'Height'),
                    w: calculateDimension.call(this, lc.w, 'Width')
                };

                
                applyDimensions.call(this, false);
            },

            
            browserResized: function browserResized(size) {
                this.setDimensions(size.h, size.w);
                return true;
            },

            
            onwidthChange: function widthChg() {
                var dn = this.domNode;
                if (!dn || !this.layoutConfig) {
                    return;
                }

                dn.style.width = this.width;
                this.doLayout();
            },

            
            onheightChange: function heightChg() {
                var dn = this.domNode;
                if (!dn || !this.layoutConfig) {
                    return;
                }

                dn.style.height = this.height;
                this.doLayout();
            },

            
            adjustParentDimensions: function adjustParentDimensions() {
                var p = this.parent,
                    lw = p && p._layoutWidgets;

                
                if (lw) {
                    
                    adjustDimension.call(p, this, lw.h, 'Height');
                    adjustDimension.call(p, this, lw.w, 'Width');
                }
            },

            
            setDimensions: function setDimensions(h, w) {
                if (this.height !== h || this.width !== w) {
                    
                    this.height = h;
                    this.width = w;

                    
                    var dn = this.domNode;
                    if (dn) {
                        dn.style.height = h;
                        dn.style.width = w;

                        
                        this.doLayout();
                    }

                    return true;
                }

                return false;
            },

            
            setSlotDimensions: function setSlotDimensions(slot, h, w) {
                
                var sl = this[slot] && this[slot].style;
                if (!sl) {
                    
                    return;
                }

                
                if (h !== undefined && sl.height !== h) {
                    
                    sl.height = h;
                }

                
                if (w !== undefined && sl.width !== w) {
                    
                    sl.width = w;
                }
            }

        };

    
    mstrmojo._HasLayout.getSlotSize = function getSlotSize(constructor, slot) {
        var layoutCfg = constructor && constructor.prototype.layoutConfig;
        if (layoutCfg) {
            var h = layoutCfg.h,
                w = layoutCfg.w;

            return {
                h: (h && h[slot]) || undefined,
                w: (w && w[slot]) || undefined
            };
        }

        return null;
    };

}());
(function() {
    mstrmojo.BarcodeReader = mstrmojo.provide(
        'mstrmojo.BarcodeReader',
        {
            
            _callback: null,
            _callbackId: 0,
            
            
            readBarcodes: function readBarcodes(params, callback, name, selectedPrompts, displayKeypadView) {
                this._callbackId++;
                var id = '' + this._callbackId;
                this._callback = callback;
                var callbackStr = 'mstrmojo.BarcodeReader.onBarcodeResult';
                if ( params ) {
                    params.blockBegin = 0;
                    params.blockCount = -1;
                    params.serverUrl = mstrApp.getConfiguration().getTaskUrlByProject(mstrApp.getCurrentProjectId());
                    params.sessionState = mstrApp.getSessionState();
                }
               
                mstrMobileApp.readBarcodes(id, name, (params && JSON.stringify(params)) || null, (selectedPrompts && JSON.stringify(selectedPrompts)) || null, displayKeypadView || null, callbackStr);
            },
            
            onBarcodeResult: function onBarcodeResult(id, resCode, value) {
                
                var callback = this._callback;
                if ( id != this._callbackId || (! callback)) {
                    return;
                }
                delete this._callback;
                if ( resCode == -1 ) { 
                    callback.success(value);
                } else if ( resCode != 0 ) {
                    callback.failure(value || 'Error reading bare code.');
                }
            }
        }
    );
    

})();
mstrmojo.DynamicClassFactory = {
	newComponent: function (comp, mixins, props) {
        var name = comp.prototype.scriptClass.replace(/^mstrmojo./, ''); 
        for (var i = 0, cnt = mixins && mixins.length || 0; i < cnt; i++) {
        	if (!mixins[i]._mixinName){
        		alert("Need mixin have '_mixinName' to be used in DynamicClassFactory");
        		return null;
        	}
        	name += '_' + mixins[i]._mixinName.replace(/^mstrmojo./, ''); 
        }

        var f = mstrmojo[name];
        if (!f) {
             f = mstrmojo.declare(comp, mixins, props);
             mstrmojo[name] = f;
        }
        return f;
    }
};

(function () {

    
    function itemSelected(item, isExecute) {
        
        var subType = item.st;
        if (!subType || subType === 2048 || subType === 'Project') {
            
            this.openFolder(item);

        } else {
            
            if (isExecute || !mstrApp.isTablet() || this.orientation) {
                
                this.openItem(item);

            } else {
                
                this.rootCtrl.updateItemProperties('', item, this.id, this.isItemAvail(item));

            }
        }
    }

    
    mstrmojo.android.controllers._HasFolderView = mstrmojo.provide(

        'mstrmojo.android.controllers._HasFolderView',

        
        {

            _mixinName: 'mstrmojo.android.controllers._HasFolderView',
            
            start: function start(params) {
                this._super(params);
                
                var publisher = mstrmojo.publisher,
                	id = this.id;
                
                
                mstrmojo.array.forEach([ publisher.CONNECTIVITY_CHANGED_EVENT, publisher.RECONCILE_END_EVENT], function (evt) {
                    publisher.subscribe(publisher.NO_SRC, evt, function () {
                    	var view = this.view;
                        if (view.hasRendered) {
    	                    
    	                    view.refresh();
                        }
                    }, id);                	
                });
             },

            
            initFolderView: function initFolderView() {
                var view = this.view = this.newView('Folder', {
                    cssClass: 'folder-browser',
                    multiSelect: false,
                    hasEvenRows: !mstrApp.isTablet() || !this.orientation,                 
                    postselectionChange: function (evt) {
                        
                        var added = evt.added;
                        if (added) {
                            
                            itemSelected.call(this.controller, this.items[added[0]]);
                        }
                    }
                });

                return view;
            },

            
            

            
            

            
            executeItem: function executeItem(item) {
                
                var nextController = this.nextController;
                if (nextController) {
                    
                    nextController.destroy();

                    
                    this.rootCtrl.updateFolder(this.view);
                }

                
                if (mstrApp.isTablet() && !this.orientation) {
                    
                    itemSelected.call(this, item, true);

                } else {
                    
                    this.view.singleSelect(item._renderIdx);

                }
            },

            onorientationChange: function onorientationChange() {
                this._super();

                
                var view = this.view;
                if (view && mstrApp.isTablet()) {

                    
                    view.set('hasEvenRows', !this.orientation);

                    
                    if (view.hasRendered && view.domNode && view.domNode.parentNode) {
                        
                        var cfg = view.scrollerConfig;
                        if (cfg && cfg.origin) {
                            
                            cfg.offsetIdx = view.getOffsetIndex();

                            
                            cfg.origin.y = 0;

                            
                            view.updateScroller();
                        }

                        
                        this.syncItemProperties();
                    }
                }
            },

            
            syncItemProperties: function syncItemProperties() {
                
                if (mstrApp.isTablet() && !this.orientation) {
                    var view = this.view,
                        item = view && view.getSelectedItems && view.getSelectedItems()[0];

                    
                    if (item) {
                        
                        this.rootCtrl.updateItemProperties('', item, this.id, this.isItemAvail(item));
                    } else {
                        
                        this.updatePropertiesMsg();
                    }
                }
            },

            
            getDefaultMessage: function getDefaultMessage() {
                return '';
            },

            
            updatePropertiesMsg: function updatePropertiesMsg() {
                
                var view = this.view;
                this.rootCtrl.updateItemProperties(this.getDefaultMessage(view && view.items));
            },

            canItemLinger: function canItemLinger(item) {
                
                if (!mstrApp.isTablet()) {
                    
                    return true;
                }

                
                var subType = item.st;
                if (subType === 2048 || subType === 'Project' ||  this.orientation) {
                    
                    return true;
                }

                
                return false;
            },

            
            itemLongPressed: function itemLongPressed(item) {
                
                var id = this.id;
                if (!mstrApp.isTablet() || this.orientation) {
                    
                    this.rootCtrl.updateItemProperties('', item, id, this.isItemAvail(item));

                    
                    return true;
                }

                
                return false;
            },

            
            isItemAvail: function isItemAvail(item, skipCacheCheck) {
                
                if (mstrMobileApp.isOnline() || item.act === 5 || item.act === 3) {
                    
                    return true;
                }

                
                if (item.t === 8 && (item.st === 'Project' || item.systemFolder)) {
                    
                    var project = mstrApp.getConfiguration().getProject(item.did);
                    return !!(project && project.realPid);
                }

                
                return skipCacheCheck ? false : this.isItemCached(item);
            },

            
            isItemCached: function isItemCached(item) {
                var itemType = item.t,
                    itemSubtype = item.st;

                
                if (!(itemType === 3 || itemType === 55 || itemSubtype === 2048 ||  itemSubtype === 'Project')) {
                    return false;
                }

                
                if (itemSubtype === 2048 && mstrMobileApp.isOnline()) {
                    return true;
                }

                
                
                var itemPid = item.pid || item.projectID;
                if (!itemPid) {
                    var project = mstrApp.getConfiguration().getProject(mstrApp.getCurrentProjectId());
                    itemPid = project && project.realPid;
                }
                return !!(itemPid && mstrMobileApp.isCached(itemPid, item.sub_id || item.did, (item.sub_id) ? -1 : itemSubtype));
            }
        }
    );
}());

mstrmojo.mstr.EnumFunction = {

    
   FunctionCustom: -1,

    
   FunctionReserved: 0,

    
   FunctionPlus: 1,

    
   FunctionMinus: 2,

    
   FunctionTimes: 3,

    
   FunctionDivide: 4,

    
   FunctionUnaryMinus: 5,

    
   FunctionEquals: 6,

    
   FunctionNotEqual: 7,

    
   FunctionGreater: 8,

    
   FunctionLess: 9,

    
   FunctionGreaterEqual: 10,

    
   FunctionLessEqual: 11,

    
   FunctionSum: 12,

    
   FunctionCount: 13,

    
   FunctionAvg: 14,

    
   FunctionMin: 15,

    
   FunctionMax: 16,

    
   FunctionBetween: 17,

    
   FunctionLike: 18,

    
   FunctionAnd: 19,

    
   FunctionOr: 20,

    
   FunctionNot: 21,

    
   FunctionIn: 22,

    
   FunctionRank: 23,

    
   FunctionAbs: 24,

    
   FunctionRunningSum: 25,

    
   FunctionRunningAvg: 26,

    
   FunctionMovingSum: 28,

    
   FunctionMovingAvg: 27,

    
   FunctionProduct: 29,

    
   FunctionMedian: 30,

    
   FunctionMode: 31,

    
   FunctionStdev: 32,

    
   FunctionVar: 33,

    
   FunctionGeomean: 34,

    
   FunctionEqualEnhanced: 35,

    
   FunctionNotEqualEnhanced: 36,

    
   FunctionGreaterEqualEnhanced: 37,

    
   FunctionLessEqualEnhanced: 38,

    
   FunctionBetweenEnhanced: 39,

    
   FunctionBanding: 40,

    
   FunctionBandingC: 41,

    
   FunctionBandingP: 42,

    
   FunctionNotLike: 43,

    
   FunctionNotBetween: 44,

    
   FunctionIntersect: 45,

    
   FunctionIntersectIn: 46,

    
   FunctionNullToZero: 47,

    
   FunctionZeroToNull: 48,

    
   FunctionApplySimple: 49,

    
   FunctionApplyAggregation: 50,

    
   FunctionApplyLogic: 51,

    
   FunctionApplyComparison: 52,

    
   FunctionApplyRelative: 53,

    
   FunctionIsNull: 54,

    
   FunctionIsNotNull: 55,

    
   FunctionUcase: 56,

    
   FunctionNotIn: 57,

    
   FunctionNTile: 58,

    
   FunctionPercentile: 59,

    
   FunctionMovingMax: 60,

    
   FunctionMovingMin: 61,

    
   FunctionMovingDifference: 62,

    
   FunctionMovingStdev: 63,

    
   FunctionExpWghMovingAvg: 64,

    
   FunctionMovingCount: 65,

    
   FunctionRunningMax: 66,

    
   FunctionRunningMin: 67,

    
   FunctionRunningStdev: 68,

    
   FunctionRunningCount: 69,

    
   FunctionExpWghRunningAvg: 70,

    
   FunctionNotBetweenEnhanced: 71,

    
   FunctionConcat: 72,

    
   FunctionFirstInRange: 73,

    
   FunctionLastInRange: 74,

    
   FunctionValueSegment: 75,

    
   FunctionContains: 76,

    
   FunctionBeginsWith: 77,

    
   FunctionEndsWith: 78,

    
   FunctionNotContains: 79,

    
   FunctionNotBeginsWith: 80,

    
   FunctionNotEndsWith: 81,

    
   FunctionCase: 82,

    
   FunctionCaseV: 83,

    
   FunctionStdevP: 84,

    
   FunctionRunningStdevP: 85,

    
   FunctionMovingStdevP: 86,

    
   FunctionNTileS: 87,

    
   FunctionNTileVS: 88,

    
   FunctionVarP: 89,

    
   FunctionCurrentDate: 90,

    
   FunctionDayOfMonth: 91,

    
   FunctionDayOfWeek: 92,

    
   FunctionDayOfYear: 93,

    
   FunctionWeek: 94,

    
   FunctionMonth: 95,

    
   FunctionQuarter: 96,

    
   FunctionYear: 97,

    
   FunctionCurrentDateTime: 98,

    
   FunctionCurrentTime: 99,

    
   FunctionHour: 100,

    
   FunctionMinute: 101,

    
   FunctionSecond: 102,

    
   FunctionMilliSecond: 103,

    
   FunctionConcatNoBlank: 104,

    
   FunctionLength: 105,

    
   FunctionLower: 106,

    
   FunctionLTrim: 107,

    
   FunctionPosition: 108,

    
   FunctionRTrim: 109,

    
   FunctionSubStr: 110,

    
   FunctionInitCap: 111,

    
   FunctionTrim: 112,

    
   FunctionRightStr: 113,

    
   FunctionLeftStr: 114,

    
   FunctionGreatest: 115,

    
   FunctionLeast: 116,

    
   FunctionAdd: 134,

    
   FunctionAverage: 135,

    
   FunctionMultiply: 136,

    
   FunctionBandingM: 137,

   FunctionReservedLastOne: 138,

    
   FunctionTuple: 1000
};


mstrmojo.mstr.EnumExpressionType = {
    ExpressionReserved: 0,

    
    ExpressionGeneric: 1,

    
    FilterSingleBaseFormQual: 2,

    
    FilterMultiBaseFormQual: 3,

    
    FilterJointFormQual: 4,

    
    FilterListQual: 5,

    
    FilterListFormQual: 6,

    
    FilterJointListQual: 7,

    
    FilterJointListFormQual: 8,

    
    FilterSingleBaseFormExpression: 9,

    
    FilterSingleMetricQual: 10,

    
    FilterMultiMetricQual: 11,

    
    FilterMetricExpression: 12,

    
    FilterEmbedQual: 13,

    
    FilterBranchQual: 14,

    
    FilterRelationshipQual: 15,

    
    FilterAllAttributeQual: 16,

    
    FilterAttributeIDQual: 17,

    
    FilterAttributeDESCQual: 18,

    
    ExpressionAggMetric: 19,

    
    ExpressionBanding: 20,

    
    FilterReportQual: 21,

    
    ExpressionMDXSAPVariable: 22,

    
    ExpressionSQLQueryQual: 23, 

    
    ExpressionCanceledPrompt: 24, 

    
    ExpressionElementList: 25, 

    
    ExpressionElementSingle: 26 

};

(function () {

    
    mstrmojo.android._HasLingeringListSelections = mstrmojo.provide(

        "mstrmojo.android._HasLingeringListSelections",

        
        {
            _mixinName: 'mstrmojo.android._HasLingeringListSelections',

            
            selectionPolicy: 'reselect',

            
            noLinger: false,

            
            canItemLinger: function canItemLinger(item) {
                return true;
            },

            
            setClearHandler: function setClearHandler(delay) {
                
                if (this.noLinger) {
                    
                    return;
                }
                
                var idx = this.selectedIndex,
                    id = this.id;

                
                if (idx > -1 && this.canItemLinger(this.items[idx])) {
                    
                    this._clearHandler = window.setTimeout(function () {
                        var list = mstrmojo.all[id];

                        
                        if (list) {
                            
                            if (list.selectedIndex === idx) {
                                
                                list.clearSelect();
                            }
                            
                            delete list._clearHandler;
                        }

                    }, delay);
                }
            },

            
            postBuildRendering: function postBuildRendering() {
                this._super();

                
                this.setClearHandler(800);
            },

            
            preselectionChange: function preselectionChange(evt) {
                
                var selectionHandler = this._clearHandler;
                if (selectionHandler) {
                    
                    window.clearTimeout(selectionHandler);

                    
                    delete this._clearHandler;
                }
            }
        }
    );
}());
mstrmojo.EnumReadystate = {
    IDLE: 1,
    WAITING: 3,
    ERROR: 4,
    SUCCESS: 5,
    CANCELLED: 6,
    TIMEOUT: 7
};
mstrmojo._ShowsStatus = mstrmojo.provide(
"mstrmojo._ShowsStatus",
{
    
    showStatus: function shwSts( show,  txt,  perc) {
        
        var el = this._STATUS;
        
        if (!this.hasRendered || !el) {
            return;
        }
        
        if (!show) {
            
            if (this.showingStatus) {
                el.style.display = 'none';
            }
        } else {
            if (el) {
                
                var zz = this._STATUS_TXT && (this._STATUS_TXT.innerHTML = txt || '');

                
                zz = this._STATUS_BAR && (this._STATUS_BAR.style.width = (perc || 0) + '%');
                
                
                if(!this.isStatusBarPositioned) {
                    el.style.top = Math.max((this.scrollboxHeight || 0) - 50, 12) + 'px';
                    this.isStatusBarPositioned = true;
                }

                if (!this.showingStatus) {
                    el.style.display = 'block';
                }
                
            }
        }
        
        this.showingStatus = show;
    },
    
     updateStatus: function updSts( txt,  perc) {
        this.showStatus(this.showingStatus, txt, perc);
    }
});

(function(){


	mstrmojo._IsGraphDataService = mstrmojo.provide(
			"mstrmojo._IsGraphDataService",

			
			{
				handleUserSingleTap: function handleUserSingleTap(sliceID, nodekey, x, y, selectable, callback) {
					if(mstrApp.onMobileDevice()) {
						mstrApp.serverRequest({
							taskId: 'handleUserSingleTap',
							sliceID: sliceID,
							nodekey: nodekey,
							x: x,
							y: y,
							selectable: selectable
						}, callback);
					}
				}

			});
}());

 
mstrmojo.mstr.EnumWebAPIErrorCodes = {
    	MSI_INBOX_MSG_NOT_FOUND:                    -2147468986, 
		E_MSI_USERMGR_USER_NOTFOUND:                -2147209051, 
		AUTHEN_E_LOGIN_FAIL_EXPIRED_PWD:            -2147216963, 
		AUTHEN_E_LOGIN_FAILED_NEW_PASSWORD_REQD:    -2147216960, 
		AUTHEN_E_LOGIN_FAIL:						-2147216959, 

		
		E_UNUSED: 0xFFFFFFFF
};
mstrmojo.android.EnumMenuOptions = mstrmojo.provide(
    "mstrmojo.android.EnumMenuOptions",

    {
        
        HOME: 1,
        SETTINGS: 2,
        HELP: 4,
        LEARN: 8,

        ALL: 255,    

        

        
        
        
        REFRESH:               0x0100,
        FULL_SCREEN:           0x0200,
        GROUP_BY:              0x0300,
        PAGE_BY:               0x0400,
        REPROMPT:              0x0500,
        DELETE:                0x0600,
        SEARCH:                0x0700,
        SCAN:                  0x0800,
        MAP_ROADMAP:           0x0900,
        MAP_SAT:               0x0A00,
        MAP_HYBRID:            0x0B00,
        MAP_TERRAIN:           0x0C00,
        DOC_LAYOUTS:           0x0D00,
        TRANSACTIONS_QUEUE:    0x0E00,
        ADD_SERVER:            0x0F00,
        ADD_PROJECT:           0x1000,
        ABOUT:                 0x1100,
        SHARE:                 0x1200,
        ABOUT_RESULTSET:       0x1300,
        ANNOTATION:			   0x1400
    }
);


mstrmojo.LoadedExternalJSURLs = {};

function LoadScriptsExternalJSCallback()
{
	
    
    mstrmojo.LoadedExternalJSURLs[mstrmojo._LoadsScript.esScripts.splice(0, 1)[0].url] = true;
	
	mstrmojo._LoadsScript.requiresExternalScripts(mstrmojo._LoadsScript.esScripts,
                                                  mstrmojo._LoadsScript.callback,
												  mstrmojo._LoadsScript.esScritsContext
												  );
    
	mstrmojo._LoadsScript.ExternalJSCallbackIsBusy = false;
}

mstrmojo._LoadsScript = mstrmojo.provide(
"mstrmojo._LoadsScript",

{
    
    _meta_usesSuper: false,

	
	requiresMethod: function rqMth( n) {
		if (!n) {
            return;
        }
		
		
		if (typeof(this[n]) === "function") {
            return true;
        } else {
			
			var fqcn = this[n] || (this.methods && (this.methods[n] || this.methods["*"]));
			if (typeof(fqcn) === "string") {
				this.requiresCls(fqcn);	
				return typeof(this[n]) === "function";
			}
			return false;					
		}
	},

			
			requiresCls: function req( mixins,  callback) {
				
				if (mixins) {
					if (typeof(mixins) == "string") {
						mixins = [mixins];
					}
					
					mstrmojo.requiresCls.apply(mstrmojo, mixins);
					
					
					var p = this.constructor.prototype,
						pm = p.mixins;
					if (!pm) {
						p.mixins = {};
						pm = p.mixins;
					}
					var mx = mstrmojo.mixin;
					for (var i=0, len=mixins.length; i<len; i++) {
						var fqcn = mixins[i];
						if (!pm[fqcn]) {
							var m = eval(mixins[i]);
							mx(m, p);
							pm[fqcn] = true;
							
							if (m.__onmixin__) {
								m.__onmixin__.apply(this, []);
							}
						}
					}
					if (callback) {
						callback.apply(this, []);						
					}
				}
			},
			
			
			requiresContrib: function reqCb( propName,  bForceStartup) {
				var fqcn = this[propName];
				if (fqcn) {
					var c,
						firstTime = false;
					if (typeof(fqcn) == 'string') {
						c = mstrmojo.registry.ref(fqcn);
						this[propName] = c;
						firstTime = true;
					} else {
						c = fqcn;	
					}
					
					
					if (c && (firstTime || bForceStartup)) {
						c.parent = this;
						if (c.startup) {
							c.startup();
						}
					}
					return c;
				}
				return null;
			},
					
			
             requiresExternalScripts : function requiresES(esScripts, callback, context)
			 {
			 	
			 	if(esScripts && esScripts instanceof Array)
				{
					   if (esScripts.length == 0) { 
						   
						   callback && callback.call(context);
						   
						   return;
					   } 		
				        
							   
					   
					   if(esScripts[0].forceReload && esScripts[0].forceReload == false && mstrmojo.LoadedExternalJSURLs [esScripts[0].url])
					   {
					   	
					   	 esScripts.splice(0, 1); 
					   							 
					   	 return this.requiresExternalScripts(esScripts, callback, context);
					   }
				
					  	var script = document.createElement("script"), isIE = !!document.all;
					  						  	
					  	script.type = "text/javascript";
					  	script.src = esScripts[0].url;
						
						if (!esScripts[0].callbackParamName) {
							if (isIE) {
								
								script.onreadystatechange = function(){
									
									
									if (script.readyState == "loaded" || script.readyState == "complete") {
										script.onreadystatechange = null; 
										
										if (esScripts.length > 1) {
											
											
											mstrmojo.LoadedExternalJSURLs [esScripts.splice(0, 1)[0].url] = true;
											mstrmojo._LoadsScript.requiresExternalScripts(esScripts, callback);
										}
										else 
											if (esScripts.length == 1) {
												
											mstrmojo.LoadedExternalJSURLs [esScripts[0].url] = true;
												
												if (callback) {										
													callback.call(context);
												}
											}
									}
								}
							}
							else { 
								script.onload = function(){
								
									script.onload = null; 
									
									if (esScripts.length > 1) {
										
										 
										mstrmojo.LoadedExternalJSURLs [esScripts.splice(0, 1)[0].url] = true;									
										mstrmojo._LoadsScript.requiresExternalScripts(esScripts, callback);
									}
									else 
										if (esScripts.length == 1) {
												mstrmojo.LoadedExternalJSURLs [esScripts[0].url] = true;
												
												if (callback) {										
													callback.call(context);
												}
											
										}
								}
							}
						} 
						else{
							if(esScripts[0].callbackParamName.length != 0){ 
								
								if(mstrmojo._LoadsScript.ExternalJSCallbackIsBusy &&
								   mstrmojo._LoadsScript.ExternalJSCallbackIsBusy == true)
								{								
									   var that = this;
                                       window.setTimeout(function()
									                     {           
                                                            that.requiresExternalScripts(esScripts, callback, context);
                                                         }
                                                         ,500);
						               return;
								}
								
                                mstrmojo._LoadsScript.ExternalJSCallbackIsBusy = true;
								
								
                                script.src += "&" + esScripts[0].callbackParamName + "=LoadScriptsExternalJSCallback" ;
						        
						
								mstrmojo._LoadsScript.esScripts = esScripts;
								mstrmojo._LoadsScript.callback = callback;
								mstrmojo._LoadsScript.esScritsContext = context;
															 
                            }
						}
						
						document.getElementsByTagName("head")[0].appendChild(script);
				}
			 }

});
(function () {
    
    function _shouldRenderSec(x, y, left, right, top, bottom, orH) {
        if (y > bottom) {
            return false;
        }
        return (!orH) ||
            (x === 0) ||
            
            
            
            ((x < right) && (y >= top - (bottom - top)));
    }

    
    function _shouldRenderSub(ss, x, y, left, right, top, bottom, orH) {
        if (y > bottom) {
            return false;
        }

        
        return (!orH) || ((x < right) && (y >= top - ss.height()));
    }

    
    function _fireRender(w, parent, bBuildCh) {
        
        w.renderMode = "scroll";
        w.render();
        w.numChildrenRendered = 0;
        parent.numChildrenRendered++;

        
        if (bBuildCh && !w.builtChildren) {
            w.buildChildren();
        }
    }

    
    function getScrollBuffer() {
        return this.useScrollBuffer ? this.scrollBuffer : 0;
    }

    
    mstrmojo._CanRenderDocOnScroll = mstrmojo.provide(
        "mstrmojo._CanRenderDocOnScroll",
        {
            _mixinName: 'mstrmojo._CanRenderDocOnScroll',

            
            renderMode: 'scroll',

            
            scrollBuffer: 0,

            
            postBuildRendering: function postBuildRendering() {
                if (this.renderMode === null) {
                    return this._super();
                } else {
                    this.renderChildren();
                    return true;
                }
            },

            
            childRenderOnAddCheck: function (children) {
                if (this.renderMode === null) {
                    return this._super(children);
                } else {
                    return false;
                }
            },

            
            renderChildren: function renderChildren() {

                var own;

                if (this.renderMode === "scroll") {
                    
                    
                    var anc = this;
                    while (anc) {
                        if (anc.scrollboxNode && (anc.scrollboxWidthFixed || anc.scrollboxHeightFixed) && anc.connectScrollbox) {
                            own = anc;
                            break;
                        }
                        anc = anc.parent;
                    }
                }

                
                
                if ((this.renderMode !== "scroll") || !own) {
                    this._super();
                    return;
                }

                if (this.containerNode) {
                    
                    
                    this.scrollboxOwner = own;
                    own.connectScrollbox(this);

                    
                    this.numChildrenRendered = 0;
                    var len = this.numChildren;
                    if (len === undefined) {
                        
                        this.numChildren = len = this._getModelChildNodes(this.node, false, 0, 0, true).total;
                    }

                    
                    
                    this.sectionsToRender = len;
                    this.subsectionsToRender = 0;

                    
                    if (len) {
                        this._startSubsectionThread(false);
                    }
                }
                if (this.resizeOrReposition) {
                    this.resizeOrReposition();
                }
            },

            
            onscroll: function onscroll() {
                if (!this.renderingSubsections) {
                    
                    this.useScrollBuffer = true;

                    this._startSubsectionThread(true);
                }
            },

            
            _startSubsectionThread: function _stSbsThd( bPauseBeforeCtls) {
                
                var me = this;

                
                var fnClearIntv = function (n, bIsTimeout) {
                    if (me[n]) {
                        if (bIsTimeout) {
                            self.clearTimeout(me[n]);
                        } else {
                            self.clearInterval(me[n]);
                        }
                        delete me[n];
                    }
                };

                
                
                var fnCleanUp = function ( bPause) {
                    me.renderingSubsections = false;
                    var fn = function () {
                            fnClearIntv('renderCtlsTimer');
                            me.showRenderStatus(false);
                            me.renderCtrlsInViewport();
                            
                            
                            me.raiseEvent({name: 'afterScroll'});
                            me = null;
                        };
                    if (bPause) {
                        me.renderCtlsTimer = self.setTimeout(
                            fn,
                            me.scrollboxOwner.scrollInterval + 1
                        );
                    } else {
                        fn();
                    }
                };

                
                fnClearIntv('renderSubsTimer');
                fnClearIntv('renderCtlsTimer', true);

                this.renderingSubsections = true;

                
                
                if ((this.sectionsToRender || this.subsectionsToRender) && !this._renderSubsectionsToScroll()) {
                    this.showRenderStatus(true);
                    this.renderSubsTimer = self.setInterval(
                        function () {
                            if (me._renderSubsectionsToScroll()) {
                                fnClearIntv('renderSubsTimer');
                                fnCleanUp(bPauseBeforeCtls);
                            } else {
                                me.showRenderStatus(true);
                            }
                        },
                        this.scrollboxOwner.scrollInterval
                    );
                } else {

                    fnCleanUp(bPauseBeforeCtls);
                }
            },

            
            showRenderStatus: function shwRndrSts(show, msg) {
                var p = this.parent;
                if (!p || !p.showStatus) {
                    return;
                }

                var txt = msg,
                    per;
                if (show) {
                    
                    var num = this.numChildrenRendered,
                        tot = this.numChildren;

                    per = tot && parseInt(100 * num / tot, 10);
                    txt = "*Rendering section " + num + " of " + tot + ".*";    
                }
                p.showStatus(show, txt, per);
            },

            
            _renderSubsectionsToScroll: function rndSubs2Scll() {
                var own = this.scrollboxOwner,
                    top = own.scrollboxTop,
                    left = own.scrollboxLeft,
                    bottom = own.scrollboxBottom + getScrollBuffer.call(this),
                    right = own.scrollboxRight,
                    height = bottom - top,
                    x = 0,
                    y = 0,
                    yStart = null,
                    yStop = null,
                    forcedH, sidx;

                
                function _updateStart() {
                    yStart = y;
                    yStop = yStart + height;
                }

                var secsCount = this.numChildren,
                    secs = this.children || [],
                    model = this.model,
                    node = this.node,
                    orH = false;        

                
                for (sidx = 0; sidx < secsCount; sidx++) {

                    
                    var sec = secs[sidx];
                    if (!sec) {
                        
                        sec = this.addChildren(this.builder.build(
                            this._getModelChildNodes(node, false, sidx, 1, true).nodes,
                            model
                        ))[0];
                        
                        secs = this.children || [];
                    }

                    
                    var orWas = orH;

                    
                    orH = !!sec.defn.horiz;

                    
                    
                    forcedH = (sidx > 0 && sec.node.data.bh);

                    
                    
                    if ((!orH && orWas) || (forcedH && orWas)) {
                        
                        x = 0;

                        
                        y += secs[sidx - 1].height();

                        
                        if (y > bottom) {
                            
                            return true;

                        } else if ((yStop !== null) && (y > yStop)) {
                            
                            
                            return false;
                        }
                    }

                    
                    if (!sec.hasRendered) {
                        
                        if (!_shouldRenderSec(x, y, left, right, top, bottom, orH)) {
                            
                            if (orH) {
                                
                                continue;
                            } else {
                                
                                return true;
                            }
                        }

                        this._renderSection(sec, sidx);

                        this.sectionsToRender--;
                        this.subsectionsToRender += (sec.children && sec.children.length) || 0;

                        
                        if (yStart === null) {
                            _updateStart();
                        }
                    }

                    
                    var ssch = sec.children || [],
                        ss = null,
                        ssidx, sslen;

                    for (ssidx = 0, sslen = ssch.length; ssidx < sslen; ssidx++) {
                        
                        ss = ssch[ssidx];
                        
                        if (!ss.hasRendered) {
                            if (!_shouldRenderSub(ss, x, y, left, right, top, bottom, orH)) {
                                
                                if (orH) {
                                    
                                    break;
                                } else {
                                    
                                    return true;
                                }
                            }
                            
                            _fireRender(ss, sec);
                            this.subsectionsToRender--;
                            
                            if (yStart === null) {
                                _updateStart();
                            }
                        }
                        
                        
                        
                        if (orH) {
                            x += ss.width();
                            
                            
                            if (x > right) {
                                break;
                            }
                        } else {
                            y += ss.height();
                            
                            if (y > bottom) {
                                
                                return true;
                            } else if ((yStop !== null) && (y > yStop)) {
                                
                                
                                return false;
                            }
                        }
                    }    
                } 

                
                return true;
            },

            _renderSection: function _renderSection(sec, sidx) {
                
                _fireRender(sec, this, true);
            },

            
            _getModelChildNodes: function (node, isPartial, start, count, includeTotal) {
                return this.model.getChildren(node, isPartial, start, count, includeTotal);
            },
            
            renderCtrlsInViewport: function rnCtlsInVw() {
                var own = this.scrollboxOwner,
                    top = own.scrollboxTop,
                    left = own.scrollboxLeft,
                    bottom = own.scrollboxBottom + getScrollBuffer.call(this),
                    right = own.scrollboxRight,
                    x = 0,
                    y = 0,
                    orH = false,
                    secs = this.children || [],
                    orWas,
                    forcedH, sidx, secCount;

                
                var fnIncSize = function (ss) {
                    if (orH) {
                        x += ss.width();
                    } else {
                        y += ss.height();
                    }
                };

                
                var fnCtlInt = function (s, cx, cs, vs, ve) {
                    
                    cx = parseInt(cx, 10) || 0;
                    cs = parseInt(cs, 10);

                    return (isNaN(cs)) ? (s + cx <= ve) : mstrmojo.boxmodel.rangeIntersect(s + cx, s + cx + cs, vs, ve);
                };

                
                for (sidx = 0, secCount = (secs && secs.length) || 0; sidx < secCount; sidx++) {
                    var sec = secs[sidx];
                    
                    orWas = orH;

                    
                    orH = !!sec.defn.horiz;

                    
                    
                    forcedH = (sidx > 0 && sec.node.data.bh);

                    
                    
                    if ((!orH && orWas) || (forcedH && orWas)) {
                        
                        x = 0;
                        
                        y += secs[sidx - 1].height();
                        
                        if (y > bottom) {
                            
                            return;
                        }
                    }

                    
                    if (!sec.hasRendered) {
                        if (!orH) {
                            return;    
                        } else {
                            continue;    
                        }
                    }
                    
                    var subs = sec.children,
                        ssCount = (subs && subs.length) || 0,
                        ssidx,
                        ss;

                    
                    for (ssidx = 0; ssidx < ssCount; ssidx++) {
                        ss = subs[ssidx];
                        if (!ss.hasRendered) {
                            break;    
                        }

                        
                        if (ss.builtChildren && (ss.numChildrenRendered === ((ss.children && ss.children.length) || 0))) {
                            
                            fnIncSize(ss);

                        } else {
                            
                            if ((y + ss.height() >= top) && (!orH || (x + ss.width() >= left))) {

                                
                                var chdn = ss.children,
                                    chLen = (chdn && chdn.length) || 0;

                                if (!chLen && !ss.builtChildren) {
                                    ss.buildChildren();
                                    chdn = ss.children;    
                                    chLen = (chdn && chdn.length) || 0; 
                                }

                                
                                var rc = [],
                                    i;

                                
                                for (i = 0; i < chLen; i++) {
                                    var c = chdn[i];
                                    if (c.hasRendered) {
                                        continue;
                                    }

                                    var cf = c.getFormats() || {};
                                    
                                    if (fnCtlInt(y, cf.top, cf.height, top, bottom) && fnCtlInt(x, cf.left, cf.width, left, right)) {
                                        c.render();
                                        rc.push(c);
                                    }
                                }

                                
                                ss.performCanGrowCanShrink(rc, true);
                            }

                            
                            fnIncSize(ss);
                        }

                        if ((orH && x > right) || (!orH && y > bottom)) {
                            break;    
                        }
                    }
                }
            },

            
            unrender: function unrdr(ignoreDom) {
                var own = this.scrollboxOwner;
                if (own) {
                    own.disconnectScrollbox(this);
                }
                this._super(ignoreDom);
            }
        }
    );
}());
(function() {
	var cachedCalls = [];
	function cacheCall (func, args) {
		cachedCalls.push({n: func, args: args});
	}
	function checkLoadingStatus (geo, func, args) {
		var ok = false;
		switch (geo._loadingStatus) {
		case 0: 
			if (google && google.maps && google.maps.Geocoder) {
				
				geo._loadingStatus = 2;
				ok = true;
			} else {
				cacheCall(func, args);
				geo._loadScript();
			}
			break;
		case 1: 
			cacheCall(func, args);
			break;
		case 2:
			ok = true;
			break;
		}
		return ok;
	}
	mstrmojo.GeoLocation = mstrmojo.provide(
		'mstrmojo.GeoLocation',
		{
			
			_altitude: null,
			 
			_latitude: null,
			
			_longitude: null,
			
			_callbacks: [],
			_getPos: function(){
				if (mstrMobileApp && mstrMobileApp.getGeoLocation){
					mstrmojo.GeoLocation._getPos = function() {
						mstrMobileApp.getGeoLocation('mstrmojo.GeoLocation.updateLocation');
					};
				} else if (navigator && navigator.geolocation) {
					mstrmojo.GeoLocation._getPos = function() {
						navigator.geolocation.getCurrentPosition(
							function(position) {  
								mstrmojo.GeoLocation.updateLocation(position);
							},
							function(error) {
								switch(error.code){
									case error.TIMEOUT :
										alert( "Retrieve Geo Position: Timeout, please try it again " );
										break;
									case error.PERMISSION_DENIED :
										alert( "Retrieve Geo Position: Permission to use location service has been denied " );
										break;
									case error.POSITION_UNAVAILABLE : 
										alert( "Retrieve Geo Position: Position unavaiable " );
										break;
								}
								mstrmojo.GeoLocation.updateLocation(error);
							},
							
							{maximumAge:10000, timeout:10000}
						);
					};
				} else {
					mstrmojo.GeoLocation._getPos = function() {
						alert("no available Geo Location service");
					};
				}
				mstrmojo.GeoLocation._getPos();
			},
			
			getCurrentLocation: function(callbacks){
				
				this._callbacks.push(callbacks);
				if (!this._pending) {
					this._pending = true;
					this._getPos();
				}
			},
			
			updateLocation: function(info){
				var me = mstrmojo.GeoLocation;
                var i,cbs;





				var p = info && info.coords;
				var e = info && info.err;
				if (p){
					
					me._latitude = p.latitude;
					me._longitude = p.longitude;
					
					
                    cbs = me._callbacks;
                    
                    for (i = 0; i < cbs.length; i ++ ){
						cbs[i].success(p.latitude, p.longitude);
					}
				} else if (e){
					
                    cbs = me._callbacks;
                    for (i = 0; i < cbs.length; i ++ ){
						cbs[i].failure('Error in updating geo location information.'+e);
					}
				} else {
					
                    cbs = me._callbacks;
                    for (i = 0; i < cbs.length; i ++ ){
						cbs[i].failure('Error in updating geo location information.');
					}
				}				
				
				me._callbacks = [];
				
				
				me._pending = false;
			},
			getCurrentAddress: function(callbacks){
				this.getCurrentLocation({
					success: function(la, lo, al){
						mstrmojo.GeoLocation.findAddress(
								{lat: la, lng: lo}, 
								{
									success: callbacks.success && callbacks.success || mstrmojo.emptyFn,
									failure: callbacks.failure && callbacks.failure || mstrmojo.emptyFn 
							
								}
						);
					}, 
					failure: callbacks.failure && callbacks.failure || mstrmojo.emptyFn
				});
			},
            count:null,
            cbs:null,
            getUniqId:function getUniqId() {
                var c;
                if (!this.count) {
                    c = this.count = 1;
                } else {
                    c = this.count++;
                }
                return "fa"+c;
            },
            findAddress: function findAddress(latlng, callbacks) {
            	if (!mstrMobileApp || !mstrMobileApp.useNativeMap || !mstrMobileApp.useNativeMap()) {
            		this.findAddressUsingJsAPI(latlng,callbacks);
            	} else {
            		this.findAddressUsingNativeAPI(latlng,callbacks);
                }
            },
            findAddressUsingJsAPI:function findAddressUsingJsAPI(latlng,callbacks) {
            	if (checkLoadingStatus(this, 'findAddress', [latlng, callbacks])) {
			    	var geocoder = new google.maps.Geocoder();          
			    	geocoder.geocode(
			    			{location:new google.maps.LatLng(latlng.lat, latlng.lng)}, 
			    			function(results, status) {            
			    				if (status == google.maps.GeocoderStatus.OK && results[0]) {
			    					callbacks.success(results);
			    				} else {
			    					callbacks.failure(results, status);
			    				}
			    			}
			    	);        
				}
            },
            findAddressUsingNativeAPI:function findAddressUsingNativeAPI(latlng,callbacks) {
                var id = this.getUniqId();
                if (this.cbs == null) {
                	this.cbs = {};
                }
                this.cbs[id] = function(result) {
                    if (result.status == "OK") {
                        callbacks.success(result.results);
                    } else {
                        callbacks.failure(result.results, result.status);
                    }
                };
                mstrMobileApp.findAddress(latlng.lat,latlng.lng,'mstrmojo.GeoLocation.findAddressCallback',id);
            },
            findAddressCallback : function findAddressCallback(res,status,id) {
            	this.cbs[id].apply(mstrmojo.GeoLocation,[res]);
            },
		    
		    
			_loadingStatus: 0,	
			
			_loadScriptCallBack: function _loadScriptCallBack() { 
				this._loadingStatus = 2;
				
				
				for (var i = 0; i < cachedCalls.length; i ++) {
					var c = cachedCalls[i];
					mstrmojo.GeoLocation[c.n].apply(mstrmojo.GeoLocation, c.args);
				}
			}, 
			_loadScript: function _loadScript() {
				this._loadingStatus = 1;
				var script = document.createElement("script"); 
				script.type = "text/javascript"; 
				script.src = "http://maps.google.com/maps/api/js?sensor=false&callback=mstrmojo.GeoLocation._loadScriptCallBack"; 
				document.body.appendChild(script); 
			}
			
		}
	);
	

})();
(function() {

	var DefaultColor = {
			Min: 0xf23225,
			Max: 0x16b932,
			
			Invalid: 0x000000,
            NoColorMetric: 0xf5f5f7
		};
	var BandDirection = {
			LeftToRight: 0,
			RightToLeft: 1,
			Center: 2,
			None: 3
		};

	function getColorInRange(i, s, e){
		if(i < 0 || i > 1){
			return 0x000000;
		}
		var range = 256,
			index = i*range,
			r, g, b,
			sR = s>>16,
			eR = e>>16,
			sG = (s&0xff00)>>8,
			eG = (e&0xff00)>>8,
			sB = (s&0x00ff),
			eB = (e&0x00ff);
		r = sR+Math.floor((index*(eR-sR)/range));
		g = sG+Math.floor((index*(eG-sG)/range));
		b = sB+Math.floor((index*(eB-sB)/range));
		return	b + (g<<8) + (r<<16);
	}

	function darkerHex(h, p){
		var r = h>>16,
			g = (h&0x00ff00)>>8,
			b = (h&0x0000ff);

		r = Math.floor((1-p)*r);
		g = Math.floor((1-p)*g);
		b = Math.floor((1-p)*b);
		return b + (g<<8) + (r<<16);
	}


	function convertBlendToBand(bl){
		var ba = [],
			blc, bac,
			dp = bl.dp,
			l = dp.length,
			blp, bln;
		if(bl == null || bl.length == 0) return [];
		for(var i = 0; i < l; i++){
			bac = {};
			var blp, bap;
			if(i > 0){
				blp = blc;
				blc = bln;
			}
			else{
				blc = dp[i];
			}
			if(i < l - 1){
				bln = dp[i+1];
			}
			bac.sv = (i==0)?blc.v:(blp.v+blc.v)/2;
			bac.ev = (i==l-1)?blc.v:(bln.v+blc.v)/2;
			bac.c = blc.c;
			bac.d = (i==0)?BandDirection.LeftToRight:(i==l-1?BandDirection.RightToLeft:BandDirection.Center);
			ba[i] = bac;
		}
		return ba;
	}

	function convertBandToBlend(ba){
		var bl = [],
			blc, bac,
			dp = ba.dp,
			l = dp.length;
		if(ba == null || ba.length == 0) return [];
		for(var i = 0; i < l; i++){
			blc = {};
			bac = dp[i];
			var s = bac.s,
				e = bac.e;
			blc.c = bac.c;
			switch (bac.d) {

				case BandDirection.LeftToRight:
					blc.v = bac.s;
					break;
				case BandDirection.RightToLeft:
					blc.v = bac.e;
				case BandDirection.Center:
				case BandDirection.None:
				default:
					var avg = (bac.s + bac.e)/2;
					blc.v = avg;
					break;
			}
			bl[i] = blc;
		}
		return bl;
	}


	function getBlendFillInfo(min, max){
		var colors = [],
			alphas = [],
			ratios = [];
		if(this.min == this.max || isNaN(min) || isNaN(max) || min == max){
			colors[0] = getBlendColor.call(this, min);
			colors[1] = getBlendColor.call(this, max);
			alphas[0] = 1;
			alphas[1] = 1;
			ratios[0] = 0;
			ratios[1] = 1;
		}else if (this.min < this.max){
			var c,
				dp = this.blend.dp,
				l = dp.length,
				index = 0;
			colors[index] = getBlendColor.call(this, min);
			alphas[index] = 1;
			ratios[index] = 0;
			index ++;
			for(var i = 0; i < l; i++){
				c = dp[i];
				if(c.v >= min && c.v <= max){
					colors[index] = c.c;
					alphas[index] = 1;
					ratios[index] = (c.v-min)/(max-min);
					index++;
				}
			}
			colors[index] = getBlendColor.call(this, max);
			alphas[index] = 1;
			ratios[index] = 1;
		}
		return {c:colors, a:alphas, r:ratios};
	}
	function getBandFillInfo(min, max){
		var colors = [],
			alphas = [],
			ratios = [];
		if(this.min == this.max || isNaN(min) || isNaN(max) || min == max){
			colors[0] = getBandColor.call(this, min);
			colors[1] = getBandColor.call(this, max);
			alphas[0] = 1;
			alphas[1] = 1;
			ratios[0] = 0;
			ratios[1] = 1;
		}else if (this.min < this.max){
			var dp = this.band.dp,
				l = dp.length,
				a = 0.4,
				c, co, dc,
				index = 0;
			if(min < 0){
				colors[index] = getBandColor(min);
				alphas[index] = 1;
				ratios[index] = 0;
				index++;
				if(max < 1){
					colors[index] = getBandColor(max);
					alphas[index] = 1;
					ratios[index] = 1;
					index ++;
				}
			}
			for(var i = 0; i < l; i++){
				c = dp[i];
				if(c.s > max || c.e < min){
					continue;
				}
				co = c.c;
				dc = darkerHex(co, a);
				var sv = Math.max(c.s, min),
					ev = Math.min(c.e, max);

				if(ev != sv){
					switch (c.d) {
						case BandDirection.LeftToRight:
						case BandDirection.RightToLeft:
						case BandDirection.Center:
							if(sv == c.s){
								colors[index] = (c.d!=BandDirection.LeftToRight) ? dc : co;
							}else{
								colors[index] = getBandColor.call(this, sv);
							}
							ratios[index] = (sv-min)/(max-min);
							alphas[index] = 1;
							index++;
							if(c.d == BandDirection.Center){
								var avg = (c.s+c.e)/2;
								if(avg > sv && avg < ev){
									colors[index] = co;
									ratios[index] = (avg-min)/(max-min);
									alphas[index] = 1;
									index++;
								}
							}

							if(ev == c.e){
								colors[index] = (c.d!=BandDirection.RightToLeft) ? dc : co;
							}else{
								colors[index] = getBandColor.call(this, ev);
							}
							ratios[index] = (ev-min)/(max-min);
							alphas[index] = 1;
							index++;
							break;
						case BandDirection.None:
						default:
							colors[index] = co;
							ratios[index] = (sv-min)/(max-min);
							alphas[index] = 1;
							index++;
							colors[index] = co;
							ratios[index] = (ev-min)/(max-min);
							alphas[index] = 1;
							index++;
							break;
					}
				}
			}
			if(max > 1){
				if(min > 1){
					colors[index] = getBandColor.call(this, min);
					ratios[index] = 0;
					alphas[index] = 1;
					index++;
				}
				colors[index] = getBandColor.call(this, max);
				ratios[index] = 1;
				alphas[index] = 1;
			}

		}
		return {c:colors, a:alphas, r:ratios};
	}


	function getBandColorFromData(v, d){
		var r = 0.4,
			dc = darkerHex(d.c, r),
			mv, p;
		switch(d.d){
			case BandDirection.LeftToRight:
				if(v < d.s)	return d.c;
				if(v > d.e) return dc;
				if(d.s == d.e) return getColorInRange(0.5, d.c, dc);
				p = (v-d.s)/(d.e-d.s);
				return getColorInRange(p, d.c, dc);
			case BandDirection.RightToLeft:
				if(v < d.s)	return dc;
				if(v > d.e)	return d.c;
				if(d.s == d.e) return getColorInRange(0.5, dc, d.c);
				p = (v-d.s)/(d.e-d.s);
				return getColorInRange(p, dc, d.c);
			case BandDirection.Center:
				mv = (d.s+d.e)/2;
				if(v < d.s || v > d.e) return dc;
				if(d.s == d.e) return dc;
				if(v <= mv) {
					p = (v-d.s)/(mv-d.s);
					return getColorInRange(p, dc, d.c);
				}
				p = (v-mv)/(d.e-mv);
				return getColorInRange(p, d.c, dc);
			case BandDirection.None:
			default:
				return d.c;
		}
	}
	function getBlendColor(v){
		if(isNaN(v)){
			return DefaultColor.Invalid;
		}
		if(this.max == this.min){
			return this.blendEqualColor;
		}
		var dp = this.blend.dp,
			l = dp.length;
		if(!this.valid){
			var s = dp[0],
				e = dp[l-1];
			if(v < this.min){
				return s.c;
			}
			return e.c;
		}
		var i, c = dp[0],
			sv = c.v,
			sc = c.c,
			ev, ec;
		for(i = 1; i < l; i++){
			c = dp[i];
			if(c.v >= v) break;
			sv = c.v;
			sc = c.c;
		}
		i = Math.min(i, l-1);
		c = dp[i];
		ev = c.v;
		ec = c.c;
		if(v < sv) return sc;
		if(v > ev) return ec;
		if(sv == ev) return getColorInRange(0.5, sc, ec);
		
				
				
		
		

		var p = (v-sv)/(ev-sv);
		return getColorInRange(p, sc, ec);
		

	}

	function getBandColor(v){
		if(isNaN(v)) return DefaultColor.Invalid;
		if(this.min == this.max) return this.bandEqualColor;
		var dp = this.band.dp,
			l = dp.length;
		if(!this.valid){
			var s = dp[0],
				e = dp[l-1];
			if(v < this.min){
				return getBandColorFromData(e.s, s);
			}else{
				return getBandColorFromData(e.e, e);
			}
		}
		for(var i = 0; i < l; i++){
			c = dp[i];
            if(c.s === c.e) {
                continue;
            }
			if(c.s <= v && v <= c.e){
				return getBandColorFromData(v, c);
			}
		}
	}



	function createDefaultBlendDataProvider(min, max){
		this.blend.dp = [];
		var dp = this.blend.dp,
			bc;
		bc = {};
		bc.c = min;
		bc.v = 0;
		dp[0] = bc;

		bc = {};
		bc.c = max;
		bc.v = 1;
		dp[1] = bc;
	}

	function createDefaultBandDataProvider(min, max){
		this.band.dp = [];
		var dp = this.band.dp,
			bc;
		bc = {};
		bc.d = BandDirection.LeftToRight;
		bc.s = 0;
		bc.e = 0.5;
		bc.c = min;
		dp[0] = bc;

		bc = {};
		bc.d = BandDirection.LeftToRight;
		bc.s = 0.5;
		bc.e = 1;
		bc.c = max;
		dp[1] = bc;
	}
	function createBlendTooltipInfo(c, w, d){
		var ar = [],
			sx = 0,
			sv, ev,
			min = this.min,
			max = this.max,
			tc = d.legendTickCount,
			rt = {}, 
			co,
			valid = !isNaN(this.min) && !isNaN(this.max);

		if(this.min >= this.max || this.blend.dp.length <= 2){
			var f = (max-min)/tc;
			for(var i = 0; i < c; i++){
				rt = {x:sx, w:Math.floor(w/tc)};
				sx += rt.w;
				if(valid){
					sv = min + i*f;
					ev = sv + f;
					co = this.getColor((sv+ev)/2);
				}else{
					sv = "Null";
					ev = "Null";
					co = 0x000000; 
				}
				ar.push({r:rt, c:co, sv:sv, ev:ev});
			}
		}else{
			var dp = this.blend.dp,
				l = dp.length;
			for(var i = 0; i < l; i++){
				var item = dp[i],
					p, n;
				if(i == 0){
					sv = min;
				}else{
					p = dp[i-1];
					sv = min + (max-min)*(item.v+p.v)/2;
				}
				if(i == l-1){
					ev = max;
				}else{
					n = dp[i+1];
					ev = min + (max-min)*(item.v+n.v)/2;
				}
				rt = {x:sx, w:Math.floor(w*(ev-sv)/(max-min))};
				sx += rt.w;
				if(valid){
					co = this.getColor((sv+ev)/2);
				}else{
					sv = "Null";
					ev = "Null";
					co = 0x000000; 
				}
				ar.push({r:rt, c:co, sv:sv, ev:ev});
			}
		}
		this.tooltipInfo = ar;
	}
	function createBandTooltipInfo(c, w, d){
		var ar = [],
			sx = 0,
			sv, ev,
			min = this.min,
			max = this.max,
			tc = d.legendTickCount,
			rt = {}, 
			co,
			st, 
			valid = !isNaN(this.min) && !isNaN(this.max);
		if(this.min >= this.max){
			for(var i = 0; i < c; i++){
				rt = {x:sx, w:Math.floor(w/tc)};
				st += rt.w;
				if(valid){
					st = sv + " < " + ms + " < " + ev;
					co = this.getColor(min);
				}else{
					sv = "Null";
					ev = "Null";
					co = 0x000000; 
				}
				ar.push({r:rt, c:co, sv:sv, ev:ev});
			}
		}else{
            var imax, imin;
            if(this.isFixedColorBanding) {
                imax = this.initMax;
                imin = this.initMin;
            } else {
                imax = max;
                imin = min;
            }
			var dp = this.band.dp,
				l = dp.length;
			if(l <= 2){
				for(var i = 0; i < l; i++){
					var item = dp[i];
					if(i == 0){
						sv = imin;
					}else{
						sv = imin + (imax-imin)*item.s;
					}
					if(i == l-1){
						ev = imax;
					}else{
						ev = imin + (imax-imin)*item.e;
					}
                    if(sv < min) {
                        sv = min;
                    }
                    if(ev > max) {
                        ev = max;
                    }
                    if(sv > ev && ev >= max) {
                        sv = max;
                        ev = max;
                    } else if(ev < sv && sv <= min) {
                        sv = min;
                        ev = min;
                    }
					rt = {x:sx, w:Math.floor(w*(ev-sv)/(max-min)/2)};
					sx += rt.w;
					if(valid){
						ev = (sv+ev)/2;
						co = this.getColor((sv+ev)/2);
					}else{
						sv = "Null";
						ev = "Null";
						co = 0x000000; 
					}
					ar.push({r:rt, c:co, sv:sv, ev:ev});

					sx += rt.w;
					var bw = w*(ev-sv)/(max-min)/2;
					rt = {x:sx, w:Math.ceil(bw)};
					if(i > 0){
						var pr = ar[ar.length-1].r;
						if(rt.x < pr.x + pr.w+1){
							pr.w = rt.x - pr.x;
						}
					}
					sx += Math.floor(bw);
					if(valid){
						sv = (sv+ev)/2;
						co = this.getColor((sv+ev)/2);
					}else{
						sv = "Null";
						ev = "Null";
						co = 0x000000; 
					}
					ar.push({r:rt, c:co, sv:sv, ev:ev});
				}
			}
			else{
				for(var i = 0; i < l; i++){
					var item = dp[i];
					if(i == 0){
						sv = d.props.legendAsc ? imin : imax;
					}else{
						sv = d.props.legendAsc ? imin + (imax-imin)*item.s
								: imax + (imin-imax)*item.s;
					}
					if(i == l-1){
						ev = d.props.legendAsc ? imax : imin;
					}else{
						ev = d.props.legendAsc ? imin + (imax-imin)*item.e
								: imax + (imin-imax)*item.e;
					}
                    if(sv < min) {
                        sv = min;
                    }
                    if(ev > max) {
                        ev = max;
                    }
                    if(sv > ev && ev >= max) {
                        sv = max;
                        ev = max;
                    } else if(ev < sv && sv <= min) {
                        sv = min;
                        ev = min;
                    }
					var bw = w*(ev-sv)/(max-min);

					rt = {x:sx, w:Math.ceil(bw)};
					if(i > 0){
						var pr = ar[ar.length-1].r;
						if(rt.x < pr.x + pr.w+1){
							pr.w = rt.x - pr.x;
						}
					}
					if(i == l - 1){
						rt.w = w - sx;
					}
					sx += Math.floor(bw);
					var sign = d.props.legendAsc ? " < " : " > ";
					if(valid){
						co = this.getColor((sv+ev)/2);
					}else{
						sv = "Null";
						ev = "Null";
						co = 0x000000; 
					}
					if(sign){
						ar.push({r:rt, c:co, sv:sv, ev:ev});
					}else{
						ar.push({r:rt, c:co, sv:sv, ev:ev, sign:">"});
					}

				}
			}
		}
		this.tooltipInfo = ar;
	}
	mstrmojo.VisHeatMapColorTheme = {
		newInstance:function(){
			return {
				initialize : function prepareData(){
					this.blend = {};
					this.band = {};
					this.valid = true;
					this.blendEqualColor = 0;
					this.bandEqualColor = 0;
					this.isBlend = true;
					this.setDefaultDataProvider();
					this.checkMinMax();
				},


				getGradientFillInfo: function getGradientFillInfo(min, max){
					var tmin, tmax;
					if(isNaN(min) || isNaN(max)){
						if(this.isBlend){
							return getBlendFillInfo.call(this, min, max);
						}else{
							return getBandFillInfo.call(this, min, max);
						}
					}
					if(this.min == this.max){
						if(min < this.min){
							tmin = 0;
						}else{
							tmin = 1;
						}
						if(max < this.max){
							tmax = 0;
						}else{
							tmax = 1;
						}
					}else{
						if(this.isFixedColorBanding){
								var d = this.initMax - this.initMin;
								tmin = (min-this.initMin)/d;
								tmax = (max-this.initMin)/d;
						}
						else{
								var d = this.max-this.min;
								tmin = (min-this.min)/d;
								tmax = (max-this.min)/d;
						}
					}
					if(this.isBlend){
						return getBlendFillInfo.call(this, tmin, tmax);
					}else{
						return getBandFillInfo.call(this, tmin, tmax);
					}
				},

				checkMinMax: function checkValid(){
					var cmin = this.min,
						cmax = this.max;
					if(cmin > cmax){
						this.valid = false;
					}else if(cmin == cmax){
						cmin = cmax = 1; 
						var dp = this.blend.dp,
							l = dp.length,
							c,
							index;

						for(var i = l - 1; i >= 0; i--){
							c = dp[i];
							if(i == l - 1 && c.v <= cmin){
								this.blendEqualColor = c.c;
								break;
							}
							if(i == 0 && c.c >= cmin){
								this.blendEqualColor = c.c;
								break;
							}
							if(i > 0 && c.c >= cmin){
								var pc = dp[i-1];
								if(pc.c < cmin){
									index = (cmin-pc.v)/(c.v-pc.v);
									this.blendEqualColor = getColorInRange(index, pc.c, c.c);
									break;
								}
							}
						}
						dp = this.band.dp;
						l = dp.length;
						for(var i = 0; i < l; i++){
							c = dp[i];
							if((i == 0 && c.s >= cmin)
								||(i == l - 1 && c.e <= cmin)
								||(c.s <= cmin && c.e >= cmin)){
								this.bandEqualColor = c.c;
								break;
							}
						}
					}
					
						
						

					
				},

				setDefaultDataProvider: function setDefaultData(){
					createDefaultBlendDataProvider.call(this, DefaultColor.Min, DefaultColor.Max);
					createDefaultBandDataProvider.call(this, DefaultColor.Min, DefaultColor.Max);
					this.useDefault = true;
				},
				getColor: function getColorForValue(v){
                    if(this.hasNoColorMetric)
                            return DefaultColor.NoColorMetric;
					var value = NaN;
					if(isNaN(v)) value == 0;
					else if(this.min == this.max){
						value = v < this.min ? 0 : 1;
					}else{
						if(this.isFixedColorBanding)
							value = (v-this.initMin)/(this.initMax-this.initMin);
						else
							value = (v-this.min)/(this.max-this.min);
					}
					if(this.isBlend){
						return getBlendColor.call(this, value);
					}else{
						return getBandColor.call(this, value);
					}
				},

				isBrightColor: function isBrightColor(c){
					var r = c>>16,
						g = (c&0x00ff00)>>8,
						b = (c&0x0000ff),
						bright = (r*299+g*587+b*114)/1000;
					if(bright>150) return true;
					return false;
				},
				getContrastColor: function getContrastColor(c){
					if(this.isBrightColor(c)){
						return 0x000000;
					}
					return 0xffffff;
				},
				
				createTooltipInfo: function createTooltipInfo (t, w, d){
					var count = 0;
					if(this.min >= this.max){
						count = 1;
					}else {
						var l;
						if(this.isBlend){
							l = this.blend.dp.length;
							count = (l <= 2) ? 5 : l;
						}else{
							l = this.band.dp.length;
							count = (l <= 2) ? 4 : l;
						}
					}
					if(this.isBlend){
						createBlendTooltipInfo.call(this, count, w, d);
					}else{
						createBandTooltipInfo.call(this, count, w, d);
					}
				},

				getTooltipInfo: function getTooltip(v){
					var t = this.tooltipInfo;
					for(var i = 0; i < t.length; i++){
						var item = t[i],
							rect = item.r;
						if(v >= rect.x && v < rect.x + rect.w){
							return i;
						}
					}
					return i-1;
				},

				getMaxMinByMetricID: function(model,id){
						var col = model.gts.col,
						len = col.length,
						i = 0,
						index = null
						range = {min:null,max:null};

						for(i = 0; i < len && index == null; i++){
							var es = col[i].es,
								lenes = es.length,
								j;
							for(j = 0; j < lenes; j++){
								if(es[j].oid == id){
									index = j;
									break;
								}
							}
						}
						if(index == null)
							return range;
						var gvs = model.gvs.items,
							len = gvs.length;
						for(i = 0; i < len; i++){
							var value = parseFloat(gvs[i].items[index].rv);
							if(range.min == null)
								range.min = value;
							if(range.max == null)
								range.max = value;
							if(range.min > value)
								range.min = value;
							if(range.max < value)
								range.max = value;
						}
						return range;
				},
				convertFixedValueToBlendString: function(fixedBandingArray,range){
						var convertedBlend = "";
						if(fixedBandingArray.length%2 == 0){
								var length = fixedBandingArray.length,
								min = range.min,
								max = range.max,
								i = 0;

								
								
								
								
								var delta = max - min;
								convertedBlend = '0,'+fixedBandingArray[1];
								for(i = 2; i < length-2; i += 2){
										var value = parseInt(fixedBandingArray[i]);
										if(value < min || value > max)
												continue;
										else{
												var colorIndex = (value-min)/delta;
												convertedBlend += ',' + colorIndex + ',' + fixedBandingArray[i+1];
										}
								}
								convertedBlend += ',1,' + fixedBandingArray[length-1];

								
								
								
						
								
								
						}
						return convertedBlend;
				},

                convertFixedValueToBandString: function(string, range) {
                        var a = string.split(','),
                            len = a.length,
                            i,
                            d = range.max - range.min;
                        var ret = '';
                        if(len % 4 === 0) {
                            for(i = 0; i < len; i+=4){
                                var j = 0;
                                for(j = 0; j < 2; j++) {
                                    var v,
                                        str = a[i + j];
                                    if(str === 'min') {
                                        v = range.min;
                                    } else if(str === 'max') {
                                        v = range.max;
                                    } else {
                                        v = parseFloat(a[i + j]);
                                    }
                                    if(!isNaN(v)) {
                                        a[i + j] = String((v - range.min) / d);
                                    } else {
                                        console.log('warning: invalid band string. In heatmap color theme');
                                    }
                                }
                            }
                            for(i = 0; i < len; i++) {
                                ret += (a[i] + ',');
                            }
                            ret = ret.substring(0, ret.length - 1);
                        } else {
                            console.log('warning: Invalid band color string. In heatmap color theme');
                        }
                        return ret;
                },

				convertAbsoluteToBlend: function(heatMap,propValue){
						this.useDefault = false;
						this.isColorBanding = true;
						var abs = propValue.abs.replace(/&quot;/g, '"')
												.replace(/&gt;/g, '>')
												.replace(/&lt;/g, '<')
												.replace(/&amp;/g, '&');
						abs = (new window.DOMParser()).parseFromString(abs,"text/xml");
						var absM = abs.getElementsByTagName('m')[0];
						
						heatMap.absoluteColorID = absM.getAttribute('id');
						this.isFixedColorBanding = true;
						this.fixedBandingArray= absM.getAttribute('bl').split(',');
						var	range;
						
						
						
						
						if(!isNaN(this.min) && !isNaN(this.max))
							range = {max: this.max, min: this.min};
						else{
								range = this.getMaxMinByMetricID(heatMap.model,heatMap.absoluteColorID);
								this.max = range.max;
								this.min = range.min;
						}
						if(isNaN(this.initMax) || isNaN(this.initMin)){
								range = this.getMaxMinByMetricID(heatMap.model,heatMap.absoluteColorID);
								this.max = range.max;
								this.min = range.min;
								this.initMax = range.max;
								this.initMin = range.min;
						}
						
								
						
                        propValue.bandColors = this.convertFixedValueToBandString(absM.getAttribute('ba'), range);
						propValue.gradientColors = this.convertFixedValueToBlendString(this.fixedBandingArray,range);
				},


				createDataProviderFromString: function createDataProvider(bl, ba){
					var arr = bl.split(','),
						i = 0,
						dp;
					this.blend.dp = [];
					this.useDefault = false;
					dp = this.blend.dp;
					if(arr.length % 2 == 0){
						while(i < arr.length){
							var c = {};
							c.v = parseFloat(arr[i]);
							i++;
							c.c = parseInt(arr[i]);
							i++;
							dp[dp.length] = c;
						}
					}
					i = 0;
					arr = ba.split(',');
					this.band.dp = [];
					dp = this.band.dp;
					if(arr.length % 4 == 0){
						while(i < arr.length){
							var c = {};
							c.s = parseFloat(arr[i]);
							i++;
							c.e = parseFloat(arr[i]);
							i++;
							c.c = parseInt(arr[i]);
							i++;
							var str = arr[i];
							switch(str){
								case "leftToRight":
									c.d = BandDirection.LeftToRight;
									break;
								case "rightToLeft":
									c.d = BandDirection.RightToLeft;
									break;
								case "center":
									c.d = BandDirection.Center;
									break;
								default:
									c.d = BandDirection.None;
							}
							i++;
							dp[dp.length] = c;
						}
					}
				}
			};
		}
	}

})();


mstrmojo.mstr.EnumDataType = {

    
    DataTypeUnknown: -1,

    
    DataTypeReserved: 0,

    
    DataTypeInteger: 1,

    
    DataTypeUnsigned: 2,

    
    DataTypeNumeric: 3,

    
    DataTypeDecimal: 4,

    
    DataTypeReal: 5,

    
    DataTypeDouble: 6,

    
    DataTypeFloat: 7,

    
    DataTypeChar: 8,

    
    DataTypeVarChar: 9,

    
    DataTypeLongVarChar: 10,

    
    DataTypeBinary: 11,

    
    DataTypeVarBin: 12,

    
    DataTypeLongVarBin: 13,

    
    DataTypeDate: 14,

    
    DataTypeTime: 15,

    
    DataTypeTimeStamp: 16,

    
    DataTypeShort: 21,

    
    DataTypeLong: 22,

    
    DataTypeMBChar: 23,

    
    DataTypeBool: 24,

    
    DataTypePattern: 25,

    
    DataTypeBigDecimal: 30
};
(function () {
    
    
    
    function measureDimension(node, dim, ch) {
        var x = 0,
            i = 0,
            len = (ch && ch.length) || 0;
        
        
        if (!node || !ch) {
            return x;
        }
        
        
        for (; i < len; i++) {
            x += ch[i][dim]();
        }
        
        
        return x;
    }
    
    
    function resolveChildrenToMeasure(ch, count) {
        if (count === undefined || isNaN(count)) {
            return ch;
        }
        
        
        return (ch && [ ch[count - 1] ]);
    }

    
    mstrmojo._CanMeasureChildren = 
        
        {
            
            
            height: function height(count) {
                return measureDimension(this.domNode, 'height', resolveChildrenToMeasure(this.children, count));
            },
            
            
            width: function width(count) {
                return measureDimension(this.domNode, 'width', resolveChildrenToMeasure(this.children, count));
            }
            
        };
    
}());

mstrmojo.mstr.EnumNodeDimty = {

    
    NodeDimtyReserved: 0,

    
    NodeDimtyNone: 1,

    
    NodeDimtyContinuation: 2,

    
    NodeDimtyExclusiveContinuation: 3,

    
    NodeDimtyOutputLevel: 4,

    
    NodeDimtyBreakBy: 5,

    
    NodeDimtyEmbedded: 6,
    
    
    NodeDimtyUnspecified: 7
};
(function () {
    
    mstrmojo._ReportDataService = mstrmojo.provide(
        'mstrmojo._ReportDataService',
        
        
        {
            _mixinName: 'mstrmojo._ReportDataService',
            
            getPageByTree: function getPageByTree(callback) {
                mstrApp.serverRequest({
                    taskId: 'getPageByTree',
                    msgID: this.msgId
                }, callback);
            },
            
            pageByUnitsToKeys: function pageByUnitsToKeys(pbUnits) {
                var pbArr = [],
                    i;
                
                for (i = 0; i < pbUnits.length; i++) {
                    var p = pbUnits[i];
                    if (mstrApp.useBinaryFormat) {
                        pbArr.push(p.v);
                    } else {
                        pbArr = pbArr.concat([ p.id, p.tp, p.v ]);
                    }
                }
                return pbArr.join('\u001F');
            }
        }
    );
}());
mstrmojo.android.EnumOrientationTypes = {
    PORTRAIT: 1,
    LANDSCAPE: 2
};
(function () {
    
    
    mstrmojo.array = mstrmojo.provide(
        "mstrmojo.array",
        
        {
            
            
            indexOf: function indexOf(arr, item) {
                var i = 0,
                    len = (arr && arr.length)  || 0;
                
                for (; i < len; i++) {
                    if (arr[i] == item) {
                        return i;
                    }
                }
                return -1;
            },
            
            
            indexOfMulti: function idxOf( arr,  items) {
                if (!items) {
                    return {indices: null, map: {}, count: 0};
                }
                var len = items.length,
                    idxs = new Array(len),
                    map = {},
                    c = 0;
                for (var i=0, j=(arr&&arr.length)||0; i<j; i++){
                    var a = arr[i];
                    for (var k = 0; k<len; k++) {
                        if (items[k] === a){
                            idxs[k] = i;
                            map[k] = i;
                            c++;
                            break;  
                        }
                    }
                }
                return {indices: idxs, map: map, count: c}; 
            },
            
            
            forEach: function forEach(arr, f, scope) {
                for (var i = 0, len = (arr && arr.length) || 0; i < len; i++) {
                    if (scope) {
                        if (f.call(scope, arr[i], i, arr) === false) {
                            break;
                        }
                    } else {
                        if (f(arr[i], i, arr) === false) {
                            break;
                        }
                    }
                }
            },
            
            
            filter: function filter( arr,  f,  config) {
                var result = [],
                    n = 0;
                for (var i=0, len=arr && arr.length || 0; i < len; i++) {
                    if (f(arr[i])) {
                        result[n] = arr[i];
                        n++;
                        if (config && config.max && (n >= config.max)) {
                            break;
                        }
                    }
                }
                return result;
            },
            
            
            find: function find( arr,  n,  v) {
                for (var i=0, len=arr && arr.length || 0; i < len; i++) {
                    var obj = arr[i];
                    if (obj && obj[n] == v) {
                        return i;
                    }
                }
                return -1;
            },
            
            
            findBin: function fBin( arr,  item,  p,  len) {
                var h = len ? len : arr.length, 
                    l = -1,         
                    m,              
                    v = item[p];    
                while (h-l > 1) {
                    if (arr[m = h+l >> 1][p] < v) { 
                        l = m;
                    } else {
                        h = m;
                    }
                }
                return arr[h][p] === v ? h : -1;
            },

            
            
            search: function search(o,v,p) {
                var h = o.length,
                    l = -1,
                    m,
                    val = v.toUpperCase(),
                    len = v.length;
                    
                while(h - l > 1)
                    if(o[m = h + l >> 1][p].substr(0,len).toUpperCase() < val) l = m;
                    else h = m;
                return h;
            },

            
            findMulti: function idxOf( arr,  n,  items) {
                if (!items) {
                    return {indices: null, map: {}, count: 0};
                }
                var len = items.length,
                    idxs = [], 
                    map = {},
                    c = 0;
                for (var i=0, j=(arr&&arr.length)||0; i<j; i++){
                    var a = arr[i][n];
                    for (var k = 0; k<len; k++) {
                        if (items[k][n] === a){
                            idxs[k] = i;
                            map[k] = i;
                            c++;
                            break;  
                        }
                    }
                }
                return {indices: idxs, map: map, count: c}; 
            },
            
            
            removeItem: function rmI( arr,  item) {
                var i = this.indexOf(arr, item);
                if (i >-1) {
                    this.removeIndices(arr, i, 1);
                }
                return i;
            },
            
            
            removeItems: function rmIts(arr, n, items){
                var ret = this.findMulti(arr, n, items);
                if (ret.count) {
                    
                    var idxs = ret.indices.concat().sort(this.numSorter).slice(0, ret.count);
                    for (var i=idxs.length-1; i>-1; i--) {
                        
                        arr.splice(idxs[i], 1);
                    }
                }
            },
            
            
            numSorter: function ns(a,b) {
                return Number(a)-Number(b);
            },

            stringSorter: function ss(a,b){
                var A = a.toLowerCase();
                var B = b.toLowerCase();
                if (A < B){
                   return -1;
                }else if (A > B){
                  return  1;
                }else{
                  return 0;
                }
            },
            
            
            removeIndices: function removeIds( arr,  start,  count) {
                arr.splice(start, count);
            },
            
            
            insert: function inst(arr, idx, items) {
                if (!arr) {
                    arr = [];
                }
                if (idx == null){
                    idx = arr.length;
                }
                Array.prototype.splice.apply(arr, [idx, 0].concat(items));
                return arr;
            },
            
            
            hash: function hs(arr) {
                var h = {};
                for (var i=0, len=(arr&&arr.length)||0; i<len; i++) {
                    h[arr[i]] = true;
                }
                return h;
            },
            
            
            get: function gt(arr, idxs){
                if (!idxs) {
                    return null;
                }
                var ret = [];
                for (var i=0, len=idxs.length; i<len; i++) {
                    ret[i] = arr[idxs[i]];
                }
                return ret;
            },

            
            deepSortArr: function deepSortArr(arr, prop,  idx, asc) {
                return arr.sort(function(a, b){
                    return (!asc ? (a[idx][prop] <= b[idx][prop]) : (a[idx][prop] > b[idx][prop])) ? -1 : 1;
                    }
                );
            }

        });
    
})();
(function(){
    
    
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    
    var $SFCC = String.fromCharCode;
    
    function _utf8_encode(string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";
     
        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);
            if (c < 128) {
                utftext += $SFCC(c);
            }else if((c > 127) && (c < 2048)) {
                utftext += $SFCC((c >> 6) | 192);
                utftext += $SFCC((c & 63) | 128);
            }else {
                utftext += $SFCC((c >> 12) | 224);
                utftext += $SFCC(((c >> 6) & 63) | 128);
                utftext += $SFCC((c & 63) | 128);
            }
         }
        return utftext;
    }
     
    function _utf8_decode(utftext) {
        var string = "",
            i = 0,
            c = 0, c1 = 0, c2 = 0;
        
        while ( i < utftext.length ) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
                string += $SFCC(c);
                i++;
            }else if((c > 191) && (c < 224)) {
                c1 = utftext.charCodeAt(i+1);
                string += $SFCC(((c & 31) << 6) | (c1 & 63));
                i += 2;
            }else {
                c1 = utftext.charCodeAt(i+1);
                c2 = utftext.charCodeAt(i+2);
                string += $SFCC(((c & 15) << 12) | ((c1 & 63) << 6) | (c2 & 63));
                i += 3;
            }
        }
        return string;
    }
    
    mstrmojo.base64 = mstrmojo.provide(
        "mstrmojo.base64",
        
        {
            
            decodeHttpHeader: function(value){
                var rEncoded = /\=\?UTF-8\?B\?(.+?)\?\=/g;
                if (value && value.indexOf("=?UTF-8?B?") === 0){
                    var decMsg = "", result;
                    while ((result = rEncoded.exec(value)) !== null){
                        decMsg += mstrmojo.base64.decode(result[1]);
                    }
                    return decMsg;
                }
                return value;
            },
            
            
            encode: function (input) {
                var output = "";
                var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
                var i = 0;
                
                input = _utf8_encode(input);
                while (i < input.length) {
                    chr1 = input.charCodeAt(i++);
                    chr2 = input.charCodeAt(i++);
                    chr3 = input.charCodeAt(i++);
    
                    enc1 = chr1 >> 2;
                    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                    enc4 = chr3 & 63;
    
                    if (isNaN(chr2)) {
                        enc3 = enc4 = 64;
                    } else if (isNaN(chr3)) {
                        enc4 = 64;
                    }
             
                    output += _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
             
                }
                return output;
            },
            
            
            decode: function (input) {
                var output = "", i = 0;
                var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
                
                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                while (i < input.length) {
                    enc1 = _keyStr.indexOf(input.charAt(i++));
                    enc2 = _keyStr.indexOf(input.charAt(i++));
                    enc3 = _keyStr.indexOf(input.charAt(i++));
                    enc4 = _keyStr.indexOf(input.charAt(i++));
    
                    chr1 = (enc1 << 2) | (enc2 >> 4);
                    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                    chr3 = ((enc3 & 3) << 6) | enc4;
                    
                    output += $SFCC(chr1);
                    
                    if (enc3 != 64) {
                        output += $SFCC(chr2);
                    }
                    if (enc4 != 64) {
                        output += $SFCC(chr3);
                    }
                }
                output = _utf8_decode(output);
                return output;
            }
        }
    ); 
})();
(function(){

         
    var _reTOKENS = /\{\@([^\}]+)\}/gm,
        _reLT = /\</gm,
        _reGT = /\>/gm,
        _reNEm = /\S/,
        _regSpecials = ['$','^','=','!',':',
                    '/', '.', '*', '+', '?', '|',
                    '(', ')', '[', ']', '{', '}', '\\'
                  ],
        _reRegEsc = new RegExp(
                '(\\' + _regSpecials.join('|\\') + ')', 'g'
        ),
        _xmlRep = {
                    '&': { k: '&(?!#?\\w+;)', v: '&amp;'},
                    '<'            : '&lt;',
                    '>'            : '&gt;',
                    'u0009'        : '&#x09;',  
                    '\n'           : '&#x0A;',  
                    '\r'           : '&#x0D;',  
                    '"'            : '&quot;'
                    },
       _htmlRep = {
                    '&': { k: '&(?!#?\\w+;)', v: '&amp;'},
                    '<'            : '&lt;',
                    '>'            : '&gt;', 
                    ' '            : '&nbsp;',
                    '\n'           : '<br/>',  
                    '\r'           : '&nbsp;&nbsp;&nbsp;&nbsp;',  
                    '\''           : '&#039;',
                    '"'            : '&quot;'                    
                    },
       _htmlDecodeRep = {
                    '&amp;'         :'&',
                    '&lt;'		    : '<',
                    '&gt;'          : '>',
                    '&nbsp;'        : ' ',
                    '<br/>'         : '\n',  
                    '&nbsp;&nbsp;&nbsp;&nbsp;'  : '\r',  
                    '&#039;'        : '\'',
                    '&quot;'        : '"'
    };

    
    var _typeOf = function (v) {
        if (v == null) {
            return 'null';
        }
        var t = typeof(v);
        if (t != 'object') {
            return t;
        } else {
            if (v.length === undefined) {
                return 'object';
            } else {
                return 'array';
            }
        }
    };
    
    var parseUriOptions = {
        strictMode: false,
        
        key: [ 'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor' ],
        
        q: {
            name: 'queryKey',
            parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        
        parser: {
            strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
            loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
    };        
    
	
	mstrmojo.string = mstrmojo.provide(
	        
	   "mstrmojo.string",
	   
	   
	   {

		
		multiReplace: function multiReplace(s, hash) {
			if (!s) {
				return '';
			}
			
			var keys = [];
			for (var k in hash) {
			    keys.push(k.k || k); 
			}
			
			return s.replace(new RegExp(keys.join('|'), 'g'), function ($0) {
				var v = hash[$0];
                return v.v || v;           
			});
		},
			
				
		trim: function trim( s) {
			return (s && s.replace)? s.replace(/^\s+/, "").replace(/\s+$/, ""):s;
		},

        
        ellipsize: function ellipsize(text, length) {
            
            var shortText = this.trim(text.substr(0, (length || 1) - 1));
    
            
            if (shortText !== text) {
                
                shortText += '&hellip;';
            }

            return shortText;
        },

        
        isEmpty: function isEmpty(v){
            return (v == null) || !(_reNEm.test(v)); 
        }, 

        regEscape : function regEscape(text){
            return text.replace(_reRegEsc, '\\$1');
        },
        
		
		encodeXMLAttribute : function(v) {
			return mstrmojo.string.multiReplace(v, _xmlRep);
		},
		
		encodeHtmlString: function(v) {
	        return mstrmojo.string.multiReplace(v, _htmlRep);
		},
		
		
		decodeHtmlString: function(v) {
	        return mstrmojo.string.multiReplace(v, _htmlDecodeRep);
		},
		
		
		htmlAngles: function(s){
		  s = String(s);
		  if (s != null) {    
		      return s.replace(_reLT, '&lt;').replace(_reGT, '&gt;');
		  }
		  return s;
		  
		},
		
        
        apply: function apl(tmpl, obj) {
            if (!tmpl) {
                return "";
            }
            return tmpl.replace(
                                _reTOKENS,
                                function tokenRepl(token, prop) {
                                        return (prop in obj && obj[prop] !== null) ? obj[prop] : "";
                                }
                    );
        },
        
        json2xml: function(nodeName, jsons, config){
            if (!(jsons instanceof Array)){
                jsons = [jsons];
            }
           
            var serial = config && config.isSerializable,
                convertBoolean = (config.convertBoolean === false)? false:true;
            
            
            var att= [],    
                ch = [],    
                n,          
                v,          
                t;          
            
            for (var ji = 0, jlen = jsons.length; ji < jlen; ji ++) {
                var json = jsons[ji];
                
                for (n in json){
                    
                    if (serial) {
                        var ret = serial(n, jsons, ji);
                        if (ret !== true){
                            if (ret === false) {    
                                continue; 
                            } else {
                                if (ret.att){       
                                    att.push(ret.att);
                                }
                                if (ret.child){     
                                    ch.push(ret.child);
                                }
                                continue;
                            }
                        }
                        
                    }                
                    v = json[n];
                    t = _typeOf(v);
                    switch(t) {
                        case 'array':
                            ch.push('<' + n + '>');     
                            
                            for (var i = 0, len = v.length; i < len; i ++){
                                var cn = config.getArrItemName(n,v,i) || i; 
                                ch.push(this.json2xml(cn, v[i], config));   
                            }
                            ch.push('</' + n + '>'); 
                            break;
                        case 'object':
                            ch.push(this.json2xml(n, v, config));
                            break;
                        case 'string':
                            att.push(n + '="' + mstrmojo.string.encodeXMLAttribute(v) + '"'); 
                            break;
                        case 'boolean':
                            att.push(n + '="' + ((convertBoolean)? (v ? '-1': '0'):v) + '"'); 
                            break;
                        case 'null': 
                            if (!config.skipNull) {
                                att.push(n + '="' + config.nullValue + '"');
                            }
                            break;
                        default:
                            att.push(n + '="' + v + '"'); 
                            break;
                    }
                } 
            } 
            return '<' + nodeName + ' ' + att.join(' ') + '>' + ch.join('') + '</' + nodeName + '>';
        },
        
        escape4HTMLText: function escape4HTMLText(v) {
            if (!v || !v.replace) {
                return v;
            }
            var QUOTE = /\"/gm;
            var QUOTE_ENCODED = '&quot;';
            var AMP = /\&/gm;
            var AMP_ENCODED = '&amp;';
            var LESSTHAN = /\</gm;
            var LESSTHAN_ENCODED = '&lt;';
            var GREATERTHAN = /\>/gm;
            var GREATERTHAN_ENCODED = '&gt;';
            return v.replace(AMP, AMP_ENCODED
                                ).replace(QUOTE, QUOTE_ENCODED
                                ).replace(LESSTHAN, LESSTHAN_ENCODED
                                ).replace(GREATERTHAN, GREATERTHAN_ENCODED);
        },
        
        
        parseUri: function (str, options) {
            options = options || parseUriOptions;
            
            var m = options.parser[((options.strictMode) ? 'strict' : 'loose')].exec(str),
                uri = {},
                i = 14;
            
            while (i--) {
                uri[options.key[i]] = m[i] || '';
            }
            
            uri[options.q.name] = {};
            uri[options.key[12]].replace(options.q.parser, function ($0, $1, $2) {
                if ($1) {
                    uri[options.q.name][$1] = $2;
                }
            });
            
            return uri;
        }

	});
	
})();

(function () {

	mstrmojo.debug = {
        
	    nocache: true,
	    
	    
	    getStackTrace: window.printStackTrace || undefined,
	    
	    
	    debug_xhr: function debug_xhr (xhrStartTime, xhrParams, xhrResponse) {
	        xhrParams = xhrParams || {};
	        xhrResponse = xhrResponse || {};
	        
	        var details = [];
	        
	        
	        if (xhrParams.taskId) {
	            details.push('taskID=' + xhrParams.taskId);
	            switch(xhrParams.taskId) {
	                case 'iPhoneGetReportResults':
	                    details.push('msgId=' + xhrParams.messageID);
	                    break;
	                    
	                case 'reportExecute':
	                    details.push('reportID=' + xhrParams.reportID);
	                    if (xhrResponse.id) {
	                        details.push('msgID=' + xhrResponse.id);
	                    }
	                    break;
	            }
	        }
	
	        
	        mstrmojo.dbg_profile('xhr completed', xhrStartTime, details.join('\t'));
	    },

        
	    	    
	    load_firebug: function( uri ) {
	        if ( typeof Firebug === "undefined" ) {
	            
                if ( (typeof uri === "undefined") || document.getElementById('FirebugLite')) return;
                
                e = document['createElement']('script');
                e.setAttribute('id', 'FirebugLite');
                e.setAttribute('src', uri + 'firebug-lite.js#startOpened');
                e.setAttribute('FirebugLite', '4');
                (document['getElementsByTagName']('head')[0] || document['getElementsByTagName']('body')[0]).appendChild(e);
	        } else {
	            
                Firebug.chrome.toggle(true );
            }
	    } 
	};
	
    mstrmojo.dbg = function dbg(s) {
        if (window.console) { 
            window.console.log(s);
        }
    };
    
    mstrmojo.dbg_profile = function dbg_profile(title, time, msg) {
        mstrmojo.dbg(title + new Array(Math.max(0, 25 - title.length)).join(' ') + 'time=' + (mstrmojo.now() - time) + 'ms\t' + (msg || ''));
    }; 
  
    mstrmojo.dbg_stack = function dbg_stack() { 
        mstrmojo.dbg(mstrmojo.debug.getStackTrace());
    };
  
    mstrmojo.dbg_xhr = function dbg_xhr(st,p,r) {
        mstrmojo.debug.debug_xhr(st,p,r);
    };
})();

(function () {

    
    mstrmojo._HasDrillLinks = mstrmojo.provide(
        'mstrmojo._HasDrillLinks',

        
        {
        	_mixinName: 'mstrmojo._HasDrillLinks',
        	
            update: function update(node) {
                this._super(node);

                var fdl = node.defn.dl,
                    ddl = node.data.dl,
                    dliRef = this.drillLinkItems = ((fdl && fdl.items) || []).concat((ddl && ddl.items) || []).sort(function (a, b) {
                        return a.index - b.index;
                    }),
                    i;

                
                
                for (i = dliRef.length - 1; i >= 0; i--) {
                    if (i && dliRef[i].index === dliRef[i - 1].index) {
                        dliRef.splice(i, 1);
                    }
                }

                if (fdl && fdl.target) {
                    for (i = 0; i < dliRef.length; i++) {
                        dliRef[i].target = fdl.target;
                    }
                }
            }
        }
    );
}());
(function() {
	mstrmojo._Fetchable = mstrmojo.provide(
			'mstrmojo._Fetchable',
			{
				_mixinName: 'mstrmojo._Fetchable',
				
				blockBegin: 1,
				
				blockCount: -1,
				
				concat: false,
				
				items: null,
				
				size: function size() {
					return this.items == null ? 0 : this.items.length;
				},
				
				totalSize: function totalSize() {
					return this.totalSize;
				},
				
				next: function(callbacks) {
					
					if (this.hasNext()) {
						this.getItems(this.blockBegin + this.blockCount, callbacks);
					}
					
				},
				
				previous: function(callbacks) {
					
					if (this.hasPrevious()) {
						var bb = this.blockBegin - this.blockCount;
						bb = bb < 0 ? 0 : bb;
						this.getItems(bb, callbacks);
					}
					
				},
				
				getItems: function(bb, callbacks){
                    callbacks = callbacks || {};
					var me = this,
					    fnEmpty = mstrmojo.emptyFn,
					    fnSuccess = callbacks.success || fnEmpty,
					    fnFail = callbacks.failure || fnEmpty;
					
					this._retrieveItems(bb, {
						
						success: function(res){
							me.blockBegin = bb;
							
							me.set('items', (me.concat? (me.items || []).concat(res.items) : res.items));
							if (res.totalSize) {
								me.totalSize = res.totalSize;
							}
							fnSuccess(me, res.items);
						},
						failure: function(res){
						    fnFail(res);
						}
					});
				},
				
				_retrieveItems: function() {
					alert("Object which mixes in this mixin has not implemented this method - _retrieveItems().");
				},
				
				hasNext: function() {
					return (((this.concat? 1 : this.blockBegin) + (this.items && this.items.length || 0)) < (this.totalSize + 1));
				},
				
				hasPrevious: function() {
					return this.blockBegin > 1;
				}
			}
	);
})();
(function () {
    
    
    function measureDimension(d, w) {
        
        if (!w.domNode) {
            return 0;
        }
        
        
        var cn = '_fixed' + d;
        
        
        if (w[cn]) {
            return w[cn];
        }
        
        
        var f = w.getFormats();
        
        
        var p = d.toLowerCase();
        
        
        if (f && p in f) {
            
            var v = f[p];
            
            
            if (v.charAt(v.length - 1) !== '%') {
                
                var px = parseInt(v, 10);
                
                
                if (!isNaN(px)) {
                    w[cn] = px;
                    return px;
                }
            }
        }
        
        
        return (w.domNode['client' + d] || 0);
    }    

    
    mstrmojo._ContainsDocObjects =
    
    {
        
        height: function height() {
            return measureDimension('Height', this);
        },
        
        
        width: function width() {
            return measureDimension('Width', this);
        },
        
        
        getMaxZIndex: function getMaxZIndex() {
            var mx = 0;
            mstrmojo.array.forEach(this.children, function (c) {
                mx = Math.max(mx, c.getFormats()['z-index']);
            });
            
            return mx;
        }
    };
})();
(function(){

    
    mstrmojo.boxmodel =
        
        {
            
    		rangeIntersect:	function rangeInt( top1,  bot1,  top2,  bot2) {
    	            if (top1 < top2) {
    	            	return top2 <= bot1;
    	            } else if (top1 > top2) {
    	            	return top1 <= bot2;
    	            } else {
    	            	return true;
    	            }
    		},
    		
    		
    		px2Inches: function px2Inches(di, v) {
    			
    			v = parseInt(v, 10);
    			
    			
    			return parseFloat((v / di.zf / di.dpi).toFixed(4), 10);
    		},
    		
            
    		offset: function offst( el,  elLimit) {
    		    var org = el,
    		    	x = 0,
                    y = 0;
                while (el) {
                    x += el.offsetLeft;
                    y += el.offsetTop;
                    el = el.offsetParent;
                    if (el === elLimit) break;
                }
                
                
                
                
                
                for (e = org && org.parentNode; e && e != elLimit; e = e.parentNode){
                	if (e.scrollTop) y -= e.scrollTop;
                	if (e.scrollLeft) x -= e.scrollLeft;
                }
                return {left: x, top: y};
    		},
    		
    		
    		convert2px: function convert2px(dom, v) {
    			
    	        if (!/px$/.test(v)) {
    	            var img = document.createElement('img'), pl;
    	            img.style.zIndex = -1;
    	            img.style.left = v;
    	            
    	            dom.appendChild(img);
    	            
    	            
    	            pl = img.style.pixelLeft;
    	            dom.removeChild(img);
    	            
    	            return pl + 'px';
    	        } else {
    	        	return v;
    	        }
    		}
    	};
})();
(function(){
    
    
    mstrmojo.hash = mstrmojo.provide(
    "mstrmojo.hash",
    {
        
        copy: function copy(src, dest) {
            if (src) {
                dest = dest || {};

                for (var n in src) {
                    dest[n] = src[n];
                }
            }
            return dest;
        },

        
        copyProps: function copyProps(ns, src, dest) {
            
            dest = dest || {};
            
            if (src) {
                
                for (var i = 0, len = (ns && ns.length) || 0; i < len; i++) {
                    var n = ns[i];
                    
                    if (n in src) {
                        
                        dest[n] = src[n];
                    }
                }
            }
            return dest;
        },
        
        
        forEach: function forEach(hash, f, scope) {
            if (hash) {
                for (var key in hash) {
                    if (scope) {
                        if (f.call(scope, hash[key], key, hash) === false) {
                            break;
                        }
                    } else {
                        if (f(hash[key], key, hash) === false) {
                            break;
                        }
                    }
                }
            }
        },
        
        
        walk: function walk(path, context) {
            if (!context) {
                context = mstrmojo.global;
            }
            var parts = path.split('.');
            if (parts.length == 1) {
                return context[path];
            }
            for (var i=0, len=parts && parts.length || 0; i<len; i++) {
                context = context[parts[i]];
                if (!context) {
                    break;
                }
            }
            return context;
        },
        
        
        isEmpty: function( hash) {
            if (!hash) {
                return true;
            }
            for (var k in hash) {
                if (hash[k] != null) {  
                    return false;
                }
            }
            return true;
        },
        
        
        clear: function clr(h){
            if (h) {
                for (var k in h){
                    delete h[k];
                }
            }
            return h;
        },
        
        
        any: function( hash,  keyOrValue) {
            if (hash) {
                for (var k in hash) {
                    return keyOrValue ? k : hash[k];
                }
            }
            return undefined;
        },

        
        clone: function cln(obj) {
            if (!obj) {
                return null;
            }
            
            var c;
            if (obj.constructor === Array) {
                
                c = obj.concat();
                
                var first = c[0];
                if (first && typeof(first) === 'object') {
                    for (var i=0, len=c.length; i<len; i++){
                        c[i] = this.clone(obj[i]);
                    }
                }
            } else {
                
                c = {};
                for (var k in obj) {
                    var v = obj[k];
                    
                    if (v && typeof(v) == 'object') {
                        
                        c[k] = this.clone(v);
                    } else {
                        
                        c[k] = v;
                    }
                }
            }
            return c;
        },
        
        
        cloneArray: function clnArr( arr) {
            var arr2 = [];
            for (var i=0, len=(arr&&arr.length)||0; i<len; i++) {
                arr2[i] = this.clone(arr[i]);
            }
            return arr2;
        },

        
        keyarray: function kyarr(h, nums) {
            var arr = [];
            if (h) {
                for (var k in h) {
                    arr.push(nums ? Number(k) : k);
                }
            }
            return arr;
        },
        
        
        valarray: function varr(h){
            var arr = [];
            if (h) {
                for (var k in h) {
                    arr.push(h[k]);
                }
            }
            return arr;
        },
        
        equals: function eq(h1, h2) {
            
            var _H = mstrmojo.hash,
                _rslt = h1 && h2 || (!h1 && !h2 && (h1 === h2));
            
            if (_rslt && h1) {
                
                _rslt = (h1.constructor === h2.constructor);
                if (_rslt) {
                    
                    if (h1.constructor === Array) {
                        var len = h1.length;
                        
                        _rslt = (len === h2.length);
                        
                        if (_rslt && len){
                            
                            for (var i = 0; i < len; i ++) {
                                _rslt = _rslt && _H.equals(h1[i], h2[i]);
                            }
                        }
                    
                    } else if (typeof (h1) === 'object'){
                        
                        var h1k = _H.keyarray(h1),
                            h2k = _H.keyarray(h2);
                        _rslt = h1k.length === h2k.length;
                        if (_rslt){
                            for (var p in h1){
                                _rslt = _rslt && (_H.equals(h1[p], h2[p]));
                            }
                        }
                    
                    } else {
                        _rslt = (h1 === h2);
                    }
                }
            }
            return _rslt;
        },
        
        obj2array: function(o){
           for(var n in o){
              var p = o[n];
              if(p && typeof(p) == 'object'){
                  o[n] = this.obj2array(p);
              } 
           }
           if('isArray' in o && (o.isArray === true)){
               var r = [];
               for(var i=0,len=o.length;i<len;i++){
                   r.push(o[i]);   
               }
               return r;
           } else {
               return o;   
           }
        },
        
        
        
        min: function min(h, vals, nums){
            var m;
            if (h) {
                for (var k in h){
                    var v = vals ? h[k] : k;
                    if (nums) {
                        v = Number(v);
                    }
                    if ((m == null)||(v < m)){
                        m = v;
                    }
                }
            }
            return m;
        },
        
        
        make: function mk(h, c, props) {
            if (!h || !c) {
                return null;
            }
            if (h.attachEventListener) {
                
                return h;
            }
            if (c.makeObservable) {
                h = c.makeObservable(h, props) || h;
            } else {
                this.copy(c.prototype, h);
                if (h.init) {
                    h = h.init(props) || h;
                }
            }
            return h;
        }
    });
    
})();
(function () {

    var $MATH = Math;

    
    function _evt(hWin, e) {
        return e || (hWin || window).event;
    }

    
    var isIE = !!document.all,
        ua = navigator.userAgent,
        isFF = !isIE && !!ua.match(/Firefox/),
        bv = 0,
        isAndroid = !!ua.match(/Android/),
        isIPad = !!ua.match(/iPad/),
        tch = !!document.createTouch || isAndroid,
        isPlayBook = !!ua.match(/PlayBook/),
        isWinPhone = !!ua.match(/Windows Phone/),
        isIE10 = isIE && !!ua.match(/MSIE 10/),
        isIEW3C = !isIE && !!ua.match(/Trident.*rv/),
        isDXIE = isIE && !isIE10,
        CSS3_PREFIX = isFF ? '-moz-' :
                             isIE ? '' : '-webkit-',
        CSS3_TRANSFORM_PREFIX = isFF ? 'Moz' :
                                       isIE10 ? '' :
                                                isIE ? 'ms' : 'webkit',
        CSS3_T_INITIAL = (isIE10 ? 't' : 'T'),
        CSS3_TRANSITION = CSS3_TRANSFORM_PREFIX + CSS3_T_INITIAL + 'ransition', 
        CSS3_TRANSFORM = buildCSS3Transform(),
        CSS3_TRANSITION_PROPERTY = buildCSS3TransitionProperty(),
        CSS3_TRANSITION_DURATION = buildCSS3TransitionDuration(),
        CSS3_TRANSITION_END = buildCSS3TransitionEnd(),   
        CSS3_BOXSHADOW = buildCSS3BoxShadow();
        
    function buildCSS3Transform(){
        
        

        return CSS3_TRANSFORM_PREFIX + CSS3_T_INITIAL + 'ransform';
    }
    
    function buildCSS3TransitionProperty(){
        
        

        return CSS3_TRANSITION + 'Property';
    }     
    
    function buildCSS3TransitionDuration(){
        
        

        return CSS3_TRANSITION + 'Duration';
    }
    
    function buildCSS3TransitionEnd(){
        
        
        
        return (isIE10 || isFF) ? 'transitionend' :  'webkitTransitionEnd';
    }   
    

    function buildCSS3BoxShadow(){
        
        
        
        return CSS3_TRANSFORM_PREFIX + 'BoxShadow';
    }    
    

    
    function getBrowserVersion() {
        
        if (!bv && isFF) {
            
            
            var nav = ua.match(/.*Firefox\/([\d|\.]*).*/);
            
            if (nav) {
                
                bv = parseFloat(nav[1], 10);
            }
        }

        return bv;
    }

    function _docScroll() {
        var x = 0,
            y = 0,
            w = window,
            d = document,
            b = d.body,
            de = d.documentElement;
        if (typeof w.pageYOffset == 'number') {
            y = w.pageYOffset;
            x = w.pageXOffset;
        } else if (b && (b.scrollLeft || b.scrollTop)) {
            y = b.scrollTop;
            x = b.scrollLeft;
        } else if (de && (de.scrollLeft || de.scrollTop)) {
            y = de.scrollTop;
            x = de.scrollLeft;
        }
        return {
            x: x,
            y: y
        };
    }

    function setTranslateValue(num) {

        
        num = num || 0;

        
        num = String(num);

        return ((num.indexOf("%", 0)) != -1) ? num : (num + 'px');
    }

    function createTransformationString(x, y, z, use3d, translateString) {

        if (!mstrmojo.dom.isWinPhone) {
            use3d = (use3d || false || this.isHWAccelerated);
        } else {
            use3d = false;
        }

        var translateOpen = translateString + (use3d ? '3d' : '') + '(',
            translateClose = use3d ? (',' + z + ')') : ')';

        return translateOpen + x + ',' + y + translateClose;
    }
    
    var TOP = 1, 
        BOTTOM = 2,
        CENTER = 3,
        LEFT = 4,
        RIGHT = 5;
    
    
    function alignDOM(e, h, v) {
        var es = e.style,
            eds = es.display,
            wdim = this.windowDim(),
            ds = _docScroll();
        
        
        es.display = 'block';
        
        var hpos = wdim.w - e.clientWidth,
            vpos = wdim.h - e.clientHeight,
            hm = {
                4: 0, 
                5: hpos, 
                3: hpos/2 
            },
            vm = {
                1: 0, 
                3: vpos/2, 
                2: vpos 
            };
        
        es.left = hm[h] + ds.x + 'px';
        es.top = vm[v] + ds.y + 'px';
        es.display = eds;
    }

    mstrmojo.Enum_Keys = {
        
        
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        CTRL: 17,
        ESCAPE: 27,
        SPACE: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT_ARROW: 37,
        UP_ARROW: 38,
        RIGHT_ARROW: 39,
        DOWN_ARROW: 40,
        INSERT: 45,
        DELETE: 46
    };

    mstrmojo.dom = mstrmojo.provide(
        "mstrmojo.dom",
        {
            userAgent: ua,

            isIE: isIE,

            isIE6: isIE && !!ua.match(/MSIE 6/),
            isIE7: isIE && !!ua.match(/MSIE 7/),
            isIE8: isIE && !!ua.match(/MSIE 8/),
            isIE9: isIE && !!ua.match(/MSIE 9/),
            isIE10: isIE10,
            isIEW3C: isIEW3C,
            isNSIE: isIE && !isIE10, 
            isDXIE: isDXIE,

            isFF: isFF,

            isWK: !!ua.match(/AppleWebKit/),

            isSafari: !!ua.match(/Safari/) && !ua.match(/Chrome/),

            isHWAccelerated: !isAndroid,

            isAndroid: isAndroid,

            isIPad: isIPad,

            isPlayBook: isPlayBook,

            isWinPhone: isWinPhone,

            supportsTouches: tch,

            TOUCHSTART: tch ? 'touchstart' : 'mousedown',
            TOUCHMOVE: tch ? 'touchmove' : 'mousemove',
            TOUCHEND: tch ? 'touchend' : 'mouseup',
            TOUCHCANCEL: tch ? 'touchcancel' : '',
            RESIZE: tch ? 'orientationchange' : 'resize',

            CSS3_PREFIX: CSS3_PREFIX, 
            CSS3_BOXSHADOW: CSS3_BOXSHADOW,
            CSS3_TRANSFORM: CSS3_TRANSFORM,
            CSS3_TRANSITION: CSS3_TRANSITION,
            CSS3_TRANSITION_PROPERTY: CSS3_TRANSITION_PROPERTY,
            CSS3_TRANSITION_DURATION: CSS3_TRANSITION_DURATION,
            CSS3_TRANSITION_END: CSS3_TRANSITION_END,
                    
            cssFeatures: {
                GRADIENTS: 'gd',
                ROUND_CORNERS: 'rc',
                TEXT_ROTATION: 'tr',
                DROP_SHADOW: 'sh'
            },

            
            supports: function supports(f) {
                var ffVer = this.isFF && getBrowserVersion();
                switch (f) {
                case this.cssFeatures.GRADIENTS:
                    return (this.isIE || this.isIEW3C || this.isWK || ffVer >= 3.6 || this.isWinPhone);

                case this.cssFeatures.ROUND_CORNERS:
                    return (this.isWK || this.isFF || this.isWinPhone || this.isIE10);

                case this.cssFeatures.TEXT_ROTATION:
                case this.cssFeatures.DROP_SHADOW:
                    return (this.isIE || this.isWK || ffVer >= 3.5 || this.isWinPhone || this.isIE10 || this.isIEW3C);
                }

                return false;
            },

            
            replace: function dom_repl( target,  replacement) {
                if (!target || !replacement) {
                    return;
                }

                var p = target.parentNode;
                if (p) {
                    p.replaceChild(replacement, target);
                }
            },

            
            attachEvent: function dom_attch(el, eventName, f, phase) {
                if (el.addEventListener) {
                    return el.addEventListener(eventName, f, !!phase);
                } else {
                    return el.attachEvent("on"+eventName, f);
                }
            },
    
            
            detachEvent: function dom_detach( el,  eventName,  f, phase) {
                if (!el) {
                    return;
                }
    
                if (el.removeEventListener) {
                    el.removeEventListener(eventName, f, !!phase);
                } else {
                    el.detachEvent("on" + eventName, f);
                }
            },
    
            attachOneTimeEvent: function attachOneTimeEvent(el, eventName, f, phase) {
                
                var fn = function(evt) {
                    
                    f(evt);
    
                    
                    mstrmojo.dom.detachEvent(this, eventName, fn, phase);
                };
    
                
                this.attachEvent(el, eventName, fn, phase);
    
                
                el = null;
    
                return fn;
            },
    
            
            captureDomEvent: function captureDomEvent(id, type, hWin, e, config) {
                var x = mstrmojo.all[id];
                if (x) {
                    x.captureDomEvent(type, hWin, e, config);
                }
            },
    
    
            
            translate: function translate(el, x, y, z, extra, useTranslate3d) {
                extra = (extra && ' ' + extra) || '';
    
                el.style[((mstrmojo.dom.isWinPhone || mstrmojo.dom.isIE9 || mstrmojo.dom.isIE10) ? 'ms' : 'webkit') + 'Transform'] = this.createTranslateString(x, y, z, useTranslate3d) + extra;
            },
    
    
            createTranslateString: function createTranslateString(x, y, z, useTranslate3d) {
    
                
                x = setTranslateValue(x);
                y = setTranslateValue(y);
                z = setTranslateValue(z);
    
                return createTransformationString(x, y, z, useTranslate3d, 'translate');
            },
    
            createScaleString: function createScaleString(x, y, z, useScale3d) {
    
                
                x = x || 0;
                y = y || 0;
                z = z || 0;
    
                return createTransformationString(x, y, z, useScale3d, 'scale');
            },
    
            
            _bufferSize: 200,
    
            
            _bufferConnects: {},
    
            
            attachBufferedEvent: function dom_attchbuf( el,  eventName,  f,  bufferSize) {
    
                var key = el.id+"-"+eventName,
                    info = this._bufferConnects[key];
                if (!info) {
                    info = this._bufferConnects[key] = {
                        elId: el.id,
                        eventName: eventName,
                        timer: null,
                        bufferSize: bufferSize,
                        listeners: [],
                        callback:     function(e) {
                                        mstrmojo.dom._callback(e, mstrmojo.global, key);
                                        return true;
                                    }
                    };
                    this.attachEvent(el, eventName, info.callback);
                }
                info.listeners.push(f);
            },
    
            _callback: function dom_callback( e,  hWin,  key) {
                
                if (!e) {
                    e = hWin.event;
                }
                var info = this._bufferConnects[key],
                    timer = info && info.timer;
                if (info && !timer) {
                    var ms = (info.bufferSize === null) ? this._bufferSize : info.bufferSize;
    
                    if (info.bufferSize) {
                        info.timer = hWin.setTimeout(
                                        function() {mstrmojo.dom.updateBuffers(key);},
                                        ms
                                   );
                    } else {
                        
                        mstrmojo.dom.updateBuffers(key);
                    }
                }
            },
    
            updateBuffers: function dom_updateBuffers( key) {
                var info = this._bufferConnects[key],
                    ls = info && info.listeners;
                for (var i=0, len=ls && ls.length || 0; i<len; i++) {
                    ls[i]();
                }
                if (info && info.timer) {
                    delete info.timer;
                }
            },
    
            detachBufferedEvent: function dom_dtchbuf( el,  eventName,  f) {
                if (!el) {
                    return;
                }
    
                var key = el.id+"-"+eventName,
                    info = this._bufferConnects[key],
                    ls = info && info.listeners,
                    len = (ls && ls.length) || 0;
                if (len) {
                    for (var i=len-1; i>-1; i--) {
                        if (ls[i] == f) {
                            ls.splice(i,1);
                        }
                    }
                    
                    
                    if (!ls.length) {
                        this.detachEvent(el, eventName, info.callback);
                        delete this._bufferConnects[key];
                        if (info.timer) {
                            mstrmojo.global.clearTimeout(info.timer);
                        }
                    }
                }
            },
    
            
            eventTarget: function evtTgt( hWin,  e) {
                e = _evt(hWin, e);
                return e.target || e.srcElement;
            },
    
            
            ctrlKey: function ctrl( hWin,  e) {
                return _evt(hWin, e).ctrlKey;
            },
    
            
            shiftKey: function shift( hWin,  e) {
                return _evt(hWin, e).shiftKey;
            },
            
            
            getButton: function getButton( hWin,  e) {
                return ((_evt(hWin, e)).button == 2) ? 2 : 1;    
            },
    
            getMousePosition: function getMousePosition(e, hWin) {
                hWin = hWin || window;
    
                var x, y;
                if (mstrmojo.dom.isIE) {
                    e = e || hWin.event;
                    
                    var d = document,
                        b = d.body,
                        de = d.documentElement;
                    x = e.clientX + b.scrollLeft + (de.scrollLeft || 0);
                    y = e.clientY + b.scrollTop + (de.scrollTop || 0);
                } else {
                    
                    x = e.pageX;
                    y = e.pageY;
                }
    
                return { "x" : x, "y" : y };
            },
    
            
            position: function(el, includeScroll) {
                var p = {
                    x: 0,
                    y: 0
                };
    
                
                if (el && el.getBoundingClientRect) {
                    try {
                        
                        p = el.getBoundingClientRect();
                    } catch (e) {
                        p = {
                            left: 0,
                            top: 0,
                            right: 0,
                            bottom: 0,
                            height: 0,
                            width: 0
                        };
                    }
    
                    
                   p = {
                       x: p.left,
                       y: p.top,
                       w: p.right - p.left,
                       h: p.bottom - p.top
                   };
    
                   
                   if (this.isIE6 || this.isIE7) {
                       
                       var ownerDocument = el.ownerDocument;
                       if (ownerDocument) {
                           
                           var de = ownerDocument.documentElement,
                               deo = de.getBoundingClientRect();
                           p.x -= deo.left;
                           p.y -= deo.top;
                       }
                   }
                }
    
                
                if (includeScroll) {
                    var ds = _docScroll();
                    p.x += ds.x;
                    p.y += ds.y;
                }
    
                return p;
            },
    
            
            delta: function delta( el,  elLimit) {
                elLimit = elLimit || document.body;
                var pe = this.position(el),
                    pr = this.position(elLimit);
    
                return {x: Math.round(pe.x - pr.x), y: Math.round(pe.y - pr.y)};
            },
    
            
            windowDim: function _winDim() {
                var w = 0,
                    h = 0,
                    win = window,
                    d = document,
                    de = d.documentElement,
                    db = d.body;
                if (typeof(win.innerWidth) == 'number') {
                  w = win.innerWidth;
                  h = win.innerHeight;
                } else if (de  && (de.clientWidth || de.clientHeight)) {
                  w = de.clientWidth;
                  h = de.clientHeight;
                } else if (db && (db.clientWidth || db.clientHeight)) {
                  w = db.clientWidth;
                  h = db.clientHeight;
                }
                return {w:w,h:h};
            },
    
            
            center: function center(e) {
                alignDOM.call(this, e, CENTER, CENTER);
            },
            
            
            bottomCenter: function bottomCenter(e) {
                alignDOM.call(this, e, CENTER, BOTTOM);
            },
    
            
            clearBrowserHighlights: function clrHiLits( hWin) {
                hWin = hWin || self;
                if (isIE) {
                    var doc = hWin.document,
                        sel = doc && doc.selection,
                        em = sel && sel.empty;
                    if (em) {
                        try {
                            sel.empty();
                        } catch(ex) {
                            
                        }
                    }
                }
                else {
                    var gs = hWin.getSelection,
                        s = gs && hWin.getSelection();
                    if (s && !s.isCollapsed) {
                        if (s.empty) {
                            s.empty();
                        } else if (s.removeAllRanges) {
                            s.removeAllRanges();
                        }
                    }
                }
            },
    
            
            findAncestorByAttr: function fndAncAttr( el,  attr,  inclusive,  elLimit) {
                var node = inclusive ? el : el && el.parentNode;
                while (node && (node != elLimit)) {
                    var v = node.getAttribute && node.getAttribute(attr);
                    if (v != null) {
                        return {
                                node: node,
                                value: v
                        };
                    }
                    node = node.parentNode;
                }
                return null;
            },
    
            
            findAncestorByName: function fndAncNm( el,  nodeName,  inclusive,  elLimit) {
                nodeName = nodeName && nodeName.toLowerCase();
                var node = inclusive ? el : el && el.parentNode;
                while (node && (node != elLimit)) {
                    var n = node.nodeName;
                    if (n && (n.toLowerCase() == nodeName)) {
                        return node;
                    }
                    node = node.parentNode;
                }
                return null;
            },
    
            
            contains: function cntns( elP,  elC,  inclusive,  elLimit) {
                var node = elC;
    
                
                if (!inclusive) {
                    
                    node = node.parentNode;
                }
    
                while (node) {
                    
                    if (node == elP) {
                        return true;
                    }
    
                    
                    if (node === elLimit) {
                        break;
                    }
    
                    
                    node = node.parentNode;
                }
    
                return false;
            },
    
            preventDefault: function prvDft(hWin, e) {
                if (!e) {
                    e = hWin.event;
                }
                if (e.preventDefault) {
                    e.preventDefault();
                }else{
                    e.returnValue = false;
                }
            },
    
            stopPropogation: function stpPrg(hWin, e) {
                if (!e) {
                    e = hWin.event;
                }
                if (e.stopPropogation) {
                    e.stopPropogation();
                } else {
                    e.cancelBubble = true;
                }
            },
    
            firstTouch: function fstTch(hWin, e) {
                return e && e.touches && e.touches.length ? e.touches[0] : (e || hWin.event);
            },
    
            firstChangedTouch: function fstChTch(hWin, e) {
                return e && e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : (e || hWin.event);
            },
    
            isLandscape: function isLandscape() {
                return !this.supportsTouches || (Math.abs(window.orientation) === 90);
            },
    
            
            findWidget: function(el) {
                while (el) {
                    var id = el.mstrmojoId;
                    if (id != null) {
                        return mstrmojo.all[id];
                    }
                    el = el.parentNode;
                }
                return null;
            },
    
            
            setCaret: function (el, pos) {
                if (el.setSelectionRange) {
                    el.focus();
                    el.setSelectionRange(pos, pos);
                }
                else if (el.createTextRange) { 
                    var tr = el.createTextRange();
                    tr.move("character", pos);
                    tr.select();
                }
            }

    });
    
    var G = mstrmojo.dom,
        w = window,
        d = document,
        de = d && d.documentElement,
        b = d && d.body ;
    







    
    if (w.innerWidth) { 


        G.getHorizontalScroll = function() { return w.pageXOffset;};
        G.getVerticalScroll = function() { return w.pageYOffset;};
    } else if (de && de.clientWidth) {
    


        G.getHorizontalScroll = function() { return de.scrollLeft;};
        G.getVerticalScroll = function() { return de.scrollTop;};
    } else if (b.clientWidth) {
    


        G.getHorizontalScroll = function() { return b.scrollLeft;};
        G.getVerticalScroll = function() { return b.scrollTop;};
    }
    








})();
(function () {

    
    function setFullScreenStatus(isEnter, animate, isFlash) {
        
        if (!isFlash && isEnter === !!this._inFullScreen) {
            
            return;
        }

        
        delete this._inFlash;

        
        var domNode = this.domNode;
        if (!domNode) {
            
            return;
        }

        var domNodeStyle = domNode.style,
            isMain = !!this.controller,
            me = this,
            styleProp = (this.fullscreenDirection === 'up') ? 'top' : 'bottom',
            fnPosition = function () {
                
                domNodeStyle.position = isEnter ? 'absolute' : 'static';

                
                if (isMain) {
                    
                    mstrApp.rootView.doLayout();
                }
            },
            fnStatusBar = function () {
                
                if (isMain) {
                    
                    mstrMobileApp[(isEnter ? 'enter' : 'exit') + 'FullScreen']();
                }
            };

        
        if (!isFlash) {
            
            this._inFullScreen = isEnter;

            
            if (isEnter || !animate) {
                
                fnPosition();
            }
        }

        
        if (!isEnter) {
            
            if (parseInt(domNodeStyle[styleProp], 10) === 0) {
                
                fnPosition();

                
                fnStatusBar();

                return;
            }

            
            if (isFlash) {
                
                this._inFlash = true;
            }
        }

        
        if (animate) {
            
            mstrmojo.dom.attachOneTimeEvent(domNode, 'webkitTransitionEnd', function () {
                
                if (!isEnter) {
                    
                    if (!isFlash) {
                        
                        fnPosition();

                    } else {
                        
                        me._flashHandle = window.setTimeout(function () {
                            
                            delete me._flashHandle;

                            
                            setFullScreenStatus.call(me, true, true, true);
                        }, 3000);

                    }
                }else{
                	if(me.onEnterFullScreenEnd){
                		me.onEnterFullScreenEnd();
                	}
                }

                
                if (!isFlash) {
                    
                    fnStatusBar();
                }
            });
        } else {
            
            fnStatusBar();
        }


        
        this['on' + (isEnter ? 'Enter' : 'Exit') + 'FullScreen']();

        
        domNodeStyle.webkitTransitionDuration = animate ? '' : 0;

        
        domNodeStyle[styleProp] = isEnter ? -domNode.offsetHeight + 'px' : 0;


    }

    
    function clearFlashHandle() {
        
        var handle = this._flashHandle;
        if (handle) {
            
            window.clearTimeout(handle);

            
            delete this._flashHandle;
        }
    }

    
    mstrmojo.android.ui._CanBeFullScreen = mstrmojo.provide(

        "mstrmojo.android.ui._CanBeFullScreen",

        
        {
            
            fullscreenDirection: 'up',

            
            onEnterFullScreen: mstrmojo.emptyFn,

            
            onExitFullScreen: mstrmojo.emptyFn,

            
            resetFullScreen: function resetFullScreen() {
                
                if (this._inFullScreen) {
                    
                    delete this._inFullScreen;

                    
                    setFullScreenStatus.call(this, true, false);
                }
            },

            
            enterFullScreen: function enterFullScreen() {
                
                setFullScreenStatus.call(this, true, true);
            },

            
            flashFullScreen: function flashFullScreen() {
                
                if (this._inFullScreen && !this._inFlash) {
                    
                    setFullScreenStatus.call(this, false, true, true);
                }
            },

            
            exitFullScreen: function exitFullScreen(animate) {
                
                clearFlashHandle.call(this);

                
                setFullScreenStatus.call(this, false, animate);
            },

            
            cancelFlashFullScreen: function cancelFlashFullScreen() {
                
                if (this._inFullScreen && this._inFlash) {
                    
                    clearFlashHandle.call(this);

                    
                    setFullScreenStatus.call(this, true, false, true);
                }
            }
        }
    );
}());
(function() {
    
    mstrmojo.StringBuffer = mstrmojo.declare(
        null, 
        null,
        
        {
            scriptClass: 'mstrmojo.StringBuffer',
            
            
            append: function append(txt) {
                if (!this.buf) {
                    this.reset();
                }
                this.buf[++this.len] = txt;
                return this; 
            },
            
            
            reset: function reset() {
                this.buf = [];
                this.len = -1;
            }
        }
    );

        
    mstrmojo.StringBuffer.prototype.toString = function(sep) {
        var buf = this.buf;
        return (buf && buf.join(sep || '')) || '';         
    }
})();
(function() {
    
    
    mstrmojo._HasRelativeUrls = 
        
        {
            _mixinName: 'mstrmojo._HasRelativeUrls', 
            
            
            relativeUrls: [], 
            
            
            update: function update(node) {
                this._super(node);
                
                var me = this,
                    doc = me.builder.parent,
                    hostUrl = mstrApp.getConfiguration().getHostUrlByProject(mstrApp.getCurrentProjectId());

                
                mstrmojo.array.forEach(this.relativeUrls, function (p) {
                    
                    var url = me[p];
                    
                    
                    if (url && (url.indexOf('://') === -1 && url.indexOf('data:') !== 0)) {
                        
                        me[p] = hostUrl + url;
                    }
                });
            }
                
        };
    
})();
(function() {
    mstrmojo._HasTooltip = mstrmojo.provide(
            'mstrmojo._HasTooltip',
            {

            
            tooltip: '',
            
            
            richTooltip: null,
            
            useRichTooltip: false,
            
            tooltipNode: null,
            
            postBuildRendering: function() {
                var ret;
                if (this._super) {
                    ret = this._super();
                }
                    
                if (this.useRichTooltip){
                    var d = this.tooltipNode || this.domNode,
                        dom = mstrmojo.dom,
                        ttl = d && d.getAttribute('title');
                    
                    if (ttl) {
                        d.setAttribute('title', '');
                    }
                    
                    if (!this._ontooltipover){
                        var id = this.id;
                        this._ontooltipover = function(e) {
                            var me = mstrmojo.all[id];
                            me.showTooltip(e, self);
                        };
                        this._ontooltipout = function(e) {
                            var me = mstrmojo.all[id];
                            me.hideTooltip(e, self);
                        };
                    }
                    dom.attachEvent(d, 'mouseover', this._ontooltipover);
                    dom.attachEvent(d, 'mouseout', this._ontooltipout);
                }
                return ret;
            },
            
            showTooltip: function(e, win) {
                mstrmojo.requiresCls("mstrmojo.tooltip");
                mstrmojo.tooltip.open(this, e, win);
            },
            
            hideTooltip: function(e, win) {
                mstrmojo.requiresCls("mstrmojo.tooltip");
                mstrmojo.tooltip.close();
            },
            
            unrender: function(ignoreDom) {
                var d = this.tooltipNode || this.domNode,
                dom = mstrmojo.dom;
                
                if (d && this._ontooltipover){
                    dom.detachEvent(d, 'mouseover', this._ontooltipover);
                }
                if (d && this._ontooltipout) {
                    dom.detachEvent(d, 'mouseout', this._ontooltipout);
                }
                if (this._super) {
                    this._super(ignoreDom);
                }
                
            }
    });
})();
(function(){

        
    mstrmojo._IsPopup = {
    
        
        visible: false,
        
        
        opener: null,
        
        
        onOpen: null,

        
        onClose: null,
        
        
        open: function open( opener,  config) {
            
            
            if (this.updatePopupConfig) {
                this.updatePopupConfig(config, opener);
            } else     if (config) {
                for (var k in config) {
                    this.set(k, config[k]);
                }
            }
            
            
            this.set('opener', opener);
            if (!this.hasRendered) {
                this.render();
            }
            
            
            if (this.nudge) {
                this.domNode.style.top = '-10000px';
            }
            
            
            this.set('visible', true);
            
            
            if (this.nudge) {
                this.nudge();
            }
            
            
            if (this.onOpen) {
                this.onOpen();
            }
        },
        
        
        close: function cls(config) {
            
            if (this.onClose) {
                this.onClose(config);
            }

            this.set('visible', false);
            this.set('opener', null);
        }
    };
    
})();
(function() {
	mstrmojo.requiresCls("mstrmojo.hash","mstrmojo.string", "mstrmojo.StringBuffer");

	
	mstrmojo._XMLNode = mstrmojo.declare(null, null ,
		{
			nodeName: null,
			init: function init(props) {
		        
				mstrmojo.hash.copy(props, this);    
			},
			addChild: function addChild(nodeName)
			{
				var child = new mstrmojo._XMLNode({nodeName: nodeName});
				return this.appendNode(child);
			},

			appendNode: function appendNode(node)
			{
				if (node)
				{
					if (!this.children)
					{
						this.children = [];
					};
					this.children.push(node);
					node.parent = this; 
				};
				return node;
			},
			
			addAttribute: function addAttribute(name, value)
			{
				if (name != null)
				{
					if (!this.attributes)
					{
						this.attributes = {};
					};
					this.attributes[name] = value;
				};
				return this;
			},
			
			addText: function addText(text)
			{
				this._addToStringMember('text', text);
				return this;
			},

			addRawXML: function addRawXML(xml)
			{
				this._addToStringMember('rawXML', xml);
				return this;
			},
			getXMLString: function getXMLString() {
				var buf = new mstrmojo.StringBuffer();
				this.buildXMLString(buf);
				return buf.toString();
			},
			buildXMLString: function buildXMLString(buf)
			{
				buf = buf || new mstrmojo.StringBuffer();
				buf.append('<')
					.append(this.nodeName )
					.append(' ');
					this._buildAttributesXMLString(buf)
					.append('>')
						.append(((this.text != null) ? this._escapeString(this.text) : ''))
						.append(((this.rawXML != null) ? this.rawXML : ''));
						this._buildChildrenXMLString(buf)
					.append('</')
					.append(this.nodeName) 
					.append('>');
						
				return buf;
			},

			
			
			_buildAttributesXMLString: function buildAttributesXMLString(arr)
			{
				var attrs = this.attributes;
				if (attrs)
				{
					for (var id in attrs)
					{
						if (attrs[id] != null)
						{
							var v = String(attrs[id]);
							switch(id) {
							case 'et':
							case 'nt':
							case 'dmt':
							case 'ddt':
							case 'fnt':
							case 'tp':
							case 'stp':
								break;
							default:
								v = this._escapeString(v);
							}
							arr.append(id + '="' + v + '" ');
						};
					};
				};
				return arr;
			},
			
			_escapeString: function escapeString(v) {
				return mstrmojo.string.escape4HTMLText(v);
			},
			
			_buildChildrenXMLString: function buildChildrenXMLString(arr)
			{
				var c = this.children;
				var len = c && c.length;
				if (len)
				{
					for (var i = 0; i < len; i++)
					{
						if (c[i] && c[i].buildXMLString) {
							c[i].buildXMLString(arr);
						}
					};
				};
				return arr;
			},
			
			_addToStringMember: function addToStringMember(memberName, str)
			{
				var val = this[memberName];
				if (val == null)
				{
					this[memberName] = str;
				}
				else
				{
					this[memberName] = val + str;
				};
			}
	});
	mstrmojo.XMLBuilder = mstrmojo.declare(null, null, {
		
		root: null,
		
		curNode: null,
		
		addChild: function addChild(nodeName)
		{
			if (!this.root){
				this.currentNode = this.root = new mstrmojo._XMLNode({nodeName: nodeName});
				
			} else {
				this.currentNode = this.currentNode.addChild(nodeName);
				
			}
			return this;
		},
		
		appendNode: function appendNode(node)
		{
			if (!this.root){
				this.currentNode = this.root = node;
				
			} else {
				this.currentNode = this.currentNode.appendNode(node);
			}
			return this;
		},
		
		addAttribute: function addAttribute(name, value)
		{
			if (this.currentNode){
				this.currentNode.addAttribute(name, value);
			} else {
				alert('no root node');
			}
			return this;
		},
		
		addText: function addText(text)
		{
			if (this.currentNode){
				this.currentNode.addText(text);
			} else {
				alert('no root node');
			}
			return this;
		},
		
		addRawXML: function addRawXML(xml)
		{
			if (this.currentNode){
				this.currentNode.addRawXML(xml);
			} else {
				alert('no root node');
			}
			return this;
		},
		
		closeElement: function closeElement() {
			this.currentNode = this.currentNode.parent;
		},
		
		toString: function toString() {
			if (this.root) {
				return this.root.getXMLString();
			} else {
				return '';
			}
		}
			
	}
	);
})();
(function() {
    
    mstrmojo.requiresCls("mstrmojo.StringBuffer",
                         "mstrmojo.hash");
    
    var CLASS_NAME = 'AndroidServerTransport';
    
    
    mstrmojo.android.AndroidServerTransport = {
            
        
        serverRequest: function serverRequest(id, requestId, request) {
            
            var url = new mstrmojo.StringBuffer(),
                urlStr, rqst;
            mstrmojo.hash.forEach(request.params, function (v, n) {
                url.append(n + '=' + encodeURIComponent(v));
            });
            urlStr = request.taskURL + '?' + url.toString('&');
            request.params.hostUrl = request.taskURL;
            if ( mstrApp.useBinaryFormat) {
                rqst = JSON.stringify({
                    params: request.params,
                    url: urlStr
                });
            } else {
                rqst = urlStr;
            }
            
            $MAPF(true, CLASS_NAME, 'transportRequest');
            
            
            mstrMobileTransport.serverRequest(id, requestId, rqst, 'response', 'progress');
        },
        
        
        cancelRequest: function cancelRequest(requestId) {
            $MAPF(false, CLASS_NAME, 'transportRequest');
            
            return mstrMobileTransport.cancelRequest(requestId);
        }
    };
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.array",
                         "mstrmojo.hash",
                         "mstrmojo.StringBuffer");

    var $D = mstrmojo.dom,
        $H = mstrmojo.hash,
        $A = mstrmojo.array;

    
    function destroyInfoWindows() {
        
        $H.forEach(this.ifwMap, function (infoWindow) {
            infoWindow.destroy();
        });

        
        this.ifwMap = {};
    }

    
    function recordInfoWins() {
        var ifwrds = [],
            sellyt = null,
            docScroll = null;
        $H.forEach(this.ifwMap, function (ifw) {
            if (ifw.visible) {
                ifwrds.push({
                    psId: ifw.psId,
                    psKey: ifw.psKey,
                    anchorPos: ifw.anchorPosition || $D.position(ifw.anchor, true),
                    anchorOrn: ifw.anchorOrientation
                });
            }
        });
        
        if (ifwrds.length > 0) {
            sellyt = this.getSelectedLayoutWidget();
            docScroll = sellyt && sellyt.getScrollPos();
        }
        
        return {ifwRecords: ifwrds, docScrollRecord: docScroll};
    }
    
    
    function restoreInfoWins(rd) {
        var ifwrds = (rd && rd.ifwRecords) || [],
            docScroll = rd && rd.docScrollRecord,
            sellyt = this.getSelectedLayoutWidget(),
            me = this,
            fakeAnchor= {};
        
        if (ifwrds.length > 0) {
            if (docScroll && sellyt) {
                sellyt.scrollTo(docScroll);
            }
            
            $A.forEach(ifwrds, function (rd) {
                me.showInfoWindow(rd.psId, rd.psKey, fakeAnchor, null, rd.anchorOrn, rd.anchorPos)
            })
        }
    }

    
    function destroyPopups() {
        mstrmojo.DICPopup && mstrmojo.DICPopup.cancel && mstrmojo.DICPopup.cancel();
    }
    
    function clearXtabStyleSheet() {
        
        if (this.xtabStyleSheets) {
            var stylesheet, i, parentNode;
            for (i = 0; stylesheet = this.xtabStyleSheets[i]; i++) {
                parentNode = stylesheet.parentNode;
                if (parentNode) {
                    parentNode.removeChild(stylesheet);
                }
            }
        }
    }

    function updateDocGroupBy(layoutKey, gbys) {
    	var layout = this.getLayout(layoutKey),
            docGB = layout.docGroupBy,
            ctrl = this.controller;

    	if (docGB) {
    		docGB.set('data', gbys.groupbys);
    		layout.gb = gbys;
    	}

        if (ctrl.getPageByTree) {  
            ctrl.getPageByTree(true);
        }
    }

    
    mstrmojo._IsRwDocument = {

        _mixinName: 'mstrmojo._IsRwDocument',

        
        updateXtabStyles: function updateXtabStyles(layoutKey, newStyles) {
            var styleSheet = this.xtabStyleSheets && this.xtabStyleSheets[0],
                styleList = this.styleList || {},    
                fnAddStyles = function (tgt, src) {  
                    var srcKey;

                    
                    for (srcKey in src) {
                        
                        var newCss = src[srcKey].css || '';

                        
                        if (src[srcKey].app) {
                            
                            newCss = (tgt[srcKey] || '') + newCss;
                        }

                        
                        tgt[srcKey] = newCss;
                    }

                    return tgt;
                },
                doc = document;

            
            if (!styleList[layoutKey]) {
                
                styleList[layoutKey] = fnAddStyles({}, this.model.getSelectedXtabStyles(layoutKey));
            }

            
            fnAddStyles(styleList[layoutKey], newStyles);

            
            if (!styleSheet) {
                
                this.xtabStyleSheets = [];
                styleSheet = this.xtabStyleSheets[0] = doc.getElementsByTagName('head')[0].appendChild(doc.createElement('style'));
            }

            
            var cssText = new mstrmojo.StringBuffer(),
                tgt,
                css;
            for (tgt in styleList) {
                for (css in styleList[tgt]) {
                    cssText.append(styleList[tgt][css]);
                }
                cssText.append('\n');
            }

            
            cssText = cssText.toString();

            
            if (styleSheet && cssText) {
                
                
                styleSheet = styleSheet.styleSheet || styleSheet;

                
                if ($D.isWK) {
                    
                    var firstChild = styleSheet.firstChild;
                    if (firstChild) {
                        
                        firstChild.nodeValue = cssText;
                    } else {
                        
                        styleSheet.appendChild(doc.createTextNode(cssText));
                    }
                } else if ($D.isIE) {
                    
                    styleSheet.cssText = cssText;
                    
                    
                    
                    
                    
                    var count, lastRule, selectorText, index;
                    for (count = 1; styleSheet.rules.length === 4095 && doc.styleSheets.length < 31; count++) {
                        lastRule = styleSheet.rules[4094];
                        selectorText = new RegExp(lastRule.selectorText, 'i');
                        index = cssText.search(selectorText);
                        if (index === -1) {
                            break;
                        }
                        index = cssText.indexOf('}', index + 1);
                        
                        cssText = cssText.slice(index + 1);
                        if (!this.xtabStyleSheets[count]) {
                            this.xtabStyleSheets[count] = doc.getElementsByTagName('head')[0].appendChild(doc.createElement('style'));
                        }
                        styleSheet = this.xtabStyleSheets[count].styleSheet;
                        styleSheet.cssText = cssText;
                    }
                } else {
                    
                    styleSheet.innerHTML = cssText;
                }
            }

            
            this.styleList = styleList;
        },

        
        postBuildRendering: function postBuildRendering() {
            
            if (this.xtabStyleSheets) {
                for (var stylesheet, i = 0; stylesheet = this.xtabStyleSheets[i]; i++) {
                    if (!stylesheet.parentNode) {
                        document.getElementsByTagName('head')[0].appendChild(stylesheet);
                    }
                }
            }
            return this._super();
        },

        
        buildChildren: function buildChildren(noAddChildren) {
            var rtn;

            try {
                var m = this.model;
                if (m) {
                    var subs = this.buildSubs || {},
                        s = m.id + '-partialUpdate',
                        r = m.id + '-rebuildLayout',
                        u = m.id + '-updateStyles',
                        ifw = m.id + '-showInfoWin',
                        id = this.id;
                    
                    
                    var me = this,
                        unloadLayoutCache = function() {
                            $A.forEach(me.getLayouts(), function(l) {
                                if (l.k !== m.currlaykey) {
                                    l.defn.loaded = false;
                                }
                            });
                        };

                    
                    if (subs[s] === undefined) {

                        
                        var fnUpdate = function updateDescendants(evt) {
                            var m = this.model,
                                dataCache = m && m.getLayoutDataCache(m.getCurrentLayoutKey()),
                                ids = evt && evt.ids;

                            
                            if ($H.isEmpty(dataCache) || !ids) {
                                
                                return;
                            }

                            
                            $A.forEach(evt.tree.layouts, function (l) {
                                
                                if (l.k === m.currlaykey) {
                                    
                                    this.updateXtabStyles(l.k, l.xtabStyles);

                                    
                                    if (l.gbys) updateDocGroupBy.call(this, l.k, l.gbys);

                                    
                                    return false;
                                }
                            }, this);

                            var $FE = $H.forEach,
                                shouldNotifyScrollListeners = false,
                                ups = {
                                    update: ids.upd,
                                    refresh: ids.tgts,
                                    adjustSectionSize: ids.secs
                                };

                             





                            
                            
                            $FE(ids.ifws, function (psId, psKey) {
                                var infoWindow = mstrmojo.all[psId + '_ifw'];

                                
                                if (infoWindow && infoWindow.visible) {
                                    this.updateInfoWindowPS(psId, psKey);
                                }
                            }, this);

                            
                            $FE(ups, function (col, meth) {
                                
                                $FE(col, function (v, id) {
                                    
                                    var w = mstrmojo.all[id],
                                        rtn;

                                    
                                    if (w && w[meth] !== undefined) {
                                        
                                        
                                        rtn = w[meth](meth === 'update' ? dataCache[id] : null);

                                        
                                        if (meth === 'adjustSectionSize' && rtn) {
                                            
                                            shouldNotifyScrollListeners = shouldNotifyScrollListeners || (!!rtn.heightReduced);
                                        }
                                    }
                                }, this);
                            }, this);

                            var selectedLayout = this.getSelectedLayoutWidget();

                            
                            if (shouldNotifyScrollListeners) {
                                selectedLayout.notifyScrollListeners();
                            }

                            
                            
                            var docLayout = selectedLayout.docLayout;
                            if (docLayout) {
                                docLayout.resizeOrReposition();
                            }
                            
                            
                            if(evt && evt.unloadCache) {
                                unloadLayoutCache();
                            }
                        };

                        subs[s] = m.attachEventListener('partialUpdate', id, fnUpdate);
                    }

                    
                    subs[r] = subs[r] || m.attachEventListener('rebuildLayout', id, function (evt) {
                        var restoreIW = evt && evt.restoreIW,
                            ifwRecords;
                        
                        if (restoreIW) { 
                            ifwRecords = recordInfoWins.call(this);
                            this.model.aws = null; 
                        }
                        
                        
                        this.onLayoutRebuilt(this.rebuildLayout(evt.src.currlaykey, this.getLayouts()));
    
                        
                        if (evt && evt.unloadCache) {
                            unloadLayoutCache();
                        }
                        
                        if (restoreIW) { 
                            restoreInfoWins.call(this, ifwRecords);
                        }
                    });

                    
                    subs[u] = subs[u] || m.attachEventListener('updateStyles', id, function (evt) {
                        this.updateXtabStyles(evt.key, evt.updatedStyles);
                    });

                    subs[ifw] = subs[ifw] || m.attachEventListener('showInfoWin', id, function (evt) {
                        this.showInfoWindow(evt.psId, evt.psKey, evt.anchor, evt.invalidate, evt.anchorOrientation, evt.anchorPosition);
                    });

                    this.updateXtabStyles(m.getCurrentLayoutKey());

                    
                    m.attachEventListener('refresh', this.id, function () {
                        this.refresh();
                    });
                }

                rtn = this._super(noAddChildren);


            } catch (ex) {
                mstrmojo.err(ex);
            }

            return rtn;
        },

        
        updateInfoWindowPS: mstrmojo.emptyFn,

        
        showInfoWindow: function showInfoWindow(psId, psKey, anchor, invalidate, anchorOrientation, anchorPosition) {
            var model = this.model,
                dataCache = model.getLayoutDataCache(model.getCurrentLayoutKey()),
                builder = this.builder,
                ifwDefn = dataCache[psId] && dataCache[psId].defn,
                infoPlacement = ifwDefn && ifwDefn.iwpl,
                id = psId + "_ifw",
                infoWindow = mstrmojo.all[id],
                domNode = this.domNode,
                ENUM_FIXED_PLACEMENT = mstrmojo.DocInfoWindow.PLACEMENT.FIXED,
                updatePopupPosition = function (infoWindowObj, parentDomNode, layoutNode, left, top) {
                    if (infoPlacement === ENUM_FIXED_PLACEMENT) {
                        if(parentDomNode){
                        var parentPosition = $D.delta(parentDomNode, domNode); 

                        
                        infoWindowObj.popPosition = {
                            left: (parentPosition && parentPosition.x) ? left + parentPosition.x : left,
                            top: (parentPosition && parentPosition.y) ? top + parentPosition.y : top
                        };
                        }else if(layoutNode){
                            infoWindowObj.popPosition = {
                                    left: (layoutNode.scrollboxLeft) ? left - layoutNode.scrollboxLeft : left,
                                    top: (layoutNode.scrollboxTop) ? top - layoutNode.scrollboxTop : top
                                };
                        }else{
                            infoWindowObj.popPosition = {
                                    left: left,
                                    top: top
                                };
                        }
                    }
                };

            var layoutNode = this.getLayout(model.getCurrentLayoutKey());
            
            if (infoWindow) {
                if (invalidate) {
                    
                    infoWindow.refresh();
                }

                infoWindow.anchorOrientation = anchorOrientation;
                infoWindow.anchorPosition = anchorPosition;

                
                updatePopupPosition(infoWindow, infoWindow._ifwpdn, layoutNode, infoWindow._ifwfl, infoWindow._ifwft);

                
                infoWindow.open(this, {
                    anchor: anchor,
                    boundary: domNode
                });

            } else {
                var cfg = {
                        opener: this,
                        anchor: anchor,
                        anchorOrientation: anchorOrientation,
                        boundary: domNode,
                        parent: this,
                        builder: builder,
                        model: this.model,
                        psKey: psKey,
                        psId: psId,
                        id: id,
                        autoCloses: true,
                        locksHover: true,
                        closeOnClick: false,
                        anchorPosition: anchorPosition
                    };

                if (infoPlacement) {
                    infoPlacement = parseInt(infoPlacement, 10);
                    cfg.placement = infoPlacement;

                    
                    if (infoPlacement === ENUM_FIXED_PLACEMENT) {
                        var formats = ifwDefn.fmts,
                            left = cfg._ifwfl = formats && formats.left && parseInt(formats.left.replace('px', ''), 10), 
                            top = cfg._ifwft = formats && formats.top && parseInt(formats.top.replace('px', ''), 10),  
                            infoWindowParent = dataCache[psId] && dataCache[psId].p,
                            parentObject = infoWindowParent && model.getUnitInstance(infoWindowParent.k, infoWindowParent.wid),
                            parentDomNode = cfg._ifwpdn = parentObject && parentObject.domNode;

                        
                        updatePopupPosition(cfg, parentDomNode, layoutNode, left, top);
                    }
                }

                
                infoWindow = builder.newInfoWindow(cfg);

                
                this.renderInfoWindow(infoWindow);

                
                var infoMap = this.ifwMap = (this.ifwMap || {});
                infoMap[psId] = infoWindow;
            }
        },

        
        renderInfoWindow: function renderInfoWindow(infoWindow) {
            infoWindow.render();
        },

        _lockInfoWinContainer: function lockInfoWinContainer(config) {
            var ifwm = this.ifwMap,
                k;
            for (k in ifwm) {
                var ifw = ifwm[k],
                    xtab = config.xtab;
                if (ifw && xtab &&
                        $D.contains(ifw.infoNode, xtab.domNode, true, document.body)) {
                    ifw.autoCloseLocked = true;
                    config.onClose = function () {
                        ifw.autoCloseLocked = false;
                    };
                    break;
                }
            }
        },

        
        unrender: function unrender(ignoreDom) {
            
            destroyInfoWindows.call(this);

            this._super(ignoreDom);

            clearXtabStyleSheet.call(this);
        },

        getLayouts: function getLayouts() {
            return this._layouts;
        },

        
        getLayout: function getLayout(key) {
            key = key || this.model.getCurrentLayoutKey();
            var layouts = this.getLayouts();
            return layouts[$A.find(layouts, 'k', key)];
        },

        getNewLayout: function getNewLayout(params, layouts, isSelected, callback) {
            var me = this,
                model = me.model,
                dataService = model.getDataService(),
                key = params.layoutKey,
                layout = layouts[$A.find(layouts, 'k', key)];  

            
            if (layout.defn && (params.reload || layout.defn.loaded === false || (model.zt && (window.mstrMobileApp !== undefined) && (layout.defn.lastOrientation !== mstrMobileApp.getOrientation())))) {
                
                var fnSuccess = callback.success;
                callback.success = function (res) {

                    
                    model.replaceLayout(key, res);

                    
                    
                    model.currlaykey = key;

                    
                    if (isSelected) {
                        
                        layout.zf = res.zf;

                        
                        me.selectLayout(layout, false);
                    }


                    var newLayout = me.rebuildLayout(key, layouts);

                    if (me.controller.getPageByTree) {  
                        me.controller.getPageByTree(true);
                    }

                    
                    fnSuccess(newLayout);
                };

                
                dataService.loadDocLayout(params, callback);

            } else {
                
                callback.success(layout);

                
                if (isSelected) {
                    
                    this.selectLayout(layout, true, {
                        success: function (res) {
                            $H.copyProps(['bs'], res, model);
                        }
                    });
                }

            }
        },

        selectLayout: function selectLayout(layout, updateServer, callback) {
            
            var model = this.model,
                key = layout.k,
                isNewKey = (key !== model.currlaykey);

            
            model.currlaykey = key;

            
            this.restoreLayoutState(layout);

            
            if (updateServer && isNewKey) {
                
                model.getDataService().setCurrentDocLayout(key, callback);

            
            } else if (callback && callback.complete) {
                
                callback.complete();
            }

            
            return layout;
        },

        
        rebuildLayout: function rebuildLayout(k, layouts) {
            var model = this.model,
                findLayout = $A.find,
                oldLayout = layouts[findLayout(layouts, "k", k)],
                nodes = model.getChildren(this.node, false);

            var newLayout = nodes[findLayout(nodes, 'k', k)];

            
            if (window.mstrMobileApp !== undefined) {
                newLayout.defn.lastOrientation = mstrMobileApp.getOrientation();
            }

            
            var c = this.replaceLayout(oldLayout, newLayout);

            
            this.updateXtabStyles(k, model.getSelectedXtabStyles(k));

            
            destroyInfoWindows.call(this);

            destroyPopups();
            
            return c;
        },



        
        destroy: function destroy() {

            
            destroyInfoWindows.call(this);

            
            if (this._super) {
                this._super();
            }

            clearXtabStyleSheet.call(this);
        },

        
        replaceLayout: mstrmojo.emptyFn,

        
        restoreLayoutState: mstrmojo.emptyFn,

        
        onLayoutRebuilt: mstrmojo.emptyFn,

        
        unloadGbLayuts: function unloadGbLayuts(groupbyKey) {
            var layouts = this.getLayouts(),
                curLayoutKey = this.model.getCurrentLayoutKey(),
                layout,
                i,
                gb,
                groupbys,
                k,
                gbDssId;

            
            layout = this.getLayout();
            groupbys = layout.gb && layout.gb.groupbys;
            for (k = 0; k < groupbys.length; k++) {
                gb = groupbys[k];
                if (gb.k === groupbyKey) {
                    gbDssId = gb.unit.target.did;
                    break;
                }
            }

            
            for (i = 0; i < layouts.length; i++) {
                layout = layouts[i];
                if (layout.k === curLayoutKey) {
                    continue;
                }
                groupbys = layout.gb && layout.gb.groupbys;
                if (groupbys && groupbys.length) {
                    for (k = 0; k < groupbys.length; k++) {
                        gb = groupbys[k];
                        if (gb.unit.target.did === gbDssId) {
                            
                            
                            layout.defn.loaded = false;
                            break;
                        }
                    }
                }
            }
        }
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom");

    var $D = mstrmojo.dom;
    
    
    var EVENT_TO_CLOSE = 'mousedown';

    function _attachHotSlot(me) {
        
        var el = me[me.hotSlot || "domNode"];
        if (el) {
            
            if (!me._closeCallback) {
                var id = me.id,
                    fnCallback = function (mthName) {
                        return function (e) {
                            var p = mstrmojo.all[id];
                            if (p && !p.ignoreHover) {
                                p['auto' + mthName](e, self);
                            }
                        };
                    };

                
                
                me._uncloseCallback = fnCallback('Unclose');
                me._closeCallback = fnCallback('Close');
            }
            
            $D.attachEvent(el, "mouseover", me._uncloseCallback);
            $D.attachEvent(el, "mouseout", me._closeCallback);
        }
    }

    function _detachHotSlot(me) {
        if (me._closeCallback) {
            var el = me[me.hotSlot || "domNode"];
            if (el) {
                $D.detachEvent(el, "mouseover", me._uncloseCallback);
                $D.detachEvent(el, "mouseout", me._closeCallback);
            }
        }
    }

    function _toggleLock(me, lock) {
        var w = me;
        while (w) {
            
            if (w.open || w.openPopup) {
                
                if (w.set) {
                    w.set("ignoreHover", lock);
                } else {
                    w.ignoreHover = lock;
                }
            }
            
            w = w.opener || w.parent;
        }
    }

    function clearLockHoverCallback() {
        var fn = this._lockHoverCallback;
        if (fn) {
            $D.detachEvent(document.body, EVENT_TO_CLOSE, fn, true);
            delete this._lockHoverCallback; 
        }

    }

    
    mstrmojo._CanAutoClose = {

        
        autoCloses: false,

        
        autoCloseDelay: 100,

        
        locksHover: false,

        
        hotSlot: null,

        
        closeOnClick: false,

        
        curtainNode: null,

        
        postBuildRendering: function postBuildRendering() {
            this._super();

            if (this.autoCloses) {
                _attachHotSlot(this);
            }

            this.oncloseOnClickChange();

        },

        
        onautoClosesChange: function onautoClosesChange() {
            var fn = (this.autoCloses) ? _attachHotSlot : _detachHotSlot;
            fn(this);
        },

        oncloseOnClickChange: function oncloseOnClickChange() {
            if (!this.curtainNode) {
                return;
            }

            var me = this,
                mthName = 'click',
                isTouchApp = (mstrApp && mstrApp.isTouchApp && mstrApp.isTouchApp());

            if (isTouchApp) {
                mthName = 'touchstart';
            }

            $D.attachEvent(me.curtainNode, mthName, function () {
                me.close();
                if (isTouchApp) {
                    mstrmojo.touchManager.notify([]);
                }
            });
        },

        
        autoUnclose: function autUncls() {
            var t = this._autoCloseTimer;
            if (t) {
                self.clearTimeout(t);
                delete this._autoCloseTimer;
            }
        },

        
        autoClose: function autCls() {
            if (this.ignoreHover) {
                return;
            }

            
            if (this._autoCloseTimer) {
                self.clearTimeout(this._autoCloseTimer);
            }

            if (this.opener) {
                if (this.autoCloseDelay) {
                    
                    var xid = this.opener.id;
                    this._autoCloseTimer = self.setTimeout(function () {
                        mstrmojo.all[xid].closePopup();
                    }, this.autoCloseDelay);
                } else {
                    
                    this.opener.closePopup();
                }
            }
        },

        
        destroy: function destroy(ignoreDom) {
            clearLockHoverCallback.call(this);

            this._super(ignoreDom);
        },


        
        lockHover: function lockHover() {
            _toggleLock(this, true);

            if (!this._lockHoverCallback) {

                var id = this.id,
                    fn = this._lockHoverCallback = function (evt) {
                       mstrmojo.all[id]._unlockHoverCheck(evt, self);
                    };

                
                
                

                
                

                
                
                
                
                
                
                if (($D.isIE7 || $D.isIE8 ) && window.event && (window.event.type == EVENT_TO_CLOSE) && this.opener) {
                    
                    this.opener._ignoreMousedown = true;
                }
                    
                
                $D.attachEvent(document.body, EVENT_TO_CLOSE, fn, true);
            }
        },

        
        unlockHover: function unlockHover() {
            _toggleLock(this, false);

            clearLockHoverCallback.call(this);
        },

        
        _unlockHoverCheck: function _unlockHoverCheck(e, hWin) {
            
            
            var opener = this.opener;
            if ( opener && opener._ignoreMousedown) {
                delete opener._ignoreMousedown;
                return;
            }

            if (!$D.contains(this.domNode, $D.eventTarget(hWin, e), true, document.body)) {
                this.close();
            }
        },

        
        open: function open(opener, config) {
            
            if (this.autoCloses) {
                this.autoUnclose();
            }

            this._super(opener, config);

            
            if (this.locksHover) {
                this.lockHover();
            }
        },

        
        close: function close(cfg) {
            
            if (this.locksHover) {
                this.unlockHover();
            }
            this._super(cfg);
        }
    };

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.dom");

    
    var FLOATING_TB_CSS = "mstrmojo-floating-toolbar-lightbox";
    var FLOATING_BAR_CSS = "mstrmojo-floating-toolbar";
    var FLOATING_CELL_CSS = "mstrmojo-floating-toolbar-cell";

    var FIXED_TB_CSS = "mstrmojo-fixed-toolbar-lightbox";
    var FIXED_BAR_CSS = "mstrmojo-fixed-toolbar";
    var FIXED_CELL_CSS = "mstrmojo-fixed-toolbar-cell";    
    
    var CTN_CSS_SUFFIX = " hasToolBar";
    var BTN_CSS_PREFIX = "mstrmojo-Button mstrmojo-InteractiveButton mstrmojo-oivmSprite ";
    var BTN_CNT_CSS = "mstrmojo-Button-text";
        
    var SL = 27; 
    
    
    mstrmojo._HasToolbar =
    
    {
        
        _mixinName: 'mstrmojo._HasToolbar',
        

        
        postBuildRendering: function TB_postBuildRendering() {        
            this._super();
            
            var tb = this.getToolbarCfg();
            
            
            if(!tb || this.defn.ttl) {
                return;
            }
            
            
            var cn = this.containerNode;
            if(cn) {                
                
                var d = this._createToolbar(FLOATING_BAR_CSS, FLOATING_CELL_CSS);
                
                
                d.className = FLOATING_TB_CSS;
                
                cn.className += CTN_CSS_SUFFIX;
                
                
                cn.insertBefore(d, cn.firstChild);
                
                var dm = this.domNode,
                    ofst = mstrmojo.boxmodel.offset(dm, this.parent && this.parent.domNode); 

                
                
                
                if(ofst.top < SL) {
                    d.style.top = (SL - ofst.top) + 'px';
                }
            }
        },
        
                
        
        _createToolbar: function TB_addBtns(barCss, btnCss) {            
            var tb = this.getToolbarCfg(),
                me = this,            
                d = document,
                dv = d.createElement('div'),
                tbl = d.createElement('table'),
                tr = d.createElement('tr'),
                td = d.createElement('td');
            
            dv.appendChild(tbl);

            
            tbl.className = barCss;
            td.className = btnCss;
            tr.appendChild(td);
            tbl.appendChild(tr);
            
            
            
            
            
            
            
            
            
            
            
            for(var i in tb) {
                var div = d.createElement('div');
                div.className = BTN_CSS_PREFIX + tb[i].css[0];
                
                var cnt = d.createElement('div');
                cnt.className = BTN_CNT_CSS;
                cnt.nodeValue = "&nbsp;";
                
                
                cnt.setAttribute("ix", i);
                
                
                cnt.setAttribute("cix", 0);

                div.appendChild(cnt);                
                td.appendChild(div);

                div.onclick = function(e) {
                    me.onClick(e);
                };
            }
            
            return dv;

        },
        
        
        
        renderToolbar: function TB_rndToolbar(slot) {
            if(!this.getToolbarCfg()) {
                
                return;
            }
            
            var fc = slot.firstChild,
                tb = this._createToolbar(FIXED_BAR_CSS, FIXED_CELL_CSS);
            
            tb.className = FIXED_TB_CSS;
            
            if(fc) {
                slot.insertBefore(tb, fc);
            } else {
                slot.appendChild(tb);
            }
        },
    
        
        
        onClick: function TB_clk( e,  hWin) {
            
            var d = mstrmojo.dom,
                b = d.eventTarget(hWin, e),
                cix = b.getAttribute("cix"),
                ix = b.getAttribute("ix");            
            
            var tb = this.toolbarCfg[ix],
                tbFn = tb.callback;
            
            if(tbFn && this[tbFn] && this[tbFn]()) { 
                
                cix = ++cix % tb.css.length; 
                b.parentNode.className = BTN_CSS_PREFIX + tb.css[cix];
                b.setAttribute("cix", cix);
            }
        }

    };
})();
(function(){

	mstrmojo.requiresCls("mstrmojo.dom");

	
	function validateListener(l) {
		return (l && l.id);
	}
	
    
    mstrmojo._HasScrollbox = 
        
        {
            
            _mixinName: "mstrmojo._HasScrollbox",
            
            
			
			scrollListeners: null,   
			
			
			scrollListenerCount: 0,
			
			
			connectScrollbox: function cnnScll( listener) {
				if (!validateListener(listener)) {
					return;
				}
				
				
				
				var hash = this.scrollListeners,
				    lid = listener.id;
				if (!hash) {
				    hash = {};
				    this.scrollListeners = hash;
				}
				if (!hash[lid]) {
    				hash[lid] = listener;
	       			this.scrollListenerCount++;
    				
    				if (this.scrollListenerCount == 1) {
    					this._attachScrollDom();
    				}
				}
			},

			disconnectScrollbox: function discnnScll( listener) {
				if (!validateListener(listener)) {
					return;
				}
				
				
				var hash = this.scrollListeners,
				    lid = listener.id;
                if (hash != null && lid in hash) {
				    delete this.scrollListeners[lid];
    				this.scrollListenerCount--;
    				
    				if (!this.scrollListenerCount) {
    				    this._detachScrollDom();
    				}
                }
			},
            
			
			
			notifyScrollListeners: function ntfSclls(evt) {
                
                
			    var p = evt || this.getScrollPos(),
			        top = p.y,
			        left = p.x;
			    
			    this.scrollboxTop = top;
                this.scrollboxLeft = left;
				this.scrollboxRight = left + this.scrollboxWidth;
				this.scrollboxBottom = top + this.scrollboxHeight;
				
				
				var ls = this.scrollListeners;
				for (var id in ls) {
					ls[id].onscroll(this);
				}
			},
			
			getScrollPos: function getScrollPos() {
			    var node = this.scrollboxNode; 
			    return {
			        x: node.scrollLeft,
                    y:  node.scrollTop
			    };
			},
			
			scrollTo: function scrollTo(pos) {
			    var node = this.scrollboxNode;
			    if (node && pos) {
			        node.scrollLeft = pos.x;
			        node.scrollTop = pos.y;
			    }
			},
						
			scrollInterval: 50,

			_attachScrollDom: function attSbxDom() {
				
				var sbn = this.scrollboxNode;
				if (sbn) {
                    
				    var useTouch = this.usesTouches;
				    if (!useTouch) {
	                    
	                    if (!this.scrollCallback) {
	                        var id = this.id;
	                        this.scrollCallback = function(){
	                            mstrmojo.all[id].notifyScrollListeners();
	                        };
	                    }

	                    
	                    mstrmojo.dom.attachBufferedEvent(sbn, "scroll", this.scrollCallback, this.scrollInterval);
					}
					    
					
					
					
					
					
					if (this.scrollboxTop === null) {
						this.scrollboxTop = (useTouch) ? 0 : sbn.scrollTop;
					}
					if (this.scrollboxLeft === null) {
						this.scrollboxLeft = (useTouch) ? 0 : sbn.scrollLeft;
					}
					
					var fnD = function (d) {
						var css = d.toLowerCase();
						
						
						var x = sbn.style[css];
						return (!isNaN(x) && x.charAt(x.length - 1) !== '%') ? parseInt(x, 10) : sbn['client' + d]; 
					};
					
					if (this.scrollboxHeight === null) {
						this.scrollboxHeight = fnD('Height');
					}
					if (this.scrollboxWidth === null) {
						this.scrollboxWidth = fnD('Width');
					}
					
					this.scrollboxBottom = this.scrollboxTop + this.scrollboxHeight;
					this.scrollboxRight = this.scrollboxLeft + this.scrollboxWidth;
					
					this._attachedScrollbox = sbn;
				}
			},
			
            _detachScrollDom: function dtchSbxDm() {
                var as = this._attachedScrollbox;
                if (as && this.scrollCallback) {
                    mstrmojo.dom.detachBufferedEvent(
                        as,
                        "scroll",
                        this.scrollCallback,
                        this.scrollInterval);
                }
                delete this._attachedScrollbox;
            },

            
			scrollboxTop: null,
			scrollboxLeft: null,
			scrollboxHeight: null,
			scrollboxBottom: null,

			
			buildRendering: function bldRndr() {
				
                
				this._detachScrollDom();
				
				
				this._super();
				
				
				if (this.scrollListenerCount) {
					this._attachScrollDom();
				}
			}		
			
			
	};
	
})();
(function () {

    mstrmojo.requiresCls("mstrmojo._HasDrillLinks",
                         "mstrmojo.registry",
                         "mstrmojo.hash",
                         "mstrmojo.dom");

    var $DOM = mstrmojo.dom;

    
    
    
    function getPopupDelegate(widget) {
        var w = widget;
        while (w) {
            if (w.openDrillLinkMenu) {
                return w;
            }
            w = w.parent;
        }

        return null;
    }


    
    mstrmojo._HasHoverButton = mstrmojo.provide(
        'mstrmojo._HasHoverButton',

        
        mstrmojo.hash.copy(mstrmojo._HasDrillLinks, {
            
            _mixinName: 'mstrmojo._HasHoverButton',

            buttonNodeMarkup: '<div class="mstrmojo-LinkInfo-buttonNode"></div>',

            init: function init(p) {
                this._super(p);

                this.markupSlots.buttonNode = function () { return this.domNode.lastChild; };
            },

            postBuildRendering: function pstBldRnd() {
                if (!this.hoverBtn) {
                    this.addChildren(mstrmojo.registry.ref({
                        scriptClass: "mstrmojo.Button",
                        slot: "buttonNode",
                        alias: "hoverBtn",

                        onclick: function onclick() {
                            this.openPopup();
                        },

                        openPopup: function openPopup() {
                            var dl = getPopupDelegate(this);
                            if (dl) {
                                dl.openDrillLinkMenu({
                                    openerButton: this,
                                    drillLinkItems: this.parent.drillLinkItems,
                                    cmPos: this.cmPos
                                });
                            }
                        },

                        closePopup: function closePopup() {
                            var dl = getPopupDelegate(this);
                            if (dl) {
                                dl.closeDrillLinkMenu();
                            }
                        }

                    }));
                }

                var ret = this._super();

                
                var id = this.id;
                $DOM.attachEvent(this.domNode, 'contextmenu', function (e) {
                    mstrmojo.all[id].oncontextmenu(e, self);
                });

                return ret;
            },

            
            oncontextmenu: function (e, hWin) {
                var btn = this.hoverBtn;
                btn.cmPos = $DOM.getMousePosition(e, hWin);
                btn.openPopup();
                btn.cmPos = null;

                $DOM.preventDefault(hWin, e);
            }
        })
    );
}());
(function(){

	 mstrmojo.requiresCls("mstrmojo.dom");

	var $DOM = mstrmojo.dom;

	var TEXTMARGIN = 5; 
	
	var D_S_P = 1;
	
	var D_E_P = 2;
	
	var D_O_P = 4;

	var T_Z_A = 0;

	var needAdjust = true;

	var ZoomFactor = 0;


	
	var millisOnDay = 86400000;

	mstrmojo.VisChartUtils = mstrmojo.provide(
        "mstrmojo.VisChartUtils",
        
        {
        	getScreenZoomFactor: function getScrnZmFctr(){
        		if(ZoomFactor == 0){
        			if(mstrMobileApp){
        				var dpi = mstrMobileApp.getDeviceDPI();
        				console.log("dpi:"+dpi);
    	        		ZoomFactor = dpi/160;
        			}else{
        				ZoomFactor = 1;
        			}

        		}
        		return ZoomFactor;
        	},

        	changeElementSize: function chngfntsz(el,prop,zf){

        		if(prop == 'fontSize' || prop == 'height' || prop == 'line-height'){
        			var propValue = mstrmojo.css.getStyleValue(el,prop);
	        		var intSize = Math.round(zf*parseInt( propValue ));
	        		

	        		el.style[prop] = intSize + "px";
	        	
        		}else if(prop == 'font'){
        			var fontSize = mstrmojo.css.getStyleValue(el,'fontSize');
        			var intSize = Math.round(zf*parseInt( fontSize ));
        			var fontWeight = mstrmojo.css.getStyleValue(el,'fontWeight');
        			var fontFamily = mstrmojo.css.getStyleValue(el,'fontFamily');
        			el.style.font = fontWeight+ " "+ intSize+"px " + fontFamily;
        			
        		}
        	},

        	rgbaStr2rgba: function C_rgbaStr2rgba(color) {
                var rgba = null;
                color = color.replace(/ /g, ''); 
                var i = color.indexOf('rgba');
                if (i >= 0) {
                    color = color.substring(i + 5, color.length - 1);
                    rgba = color.split(',');
                }
                return rgba;
            },

            
            fillBackground: function fllBckgrnd(widget, width, height, context, opacity) {

                
                var cntx = context || widget.context,
                    wd = width || widget.canvas.width,
                    ht = height || widget.canvas.height,
                    themeColor = widget.themeColor || '#000000', 
                    gradient = null,
                    opc = opacity || 1;

				if(!cntx){
					
					cntx = widget.canvas.getContext('2d');
					if(!cntx){
						
						return;
					}
				}
                cntx.save();

                if (widget.noBackground) {
                	
                } else if(!widget.isAndroid && !widget.isTimeSeries) {

                	gradient = cntx.createLinearGradient(0, 0, 0, ht / 2);

                	
                	cntx.fillStyle = themeColor;
                	cntx.fillRect(0, 0, wd, ht);

                	

                	cntx.globalAlpha = 0.4;

                	gradient.addColorStop(0, '#fff');
                	gradient.addColorStop(0.1, '#fff');
                	gradient.addColorStop(1, themeColor);


                	cntx.fillStyle = gradient;
                	cntx.rect(0, 0, wd, ht / 2);
                	cntx.fill();


                	cntx.globalAlpha = 0.1;
                	cntx.fillStyle = '#fff';
                	cntx.fillRect(0, 0, wd, ht / 2);
                } else if(widget.isTimeSeries) {
                	var formatProp = widget.formatProp;

            		gradient = cntx.createLinearGradient(0, 0, 0, ht);
                	
                	cntx.globalAlpha = formatProp.backgroundAlpha;

                	var topGradient = this.rgb2rgbStr(formatProp.backgroundClr, 0.83) || '#2c2c2c';
     			    var bottomGradient = this.rgb2rgbStr(formatProp.backgroundClr) || '#000000';
					gradient.addColorStop(0, topGradient);
                	gradient.addColorStop(1, bottomGradient);
                	cntx.fillStyle = gradient;
                	cntx.rect(0, 0, wd, ht);
                	cntx.fill();

                }else {
                	cntx.globalAlpha = opc;
                	cntx.fillStyle = themeColor;
                	cntx.fillRect(0, 0, wd, ht);
                }

                cntx.restore();

            },

            rgb2rgbStr: function rgb2rgbStr(rgb, opc){
            	var result = '';

            	if(!rgb || rgb.length != 3){
            		return result;
            	}

            	if(opc || opc == 0){
            		result = 'rgba('+ rgb[0] + ','+rgb[1]+','+rgb[2]+','+opc+')';
            	}else{
            		result = 'rgb('+ rgb[0] + ','+rgb[1]+','+rgb[2]+')';
            	}

            	return result;
            },

            
            getRGBWithOpacity: function getRGBWithOpacity(rgb, opacity, rgb2){
            	if(isNaN(opacity)){
            		return;
            	}

            	if(!rgb2){
            		rgb2 = [255, 255, 255];
            	}

            	var resultRGB = [];

            	for(color in rgb){
            		resultRGB[color] = parseInt( rgb[color]*(1 - opacity) + rgb2[color]*opacity );
				}
            	return resultRGB;
            },

            fillMasterChartBackground: function fillMasterChartBackground(widget, topX, topY, width, height, bottomY, context){
				 
			     var cntx = context || widget.context,
			         wd = width || widget.canvas.width,
			         ht = height || widget.canvas.height,
			         themeColor = widget.themeColor,
			         gradient = null;

			     var formatProp = widget.formatProp;

			    cntx.save();
			    cntx.globalAlpha = formatProp.backgroundAlpha;
			    cntx.fillStyle = this.rgb2rgbStr(formatProp.backgroundClr) || '#000000';
				cntx.fillRect(0, 0, wd, topY);

			    gradient = cntx.createLinearGradient(0, 0, 0, ht/2);
				


				
			    var topGradient = this.rgb2rgbStr( this.getRGBWithOpacity(formatProp.backgroundClr, 0.45) ) || '#737373';
			    var bottomGradient = this.rgb2rgbStr( this.getRGBWithOpacity(formatProp.backgroundClr, 0.13) ) || '#222222';
				gradient.addColorStop(0, topGradient);
				gradient.addColorStop(1, bottomGradient);
				cntx.fillStyle = gradient;
				cntx.fillRect(topX, topY, wd, ht/2 );

				cntx.fillStyle = this.rgb2rgbStr(formatProp.backgroundClr) || '#000000';
				cntx.fillRect(topX, topY + ht/2, wd, ht/2 + bottomY);

				
				cntx.globalAlpha = 1;
				cntx.strokeStyle = this.rgb2rgbStr ( widget.formatProp.textClr, 0.50 );
				cntx.lineWidth = 1;
				
				var lineY = topY +0.5;
				this.drawLineSet(this, [{
	                x: topX,
	                y: lineY
	            }, {
	                x: topX + wd,
	                y: lineY
	            }], false, cntx);
				
				
				lineY = topY + ht - 0.5;
				this.drawLineSet(this, [{
	                x: topX,
	                y: lineY
	            }, {
	                x: topX + wd,
	                y: lineY
	            }], false, cntx);

				cntx.restore();
          },

			
			drawLineSetWithSplit: function(widget, lines, fill, context, split) {
				var n = lines.length, 
					np = Math.ceil(n / split), 
					start, end;
				for (var i = 0; i < np; i++) {
					start = i * split; 
					end = Math.min(start + split + 1, n); 
					this.drawLineSet(widget, lines.slice(start, end), fill, context);
				}
			},

            
			drawLineSet: function drwlnst(widget, lines, fill, context) {

                
				var cntx = null,
					l = lines.length,
					li = null;

                
                if (context) {
                    cntx = context;
                } else {
                    cntx = widget.context;
                }

            	
            	var lastPoint = null,
            		moveToPoint = false;

                
				cntx.beginPath();
				var i = 0;
				while(i < l) {
					if(lines[i]) {
						cntx.moveTo(lines[i].x, lines[i].y);
						lastPoint = lines[i];
						moveToPoint = true;
						i++;
						break;
					}

					i++;

				}
				
				
				var skip = false;
				for(;i<l;i++) {
					li = lines[i];
					if(li) { 
						if(!skip) {
							cntx.lineTo(li.x, li.y);
							moveToPoint = false;
						} else {
							cntx.moveTo(li.x, li.y);
							moveToPoint = true;
							lastPoint = li;
							skip = false;
						}
					} else {
						if(!skip){
							skip = true;
							if(moveToPoint){
									
									cntx.arc(lastPoint.x,lastPoint.y, 1, 0, Math.PI * 2, false);
							}
						}
					}
				}

                
				if (fill) {
					cntx.closePath();
					cntx.fill();
				} else {
					cntx.stroke();
				}
			},

			
			getMinYPosition: function getMinYPosition(lines, start, end){
				var i = start,min;
				while(i <= end){
					if(lines[i]){
						min = lines[i].y;
						break;
					}
					i++;
				}
				for(i = start; i <= end;i++){
					if(lines[i]){
						min = Math.min(min,lines[i].y);
					}
				}
				return min;
			},

			drawLineAreaWithSplit: function (widget, lines, start, end, bottomY, rgbClr, context, split) {
				var n = end - start + 1, 
					np = Math.ceil(n / split), 
					p1, p2;
				for (var i = 0; i < np; i++) {
					p1 = start + i * split; 
					p2 = Math.min(p1 + split, start + n - 1); 
					this.drawLineArea(widget, lines, p1, p2, bottomY, rgbClr, context);
				}
			},

			
			drawLineArea: function drwlnst(widget,lines, start, end, bottomY, rgbClr, context) {
				
				var cntx = null,
					l = lines.length,
					li = null,
					startBottomX = 0,
					endBottomX = 0;

		        
		        if (context) {
		            cntx = context;
		        } else {
		            cntx = widget.context;
		        }

		        
            	var lastPoint = null,
            		moveToPoint = false;

		        cntx.save();

		        cntx.lineWidth = 0;
		        
				cntx.beginPath();
				var i = start, startIndex;
				while(i <= end) {
					if(lines[i]) {
						startBottomX = lines[i].x;
						cntx.moveTo(startBottomX, bottomY);
						lastPoint = lines[i];
						moveToPoint = true;
						break;
					}
					i++;
				}
				startIndex = i;
				
				
				var skip = false;
				for( ;i<=end;i++) {
					li = lines[i];
					if(li) { 
						if(!skip) {
							cntx.lineTo(li.x, li.y);
							moveToPoint = false;
							endBottomX = li.x;
						} else {

							startBottomX = li.x;
							cntx.moveTo(startBottomX, bottomY);
							if(i+1<=end && lines[i+1]){
								cntx.lineTo(li.x, li.y);
							}
							lastPoint = li;
							skip = false;
							startIndex = i;
						}
					} else {
						if(!skip){
							skip = true;
							if(!moveToPoint){
								cntx.lineTo(endBottomX, bottomY);
								cntx.lineTo(startBottomX, bottomY);
								var MinY = this.getMinYPosition(lines, startIndex, i) || 0;

								var my_gradient  = cntx.createLinearGradient(0,MinY,0,bottomY);
							    my_gradient.addColorStop(1,this.rgb2rgbStr(rgbClr, 0));
							    my_gradient.addColorStop(0,this.rgb2rgbStr(rgbClr, 1));
							    cntx.fillStyle = my_gradient;
							    cntx.globalAlpha = 0.8;
								cntx.fill();
							}
						}
					}
				}

		         
		        if(!moveToPoint){
					cntx.lineTo(endBottomX, bottomY);
					cntx.lineTo(startBottomX, bottomY);
					var MinY = this.getMinYPosition(lines, startIndex, end) || 0;
					cntx.closePath();
					var my_gradient  = cntx.createLinearGradient(0,MinY,0,bottomY);
				    my_gradient.addColorStop(1,this.rgb2rgbStr(rgbClr, 0));
				    my_gradient.addColorStop(0,this.rgb2rgbStr(rgbClr, 1));
				    cntx.fillStyle = my_gradient;
				    cntx.globalAlpha = 0.8;
					cntx.fill();
		        }

				cntx.restore();
			},

			
			drawRectangle: function drwRect(widget, x, y, w, h, fill, context) {
				var cntx = null;

				
				if (context) {
					cntx = context;
				} else {
					cntx = widget.context;
				}

				if(fill) {
					cntx.fillRect(x,y,w,h);
				} else {
					cntx.strokeRect(x,y,w,h);
				}
			},
			
			drawArc: function drwArc(widget, x, y, radius, startAngle, endAngle, anticlockwise, fill, context) {
				var cntx = null;

				
				if (context) {
					cntx = context;
				} else {
					cntx = widget.context;
				}

				cntx.beginPath();

				cntx.arc(x,y,radius,startAngle,endAngle,anticlockwise);

				if(fill) {
					cntx.fill();
				} else {
					cntx.stroke();
				}

			},

			
			drawRoundRect: function drawRoundRect(ctx, x, y, w, h, r, fill) {
				
				r = Math.min(w/2, h/2, r);

				ctx.beginPath();
				ctx.moveTo(x + r, y);
				ctx.arcTo(x+w, y,   x+w, y+h, r);
				ctx.arcTo(x+w, y+h, x,   y+h, r);
				ctx.arcTo(x,   y+h, x,   y,   r);
				ctx.arcTo(x,   y,   x+w, y,   r);








				ctx.closePath();

				if (fill) {
					ctx.fill();
				}else{
					ctx.stroke();
				}
			},

			drawHalfRoundedRectangle: function drwHRRect(widget, x, y, w, h, r, fill, context) {
				var cntx = null;

				
				if (context) {
					cntx = context;
				} else {
					cntx = widget.context;
				}

				cntx.beginPath();
				cntx.moveTo(x+w,y);
				cntx.lineTo(x+r,y);
				cntx.arcTo(x,y,x,y+r,r);
				cntx.lineTo(x,y+h-r);
				cntx.arcTo(x,y+h,x+r,y+h,r);
				cntx.lineTo(x+w,y+h);
				if(fill) {
					cntx.fill();
				} else {
					cntx.stroke();
				}
			},

			
			drawStartEndPoints: function dsep(widget, lines, context, dp) {
				var l = lines.length;

				var cntx = null,
				r = widget.startEndPointRadius;

				
				if (context) {
					cntx = context;
				} else {
					cntx = widget.context;
				}

				cntx.save();

				var spc = '#f0f43e',
					epc = '#f0f43e',
					opc = '#663300';

				if(widget.startPointColor) {
					spc = widget.startPointColor;
				}

				if(widget.endPointColor) {
					epc = widget.endPointColor;
				} else {
					
					
					var	s = lines[0].y,
					h = lines[l -1].y;
					if( s > h) {
						epc = '#008000';
					} else if( s < h) {
						epc = '#8d1616';
					} else {
						epc = spc;
					}
				}

				if (widget.otherPointColor) {
					opc = widget.otherPointColor;
				}

				if(dp & D_S_P && lines[0]) {
					cntx.strokeStyle = spc;
					cntx.fillStyle = spc;
					
					this.drawArc(this, lines[0].x, lines[0].y, r, 0, Math.PI * 2, true, true, cntx);
				}

				if(dp & D_E_P && lines[l - 1]) {
					cntx.strokeStyle = epc;
					cntx.fillStyle = epc;
					this.drawArc(this, lines[l - 1].x, lines[l - 1].y, r, 0, Math.PI * 2, true, true, cntx);
				}

				if(dp & D_O_P) {
					cntx.strokeStyle = opc;
					cntx.fillStyle = opc;
					
					for (var i = 1; i < l -1; i ++) {
						if(lines[i]){
							this.drawArc(this, lines[i].x, lines[i].y, r, 0, Math.PI * 2, true, true, cntx);
						}
					}
				}

				cntx.restore();
			},

            
			getColor: function gtclr(w) {
				return (parseInt(w.themeColor.substr(1), 16) > 0x7fffff) ? '#000000' : '#ffffff';
			},

            
            drawHighlightLine: function drwHghlghtln(w, y) {
				var ctx = w.context,
                    margin = w.margin,
					x1 = margin.l,
					x2 = w.isTimeSeries ? w.chartWidth + margin.l : w.getWidth() - margin.r;

				ctx.save();
                
				ctx.globalAlpha = 1;
				ctx.strokeStyle = this.rgb2rgbStr(w.formatProp.textClr, 0.35)
				ctx.lineWidth = 1;
				ctx.lineCap = 'round';

                
				while (x1 < x2) {
					ctx.beginPath();
					ctx.moveTo(x1, y);
					x1 += 2;
					ctx.lineTo(x1, y);
					ctx.stroke();
					x1 += 3;
				}

				ctx.restore();
			},


            
			addLabel: function adDtLbl(w, text, x, y, width, rotate, prevLabel) {

				
                var lbl = document.createElement("div");
                lbl.className = 'mstrmojo-Chart-lbl';
                lbl.style.color = this.rgb2rgbStr(w.formatProp.textClr, 0.8);

                lbl.innerHTML = text;

                if (width) {
                    lbl.style.width = width + 'px';
                }
                var node = null;
                var aWidth = 0;
                if(w.isTimeSeries) {
                	if(prevLabel.w >= 0) {
                		node = w.xdiv;
                		aWidth = w.animationCanvas.width;
                	} else {
                		node = w.domNode.getElementsByClassName('mstrmojo-chart-ylbl-div')[0];
                		if(!node) {
                			node = document.createElement("div");
                			node.id = 'mstrmojo-chart-ylbl-div';
                			node.className = 'mstrmojo-chart-ylbl-div';
                	
                	
                			w.domNode.appendChild(node);
                		}
                		node.style.width = w.margin.l - 1 + 'px';
                	}
                } else {
                	node = w.domNode;
                	aWidth = w.getWidth();
                }

                
                
                node.appendChild(lbl);

                var lblTextWidth = lbl.offsetWidth || ( w.getTextWidth && w.getTextWidthByElem(text,lbl) );

                

                
                var ht = lbl.offsetHeight || 22*(ZoomFactor || 1); 
                var wd = width || lblTextWidth || 100;

                var X_PAD = w.xLabelPadding/2;
                var Y_PAD = w.yLabelPadding/2;

                
                 if(prevLabel.w >= 0 && w.isTimeSeries && w._scroller.origin){
                	 var distanceOffOrgin = x - w._scroller.origin.x;
                	 if(distanceOffOrgin <= 0 && (distanceOffOrgin + lblTextWidth/2 > -w.maxYLblWidth)){
                	 	w.needRedrawVerticalLine = true;
                	 	node.removeChild(lbl);
                		return null;
                	 }

                	 var distanceOffLegend = distanceOffOrgin - w.getChartWidthOnScreen();
                	 if( (distanceOffLegend - lblTextWidth/2) <=0  && distanceOffLegend >= 0){
                	 	w.needRedrawVerticalLine = true;
                	 	node.removeChild(lbl);
                		return null;
                	 }
                 }


                if(prevLabel.w >= 0) {
                	x = x - wd /2;
                }

                
                if(prevLabel.h >= 0 && ((y >= prevLabel.y - Y_PAD && y <= prevLabel.y + prevLabel.h) ||
                		(y + ht >= prevLabel.y - Y_PAD && y + ht <= prevLabel.y + prevLabel.h) ||
                		(y + ht >= w.canvas.height - w.margin.b) )) {
                	node.removeChild(lbl);
                	return null;
                }

                
                if(prevLabel.w >= 0 && (((x >= prevLabel.x && x < prevLabel.x + prevLabel.w + X_PAD)) || x < prevLabel.x || x < w.margin.l || x + wd > aWidth)) {
                	node.removeChild(lbl);
                	return null;
                }

                
                if(w.isTimeSeries && prevLabel.h >= 0) {
                	node.style.top = (w.margin.t - ht/2) + 'px';
                	
                	node.style.height = (w.canvas.height - w.margin.t - w.margin.b -1 + ht/2) + 'px'; 
                	this.translateCSS(x, (y - w.margin.t) + ht/2, rotate, lbl);
                } else {
                	this.translateCSS(x, y, rotate, lbl);
                	lbl.style.maxHeight = ht + 'px'; 
                }

                
                prevLabel.x = x;
                prevLabel.y = y;
                if(prevLabel.h >= 0) {
                	prevLabel.h = ht;
                }
                if(prevLabel.w >= 0){
                	prevLabel.w = wd;
                	lbl.style.textAlign = 'center';
                }

                return lbl;
			},

            
			addDataLabel: function adDtLbl(w, text, y, prevLabel) {
				var xText = (w.margin.l > w.margin.r) ? TEXTMARGIN : w.getWidth() - w.margin.r + TEXTMARGIN,
                    spaceAvailable = (w.margin.l > w.margin.r) ? w.margin.l : w.margin.r;
                
                return this.addLabel(w, text, xText, y - 10, spaceAvailable-TEXTMARGIN*2, false, prevLabel);
			},

			

			translateCSS: function trnlt(x, y, rotate, lbl) {
			    var value = 'translate(' + x + 'px,' + y + 'px)';
			    if (rotate) {
			        value += ' rotate(45deg)';
			    }

                lbl.style[$DOM.CSS3_TRANSFORM] = value;
			},

			getTouchXYOnWidget: function getTouchXYOnWidget(touchX, touchY, widget){
				var TouchScroller = mstrmojo.TouchScroller,
			 		scrollerOffsets = (TouchScroller && widget.parent && TouchScroller.getScrollPositionTotals(widget.parent)) || { x: 0, y:0}; 

				touchX = touchX - widget.offsetLeft + scrollerOffsets.x;
				touchY = touchY - widget.offsetTop + scrollerOffsets.y;
				return {touchX:touchX, touchY:touchY};
			},

			
		    getYValue: function gyval(widget, point) {
		        var height = widget.canvas.height,
		            margin = widget.margin,
		            mvalues = widget.model.mvalues;
		        return height - margin.b - 4 -((parseFloat(point) - mvalues[0]) * widget.RTY);
		    },

		  
		    getMasterYValue: function getMasterYValue(widget, point, mm ) {
		        var height = widget.masterCanvas.height,
		            mvalues = widget.model.mvalues;
		        return height - mm.b - 3 - ((parseFloat(point) - mvalues[0]) * widget.MRTY);
		    },

		    
		    getSeriesIndexAndYValue: function gsiyv(w, rowIdx, touchY) {
		    	var s = w.model.series,
		    	l = s.length,
		    	si = 0;
				y = this.getYValue(w, s[si].rv[rowIdx]) || 0;
		    	var cp = touchY - y < 0 ? - (touchY - y) : touchY - y,
		    			pp = cp;
		    	for(var i = 1; i < l; i++) {
		    		var cy = this.getYValue(w, s[i].rv[rowIdx]) || 0;
		    		cp = touchY - cy < 0 ? - (touchY - cy) : touchY - cy;
		    		if(cp < pp) {
		    			y = cy;
		    			pp = cp;
		    			si = i;
		    		}
		    	}

		    	return {y:y, si:si};
		    },

		    getLabelWidthForMargin: function tsip(w, text) {
		    	var lbl = document.createElement("div");
                lbl.className = 'mstrmojo-Chart-lbl';
                lbl.innerHTML = text;

                
                w.domNode.appendChild(lbl);
                var wd = lbl.offsetWidth || 60;
                w.domNode.removeChild(lbl);
                return wd + TEXTMARGIN * 2;
		    },

			animateLineSet: function anmtHLnSt(w, fromLines, toLines, cfg) {
                var lines = [],
                    x = w.animationContext,
                    l = toLines.length;

                x.clearRect(0, 0, w.getWidth(), w.canvas.height);

                if (!cfg.index) {
                    cfg.index = 0;
                } else if (cfg.index >= cfg.rate) { 
                    this.drawLineSet(w, toLines, false, x);
                    w.drawLabels();
                    if(w.isFillLinesArea) {
                    	
                    	this.fillLinesArea(w,toLines.slice(0));
                    }
                    if(w.isDrawStartEndPoints) {
                    	this.drawStartEndPoints(w, toLines, x, w.isDrawStartEndPoints);
                    }
                    return;
                }

                for (var i = 0; i < l; i++) {
                    var tli = toLines[i],
                        fli = fromLines[i];
                    lines[i] = {x:(cfg.index * (tli.x - fli.x) / cfg.rate) + fli.x, y:(cfg.index * (tli.y - fli.y) / cfg.rate) + fli.y};
                }

                this.drawLineSet(w, lines, false,  x);

                var me = this;
                cfg.index++;
                window.setTimeout(function() {
                    me.animateLineSet(w, fromLines, toLines,  cfg);
                }, 40);

			},

			
            fillLinesArea: function flA(w,area) {
				var hgt = w.canvas.height;

				area.push({x:w.getWidth() - w.margin.r, y:hgt - w.margin.b});
				area.push({x:w.margin.l, y:hgt - w.margin.b});

                var fillColor = new Array();
                if(w.fillinColor) {
                	mstrmojo.requiresCls("mstrmojo.color");
                	var g = mstrmojo.color.hex2rgb(w.fillinColor).join(',');
                	fillColor[0] = 'rgba(' +  g + ', 0.8)';
                	fillColor[1] = 'rgba(' +  g + ', 0.2)';
                } else {
                	fillColor = ['rgba(255,128,0,0.8)', 'rgba(255,128,0,0.2)'];
                }

                var ctx = w.animationContext;
                var g = ctx.createLinearGradient(0, 0, 0, hgt);

                g.addColorStop(0, fillColor[0]);
                g.addColorStop(0.75, fillColor[1]);

                ctx.fillStyle = g;
                this.drawLineSet(w, area, true, ctx);
            },

            convertRawValueToMilliseconds: function convertRawValueToMilliseconds(val) {
          		var daysSinceJan1st1899_12_30 = Number(val),
            		realVal = daysSinceJan1st1899_12_30 - ((new Date('1/1/1970').getTime() - new Date('12/30/1899').getTime())/millisOnDay) - T_Z_A,
            		dt = new Date(realVal * millisOnDay); 
        		return new Date(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate()).getTime(); 
        	},

        	
        	getAncestorBgColor: function getAncestorBgColor(widget) {
    			var bgColor = null,
    				me = widget,
    				model = me.model,
    				docModel = null;
    			if (me.hasOwnProperty("xtabModel") && me.xtabModel.hasOwnProperty("docModel")) {
    				docModel = me.xtabModel.docModel;
    			}
    			if (docModel && docModel.defn && docModel.defn.layouts && docModel.defn.layouts.length>0) {
    				var layouts = docModel.defn.layouts,
    					layout;
    				var i;
    				
    				for(i in layouts) {
    					if (layouts[i].loaded) {
    						layout = layouts[i];
    					}
    				}
    				if (layout && layout.hasOwnProperty("units")) {
    					var units = layout.units;
    					var parent = model.parent;
    					while (parent) {
    						var pk = parent.k || null;
    						if (units[pk] && units[pk].fmts && units[pk].fmts["background-color"]) {
    							bgColor = units[pk].fmts["background-color"];
    							break;
    						} else {
    							parent = parent.parent || null;
    						}
    					}
    					if (!bgColor) {
    						if (layout.fmts && layout.fmts["background-color"]) {
    							bgColor = layout.fmts["background-color"];
    						}
    					}
    				}

    			}

    			return bgColor;

        	},

        	getPointDistanceSquare: function getPointDistSquare(p1 ,p2){
            	return (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y);
            },

            truncateTextToLine: function(elem, span, lineCount){
            	span.className = elem.className;
            	span.style.whiteSpace = "nowrap";

            	var str = span.innerHTML = elem.innerHTML;
            	var paddingWidth = parseInt(elem.offsetWidth) - parseInt(elem.style.width);
            	var maxWidth = lineCount * parseInt(elem.style.width) + paddingWidth ;

            	var res = str;
            	if(span.offsetWidth > maxWidth){
            		var low = 0,
                    high = str.length - 1;
	                while (low <= high) {
	                    var mid = Math.round((low + high) / 2);
	                    var s0 = str.substr(0, mid+1);
	                    var s1 = str.substr(0, mid+2);
	                    span.innerHTML = s0;
	                    var h0 = span.offsetWidth;
	                    span.innerHTML = s1;
	                    var h1 = span.offsetWidth;

	                    if (h0 <= maxWidth && h1 > maxWidth) {
	                        break;
	                    } else if (h0 > maxWidth) { 
	                        high = mid - 1;
	                    } else if (h1 <= maxWidth) {
	                        low = mid + 1;
	                    }
	                }

	                res = str.substr(0, mid+1);
	                if (res.length < str.length) { 
	                    if (res.charAt(res.length-1) === ' ') { 
	                        res = res.substr(0, res.length-1);
	                    }
	                    var pos = res.lastIndexOf(' ');
	                    var left = res.length - 1 - pos; 
	                    if (left >= 2 && left <= 8) { 
	                        res = res.substr(0, res.length-left-1) + '...';
	                    } else {
	                        res = res.substr(0, res.length-3) + '...'; 
	                    }
	                }
            	}

            	elem.innerHTML = res;
            },
            getLen:function(text, span, errorAdjust, paddingWidth)
            {
            	span.innerHTML = text;
        		var wiLen = span.offsetWidth + errorAdjust - paddingWidth;
        		return wiLen;
            },

            splitWordIfTooLong: function(wlst, span, availSp, paddingWidth, errorAdjust){
        	
        	var wordsArr = wlst.split(' ');
        	var res = [];
        	var sz = wordsArr.length;
        	var i = 0;
        	var j = 0;
        	for (i = 0; i < sz; i++)
        	{
        		var wd = wordsArr[i];
        		while(true){
        			
        			var wiLen = this.getLen(wd, span, errorAdjust, paddingWidth);
        			if(wiLen > availSp){
        				var clipL = (availSp/wiLen) * wd.length;
        				var intClip = Math.round(clipL);

        				while(intClip > 0){
        					var tpWd = wd.substr(0, intClip);
        					var len1 = this.getLen(tpWd, span, errorAdjust, paddingWidth);
        					if(len1<=availSp){
        						res.push( tpWd );
        						break;
        					}
        					else
        						intClip--;
        				}
        				
        				wd = wd.substr(intClip, wd.length - intClip);
        			}
        			else{
        				res.push(wd);
        				break;
        			}
        		}
        	}
        	return res.join(' ');
        },
            truncateTextToLineWithWordWrap: function(elem, span, lineCount){
            	span.className = elem.className;
            	span.style.whiteSpace = "nowrap";

            	var errorAdjust = 7;
            	
            	var availSp = -1;
            	if(elem.style && elem.style.width && elem.style.width.length > 0){
            		availSp= parseFloat(elem.style.width);
            	}
            	if(availSp < 0)
            		availSp = parseFloat(mstrmojo.css.getComputedStyle(elem).width);

            	var str = elem.innerHTML;
            	var paddingWidth = parseFloat(elem.offsetWidth) - availSp;
            	

            	str = this.splitWordIfTooLong( str, span, availSp, paddingWidth, errorAdjust );

            	var wordsArr = str.split(' ');
            	var lenArr = [];
            	var preLenArr = [];
            	var i = 0;
            	var totalLen = 0;
            	var sz = wordsArr.length;
            	span.innerHTML = '&nbsp;';
            	var blankSpaceLen = span.offsetWidth - paddingWidth;
            	preLenArr.push(0);
            	for (i = 0; i < sz; i++)
            	{
            		
            		
            		var wiLen = this.getLen(wordsArr[i], span, errorAdjust, paddingWidth);
            		if(wiLen > availSp){
            			var wd = wordsArr[i];
            			var clipL = (availSp/wiLen) * wd.length;
            			wordsArr[i] = wd.substr(0, parseInt(clipL));
            			wiLen = availSp; 
            		}
            		lenArr.push(wiLen);
            		totalLen += wiLen;
            		preLenArr.push(totalLen);
            		if( i !== sz - 1 )
            			totalLen += blankSpaceLen;
            	}
            	
            	var lnS = 0, lnE = 0;
            	var ln = lineCount;
            	for (; lnE < preLenArr.length; )
            	{
            		var len1 = preLenArr[lnE] - preLenArr[lnS];
            		if(lnS > 0 && lnE != lnS)
            			len1 -= blankSpaceLen;
            		var len2 = preLenArr[lnE+1]-preLenArr[lnS];
            		if(lnS > 0 && lnE + 1 != lnS )
            			len2 -= blankSpaceLen;
            		if( len1 <= availSp &&  ((lnE+1 == preLenArr.length) || (len2 > availSp)))
            		{
            			
            			ln --;
            			if( ln == 0 || lnE === sz )
            				break;
            			else
            			{
            				lnS = lnE;
            				lnE++;
            			}
            		}
            		else
            		{
            			lnE++;
            		}
            	}
            	if(lnE > sz)
            		lnE = sz;
            	var lastlineLen = preLenArr[lnE] - preLenArr[lnS];
        		if(lnS > 0 && lnE != lnS)
        			lastlineLen -= blankSpaceLen;

            	var res;
            	if(lnE >= sz && lastlineLen < availSp)
            		res = wordsArr.join(' ');
            	else{
            		res = wordsArr.slice(0, lnE).join(' ');
            		
            		
            		
            		

            		
                	
                	var elipLen = this.getLen('...', span, errorAdjust, paddingWidth);

                	if( lastlineLen + elipLen <= availSp)
                		res += '...';
                	else
                	{
                		if (res.charAt(res.length-1) === ' ') { 
	                        res = res.substr(0, res.length-1);
	                    }
	                    var pos = res.lastIndexOf(' ');
	                    var left = res.length - 1 - pos; 
	                    
	                    if( left === 3 )
	                    	res = res.substr(0, res.length-3) + ' ...'; 
	                    else
	                    	res = res.substr(0, res.length-3) + '...';
                	}
            	}
            	elem.innerHTML = res;
            },

            getLen2:function(text, fontStr, txtCvs)
            {
            	var canvas = txtCvs;
				var context = canvas.getContext('2d');
				context.font = fontStr;
				context.textAlign = 'center';
				context.fillStyle = 'blue';
				
				var metrics = context.measureText(text);
				var width = metrics.width;
				return width;
            },

            splitWordIfTooLong2: function(wlst, availSp, fontStyle, txtCvs){
            	
            	var wordsArr = wlst.split(' ');
            	var res = [];
            	var sz = wordsArr.length;
            	var i = 0;
            	var j = 0;
            	for (i = 0; i < sz; i++)
            	{
            		var wd = wordsArr[i];
            		while(true){
            			
            			var wiLen = this.getLen2(wd, fontStyle, txtCvs);
            			if(wiLen > availSp){
            				var clipL = (availSp/wiLen) * wd.length;
            				var intClip = Math.max(Math.round(clipL), 1);

            				while(intClip > 0){
            					var tpWd = wd.substr(0, intClip);
            					var len1 = this.getLen2(tpWd, fontStyle, txtCvs);
            					
            					if(len1<=availSp ||intClip == 1){
            						res.push( tpWd );
            						break;
            					}
            					else
            						intClip--;
            				}
            				
            				wd = wd.substr(intClip, wd.length - intClip);
            			}
            			else{
            				res.push(wd);
            				break;
            			}
            		}
            	}
            	return res.join(' ');
            },

            
            getComputedFontStyle: function getCFontStyle(computedStyle){
                var fontStyle = computedStyle.fontStyle + " "
                    + computedStyle.fontWeight + " "
                    + computedStyle.fontSize + "/"
                    + computedStyle.fontVariant
                    + " " + computedStyle.fontFamily;

                return fontStyle;
            },

            
            truncateTextToLineWithWordWrap2: function(elem, txtCvs, lineCount){
            	
            	var availSp = -1;
            	if(elem.style && elem.style.width && elem.style.width.length > 0){
            		var paddingWidth = 0;

					var compStyle = mstrmojo.css.getComputedStyle(elem);
					if( compStyle.paddingLeft ){
						paddingWidth += parseFloat(compStyle.paddingLeft);
					}
					if( compStyle.paddingRight ){
						paddingWidth += parseFloat(compStyle.paddingRight);
					}

					var elemWidth = elem.offsetWidth;
					availSp = elemWidth ? elemWidth - paddingWidth : parseInt(elem.style.width);
            	}
            	if(availSp < 0){

            		elem.innerHTML = "...";
            		return;
            	}

            	var str = elem.innerHTML;
            	var computedStyle = mstrmojo.css.getComputedStyle(elem);
            	var fontStyle = this.getComputedFontStyle(computedStyle);
            	str = this.splitWordIfTooLong2( str, availSp, fontStyle, txtCvs );


            	var wordsArr = str.split(' ');
            	var lenArr = [];
            	var preLenArr = [];
            	var i = 0;
            	var totalLen = 0;
            	var sz = wordsArr.length;
            	
            	var blankSpaceLen = this.getLen2(' ', fontStyle, txtCvs);
            	preLenArr.push(0);
            	for (i = 0; i < sz; i++)
            	{
            		
            		
            		var wiLen = this.getLen2(wordsArr[i], fontStyle, txtCvs);
            		if(wiLen > availSp){
            			var wd = wordsArr[i];
            			var clipL = (availSp/wiLen) * wd.length;
            			wordsArr[i] = wd.substr(0, parseInt(clipL));
            			wiLen = availSp; 
            		}
            		lenArr.push(wiLen);
            		totalLen += wiLen;
            		preLenArr.push(totalLen);
            		if( i !== sz - 1 )
            			totalLen += blankSpaceLen;
            	}
            	
            	var lnS = 0, lnE = 0;
            	var ln = lineCount;
            	for (; lnE < preLenArr.length; )
            	{
            		var len1 = preLenArr[lnE] - preLenArr[lnS];
            		if(lnS > 0 && lnE != lnS)
            			len1 -= blankSpaceLen;
            		var len2 = preLenArr[lnE+1]-preLenArr[lnS];
            		if(lnS > 0 && lnE + 1 != lnS )
            			len2 -= blankSpaceLen;
            		if( len1 <= availSp &&  ((lnE+1 == preLenArr.length) || (len2 > availSp)))
            		{
            			
            			ln --;
            			if( ln == 0 || lnE === sz )
            				break;
            			else
            			{
            				lnS = lnE;
            				lnE++;
            			}
            		}
            		else
            		{
            			lnE++;
            		}
            	}
            	if(lnE > sz)
            		lnE = sz;
            	var lastlineLen = preLenArr[lnE] - preLenArr[lnS];
        		if(lnS > 0 && lnE != lnS)
        			lastlineLen -= blankSpaceLen;

            	var res;
            	if(lnE >= sz && lastlineLen < availSp)
            		res = wordsArr.join(' ');
            	else{
            		res = wordsArr.slice(0, lnE).join(' ');
            		
            		
            		
            		

            		
                	
                	var elipLen = this.getLen2('...', fontStyle, txtCvs);

                	if( lastlineLen + elipLen <= availSp)
                		res += '...';
                	else
                	{
                		if (res.charAt(res.length-1) === ' ') { 
	                        res = res.substr(0, res.length-1);
	                    }
	                    var pos = res.lastIndexOf(' ');
	                    var left = res.length - 1 - pos; 
	                    
	                    if( left === 3 )
	                    	res = res.substr(0, res.length-3) + ' ...'; 
	                    else
	                    	res = res.substr(0, res.length-3) + '...';
                	}
            	}
            	elem.innerHTML = res;

                return res.indexOf('...') > -1;
            },



            truncateDivContent: function (str, span, comp) {
				span.innerHTML = str;
                if (span.offsetHeight > comp) { 
                    var low = 0,
                        high = str.length - 1;
                    while (low <= high) {
                        var mid = Math.round((low + high) / 2);
                        var s0 = str.substr(0, mid+1);
                        var s1 = str.substr(0, mid+2);
                        span.innerHTML = s0;
                        var h0 = span.offsetHeight;
                        span.innerHTML = s1;
                        var h1 = span.offsetHeight;

                        if (h0 <= comp && h1 > comp) {
                            break;
                        } else if (h0 > comp) { 
                            high = mid - 1;
                        } else if (h1 <= comp) {
                            low = mid + 1;
                        }
                    }

                    var res = str.substr(0, mid+1);
                    if (res.length < str.length) { 
                        if (res.charAt(res.length-1) === ' ') { 
                            res = res.substr(0, res.length-1);
                        }
                        var pos = res.lastIndexOf(' ');
                        var left = res.length - 1 - pos; 
                        if (left >= 2 && left <= 8) { 
                            res = res.substr(0, res.length-left-1) + '...';
                        } else {
                            res = res.substr(0, res.length-3) + '...'; 
                        }
                    }
                    return res;
                } else {
					return str;
				}
			}


        });

})();
(function(){

    mstrmojo.requiresCls("mstrmojo.dom");
    
    var _D = mstrmojo.dom,
        _DND,
        _doc = mstrmojo.global.document;
    
    function _onMouseDown(e){        
        _DND.startDragCheck(self, e);
    }
    
    var _av,
        _avin,
        _avCSS = 'mstrmojo-dnd-avatar',
        _avs;
    
    function _updateAvatar(pos, allowDrop, html){
        if (html != null) { 
            _avin.innerHTML = html;         
        }
        _avs.left = pos.x + 'px';
        _avs.top = pos.y + 'px';
    }
    function _showAvatar(html, pos){
        if (!_av) {
            _av = _doc.createElement("div");
            _avs = _av.style;
            _av.className = _avCSS;
            _av.innerHTML = '<div class="'+ _avCSS + '-inner"></div>';
            _avin = _av.firstChild;
            _doc.body.appendChild(_av);
        }
        _updateAvatar(pos, true, html);
        _avs.display = 'block';
    }
    function _hideAvatar(){
        if (_av) {
            _avs.display = 'none';
        }
    }
    
    
     function _onMoveDuringCheck(e) {
        var c = ++_DND.ctxt.moveCount;
        if (c >= _DND.minMoves) {
            
            _DND.stopDragCheck(self, e);
            _DND.startDrag(self, e);
        }
    }
    
    
    function _onUpDuringCheck(e) {
        _DND.stopDragCheck(self, e);
    }
    
    
    function _onMoveDuringDrag(e) {
        _DND.onDragMove(self, e);
    }

    
    function _onUpDuringDrag(e) {
        _DND.stopDrag(self, e);
    }

    
    function _capEvtInf(h) {
        if (!h) {
            return;
        }        
        if (!h.hWin) {
            h.hWin = window;
        }
        if (!h.e) {
            h.e = h.hWin.event;
        }

        h.node = _D.eventTarget(h.hWin, h.e);
        h.pos = _D.getMousePosition(h.e, h.hWin);
        
        return h;
    }
    
    
    function _findDraggable(nd){
        var w = _D.findWidget(nd);
        while (w) {
            if (w.draggable) {
                return w;
            }
            w = w.parent;
        }
        return null;
    }
    
    
    function _findDroppable(nd, c){
        var w = _D.findWidget(nd);
        while (w) {
            if (w.dropZone) {
                
                
                if (w.allowDrop && w.allowDrop(c)) {
                    return w;
                }
            }
            w = w.parent;
        }
        return null;
    }
    

        
    function _ondragenterDefault(c){
        if (this.set) {
            this.set("allowingDrop", true);
        }
    }

        
    function _ondragleaveDefault(c){
        if (this.set) {
            this.set("allowingDrop", false);
        }
    }

        
    var _ondropDefault = _ondragleaveDefault;

    
    mstrmojo.dnd = mstrmojo.provide(
        "mstrmojo.dnd",
        
        {
            
            minMoves: 3,

                        
            enable: function(){
                if(!mstrmojo.dndEnabled){
                    _D.attachEvent(_doc, "mousedown", _onMouseDown);
                    mstrmojo.dndEnabled = true;
                } 
            },
            
                        
            disable: function(){
                _D.detachEvent(_doc, "mousedown", _onMouseDown);
            },
        
            
            startDragCheck: function(hWin, e){
                delete this.ctxt;
                                
                var src = _capEvtInf({hWin: hWin, e: e});
                
                this.ctxt = {src: src, moveCount: 0};
                    
                
                if (this.minMoves) {
                    
                    _D.attachEvent(_doc, "mousemove", _onMoveDuringCheck);
                    _D.attachEvent(_doc, "mouseup", _onUpDuringCheck);
                } else {
                    
                    this.startDrag(hWin, e);
                }
            },

            
            stopDragCheck: function(hWin, e){
                _D.detachEvent(_doc, "mousemove", _onMoveDuringCheck);
                _D.detachEvent(_doc, "mouseup", _onUpDuringCheck);
            },

            
            startDrag: function(hWin, e){
                
                var c = this.ctxt;
                c.id = new Date();

                var src = c.src,
                    w = _findDraggable(src.node);
                if (!w) {
                    return;
                }
                
                
                src.widget = w;
                src.data = w.getDragData && w.getDragData(c);
                
                
                if (w.ondragstart) {
                    if (w.ondragstart(c) === false) {
                        
                        return;
                    }
                }
                
                
                
                _D.clearBrowserHighlights();
                _D.preventDefault(self, e);

                _D.attachEvent(_doc, "mousemove", _onMoveDuringDrag);
                _D.attachEvent(_doc, "mouseup", _onUpDuringDrag);
                
                if(w && !w.ownAvatar) {
                    _showAvatar(src.data && src.data.html, src.pos);
                }
            },

            
            stopDrag: function(hWin, e){                
                
                _D.detachEvent(_doc, "mousemove", _onMoveDuringDrag);
                _D.detachEvent(_doc, "mouseup", _onUpDuringDrag);

                
                var c = this.ctxt,
                    ct = _capEvtInf({hWin: hWin, e: e}),
                    w = _findDroppable(ct.node, c);
                ct.widget = w;
                c.tgt = ct;
                
                
                
                
                
                
                
                
                
                if (w) {
                    
                    if (w.ondrop) {
                        w.ondrop(c);
                    } else {
                        _ondropDefault.apply(w, [c]);
                    }
                }

                
                var s = c.src.widget;
                if (s && s.ondragend) {
                    s.ondragend(c);
                }

                
                
                if(s && !s.ownAvatar) {
                    _hideAvatar();
                }
            },
            
            
            onDragMove: function(hWin, e){
                if (_D.isSafari) {
                    _D.clearBrowserHighlights();
                }

                
                var c = this.ctxt,
                    ct = _capEvtInf({hWin: hWin, e: e}),
                    w = _findDroppable(ct.node, c);
                ct.widget = w;      
                                
                
                var tWas = c && c.tgt && c.tgt.widget;
                
                c.tgt = ct;
                
                if (tWas !== w) {
                    

                    
                    if (tWas) {
                        
                        if (tWas.ondragleave) {
                            tWas.ondragleave(c);
                        } else {
                            _ondragleaveDefault.apply(tWas, [c]);
                        }
                    }
                    
                    
                    if (w) {
                        
                        if (w.ondragenter) {
                            w.ondragenter(c);
                        } else {
                            _ondragenterDefault.apply(w, [c]);
                        }
                    }
                } else if (w) {
                    
                    
                    
                    if (w.ondragover) {
                        w.ondragover(c);
                    }
                } 

                
                var s = c.src.widget;
                if (s && s.ondragmove) {
                    s.ondragmove(c);
                }
                
                if(s && !s.ownAvatar) {
                    _updateAvatar(ct.pos, !!w);                
                }
            }
            
        });
        
    _DND = mstrmojo.dnd;

    
    _DND.enable();

})();


(function () {

    mstrmojo.requiresCls("mstrmojo.dom");

    var $D = mstrmojo.dom,
        _switchDimensions = false;

    
    mstrmojo._FillsBrowser = mstrmojo.provide(

        "mstrmojo._FillsBrowser",

        
        {
            _mixinName: 'mstrmojo._FillsBrowser',

            getBrowserDimensions: function () {
                var winDim = $D.windowDim(),
                    browserOffset = ($D.isFF || $D.isWK) ? 0 : 2;    

                var w = winDim.w,
                    h = winDim.h;
                
                if (_switchDimensions) {
                    var t = h;
                    h = w;
                    w = t;
                }

                return {
                    w: Math.max(w, 0) + 'px',
                    h: Math.max(h - browserOffset, 0) + 'px'
                };
            },

            

            simulateOrientationChange: function simulateOrientationChange() {
                _switchDimensions = !_switchDimensions;
                this.monitorWindow();
            },

            
            preBuildRendering: function preBuildRendering() {
                var rtn = true;
                if (this._super) {
                    rtn = this._super();
                }

                var d = this.getBrowserDimensions();

                
                if (!('browserResized' in this) || this.browserResized(d) !== true) {
                    this.height = d.h;
                    this.width = d.w;
                }

                
                if (!this._listenerProc) {
                    
                    window._monitor = this;

                    
                    var id = this.id,
                        fn = this._listenerProc = function (e) {
                            var evt = e || window.event;
                            mstrmojo.all[id].monitorWindow(evt);
                        };

                    
                    $D.attachEvent(window, 'resize', fn);
                }
                return rtn;
            },

            
            destroy: function destroy(ignoreDom) {
                
                if (this._listenerProc) {
                    
                    $D.detachEvent(window, 'resize', this._listenerProc);
                }
                this._super(ignoreDom);
            },

            
            monitorWindow: function (evt) {
                
                var currentTarget = evt.currentTarget,                             
                    d = this.getBrowserDimensions(),
                    size = {
                        w: (currentTarget ? currentTarget.innerWidth + 'px': d.w),
                        h: (currentTarget ? currentTarget.innerHeight + 'px': d.h) 
                    };

                
                if (size.h === this.height && size.w === this.width) {
                    
                    return;
                }

                
                
                if (!('browserResized' in this) || this.browserResized(size) !== true) {
                    if (size.h !== this.height) {
                        this.set('height', size.h);
                    }

                    if (size.w !== this.width) {
                        this.set('width', size.w);
                    }
                }
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.dom");

	mstrmojo.fx = {enabled: true};
	
	var $DOM = mstrmojo.dom;	

	
	
	mstrmojo.fx._Effect = mstrmojo.declare(
		
		null,
		
		null,
		
		{
			scriptClass: "mstrmojo.fx._Effect",
			
			
			duration: 500,
			
			
			interval: 50,
			
			
			delay: null,
			
			
			target: null,
			
			
			getTarget: null,
			
			
			widget: null,
			
			
			slot: null,
			
			
			preStart: null,

			
			postStart: null,

			
			onCancel: null,

			
			onEnd: null,

			
			revertOnCancel: true,
			
			
			isPlaying: false,
			
			
			started: false,
			
			
			init: function init( props) {
				mstrmojo.hash.copy(props, this);
			},
									
			
			play: function ply() {
				this.isPlaying = true;
				this.started = false;
				if (this.delay) {
					var me = this;
					this.delayTimer = window.setTimeout(
						function() {
							me._start();
							me = null;
						},  
						this.delay
					);
				} else {
					this._start();
				}
			},
			
			pause: function pause() {
				if (this.delayTimer) {
					window.clearTimeout(this.delayTimer);
					delete this.delayTimer;
				}
				if (this.timer) {
					window.clearInterval(this.timer);
					delete this.timer;
				}
				this.isPlaying = false;
			},

			
			cancel: function cnl() {
				this.pause();
				if (this.started) {
					if (this.revertOnCancel) {
						this.counter = 0;
						this.exec();
					}
					if (this.onCancel) {
						this.onCancel();
					}
					this.started = false;
				}
			},
						
			
			_start: function start() {
				this.started = true;

				
				this._doTarget();

				
				
				this.steps = Math.max(
								Math.ceil(this.duration/this.interval), 
								1);
				
				
				var ea = this.ease;
				if (typeof(ea) == "string") {
					this.ease = mstrmojo.registry.ref(ea);
				}
				
				
				if(this._doPreStart() === false) {
				    this.started = false;
				    this.isPlaying = false;
				    return;
				}

				
				this.counter = 0;
				this.exec();
				this.counter++;

				
				this._doPostStart();
				
				
				if (this.counter >= this.steps) {
					
					this._end();
				} else {
					
					var me = this;
					if (this.timer) {
						window.clearInterval(this.timer);
					}
					this.timer = window.setInterval(
							function fxIntvl(){
							    if (me) {
							        me.exec();
							        me.counter++;
							        if (me.counter >= me.steps) {
							            me._end();
							            me = null;
							        }
							    }
							},
							this.interval);
				}
			},

						
			exec: null,
			
			
			_end: function end(){
				
				this.pause();
				this.started = false;
				if (this.onEnd) {
					this.onEnd();
				}
			},

            _doTarget: function tgt() {
                
                if (this.getTarget) {
                    
                    this.target = this.getTarget.apply(this, []);
                } else if (this.widget) {
                    
                    
                    this.target = this.widget[this.slot || "domNode"];
                } else if (this.target) {
                    
                    var t = this.target;
                    if (t && this.slot && t.scriptClass) {
                        var node = t[this.slot];
                        if (node) {
                            this.widget = t;
                            this.target = node;
                        }
                    }
                }
				
				
				
				
				if (!this.target) {
					var w = this;
					while (w = w.parent) {	
						if (!w || w.domNode){
						  break;
                        }
					}
					if (w) {
						this.widget = w;
						this.target = w[this.slot || "domNode"];
					}
				}
			},

			_doPreStart: function pre(){
				if (this.preStart) {
					 return this.preStart();
				}
			},
			_doPostStart: function post(){
				if (this.postStart) {
					this.postStart();
				}
			}			
		}
	);		

	
	function _callChildren(me, fName) {
		var arr = me.children;
		for (var i=0, len=(arr&&arr.length) || 0; i<len; i++) {
			arr[i][fName]();
		}
	}
	
	
	mstrmojo.fx.Parallel = mstrmojo.declare(
		
		mstrmojo.fx._Effect,
		
		null,
		
		{
			scriptClass: "mstrmojo.fx.Parallel",
			
			init: function init( props) {
				this._super(props);
				
				
				var ch = this.children;
				mstrmojo.registry.refArray(ch);
				
				for (var i=0, len=(ch&&ch.length)||0; i<len; i++) {
					ch[i].parent = this;
				}
			},
			
			
			_start: function start() {
				this.started = true;

				if (this.preStart) {
					this.preStart();
				}

				_callChildren(this, "play");
				
				if (this.postStart) {
					this.postStart();
				}
			},

			
			pause: function pause() {
				_callChildren(this, "pause");
			},

			
			cancel: function cnl() {
				_callChildren(this, "cancel");
			}
		}
	);
	
    
    mstrmojo.fx.AnimateProp = mstrmojo.declare(
		
		mstrmojo.fx._Effect,
		
		null,
		
		{
			scriptClass: "mstrmojo.fx.AnimateProp",
			
			
			props: null,

			
			_start: function st() {
				
				
				
				var ps = this.props;
				for (var n in ps) {
					var p = ps[n],
						ea = p.ease;
					if (typeof(ea) == "string") {
					    p.ease = mstrmojo.registry.ref(ea, {dontInst: true});
					}
				}
				
				this._super();

			},
									
			exec: function exec() {
				var ps = this.props;
				for (var n in ps) {
					var p = ps[n],
						v = (p.ease || mstrmojo.ease.sin)(this.counter, p.start, p.stop-p.start, this.steps-1);
					if(p.fn){
					    v = p.fn(v);
					}
					if (p.suffix){
					   v += p.suffix;
                    }
                    var o = p.isStyle === false ? this.target : this.target.style;
                    o[n] = v;
				}
			}
		}
	);
	
	mstrmojo.fx.Typewriter = mstrmojo.declare(
		
		mstrmojo.fx._Effect,
		
		null,
		
		{
			scriptClass: "mstrmojo.fx.Typewriter",
			
			charGroupSize: 1,
			
			
			srcProp: "text",
			
			
			_doPreStart: function () {
				
				this._super();
				
				
				this._dynStop = false;
				
				if (this.stop == null) {    
					var sp = this.srcProp,
                        st;
					if (sp) {
						var w = this.widget || this.parent;
						st = w && w[sp];
						if ((st != null) && (typeof(st) !== 'string')) {  
							st = String(st);
						}
					}
					this.stop = st;
					this._dynStop = true;
				}
				
				if (this.stop == null) {
					this.stop = "";
				}

				
				var t = this.target,
					ttn = null,
					cgs = 1;

				if (t) {
					t.innerHTML = '';
					ttn = document.createTextNode('');
					t.appendChild(ttn);
					cgs = Math.max(
							Math.floor(this.stop.length / this.steps),
							1);
				}
				this.targetTextNode = ttn;
				this.charGroupSize = cgs;
			},
			
			exec: function() {
				var ttn = this.targetTextNode;
				if (!ttn) {
				    return;
			    }
				
				var v;
				if (this.counter >= this.steps-1) {
					v = this.stop;
				} else if (this.counter === 0) {
					v = '';
				} else {
					v = this.stop.substring(0, this.charGroupSize * this.counter) + '_';
				}
				ttn.nodeValue = v;
			},
			
			_end: function end() {
				this._super();
				if (this._dynStop) {
					this.stop = null;
					delete this._dynStop;
				}
			},
			
			cancel: function cnl() {
				if (this._dynStop) {
					this.stop = null;
					delete this._dynStop;
				}
			}
		}
	);
	
	mstrmojo.requiresCls("mstrmojo.dom");
		
	
	mstrmojo.fx.Fade = mstrmojo.declare(
		
		mstrmojo.fx._Effect,
		
		null,
		
		{
			scriptClass: "mstrmojo.fx.Fade",
			
			
			start: null,
			stop: null,
			
			
			ease: null,

			
			suffix: null,

			exec: function exec(v) {
				if (v == null) {    
					v = (this.ease || mstrmojo.ease.sin)(this.counter, this.start, this.stop-this.start, this.steps-1);
				}
				if ($DOM.isIE && !$DOM.isWinPhone) {
					
					this.target.style.filter = 'alpha(opacity=' + parseInt(v*100,10) + ')';
					
				} else {
					this.target.style.opacity = v;
				}
			}
		}
	);
	
	
	mstrmojo.fx.FadeOut = mstrmojo.declare(
		
		mstrmojo.fx.Fade,
		
		null,
		
		{
			scriptClass: "mstrmojo.fx.FadeOut",
			
			start: 1,
			stop: 0,
			revertOnCancel: true,
			
			
			cssDisplay: 'block',
			
			
			_end: function end(){
				if (this.cssDisplay) {
					this.target.style.display = 'none';
					this.exec(this.start);
				}
				this._super();
			},
			
			
			cancel: function cnl() {
				if (this.started && this.cssDisplay) {
					this.target.style.display = this.cssDisplay;
				}
				this._super();
			}
		}
	);

	
	mstrmojo.fx.FadeIn = mstrmojo.declare(
		
		mstrmojo.fx.Fade,
		
		null,
		
		{
			scriptClass: "mstrmojo.fx.FadeIn",
			
			start: 0,
			stop: 1,
			revertOnCancel: true,
			
			
			cssDisplay: 'block',
			
			
			_doPostStart: function postS(){
				if (this.cssDisplay) {
					this.target.style.display = this.cssDisplay;
				}
				this._super();
			},
			
			
			cancel: function() {
				if (this.started && this.revertOnCancel && this.cssDisplay) {
					this.target.style.display = 'none';
				}
				this._super();
			}
		}
	);


	function fraction(num, dem, digits) {
		var x = Math.pow(10, digits || 2);
		if (dem) {
			return parseInt(x * num / dem, 10) / x;
		} else {
			return parseInt(x * num,10) / x;
		}
	}
	
	
	mstrmojo.ease = {
		linear: function ln(t, b, c, d) {
			if (t === d){
				return b+c;
			}else if (t === 0){
				return b;
			}else {
				return b + c * fraction(t, d);
            }
		},
		
		sin: function sin(t, b, c, d) {
			return b + c * Math.sin((Math.PI / 2) * t / d);
		},
		
		cos: function cos(t, b, c, d) {
			return b + c * Math.cos((Math.PI / 2) * (1 - t / d));
		},
		
		sincos: function sincos(t, b, c, d) {
			if (t > d / 2) {
				return b + c * Math.cos((Math.PI / 2) * (1 - t / d));
			} else {
				return b + c * Math.sin((Math.PI / 2) * t / d);
            }
		},
		
		cossin: function cossin(t, b, c, d) {
			if (t > d / 2) {
				return b + c * Math.sin((Math.PI / 2) * t / d);
			} else {
				return b + c * Math.cos((Math.PI / 2) * (1 - t / d));
            }
		},
		
		bounce: function bounce(t, b, c, d) {
			if ((t /= d) < (1 / 2.75)) {
			      return c * (7.5625 * t * t) + b;
			}
			else if (t < (2 / 2.75)) {
			      return c * (7.5625 * (t-=(1.5/2.75)) * t + 0.75) + b;
			}
			else if (t < (2.5 / 2.75)) {
			      return c * (7.5625 * (t-=(2.25/2.75)) * t + 0.9375) + b;
			}
			else {
			      return c * (7.5625 * (t-=(2.625/2.75)) * t + 0.984375) + b;
			}
		},
		
		shake: function shake(t, b, c, d) {
			if (t < d/2) {
				return b + c * fraction(Math.sin(2 * Math.PI * t/8), null, 2) * 2 * t/d;
			} else {
				return b + c * fraction(Math.sin(2 * Math.PI * t/8), null, 2) * 2 *(1-t/d);

			}
		}

	};
	
})();

(function () {

    mstrmojo.requiresCls("mstrmojo.string",
                         "mstrmojo.dom");

    var _S = mstrmojo.string,
        _D = mstrmojo.dom;

    
    var _elCreate = mstrmojo.useFrames ? null : document.createElement('span');

    var _REG_EXP_EVTS = /\mstrAttach\:([\w\,]+)/g;

    
    var isTouchEnabled;

    
    function _replEvts(s) {
        
        if (isTouchEnabled === undefined) {
            
            isTouchEnabled = (mstrApp !== undefined && mstrApp.isTouchApp && mstrApp.isTouchApp()) || false;
        }

        return s.replace(_REG_EXP_EVTS, function hRepl(token, es) {
            var arr = es.split(","),
                out = [],
                len = arr.length,
                i;

            for (i = 0; i < len; i++) {
                var e = arr[i];
                if (e) {
                    
                    if (isTouchEnabled) {
                        
                        if (e.indexOf('mouse') > -1) {
                            
                            continue;

                        
                        } else if (e === 'click') {
                            
                            e = 'touchend';
                        }
                    }

                    
                    out.push('on' + e + '="mstrmojo.dom.captureDomEvent(\'{@id}\',\'' + e + '\', self, event)"');
                }
            }
            return out.join(" ");
        });
    }

    var PRE = 'preBuildRendering',
        BUILD = 'buildRendering',
        POST = 'postBuildRendering';

    
    function _build(widget) {

        var s = widget.markupString;
        
        if (s.match(/mstrAttach:/)) {
            
            s = _replEvts(s);
            
            if (widget.markupString === widget.constructor.prototype.markupString) {
                
                widget.constructor.prototype.markupString = s;
            }
        }
        var html = _S.apply(s, widget);
        if (html) {
            if (mstrmojo.useFrames) {
                
                
                var doc = (widget.domNode && widget.domNode.ownerDocument) ||
                            self.document;
                if (!_elCreate || _elCreate.ownerDocument !== doc) {
                    _elCreate = doc.createElement('span');
                }
            }
            _elCreate.innerHTML = html;
            var d = _elCreate.firstChild;
            
            d.mstrmojoId = widget.id;
            return d;
        }
        return null;
    }

    
    function _callSlots(widget) {
        
        var ms = widget.markupSlots,
            nodes,
            n;

        if (ms) {
            nodes = {};
            for (n in ms) {
                nodes[n] = ms[n].apply(widget, []);
            }
        }
        return nodes;
    }

    
    mstrmojo._HasMarkup = mstrmojo.provide(
        "mstrmojo._HasMarkup",
        
        {
            
            

            
            

            
            

            onRender: mstrmojo.emptyFn,

            onUnRender: mstrmojo.emptyFn,

            
            render: function rnd() {
                if ((this[PRE] && this[PRE]() === false) || (this[BUILD]() === false) || (this[POST] && this[POST]() === false)) {
                    return false;
                }

                this.hasRendered = !!this.domNode;

                this.onRender();

                
                var evtName = 'renderComplete';
                if (mstrmojo.publisher.hasSubs(this.id, evtName)) {
                    
                    this.raiseEvent({
                        name: evtName
                    });
                }

                return true;
            },


            buildDom: function buildDom() {
                return _build(this);
            },

            preBuildRendering: mstrmojo.emptyFn,

            
            buildRendering: function bldRnd() {

                
                var dnWas = this.domNode,
                    dn = this.buildDom();

                this.domNode = dn;

                
                if (this.postBuildDom) {
                    this.postBuildDom();
                }

                
                if (this.slotNames) {
                    this.removeSlots(this.slotNames);
                }
                
                this.addSlots(_callSlots(this));

                
                this.paint();

                
                if (dn) {
                    
                    var ph = dnWas;
                    if (!ph) {
                        
                        ph = this.placeholder;
                        if (ph) {
                            
                            if (typeof ph === 'string') {
                                ph = document.getElementById(ph);
                            }
                            
                            delete this.placeholder;
                        }
                    }
                    if (ph) {
                        _D.replace(ph, dn);
                    }
                }

                
                
                
                
                var fn = "onchildRenderingChange",
                    p = this.parent;
                if (p && p[fn]) {
                    p[fn](this);
                }

                return true;
            },

            postBuildRendering: mstrmojo.emptyFn,

            
            unrender: function unrn(ignoreDom) {
                
                if (this.hasRendered) {
                    if (!ignoreDom) {
                        try {
                            var dn = this.domNode;
                            
                            if (dn.parentNode) {
                                dn.parentNode.removeChild(dn);
                            }
                            
                            if (mstrmojo.dom.isIE && dn.outerHTML !== "undefined") {
                                dn.outerHTML = "";
                            }
                        } catch (ex) {
                          
                        }
                    }
                    this.domNode = null;
                    this.removeSlots(this.slotNames);
                    this.hasRendered = false;

                    this.onUnRender();
                }
            },

            
            paint: function pnt() {
                var ms = this.markupMethods;
                if (!ms) {
                    return;
                }
                var me = this,
                    callM = function (n) {
                        var f = ms[n];
                        if (f) {
                            try {
                                f.apply(me, [true]);
                            } catch (localerr) {
                                throw new Error([
                                    "Error in markup method.",
                                    "Widget id: " + me.id,
                                    "Method name: " + n,
                                    "Err: " + localerr.message
                                ].join('\n\n'));
                            }
                        }
                    };
                var s = ms.sequence,
                    len,
                    i,
                    n;

                if (s) {
                    len = s.length || 0;
                    for (i = 0; i < len; i++) {
                        callM(s[i]);
                    }
                } else {
                    for (n in ms) {
                        callM(n);
                    }
                }
            },

            
            refresh: function refresh(postUnrender) {
                if (this.hasRendered) {
                    
                    
                    var ph = this.domNode;
                    
                    
                    this.unrender(true);
                    this.placeholder = ph;
                    if (postUnrender) {
                        postUnrender();
                    }
                    this.render();
                }
            },

            
            set: function set(n, v) {
                
                
                this._super(n, v);

                if (this.domNode) {  
                    
                    
                    
                    
                    var ms = this.markupMethods,
                        f = ms && ms["on" + n + "Change"];
                    if (f) {
                        f.apply(this);
                    }
                }
                return this;
            },


            
            slotNames: null,

            
            addSlots: function addSlots(slots) {
                
                var ns = this.slotNames,
                    n;

                if (!ns) {
                    ns = {};
                    this.slotNames = ns;
                }

                
                for (n in slots) {
                    this[n] = slots[n];
                    ns[n] = true;
                }
            },

            
            removeSlots: function rmvSlts(slots) {
                if (slots) {
                    var sns = this.slotNames,
                        n;

                    for (n in slots) {
                        delete this[n];
                        if (sns) {
                            delete sns[n];
                        }
                    }
                }
            },

            
            captureDomEvent: function cap(type, hWin, e, config) {
                if (this.enabled !== false) {
                    this.raiseEvent({
                        name: type,
                        hWin: hWin,
                        e: e || hWin.event,
                        config: config
                    });
                }
            },

            
            playEffect: function playEffect(n) {
                var fx = this[n];
                if (fx && fx.constructor === Object) {
                    fx = mstrmojo.insert(mstrmojo.hash.clone(fx)); 
                    fx.widget = this;
                    this[n] = fx;
                }
                if (fx) {
                    fx.play();
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom");

    var $DOM = mstrmojo.dom;

    
    var CGS_HEIGHT = 1,
        CGS_WIDTH = 2;

    
    function canGrowOrShrink(children) {
        var defn = this.defn,
            verticalConfig = defn.vc,
            horizontalConfig = defn.hc;

        
        if (!children || children.length === 0 || (!verticalConfig && !horizontalConfig)) {
            
            return {};
        }

        return {
            v: !!verticalConfig,
            h: !!horizontalConfig
        };
    }

    
    function getInitialSize(mode) {
        return parseInt(this.getFormats()[(mode === CGS_HEIGHT) ? 'height' : 'width'], 10);
    }

    
    function getMaxSize(mode) {
        var maxProperty = this.getFormats()['max-' + ((mode === CGS_HEIGHT) ? 'height' : 'width')];
        return maxProperty && parseInt(maxProperty, 10);
    }

    
    function getDynamicChildDomNode(child, mode) {
        
        
        
        var defn = this.defn,
            childDomNode = child && (child.dimNode || child.domNode),
            dynamicChild = defn.ck && defn.ck[child && (child.k || child.content.k)];

        
        if (childDomNode && dynamicChild && (dynamicChild & mode)) {
            
            return childDomNode;
        }

        
        return null;
    }

    
    function getChildEndPoint(child, mode, domNode, size) {
        
        var start = parseInt(domNode.style[(mode === CGS_HEIGHT) ? 'top' : 'left'], 10);

        
        if (!!size) {
            
            return start + size;
        }

        
        var fx = (child.fmts && child.fmts.fx) || {},
            rotatedMode = (!$DOM.isIE7 && (fx.rt === 1 || fx.rt === 3)) ? ((mode === CGS_HEIGHT) ? CGS_WIDTH : CGS_HEIGHT) : mode,     
            rotatedUCProperty = (rotatedMode === CGS_HEIGHT) ? 'Height' : 'Width';                                                     

        
        
        
        
        size = domNode['offset' + rotatedUCProperty] + (fx.ds || 0);

        
        var endPoint = start + size;

        
        
        
        
        
        if ($DOM.isIE7 && rotatedUCProperty === 'Width' && child instanceof mstrmojo.XtabBase) {
            var childWidth = child.contentNode.offsetWidth;
            if (endPoint < childWidth) {
                endPoint += childWidth;
            }
        }

        return endPoint;
    }

    
    function updateCalculatedSize(endPoint, calculatedSize, maxSize) {
        
        if (endPoint > calculatedSize) {
            
            if (maxSize) {
                
                endPoint = Math.min(endPoint, maxSize);
            }

            
            return endPoint;
        }

        return calculatedSize;
    }

    
    function updateContainerSize(mode, calculatedSize, dontShrink) {
        var containerNode = this.getCanGrowShrinkNode(),
            propertyName = (mode === CGS_HEIGHT) ? 'Height' : 'Width',
            lcPropertyName = propertyName.toLowerCase(),
            currentValue = parseInt(containerNode.style[lcPropertyName], 10);

        
        if (calculatedSize && calculatedSize !== currentValue && !(calculatedSize < currentValue && !!dontShrink)) {
            
            currentValue = calculatedSize;

            
            containerNode.style[lcPropertyName] = currentValue + 'px';

            
            this.afterCanGrowShrink();
        }

        
        this['_fixed' + propertyName] = currentValue;
    }

    
    function calculateSize(ctrls, mode, dontShrink) {
        var maxSize = getMaxSize.call(this, mode),
            calculatedSize = getInitialSize.call(this, mode),
            len = ctrls.length,
            i;

        
        for (i = 0; i < len; i++) {
            var child = ctrls[i],
                childDomNode = getDynamicChildDomNode.call(this, child, mode);

            
            if (!childDomNode) {
                
                continue;
            }

            
            calculatedSize = updateCalculatedSize(getChildEndPoint.call(this, child, mode, childDomNode), calculatedSize, maxSize);

            
            if (calculatedSize === maxSize) {
                
                break;
            }
        }

        
        updateContainerSize.call(this, mode, calculatedSize, dontShrink);
    }

    
    function calculateFixedSize(child, mode, size, dontShrink) {
        
        var childDomNode = getDynamicChildDomNode.call(this, child, mode);
        if (!childDomNode) {
            
            return;
        }

        
        var endPoint = getChildEndPoint.call(this, child, mode, childDomNode, size);

        
        updateContainerSize.call(this, mode, updateCalculatedSize(endPoint, getInitialSize.call(this, mode), getMaxSize.call(this, mode)), dontShrink);
    }

    
    mstrmojo._CanGrowOrShrink = mstrmojo.provide(

        "mstrmojo._CanGrowOrShrink",

        
        {
            
            getCanGrowShrinkNode: function getCanGrowShrinkNode() {
                return this.domNode;
            },

            
            performCanGrowCanShrink: function performCanGrowCanShrink(ch, dontShrink) {
                var config = canGrowOrShrink.call(this, ch);

                
                if (config.v) {
                    
                    calculateSize.call(this, ch, CGS_HEIGHT, dontShrink);
                }

                
                if (config.h) {
                    
                    calculateSize.call(this, ch, CGS_WIDTH, dontShrink);
                }
            },

            
            fixedSizeCanGrowShrink: function fixedSizeCanGrowShrink(child, height, width, dontShrink) {
                
                var config = canGrowOrShrink.call(this, child && [ child ]);

                
                height = parseInt(height, 10);
                width = parseInt(width, 10);

                
                if (config.v && !isNaN(height)) {
                    
                    calculateFixedSize.call(this, child, CGS_HEIGHT, height, dontShrink);
                }

                
                if (config.h && !isNaN(width)) {
                    
                    calculateFixedSize.call(this, child, CGS_WIDTH, width, dontShrink);
                }
            },

            
            afterCanGrowShrink: mstrmojo.emptyFn
        }
    );

}());
(function(){

    mstrmojo.requiresCls("mstrmojo.dom");
    
    var $D = mstrmojo.dom,
        $MATH = Math;
    
    var    PLACEMENT_AUTO = 1,
        PLACEMENT_FIXED = 2,
        PLACEMENT_ABOVE = 3,
        PLACEMENT_BELOW = 4,
        PLACEMENT_LEFT = 5,
        PLACEMENT_RIGHT = 6;
        
        function anchorPopup() {
        
            var anchor = this.anchor;
            
            if(!anchor){
                return false;
            }
            
            
            var  baseTipCls = this.baseTipClass, 
                tipNode = this[this.tipNodeName];
            tipNode.className = baseTipCls + ' top';
            
            var boundary = this[this.boundaryNodeName],
                popupNode = this[this.popupNodeName],
                editorOffset = this.anchorOffset,
                defaultOrientation = this.anchorOrientation,
                hasScrollbars = this.hasScrollbars(),
                anchorPosition = mstrmojo.hash.copy(this.anchorPosition || $D.position(anchor, true)),
                boundaryPosition = $D.position(boundary, true),
                boundaryRight = boundaryPosition.w,
                boundaryBottom = boundaryPosition.h,
                popWidth = popupNode.offsetWidth,
                popHeight = popupNode.offsetHeight,
                halfPopWidth =  popWidth / 2,
                halfPopHeight = popHeight / 2,
                tipPosition = $D.position(tipNode),
                tipDimensionShort = $MATH.min(tipPosition.h, tipPosition.w),
                tipHalfLong = $MATH.max(tipPosition.h, tipPosition.w) / 2,
                plm = this.placement;
            
            
            if (hasScrollbars) {
                
                boundaryRight -= 15;
                boundaryBottom -= 15;
            }
            
            
            var popupInsideBoundary = $D.contains(boundary, popupNode), 
                offsetTop = popupInsideBoundary ? 0 : boundaryPosition.y, 
                popLeft = boundaryRight / 2 - halfPopWidth,      
                popTop = boundaryBottom / 2 - halfPopHeight + offsetTop,     
                tipLeft = -1000,                                 
                tipTop = -1000,                                  
                tipClass,
                tipBorderStyles = ['borderBottomColor', 'borderTopColor', 'borderRightColor', 'borderLeftColor'],
                tipStyleIdx = 0;
            
            
            
            if(popupInsideBoundary) {
                
                anchorPosition.x = anchorPosition.x - boundaryPosition.x;
                anchorPosition.y = anchorPosition.y - boundaryPosition.y;
            }

            var anchorBottom = anchorPosition.y + anchorPosition.h,
                anchorRight = anchorPosition.x + anchorPosition.w,
                fitsRight = ((anchorRight + popWidth) < boundaryRight),
                fitsAbove = anchorPosition.y > popHeight,
                fitsBottom = ((anchorBottom + popHeight) < boundaryBottom),
                fnBounds = function (minVal, maxVal, desiredVal) {                              
                    return $MATH.min($MATH.max(minVal, desiredVal), $MATH.max(maxVal, 0));
                },
                fnVertFit = function() {
                    
                    if ((anchorPosition.x < boundaryRight) && (fitsBottom || fitsAbove)) {
                        
                        var anchorMidWidth = anchorPosition.x + (anchorPosition.w / 2),
                            
                            posBottom = (plm == PLACEMENT_BELOW && fitsBottom) || !fitsAbove;
                        
                        
                        if (posBottom) {
                            
                            tipClass = 'top';
                            tipTop = anchorBottom; 
                            tipStyleIdx = 0;
                            
                            
                            popTop = anchorBottom + tipDimensionShort - editorOffset;
                            
                        } else {
                            
                            tipClass = 'bottom';
                            tipTop = anchorPosition.y - tipDimensionShort;
                            tipStyleIdx = 1;
                            
                            
                            popTop = tipTop - popHeight + editorOffset;
                        }
    
                        
                        popLeft = fnBounds(0, boundaryRight - popWidth, anchorMidWidth - halfPopWidth);
    
                        
                        tipLeft = fnBounds(anchorPosition.x, anchorRight, anchorMidWidth) - tipHalfLong;
    
                        
                        return true; 
                    }
                    
                    
                    return false;
                },
                fnHorizFit = function() {
                    
                    if ((anchorPosition.y < boundaryBottom) && (fitsRight || anchorPosition.x > popWidth)) {
                        
                        var anchorMidHeight = anchorPosition.y + (anchorPosition.h / 2),
                            posRight = !(plm == PLACEMENT_LEFT && anchorPosition.x > popWidth) && fitsRight;
                        
                        
                        if (posRight) {
                            
                            tipClass = 'left';
                            tipLeft = anchorRight; 
                            tipStyleIdx = 2;
                            
                            
                            popLeft = anchorRight + tipDimensionShort - editorOffset;
                            
                        } else {
                            
                            tipClass = 'right';
                            tipLeft = anchorPosition.x - tipDimensionShort;
                            tipStyleIdx = 3;
                            
                            
                            popLeft = tipLeft - popWidth + editorOffset;
                        }
                        
                        
                        
                        popTop = fnBounds(offsetTop, boundaryBottom - popHeight, anchorMidHeight - halfPopHeight);
                        
                        
                        tipTop = fnBounds(anchorPosition.y, anchorBottom, anchorMidHeight) - tipHalfLong;
                        
                        
                        return true;
                    }               
                    
                    
                    return false;
                },
                testFns = [ fnVertFit, fnHorizFit ],                
                i = 0;
                
            if (plm == PLACEMENT_FIXED) {
                popTop = this.popPosition.top;
                popLeft = this.popPosition.left;
                tipTop = -1000;
                tipLeft = -1000;
                tipClass = null;
            } else {    
                
                
                if (plm == PLACEMENT_LEFT || plm == PLACEMENT_RIGHT ||
                        (plm == PLACEMENT_AUTO && defaultOrientation === 'h')) {
                    
                    testFns.reverse();
                }

                
                for (; i < 2; i++) {
                    
                    if (testFns[i]()) {
                        
                        break;
                    }
                }
                
                popTop = $MATH.round(popTop);
                popLeft = $MATH.round(popLeft);
                tipTop = $MATH.round(tipTop);
                tipLeft = $MATH.round(tipLeft);
            }
    
            
            tipNode.className = baseTipCls + ' ' + (tipClass || 'hidden');
            
            var tipNodeStyle = tipNode.style,
                popupNodeStyle = popupNode.style;
            
            
            tipNodeStyle.top = tipTop + 'px';
            tipNodeStyle.left = tipLeft + 'px';
            
            if (this.tipNodeColor) {
                
                mstrmojo.array.forEach(tipBorderStyles, function(s) {
                    tipNodeStyle[s] = '';
                });
                tipNodeStyle[tipBorderStyles[tipStyleIdx]] = this.tipNodeColor;
            }
            
            
            popupNodeStyle.top = popTop + 'px';
            popupNodeStyle.left = popLeft + 'px';
            
            return true;
        }
    
        
    mstrmojo._IsAnchorable = {
        
        
        anchor : null,
        
        
        anchorPosition: null,
        
        
        boundaryNodeName : 'curtainNode',
        
        
        popupNodeName : 'editorNode',
        
        
        tipNodeName : 'tipNode',
        
        
        baseTipClass : 'mstrmojo-Editor-tip',
        
        
        anchorOffset : 25,
        
        
        anchorOrientation : 'v',
        
        placement: PLACEMENT_AUTO,
        
        popPosition: null,
        
        
        hasScrollbars : function hasScrollbars(){
            return (!mstrApp.isTouchApp || !mstrApp.isTouchApp());
        },
        
        
        prepareAnchor : mstrmojo.emptyFn,
        
        positionDialog : function positionDialog(){
            this.prepareAnchor();
            if (!anchorPopup.apply(this,[])) {
                
                if ( typeof this._super === "function" ) {
                    this._super();
                }
            }
        }
    };
    
})();
(function() {
    
    mstrmojo.requiresCls("mstrmojo.dom");
    
    var $D = mstrmojo.dom;
    
    
    mstrmojo._IsDocXtab = {
            
        _mixinName: 'mstrmojo._IsDocXtab',            
        
        
        isDocXtab: true,
        
        formatHandlers: {
            
            domNode: [ 'RW', 'T', 'font'],
            msgNode: [ 'height', 'background-color' ],
            viewport: [ 'D', 'background-color', 'B', 'fx' ]
        },
                
        preBuildRendering: function preBuildRendering() {
            
            
            var f = this.getFormats(),
                cs = '',
                setDim = function setDim(dim) {
                    if(f[dim]) {
                        
                        var d = this[dim] || f[dim];
                        
                        
                        this[dim] = d;
                        
                        
                        if (this.isFullScreenWidget) {
                            f[dim] = d;
                        }
                        
                        
                        this[dim + 'Limit'] = parseInt(d, 10);
                    }
                };

            
            setDim.call(this, 'height');
            setDim.call(this, 'width');
            
            
            
            var fn = function (d, offset) {
                
                var x = f[d];

                
                if (x && x.charAt(x.length - 1) !== '%') {
                    var v = parseInt(x, 10);
                    
                    
                    if (!isNaN(v)) {
                        
                        if (offset) {
                            v -= offset;
                        }
                        
                        
                        
                        cs += d + ':' + v + 'px;';
                    }
                }

                
                
                
                return null;
            };
            
            
            fn('height', 0);
            
            
            fn('width', 0);
            
            this.scrollboxNodeCssText = cs;
            
            return this._super();
        },        
               
        
        resize: function() {              
            
            this.clearCache();                
            
            var f = this.getFormats(),
                h = parseInt(f.height, 10),
                w = parseInt(f.width, 10);
            if (w > 0 && h > 0) {
                if (!this.visible && this.forcedHidden){
                    this.set('visible', true);
                    this.forcedHidden = false;
                }
                
                
                
                mstrmojo.array.forEach([this.scrollboxNode, this.viewport], function (node) {
                    var nodeStyle = node.style;
                    nodeStyle.height = h + 'px';
                    nodeStyle.width = w + 'px';
                });
                
                
                if (this.scrollboxNode) {
                    
                    this.scrollboxHeightFixed = h && (h !== "auto");

                    
                    if (this.scrollboxHeightFixed) {
                        this.scrollboxHeight = parseInt(h, 10); 
                        
                        this.scrollboxBottom = this.scrollboxTop + h;
                        
                        
                    }                            

                    
                    if (this.lockHeadersCase) {
                        this.resizeScrollBox($D.isIE);
                    }
                }                   

                
                var zs = this.zones;
                if(zs) {
                    if(zs._BL) {
                        zs._BL.onscroll();
                    }
                    if(zs._BR) {
                        zs._BR.onscroll();
                    }
                }
                
                if (!(this.gridData && this.gridData.eg)) {
                    
                    this.onGridWidthChanged();
                }
            } else {
                
                if (this.visible) {
                    this.set('visible', false);
                    this.forcedHidden = true;
                }
            }
        },        
                
        
        renderPortalState: function renderPortalState() {
            this.clearCache();
            this.unrender();
            this.render();
        },        
        
        
        unrender: function unrender() {
            
            this.clearCache();
            
            
            if (this._super) {
                this._super();
            }
        },        
        
        
        defaultAction: function defaultAction(td, tCell) {
            if (this._super(td, tCell)) {
                var sti = this.model.sti,
                    titleId = sti && sti.titleId,
                    deselectCurrentCell = sti && sti.deselectCurrent,
                    z;
                
                
                this._currentSelectedTD = deselectCurrentCell ? undefined : td;            
                
                
                if (titleId) {
                    
                    for (z in this.zones) {
                        var zn = this.zones[z],
                            dn = zn.domNode,
                            fc = dn && dn.firstChild;
                        
                        if (fc && (td.offsetParent === fc || td.offsetParent === dn)) {
                            zn.clearHilites(titleId);
                            if (!deselectCurrentCell) {
                                zn.setHilites(titleId, td);
                            }
                            zn.hiliteKey = titleId; 
                            
                            this.model.sti = null;
                            return true;
                        }
                    }
                }
                
                return true;
            }
            
            return false;
        }        
    };
}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.dom",
        "mstrmojo.array",
        "mstrmojo.string");
    
    
    var $D = mstrmojo.dom,
        $S = mstrmojo.string;

    
    mstrmojo.css = mstrmojo.provide(
        "mstrmojo.css",
        
        {
        
            
            DISPLAY_TABLE: $D.isNSIE ? 'block' : 'table',
            
            
            DISPLAY_CELL: $D.isNSIE ? 'block' : 'table-cell',

            
            MINHEIGHT: $D.isIE6 ? 'height' : 'minHeight',
                    
            
            addClass: function addClass(el, s) {
                if (!el) {
                    return;
                }
                
                if (s.constructor !== Array) {
                    s = [ s ];
                }
                var cls = el.className || '',
                    start = ' ' + cls +  ' ',
                    bAdded = false;
                for (var i=0, len=s.length; i<len; i++) {
                    var c = s[i];
                    if (!start.match(new RegExp("\\s" + c + "\\s"))) {
                        cls += ' ' + c;
                        bAdded = true;
                    }
                }
                if (bAdded) {
                    el.className = $S.trim(cls);
                }
            },
            
            
            removeClass: function removeClass(el, s) {
                if (!el) {
                    return;
                }
                
                if (s.constructor !== Array) {
                    s = [ s ];
                }
                var cls = ' ' + (el.className || '') + ' ';
                for (var i=0, len=s.length; i<len; i++) {
                    cls = cls.replace(new RegExp("\\s" + s[i] + "\\s", "g"), " ");
                }
                el.className = $S.trim(cls);
            },
            
            
            addWidgetCssClass: function addWidgetCssClass(widget, classes) {
                
                var origClasses = widget.cssClass,
                    existing = (origClasses && origClasses.split(' ')) || [];
                
                
                if (classes.constructor !== Array) {
                    
                    classes = [ classes ];
                }

                
                widget.cssClass = existing.concat(classes).join(' ');
            },
            
            
            toggleClass: function toggleClass(el, s, b) {
                if (b) {
                    this.addClass(el, s);
                } else {
                    this.removeClass(el, s);
                }
            },
            
            
            applyShadow: function applyShadow(el, xOff, yOff, spread, color) {
                var s = el.style;
                if ($D.isDXIE) {
                    s.filter += "progid:DXImageTransform.Microsoft.dropshadow(OffX=" + xOff + "px, OffY=" + yOff + "px, Color='" + color + "')";
                } else if ($D.isFF || $D.isWK || $D.isIE10) {
                    s[$D.CSS3_BOXSHADOW] = xOff + 'px ' + yOff + 'px ' + spread + 'px ' + color;
                }
            },
            
            
            removeShadow: function removeShadow(el) {
                var s = el.style;
                if ($D.isDXIE) {

                } else if ($D.isFF || $D.isWK || $D.isIE10) {
                    s[$D.CSS3_BOXSHADOW] = '';
                }
            },
            
            
            setOpacity: function setOpacity(el, val) {
                if ($D.isDXIE && !$D.isIE9){
                    var filterText = el.currentStyle.filter; 
                    var filter = null;
                    if (filterText.length > 0 ) {
                        filter = el.filters['DXImageTransform.Microsoft.Alpha'];
                    }
                    
                    if(filter) {
                        filter.opacity = val;
                        filter.enabled = (val != 100);
                    } else if (val < 100){
                        var filterDefinition = 'progid:DXImageTransform.Microsoft.Alpha(Opacity='+val+')';
                        el.style.filter = (filterText?filterText:"") + " " + filterDefinition;
                    }
                }else {
                	
                    el.style.opacity = val / 100 - ($D.isIE9 ? 0.00001: 0);
                }
            },
            
            
            buildGradient: function buildGradient(t, sc, ec) {
                if ($D.supports($D.cssFeatures.GRADIENTS)) {
                    var rtn = {};
                    
                    if ($D.isDXIE) {
                        rtn.n = 'filter';
                        rtn.v = "progid:DXImageTransform.Microsoft.Gradient(GradientType=" + t + ",StartColorStr='" + sc + "',EndColorStr='" + ec + "')";
                        
                    } else if ($D.isFF) {
                        rtn.n = 'background-image';
                        rtn.v = '-moz-linear-gradient(' + ((t === 0) ? 'top' : 'left') + ',' + sc + ',' + ec + ')';
                        
                    } else if ($D.isWK) {
                        rtn.n = 'background';
                        rtn.v = '-webkit-gradient(linear,' + ((t === 0) ? 'left top, left bottom' : 'left top, right top') + ',from(' + sc + '),to('+ ec + '))';
                    } else if ($D.isIE10 || $D.isIEW3C) {
                        rtn.n = 'background';
                        rtn.v = 'linear-gradient(' + ((t === 0) ? 'to bottom' : 'to right') + ',' + sc + ',' + ec + ')';
                    }
                    return rtn;
                }
                
                return null;
            },
            
            
            buildRoundCorners: function buildRoundCorners(r, t) {
                if ($D.supports($D.cssFeatures.ROUND_CORNERS)) {
                    var v = r + 'px';
                    var radiusValue = v + ((t) ? ' ' + v + ' 0 0' : '') + ';';
                    
                    if ($D.isFF) {
                        return '-moz-border-radius:' + radiusValue;
                        
                    } else if ($D.isWinPhone || $D.isIE10) {
                    	return 'border-radius:' + radiusValue;
                    	
                    } else if ($D.isWK) {	
                        
                        if (!t) {
                            
                            return '-webkit-border-radius:' + v + ';';
                            
                        } else {
                            
                            var ds = ['left', 'right'],
                                css = [],
                                x = -1;
                            
                            for (var i = 0; i < 2; i++) {
                                css[++x] = '-webkit-border-top-' + ds[i] + '-radius:' + v;    
                                css[++x] = '-webkit-border-bottom-' + ds[i] + '-radius:0';    
                            }
                            
                            return css.join(';');
                        }
                    }
                }
                
                return '';
            },
            
            
            getBorderWidthsOrPaddings: function getBorderWidthsOrPaddings(b, dpi) {
                
                var o = {
                    t: 0,
                    r: 0,
                    b: 0,
                    l: 0,
                    h: 0,
                    w: 0
                };
                
                
                if (!b) {
                    return o;
                }

                
                var a = b.split(' '),
                    len = a.length;
                
                
                for (var i = 0; i < len; i++) {
                    a[i] = Math.round(dpi * parseFloat(a[i], 10) / 72);
                }
                
                
                if (len < 4) {
                    
                    if (len === 1) {
                        
                        a[1] = a[2] = a[3] = a[0];
                    } else {
                        
                        a[3] = a[1];
                        
                        if (len === 2) {
                            
                            a[2] = a[0];
                        }
                    }
                }
                
                
                o.t = a[0];
                o.r = a[1];
                o.b = a[2];
                o.l = a[3];
                o.h = o.t + o.b; 
                o.w = o.l + o.r;
                
                return o;
            },
            
            
            getBorderWidths: function getBorderWidths(p, dpi) {
                return this.getBorderWidthsOrPaddings(p, dpi);
            },
            
            
            getPaddings: function getPaddings(p, dpi) {
                return this.getBorderWidthsOrPaddings(p, dpi);
            },
            
            
            parkAfterFade: function parkAfterFade(evt) {
                
                var elStyle = evt.target.style;

                
                if (elStyle.opacity == 0) {
                    
                    elStyle.left = '-10000px';
                    
                    
                    
                    window.setTimeout(function() {
                        elStyle.opacity = 0.99;
                    }, 0);

                    
                    return true;
                }
                
                
                return false;
            },
            
            
            
            getStyleValue: function getStyleValue(el, prop) {
                if (el.currentStyle){ 
                    prop = prop == 'float' ? 'styleFloat' : prop;
                    value = el.currentStyle[prop];
                }
                else if (document.defaultView && document.defaultView.getComputedStyle){ 
                    prop = prop == 'float' ? 'cssFloat' : prop; 
                    var styles = document.defaultView.getComputedStyle(el, null); 
                    value = styles ? styles[prop] : null;
                }
                
                return value;           
            },
            
            
            getComputedStyle: function(element, pseudoElement) {
                var fn = (window.getComputedStyle) ? 
                        function (element, pseudoElement) {
                            return window.getComputedStyle(element, pseudoElement || null);
                        } : 
                        function (element) {
                            return element.currentStyle || {};
                        };
                        
                mstrmojo.css.getComputedStyle = fn;
                
                return fn(element, pseudoElement);
            }
            
        });
    
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.func",
                         "mstrmojo.hash");
    
	var $WRAP = mstrmojo.func.wrapMethods;
	function wrapCallback(callback, argv, method, idx, me) {
		return $WRAP({
            success: function (res) {
                if (mstrMobileApp && mstrMobileApp.sendCallback) {
                    mstrMobileApp.sendCallback('success', argv.target, JSON.stringify(argv.memo), JSON.stringify(res));
                }
            },
            complete: function () {
                if (mstrMobileApp && mstrMobileApp.sendCallback) {
                    mstrMobileApp.sendCallback('complete', argv.target, JSON.stringify(argv.memo));
                }        
                me.removeCallback(method, idx);
            },
            failure: function (res) {
                if (mstrMobileApp && mstrMobileApp.sendCallback) {
                    mstrMobileApp.sendCallback('failure', argv.target, JSON.stringify(argv.memo), JSON.stringify(res));
                }                            
            }
        }, callback);
	}
	
    mstrmojo._CanProxyCallback = mstrmojo.provide(
            
        'mstrmojo._CanProxyCallback', 
        
        {    
            _mixinName: "mstrmojo._CanProxyCallback",
            
            callbacks: null,
            
            isCallbackReceiver: false,
            
            newCallback: function newCallback(props) {
                
                
                return props;
                
                var cbs = this.callbacks,
                    cb = mstrmojo.hash.copy(props), 
                    idx = (props.index !== undefined) ? String(props.index) : 'index',
                    args = arguments.callee.caller.arguments,
                    argv,
                    i,
                    len,
                    method = props.method || 'anonymous';
                if (!cbs) {
                    cbs = this.callbacks = {};
                }
                
                if (!cbs[method]) {
                    cbs[method] = {};
                } 
                
                
                if (!this.isCallbackReceiver) {
                    for (i = 0, len = args.length; i < len; i++) {
                        argv = args[i];
                        if (argv && argv.target) {
                            cb = wrapCallback(cb, argv, method, idx, this);
                            break;
                        }
                    }
                }
                
                
                if (!props.method) {
                	cb.proxy = this.getCallbackMemo();
                }
                
                cbs[method][idx] = cb;
                return cb;                
            },
            
            anonymous: function (params, callback, config, argv) {
                if (!this.isCallbackReceiver) {
	            	callback = wrapCallback(callback, argv, 'anonymous', 'index', this);	            	
	            	mstrApp.serverRequest(params, callback, config);
            	}
            },
            
            getCallback: function getCallback(method, index) {
                var idx = index || 'index',
                    cbs = this.callbacks;
                return cbs && cbs[method] && cbs[method][idx];
            },
            
            removeCallback: function removeCallback(method, index) {
                var idx = index || 'index',
                    cbs = this.callbacks;
                if (cbs && cbs[method]) {
                    delete cbs[method][idx];
                    if (mstrmojo.hash.isEmpty(cbs[method])) {
                        delete cbs[method];
                    }
                }
            },

            getCallbackMemo: function getCallbackMemo(method, index) {
                return {
                    target: 'mstrmojo.all["' + this.id + '"].receiveCallback',
                    memo: {
                        method: method || 'anonymous',
                        index: index || 'index'
                    }
                };
            },
            
            receiveCallback: function receiveCallback(fn, memo, res) {
                var method = memo.method,
                    idx = memo.index,
                    cb = this.getCallback(method, idx);
                
                if (cb && fn && cb[fn]) {
                    cb[fn](res);
                }
            }
        }
    );
    
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.registry", "mstrmojo.hash");
    
    var _loadedCls = false,
        _FQCN = "mstrmojo.Binding",
        _B = "bindings",
        _R = mstrmojo.registry;
    
    
    function _shutdown(bs) {
        for (var d in bs) {
            var b = bs[d];
            if (b && b.disable) {
                b.destroy();
            }
        }
    }
    
    
    function _startup(bs, p) {
        
        if (!_loadedCls) {
            mstrmojo.requiresCls(_FQCN);
            _loadedCls = true;
        }
        
        for (var d in bs) {
            var b = bs[d];
            if (b == null) {    
                continue;
            }
            var t = typeof(b);
            
            
            if (t === "string" || t === "function") {
                b = {
                        destination: d,
                        source: b,
                        scriptClass: _FQCN
                    };
            }
            
            b.parent = p;
            
            
            b = _R.ref(b, {skipLoadChecks: true});
            bs[d] = b;
            b.enable();
        }
    }
    
    
    mstrmojo._HasBindings = mstrmojo.provide(
    "mstrmojo._HasBindings",
    
    {
        _meta_usesSuper: false,

        
        
        
        
        

        
        initBindings: function inB() {
            this.hasInitBindings = true;

            var bs = mstrmojo.hash.copy(this[_B]);
                
            if (bs) { 
                delete this[_B];
                this._set_bindings(_B, bs, true);
                
                if (this.postCreateBindings) {
                    this.postCreateBindings();        
                }
            }
            
            var ch = this.children;
            if (ch) {
                for (var i=0, len=ch.length; i<len; i++) {
                    var c = ch[i];
                    if (c && c.initBindings) {
                        c.initBindings();
                    }        
                }
            }
        },
        
        destroyBindings: function destB(){
            var bs = this.bindings;
            if (bs) {
                _shutdown(bs);
                delete this.bindings;
            }
        },
        
        
        _set_bindings: function setB(n, v) {
            var bs = this[_B];
            if (v !== bs){
                if (bs) {
                    _shutdown(bs);
                }
                this[_B] = v;
                if (v) {
                    _startup(v, this);
                }
                return true;
            }
            return false;
        }
    });

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.array");

    
    var _subs = {};

    
    var _listenerMap = {};

    
    mstrmojo.publisher = mstrmojo.provide(
        "mstrmojo.publisher",

        
        {
            
            publish: function pub(id, type, data) {
                
                var ls = _subs[id] && _subs[id][type],
                    lid;
                if (!ls) {
                    return;
                }

                
                for (lid in ls) {
                    
                    var l = null;
                    if (lid) {
                        l = mstrmojo.all[lid];
                        
                        
                        
                        
                        if (!l) {
                            delete ls[lid];
                            continue;
                        }
                    }
                    
                    var ns = ls[lid].methods;
                    if (ns) {
                        
                        
                        var ctxt = l || mstrmojo.global,
                            n;
                        for (n in ns) {
                            if (ctxt[n]) {
                                ctxt[n](data);
                            }
                        }
                    }
                    
                    
                    
                    
                    var fs = ls[lid] && ls[lid].functions,
                        flen = (fs && fs.length) || 0;
                    if (flen) {
                        var i;
                        if (l) {
                            
                            for (i = flen - 1; i > -1; i--) {
                                if (fs[i]) {
                                    fs[i].apply(l, [data]);
                                }
                            }
                        } else {
                            
                            
                            for (i = flen - 1; i > -1; i--) {
                                if (fs[i]) {
                                    fs[i](data);
                                }
                            }
                        }
                    }

                }
            },

            
            subscribe: function sub(id, type, callback, listener) {

                
                var s = _subs[id];
                if (!s) {
                    s = {};
                    _subs[id] = s;
                }

                
                var e = s[type];
                if (!e) {
                    e = {};
                    s[type] = e;
                }

                
                var l = e[listener || ""];
                if (!l) {
                    l = {};
                    e[listener || ""] = l;
                }

                
                if (typeof callback  === "function") {
                    var fs = l.functions;
                    if (!fs) {
                        fs = [];
                        l.functions = fs;
                    }
                    fs.push(callback);
                } else {
                    
                    var ms = l.methods;
                    if (!ms) {
                        ms = {};
                        l.methods = ms;
                    }
                    ms[callback] = true;
                }

                
                var lmap = _listenerMap,
                    pmap = lmap[listener || ""];
                if (!pmap) {
                    pmap = {};
                    lmap[listener || ""] = pmap;
                }
                var emap = pmap[id];
                if (!emap) {
                    emap = {};
                    pmap[id] = emap;
                }
                emap[type] = true;


                
                return {
                    id: id,
                    type: type,
                    callback: callback,
                    listener: listener,
                    clear: function () {
                        mstrmojo.publisher.unsubscribe(this);
                    }
                };
            },

            
            unsubscribe: function unsub(sub) {
                var s = _subs[sub.id],
                    e = s && s[sub.type],
                    l = e && e[sub.listener || ""];
                if (!l) {
                    return;
                }

                var A = mstrmojo.array,
                    H = mstrmojo.hash,
                    tp = typeof sub.callback,
                    cleanupListener = false;
                if (tp === "function") {
                    
                    var fs = l.functions;
                    if (fs) {
                        A.removeItem(fs, sub.callback);
                        if (!fs.length) {
                            
                            delete l.functions;
                            
                            if (H.isEmpty(l.methods)) {
                                cleanupListener = true;
                            }
                        }
                    }
                } else {
                    
                    var ms = l.methods;
                    if (ms) {
                        delete ms[sub.callback];
                        if (H.isEmpty(ms)) {
                            
                            delete l.methods;
                            
                            if (!l.functions || !l.functions.length) {
                                cleanupListener = true;
                            }
                        }
                    }
                }
                
                if (cleanupListener) {
                    
                    delete e[sub.listener || ""];
                    
                    if (H.isEmpty(e)) {
                        
                        delete s[sub.type];
                    }
                }
            },

            
            hasSubs: function hasSubs(id, type) {
                var s = _subs[id],
                    evt = s && s[type];

                return !!evt;
            },

            
            clearSubscriptions: function clr(listener) {
                if (!listener) {
                    listener = "";
                }
                var sbs = _subs,
                    _H = mstrmojo.hash,
                    id;

                
                if (sbs[listener]) {
                    
                    delete sbs[listener];
                }

                
                var pmap = _listenerMap[listener];
                if (pmap) {
                    
                    for (id in pmap) {
                        var es = sbs[id],
                            emap = pmap[id],
                            e;
                        if (!es) {
                            continue;
                        }
                        
                        for (e in emap) {
                            
                            var ls = es[e];
                            if (!ls) {
                                continue;
                            }
                            delete ls[listener];
                            
                            if (_H.isEmpty(ls)) {
                                
                                delete es[e];
                            }
                        }
                    }
                }
            }
        }
    );

    mstrmojo.publisher.NO_SRC = "NO_SRC";
    mstrmojo.publisher.CONNECTIVITY_CHANGED_EVENT = "CONNECTIVITY_CHANGED";
    mstrmojo.publisher.RECONCILE_END_EVENT = "RECONCILE_END";

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.hash");

    var $H = mstrmojo.hash,
        dicPopup = null;
    
    
    
    function _createDICInGroup(o){
        return mstrmojo.DICFactory.createDIC(
                $H.copy({dic: this.dic, owner: this.owner, group: this}, o));
    }
    
    
    mstrmojo.DICFactory = mstrmojo.provide(
        "mstrmojo.DICFactory",
        {
            
            createDIC: function(o) {
                var dic = o.dic,
                    Cls = mstrmojo.DICConfig.getDICClass(dic),
                    w; 
                if(Cls) {
                    
                    if (o.k === undefined){
                        o.k = o.opener && o.opener.id;
                    }
                    
                    
                    o.showByDefault = mstrmojo.DICConfig.showDICByDefault(o.dic, o.openerType);
                    o.hasPreview = mstrmojo.DICConfig.hasDICPreview(o.dic, o.openerType);
                    
                    w = new Cls(o);
                }
                
                return w;
            },
                        
            
            createDICPopup: function(opener, dic) {
                return mstrmojo.DICPopup.getInstance(opener, dic);
            },

            
            createDICGroup: function(gco) {
                var dicGroup = $H.copy(gco, {
                    
                        scriptClass: "mstrmojo.Widget",
                    
                        
                        widgetsMap: {},
                        
                        
                        dic: null,
                        
                        
                        owner: null,
                        
                        
                        groupMembers: {},

                        postCreate: function(){
                            var dic = this.dic, otp = this.openerType, DC = mstrmojo.DICConfig;
                            this.showByDefault = DC.showDICByDefault(dic, otp);
                            this.hasPreview = DC.hasDICPreview(dic, otp);
                        },
                        
                        
                        addDIC: function addDIC(k, o) {
                            this.groupMembers[k] = o;
                        },
                        
                        
                        showPopupDIC: function showPopupDIC(k){
                            if (!this.showByDefault){
                                var w = this.widgetsMap[k],
                                    o = this.groupMembers[k];
                                
                                if (!o){
                                    return;
                                }
                                
                                
                                if (!w){
                                    w = this.widgetsMap[k] = _createDICInGroup.call(this, o);

                                }
                                
                                
                                w.showInPopup();
                            }
                        },
                        
                        
                        render: function render() {
                            
                            if (this.showByDefault || this.hasPreview){ 
                                var gms = this.groupMembers, me = this, dicWidget;

                                $H.forEach(gms, function (go, k) {
                                    if (!go.hasRendered){
                                        me.widgetsMap[k] = dicWidget = _createDICInGroup.call(me, go);
                                        
                                        
                                        if (me.showByDefault){
                                            dicWidget.render();
                                        
                                        }else if (me.hasPreview){
                                            dicWidget.renderPreview();
                                        }
                                        
                                        go.hasRendered = true;
                                    }
                                });
                            }
                        },
                        
                        destroy: function destroy() {
                            $H.forEach(this.widgetsMap, function (w) {
                                w.destroy();
                            });
                            this.widgetsMap = {};
                        }
                    });
                
                return mstrmojo.insert(dicGroup);
            }
        }
    );
}());
(function() {
    
    mstrmojo.requiresCls("mstrmojo.hash");
    
    var $H = mstrmojo.hash;
    
    
    mstrmojo._CanSupportTransaction = {
            
        _mixinName: "mstrmojo._CanSupportTransaction",
        
        
        updatedCellsMap: null,
                        
        
        getUpdates: mstrmojo.emptyFn, 
        
        
        getUpdateObject: mstrmojo.emptyFn, 

        
        getKeyContext: mstrmojo.emptyFn, 
        
        
        autoRefresh: mstrmojo.emptyFn, 
        
        
        editNext: mstrmojo.emptyFn,
        
        
        dataChanged: function dataChanged(k, r, v, d) {
            
            var autoRefresh = this.updateValue(k, v);
            
            this.updatedCellsMap[k] = {r: r, v: v};
            
            
            this.controller.onTransactionUpdates(this, this.getUpdateObject(), autoRefresh);
        },
        
        
        postBuildRendering: function pstBldRnd() {
            if(this._super) {
                this._super();
            }
            
            if (!this.txModel){
            	this.txModel = this.model.docModel || this.model;
            }
            
            this.updatedCellsMap = this.updatedCellsMap || {};           
        },

        
        updateValue: function(k, v) {
            if(this.txModel.deltaUpdate) {
                this.txModel.deltaUpdate(this);
            }
            return false;
        },

        
        getUpdatedValues: function() {
            var um = this.updatedCellsMap,
                i, u, vs = [];
            for(i in um) {
                if(um.hasOwnProperty(i)) {
                    u = {};
                    u.v = um[i].v.v;
                    vs.push($H.copy(this.getKeyContext(i), u));
                }
            }
            return vs;
        },        
        
        
        clear: function() {
            this.updatedCellsMap = {};
        },
        
        
        registerTxWidget: function(){
            function fnRegisterOnPS(w, ps){
                var k = w.node.data.k;
                ps.txWidgets = ps.txWidgets || {};
                ps.txWidgets[k] = w;
                return false;
            }

            var p = this.parent;
            while (p){
                if (p.isPanelStack === true){
                    
                    fnRegisterOnPS(this, p);
                }
                p = p.parent;
            }
        }
    };
}());

(function(){

    mstrmojo.requiresCls("mstrmojo.hash");
    
    mstrmojo.requiresDescs(3852,3853,3854,3855,3856,3857,3858,3859,3860,3861,3862,3863,
    		1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,
    		9379,9380,9381,9382,9383,9384,9385,
    		6078,7899,7900,7901,6079,6081,6080,6082,7902,7902,6076,6077,7903);
    
    
    mstrmojo.locales = mstrmojo.provide(
        "mstrmojo.locales",
            
            {
                
        	    load: function(callback){
                    var me = this;
                    if (this.isLoaded) {
                        callback();
                    } else {
                        mstrmojo.xhr.request('POST', mstrConfig.taskURL, 
                        {
                            success: function(res) {
                                
                                mstrmojo.hash.copy(mstrmojo.hash.obj2array(res), me);
                                
                                callback();
                                if (mstrmojo.expr) {
                                    mstrmojo.expr.onLocaleUpdated();
                                }
                                mstrmojo.locales.isLoaded = true;
                                
                            },
                            failure: function(res) {
                                alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
                            }
                        },
                        
                        {
                            taskId: 'getLocaleInfo'
                        });
                    }            
                },
                
                isLoaded: false,
                
                "datetime": {
                    "MONTHNAME_SHORT": [
                        mstrmojo.desc(3852, "Jan"),
                        mstrmojo.desc(3853, "Feb"),
                        mstrmojo.desc(3854, "Mar"),
                        mstrmojo.desc(3855, "Apr"),
                        mstrmojo.desc(3856, "May"),
                        mstrmojo.desc(3857, "Jun"),
                        mstrmojo.desc(3858, "Jul"),
                        mstrmojo.desc(3859, "Aug"),
                        mstrmojo.desc(3860, "Sep"),
                        mstrmojo.desc(3861, "Oct"),
                        mstrmojo.desc(3862, "Nov"),
                        mstrmojo.desc(3863, "Dec")
                    ],
                    "MONTHNAME_FULL": [
                        mstrmojo.desc(1956, "January"),
                        mstrmojo.desc(1957, "February"),
                        mstrmojo.desc(1958, "March"),
                        mstrmojo.desc(1959, "April"),
                        mstrmojo.desc(1960, "May"),
                        mstrmojo.desc(1961, "June"),
                        mstrmojo.desc(1962, "July"),
                        mstrmojo.desc(1963, "August"),
                        mstrmojo.desc(1964, "September"),
                        mstrmojo.desc(1965, "October"),
                        mstrmojo.desc(1966, "November"),
                        mstrmojo.desc(1967, "December")
                    ],
                    "dayShortNames": [
                        "S",
                        "M",
                        "T",
                        "W",
                        "T",
                        "F",
                        "S"
                    ],
                    "dayNames": [
                        mstrmojo.desc(9379, "Sunday"),
                        mstrmojo.desc(9380, "Monday"),
                        mstrmojo.desc(9381, "Tuesday"),
                        mstrmojo.desc(9382, "Wednesday"),
                        mstrmojo.desc(9383, "Thursday"),
                        mstrmojo.desc(9384, "Friday"),
                        mstrmojo.desc(9385, "Saturday")
                    ],
                    "DATEINPUTFORMATS": [
                        "M/d/yy",
                        "M/d/yyyy",
                        "MMM d, yy"
                    ],
                    "TIMEINPUTFORMATS": [
                        "h:mm a",
                        "H:mm",
                        "h:mm:ss a",
                        "H:mm:ss",
                        "h:mm:ss a z"
                    ],
                    "DATEOUTPUTFORMAT": "M/d/yyyy",
                    "TIMEOUTPUTFORMAT": "h:mm:ss a",
                    "AM_NAME": "AM",
                    "PM_NAME": "PM",
                    "TWODIGITYEARSTART": "2029"
                },
                "number": {
                    "NUMBERINPUTFORMATS": {
                        "0": "#,##0.###"
                    },
                    "INTEGERINPUTFORMATS": {
                        "0": "#,##0"
                    },
                    "NUMBEROUTPUTFORMAT": "#0.##########",
                    "INTEGEROUTPUTFORMAT": "#0",
                    "DECIMALSEPARATOR": ".",
                    "THOUSANDSEPARATOR": ","
                },
                "expression": {
                    "METRICVALIDATIONLEVEL": "0",
                    "PRESERVEWHITESPACE": false,
                    "Include": [
                        {
                            "did": "1",
                            "n": "Include"
                        },
                        {
                            "did": "2",
                            "n": "Exclude"
                        }
                    ],
                    "BranchQual": [
                        {
                            "did": "19",
                            "n": "AND"
                        },
                        {
                            "did": "20",
                            "n": "OR"
                        },
                        {
                            "did": "21",
                            "n": "NOT"
                        },
                        {
                            "did": "19_21",
                            "n": "AND NOT"
                        },
                        {
                            "did": "20_21",
                            "n": "OR NOT"
                        }
                    ],
                    "RootOperator": [
                        {
                            "did": "19",
                            "n": "All selections"
                        },
                        {
                            "did": "20",
                            "n": "Any selection"
                        }
                    ],
                    "ExprType": [
                        {
                            "did": "2",
                            "n": "Qualify"
                        },
                        {
                            "did": "5",
                            "n": "Select"
                        }
                    ],
                    "DimtyLevels": [
                        {
                            "did": "1",
                            "n": "Default"
                        },
                        {
                            "did": "2",
                            "n": "Metric"
                        },
                        {
                            "did": "3",
                            "n": "Report"
                        }
                    ],
                    "Attribute": [
                        {
                            "did": "1,6",
                            "n": "Equals",
                            "t": 1
                        },
                        {
                            "did": "1,7",
                            "n": "Does not equal",
                            "t": 1
                        },
                        {
                            "did": "1,8",
                            "n": "Greater than",
                            "t": 1
                        },
                        {
                            "did": "1,10",
                            "n": "Greater than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,9",
                            "n": "Less than",
                            "t": 1
                        },
                        {
                            "did": "1,11",
                            "n": "Less than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,17",
                            "n": "Between",
                            "t": 1
                        },
                        {
                            "did": "1,44",
                            "n": "Not between",
                            "t": 1
                        },
                        {
                            "did": "1,76",
                            "n": "Contains",
                            "t": 1
                        },
                        {
                            "did": "1,79",
                            "n": "Does not contain",
                            "t": 1
                        },
                        {
                            "did": "1,77",
                            "n": "Begins with",
                            "t": 1
                        },
                        {
                            "did": "1,80",
                            "n": "Does not begin with",
                            "t": 1
                        },
                        {
                            "did": "1,78",
                            "n": "Ends with",
                            "t": 1
                        },
                        {
                            "did": "1,81",
                            "n": "Does not end with",
                            "t": 1
                        },
                        {
                            "did": "1,18",
                            "n": "Like",
                            "t": 1
                        },
                        {
                            "did": "1,43",
                            "n": "Not Like",
                            "t": 1
                        },
                        {
                            "did": "1,54",
                            "n": "Is Null",
                            "t": 1
                        },
                        {
                            "did": "1,55",
                            "n": "Is Not Null",
                            "t": 1
                        },
                        {
                            "did": "1,22",
                            "n": "In",
                            "t": 1
                        },
                        {
                            "did": "1,57",
                            "n": "Not In",
                            "t": 1
                        }
                    ],
                    "Metric": [
                        {
                            "did": "1,6",
                            "n": "Equals",
                            "t": 1
                        },
                        {
                            "did": "1,7",
                            "n": "Does not equal",
                            "t": 1
                        },
                        {
                            "did": "1,8",
                            "n": "Greater than",
                            "t": 1
                        },
                        {
                            "did": "1,10",
                            "n": "Greater than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,9",
                            "n": "Less than",
                            "t": 1
                        },
                        {
                            "did": "1,11",
                            "n": "Less than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,17",
                            "n": "Between",
                            "t": 1
                        },
                        {
                            "did": "1,44",
                            "n": "Not between",
                            "t": 1
                        },
                        {
                            "did": "1,54",
                            "n": "Is Null",
                            "t": 1
                        },
                        {
                            "did": "1,55",
                            "n": "Is Not Null",
                            "t": 1
                        },
                        {
                            "did": "1,22",
                            "n": "In",
                            "t": 1
                        },
                        {
                            "did": "1,57",
                            "n": "Not In",
                            "t": 1
                        },
                        {
                            "did": "2,1",
                            "n": "Highest",
                            "t": 2
                        },
                        {
                            "did": "2,2",
                            "n": "Lowest",
                            "t": 2
                        },
                        {
                            "did": "3,1",
                            "n": "Highest%",
                            "t": 3
                        },
                        {
                            "did": "3,2",
                            "n": "Lowest%",
                            "t": 3
                        }
                    ],
                    "MDXAttribute": [
                        {
                            "did": "1,6",
                            "n": "Equals",
                            "t": 1
                        },
                        {
                            "did": "1,7",
                            "n": "Does not equal",
                            "t": 1
                        },
                        {
                            "did": "1,8",
                            "n": "Greater than",
                            "t": 1
                        },
                        {
                            "did": "1,10",
                            "n": "Greater than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,9",
                            "n": "Less than",
                            "t": 1
                        },
                        {
                            "did": "1,11",
                            "n": "Less than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,17",
                            "n": "Between",
                            "t": 1
                        },
                        {
                            "did": "1,44",
                            "n": "Not between",
                            "t": 1
                        },
                        {
                            "did": "1,22",
                            "n": "In",
                            "t": 1
                        },
                        {
                            "did": "1,57",
                            "n": "Not In",
                            "t": 1
                        }
                    ],
                    "MDXMetric": [
                        {
                            "did": "1,6",
                            "n": "Equals",
                            "t": 1
                        },
                        {
                            "did": "1,7",
                            "n": "Does not equal",
                            "t": 1
                        },
                        {
                            "did": "1,8",
                            "n": "Greater than",
                            "t": 1
                        },
                        {
                            "did": "1,10",
                            "n": "Greater than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,9",
                            "n": "Less than",
                            "t": 1
                        },
                        {
                            "did": "1,11",
                            "n": "Less than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,17",
                            "n": "Between",
                            "t": 1
                        }
                    ],
                    "SAPAttribute": [
                        {
                            "did": "1,6",
                            "n": "Equals",
                            "t": 1
                        },
                        {
                            "did": "1,7",
                            "n": "Does not equal",
                            "t": 1
                        },
                        {
                            "did": "1,22",
                            "n": "In",
                            "t": 1
                        },
                        {
                            "did": "1,57",
                            "n": "Not In",
                            "t": 1
                        },
                        {
                            "did": "1,8",
                            "n": "Greater than",
                            "t": 1
                        },
                        {
                            "did": "1,10",
                            "n": "Greater than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,9",
                            "n": "Less than",
                            "t": 1
                        },
                        {
                            "did": "1,11",
                            "n": "Less than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,17",
                            "n": "Between",
                            "t": 1
                        }
                    ],
                    "Element": [
                        {
                            "did": "1,22",
                            "n": "In List",
                            "t": 1
                        },
                        {
                            "did": "1,57",
                            "n": "Not In List",
                            "t": 1
                        }
                    ]
                },
                "validation": {
                        "requiredFieldError": mstrmojo.desc(6078, "This field is required."),
                        "invalidCharError": mstrmojo.desc(7899, "This field contains invalid characters for #."),
                        "invalidDateStringError": mstrmojo.desc(7900, "This field contains invalid date/time string."),
                        "invalidNumericFormatError": mstrmojo.desc(7901, "This field contains numeric value with incorrect format."),
                        "outofRangeError": mstrmojo.desc(6079, "This field should be # between ## and ###."),
                        "noLessMinError": mstrmojo.desc(6081,  "This field should be # greater than or equal to ##."),
                        "noGreaterMaxError": mstrmojo.desc(6080, "This field should be # less than or equal to ###."),
                        "failRegexTestError": mstrmojo.desc(6082, "This field failed regular expression validation."),
                        "invalidValueInListError": mstrmojo.desc(7902, "One of the value (#) in this list is not valid."),
                        "integerDataType": mstrmojo.desc(6076, "an Integer value"),
                        "numericDataType": mstrmojo.desc(6077, "a Number value"),
                        "dateDataType": mstrmojo.desc(7903, "a Date/Time value")    
                },
                'color':{
                    'colors':[{'n':'Black','v':'#000000'},{'n':'Brown','v':'#993300'},{'n':'Olive Green','v':'#333300'},{'n':'Dark Green','v':'#003300'},{'n':'Dark Teal','v':'#003366'},{'n':'Dark Blue','v':'#000080'},{'n':'Indigo','v':'#333399'},{'n':'Grey-80%','v':'#333333'},{'n':'Dark Red','v':'#800000'},{'n':'Orange','v':'#FF6600'},{'n':'Dark Yellow','v':'#808000'},{'n':'Green','v':'#008000'},{'n':'Teal','v':'#008080'},{'n':'Blue','v':'#0000FF'},{'n':'Blue-Grey','v':'#666699'},{'n':'Grey-50%','v':'#808080'},{'n':'Red','v':'#FF0000'},{'n':'Light Orange','v':'#FF9900'},{'n':'Lime','v':'#99CC00'},{'n':'Sea Green','v':'#339966'},{'n':'Aqua','v':'#33CCCC'},{'n':'Light Blue','v':'#3366FF'},{'n':'Violet','v':'#800080'},{'n':'Grey-40%','v':'#969696'},{'n':'Pink','v':'#FF00FF'},{'n':'Gold','v':'#FFCC00'},{'n':'Yellow','v':'#FFFF00'},{'n':'Bright Green','v':'#00FF00'},{'n':'Turquoise','v':'#00FFFF'},{'n':'Sky Blue','v':'#00CCFF'},{'n':'Plum','v':'#993366'},{'n':'Grey-25%','v':'#C0C0C0'},{'n':'Rose','v':'#FF99CC'},{'n':'Tan','v':'#FFCC99'},{'n':'Light Yellow','v':'#FFFF99'},{'n':'Light Green','v':'#CCFFCC'},{'n':'Light Turquoise','v':'#CCFFFF'},{'n':'Pale Blue','v':'#99CCFF'},{'n':'Lavender','v':'#CC99FF'},{'n':'White','v':'#ffffff'}],
                    'userPalette':[{'n':'#F00E0E','v':'#F00E0E'},{'n':'#080000','v':'#080000'},{'n':'#E81A1A','v':'#E81A1A'},{'n':'#6E0909','v':'#6E0909'},{'n':'#4F2828','v':'#4F2828'},{'n':'#141212','v':'#141212'},{'n':'#D60202','v':'#D60202'},{'n':'#C40404','v':'#C40404'}]
                }
                                
        	}
        );
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.hash");

    mstrmojo.mstr.ElementDataService = mstrmojo.provide(

        'mstrmojo.mstr.ElementDataService',

        {
            
            getElements: function getElements(params, callback) {
                var req = mstrmojo.hash.copy(params, {});
                req.taskId = req.taskId || 'browseElements';
                mstrApp.serverRequest(req, callback, {
                    showWait: true,
                    hideWait: true,
                    delay: true
                });
            }
        }
    );
}());
(function() {
    
    mstrmojo.requiresCls( "mstrmojo.func",
                          "mstrmojo.hash" );

    var $FWM = mstrmojo.func.wrapMethods,
        $HSH = mstrmojo.hash;

    
    function getHandlerFunction(methodName) {
        return function() {
            
            var model = this,
                args = [].slice.call(arguments),        
                callback = args.pop();
            
            
            args.push(mstrmojo.func.wrapMethods({
                success: function (res) {
                	model.setData(res);
                },
                
                prompts: function(res) {
                	model.setPrompts(model.getDataService().getPrompts());
                }
            }, callback));

            
            this.submitToDataService(methodName, args);
        };
    }
    
    
    function executeHandler(model, data) {
        
        if (data) {
            
            model.data = data;
        }
        
        
        
        model.setPrompts(model.getDataService().getPrompts());
    }
    
    
    mstrmojo._IsRptModel = {
            
        _mixinName: 'mstrmojo._IsRptModel',
        
        setPrompts: function setPrompts(prompts) {
            this.prompts = prompts;
            if (prompts) {
                prompts.host = this;
            }
        },

        getDataService: function getDataService() {
            return this.dataService;
        },
        
        execute: function execute(params, callback) {
            var model = this,
            
                
                
                p = $HSH.copy( params, {
                    dssId: params.did
                } );
                                    
            if (params.forceExec){
                
                p.execFlags = 1;
                p.doNotUpdateCaches = true;
            }

            this.getDataService().execute(p, $FWM({
                    success: function (res) {
                        executeHandler(model, res);
                    },
                    prompts: function () {
                        executeHandler(model);
                    }
                }, callback));
        },
        
        refresh: function refresh(params, callback){
            var model = this;
            this.getDataService().getResults(
                null,
                $FWM({
                   success: function(res) {
                        executeHandler(model, res);
                   }
                }, callback));           
        },
        
        answerPrompts: function answerPrompts(callback) {
            var model = this;
            this.getDataService().answerPrompts(this.prompts, $FWM({
                success: function (res) {
                    model.data = res;
                }
            }, callback));
        },
        
        
        submitToDataService : function submitToDataService(methodName, args) {
            var dataService = this.getDataService();
            dataService[methodName].apply(dataService, args);
        },
        
        getPageByTree: function getPageByTree(callback) {
            this.submitToDataService.call(this, 'getPageByTree', [ callback ]);
        },
        
        sort: getHandlerFunction('sort'),
        
        pivot: getHandlerFunction('pivot'),
        
        drillGrid: getHandlerFunction('drillGrid'),
        
        drill2Grid: getHandlerFunction('drill2Grid'),
        
        linkToObject: getHandlerFunction('linkToObject'),
        
        pageBy: getHandlerFunction('pageBy'),
        
        setData: function setData(res) {
            this.data = res;
            
            
            if ( ! this.prompts ) {
                this.setPrompts(this.dataService.getPrompts());
            }
        	
        }
    };
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.hash");
    
    
    mstrmojo._HasPopup =
    
    {
        
        
        openPopup: function opP( ref,  config) {
            
            
            var isProp = !!ref && (typeof(ref) === "string") && !ref.match(/\./) && !!this[ref],
                
                p = mstrmojo.registry.ref(isProp ? this[ref] : ref, true);

            
            if (p && p.open) {
                
                
                
                if (isProp) {
                    this[ref] = p;
                }
                
                this.disposables.push(p);
                
                var s = p.slot && this[p.slot];
                if (s) {
                    if (p.parent !== this) {
                        
                        if (this.addChildren) {
                            
                            
                            this.addChildren(p);
                        } else {
                            
                            
                            
                            
                            
                            var skipCheck = false,
                                el = p.domNode || p.placeholder;
                            if (el && typeof(el) === 'string') {
                                el = document.getElementById(el);
                            }
                            if (!el) {
                                skipCheck = true;
                                el = document.createElement('span');
                                p.placeholder = el;                                
                            }
                            if (skipCheck || (el.parentNode !== s)) {
                                s.appendChild(el);
                            }
                        }
                    }
                }
                p.open(this, config);
                this._lastOpened = p;
            }
        },
        
        
        closePopup: function clP() {
            var p = this._lastOpened;
            if (p && p.visible && p.close) {
                p.close();
                delete this._lastOpened;
            }
        }
    };

})();

 
(function(){
    
    mstrmojo.requiresCls( "mstrmojo.hash" );

    
    var _H = mstrmojo.hash;
    
    
    
    
    var elapsedTm = function(ts) {
        return ( mstrmojo.now() - ts.getTime());
    };
    
     
    mstrmojo.storage.DOMStorage = mstrmojo.declare( null, null,     
    
    {
        scriptClass: "mstrmojo.storage.DOMStorage",
        
        
        mIsSupported: false,
        
        
        mStorageObj: null,
        
                
        itemTimeToLive: 3600,

        
        init : function init(props) {
            
            _H.copy(props, this);
            return this;
        },

        
        isSupported: function isSupported() { return this.mIsSupported; },


        checkVersion: function checkVersion(curVer) {
            
            var  existingVer = this.getItem('__version__');
            
            
            if ( existingVer && existingVer < curVer ) {
                mstrmojo.dbg( "DOMStorage data is old - clearing, v="+existingVer );
                this.clear();
            }
            
            this.setItem('__version__',curVer,-1);
            
            return this;
        },



        
        length: function() { return ( this.mIsSupported ? this.mStorageObj.length : 0 ); },

    
    
       
         
        _keyExpired: function _keyExpired(d) {
            return (d && (d.ts>0) && (mstrmojo.now() > d.ts));
        },
        
        
        key: function(index) { return ( this.mIsSupported ? this.mStorageObj.key(index) : null ); },
        
             
        getItemAsString: function( key ) {
            var result = this.getItem(key);
            if (result){
                if ( typeof result == "object" ) {
                    
                    result = JSON.stringify(result);    
                } else {
                    
                    result = result + "";
                }
            }
            return result;
        },
        
              

        getItem: function(key) { 
            var result = null;
            if (this.mIsSupported){            
                var d = this.mStorageObj.getItem(key);
                if ( d ) {
                    try { d = JSON.parse(d); } catch(e) {  }
                    if ( this._keyExpired( d ) ) {
                        this.removeItem(key);
                    } else {
                        
                        result = d.data;
                    }
                }
            }
            return result;
        },



             
         
        setItem: function(key,any_data,ttl) {
            ttl = ttl || this.itemTimeToLive;            
            try {
                
                if ( this.mIsSupported ) {
                    this.mStorageObj.removeItem(key);
                    
                    
                    var exp = (ttl > 0) ? (mstrmojo.now() + (ttl*1000)) : -1;
                    var item = { ts: exp, data: any_data };
                    this.mStorageObj.setItem(key,JSON.stringify(item) );
                }
            } catch ( e ) {
                
                
                if ( e !== QUOTA_EXCEEDED_ERR ) { throw e; }
            } finally {
            }
            return this;
        },


             
         
        removeItem: function(key) {
            if ( this.mIsSupported ) { this.mStorageObj.removeItem(key); }
            return this;
        },


             
         
        clear: function() {
            if ( this.mIsSupported ) { this.mStorageObj.clear(); }
            return this;
        }

    } );
    
})();
(function(){
	mstrmojo.requiresCls("mstrmojo.hash");
	
    var reCHAIN_THIS = /this\.([\w\.\[\]\'\"\-]+)/m,
        reCHAIN_THIS_TEST = /this\./m,
        reCHAIN_ALL_BRACKET = /mstrmojo\.all\[[\'\"]([\w]+)[\'\"]\]\.([\w\.\[\]\'\"\-]+)/m,
        reCHAIN_ALL_BRACKET_TEST = /mstrmojo\.all\[/m,
        reCHAIN_ALL_DOT = /mstrmojo\.all\.([\w]+)\.([\w\.\[\]\'\"\-]+)/m,
        reCHAIN_ALL_DOT_TEST = /mstrmojo\.all\./m,
        reCvtIdxs = /\[(\d+)\]/g,
        reCvtSingleQts = /\[\'([\w\-]+)\'\]/g,
        reCvtDblQts = /\[\"([\w\-]+)\"\]/g,
        reTruncBrkts = /([\[\]].*)/;

    mstrmojo.Binding = mstrmojo.declare(
        
        null,
        
        null,
        
        {
			scriptClass: "mstrmojo.Binding",
			
            
            parent: null,
            
            
            source: null,
            
            
            destination: null,

            
            enabled: false,
            
            
            setter: "set",
            
            
            executing: 0,
                        
            init: function init( props) {
                
                mstrmojo.hash.copy(props, this);
                
                
                mstrmojo.registry.add(this);
            },

            destroy: function dest(){
                
                mstrmojo.publisher.clearSubscriptions(this.id);
                
                mstrmojo.registry.remove(this);
            },
                        
            
            exec: function exec(){
                this.executing++;
                
                var fn = this._sourceFn;
                if (!fn) {
                    var s = this.source;
                    if (s != null) {
                        if (typeof(s) == "string") {
                            
                            
                            
                            if (!(s.match("return ")) && !(s.match(/\;\s*\S/))) {
                                s = "return " + s;
                            }
                            fn = new Function(s);
                        } else if (typeof(s) == "function") {
                            fn = s;
                        }
                        this._sourceFn = fn;
                    }
                }
                
                
                var v, p = this.parent;
                if (fn) {
                    try {
                        v = fn.apply(p, []);
                    } catch(ex) {
                        
                    }
                }        
                
                
                var st = this.setter,
                    d = this.destination;
                if (st == null) {
                    p[d] = v;
                } else if (typeof(st) == "string") {
                    p[st](d, v);
                } else if (typeof(st) == "function") {
                    st.apply(p, [d,v]);
                }
                this.executing--;
            },
                        
            
            enable: function en() {
                if (!this.enabled) {        
                    
                    this.exec();        
                    
                    var chs = this._chains;
                    if (!chs) {
                        this._parseChains();
                        chs = this._chains;
                    }
                    
                    for (var k in chs) {
                        this._attachChain(chs[k]);
                    }
                    this.enabled = true;
                }
            },
            
            
            disable: function dis() {
                if (this.enabled) {
                    
                    var chs = this._chains;
                    if (chs) {
                        for (var k in chs) {
                            this._detachChain(chs[k]);
                        }                
                    }        
                    this.enabled = false;        
                }
            },

            
            _chains: null,

            
            _parseChains: function() {
                
                this._chains = {};
                var chains = this._chains;

                
                var s = this.source;
                if (s && (typeof(s) == "function")) {
                    s = s.toString && s.toString();
                }
                if (!s) {
                    return;
                }
                
                
                function _findMatches( str,  re,  hostIdx,  partsIdx) {
                    var sTemp = str,
                        match;
                
                    while (match = sTemp.match(re)) {    
                        
                        var key = match[0],
                            len = key.length,
                            add = true;
                        
                        
                        
                        key = key.replace(reCvtIdxs, ".$1"
                                    ).replace(reCvtSingleQts, ".$1"
                                    ).replace(reCvtDblQts, ".$1"
                                    ).replace(reTruncBrkts, '');
                        
                        
                        for (var k in chains) {
                            if (k.substr(0, len) === key) {
                                
                                add = false;
                                break;
                            } else if (key.indexOf(k) === 0) {
                                
                                delete chains[k];
                            }
                        }
                        if (add) {
                            chains[key] = {
                                host: (hostIdx == null) ? null : match[hostIdx],
                                parts: match[partsIdx].replace(reCvtIdxs, ".$1"
                                        ).replace(reCvtSingleQts, ".$1"
                                        ).replace(reCvtDblQts, ".$1"
                                        ).replace(reTruncBrkts, '').split('.')
                            };
                        }
                        sTemp = sTemp.substr(match.index + len);
                    }
                }                
                
                
                if (reCHAIN_THIS_TEST.test(s)) {
                    _findMatches(s, reCHAIN_THIS, null, 1);
                }
                
                
                if (reCHAIN_ALL_BRACKET_TEST.test(s)) {
                    _findMatches(s, reCHAIN_ALL_BRACKET, 1, 2);
                }
                
                if (reCHAIN_ALL_DOT_TEST.test(s)) {
                    _findMatches(s, reCHAIN_ALL_DOT, 1, 2);
                }
            },

            
             _attachChain: function attCh( ch,  start) {
    
                
                 if (!ch.evt2idx) {
                     ch.evt2idx = {};
                 }
                 if (!ch.idx2evt) {
                     ch.idx2evt = [];
                 }
                 var evt2idx = ch.evt2idx,
                     idx2evt = ch.idx2evt,
                     parts = ch.parts;
    
                 
                 var idx = (start >= 0) ? start : 0,
                     bId = this.id,
                     reg = mstrmojo.all,
                     ctxt = (start > 0) ?
                                 reg[idx2evt[idx-1].context][parts[idx-1]] :
                                 (ch.host ? reg[ch.host] : this.parent), 
                     prop = parts[idx];
                     
                
                var A = mstrmojo.array;                 
                 while (ctxt && prop) {
                     if (ctxt.attachEventListener) {
                         
                         var evts = ctxt[prop+"_bindEvents"] || (prop+"Change");
                         if (typeof(evts) == "string") {
                             evts = [evts];
                         }
                         var subs = [];
                         for (var i = 0, iLen = evts.length; i< iLen; i++) {                           
                             subs[i] = ctxt.attachEventListener(evts[i], bId, "_callback");
                         }
                         
                         
                         for (var i=0; i<evts.length; i++) {
                             evt2idx[ ctxt.id+"_"+evts[i] ] = idx;
                         }
                         
                         
                         idx2evt[idx] = {context: ctxt.id, evts: evts, subs: subs};
                     }
                     
                     ctxt = ctxt[prop];
                     prop = ch.parts[++idx];
                 }
             },
             
            
            _detachChain: function detCh( ch,  start) {

                 var reg = mstrmojo.all,
                     idx2evt = ch.idx2evt,
                     evt2idx = ch.evt2idx,
                     bId = this.id;
    
                 var i = (start > -1) ? start : 0,
                     len = idx2evt.length;
                 if (i < len) {
                     for (; i<len; i++) {
                          
                         var atts = idx2evt[i];
                         if (!atts) {
                             break;
                         }
                         var ctxtid = atts.context,
                             ctxt = reg[ctxtid],
                             evts = atts.evts;
                             
                         
                         if (ctxt && ctxt.detachEventListener) {
                             var s = atts.subs;                                
                             for(var t = 0, tLen = s.length; t < tLen; t++) {                                
                                 ctxt.detachEventListener(s[t]);
                             }
                         }
                         
                         idx2evt[i] = null;
                         
                         for (var j=0, jLen=evts.length; j<jLen; j++) {
                             delete evt2idx[ctxtid+"_"+evts[j]];
                         }
                     }
                 }
            },
            
            
            _callback: function clbk( evt) {
                
                
                this.exec();
                
                
                    
                if (!evt || !evt.name || !evt.src) {
                    return;
                }
                
                
                var k = evt.src.id+"_"+evt.name,
                    chains = this._chains;
                
                for (var c in chains) {
                    
                    var ch = chains[c],
                        idx = ch.evt2idx[k];
                    if (idx != null) {
                        
                        this._detachChain(ch, idx+1);
                        this._attachChain(ch, idx+1);
                    }
                }

            }
                                    
        }
    );

})();


(function () {

    mstrmojo.requiresCls("mstrmojo.debug");

    
    
    var MAX_DEPTH = 14;
    var SPACES = "                              ";
    var NL="\n";
    
    
    
    function _isArray( obj ) { return toString.call(obj) === "[object Array]"; }

    
    
    function _ArrayToString(a,depth,params,nl) {
        var d = depth || 1;
        var spc = SPACES.substr(0,d);
        var output = ["undefined"];

        nl = nl || NL;
        if ( a ) {
            output = ["["];
            for( var i=0; i < a.length; i++) {
                if (i != 0) {
                    output.push("," + nl);
                } else {
                    output.push(nl);
                }
                output.push(spc + _objToString(a[i], d+1,params));
            }
            output.push(spc + spc + nl + "]");
        }            
        return output.join('');
    }

    
    
     function _HashToString(h,depth,params,nl) {
         var    d = depth || 1,
                spc = SPACES.substr(0,d),
                i = 0,
                output = ["undefined"],
                ik = params.ignoreKeys;
                
         nl = nl || NL;

         if ( h ) {
             output = ["{"+nl];

             for (var key in h) {                        
                 
                 
                 if ( params.ignoreFuncs && typeof h[key]==="function") {
                     continue;
                     
                 
                 } else if ( ik && ik[key] ) {
                     continue;
                 }

                 if ( i == 0) {
                     output.push(nl);
                 } else {
                     output.push(","+nl);
                 }
                 
                 output.push(spc + "\"" + key + "\"" + ": ");

                
                 if ( key=="window"||key=="document"||key=="mstrmojo"||key=="global") {
                     if ( h[key]=="null") {
                         output.push( "null");
                     } else {
                         output.push("[" + key + "]");
                     }
                 } else if ( /.*Sibling*/.test(key)) {
                     if ( h[key]=="null") {
                         output.push( "null");
                     } else {
                         output.push("[" + typeof h[key] + "]");
                     }
                 } else if ( key=="target") {
                     if ( h[key]=="null") {
                         output.push( "null");
                     } else {
                         output.push("[id="+h[key].id+"]");
                     }
                 } else {
                     output.push(_objToString(h[key],d+1,params));                
                 }                
                 i++;
             }
             output.push(spc + spc + nl + "}");
         }
         return output.join('');
     }

    
    
    function _TouchListToString(touchList,depth,params,nl) {
        var numTouches = touchList.length;
        var d = depth || 1;
        var spc = SPACES.substr(0,d);
        var output = ["["];
        nl = nl || NL;

        for( var k = 0; k < numTouches;k++) {
            if ( k==0)
                output.push(" ");
            else
                output.push(", ");

            output.push(_objToString(touchList[k], d+1, params, " " ));
        } 
        output.push("]");
        return output.join('');
    }    
    
    
    
    function _touchEventToString(evt,depth,params,nl) {
        var d = depth || 1;
        var spc = SPACES.substr(0,d);
        var output = [];
        
        nl = nl || NL;
        output.push(spc + "{" + nl);
        output.push(spc + "changedTouches: ");
        output.push(_TouchListToString(evt.changedTouches,d+1,params) + "," + nl);
        output.push(spc + "touches: ");
        output.push(_TouchListToString(evt.touches,d+1,params) + "," + nl);
        output.push(spc + "targetTouches: ");
        output.push(_TouchListToString(evt.targetTouches,d+1,params) + nl);
        output.push(spc + "}" + nl);
        return output.join('');
    };

    
    
     function _objToString( o, depth, params, nl ) {
        var d = depth || 1;
        var spc = (nl==" ") ? "" : SPACES.substr(0,d);
        var i = 0;
        var output = [];
        nl = nl || NL;

        if ( o === null ) {
            output.push("null");
        } else if ( typeof o === "undefined" ) {
            output.push("undefined");
        } else if ( _isArray(o)) { 
            output.push(_ArrayToString(o,d+1,params));
        } else if ( typeof o === "function" ) {
            output.push("function");
        } else if ( o instanceof HTMLElement ) {
            output.push("[HTMLElement, id="+o.id+"]");
        } else if ( o instanceof TouchEvent ) {
            output.push(_touchEventToString(o,d+1,params));
        } else {
            if ( o==window || o==document ) {
                output.push(o.toString());
            } else if ( typeof o === "object" ) {            
                if (d <= params.maxDepth ) {
                    output.push(_HashToString(o, d+1,params,nl ));
                } else {
                    
                    output.push("["+(typeof o)+"]");
                }
            } else if (typeof o === "string") {
                
                output.push("\"" + o.replace(/"/g,"\\\"" ) + "\"");
            } else {
                output.push(o.toString());
            }
        }                       
        return output.join('');
    };


	mstrmojo.debug.utils = {

        

         objectToString: function objectToString( o, params ) {
             var depth=0;
             return _objToString(o,depth,params);
         },

	    
	    touchEventToString: function touchEventToString(evt) {
	        var depth=0;
	        return _objToString(evt,depth); 
	    }	    
	};
	
	
	 
    mstrmojo.dbg_obj = function dbg_obj(obj,userParams) {
        var params = { 
            ignoreFuncs: false,
            
            
            ignoreKeys: {},
            maxDepth: MAX_DEPTH
        };
        userParams = userParams || {};
        for (var n in userParams) {
            params[n] = userParams[n];
        }
        mstrmojo.dbg(mstrmojo.debug.utils.objectToString(obj, params ));
    };

    mstrmojo.dbg_touchEvent = function dbg_touchEvent(obj) {
        mstrmojo.dbg(mstrmojo.debug.utils.touchEventToString(obj));
    };
    
})();

(function () {

    mstrmojo.requiresCls("mstrmojo.array");

    var $ARR = mstrmojo.array;

    
    mstrmojo._IsPanelStack = mstrmojo.provide(

        "mstrmojo._IsPanelStack",

        
        {
            _mixinName: 'mstrmojo._IsPanelStack',
            
            TTL_SRC_PANEL: 0,

            init: function init(props) {
                this._super(props);

                
                var defn = this.defn;

                
                if (!defn) {
                    
                    defn = this.defn = this.node && this.node.defn;

                    
                    this.titleSrc = this.titleSrc || defn.ttlSrc;
                }

                
                var key = this.selectedKey = this.defn.selKey = this.node.data.selKey;

                
                this.set('selectedIdx', $ARR.find(this.node.data.panels, 'k', key));

                
                defn.attachEventListener('selKeyChange', this.id, function (evt) {
                    this.set('selectedKey', evt.value);
                });
            },

            
            addChildren: function addChildren(panels, idx, silent) {
                var fmts = this.getFormats(),
                    overflow = fmts && fmts.overflow;

                if (overflow) {
                    $ARR.forEach(panels, function (panel) {
                        var pnlFmts = panel.getFormats();
                        if (pnlFmts) {
                            pnlFmts.overflow = overflow;
                        }
                    });
                }

                return this._super(panels, idx, silent);
            },

            
            refresh: function refresh() {
                
                if (this.hasRendered) {
                    
                    var refreshKey = this.defn.newSelKey || this.selectedKey;
                    
                    
                    $ARR.forEach(this.children, function (child) {
                        
                        child._delayRefresh = (child.k !== refreshKey);

                        
                        if (!child._delayRefresh) {
                            
                            child.refresh();
                        }
                    });
                    
                }
                delete this.defn.newSelKey;
            },

            
            selectPanel: function selectPanel(key, hasLoader) {
                
                if (key !== this.selectedKey) {
                    
                    this.defn.set('selKeyChange', key);

                    
                    this.model.slice({
                        type: 3,
                        tks: this.k,
                        eid: key,
                        sid: this.node.data.wid,
                        ck: this.k,
                        hasLoader: hasLoader
                    });
                }
            },

            
            onselectedKeyChange: function onselKeyChg(evt) {
                var off, on, selectedIdx;

                
                $ARR.forEach(this.children, function (panel, idx) {
                    var panelKey = panel.k;

                    
                    if (evt.value === panelKey) {
                        
                        on = panel;
                        selectedIdx = idx;

                        
                        panel.set('selected', true);

                    
                    } else if (evt.valueWas === panelKey) {
                        
                        off = panel;

                        
                        panel.set('selected', false);
                    }

                    
                    if (on && off) {
                        
                        return false;
                    }
                });

                
                if (this.titleSrc === this.TTL_SRC_PANEL && this.title) {
                    this.set('title', on.title);

                    
                    this.defn.ttl = on.title;
                }

                
                this.prevSelectIdx = this.selectedIdx;
                this.set('selectedIdx', selectedIdx);

                
                this.raiseEvent({
                    name: 'panelSelected',
                    key: on.k
                });

                
                return {
                    on: on,
                    off: off
                };
            },

            
            setDirty: function setDirty(isDirty) {
                
                if (isDirty) {
                    
                    this.setDirtyChildren(true);
                }

                this._super(isDirty);
            },

            
            setDirtyChildren: function setDirtyChildren(includeAll) {
                
                var selectedKey = this.selectedKey;

                
                $ARR.forEach(this.children, function (child) {
                    
                    var key = child.k;
                    child[((includeAll || key !== selectedKey) ? 'add' : 'remove') + 'DirtyKey'](key);
                });
            },

            
            clearDirtyChild: function clearDirtyChild(key) {
                var panels = this.children,
                    panel = panels[$ARR.find(panels, 'k', key)];

                if (panel) {
                    panel.removeDirtyKey(panel.k);
                }
            },
            
            isPanelStack: true,
            
            checkRequiredObjects: function checkRequiredObjects() {
                var txWidgets = this.txWidgets || {}, 
                    i, w, flag = true;

                for (i in txWidgets){
                    
                    flag &= !!txWidgets[i].checkRequiredObjects();
                }
                
                return flag;
            },
            
            
            updateSelectedIdx: mstrmojo.emptyFn,
            
            
            switchToPanel: function switchToPanel(dir, selectedIdx) {
             
                if (selectedIdx !== undefined) {
                    
                    this.set('selectedIdx', selectedIdx);
                } else {
                    
                    this.updateSelectedIdx(dir);
                }

                
                this.children[this.selectedIdx] && this.selectPanel(this.children[this.selectedIdx].k);
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.array");

    var MAX_TOOLTIPS = 10, 
        TOOLTIP_PADDING = 20,
        tooltipPositionChanged = false,
        rightTooltipPositionChanged = false,
        maxAreasToShow = MAX_TOOLTIPS,
        tooltipsToPosition = [],
        $ARR = mstrmojo.array,
        hasLargeTooltip = false,    
        TOOLTIP_PADDING_LEFT_RIGHT, 
        topTitleHeight;


    
    var AreaShapePolygon = 6,
        AreaShapeRectangle = 7,
        AreaShapeCircle = 100,
        AreaShapeRingSector = 101,
        AreaShapeNormalSector = 102,
        AreaShapeCylinder = 103;

    function drawPoly(ctx, pointsArray, clr) {
        
        var startX = pointsArray[0],
            startY = pointsArray[1],
            j;

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        for (j = 2; j < pointsArray.length - 1; j = j + 2) {
            ctx.lineTo(pointsArray[j], pointsArray[j + 1]);
        }
        ctx.lineTo(startX, startY); 

        
        ctx.fillStyle = clr;

        ctx.stroke();

        ctx.fill();
    }

    function drawRectangle(ctx, pointsArray, clr) {
        var x = pointsArray[0],
            y = pointsArray[1],
            width = pointsArray[2] - x,
            height = pointsArray[3] - y;

        ctx.fillStyle = clr;

        ctx.strokeRect(x, y, width, height);
        ctx.fillRect(x, y, width, height);
    }

    function drawRingSector(ctx, pointsArray, clr) {
        var centerX = pointsArray[0],
            centerY = pointsArray[1],
            innerRadius = pointsArray[2],
            outerRadius = pointsArray[3],
            startAngle = pointsArray[4],
            endAngle = pointsArray[5];

        ctx.beginPath();
        
        ctx.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);
        
        ctx.lineTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));
        
        ctx.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);

        ctx.closePath();

        
        ctx.fillStyle = clr;
        ctx.stroke();
        ctx.fill();

    }

    function drawNormalSector(ctx, pointsArray, clr) {
        var centerX = pointsArray[0],
            centerY = pointsArray[1],
            radius = pointsArray[2],
            startAngle = pointsArray[3],
            endAngle = pointsArray[4],
            scale = pointsArray[5];
        ctx.scale(1, scale);
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);
        ctx.lineTo(centerX, centerY);
        ctx.arc(centerX, centerY, 0, endAngle, startAngle, true);
        ctx.closePath();
        
        
        ctx.fillStyle = clr;
        ctx.stroke();
        ctx.fill();
        ctx.scale(1, 1/scale);
    }

    function drawCylinder(ctx, pointsArray, clr) {
        var centerX = pointsArray[0],
            centerY = pointsArray[1],
            radius = pointsArray[2],
            startAngle = pointsArray[3],
            endAngle = pointsArray[4],
            depth = pointsArray[5],
            scale = pointsArray[6];
        ctx.scale(1, scale);
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);
        ctx.lineTo(centerX+radius*Math.cos(endAngle), centerY+radius*Math.sin(endAngle)-depth);
        ctx.arc(centerX, centerY - depth, radius, endAngle, startAngle, true);
        ctx.closePath();
        
        
        ctx.fillStyle = clr;
        ctx.stroke();
        ctx.fill();
        ctx.scale(1, 1/scale);
    }
    
    function drawCircle(ctx, pointsArray, clr) {
        
        ctx.fillStyle = clr;
        ctx.beginPath();
        ctx.arc(pointsArray[0], pointsArray[1], pointsArray[2], 0, Math.PI * 2, true);
        ctx.stroke();
        ctx.fill();
    }

    function sortAreaElements(a, b) {
        return a.Point.X - b.Point.X;
    }

    function setTooltipInfo(area, ep, tooltipPosition) {
        var tooltip = this.tooltipArr[tooltipPosition],
            ttl = area.Text,
            borderColor = area.SC,
            style = tooltip.style,
            zoom = (this.model.zf || 1),
            deviceDPI = mstrMobileApp.getDeviceDPI() / 160,
            padding = 2 * deviceDPI,
            tooltipMaxWidth = mstrApp.getScreenDimensions().w - (TOOLTIP_PADDING_LEFT_RIGHT * 2); 
            

        
        if (mstrApp.isTablet()) {            
            zoom = (zoom * deviceDPI) + 'em';
        } else if (mstrMobileApp.getDeviceDPI() > 240) {  
            zoom = (zoom * 1.5) + 'em';
        } else {
            zoom += 'em';
        }

        
        var cssText = 'font-size:' + zoom + ';';

        
        cssText += 'padding:' +  padding + 'px;';
        
        
        cssText += 'maxWidth:' + tooltipMaxWidth + 'px;';

            
        if (borderColor) { 
            cssText += 'border-color:#' + borderColor;
        }

        tooltip.innerHTML = ttl;
        style.cssText = cssText;

        style.display = 'block';

        
        var top = 0,
            left = 0;

        var offsetHeight = tooltip.offsetHeight,
            offsetWidth = tooltip.offsetWidth;

        
        top = ep.y - offsetHeight - 6;
        left = ep.x - offsetWidth - 6; 

        tooltipsToPosition.push({
            x: area.Point.X,
            y: area.Point.Y,
            clr: borderColor || '#000000',
            top: top,
            left: left,
            width: offsetWidth,
            height: offsetHeight
        });
    }

    function setSingleTooltipPosition(graph, tooltip, posElement) {
        
        var left = posElement.left,
            top = Math.max(posElement.top, topTitleHeight + TOOLTIP_PADDING) 
            width = posElement.width,
            style = tooltip.style,
            newLeft = left + width + 12;

        
        if (newLeft + width <= mstrApp.getScreenDimensions().w) {
            left = newLeft;
        } else if(left < 0) {  
            left = TOOLTIP_PADDING_LEFT_RIGHT;
        }

        style.left = left + 'px';
        style.top = top + 'px';

        graph.showAreaMarker(posElement.x, posElement.y, posElement.clr);
    }

    function positionLeftColumnTooltip(graph, position) {
        var posElement = tooltipsToPosition[position],
            tooltipArr = graph.tooltipArr,
            style = tooltipArr[position].style,
            left = posElement.left,
            top = posElement.top,
            width = posElement.width,
            height = posElement.height,
            screenWidth = mstrApp.getScreenDimensions().w,
            i,
            newLeft;

        if (position > 0) {
            
            var prevPosElem = tooltipsToPosition[position - 1],
                prevTop = prevPosElem.top,
                prevLeft = prevPosElem.left,
                prevRight = prevLeft + prevPosElem.width,
                currRight = prevLeft + width,
                prevTooltip;

            left = prevLeft;
            
            if (currRight > prevRight) {
                left -= (currRight - prevRight);
            } else if (currRight < prevRight) {
                left += (prevRight - currRight);
            }

            if (left < 0) {
            	
                if ((width * 2 ) + 12 > screenWidth) {
                	tooltipPositionChanged = false; 
                    hasLargeTooltip = true;
                    left = TOOLTIP_PADDING_LEFT_RIGHT;
                    
                    
                    for(i = 0; i < position; i++) {
                    	prevTooltip = tooltipArr[i];
                        prevPosElem = tooltipsToPosition[i];
                        newLeft = left + width - prevPosElem.width;
                        prevPosElem.left = newLeft;
                        prevTooltip.style.left = left + width - prevPosElem.width + 'px'; 
                    }
                    
                } else {
                    
                    tooltipPositionChanged = true;
                }
            }

            
            top = prevTop - TOOLTIP_PADDING - height;

            
            if (top < topTitleHeight) {

            	var pushHeight =  Math.abs(top) + topTitleHeight + TOOLTIP_PADDING;

                for (i = 0; i < position; i++) {
                    prevTooltip = tooltipArr[i];
                    prevPosElem = tooltipsToPosition[i];
                    prevTop = prevPosElem.top + pushHeight;

                    
                    prevPosElem.top = prevTop;
                    prevTooltip.style.top = prevTop + 'px';
                }
                top += pushHeight;
            }
        } else {
            
            if (left < 0) {
                
                
                if ((width * 2 ) + 12 > screenWidth) {
                    hasLargeTooltip = true;
                    left = TOOLTIP_PADDING_LEFT_RIGHT;
                } else {
                    
                    tooltipPositionChanged = true;
                }
            }
            
            if (top < topTitleHeight) {
                top = topTitleHeight + TOOLTIP_PADDING;
            }
        }

        
        if (!tooltipPositionChanged) {
            style.left = left + 'px';
            
            posElement.left = left;
        }

        style.top = top + 'px';

        
        posElement.top = top;

        graph.showAreaMarker(posElement.x, posElement.y, posElement.clr);
    }

    function positionRightColumnTooltip(graph, position, adjustCount, left) {
        var style = graph.tooltipArr[position].style,
            posElement = tooltipsToPosition[position],
            top = tooltipsToPosition[position - adjustCount].top,
            width = posElement.width;

        if (left + width > mstrApp.getScreenDimensions().w) {
            rightTooltipPositionChanged = true;
            style.display = 'none'; 
            return;
        }

        style.left = left + 'px';
        style.top = top + 'px';

        graph.showAreaMarker(posElement.x, posElement.y, posElement.clr);
    }

    function setMultiTooltipPositions(graph) {
        var tooltipsSize = tooltipsToPosition.length,
            tooltipArr = graph.tooltipArr,
            halfTooltipsSize = Math.ceil(tooltipsSize / 2),
            i = 0,
            adjustCount = 1,
            maxColTooltipSize = Math.min(tooltipsSize, MAX_TOOLTIPS / 2),
            screenWidth = mstrApp.getScreenDimensions().w,
            posElement,
            left,
            currTooltip;

        
        for (i = 0; i < halfTooltipsSize; i++) {
            positionLeftColumnTooltip(graph, i);
        }

        
        if (tooltipPositionChanged || hasLargeTooltip) {
            
            for (i; i < maxColTooltipSize; i++) {
                positionLeftColumnTooltip(graph, i);
            }

            if(!hasLargeTooltip) {
            	var j = i - 1,
            	    rightMostPosition = 0,
            	    tempPosition = 0,
            	    biggestPosElement,
            	    currentPosElementWidth;
            	posElement = tooltipsToPosition[j];
            	left = posElement.left + posElement.width + 12;  

            	for (j = i - 1; j >= 0; j--) {
            		currTooltip = tooltipArr[j];
            		currentPosElementWidth = tooltipsToPosition[j].width;
            		
            		if(left + currentPosElementWidth > screenWidth) {
            			tempPosition = TOOLTIP_PADDING_LEFT_RIGHT +  currentPosElementWidth;
            			if(tempPosition > rightMostPosition) {
            				rightMostPositon = tempPosition;
            				biggestPosElement = tooltipsToPosition[j];
            			}
            		}
            		currTooltip.style.left = left + 'px';
            	}
            	
            	
            	if(rightMostPosition > 0) {
            		for(j = 0; j < i; j++) {
            			currTooltip = tooltipArr[j];
            			currTooltip.style.left = (TOOLTIP_PADDING_LEFT_RIGHT + biggestPosElement.width -  tooltipsToPosition[j].width) + 'px';
            		}
            	}
            }
        } else {
            
            posElement = tooltipsToPosition[tooltipsSize - 1];
            left = posElement.left + posElement.width + 12;  

            for (i; i < tooltipsSize; i++) {
                positionRightColumnTooltip(graph, i, adjustCount, left);
                adjustCount += 2; 
                if (rightTooltipPositionChanged) {
                    break;
                }
            }

            
            if (rightTooltipPositionChanged && i <= maxColTooltipSize) {
                for (i = halfTooltipsSize; i < tooltipsSize; i++) {
                    positionLeftColumnTooltip(graph, i);
                    tooltipArr[i].style.display = 'block';
                }
            }
        }
    }

    function setTooltipPositions() {
        var me = this,
            numTooltips = tooltipsToPosition.length;

        if (numTooltips === 0) {
            return; 
        }

        topTitleHeight = mstrApp.rootView.getTitleHeight();  

        if (numTooltips === 1) {
            setSingleTooltipPosition(me, me.tooltipArr[0], tooltipsToPosition[0]);
        } else {
            setMultiTooltipPositions(me);
        }

    }

    function drawShape(shapeType, ctx, coords, color) {
        switch (shapeType) {
        case AreaShapeRectangle:
            drawRectangle(ctx, coords, color);
            break;

        case AreaShapeCircle:
            drawCircle(ctx, coords, color);
            break;
        case AreaShapeRingSector:
            drawRingSector(ctx, coords, color);
            break;
        case AreaShapeNormalSector:
            drawNormalSector(ctx, coords, color);
            break;
        case AreaShapeCylinder:
            drawCylinder(ctx, coords, color);
            break;
        default:
            drawPoly(ctx, coords, color);
        }
    }

    
    mstrmojo.graph._MobileGraphAreaHelper = mstrmojo.provide(
        "mstrmojo.graph._MobileGraphAreaHelper",

        
        {

            highlightArea: function highlightArea(animationCanvas, areas) {
                var me = this,
                    ctx = animationCanvas.getContext('2d'),
                    color = 'rgba(255, 255, 255, 0.5)';

                
                me.clearHighlightArea(animationCanvas);

                
                ctx.strokeStyle = "#FFFFFF";

                $ARR.forEach(areas, function (area) {
                    drawShape(area.Shape, ctx, area.Coords, color);
                });

            },

            highlightAreaInInit: function highlightAreaInInit(animationCanvas, selected) {
                var ctx = animationCanvas.getContext('2d'),
                    allAreas = this.graphData.Areas,
                    color = 'rgba(255, 255, 255, 0.5)';

                
                ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);

                
                ctx.strokeStyle = "#FFFFFF";

                var numAreas = allAreas.length,
                    DssGraphRiser = 286,
                    DssGraphDataMarker = 259,
                    DssGraphPieSlice = 341;

                var numOfSelected = selected.length / 2,
                    j,
                    i;
                for (i = 0; i < numAreas; i++) {
                    var area = allAreas[i],
                        areaOID = parseInt(area.OID, 10);

                    if (areaOID !== DssGraphRiser && areaOID !== DssGraphDataMarker && areaOID !== DssGraphPieSlice) {
                        continue;
                    }

                    if (area.SID < 0 || area.GID < 0) {
                        continue;
                    }
                    for (j = 0; j < numOfSelected; j++) {
                        if (area.SID !== selected[2 * j] || area.GID !== selected[2 * j + 1]) {
                            continue;
                        }

                        drawShape(area.Shape, ctx, area.Coords, color);
                    }

                }
            },

            clearHighlightArea: function clearHighlightArea(animationCanvas) {
                if (animationCanvas) {
                    var ctx = animationCanvas.getContext('2d');
                    ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
                    animationCanvas.width = animationCanvas.width;  
                }
            },

            showAreaMarker: function showAreaMarker(x, y, clr) {
                if (x >= 0 && y >= 0) {

                    var ctx = this.highlightNode.getContext('2d');

                    ctx.save();
                    ctx.fillStyle = '#FFFFFF'; 
                    ctx.strokeStyle = clr || '#000000';
                    ctx.lineWidth = 2;

                    
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2, true);
                    ctx.stroke();
                    ctx.fill();

                    
                    ctx.fillStyle = clr || '#000000';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2, true);
                    ctx.stroke();
                    ctx.fill();


                    ctx.restore();
                }

            },

            displayTooltips: function displayTooltips(areas, adjustX, adjustY) {
                
                areas.sort(sortAreaElements);

                var tooltipArr = this.tooltipArr,
                    i;

                tooltipPositionChanged = false;
                rightTooltipPositionChanged = false;
                tooltipsToPosition = [];
                this.clearHighlightArea(this.highlightNode);

                
                if (!tooltipArr) {
                    TOOLTIP_PADDING_LEFT_RIGHT = 8 * (mstrMobileApp.getDeviceDPI() / 160); 

                    tooltipArr = [];
                    for (i = 0; i < MAX_TOOLTIPS; i++) {
                        var divEl = document.createElement('div');

                        divEl.id = 'mstrmojo-mobileGraph-tooltip';
                        divEl.className = mstrmojo.GraphBase.tooltipCLS;
                        document.body.appendChild(divEl);
                        tooltipArr[i] = divEl;
                    }
                    this.tooltipArr = tooltipArr;
                }

                maxAreasToShow = Math.min(areas.length, MAX_TOOLTIPS);

                var touchManager = mstrmojo.touchManager;

                if (maxAreasToShow === 0 && this._touchListener) {
                    
                    touchManager.detachEventListener(this._touchListener);
                    delete this._touchListener;
                } else if (maxAreasToShow > 0 && !this._touchListener) {
                    this._touchListener = touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                    	
                    	
                    	var sourceWidget = mstrmojo.all[evt.srcId];
                    	
                    	if (!(sourceWidget instanceof mstrmojo.android.ui.ActionToolbarButtons 
                    			|| sourceWidget instanceof mstrmojo.android.ui.Menu)) {
	                    	this.displayTooltips([], 0, 0);   
	                    }
                    });
                }

                var area = null,
                    ep = {},
                    style;

                hasLargeTooltip = false; 
                
                
                for (i = 0; i < MAX_TOOLTIPS; i++) {
                    style = tooltipArr[i].style;
                    style.left = -9999; 
                    style.display = 'none';
                }

                
                for (i = 0; i < maxAreasToShow; i++) {
                    area = areas[i];
                    ep.x = area.Point.X + adjustX;
                    ep.y = area.Point.Y + adjustY;
                    
                    setTooltipInfo.call(this, area, ep, i);
                }

                
                setTooltipPositions.call(this);

                
                window.setTimeout(function () {
                    mstrMobileApp.forceRepaint();
                }, 0);
            },

            destroy: function dst(skipCleanup) {
                
                $ARR.forEach(this.tooltipArr, function (tooltip) {
                    
                    document.body.removeChild(tooltip);
                });

                delete this.tooltipArr;

                if (this._super) {
                    this._super(skipCleanup);
                }
            }
        }
    );

}());
(function () { 

    mstrmojo.requiresCls("mstrmojo.array");
    
    var $ARR = mstrmojo.array,
        $HASH = mstrmojo.hash;
    
     
    function _add( me,  idxs) {
        
        
        if ( !idxs ) {
            return;
        }
        
        var added = [],
            sel = me.selectedIndices,
            allIdx = me.allIdx,
            noneIdx = me.noneIdx,
            inc = me.parent && me.parent.include;

        
        if(me.multiSelect && (noneIdx > -1) && ($ARR.indexOf(idxs, noneIdx) > -1)) {
            return added;
        }
        
        
        var i, len,
            items = me.items,
            idf = me.itemIdField,
            selectedItems = me.selectedItems,
            item;
        
        if (me.multiSelect && (allIdx > -1) && ($ARR.indexOf(idxs, me.allIdx) > -1)) {
            for (i = 0, len=items.length; i < len; i++) {
                if (!sel[i]){
                    added.push(i);
                    sel[i] = true;
                    me.selectedIndex = i;
                    me.selectedItem = items[i];
                }
            }
        } else {
            for (i=0, len=idxs.length; i<len; i++) {
                var idx = idxs[i];
                if (!sel[idx]){
                    sel[idx] = true;
                    added.push(idx);
                    me.selectedIndex = idx;
                    item = me.selectedItem = items[idx];
                    if ( selectedItems ) {
                        selectedItems[item[idf]] = item;
                    }
                }
            }
        }
        return added;
    }
        
     
    function _rmvAll( me) {
        var rmv = [],
            sel = me.selectedIndices,
            selectedItems = me.selectedItems;
        for (var i in sel) {
            delete sel[i];
            rmv.push(parseInt(i, 10));    
        }
        me.selectedIndex = -1;
        me.selectedItem = null;
        if ( selectedItems ) {
            me.selectedItems = {};
        }
        return rmv;
    }
    
     
    function _rmv( me,  idxs) {
        
        if ( !idxs ) {
            return;
        }
        
        var removed = [],
            sel = me.selectedIndices,
            arrIdx = $ARR.indexOf,
            allIdx = me.allIdx,
            noneIdx = me.noneIdx,
            idf = me.itemIdField,
            selectedItems = me.selectedItems;
                
        
        if (me.multiSelect && (((allIdx > -1) && (arrIdx(idxs, allIdx) > -1)) || ((noneIdx > -1) && (arrIdx(idxs, noneIdx) > -1)))) {
            return _rmvAll(me);
        }
        
        
        
        if (idxs.length > 0 && sel[allIdx]) {
            if (arrIdx(idxs, allIdx) < 0) {
                idxs.push(allIdx);
            }
        }
        for (var i=0, len=idxs.length; i<len; i++) {
            var idx = idxs[i];
            if (sel[idx]){
                delete sel[idx];
                removed.push(idx);
                if ( selectedItems ) {
                    delete selectedItems[me.items[idx][idf]];
                }
                if (me.selectedIndex == idx) {
                    me.selectedIndex = -1;
                    me.selectedItem = null;
                }
            }
        }
        return removed;
    }
    
    
    function _raise( me,  added,  removed,  idxs) {
        if (me.raiseEvent) {
        	
        	
        	me.raiseEvent({
        		name: 'select',
        		idxs: idxs || []
        	});
        	
            if ((added && added.length) || (removed && removed.length)) {
                try {
                    me.raiseEvent({
                        name: 'selectionChange',
                        added: added,
                        removed: removed
                    });
                } catch (ex) {
                    
                    _rmv(me, added);
                    _add(me, removed);
                    
                    throw ex;
                }
        	}
        }
    }
    
    function indexOf(me, item) {
        if ( item == null ) {
            return -1;
        }
        var isObject = typeof(item) == 'object',
            idf = me.itemIdField;
        if (isObject && idf != null) {
            return $ARR.find(me.items, idf, item[idf]);
        } else  {
            return $ARR.indexOf(me.items, item);
        }
    } 
    
        
    mstrmojo._ListSelections = {

            multiSelect: false,
            
            allIdx : -1,
            
            items: null,
            
            selectedIndices: null,
            
            
            selectedIndex: -1,

            
            selectedIndices_bindEvents: "selectionChange",
            selectedIndex_bindEvents: "selectionChange",
            
            
            selectedItem: null,
            
            selectedItem_bindEvts: "selectionChange",
            

            
            allowUnlistedValues: true,
            
            
            selectedItems: null,

            
            supportsIncFetch: false,
            
            
            init: function( props) {
                this._super(props);
                
                
                if ( this.supportsIncFetch && this.itemIdField ) {
                    this.selectedItems = {};
                }
                if ( ! this.items ) {
                    this.items = [];
                }
                if (!this.selectedIndices) {
                    this.selectedIndices = {};
                    if (this.selectedIndex>-1) {
                        this._set_selectedIndex("selectedIndex", this.selectedIndex, true);
                    } else if (this.selectedItem) {
                        this._set_selectedItem("selectedItem", this.selectedItem, true);
                    }
                }
            },
            
            
            addItems: function addItems(newItems) {
                if ( ! newItems  ) {
                    return;
                }
                if (newItems.constructor != Array) {
                    newItems = [newItems];
                }
                var items = this.items,
                    start = this.items.length,
                    selectedItems = this.selectedItems,
                    newSelected = [], 
                    end; 
                
                items = this.items = items.concat(newItems); 
                end = items.length;

                
                
                if ( selectedItems ) {
                    var selectedIndices = this.selectedIndices,
                        idf = this.itemIdField,
                        i, item;
                    for ( i = start; i < items.length; i++ ) {
                        item = items[i];
                        if ( selectedItems[item[idf]] ) {
                            newSelected.push(i);
                        } 
                    }
                }
                
                if (newSelected && newSelected.length) { 
                    _add(this, newSelected); 
                }
                
                if ( end > start) {
                    this.itemsContainerNode.innerHTML += this._buildItemsMarkup(start, end - 1).join('');
                }
            },
            
            
            addSelectedItems: function addSelectedItems(newSelections) {
                this.selectItems(newSelections, false);
            },
            
            setSelectedItems: function setSelectedItems(newSelections) {
                this.selectItems(newSelections, true);
            },
            
            
            selectItems: function selectItems(newSelections, clearPrevSelections) {
                if ( ! newSelections ) {
                    return;
                }
                if (newSelections.constructor != Array) {
                    newSelections = [newSelections];
                }

                var me = this;
                
                
                if ( clearPrevSelections && me.selectedItems ) {
                    me.selectedItems = {};
                }
                
                var selectedItems = me.selectedItems,
                    idf = me.itemIdField,
                    item, idx, i,
                    addedItems = [], 
                    addedIdx = me.items.length, 
                    newSelectedIndices = [], 
                    allowUnlistedValues = me.allowUnlistedValues;
                
                for ( i = 0; i < newSelections.length; i++ ) {
                    item = newSelections[i];
                    idx = indexOf(this, item);
                    
                    
                    if (idx === -1 ) {
                        
                        if ( selectedItems === null ) {
                            
                            if ( allowUnlistedValues) {
                                
                                addedItems.push(v);
                                idx = addedIdx++;
                            }
                        } else {
                            
                            
                            selectedItems[item[idf]] = item;
                        }
                    } 
                    
                    
                    if ( idx !== -1) {
                        newSelectedIndices.push(idx);
                    }
                }
                
                
                if ( addedItems.length > 0 ) {
                    me.addItems(addedItems);
                }
                
                
                if ( newSelectedIndices.length > 0 ) {
                    if ( clearPrevSelections ) {
                        me.select(newSelectedIndices);
                    } else {
                        me.addSelect(newSelectedIndices);
                    }
                }
            },

            unselectItems: function selectItems(items) {
                if ( ! items ) {
                    return;
                }
                if (items.constructor != Array) {
                    items = [items];
                }

                var me = this,
                    selectedItems = me.selectedItems,
                    unselectedIndices = [],
                    idf = me.itemIdField,
                    item, idx, i;
                if ( selectedItems === null ) {
                    return;
                }
                for ( i = 0; i < items.length; i++ ) {
                    item = items[i];
                    
                    
                    if ( selectedItems ) {
                        delete selectedItems[item[idf]];
                    }

                    idx = indexOf(this, item);
                    
                    if ( idx !== -1) {
                        unselectedIndices.push(idx);
                    }
                }
                
                if ( unselectedIndices.length > 0 ) {
                    me.removeSelect(unselectedIndices);
                }
            },
            
            
            getSelectedItems: function getSelectedItems() {
                
                
                if ( this.selectedItems != null ) {
                    return $HASH.valarray(this.selectedItems);
                } else {
                    return $ARR.get(this.items, $HASH.keyarray(this.selectedIndices, true));
                }
            },
            
            
            singleSelect: function(idx, suppressEvt){
                if (idx !== -1) {
                    this.select([idx], suppressEvt);
                }
            },
            
            
            singleSelectByField: function singleSelectByField(value, fieldName, suppressEvt) {
                this.singleSelect($ARR.find(this.items, fieldName, value), suppressEvt);
            },
            
            
            toggleSelect: function( idx) {
                var add, rmv;
                if (this.selectedIndices[idx]) { 
                    rmv = _rmv(this, [idx]);
                } else {
                    add = _add(this, [idx]);
                }
                _raise(this, add, rmv, [idx]);
            },
            
            rangeSelect: function(idx) {
                 
            },
            
            select: function (idxs,  bSuppressEvt){
                if (idxs == null) return;
                if (idxs.constructor != Array) {
                    idxs = [idxs];
                }

                var rmv = _rmvAll(this),
                    add = _add(this, idxs),
                    i = rmv.length - 1;

                
                if (this.selectionPolicy !== 'reselect') {
                    
                    for (; i >= 0 ; i--) {
                        
                        var ind = $ARR.indexOf(add, rmv[i]);
                        if (ind > -1){ 
                            
                            rmv.splice(i, 1);
                            add.splice(ind, 1);
                        }
                    }
                }
                
                
                if (!bSuppressEvt) {
                    
                    _raise(this, add, rmv, idxs);
                }
            },
            
            clearSelect: function( bSuppressEvt){
                var ret = _rmvAll(this);
                if (bSuppressEvt !== true) {
                    _raise(this, null, ret, []);
                }
            }, 
            
            addSelect: function( idxs,  bSuppressEvt) {
                if (idxs == null) {
                    return;
                }
                if (idxs.constructor != Array) {
                    idxs = [idxs];
                }
                var ret = _add(this, idxs);
                
                var rmv = null,
                    noneIdx = this.noneIdx;
                
                if(this.multiSelect && (noneIdx > -1 && $ARR.indexOf(idxs, noneIdx) > -1)) {
                    rmv = _rmv(this,idxs);
                }
                
                if (bSuppressEvt !== true) {
                    _raise(this, ret, rmv, idxs);
                }
            },
            
            removeSelect: function( idxs) {
                if (idxs == null) {
                    return;
                }
                if (idxs.constructor != Array) {
                    idxs = [idxs];
                }
                 _raise(this, null, _rmv(this, idxs), idxs);
            },
            
            
            _set_selectedIndices: function(n, v,  bSuppressEvt) {
                var me = this, 
                    sel = me.selectedIndices;
                
                
                if ( me.selectedItems ) {
                    me.selectedItems = {};
                }
                var sel = me.selectedIndices;
                if (sel == v) {
                    return false;
                }

                if (!sel) {
                    sel = {};
                    me.selectedIndices = sel;
                }
                
                if (!v) {
                    v = {};
                }
                
                
                var sidx = me.selectedIndex,
                    rmv = [],
                    idx;
                for (idx in sel) {
                    if (!v[idx]) {
                        idx = parseInt(idx,10);
                        delete sel[idx];
                        rmv.push(idx);
                        if (sidx == idx) {
                            me.selectedIndex = -1;
                            me.selectedItem = null;
                        }
                    }
                }
                
                var add = [],
                    itms = me.items,
                    idf = me.itemIdField,
                    item;
                for (idx in v) {
                    if (!sel[idx]) {
                        idx = parseInt(idx,10);
                        sel[idx] = true;
                        add.push(idx);
                        me.selectedIndex = idx;
                        item = me.selectedItem = itms[idx];
                        if ( me.selectedItems ) {
                            me.selectedItems[item[idf]] = item;
                        }
                    }
                }
                
                if (bSuppressEvt !== true) {
                	var idxs = [];
                	for (idx in v) {
                		if (sel[idx]) {
                			idx = parseInt(idx, 10);
                			idxs.push(idx);
                		}
                	}
                    _raise(me, add, rmv, idxs);
                }

                return (add.length || rmv.length);    
            },
            
            
            _set_selectedIndex: function(n, v,  bSuppressEvt){
                var idxs = {};
                if (v >-1) {
                    idxs[v] = true;
                }
                return this._set_selectedIndices("selectedIndices", idxs, bSuppressEvt);
            },
            
            
            _set_selectedItem: function(n, v,  bSuppressEvt){
                
                
                var idx = indexOf(this, v);
                if ((idx === -1) && (v != null) && this.allowUnlistedValues && this.items) {
                    
                    
                    
                    this.set('items', this.items.concat(v));
                    idx = this.items.length - 1;
                }
                return this._set_selectedIndex("selectedIndex", idx, bSuppressEvt);
            }
            
        };
})();

(function(){

	mstrmojo.requiresCls("mstrmojo.array");
	
    
    mstrmojo._HasBuilder = 
        
        {
            
            postBuildRendering: function postBldRndr() {
                if (!this.builtChildren) {
                    this.buildChildren();
                }
                return this._super();
            },

            getChildren: function getChildren(){
                return this.model.getChildren(this.node, false);
            },
            
                        
            buildChildren: function bldChdn(noAddChildren) {
                if (!this.builder || !this.model) {
                    return false;
                }

                
                
                if (this.children && this.children.length) {
                    this.set("children", []);
                }
                
                
                var m = this.model,
                    children = this.builder.build(
                        this.getChildren(),
                        m,
                        this.buildConfig
                );
                
                
                if (!noAddChildren) {
                    
                    this.addChildren(children);
                }
                
                
                this.builtChildren = true;
                
                
                return (noAddChildren) ? children : true;
            }            
    };
    
})();
(function(){
    mstrmojo.requiresCls("mstrmojo.array");
    
    mstrmojo.requiresDescs(4891);
    var _A = mstrmojo.array,
        ELEM_ALL_ID = 'u;',
        ELEM_DUMMY_ID = '-1';
    
    
    mstrmojo.elementHelper = mstrmojo.provide(
        "mstrmojo.elementHelper",
        {
            
            
            buildElemsTerseID: function buildElemsTerseID(elems, attrId, delDN) {
                var item;
                for (var i in elems) {
                    item = elems[i];
                    if (item.v) {
                        var vs = item.v.split(';');
                        if (vs && vs.length > 1) {
                            vs[1] = attrId;
                            
                            
                            if (delDN && vs.length > 2) {
                                vs.pop();
                            }
                            item.v = vs.join(';');
                        }
                    }
                }
                
                return elems;
            },
            
            buildElemsCountStr: function buildElemsCountStr(ces, elems) {
                if (!ces || !ces.length || !elems || !elems.length) {
                    return '';
                }
                
                var sc = ces.length, 
                    tc = elems.length;
                
                
                if (_A.find(elems, 'v', ELEM_ALL_ID) > -1) {
                    tc -= 1;
                }
                
                if (_A.find(elems, 'v', ELEM_DUMMY_ID) > -1) {
                    tc -= 1; 
                }
                
                
                if (_A.find(ces, 'v', ELEM_ALL_ID) > -1 || _A.indexOf(ces, ELEM_ALL_ID) > -1) {
                    sc = tc;
                }
                
                
                if (sc >= tc) {
                    return '(' + tc + ')';
                } else {
                	
                    return mstrmojo.desc('4891').replace('##', sc).replace('###', tc);
                }
            }               
        });
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.android.EnumMenuOptions");

    var $MENUS = mstrmojo.android.EnumMenuOptions,
        TRANSACTIONS_QUEUE = $MENUS.TRANSACTIONS_QUEUE;

    
    function getTransactionNotificationController() {
        return mstrApp.getTransactionNotificationController();
    }

    
    function isDocumentController() {
        return (!this.hsc && (this.st === 14081));
    }

    
    mstrmojo.android.controllers._SupportsQueuedTransactions = mstrmojo.provide(

        "mstrmojo.android.controllers._SupportsQueuedTransactions",

        {
            _mixinName: "mstrmojo.android.controllers._SupportsQueuedTransactions",

            
            getTxnToolbarButton: function getTxnToolbarButton(tbCfg) {
                
                var txController = getTransactionNotificationController();

                
                
                
                if (txController && txController.hasTransactionQueue((isDocumentController.call(this)) ? this.did : null)) { 
                    tbCfg.addToolbarBtn(TRANSACTIONS_QUEUE, mstrmojo.desc(9262, 'Transactions Queue'), TRANSACTIONS_QUEUE, true, 18);
                }

                return tbCfg;
            },

            handleMenuItem: function handleMenuItem(group, cmdId) {
                
                if (group === TRANSACTIONS_QUEUE) {
                    
                    var did,
                        title;

                    
                    if (isDocumentController.call(this)) {
                        did = this.did;
                        title = this.ttl;
                    }

                    
                    getTransactionNotificationController().showNotificationBoard(this, did, title);
                } else {
                    this._super(group, cmdId);
                }
            }
        }
    );
}());
(function() {
    
    mstrmojo.requiresCls("mstrmojo.EnumReadystate");
    

    var $RS = mstrmojo.EnumReadystate;    
    
    
    function getViewKey(view) {
        return (view.getKey && view.getKey()) || view.k;
    }
    
    mstrmojo._IsDocController = {
        _mixinName: 'mstrmojo._IsDocController',
        
        _getXtabCallback: function (xtab) {
            var targetDefinitions = {},
                defn = targetDefinitions[getViewKey(xtab)] = xtab.defn,
                me = this,
                model = me.model;

            return model.newCallback({
                submission: function () {
                	
                	if ( defn.set ) {
                		defn.set('readyState', $RS.WAITING);
                	}
                },
                
                success: function (res) {
                	if(res.pukeys) {
                        targetDefinitions = model.getUnitDefinitions(res.pukeys);
                    }
                    model.partialUpdate(res.data, targetDefinitions);
                },
                
                failure: function (details) {
                    mstrmojo.alert(details.code + ': ' + details.message);
                },
                
                complete: function () {
                	
                	if ( defn.set ) {
                		defn.set('readyState', $RS.IDLE);
                	}
                    me.docRequestComplete();
                }
            });
        },
    
        _addNodeKeyToAction: function (view, action) {
            action.nodeKey = getViewKey(view);
            return action;
        },
        
        onGridSelector: function (view, action) {
        	var m = this.model,
        		ifws = m.getTargetInfoWin(action.tks);
        	if (ifws && ifws.length) {
        		for (var i = 0;i < ifws.length;i++) {
        			m.showInfoWin(ifws[i], action.anchor, 'h', true);
        		}
        	}
        	
            
            action.sid = view.sid;
            m.slice(action);
        },
        
         onVisSelector: function (view, action){
        	 if (action.anchor) {
        		var m = this.model,
      			ifws = m.getTargetInfoWin(action.tks);
	 	     	if (ifws && ifws.length) {
	 	     		m.showInfoWin(ifws[0], action.anchor, 'h', true);
	 	     	} 
        	 }
        	
	     	
        	if (view.xtabModel && view.xtabModel.docModel && view.xtabModel.docModel["slice"] ) {
				view.xtabModel.docModel.slice(action);
			}
        },
        
        
        
        isInRequest: function isInRequest() {
        	var inProcess = !!this._inProcess;
        	if (!inProcess) {
        		this._inProcess = true;
        	}
        	
        	return inProcess;
        },
        
        docRequestComplete: function docRequestComplete() {
        	this._inProcess = false;
        },

        
        nudgeWidget: mstrmojo.emptyFn,

        
        getGroupByElements: function getGroupByElements(w) {
            var gbelems = [],
                keys;
            
            while (w ) {
                var keys = w.node && w.node.data && w.node.data.pbes;
                if ( keys ) {
                    break;
                }
                w = w.parent;
            }
            
            if (keys) {
                var dataElems = this.model.data.elems;
                
                for (var i = 0, len = keys.length; i < len; i++) {
                    var idx = keys[i];
                    gbelems.push(isNaN(idx) ? idx : dataElems && dataElems[idx]);
                }
            }
            
            return gbelems;
        }
        
        
    };
    
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.EnumReadystate");

    var $READYSTATE = mstrmojo.EnumReadystate;

    
    var DELAY = 1200;

    
    var fnToggle = function (v, w) {
        if (w) {
            w.style.display = (v) ? 'block' : 'none';
        }
    };

    
    mstrmojo._HasWaitIcon =
        
        {
            
            waitHandle: null,

            
            postBuildRendering: function pstBldRndr() {
                
                if (!this._rsl) {
                    var id = this.id;
                    this._rsl = this.defn.attachEventListener('readyStateChange', id, function (evt) {
                        
                        if (!this.hasRendered) {
                            
                            return;
                        }

                        switch (evt.value) {
                        case $READYSTATE.WAITING:
                            
                            if (!this.waitIcon) {
                                
                                var icon = document.createElement('div');
                                icon.className = 'mojo-overlay-wait'; 

                                
                                icon.innerHTML = '<div class="overlay"></div><div class="icon"></div>';

                                
                                this.domNode.appendChild(icon);

                                
                                this.addSlots({
                                    waitIcon: icon
                                });
                            }

                            
                            var wi = this.waitIcon;

                            
                            if (DELAY) {
                                
                                this.waitHandle = window.setTimeout(function () {
                                    
                                    if (mstrmojo.all[id]) {
                                        mstrmojo.all[id].waitHandle = null;
                                    }

                                    
                                    fnToggle(true, wi);
                                }, DELAY);

                            } else {
                                
                                fnToggle(true, wi);

                            }
                            break;

                        case $READYSTATE.IDLE:
                            
                            if (this.waitHandle) {
                                
                                window.clearTimeout(this.waitHandle);
                                this.waitHandle = null;
                            }

                            
                            fnToggle(false, this.waitIcon);
                            break;
                        }
                    });
                }

                return this._super();
            }
        };
}());


(function(){

    mstrmojo.requiresCls( "mstrmojo.storage.DOMStorage" );

    var LOCAL_STORAGE_DATA_FORMAT_VERSION = 4;

    
    mstrmojo.storage.DOMLocalStorage = mstrmojo.declare(mstrmojo.storage.DOMStorage, null, 
             
        {
            scriptClass : "mstrmojo.storage.DOMLocalStorage",
        
                
            
             
            init : function(props) {
                this._super(props);
                
                
                
                try {
                    this.mIsSupported = ('localStorage' in window) && (window['localStorage'] !== null);        
                    this.mStorageObj = this.mIsSupported ? window.localStorage : null;

                    this.checkVersion(LOCAL_STORAGE_DATA_FORMAT_VERSION);                

                } catch (e) {
                    
                    this.mIsSupported = false;
                }
            }
        });

    
    $LS = mstrmojo.global.localStore = new mstrmojo.storage.DOMLocalStorage({ itemTimeToLive: (3600 * 24) });

})();
(function(){
 
    mstrmojo.requiresCls("mstrmojo.locales", "mstrmojo.string");
    
    var _L = mstrmojo.locales,
        _S = mstrmojo.string,
        _G = window.mstrConfig,
        
        
        
        getThousand = function(){ return mstrmojo.locales.number.THOUSANDSEPARATOR;},
        getDecimal = function(){ return mstrmojo.locales.number.DECIMALSEPARATOR;}, 
        _unit = _G.units,
        UNIT = {
            CM: 1,
            IN: 2,
            MM: 3,
            PT: 4,
            PC: 5,
            PX: 6
        },
        CAT = {
            DEFAULT: -2,
            FIXED: 0,
            CURR: 1,
            PERCENT: 4,
            FRACTION : 5,
            SCIENTIFIC: 6,
            GENERAL: 9
        };
  
    
    var DPI_CONVERSION = 96;
    
    String.prototype.reverse = function() {
        var res = "";
        for (var i = this.length; i > 0; --i) {
            res += this.charAt(i - 1);
        }
        return res;
    };    
    
    
    
    mstrmojo.num = mstrmojo.provide(
            "mstrmojo.num",
            {
                
                isInt: function isInt(v){
                    var thousand = getThousand(),
                        INT_THOUSAND = new RegExp('^(\-)?[0-9]{1,3}(\\' + thousand + '[0-9]{3})*$'),
                        INT_NO_THOUSAND = new RegExp('^(\-)?[0-9]+$');
                    
                    return (String(v).indexOf(thousand) && INT_THOUSAND.test(v)) || INT_NO_THOUSAND.test(v);
                }, 
                
                
                isNumeric: function isNumeric(v,noDG){
                    
                   var decimal = getDecimal(),
                       thousand = getThousand(),
                       NUMERIC_THOUSAND = new RegExp('^(\-)?[0-9]{1,3}(\\' + thousand + '[0-9]{3})*(\\' + decimal + '[0-9]+)?$'),
                       NUMERIC_NO_THOUSAND = new RegExp('^(\-)?[0-9]*(\\' + decimal + ')?[0-9]+$');
                   
                   return (String(v).indexOf(thousand) && NUMERIC_THOUSAND.test(v)) || NUMERIC_NO_THOUSAND.test(v);
                },
                
                
                parseInteger: function parseInteger(v, r){
                    if(!this.isInt(v)) return Number.NaN;
                    return parseInt(String(v).replace(getThousand(), ''),r);
                },
                
                
                parseNumeric: function parseNumeric(v){
                    
                    if(!this.isNumeric(v)) return Number.NaN;
                    return parseFloat(String(v).replace(getThousand(),'').replace(getDecimal(), '.'));
                },
                
                   
                inNumericRange: function inNumericRange(v,min,max){
                    v = this.parseNumeric(v);
                    max = (max != null) ? this.parseNumeric(String(max)) : Number.NaN;
                    min = (min != null) ? this.parseNumeric(String(min)) : Number.NaN;   
                    if(max != Number.NaN && (v > max || isNaN(v))) return 1;
                    if(min != Number.NaN && (v < min || isNaN(v))) return -1;
                    return 0;
                },
                
                
                
                convertToUSUnits: function(value, unit, doNotLocalize) {
                        var __result = value;

                        unit = unit || _unit; 
                        switch (parseInt(unit, 10)) {
                            case UNIT.CM:
                                __result = parseFloat(this.toString(value)) / 2.54 + '';
                                break;
                            case UNIT.MM:
                                __result = parseFloat(this.toString(value)) / 25.4 + '';
                                break;
                            case UNIT.PT:
                                __result = parseFloat(this.toString(value)) / 72 + '';
                                break;
                            case UNIT.PC:
                                __result = parseFloat(this.toString(value)) / 6 + '';
                                break;
                            case UNIT.PX:
                                __result = parseFloat(this.toString(value)) / DPI_CONVERSION + '';
                                break;
                        }
                        
                        return doNotLocalize ? __result : this.toLocaleString(__result);
                    },
                    
                    
                    convertToLocalUnits: function(value, unit, doNotLocalize) {
                        var __result;

                        unit = unit || _unit; 
                        switch (parseInt(unit, 10)) {
                        case  UNIT.CM:
                            __result = (parseFloat(this.toString(value)) * 2.5400).toFixed(4) + '';
                            break;
                        case UNIT.MM :
                            __result = (parseFloat(this.toString(value)) * 25.4000).toFixed(4) + '';
                            break;
                        case UNIT.PT:
                            __result = (parseFloat(this.toString(value)) * 72.0000).toFixed(4) + '';
                            break;
                        case UNIT.PC:
                            __result = (parseFloat(this.toString(value)) * 6.0000).toFixed(4) + '';
                            break;
                        case UNIT.PX:
                            __result = (parseFloat(this.toString(value)) * DPI_CONVERSION) + '';
                            break;
                        default:
                            __result = parseFloat(this.toString(value)).toFixed(4) + '';
                        }
                        
                        return doNotLocalize ? __result : this.toLocaleString(__result);
                    },

                    
                    convertUnits: function(unitFrom, unitTo, value) {
                        return this.convertToLocalUnits(unitTo, this.convertToUSUnits(unitFrom, value, true), true);
                    },
                    
                    
                    toLocaleString: function(value) {
                        return (value + '').replace(".", getDecimal());
                    },
                    
                    
                    toString: function(value, removeThousandsSeparator) {
                        if (removeThousandsSeparator === true) {
                            var regex = this.getThousandSepRegex();
                            if (regex) {
                             value = String(value).replace(regex,'');
                            }     
                         }
                        return String(value).replace(getDecimal(), ".");
                    },

                    getThousandSepRegex: function() {
                        if (this.thousandSeparatorRegex == null) {
                              this.thousandSeparatorRegex = new RegExp(getThousand().replace(/(\W){1}/g,'\\$1'), 'g');
                        }
                        return this.thousandSeparatorRegex;
                    },
                    
                    
                    addSeparators: function(val, ts) {
                        var _ts = ts;
                        if (ts == '.' || ts == '*' || ts == '\\') { _ts = '\\' + ts;}
                        return val.reverse().replace(/(\d{3})/g, "$1" + ts).reverse().replace(new RegExp('^(-)?'+ _ts), "$1");
                    },
                    
                    
                    format: function(category, decimalPlaces, curr, nm){
                        var pattern = '',
                        ds = (decimalPlaces > 0)? '.' : '',
                        zeros = [];
                        
                        curr = (curr)? curr: '';
                        
                        for (var i = 0; i < decimalPlaces; i ++) {zeros.push('0');}
                        zeros = zeros.join('');
                        
                        switch(category){
                        case CAT.PERCENT:
                            pattern = '0' + ds + zeros + '%';
                            break;
                        case CAT.SCIENTIFIC:
                            pattern = '0' + ds +zeros + 'E+00';
                            break;
                        default: 
                            pattern = '"' + curr + '"' + '#,##0' + ds +zeros;
                        }
                        return this.formatByMask(pattern, nm);
                    },
                    
                    
                    formatByMask: function(formatMask,nm){
                        var ptns = String(formatMask).split(';'),
                        result = '',
                        pattern = ptns[0],
                        ph = '\u00A4';
                        
                        if(isNaN(nm)){
                            return nm;
                         }
                        
                        var ePos = pattern.indexOf("E+"),
                            pPos = pattern.indexOf("%"),
                            cs = pattern.match(/\".*\"/),
                            fs = pattern.indexOf("?/?") > -1,
                            cat = (ePos != -1)? CAT.SCIENTIFIC : ( (pPos != -1)? CAT.PERCENT : ((cs)? CAT.CURR : fs ? CAT.FRACTION : CAT.FIXED)),
                            currMask = '',
                            negMask = '',
                            isNeg = false,
                            sNm = new String(nm),
                            nN = parseFloat(nm);
                        
                        
                        if(cs) {
                            currMask = pattern.replace(/\".*\"/, 
                                    cs[0].substring(1, cs[0].length -1)).replace(pattern.replace(cs[0], ''), ph);
                        }
                        
                        
                        if(nN<0){
                            sNm = sNm.substring(1, sNm.length);
                            nN = -nN,
                            isNeg = true;
                            if (ptns.length > 1) { 
                                var _ptns1 = ptns[1].replace(/\[.*\]/, ''); 
                                negMask = _ptns1.replace(ptns[0], ph); 
                            }
                        }
                       
                       
                       var negativeFormat = function(sNm, negMask) {
                           return (negMask)? negMask.replace(ph, sNm) :  '-' + sNm;
                       };
                       
                       if (cat == CAT.FRACTION) {
                           var i, 
                               j, 
                               minIndex, 
                               base = 10, 
                               output, 
                               intPart = 0,
                               v, 
                               currentMin, 
                               temp,
                               sepInt = false,
                               stemp;
                           
                           
                           if (formatMask.indexOf("# ") > -1){
                               sepInt = true;
                           }
                           
                           
                           for (i=5; i>0; i--){
                               stemp = "/";
                               for (j=0; j<i; j++){
                                   stemp +="?";
                               }
                               if (formatMask.indexOf(stemp) > -1){
                                   for (j=1;j<i;j++){
                                       base *= 10;
                                   }
                                   break;
                               }
                           }

                           if (sepInt){
                               intPart =  Number(Number(nN).toFixed(0));
                               nN -= intPart;
                           }

                           currentMin = base / 2;
                           minIndex = -1;
                           v = nN * base;
                           for (i = base; i>=2; i--){
                               temp = (v * i) / base;
                               temp = temp - Math.floor(temp);
                               temp = temp * base;

                               if (Math.abs(temp - base) < temp){
                                   temp = Math.abs(temp - base);
                               }
                               
                               temp = temp / i;
                               
                               if (temp < currentMin){
                                   currentMin = temp;
                                   minIndex = i;
                               }
                               else if ((temp == currentMin) && (temp == 0)){
                                   currentMin = temp;
                                   minIndex = i;
                               }
                           }

                           output = Math.round(minIndex * v / base);

                           for (i = minIndex; i>=2; i--){
                               if ((output % i == 0) && (minIndex % i == 0)){
                                   output = output / i;
                                   minIndex = minIndex / i;
                                   break;
                               }
                           }

                           if (minIndex == base){
                               minIndex = 1;
                               output = 0;
                           }
                           if (output == 0){
                               minIndex = 1;
                           }
                           if (output == minIndex){
                               if (sepInt){
                                   result = "" + (intPart + 1);
                               }else{
                                   result = "1";
                               }
                           }else if (sepInt && intPart >0){
                               result = intPart + " " + output + "/" + minIndex;
                           }else{
                               result = output + "/" + minIndex;
                           }
                           
                       }else if (cat == CAT.SCIENTIFIC) {
                           
                           var exp = Math.floor(Math.log(nN) / Math.LN10),
                           m = nN / Math.pow(10, exp),
                           beStr = pattern.substring(0, ePos),
                           dPos = beStr.indexOf('.');
                           
                           result += Number(m).toFixed((dPos != -1)? beStr.length - dPos - 1 : 0);
                           result = ((isNeg) ? negativeFormat(result, negMask) : result )+ 'E' + ((exp > 0)? '+': '') + exp;
                           
                       } else {
                           if(cat == CAT.PERCENT) {
                               pattern=pattern.substring(0,pattern.length - 1);
                               sNm= String(nN * 100);
                           }
                           
                         
                           var dPos = pattern.indexOf('.'),
                           dp = 0;
                           if (dPos != -1) {
                               var dpS = pattern.substr(dPos + 1 , pattern.length).match(/\d+/);
                               if (dpS && dpS.length > 0) {
                                   dp = dpS[0].length;
                               }
                           }
                           
                           result =  String(Number(parseFloat(sNm).toFixed(dp)));
                           
                           var nn = result.split('.');
                           
                           
                           var tsPos = pattern.match(/#.+##/);
                           if (tsPos !== null) {
                               nn[0] =  this.addSeparators(nn[0], getThousand());
                           }
                               
                            result =  nn.join(getDecimal());
                            
                           
                           if (cat == CAT.CURR) { result = currMask.replace(ph, result); }
                           
                           
                           if (cat == CAT.PERCENT) { result += '%'; }
                           
                           
                           if (isNeg) {  
                               result = negativeFormat(result, negMask);
                           }
                       }
                       
                       return result;
                    },
                    
                    
                    
                     generateUniqueID: function( keyLen ) {
                        var     chars="0123456789ABCDEF".split(''),
                                id = [];                        
                        for (var i = 0; i < keyLen; i++) {
                            id[i] = chars[0 | Math.random()*16];
                        }
                        return id.join('');
                     },
                     
                     countOfDecimals: function(v, decimalSep) {
                    	 var sV = String(v);
                    	 return sV.length - (sV.indexOf(decimalSep !== undefined? decimalSep : getDecimal()) + 1); 
                     }         
            });

 })();
(function() {

    mstrmojo.requiresCls("mstrmojo.array", "mstrmojo.locales");

    var _A = mstrmojo.array, MTP = mstrmojo.meta.TP, H = mstrmojo.hash, 
    _ET = {
        ANDOR : 14,
        MQ : 10,
        MC : 12,
        AQ : 2,
        AL : 6,
        AC : 9,
        AE : 5,
        F : 13,
        R : 21,
        B : 20,
        XML : 1
    }, _ETvals = {};
    for ( var k in _ET) {
        _ETvals[_ET[k]] = true;
    }

    
    var ET2TGT = {};
    ET2TGT[_ET.AQ] = 'a';
    ET2TGT[_ET.AL] = 'a';    
    ET2TGT[_ET.AC] = 'a';
    ET2TGT[_ET.AE] = 'a';
    ET2TGT[_ET.MQ] = 'm';
    ET2TGT[_ET.MC] = 'm';
    ET2TGT[_ET.F] = 'f';
    ET2TGT[_ET.R] = 'r';
    ET2TGT[_ET.XML] = 'p';

    
    var ET2C = {};
    ET2C[_ET.MQ] = [ 'not', 'm', 'fn', 'fnt', 'cs', 'dmy' ];
    ET2C[_ET.MC] = [ 'not', 'm', 'fn', 'fnt', 'm2', 'm3', 'p', 'dmy' ]; 
    ET2C[_ET.AE] = [ 'not', 'a', 'fn', 'es', 'a2', 'fm2', 'p']; 
    ET2C[_ET.AQ] = [ 'not', 'a', 'fm', 'fn', 'cs'];
    ET2C[_ET.AL] = [ 'not', 'a', 'fm', 'fn', 'cs'];    
    ET2C[_ET.AC] = [ 'not', 'a', 'fm', 'a2', 'fm2', 'a3', 'fm3', 'fn', 'cs'];
    ET2C[_ET.R] = [ 'not', 'r' ];
    ET2C[_ET.F] = [ 'not', 'f' ];
    ET2C[_ET.XML] = [ 'not', 'n', 'p' ]; 

    

    var _ET2FNS = {};
    _ET2FNS[_ET.MQ] = "METRIC_FNS";
    _ET2FNS[_ET.MC] = "METRIC_FNS";
    _ET2FNS[_ET.AQ] = "FORM_FNS";
    _ET2FNS[_ET.AL] = "FORM_FNS";    
    _ET2FNS[_ET.AC] = "FORM_FNS";
    _ET2FNS[_ET.AE] = "ELEM_FNS";

    var _TP = {
        FILTER : 1,
        REPORT : 3,        
        METRIC : 4,
        FOLDER : 8,        
        PROMPT : 10,
        FUNCTION: 11,
        ATTR : 12,
        FACT: 13,
        DIM:14,
        FORM : 21,
        ROLE: 43 
    }, _STP = {
        FILTER : 256,
        CUSTOMGROUP : 257,
        PROMPT : 2560,
        PROMPT_BOOLEAN : 2561,
        PROMPT_LONG : 2562,
        PROMPT_STRING : 2563,
        PROMPT_DOUBLE : 2564,
        PROMPT_DATE : 2565,
        PROMPT_OBJECTS : 2566,
        PROMPT_ELEMENTS : 2567,
        PROMPT_EXPRESSION : 2568,
        PROMPT_EXPRESSION_DRAFT : 2569,
        PROMPT_DIMTY : 2570,
        PROMPT_BIGDECIMAL : 2571,
        REPORT_GRID : 768,
        REPORT_GRAPH : 769,
        REPORT_ENGINE : 770,
        REPORT_TEXT : 771,
        REPORT_DATAMART : 772,
        REPORT_BASE : 773,
        REPORT_GRIDGRAPH : 774,
        REPORT_NONINTERACTIVE : 775,
        REPORT_CUBE : 776
    }, OBJKEY2TP = {
        a : _TP.ATTR,
        a2 : _TP.ATTR,
        m : _TP.METRIC,
        m2 : _TP.METRIC,
        r : _TP.REPORT,
        f : _TP.FILTER,
        p : _TP.PROMPT
    };

    
    var ET2TP = {};
    ET2TP[_ET.MQ] = _TP.METRIC;
    ET2TP[_ET.MC] = _TP.METRIC;
    ET2TP[_ET.AQ] = _TP.ATTR;
    ET2TP[_ET.AL] = _TP.ATTR;    
    ET2TP[_ET.AC] = _TP.ATTR;
    ET2TP[_ET.AE] = _TP.ATTR;
    ET2TP[_ET.F] = _TP.FILTER;
    ET2TP[_ET.R] = _TP.REPORT;

    
    
    
    
    var _funcTrans = function(funs){
            var len = funs.length,
            r = {};
            for (var i = 0; i < len; i ++){
                var f = funs[i];
                r[f.did] = f.n;
            }
            return r;
        },
        _tpTrans = function(funs){
            var len = funs.length;
            for (var i = 0; i < len; i ++){
                var fun = funs[i];
                if ('tp' in fun) {
                    fun.t = fun.tp;
                }
            }
            return funs;
        },
        _fnTrans = function(funs, t){
            var len = funs.length;
            for (var i = 0; i < len; i ++){
                var fun = funs[i];
                if ('tp' in fun) {
                    if (t) {
                        fun.t = t;
                    } else {
                        delete fun.t;
                    }
                }
            }
            return funs;
        },
        _arrRep = function(funs, desc){
            if (!desc) {
                desc = [];
            }
            
            desc.length = 0;
            for (var i = 0, len = funs.length; i < len; i ++){
                desc[i] = funs [i];
            }
            return desc;
        },
        FORM_PROHIBITED = {
            0: [ 
                 {
                     'did' :'1,76'
                 }, {
                     'did' :'1,79'
                 }, {
                     'did' :'1,77'
                 }, {
                     'did' :'1,80'
                 }, {
                     'did' :'1,78'
                 }, {
                     'did' :'1,81'
                 }, {
                     'did' :'1,18'
                 }, {
                     'did' :'1,43'
                 } ],
            1: [ 
                 {
                     'did' :'2,1'
                 }, {
                     'did' :'2,2'
                 }, {
                     'did' :'3,1'
                 }, {
                     'did' :'3,2'
                 }]
            
        };
        METRIC_PROHIBITED = {
                0:[
                       {
                           'did':'1,22'
                       },{
                            'did':'1,57'
                        }
                  ]
        };
       

    
    mstrmojo.expr = mstrmojo.provide("mstrmojo.expr",
    
    {
        
        ET : _ET,

        ETs : _ETvals,

        ET2TGT : ET2TGT,

        ET2COND : ET2C,

        ET2TP : ET2TP,

        
        FN : {
            EQUAL: 6,
            NOT_EQUAL: 7,
            GREATER: 8,
            LESS: 9,
            GREATER_EQUAL: 10,
            LESS_EQUAL: 11,
            IN_LIST : 22,
            NOT_IN_LIST : 57,
            BETWEEN : 17,
            NOT_BETWEEN : 44,
            IS_NULL : 54,
            IS_NOT_NULL : 55,
            AND : 19,
            OR : 20,
            NOT : 21
        },

        
        FNT : {
            DEF : 1,
            RANK : 2,
            PER : 3
        },

        
        FN_SEP : ",",

        
        TP : _TP,

        
        STP : _STP,

        
        DMY_TP : {
            ATTR : -1,
            DIM : -2
        },

        
        DTP : {
            UNKNOWN : -1,
            INTEGER : 1,
            UNSIGNED : 2,
            NUMERIC : 3,
            DECIMAL : 4,
            REAL : 5,
            DOUBLE : 6,
            FLOAT : 7,
            CHAR : 8,
            VARCHAR : 9,
            LONGVARCHAR : 10,
            BINARY : 11,
            VARBIN : 12,
            LONGVARBIN : 13,
            DATE : 14,
            TIME : 15,
            TIMESTAMP : 16,
            SHORT : 21,
            LONG : 22,
            MBCHAR : 23,
            BOOLEAN : 24,
            PATTERN : 25,
            BIGDECIMAL : 30
        },

        
        METRIC_DTP : 3, 

        
        FN_DTP : {
            NUM : 0,
            CHAR : 1,
            DATE : 2
        },

        
        DTP2PROMPT_STP : {
            "-1" : _STP.PROMPT,
            1 : _STP.PROMPT_LONG,
            2 : _STP.PROMPT_LONG,
            3 : _STP.PROMPT_LONG,
            4 : _STP.PROMPT_DOUBLE,
            5 : _STP.PROMPT_DOUBLE,
            6 : _STP.PROMPT_DOUBLE,
            7 : _STP.PROMPT_DOUBLE,
            8 : _STP.PROMPT_STRING,
            9 : _STP.PROMPT_STRING,
            10 : _STP.PROMPT_STRING,
            14 : _STP.PROMPT_DATE,
            15 : _STP.PROMPT_DATE,
            16 : _STP.PROMPT_DATE,
            21 : _STP.PROMPT_LONG,
            22 : _STP.PROMPT_LONG,
            23 : _STP.PROMPT_STRING,
            24 : _STP.PROMPT_BOOLEAN,
            30 : _STP.PROMPT_BIGDECIMAL
        },

        
        DTP2FN_DTP : {
            "-1" : 0,
            1 : 0,
            2 : 0,
            3 : 0,
            4 : 0,
            5 : 0,
            6 : 0,
            7 : 0,
            8 : 1,
            9 : 1,
            10 : 1,
            11 : 0,
            12 : 0,
            13 : 0,
            14 : 0, 
            15 : 0, 
            16 : 0, 
            21 : 0,
            22 : 0,
            23 : 1,
            24 : 0,
            25 : 1,
            30 : 0
        },
        
        fnCstCount : function fcc(fn, fnt) {
                
            var f = this.FN;
            switch (fn) {
            case f.BETWEEN: 
            case f.NOT_BETWEEN: 
                return 2;
            case f.IS_NULL: 
            case f.IS_NOT_NULL: 
                return 0;
            default:
                return 1;
            }
            
            
        },

        
        fn_List: function fn_List(fn, fnt){
            var f = this.FN;
            return fn == f.IN_LIST || fn == f.NOT_IN_LIST;
        },
        
        
        fn_AC_MC: function fn_AC_MC(fn, fnt){
            var f = this.FN;
            return (fn == f.EQUAL) || (fn == f.NOT_EQUAL) || (fn == f.GREATER) || (fn == f.LESS) || (fn == f.GREATER_EQUAL) || (fn == f.LESS_EQUAL);      
        },
        
        
        
        fnName : function fnn(et, fn, fnt, dtp) {
            var arr = this[_ET2FNS[et]];
            if (arr && arr.constructor === Object) {
                arr = arr[this.DTP2FN_DTP[dtp]] || arr["*"];
            }
            var i = _A.find(arr, "did", (fnt || 1) + this.FN_SEP + fn);
            if (i > -1) {
                return arr[i].n;
            }
            return '';
        },

    
        
        findTargets : function fndT(nd, idField, h) {
            if (!h) {
                h = {};
            }
            if (nd) {
                
                for ( var k in OBJKEY2TP) {
                    var t = nd[k];
                    if (t) {
                        if (!t[MTP]) { 
                            t[MTP] = OBJKEY2TP[k]; 
                        }
                        h[t[idField]] = t;
                    }
                }
        
                if (nd.dmy) {
                    var A = this.TP.ATTR, DA = this.DMY_TP.ATTR, uts = nd.dmy.uts;
                    for ( var u = 0, uLen = (uts && uts.length) || 0; u < uLen; u++) {
                        var ut = uts[u];
                        if (ut && ut.utp === DA) {
                            var dt = ut.utgt;
                            if (!dt.t) {
                                dt.t = A;
                            }
                            h[dt[idField]] = dt;
                        }
                    }
                }

                
                var ch = nd.nds, i, len;
                for ( i = 0, len = (ch && ch.length) || 0; i < len; i++) {
                    this.findTargets(ch[i], idField, h);
                }
                var cs = nd.cs,
                    clen = cs && cs.length;
                if (clen){
                    for (i = 0; i < clen; i ++){
                        this.findTargets(cs[i], idField, h);
                    }
                }
            }
            return h;
        },
        onLocaleUpdated : function() {
            var _STRS = mstrmojo.locales.expression,
                _E = mstrmojo.expr;
        
            _E.BRANCH_FNS = H.copy(_funcTrans(_STRS.BranchQual), _E.BRANCH_FNS); 
        
    
        
            _E.ELEM_FNS = _arrRep(_fnTrans(_STRS.Element, 'fn'), _E.ELEM_FNS); 
            
    
            
            _E.METRIC_FNS = {
                "*" : _fnTrans(_A.filter(_STRS.Metric, function(item){
                        return item.did && (_A.find(METRIC_PROHIBITED['0'], 'did', item.did) < 0);}))
                    
            };
            
            _E.FORM_FNS = {
                0 : 
                    _fnTrans(_A.filter(_STRS.Attribute, function(item){
                        return item.did && (_A.find(FORM_PROHIBITED['0'], 'did', item.did) < 0);})),
                1 : 
                    _fnTrans(_A.filter(_STRS.Attribute, function(item){
                        return item.did && (_A.find(FORM_PROHIBITED['1'], 'did', item.did) < 0);})),
                2 : 
                    _fnTrans(_A.filter(_STRS.Attribute, function(item){
                        return item.did && (_A.find(FORM_PROHIBITED['0'], 'did', item.did) < 0) && (_A.find(FORM_PROHIBITED['1'], 'did', item.did) < 0);}))
                    
                    
            };
    
            _E.DIMTYLEVELS = _arrRep(_fnTrans(_STRS.DimtyLevels), _E.DIMTYLEVELS) ;
                
        }
    });
    
    mstrmojo.expr.onLocaleUpdated();

})();
(function(){
 
    mstrmojo.requiresCls("mstrmojo.locales");
    
    var _DT = function(){return mstrmojo.locales.datetime;},
        $S = mstrmojo.string;

    
    mstrmojo.date = mstrmojo.provide(
            "mstrmojo.date",
            {
    			monthNumbers : {
					Jan:1,
					Feb:2,
					Mar:3,
					Apr:4,
					May:5,
					Jun:6,
					Jul:7,
					Aug:8,
					Sep:9,
					Oct:10,
					Nov:11,
					Dec:12
				},
				
                REGEXPS: {
                    DATES: {},  
                    TIMES: {}   
                },
                
                CACHE: {
                    PARSEDATE: {
                        CONTAINS: {},
                        EQUALS: {}
                    },
                    PARSETIME: {
                        CONTAINS: {},
                        EQUALS: {}
                    }
                }, 
                
                
                isDate: function isDate( s,  bFormat,  bContains) {
                    
                    var dateInfo = this.parseDate(s, bContains);
                    
                    var isValid = !!(dateInfo && this.doesDateExist(dateInfo.month, dateInfo.day, dateInfo.year));
                    if (bFormat) {
                        if (isValid) {
                            var formatted = this.formatDateInfo(dateInfo, _DT().DATEOUTPUTFORMAT);
                            if (bContains) {
                                return {match: dateInfo.match, formatted: formatted};
                            } else {
                                return formatted;
                            }
                        } else {
                            return null;
                        }
            
                    } else {
                        return !!isValid;
                    }
                },
                
                
                formatDateInfo: function formatDateInfo( dateInfo,  format) {
                    if (!format) return '';
                    var day = dateInfo.day,
                        month = dateInfo.month,
                        year = dateInfo.year;
                    
                    var s = format.replace(/dd/g, this.formatInteger(day, 2)
                                    ).replace(/d/g, Number(day)
                                    ).replace(/yyyy/g, Number(year)
                                    ).replace(/yy/g, this.formatInteger(Number(year) % 100, 2)
                                    ).replace(/MMM/g, "~~~~"
                                    ).replace(/MM/g, "@@"
                                    ).replace(/M/g, "^"
                                    ).replace(/MMMM/g, _DT().MONTHNAME_FULL[Number(month) - 1]
                                    ).replace(/\~\~\~\~/g, _DT().MONTHNAME_SHORT[Number(month) - 1]
                                    ).replace(/\@\@/g, this.formatInteger(month, 2)
                                    ).replace(/\^/g, Number(dateInfo.month)
                                    );
                    return s;
                },
                
                
                
                parseDate: function parseDate( s,  bContains,  format) {
                    if (s == null) return false;
                    if (typeof(s) != 'string') s = String(s);
                    s = $S.trim(s);
                    
                    
                    
                    var cache = this.CACHE.PARSEDATE[bContains ? "CONTAINS" : "EQUALS"],
                        cachedResult = cache[s];
                    if (cachedResult || (cachedResult === null)) return cachedResult;       
                    
                    var parseResult = null;
            
                    
                    var formats;
                    if (format){
                    	formats = [format];
                    }else{
                    	formats = [].concat(_DT().DATEINPUTFORMATS);
                    	formats.unshift(_DT().DATEOUTPUTFORMAT);
                    }
            
                    
                    for (var i = 0, len = formats.length; i < len; i++) {       
                        
                        var reInfo = this._buildRegExp4DateFormat(formats[i]),
                        
                            result = reInfo && s.match(bContains ? reInfo.reContains : reInfo.reEquals);
                        if (result) {
                            
                            parseResult = {
                                match: result[0],
                                year: reInfo.yearIndex && this.fourDigitYear(result[reInfo.yearIndex]),
                                day: reInfo.dayIndex && parseInt(Number(result[reInfo.dayIndex])),
                                month: reInfo.monthIndex && this.numericMonth(result[reInfo.monthIndex])
                            };
                            break;
                        }
                    } 
                    
                    cache[s] = parseResult;
                    return parseResult;
                },
            
                
                isTime: function isTime( s,  bFormat,  bContains) {
                    
                    var timeInfo = this.parseTime(s, bContains);
                    
                    var isValid = !!(timeInfo && this.doesTimeExist(timeInfo.hour, timeInfo.min, timeInfo.sec));
                    if (bFormat) {
                        if (isValid) {
                            var formatted = this.formatTimeInfo(timeInfo, _DT().TIMEOUTPUTFORMAT);
                            if (bContains) {
                                return {match: timeInfo.match, formatted: formatted};
                            } else {
                                return formatted;
                            }
                        } else {
                            return null;
                        }
                    } else {
                        return !!isValid;
                    }
                },
                
                
                parseTime: function parseTime( s,  bContains, format) {
                    if (s == null) return false;
                    if (typeof(s) != 'string') s = String(s);
                    s = $S.trim(s);
                    
                    
                    
                    var cache = this.CACHE.PARSETIME[bContains ? "CONTAINS" : "EQUALS"],
                        cachedResult = cache[s];
                    if (cachedResult || (cachedResult === null)) return cachedResult;       
                    
                    var parseResult = null;
            
                    
                    var formats;
                    if (format){
                    	formats = [format];
                    }else{
                    	formats = [].concat(_DT().TIMEINPUTFORMATS);
                    	formats.unshift(_DT().TIMEOUTPUTFORMAT);
                    }
            
                    
                    for (var i = 0, len = formats.length; i < len; i++) {       
                        
                        var reInfo = this._buildRegExp4TimeFormat(formats[i]),
                        
                            result = reInfo && s.match(bContains ? reInfo.reContains : reInfo.reEquals);
                        if (result) {
                            
                            var ampm = reInfo.ampmIndex && result[reInfo.ampmIndex];
                            parseResult = {
                                match: result[0],
                                
                                hour: reInfo.hourIndex && this.capitalHour(result[reInfo.hourIndex], ampm),
                                min: reInfo.minIndex && parseInt(Number(result[reInfo.minIndex])),
                                sec: reInfo.secIndex && parseInt(Number(result[reInfo.secIndex]))
                            };
                            break;
                        }
                    } 
                    
                    cache[s] = parseResult;
                    return parseResult;
                },
                
                
                formatTimeInfo: function formatTimeInfo( timeInfo,  format) {
                    if (!format) return '';
                    var twelveHour = !(Number(timeInfo.hour) % 12) ? 12 : (Number(timeInfo.hour) % 12),
                        s = format.replace(/HH/g, this.formatInteger(timeInfo.hour, 2)
                                    ).replace(/H/g, Number(timeInfo.hour)
                                    ).replace(/hh/g, this.formatInteger(twelveHour, 2)
                                    ).replace(/h/g, twelveHour
                                    ).replace(/mm/g, this.formatInteger(Number(timeInfo.min) || 0, 2)
                                    ).replace(/m/g, Number(timeInfo.min) || 0
                                    ).replace(/ss/g, this.formatInteger(Number(timeInfo.sec) || 0, 2)
                                    ).replace(/s/g, Number(timeInfo.sec) || 0
                                    ).replace(/a/g, (Number(timeInfo.hour) < 12) ? _DT().AM_NAME : _DT().PM_NAME
                                    );
                    return s;
                },

                
                doesTimeExist: function doesTimeExst( capitalHour,  min,  sec) {
                    var h = parseInt(capitalHour);
                    if (h >= 0 && h <= 23) {
                        var m = parseInt(min);
                        if (m >= 0 && m <= 59) {
                            if (!sec) return true;
                            var s = parseInt(sec);
                            if (s >= 0 && s <= 59) return true;
                        }
                    }
                    return false;
                },
                
                
                
                capitalHour: function capitalHour( hour,  ampm) {
                    
                    
                    
                    hour = parseInt(Number(hour));
                    if (ampm && (ampm.match(_DT().AM_NAME) || ampm.match(/AM/i))) {
                        
                        return hour % 12;
                    } else if (ampm && (ampm.match(_DT().PM_NAME) || ampm.match(/PM/i))) {
                        
                        return 12 + (hour % 12);
                    } else {
                        
                        
                        return hour;
                    }
                },
                
                
                isDateAndOrTime: function isDateAndOrTime( s,  bFormat) {
                    return this.isDateTime(s, bFormat)
                            || this.isDate(s, bFormat)
                            || this.isTime(s, bFormat);
                },
                
                
                isDateTime: function isDateTime( s,  bFormat) {
                    
                    
                    var dateTimeInfo = this.parseDateAndOrTime(s),
                        dateInfo = dateTimeInfo && dateTimeInfo.date,
                        timeInfo = dateTimeInfo && dateTimeInfo.time,
                        isValid = !!dateInfo 
                                    && !!timeInfo
                                    && this.doesDateExist(dateInfo.month, dateInfo.day, dateInfo.year)
                                    && this.doesTimeExist(timeInfo.hour, timeInfo.min, timeInfo.sec);
                    
                    if (bFormat) {
                        
                        if (isValid) {
                            
                            var formattedDate = this.formatDateInfo(dateInfo, _DT().DATEOUTPUTFORMAT),
                                formattedTime = this.formatTimeInfo(timeInfo, _DT().TIMEOUTPUTFORMAT),
                                dateIndex = s.indexOf(dateInfo.match),
                                timeIndex = s.indexOf(timeInfo.match);
                            return (timeIndex < dateIndex) ?
                                    formattedTime + ' ' + formattedDate :
                                    formattedDate + ' ' + formattedTime;
                                
                        } else {
                            return null;
                        }
                    } else {
                        
                        return !!isValid;
                    }
                },
                
                

                
                parseDateAndOrTime: function parseDateAndOrTime( s,  dateFormat, timeFormat) {
                    
                    var dateInfo = this.parseDate(s, true, dateFormat);
                    
                    
                    var sWithoutDate = $S.trim((dateInfo && dateInfo.match) ? 
                                            s.replace(dateInfo.match, "") :
                                            s),
                        timeInfo = this.parseTime(sWithoutDate, false, timeFormat); 
                        
                    
                    if (!dateInfo && !timeInfo) {
                        return null;
                    } else {
                        
                        return {
                            date: dateInfo,
                            time: timeInfo
                            };
                    }
                },
                
                
                inDateTimeRange: function inDateTimeRange(val, min, max) {
                    
                    var valInfo = this.parseDateAndOrTime(val),
                        valDateInfo = valInfo && valInfo.date,
                        valTimeInfo = valInfo && valInfo.time;
                    
                    if (!valDateInfo && !valTimeInfo) return 0;
                    
                    
                    if (min != null) {
                        
                        var minInfo = this.parseDateAndOrTime(min);
                        
                        if (valDateInfo && minInfo && minInfo.date) {
                            var minDiff = this.compareDate(valDateInfo, minInfo.date);
                            if (minDiff < 0) {
                                
                                return -1;
                            } else if (minDiff == 0)  {
                                
                                
                                if (valTimeInfo && minInfo.time
                                    && (this.compareTime(valTimeInfo, minInfo.time) < 0))
                                {
                                    
                                    return -1;
                                } 
                            } 
                        } 
                    } 
            
                    
                    if (max != null) {
                        
                        var maxInfo = this.parseDateAndOrTime(max);
                        
                        if (valDateInfo && maxInfo && maxInfo.date) {
                            var maxDiff = this.compareDate(valDateInfo, maxInfo.date);
                            if (maxDiff > 0) {
                                
                                return 1;
                            } else if (maxDiff == 0) {
                                
                                
                                if (valTimeInfo && maxInfo.time
                                    && (this.compareTime(valTimeInfo, maxInfo.time) > 0))
                                {
                                    
                                    return 1;
                                } 
                            } 
                        } 
                    } 
                    return 0;
                },
                
                
                 
                compareDate: function compareDate( val1,  val2) {
                    if (val1 == val2) return 0;
                    var date1 = typeof(val1) == 'string' ? this.parseDate(val1) : val1,
                        date2 = typeof(val2) == 'string' ? this.parseDate(val2) : val2;
                    if (!date1) return -1;
                    if (!date2) return 1;
                    return (date1.year - date2.year)
                                || (date1.month - date2.month)
                                || (date1.day - date2.day)
                                || 0;
                },
                
                 
                compareTime: function compareTime( val1,  val2) {
                    if (val1 == val2) return 0;
                    var time1 = typeof(val1) == 'string' ? this.parseTime(val1) : val1,
                        time2 = typeof(val2) == 'string' ? this.parseTime(val2) : val2;
                    if (!time1) return -1;
                    if (!time2) return 1;
                    return (time1.hour - time2.hour)
                                || (time1.min - time2.min)
                                || (time1.sec - time2.sec)
                                || 0;
                },
            
                 
                compareDateTime: function compareDateTime( val1,  val2) {
                    return this.compareDate(val1, val2) || this.compareTime(val1, val2);
                },
                
                compareDateAndOrTime: function compareDateAndOrTime( val1,  val2) {
                	if (val1 == val2) return 0;
                	var dt1 = typeof(val1) == 'string' ? this.parseDateAndOrTime(val1) : val1,
                		dt2 = typeof(val2) == 'string' ? this.parseDateAndOrTime(val2) : val2;
                	
                	if (!dt1) return -1;
                	if (!dt2) return 1;
                		
                	var d1 = dt1.date, d2 = dt2.date, t1 = dt1.time, t2 = dt2.time;
                	return this.compareDate(d1, d2) || this.compareTime(t1, t2); 
                },
                
                
                _buildRegExp4DateFormat: function re4DateFmt( formatStr) {
                
                    if (!formatStr) return null;
                    
                    var reInfo = this.REGEXPS.DATES[formatStr];
                    if (!reInfo) {
                        
                        if (!this.REGEXPS.MONTHNAME_FULL) {
                            this.REGEXPS.MONTHNAME_FULL = _DT().MONTHNAME_FULL.join("|");
                            this.REGEXPS.MONTHNAME_SHORT = _DT().MONTHNAME_SHORT.join("|");
                        }
                        
                        reInfo = this.REGEXPS.DATES[formatStr] = {};
                        
                        reInfo.formatStr = formatStr;
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        var reStr = reInfo.reStr = formatStr.replace(/([^M|d|y|\s])/g, "\\$1"
                                        ).replace(/dd/g, "~~~~" 
                                        ).replace(/d/g, "(\\d{1,2})"
                                        ).replace(/\~\~\~\~/g, "(\\d\\d)"   
                                        ).replace(/yyyy/g, "(\\d\\d\\d\\d)"
                                        ).replace(/yy/g, "(\\d\\d)"
                                        ).replace(/MMMM/g, "@@@@"
                                        ).replace(/MMM/g, "@@@"
                                        ).replace(/MM/g, "(\\d\\d)"
                                        ).replace(/M/g, "(\\d{1,2})"
                                        ).replace("@@@@","(" + this.REGEXPS.MONTHNAME_FULL + ")"
                                        ).replace("@@@", "(" + this.REGEXPS.MONTHNAME_SHORT + ")");
                        
                        
                        reInfo.reEquals = new RegExp("^" + reStr + "$");
                        reInfo.reContains = new RegExp("^" + reStr + "\\b");
                        
                        
                        
                        
                        
                        var indices = [
                            {key: "monthIndex", index: formatStr.indexOf("M")},
                            {key: "dayIndex", index: formatStr.indexOf("d")},
                            {key: "yearIndex", index: formatStr.indexOf("y")}
                            ];
                        indices.sort(function(a, b) { return a.index - b.index });
                        var counter = 1;
                        for (var i = 0; i < 3; i++) {
                            reInfo[indices[i].key] = indices[i].index > -1 ?
                                                        counter++ : null;
                        }   
                    }
                    return reInfo;
                },
            
                
                _buildRegExp4TimeFormat: function re4TimeFmt( formatStr) {
                
                    if (!formatStr) return null;
                    
                    var reInfo = this.REGEXPS.TIMES[formatStr];
                    if (!reInfo) {
                        
                        if (!this.REGEXPSTR_AMPM) {
                            
                            this.REGEXPSTR_AMPM = [_DT().AM_NAME, 
                                                _DT().PM_NAME,
                                                String(_DT().AM_NAME).toLowerCase(),
                                                String(_DT().PM_NAME).toLowerCase()
                                                ].join("|");
                        }
                        
                        reInfo = this.REGEXPS.TIMES[formatStr] = {};
                        
                        reInfo.formatStr = formatStr;
                        
                        
                        
                        
                        var reStr = formatStr.replace(/\'\'/g, '"');
                        
                        
                        
                        var literals = reStr.match(/\'(.+?)\'/g);
                        reStr.replace(/\'(.+?)\'/g, '*');
                        
                        
                        
                        reStr = reStr.replace(/([^H|h|m|s|z|Z|a|\s])/g, "\\$1"
                                        ).replace(/HH|hh/g, "(\\d\\d)"
                                        ).replace(/H|h/g, "(\\d{1,2})"
                                        ).replace(/mm/g, "(\\d\\d)"
                                        ).replace(/m/g, "(\\d{1,2})"
                                        ).replace(/ss/g, "(\\d\\d)"
                                        ).replace(/s/g, "(\\d{1,2})"
                                        ).replace(/a/gi, "(" + this.REGEXPSTR_AMPM + ")"
                                        ).replace(/z|Z/g, "(.+?)");
                        
                        for (var i = 1, len = literals && literals.length || 0; i < len; i++) {
                            reStr = reStr.replace(/\*/, literals[i]);
                        }
                        
                        reStr = reStr.replace(/\"/g, "'");
                        
                        
                        
                        
                        reInfo.reEquals = new RegExp("^" + reStr + "$");
                        reInfo.reContains = new RegExp(reStr);
                        
                        
                        
                        
                        
                        var indices = [
                            {key: "hourIndex", index: formatStr.search(/h|H/)},
                            {key: "minIndex", index: formatStr.indexOf("m")},
                            {key: "secIndex", index: formatStr.indexOf("s")},
                            {key: "ampmIndex", index: formatStr.indexOf("a")},
                            {key: "zoneIndex", index: formatStr.search(/z|Z/)}
                            ];
                        indices.sort(function(a, b) { return a.index - b.index });
                        var counter = 1;
                        for (var i = 0; i < 5; i++) {
                            reInfo[indices[i].key] = indices[i].index > -1 ? 
                                                        counter++ : null;
                        }   
                    }
                    return reInfo;
                },
                
                
                doesDateExist: function doesDateExist( month,  day,  year) {
                    var dt = new Date(year, month - 1, day);

                    return year == dt.getFullYear() &&
                           month == dt.getMonth() + 1 &&
                           day == dt.getDate();
                },
            
                
                fourDigitYear: function fourDigitYear( year) {
                    year = parseInt(Number(year));
                    if (!isNaN(year)) {
                        var twoDigitStart = (_DT().TWODIGITYEARSTART  % 100) || 0;   
                        if (year >= 0 && year <= twoDigitStart) 
                            year = 2000 + year; 
                        else if (year > twoDigitStart && year < 100)
                            year = 1900 + year;
                    }
                    return year;
                },
                
                
                numericMonth: function numMonth( month) {
                    
                    var monthInt = parseInt(Number(month)),
                        _A = mstrmojo.array;
                    if (!isNaN(monthInt)) return monthInt;
                    
                    
                    
                    var len = month && month.length || 0,
                        index = -1;
                    if (len) {
                        
                        if (len <= 3) {
                            index = _A.indexOf(_DT().MONTHNAME_SHORT, month);
                        }
                        
                        if (index == -1) {
                            index = _A.indexOf(_DT().MONTHNAME_FULL, month);
                        }
                    }
                    return index + 1;
                },
                
                
                formatInteger: function fmtInt( num,  minLen) {
                    var s = String(num),
                        missing = Math.max(minLen - s.length, 0);
                    if (missing > 0) {
                        var arr = [s];
                        for (var i = 1; i <= missing; i++) {
                            arr.push("0");
                        }
                        s = arr.reverse().join('');
                    }
                    return s;
                },
                
                
                getFirstDateOfMonth: function(y,m){
                    return new Date(y, m-1, 1);
                },
                
                
                getDateObject: function(y,m,d,hh,mm,ss){
                    y = y || 0;
                    m = m || 1;
                    d = d || 1;
                    hh = hh || 0;
                    mm = mm || 0;
                    ss = ss || 0;
                    return new Date(y,m-1,d,hh,mm,ss);
                },
                
                
                getDateFromDateInfo: function (dateInfo) {
                    return this.getDateObject(
                                dateInfo.date && dateInfo.date.year,
                                dateInfo.date && dateInfo.date.month,
                                dateInfo.date && dateInfo.date.day,
                                dateInfo.time && dateInfo.time.hour,
                                dateInfo.time && dateInfo.time.min,
                                dateInfo.time && dateInfo.time.sec
                            );
                },
                
                
                getDateJson: function(date){
                    return {year:date.getFullYear(),month:date.getMonth() + 1,day:date.getDate(),
                            hour:date.getHours(),min:date.getMinutes(),sec:date.getSeconds()};
                },
                
                
                isLeapYear: function(y) {
                    return !(y%400) || (!(y%4) && !!(y%100));
                },
                
                
                getDaysOfMonth: function(y,m){
                    var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                    if(m == 2 && this.isLeapYear(y)){ return 29; } 
                    return days[m - 1];     
                },
                
                
                getPreMonth: function(y,m) {
                    if(m === 1) return {y:y-1, m:12};
                    return {y:y,m:m-1};
                },
                
                
                getNextMonth: function(y,m){
                    if(m === 12) return {y:y+1,m:1};
                    return {y:y,m:m+1};
                }              
                
            });

 })();
(function () {
    mstrmojo.requiresCls("mstrmojo.css",
                         "mstrmojo.hash",
                         "mstrmojo.string",
                         "mstrmojo.DICFactory");

    var TX_ELEM_TEXTFIELD = 3,


        FIELDGROUP = 2,
        DATA_DRIVEN_CONTROL = 2,
        $CSS = mstrmojo.css,
        MASK = '********',
        $H = mstrmojo.hash;

    var tf_formatHandlers = null;

    
    function setDirtyFlag(c, d) {
        if (c) {
            
            var dicWidget = this.dicWidget;
            if (dicWidget && dicWidget.setDirtyFlag) {
                
                dicWidget.setDirtyFlag(c, d);

            
            } else if (c.className !== 'flag-container') {
                var f = document.createElement('div');
                f.className = 'flag-container';
                f.style.right = '10px';
                f.innerHTML = '<div class="dirty-cell"/>';
                d.insertBefore(f, c);
            }
        }
    }

    
    mstrmojo._IsEditableTextfield = {
        _mixinName: "mstrmojo._IsEditableTextfield",

        preBuildRendering: function preBldRnd() {
            if (!this.edb) {
                var d = this.node.data,
                    defn = this.node.defn,
                    di = d.dic || defn.txi.dic,
                    rv = (this.rv === '') ? this.value : this.rv; 

                
                if (di.psw) {
                    this.v = MASK;
                    rv = this.rv = '';
                }

                if (di.ipt === DATA_DRIVEN_CONTROL) {
                    di.vls = this.vls || []; 
                    this.dk = di.k;
                }

                this.req = di.req;
                this.dt = di.dt;

                this.dicWidget = mstrmojo.DICFactory.createDIC({dic: di, owner: this, k: 0, dv: this.value, value: rv, openerType: FIELDGROUP, popupTitle: defn.n});

                if (this.shouldReplaceValueNode()) {
                    
                    if (!tf_formatHandlers) {
                        tf_formatHandlers = $H.clone(this.formatHandlers);
                    }

                    this.formatHandlers.domNode = ['T', 'z-index', 'D', 'B', 'F', 'P', 'text-align', 'background-color', 'fx', 'white-space', 'overflow'];
                    
                    delete this.formatHandlers.valueNode;
                }
            }

            this.set('cssClass', this.edb ? '' : 'editable-field');

            this._super();
        },

        shouldReplaceValueNode: function shouldReplaceValueNode() {
            return this.dicWidget.showByDefault || this.dicWidget.hasPreview;
        },

        postBuildRendering: function pstBldRnd() {
            this._super();

            if (this.edb) {
                return;
            }

            var w = this.dicWidget,
                text = this.valueNode.innerHTML;

            
            if (mstrmojo.string.isEmpty(text)) {
                this.valueNode.innerHTML = text + '1';
                this.valueNode.style.height = this.valueNode.clientHeight + 'px';
                this.valueNode.innerHTML = text;
            }

            if (w.showByDefault) {
                w.render();
            } else {
                if (w.hasPreview) {
                    
                    w.openerNode = this.domNode;
                    
                    w.renderPreview(this.value);
                } else {
                    w.openerNode = this.valueNode;
                }

                mstrmojo.dom.attachEvent(w.openerNode, mstrApp.isMobile ? mstrmojo.dom.TOUCHEND : 'click', function () {
                    w.showInPopup();
                });
            }

            
            if (this.shouldReplaceValueNode()) {
                $H.copy(tf_formatHandlers, this.formatHandlers);
            }

            this.registerTxWidget();

            
            this.addToTraversalList();

            if (this.mdf && this.sci) {
                var domNode = this.domNode;
                setDirtyFlag.call(this, domNode.firstChild, domNode);
            }
        },

        getKeyContext: function getKeyContext() {
            return {
                dt: this.dt || 0,
                k: this.dk || undefined
            };
        },

        getUpdates: function getUpdates() {
            var udv = this.getUpdatedValues()[0],
                k = udv.k ? ('rw_control_key="' + udv.k + '" element_id="' + this.vls[mstrmojo.array.find(this.vls, 'v', udv.v)].eid + '" ') : '';
            return '<rwf rw_tree_type="' + this.tt + '" rw_node_key="' + this.fgk + '" rw_field_key="' + this.k + '" key="' + this.key + '" columns="' + this.cls + '" types="' + TX_ELEM_TEXTFIELD + '" ' + k + 'value="' + mstrmojo.string.encodeXMLAttribute(String(udv.v)) + '" dt="' + udv.dt + '" />';
        },

        updateValue: function updateValue(idx, vo) {
            if (this._super) {
                this._super(idx, vo);
            }

            var t = this.valueNode,
                d = this.domNode,
                w = this.dicWidget,
                v = vo.v,
                dv = vo.dv;

            if (this.rv !== v) {
                if (this.req) {
                    $CSS.removeClass(d, 'required');
                }

                this.rv = v;
                this.v = dv;
                this.mdf = 1;

                if (!w.showByDefault) {
                    if (w.hasPreview) {
                        w.renderPreview();
                    } else {
                        t[t.innerText !== undefined ? 'innerText' : 'textContent'] = this.psw ? MASK : dv;
                    }
                }

                if (this.req) {
                    $CSS.removeClass(d, 'required');
                }

                if (this.sci) {
                    setDirtyFlag.call(this, d.firstChild, d);
                }
            }

            
            
            return false;
        },

        applyPasswordMask: function applyPasswordMask() {
            this.psw = true;
            this.v = MASK;
            this.rv = '';
        },

        
        getUpdateObject: function getUpdateObject() {
            var changedObj = {
                    fieldKey: this.k,
                    wid: this.wid, 
                    newValue: mstrmojo.string.encodeXMLAttribute(String(this.rv)),
                    dataType: this.dt
                },
                udv = this.getUpdatedValues()[0];

            if (udv.k !== undefined) {
                changedObj.controlKey = udv.k;
                changedObj.elementId = this.vls[mstrmojo.array.find(this.vls, 'v', udv.v)].eid;
            }

            return {
                nodeKey: this.fgk,
                cells: [changedObj],
                retrieveData: false, 
                
                autoRefresh: false
            };
        },

        update: function update(node) {
            if (this._super) {
                this._super(node);
            }
            var d = node.data,
                df = node.defn;

            if (d.vls) {
                this.vls = d.vls;
            } else {
                delete this.vls;
            }

            this.cell = node.data;
            
            this.value = d.v || '';
            
            this.rv = (d.rv === undefined) ? this.value : d.rv;
            this.tca = d.tca || 0;
            this.dt = d.dt;
            this.key = d.key || ''; 
            this.cls = d.cls || ''; 
            this.wid = d.wid;

            this.edb = d.edb;

            
            this.mdf = d.mdf;
            this.req = d.req;

            
            this.sci = df.txi.sci;
            this.tt = df.tt;
            this.fgk = df.fgk;
        },

        
        addToTraversalList: function addToTraversalList() {
            if (mstrmojo.DICConfig.isKeyNavigable(this.dicWidget.dic)) {
                var traversalList = this.parent.traversalList,
                    dom = this.domNode;

                if (!traversalList) {
                    traversalList = this.parent.traversalList = [];
                }

                traversalList.push({
                    x: dom.offsetLeft,
                    y: dom.offsetTop,
                    h: dom.offsetHeight,
                    refField: this
                });
            }
        },

        
        editNext: function editNext() {
            var traversalList = this.parent.traversalList,
                i,
                len,
                avgHeight,
                sumHeight = 0;

            if (!traversalList) {
                return false;
            }

            
            if (!traversalList.isSorted) {

                
                for (i = 0, len = traversalList.length; i < len; i++) {
                    sumHeight += traversalList[i].h;
                }
                avgHeight = sumHeight / len;

                
                traversalList.sort(function (a, b) {
                    
                    var r1 = Math.floor(a.y / avgHeight),
                        r2 = Math.floor(b.y / avgHeight);

                    if (r1 < r2) { 
                        return -1;
                    }

                    if (r1 > r2) {
                        return 1;
                    }

                    if (a.x < b.x) { 
                        return -1;
                    }

                    if (a.x > b.x) {
                        return 1;
                    }

                    return (a.y < b.y) ? -1 : 1; 
                });
                
                traversalList.isSorted = true;
            }

            
            for (i = 0, len = traversalList.length; i < len; i++) {
                if (traversalList[i].refField.k === this.k) {
                    break;
                }
            }

            if (i < len) {
                do {
                    i++;
                    if (i >= len) {
                        i %= len;
                    }
                    if (i === parseInt(this.k, 10)) {
                        return false;
                    }

                    
                    var dicWidget = traversalList[i].refField.dicWidget;
                    if (dicWidget) {
                        if (!dicWidget.showByDefault) {
                            dicWidget.showInPopup();
                        } else {
                            
                            dicWidget.focus();
                        }
                        return true;
                    }
                } while (true);
            }
            
        },

        
        checkRequiredObjects: function checkRequiredObjects() {
            
            if (this.req && !this.mdf && !this.edb) {
                $CSS.addClass(this.domNode, 'required');
                return false;
            }
            return true;
        }
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.publisher");

    var $P = mstrmojo.publisher;

    
    mstrmojo._Provider = mstrmojo.provide(

        "mstrmojo._Provider",

        
        {
            
            _meta_usesSuper: false,

            
            audibles: {"*": true},

            
            set: function set(n, v) {
                
                var bChanged = false,
                    f = this["_set_" + n],
                    vWas = this[n];    

                if (f) {
                    
                    bChanged = f.apply(this, arguments);
                } else {
                    
                    this[n] = v;
                    bChanged = (vWas !== v);
                }

                
                if (bChanged) {
                    
                    
                    var evtName = n + "Change",
                        aud = this.audibles || {},
                        isAudible =  (aud[n] === true) || ((aud[n] !== false) && (aud["*"] !== false));

                    if (isAudible && (this['pre' + evtName] || this['on' + evtName] || this['post' + evtName] || $P.hasSubs(this.id, evtName))) {
                        
                        
                        this.raiseEvent({
                            name: evtName,
                            prop: n,
                            value: v,
                            valueWas: vWas
                        });
                    }
                }
                return this;
            },

            
            raiseEvent: function rse(evt) {
                var n = evt && evt.name;
                if (!n) {
                    return null;
                }
                
                evt.src = this;

                
                if (this.preHandleEvent) {
                    this.preHandleEvent(evt);
                }

                
                var ns = ['pre', 'on', 'post'],
                    abort = false,
                    i,
                    len;

                for (i = 0, len = ns.length; i < len; i++) {
                    var fn = ns[i] + n;
                    if (this[fn]) {
                        if (this[fn](evt) === false) {
                            abort = true;
                            break;
                        }
                    }
                }

                
                if (!abort) {
                    
                    if (this.postHandleEvent) {
                        this.postHandleEvent(evt);
                    }
                    
                    $P.publish(this.id, n, evt);
                }

                return evt;
            },

            
            

            
            

            
            attachEventListener: function att(name, listener, callback) {
                return $P.subscribe(this.id, name, callback, listener);
            },

            
            detachEventListener: function det(sub) {
                $P.unsubscribe(sub);
            },

            
            destroy: function destroy() {
                
                $P.clearSubscriptions(this.id);
                
                if (this._super) {
                    this._super();
                }
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.registry",
                         "mstrmojo.array",
                         "mstrmojo.publisher");

    var _R = mstrmojo.registry,
        _A = mstrmojo.array,
        _P = mstrmojo.publisher;

    
    function _preAdd(p, c) {
        if (c) {
            c.parent = p;
            return _R.ref(c);
        }
        return null;
    }

    
    function _postAdd(p, c) {
        if (c && c.alias != null) { 
            p[c.alias] = c;
        }
    }

    
    function _postRmv(p, c) {
        var a = c.alias;
        if (c.parent === p) {
            delete c.parent;
        }
        if ((a != null) && (p[a] === c)) {  
            delete p[a];
        }
    }

    
    function makeCh(p, refs) {
        var len = refs && refs.length,
            ch,
            i;

        if (len) {
            ch = [];
            for (i = 0; i < len; i++) {
                var c = _preAdd(p, refs[i]);
                if (!c) {
                    continue;
                }
                ch.push(c);
                _postAdd(p, c);
            }
        }
        return ch;
    }

    
    mstrmojo._HasChildren = mstrmojo.provide(

        "mstrmojo._HasChildren",

        
        {
            
            _meta_usesSuper: false,

            
            

            
            

            
            initChildren: function initChildren() {
                var C = "children",
                    c = this[C];

                if (!c) {
                    return;
                }

                
                this[C] = null;
                this._set_children(C, c, true);

                
                if (this.postCreateChildren) {
                    this.postCreateChildren();
                }
            },

            
            _set_children: function setCh(n, v, silent) {
                var ch = this.children;
                if (v !== ch) {
                    if (ch) {
                        
                        this.removeChildren(null, silent);
                    }
                    this.addChildren(v, 0, silent);
                }
                return false;
            },

            
            destroyChildren: function dstCh(meDestroying) {
                var ch = this.children,
                    len = (ch && ch.length) || 0,
                    i;
                if (len) {
                    for (i = len - 1; i > -1; i--) {
                        var c = ch[i];
                        if (c && c.destroy) {
                            c.destroy(meDestroying);
                            if (!meDestroying) {
                                _postRmv(this, c);
                            }
                        }
                    }
                    if (!meDestroying) {
                        ch.length = 0;
                    }
                }
            },

            invalidateChildren: function invalidateChildren() {
                mstrmojo.array.forEach(this.children, function (child) {
                    child.invalidate();
                });
            },

            invalidate: function invalidate() {
                this.invalidateChildren();
            },

            
            addChildren: function addCh(c, idx, silent) {
                if (!c) {
                    return c;
                }
                
                var isArr = c.constructor === Array,
                    arr = makeCh(this, isArr ? c : [c]);

                if (arr && arr.length) {
                    
                    var ch = this.children || [];
                    if (idx == null) {  
                        idx = ch.length;
                    }
                    this.children = _A.insert(ch, idx, arr);

                    
                    if (!silent && (this.onaddChild || _P.hasSubs(this.id, "addChild"))) {
                        this.raiseEvent({
                            name: "addChild",
                            value: arr,
                            index: idx
                        });
                    }
                }
                return isArr ? arr : (arr && arr[0]);
            },

            
            removeChildren: function rmCh(c, silent) {
                var ch = this.children,
                    c2r = c ? [c] : (this.children || []).concat(),
                    len = c2r.length,
                    idx = -1,
                    i;

                if (len) {
                    for (i = len - 1; i > -1; i--) {
                        _postRmv(this, c2r[i]);
                    }

                    if (c) {
                        idx = _A.removeItem(ch, c);
                    } else if (ch) {
                        ch.length = 0;
                        idx = 0;
                    }

                    
                    if (!silent && (this.onremoveChild || _P.hasSubs(this.id, "removeChild"))) {
                        this.raiseEvent({
                            name: "removeChild",
                            value: c2r,
                            index: idx
                        });
                    }
                }
                return idx;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.css",
                         "mstrmojo.dom");

    var $DOM = mstrmojo.dom,
        $POS = $DOM.position,
        $MTH = Math;

    
    function getCloneInfo(key, srcNode, isMultiLine) {
        var ellCollection = this._ellTestNodes || {},               
            info = ellCollection[key],                              
            compStyle = mstrmojo.css.getComputedStyle(srcNode),     
            dimensions = [ 'width', 'height' ];                     

        
        if (isMultiLine) {
            
            dimensions.reverse();
        }

        
        var testDimension = dimensions[0],
            oppositeDimension = dimensions[1];

        
        if (!info || !$DOM.contains(this.domNode, info.n, true, document.body)) {
            
            var node = srcNode.cloneNode(true);

            
            node.removeAttribute('id');
            node.removeAttribute('onclick');

            
            var nodeStyle = node.style;
            nodeStyle.position = 'absolute';                        
            nodeStyle.top = '-10000px';                             
            nodeStyle.maxHeight = nodeStyle.maxWidth = 'none';      
            nodeStyle[testDimension] = 'auto';                      

            
            srcNode.parentNode.appendChild(node);

            
            var max = parseInt(compStyle['max-' + testDimension], 10);

            
            if (isNaN(max)) {
                
                max = parseInt(compStyle[testDimension], 10);
            }

            
            info = ellCollection[key] = {
                n: node,                                            
                m: max,                                             
                d: testDimension.substr(0, 1)                       
            };

            
            this._ellTestNodes = ellCollection;

        } else {
            
            info.n.innerHTML = srcNode.innerHTML;

        }

        
        info.n.style[oppositeDimension] = compStyle[oppositeDimension];

        
        return info;
    }

    
    function addEllipsis(textArray, length) {
        var ellipsisText = this.ellipsisText;
        switch (this.ellipsisPosition) {
        case 'middle':
            
            var mid = $MTH.floor(length / 2);
            return textArray.slice(0, mid).join('') + ellipsisText + textArray.slice(-mid).join('');

        case 'end':
            
            return textArray.slice(0, length).join('') + ellipsisText;

        default:
            return textArray.join('');
        }
    }

    var COMPARE_THRESHOLD = 4;

    
    mstrmojo._SupportsEllipsisText = mstrmojo.provide(

        "mstrmojo._SupportsEllipsisText",

        
        {
            _mixinName: 'mstrmojo._SupportsEllipsisText',

            
            ellipsisText: '&hellip;',

            
            ellipsisPosition: 'end',

            
            ellipsize: function ellipsize(key, element, isMultiLine) {
                
                var text = element.innerHTML;
                if (!text) {
                    
                    return false;
                }

                
                var info = getCloneInfo.call(this, key, element, isMultiLine),
                    fnTestFit = function () {
                        var cloneDimension = $POS(info.n)[info.d];
                        return (cloneDimension <= info.m);
                    };

                
                if (fnTestFit()) {
                    
                    return false;
                }

                
                var node = info.n,
                    textArray = text.split(''),
                    low = 0,
                    high = textArray.length,
                    ellipsizedText,
                    x;

                
                while (low < high) {
                    
                    var mid = $MTH.floor((low + high) / 2);

                    
                    text = node.innerHTML = addEllipsis.call(this, textArray, mid);

                    
                    if (fnTestFit()) {
                        
                        low = mid + 1;
                    } else {
                        
                        high = mid - 1;
                    }

                    
                    if (high - low < COMPARE_THRESHOLD) {
                        
                        
                        for (x = low - 1; x < high + 1; x++) {
                            
                            text = node.innerHTML = addEllipsis.call(this, textArray, x);

                            
                            if (!fnTestFit()) {
                                
                                break;
                            }

                            
                            ellipsizedText = text;
                        }
                    }

                    
                    if (ellipsizedText) {
                        
                        element.innerHTML = ellipsizedText;
                        break;
                    }
                }

                return true;
            },

            
            unrender: function unrender(ignoreDom) {
                
                delete this._ellTestNodes;

                this._super(ignoreDom);
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.string",
                         "mstrmojo.css");

    
    mstrmojo._HasDocLink = mstrmojo.provide(
        'mstrmojo._HasDocLink',

        
        {
            _mixinName: 'mstrmojo._HasDocLink',

            url: '',

            target: '',

            linkEnabled: true,

            ifw: '',

            
            update: function update(node) {
                var d = node.defn;

                
                this.url = node.data.url || d.url;

                
                if (d.target) {
                    
                    this.target = d.target;
                }

                if (d.ifw) {
                    this.ifw = d.ifw;
                }

                this._super(node);
            },

            

            postBuildRendering: function postBuildRendering() {
                
                if (this.url || this.ifw) {
                    
                    mstrmojo.css.addClass(this.domNode, 'hasLink');
                }

                
                var doc = this.controller.view,
                    layout = doc && doc.getCurrentLayout();
                if (layout && layout.addLinkInfo) {
                    layout.addLinkInfo(this.id, {
                        url: this.url,
                        target: this.target,
                        src: this
                    });
                }

                return this._super();
            },

            
            setLinkEnabled: function setLinkEnabled(value) {
                this.linkEnabled = value;
                var node = this.domNode;
                if (!node) {
                    return;
                }

                var childNodes = node.childNodes,
                    lastChild = childNodes[childNodes.length - 1],
                    maskId = this.id + '_mask',
                    mask = (lastChild.id === maskId) ? lastChild : null;

                if (value) {
                    if (mask) {
                        node.removeChild(mask);
                        delete this._mask;
                    }

                } else {
                    if (!mask) {
                        mask = document.createElement('div');
                        mask.className = 'mstrmojo-DocLinkMask';
                        mask.id = maskId;
                        mask.innerHTML = '&nbsp;';
                        node.appendChild(mask);
                    }
                }
            },

            onclick: function () {
                
                if (this.linkEnabled) {
                	var drillLinkItems = this.drillLinkItems,
                        defaultLink = drillLinkItems && drillLinkItems[0];
                        url = this.url || (defaultLink && defaultLink.url);

                    
                    if (this.ifw) {
                        this.model.showInfoWin(this.ifw, (this.getAnchor && this.getAnchor()) || this.domNode, 'v', true);

                    
                    } else if (url) {
                        this.model.executeLink(url, this.target, this);
                    }
                }
            }
        }
    );
}());
(function(){
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.css", "mstrmojo.array");
    
    var ROW_AXIS = 1, COL_AXIS = 2;
    
    
    function _isOfSameUnit(c1, c2){
        return _isOfSameTitle(c1, c2) && c1.o === c2.o;
    }
    
    
    function _isOfSameTitle(c1, c2){
        return c1 && c2 && c1.ui === c2.ui && c1.axis === c2.axis && c1.mix === c2.mix;
    }
    
    function _addToSelection(td, cell,  w){
        var ttlId = w.getCellTitleId(cell),
            idx = w.getCellUnitIndex(cell);
        w.selections[ttlId] = w.selections[ttlId] || {};
        w.selections[ttlId][idx] = w.selections[ttlId][idx] || [];
        w.selections[ttlId][idx].push(td);
        _hilite(td);
    }
    
    function _clearSelection( w){
        var sel = w.selections;
        for (var i in sel){
            for (var j in sel[i]){
                for (var k=0, len=sel[i][j].length;k<len;k++){
                    _unHilite(sel[i][j][k]);
                }
            }
        }
        w.selections = {};
    }
    
    function _hilite(td){
        mstrmojo.css.setOpacity(td, 50);
    }
    
    function _unHilite(td){
        mstrmojo.css.setOpacity(td, 100);
    }
    
    
    function _getFormCount(cell, w){
        
        if (cell.mix === undefined){
            var titles = w.gridData.gts[cell.axis === ROW_AXIS?'row':'col'],
                ttl = titles[cell.tui || cell.ui],
                count = 0;
            for (var i=0, len=titles.length;i<len;i++){
                
                if (titles[i].id === ttl.id){
                    count++;
                }
            }
            return count;
        }
        return 0;
    }
    
    mstrmojo._XtabSelections = 
        {
            
            lastSelectedTD: null,
            
            
            singleSelect: function singleSelect(td, toggle){
                var data = this.getCellForNode(td),
                    row = td.parentNode;
                
                
                if (toggle){
                    var ttlId =  this.getCellTitleId(data), 
                        idx = this.getCellUnitIndex(data);
                        selectedTitle = this.selections[ttlId];
                        selectedUnit = selectedTitle && selectedTitle[idx];
                    if (selectedUnit){
                        
                        for (var i = 0, len = selectedUnit.length; i < len; i++){
                            _unHilite(selectedUnit[i]);
                        }
                        delete selectedTitle[idx];
                        return;
                    }
                }
                
                
                var totalForms = _getFormCount(data, this);

                if (data.axis === ROW_AXIS) {
                    
                    for (var i = 0, formFound = 0, len = row.cells.length; i < len && formFound < totalForms; i++){
                        var tc = row.cells[i], tcData = this.getCellForNode(tc);
                        if (_isOfSameUnit(tcData, data)){
                            _addToSelection(tc, tcData, this);
                            formFound++;
                        }
                    }
                } else if (data.axis === COL_AXIS) {
                    var table = mstrmojo.dom.findAncestorByName(td, 'table', false),
                    rows = table.rows;
                    
                    for (var i = 0, formFound = 0, len = rows.length; i < len && formFound < totalForms; i++){
                        var cells = rows[i].cells;
                        
                        for (var j = 0, len2 = cells.length; j < len2; j++){
                            var tc = cells[j], tcData = this.getCellForNode(tc);
                            if (_isOfSameUnit(tcData, data)){
                                _addToSelection(tc, tcData, this);
                                formFound++;
                                break;
                            }
                        }
                    }
                } else { 
                    _addToSelection(td, data, this);
                }
                
            },
            
             
                        
            rangeSelect: function rangeSelect(fromTD, toTD){
                var fromCell = this.getCellForNode(fromTD), 
                    toCell = this.getCellForNode(toTD);
                
                if (_isOfSameTitle(fromCell, toCell)){
                    
                    if (fromCell.o > toCell.o || fromCell._ei > toCell._ei){
                        var tmp = fromTD;
                        fromTD = toTD; fromCell = this.getCellForNode(fromTD);
                        toTD = tmp; toCell = this.getCellForNode(toTD);
                    }
                    
                    var totalForms = _getFormCount(fromCell, this),
                        axis = fromCell.axis,
                        table = mstrmojo.dom.findAncestorByName(fromTD, 'table', false),
                        rows = table.rows,
                        fromRow = fromTD.parentNode,
                        fromRowIdx = fromRow.rowIndex,
                        fromRowCells = fromRow.cells,
                        toRowIdx = toTD.parentNode.rowIndex;
                    
                    if (axis === ROW_AXIS) {
                        for (var i = fromRowIdx; i <= toRowIdx; i++){
                            var cells = rows[i].cells, found1 = false;
                            
                            
                            for (var j = 0, len = cells.length, formFound = 0; j < len && formFound < totalForms; j++){ 
                                var tc = cells[j], tcData = this.getCellForNode(tc);
                                if (_isOfSameTitle(tcData, fromCell)){
                                    _addToSelection(tc, tcData, this);
                                    formFound++;
                                }
                            }
                        }
                    }else if (axis === COL_AXIS){
                        for (var i = 0, len = rows.length, formsFound = 0; i < len && formsFound < totalForms; i++){
                            var cells = rows[i].cells, shouldSelect = false;
                            for (var j = 0, len2 = cells.length; j < len2; j++){ 
                                var tc = cells[j], tcData = this.getCellForNode(tc);
                                if (_isOfSameUnit(tcData, fromCell)){ 
                                    
                                    shouldSelect = true;
                                }
                                if (shouldSelect){
                                    _addToSelection(tc, tcData, this);
                                }
                                if (_isOfSameUnit(tcData, toCell)){ 
                                    
                                    break;
                                }
                            }
                            if (shouldSelect){
                                formsFound++;
                            }
                        }
                    }else{ 
                        if (fromRowIdx == toRowIdx){
                            
                            for (var i = fromTD.cellIndex, len = toTD.cellIndex; i <= len; i++){
                                var tc = fromRowCells[i], tcData = this.getCellForNode(tc);
                                _addToSelection(tc, tcData, this);
                            }
                        }else{
                            
                            for (var i = fromRowIdx, len = toRowIdx; i <= len; i++){
                                var cells = rows[i].cells;
                                for (var j = 0, len2 = cells.length; j < len2; j++){
                                    var tc = cells[j], tcData = this.getCellForNode(tc);
                                    if (_isOfSameTitle(tcData, fromCell)){
                                        _addToSelection(tc, tcData, this);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            },
            
            
            doSelection: function( e,  hWin,  td) {
                var d = mstrmojo.dom,
                    ctrl = d.ctrlKey(hWin, e),
                    shift = d.shiftKey(hWin, e);
                    
                if (!ctrl){
                    _clearSelection(this);
                }
                
                var data = this.getCellForNode(td);
                var isHeaderValue = data && (data.mix === undefined && data.o !== undefined),
                    isMetricValue = data && (data.mix !== undefined && (data._lp || data._tp));
                
                if (isHeaderValue || isMetricValue) { 
                    if (shift) {
                        this.rangeSelect(this.lastSelectedTD, td);
                    } else {
                        this.singleSelect(td, ctrl);
                        this.lastSelectedTD = td; 
                    }
                }
            }
        };
})();
(function(){
    
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.css");
    
    
    var commonProps = {
        T: [ 'top', 'left' ],
        D: [ 'height', 'width' ],
        B: [ 'border', 'border-color', 'border-style', 'border-width' ],
        F: [ 'font', 'color', 'text-decoration' ],
        P: [ 'padding' ]
    };
    
     
    commonProps.RW = ['z-index'].concat(commonProps.T.concat(commonProps.D));
    
    
    var $D = mstrmojo.dom;
    
    
    function pushFxProperty(fx, n, v) {
        
        var p = fx[n] || [];
        
        p.push(v);
        
        fx[n] = p;
    }
    
    
    mstrmojo._Formattable = 
        
        {
            _mixinName: 'mstrmojo._Formattable', 
            
            
            formatHandlers: null,
            
            
            getCacheKey: function getCacheKey(w) {
                return 'csscache' + (w.thresholdId || '');
            },

            update: function update(node) {
                
                this.invisible = !!(node && node.data && node.data.invisible);
                
                if (this._super) {
                    this._super(node);
                }
            },
            
                        
            preBuildRendering: function preBuildRendering() {
                if (this._super) {
                    this._super();
                }
                
                
                var defn = this.defn;
                if (!defn) {
                    defn = this.defn = {};
                }
                var cacheKey = this.getCacheKey(this),
                    cache = defn[cacheKey];
                if (!cache) {
                    
                    cache = defn[cacheKey] = {};
                    
                    
                    var fmts = this.getFormats();
                    if (fmts) {
                    
                        
                        var fhs = this.formatHandlers;
                        for (var slot in fhs) {
                            var handle = fhs[slot];
                            
                            
                            var src = handle.src? fmts[handle.src] : fmts;
                            if (!src) {
                                return;
                            }
                            
                            
                            var css = [];
                            var x = -1;
                            
                            
                            var slotCss = slot + 'CssText';
                            
                            
                            var props = handle.props || handle;
                            if (!props) {
                                continue;
                            }
                            
                            
                            for (var bp = props.length-1; bp >= 0; bp--) {
                                var p = props[bp];
                                
                                
                                var c = commonProps[p] || [ p ];
                                
                                
                                for (var z = c.length-1; z >= 0; z--) {
                                    
                                    p = c[z];
                                    
                                    
                                    if (p in src) {
                                        
                                        if (p === 'fx') {
                                            var f = src[p],
                                                fx = {};
                                            
                                            
                                            if ('gd' in f) {
                                                this.formatGradient(f.gd, fx);
                                            }
                                            
                                            
                                            
                                            if ('rt' in f) {
                                                if(f.rt == 1 || f.rt == 3) this.formatTextRotation(f.rt, fx);
                                            }
                                            
                                            
                                            if ('ds' in f) {
                                                this.formatDropShadow(f, fx);
                                            }
                                            
                                            
                                            for (var fp in fx) {
                                                
                                                css[++x] = fp + ':' + fx[fp].join(' ');
                                            }
                                        } else {
                                            css[++x] = p + ':' + src[p];
                                        }
                                    }
                                }
                            }
                            
                            if ( this.invisible) {
                            	css.push("visibility:hidden");
                            }
                            
                            
                            this[slotCss] = cache[slotCss] = css.join(';') + ';';
    
                        } 
                    } 
                } else {
                    
                    for (var n in cache) {
                        this[n] = cache[n];
                    }
                }            
                return true;
            },
            
            
            formatGradient: function formatGradient(gp, fx) {
                var gd = mstrmojo.css.buildGradient(gp.t, gp.sc, gp.ec);
                if (gd) {
                    pushFxProperty(fx, gd.n, gd.v);
                }
            },
            
            
            formatDropShadow: function formatDropShadow(f, fx) {
                if ($D.supports($D.cssFeatures.DROP_SHADOW)) {
                    var ds = f.ds;
                    
                    if ($D.isDXIE) {
                        pushFxProperty(fx, 'filter', "progid:DXImageTransform.Microsoft.DropShadow(Color='#66000000',Positive='true',OffX=" + ds + ",OffY=" + ds + ")");
                    } else {
                        var v = [ ds, ds ];
                        
                        
                        if (f.rt == 1 || f.rt == 3) {
                            
                            v[((f.rt === 1) ? 1 : 0)] = -ds;
                        }
                        
                        pushFxProperty(fx,  ($D.isWK ? '-webkit-' : '') + 'box-shadow', v.join('px ') + 'px 3px 0px #888');
                    }
                }
            }, 
            
            
            formatTextRotation: function formatTextRotation(tr, fx) {
                if ($D.supports($D.cssFeatures.TEXT_ROTATION)) {
                    if ($D.isDXIE) {
                        pushFxProperty(fx, 'filter', 'progid:DXImageTransform.Microsoft.BasicImage(rotation=' + tr + ')');
                    } else {
                        
                        
                        var degrees = (tr === 1) ? 90 : -90;
                        
                        
                        pushFxProperty(fx, $D.CSS3_PREFIX + 'transform-origin', 'top left');
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        pushFxProperty(fx, $D.CSS3_PREFIX + 'transform', 'rotate(' + degrees + 'deg)');
                    }
                }
            },
            
            
            getFormats: function getFormats() {
                if (!this.fmts) {
                       this.fmts = this.formatResolver.getFormat(this.defn, this.thresholdId);    
                }
                
                return this.fmts;
            },
            
            clearCache: function clearCache() {
                
                delete this.defn[this.getCacheKey(this)];
            },
            
            unrender: function unrender(ignoreDom) {
                
                
                if (this.thresholdId) {
                    
                    this.fmts = null;
                }
                
                this._super(ignoreDom);
            }
            
        };
    
    
    mstrmojo._Formattable.getBorderWidths = function(w) {
        var f = w.getFormats(),
            b = ('border' in f) ? f.border.match(/(\d*|\d*\.\d*)pt/)[0] : f['border-width'],    
            dpi = w.model.docModel ? w.model.docModel.dpi : w.model.dpi; 
        return mstrmojo.css.getBorderWidths(b, dpi);
        };
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.string",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $DOM = mstrmojo.dom,
        $CSS = mstrmojo.css,
        clsSelected = 'selected';

    function delegateSelect(mthName, el, item, idx, widget) {
        
        var hook = widget.listHooks[mthName];
        if (hook && hook.call(widget, el, item, idx)) {
            
            return;
        }

        
        $CSS[((mthName === 'select') ? 'add' : 'remove') + 'Class'](el, clsSelected);
    }

    function addToCollection(propertyName, delimiter, values) {
        
        var existing = this[propertyName],
            arr = (existing) ? existing.split(delimiter) : [];

        
        arr = arr.concat(values.split(delimiter));

        
        this[propertyName] = arr.join(delimiter);

        
        return arr.length - 1;

    }

    
    mstrmojo._IsList = mstrmojo.provide(

        "mstrmojo._IsList",

        
        {
            _mixinName: 'mstrmojo._IsList',

            
            listHooks: {},

            
            getItemMarkup: function (item, idx) {
                return '<{@tag} class="item {@cls}" idx="{@idx}" style="{@style}">{@n}</{@tag}>';
            },

            
            getItemProps: function getItemProps(item, idx) {
                var isSelected = !!this.selectedIndices[idx];
                return {
                    tag: 'div',                                                 
                    sel: isSelected,                                            
                    cls: (isSelected) ? clsSelected : '',                       
                    n: item.n || '',                                            
                    style: '',                                                  
                    idx: idx,
                    addCls: function (cls) {
                        addToCollection.call(this, 'cls', ' ', cls);
                    },
                    addStyle: function (s) {
                        addToCollection.call(this, 'style', ';', s);
                    }
                };
            },

            itemRenderer: {
                render: function (item, idx, widget) {
                    
                    item._renderIdx = idx;

                    
                    return mstrmojo.string.apply(widget.getItemMarkup(item, idx), widget.getItemProps(item, idx));
                },

                select: function (el, item, idx, widget) {
                    delegateSelect('select', el, item, idx, widget);
                },

                unselect: function (el, item, idx, widget) {
                    delegateSelect('unselect', el, item, idx, widget);
                }
            },

            onclick: function onclick(evt) {
                try {
                    
                    var target = evt.target || $DOM.eventTarget(evt.hWin, evt.e),
                        item = $DOM.findAncestorByAttr(target, 'idx', true, this.domNode),
                        idx = item && parseInt(item.value, 10);

                    if (idx !== null && !isNaN(idx)) {
                        
                        if (!this.multiSelect) {
                            
                            this.singleSelect(idx);

                        } else {
                            
                            var m = (this.selectedIndices[idx]) ? 'remove' : 'add';

                            
                            this[m + 'Select'](idx);

                        }
                    }
                } catch (ex) {
                    
                    
                    mstrApp.onerror(ex);
                }
            }
        }
    );

    
    mstrmojo._IsList.SELECTED_CLS = clsSelected;

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.css");

    
    mstrmojo.android.selectors._SupportsHoriz = mstrmojo.provide(

        "mstrmojo.android.selectors._SupportsHoriz",

        
        {
            _mixinName: 'mstrmojo.android.selectors._SupportsHoriz',

            scrollerConfig: {
                bounces: false,
                showScrollbars: false
            },

            minItemHeight: 25,

            getItemProps: function getItemProps(item, idx) {
                
                var props = this._super(item, idx),
                    h = this.height,
                    itemCnt = this.items.length,
                    lineHeight;

                
                props.tag = 'label';
                props.n = props.n || "&nbsp";

                
                if (this.isHoriz) {
                    
                    if (h) {
                        
                        lineHeight = h;
                    }

                    
                    if (this.itemWidthMode === 0) {
                        
                        props.style += 'width:' + Math.floor(100 / itemCnt) + '%;';
                    }

                } else {
                    
                    if (h) {
                        
                        lineHeight = Math.round(parseInt(h, 10) / itemCnt);

                        
                        lineHeight = Math.max(lineHeight, this.minItemHeight);

                        
                        lineHeight += 'px';
                    }

                }

                
                if (lineHeight) {
                    
                    props.style += 'line-height:' + lineHeight + ';';
                }

                return props;
            },

            init: function init(props) {
                this._super(props);

                
                if (this.isHoriz) {
                    
                    this.cssDisplay = 'table';

                    
                    var cls = [ 'horiz' ];

                    
                    if (this.itemWidthMode === 0) {
                        
                        cls.push('fixedWidth');
                    }

                    
                    mstrmojo.css.addWidgetCssClass(this, cls);
                }

            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    scrollEl = this.itemsContainerNode,
                    dimension = 'Height',
                    axis = 'y',
                    scroll = 'v',
                    offset = {};

                
                if (this.isHoriz) {
                    
                    dimension = 'Width';
                    axis = 'x';
                    scroll = 'h';
                }

                
                cfg.scrollEl = scrollEl;

                
                var size = this[dimension.toLowerCase()];
                if (size) {
                    
                    size = parseInt(size, 10);

                    
                    var offsetEnd = Math.max(scrollEl['offset' + dimension] - size, 0),
                        enableDimensionScroll = cfg[scroll + 'Scroll'] = (offsetEnd !== 0);

                    
                    if (enableDimensionScroll) {
                        
                        offset[axis] = {
                            start: 0,
                            end: offsetEnd
                        };
                    }
                }

                
                cfg.offset = offset;

                
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                return cfg;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.string",
                         "mstrmojo.css");

    var touchClass = 'tx-touch',
        HOLD_TIME = 100,
        previewMarkup = '<div class="mstrmojo-dicPreview dicx{@t} {@x}" ' +
                          'ontouchstart="mstrmojo.all[\'{@id}\'].previewTouchStart()";>' +
                             '<div>' +
                                 '<div>{@v}</div>' +
                             '</div>' +
                         '</div>';

    mstrmojo.android._HasPreviewButton = mstrmojo.provide(

        "mstrmojo.android._HasPreviewButton",

        {
            _mixinName: "mstrmojo.android._HasPreviewButton",

            renderPreview: function renderPreview() {
                
                var openerNode = this.openerNode,
                    group = this.group || this,
                    showFullPreview = (group.openerType === 2) || !!this.dic.dm || this.dicChanged;   

                this.renderPreviewButton(openerNode, showFullPreview ? this.dv : openerNode.innerHTML);
            },

            
            renderPreviewButton: function renderPreviewButton(target, value) {
                var dic = this.dic,
                    dicType = dic.t,
                    group = this.group || this,
                    showPreview = false,                    
                    showArrow = true,                       
                    $TYPES = mstrmojo.DICConfig.TYPES,
                    cls = [];


                
                switch (dicType) {
                case $TYPES.SLIDER:
                case $TYPES.TEXTAREA:
                    
                    showArrow = !dic.dm;
                    break;

                case $TYPES.SWITCH:
                case $TYPES.TOGGLE:
                case $TYPES.RATING:
                case $TYPES.STEPPER:
                case $TYPES.LIKERTSCALE:
                    
                    showArrow = false;
                    break;
                }

                
                if (group.openerType === 2) {
                    
                    showPreview = showArrow;
                }

                
                if (showArrow) {
                    
                    var targetStyle = target.style;
                    targetStyle.border = '';
                    targetStyle.padding = '';

                    
                    cls.push('arw');

                    
                    if (showPreview) {
                        
                        cls.push('prv');
                    }
                }

                var id = this.id;
                
                target.innerHTML = mstrmojo.string.apply(previewMarkup, {
                    t: dicType,
                    v: value || '&nbsp;',                   
                    id: id,
                    x: cls.join(' ')
                });

                
                this._previewNode = target.firstChild;
                
                
                if(this.inlineExtraCssText) {
                    this._previewNode.style.cssText += ' ' + this.inlineExtraCssText;
                }
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                var previewNode = this._previewNode,
                    childNode = previewNode && previewNode.firstChild;

                
                mstrmojo.css.addClass(childNode || d, 'tx-active');
            },

            previewTouchStart: function previewTouchStart() {
                var me = this;
                mstrmojo.css.addClass(me._previewNode, touchClass);
                if (this._holderTimer) {
                    clearTimeout(this._holderTimer);
                }
                this._holdTimer = setTimeout(function() {
                    delete me._holdTimer;
                    mstrmojo.css.removeClass(me._previewNode, touchClass);
                }, HOLD_TIME);
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.dnd");

    var $D = mstrmojo.dom;

    
    function cursorHack(rtnValue) {
        if ($D.isWK) {
            document.onselectstart = function (e) {
                if (!rtnValue) {
                    e.preventDefault();
                }

                return rtnValue;
            };
        }
    }

    mstrmojo._IsMovable = mstrmojo.provide("mstrmojo._IsMovable", {
        
        draggable: true,

        
        ownAvatar: true,

        
        getMovingHandle: function getMovingHandle() {
            return this.domNode;
        },

        
        getMovingTarget: function getMovingTarget() {
            return this.domNode;
        },

        
        ondragstart: function ondragstart(c) {
            var handle = this.getMovingHandle(),
                targetStyle = this.getMovingTarget().style;

            
            var shouldBeginDrag = $D.contains(handle, c.src.node, true, document.body);
            if (shouldBeginDrag) {
                
                cursorHack(false);

                
                handle.style.cursor = 'move';

                
                this._leftPos = parseInt(targetStyle.left, 10);
                this._topPos = parseInt(targetStyle.top, 10);
                this._hWidth = handle.clientWidth;
                this._hHeight = handle.clientHeight;
            }

            return shouldBeginDrag;
        },

        
        ondragmove: function ondragmove(c) {
            var targetPosition = c.tgt.pos,
                srcPosition = c.src.pos,
                targetStyle = this.getMovingTarget().style;

            
            
            targetStyle.left = this.left = Math.max(this._leftPos + targetPosition.x - srcPosition.x, -this._hWidth + 40) + 'px';
            targetStyle.top = this.top = Math.max(this._topPos + targetPosition.y - srcPosition.y, -this._hHeight + 10) + 'px';
        },

        
        ondragend: function ondragend(c) {
            
            cursorHack(true);

            
            this.getMovingHandle().style.cursor = 'default';

            
            delete this._leftPos;
            delete this._topPos;
            delete this._hWidth;
            delete this._hHeight;
        }
    });
}());
(function () {

    mstrmojo.requiresCls("mstrmojo._IsList",
                         "mstrmojo.dom");

    
    var isList = mstrmojo.android._IsList = mstrmojo.provide(
        "mstrmojo.android._IsList",

        mstrmojo.hash.copy(mstrmojo._IsList, {
            _mixinName: 'mstrmojo.android._IsList',

            
            getItemIdxTouch: function getItemIdxTouch(touch) {
                
                var item = mstrmojo.dom.findAncestorByAttr(touch.target, 'idx', true, this.domNode),
                    idx = item && parseInt(item.value, 10);

                return (idx !== null && !isNaN(idx)) ? idx : -1;
            },

            
            resetListState: function resetListState() {
                
                this.clearSelect(true);

                
                var scrollerConfig = this.scrollerConfig;
                if (scrollerConfig) {
                    
                    delete this.scrollerConfig.origin;
                }
            },

            
            restoreListState: function restoreListState(idx, origin) {
                
                var indices = {};
                indices[idx] = true;

                this.selectedIndices = indices;
                this.selectedIndex = idx;

                
                var scrollerConfig = this.scrollerConfig;
                if (scrollerConfig) {
                    
                    scrollerConfig.origin = origin;
                }
            },

            
            touchSelectEnd: function touchSelectEnd(touch) {
                
                this.touchTap(touch);
            }
        })
    );

    
    var fnClick = isList.onclick;
    isList.onclick = mstrmojo.emptyFn;

    
    isList.touchTap = function (touch) {
        
        this._listTarget = touch.target;

        
        fnClick.call(this, touch);
    };

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.registry",
                         "mstrmojo._Provider",
                         "mstrmojo.array");

    var $H = mstrmojo.hash,
        $R = mstrmojo.registry,
        $ARR = mstrmojo.array;

    
    mstrmojo.Obj = mstrmojo.declare(
        
        null,

        
        [ mstrmojo._Provider ],

        
        {
            
            scriptClass: "mstrmojo.Obj",

            
            

            
            

            
            init: function init(props) {
                
                this.disposables = [];
                
                
                $H.copy(props, this);    

                
                if (this.postApplyProperties) {
                    this.postApplyProperties();
                }

                
                $R.add(this);

                
                if (this.postCreate) {
                    this.postCreate();
                }
            },

            
            destroy: function destroy(ignoreDOM) {
                this._super(ignoreDOM);
                
                
                $ARR.forEach(this.disposables, function (d) {
                    
                    if (d.destroy) {
                        
                        d.destroy(ignoreDOM);

                    
                    } else if (d.clear) {
                        
                        d.clear();
                    }
                });
                
                
                this.disposables = [];

                
                $R.remove(this);
            }
        }
    );

    
    
    
    
    
    
    var obj = mstrmojo.Obj;
    obj.free = function free(o) {
        if (o instanceof obj) {
            o.destroy();
        }
    };
}());
(function() {
    mstrmojo.requiresCls("mstrmojo.hash",
            "mstrmojo.date",
            "mstrmojo.string");

    var $H = mstrmojo.hash,
        $S = mstrmojo.string,
        CLEARING_DIV_MKP = '<div class="clearingDiv"></div>',
        START_DIV = '<div {@attr}>',
        END_DIV = '</div>';
    
    
    function createAttrString(attr) {
        var str = [],
            len = -1;
        
        $H.forEach(attr, function (v, k) {
            str[++len] = k + '="' + v + '"';
        });
        
        return str.join(' ');
    }
    
    
    mstrmojo.android.ui.CalendarMarkupBuilder = {
        
        getHeaderHTML: mstrmojo.emptyFn,
        
        
        getContentHTML: mstrmojo.emptyFn,

        
        getSingleMonthHelper: function getSingleMonthHelper(month, year, config) {
            var html = [],
                len = -1,
                $MKP = config.mkp || (START_DIV + '{@d}' + END_DIV),
                startDate = new Date(year, month),
                curMonth = -1,
                includeAdjacentMonths = config.incl,
                showAddlWeek = config.showAddlWeek,
                week = 0;

            
            startDate.setDate(1 - startDate.getDay());
            
            
            curMonth = startDate.getMonth() - month;

            while (!((curMonth === 1 || curMonth === -11) && startDate.getDay() === 0) || (showAddlWeek && week < 6)) {
                
                var date = startDate.getDate(),
                    curItemProps = (includeAdjacentMonths || curMonth === 0) ? {
                        d: date,
                        attr: createAttrString({
                            d: date
                        })
                    } : {};
                    
                
                
                if (curItemProps.attr && config.cls) {
                    curItemProps.attr["class"] = config.cls;
                }

                
                html[++len] = $S.apply($MKP, curItemProps);
                
                
                startDate.setDate(date + 1);
                
                
                curMonth = startDate.getMonth() - month;
                
                
                if (startDate.getDay() === 0) {
                    week++;
                }
            }

            html[++len] = CLEARING_DIV_MKP;
            
            return html.join('');
        }
    };
}());
(function(){
    
    mstrmojo.requiresCls("mstrmojo.locales", "mstrmojo.expr", "mstrmojo.date","mstrmojo.num", "mstrmojo.string");
    
    mstrmojo.validation = {
            STATUSCODE: {
                    UNKNOWN: -1,
                    VALID : 0,
                    INVALID: 1,
                    INVALID_EMPTY: 2,
                    INVALID_CHAR: 3,
                    INVALID_OUTOFRANGE:4,
                    INVALID_REGEX:5,
                    INVALID_VALIDATOR:6,
                    INVALID_BAD_NUMERICFORMAT:7,
                    INVALID_BAD_DATESTRING:8            
            },        
            TRIGGER:{
                    NONE: 0,
                    ONBLUR: 1,
                    ONKEYUP: 2,
                    VALUESET: 4,
                    ALL: 7        
            },            
            REGEXP:{
                    US_ZIP: /^\d{5}([- ]?\d{4})?$/, 
                    EMAIL_ADDRESS: /^([a-zA-Z0-9\_\.\-])+@(([a-zA-Z0-9\-])+[\.])+([a-zA-Z0-9]{2,4})+$/,
                    SOCIAL_SECURITY_NUMBER: /^((?!000)(?!666)\d{3})(\s|\-)?((?!00)\d{2})\2((?!0000)\d{4})$/,
                    PHONE_NUMBER: /^(?!-)[ \d\-\(\)\.\+]+$/,
                    FILE_NAME:new RegExp("^[^:*?\"<>|/\\\\()]+$"),
                    FOLDER_PATH_WIN:new RegExp("^([a-zA-Z]:|\\\\\\\\[^:*?\"<>|/\\\\]+|[^:*?\"<>|/\\\\]*)(\\\\[^:*?\"<>|/\\\\]+)*(\\\\){0,1}$"),        
                    FOLDER_PATH_UNIX:new RegExp("^(/){0,1}([^:*?\"<>|/\\\\]+/)*([^:*?\"<>|/\\\\]+){0,1}$"),
                    PRINTER_PATH_SINGLE: new RegExp("^[^$%:*?\"<>|/\\\\]*$"),
                    PRINTER_PATH_MULTIPLE:new RegExp("^((/|\\\\\\\\)[^$%:*?\"<>|/\\\\]+)((/|\\\\)[^$%:*?\"<>|/\\\\]+)*(/|\\\\){0,1}$")
            },
            VALIDATOR:{
                    DEMO:function customValidator(v){
                           var parsed = parseInt(v,10),
                               SC = mstrmojo.validation.STATUSCODE;
                           if(parsed === 0 || parsed === 1 || parsed > 10) {
                               return {code:SC.VALID};
                           }
                           
                           return {code:SC.INVALID, msg:'This field must be either 0, 1 or greater than 10'};
                    },
                    VALIDATE_PHONENO: function validatePhoneNo(v){
                        var dt = this.dtp, 
                            phoneNo = String(v).replace(/[^\d]/g, '');
                        
                        
                        if (phoneNo.length < 10){
                            return {code:_SC.INVALID, msg: mstrmojo.desc(9203)}; 
                        }
                        
                        if (!_V.REGEXP.PHONE_NUMBER.test(v)){
                            return {code:_SC.INVALID, msg: mstrmojo.desc(9204)}; 
                        }
                        return {code:_SC.VALID};
                    },
                    VALIDATE_ZIPCODE: function validateZipCode(v){
                        var msg = '', dt = this.dtp;
                        if (!_V.REGEXP.US_ZIP.test(v)){
                            if (_V.isNumeric(dt) || _V.isInt(dt))
                                msg = mstrmojo.desc(9208); 
                            else if (_V.isString(dt)){
                                msg = mstrmojo.desc(9206); 
                            }
                            return {code:_SC.INVALID, msg: msg};
                        }
                        return {code:_SC.VALID};
                    },
                    VALIDATE_EMAIL: function validateEmail(v){
                        var atSignIdx = v.indexOf('@');
                        
                        if (atSignIdx === -1){
                            return {code: _SC.INVALID, msg: mstrmojo.desc(9197)}; 
                        }
                        
                        if (v.substring(atSignIdx).indexOf('.') === -1){
                            return {code: _SC.INVALID, msg: mstrmojo.desc(9198)}; 
                        }
                        
                        return _V.REGEXP.EMAIL_ADDRESS.test(v) ? {code:_SC.VALID} : {code:_SC.INVALID, msg:mstrmojo.desc(9207)}; 
                    },
                    VALIDATE_SSN: function validateSSN(v){
                        var dt = this.dtp, ssnNo;
                        if (_V.isNumeric(dt) || _V.isInt(dt)){
                            ssnNo = String(v).replace(/[^\d]/g, '');
                            if (ssnNo.length != 9){
                                return {code:_SC.INVALID, msg: mstrmojo.desc(9209)}; 
                            }
                        }
                        if (!_V.REGEXP.SOCIAL_SECURITY_NUMBER.test(v)){
                            return {code:_SC.INVALID, msg: mstrmojo.desc(9210)}; 
                        }
                        return {code:_SC.VALID};
                    }
            },
            isInt: function(dtp){
                return DTP2TYPE[dtp] == 1;
            },
            isNumeric: function(dtp){
                return DTP2TYPE[dtp] == 2 || DTP2TYPE[dtp] == 5;
            },
            isString: function(dtp){
                return DTP2TYPE[dtp] == 3;
            }            
    };

    
    var _G = window.mstrConfig,
    listSep = _G.listSep,
    _E = mstrmojo.expr,
    DTP = _E.DTP,
    _V = mstrmojo.validation,
    _TR = _V.TRIGGER,
    _SC = _V.STATUSCODE,    
    _C = mstrmojo.css,
    _N = mstrmojo.num,
    _S = mstrmojo.string, 
    _DP = mstrmojo.date,
    DTP2TYPE = {
        '-1':-1,
        1:1,
        2:1,
        3:2,
        4:2,
        5:2,
        6:2,
        7:2,
        8:3,
        9:3,
        10:3,
        11:4,
        12:4,
        13:4,
        14:6,
        15:6,
        16:6,
        21:2,
        22:2,
        23:3,
        24:4,
        25:3,
        30:5
    };
   
    
    
    function _containsInvalidChar(me, v){
        var dtp = me.dtp,
            c = me.constraints,
            allows = c.allowedFormatChars ? c.allowedFormatChars : '',
            isInt = (DTP2TYPE[dtp] == 1),                        
            isNumeric = (DTP2TYPE[dtp] == 2),                        
            isDT = (DTP2TYPE[dtp] == 6),
            thousand = mstrmojo.locales.number.THOUSANDSEPARATOR,
            decimal = mstrmojo.locales.number.DECIMALSEPARATOR,
            regExp;
                          
        if(isInt){
            if(!me._intRegExp){
                allows += '0-9-' + (me.isList ? listSep : '') + thousand;
                me._intRegExp = new RegExp('[^' + allows + ']');
            }
            regExp = me._intRegExp;
        }
        
        if(isNumeric){
            if(!me._numericRegExp){
                allows += '0-9-' + (me.isList ? listSep : '') + decimal + thousand;
                me._numericRegExp = new RegExp('[^' + allows + ']');
            }
            regExp = me._numericRegExp;                      
        }
            
        if(isDT){
            
        }
        
        return !!regExp && regExp.test(v);
    }
    
    
    function _valueOutOfRange(me, v){
        var dtp = me.dtp,
        c = me.constraints,
        isInt = (DTP2TYPE[dtp] == 1),                        
        isNumeric = (DTP2TYPE[dtp] == 2),                        
        isDT = (DTP2TYPE[dtp] == 6),
        min = c.min,
        max = c.max,
        parsed;
        
        
        if(min == undefined && max == undefined) {
            return false;
        }
        
        
        if(isInt || isNumeric){
            return _N.inNumericRange(v, min, max) !== 0;
        }
        
        
        if(isDT){
            return _DP.inDateTimeRange(v, min, max) !== 0;
        }
            
        return false;                        
    }
    
    
    function _badNumericFormat(me, v){                 
        return !_N.isNumeric(v) ;
    }

    
    function _badDTString(me, v){
        var isD = (me.dtp === DTP.DATE),
            isT = (me.dtp === DTP.TIME);
        return (isD ? !_DP.isDate(v) : (isT ? !_DP.isTime(v) :!_DP.isDateAndOrTime(v)));
    }
    
    
    mstrmojo._CanValidate = mstrmojo.provide(
            "mstrmojo._CanValidate",
            {
                
                constraints:null,
                
                
                required:false,
                
                
                dtp: DTP.INTEGER,
                
                
                isList: false,
                
                
                autoFormat: false,
                
                
                
                
                
                
                
                validationStatus:null,
                
                init: function init(props){
                    this._super(props);
                    if(!this.constraints) {
                        this.constraints = {};
                    }
                    var c = this.constraints;                    
                    if(!('trigger' in c)) {
                        c.trigger = _TR.NONE;    
                    }
                },
                
             
                
                
                _set_value: function(n,v){
                    var vWas = this.value,
                        bChanged = (vWas !== v);
                    if(bChanged){
                        this.value = v;
                        var t = this.constraints.trigger,
                            cv = (t & _TR.VALUESET) > 0;
                        if(cv) {
                            this.validate(v);
                        }
                    }
                    return bChanged;
                },

                
                
                
                   
                               
                
                
                validate: function validate(){
                    
                    var v = (this.value !== null && this.value !== undefined)? this.value : '',
                        vl = this.isList ? v.split(listSep) : [v],
                        r, isInvalid, method;
                    
                    for(var i=0, len = vl.length;i<len;i++){
                        r = this.doValidation(vl[i]);
                        isInvalid = (r.code > _SC.VALID);
                        if(isInvalid) {
                            if(len>1){
                                r.msg = mstrmojo.locales.validation.invalidValueInListError.replace("#", vl[i] ? vl[i] : ' ');
                            }
                            break;
                        }
                    }
                    
                    method = isInvalid ? 'onInvalid' : 'onValid';
                    
                    if(!isInvalid && this.autoFormat) {
                        this.format();
                    }
                    
                    
                    this.set('validationStatus',r);
                    
                    
                    if (this[method]) {
                        this[method](r);
                    }
                },
                
                
                format: function format(){
                    var dtp = this.dtp,
                        isDT = (DTP2TYPE[dtp] == 6);
                    if(!isDT) return;
                    
                    var listSep = mstrConfig.listSep,
                        v = this.value || '',
                        vl = this.isList ? v.split(listSep) : [v],                                   
                        isD = dtp === 14,
                        va=[], 
                        dt,
                        _DT = mstrmojo.locales.datetime;
                        
                    for(var i =0,len=vl.length;i<len;i++){
                        v = vl[i];
                        dt = _DP.parseDateAndOrTime(v);
                        if(dt){
                            if(isD && dt.date){
                                va.push(_DP.formatDateInfo(dt.date, _DT.DATEOUTPUTFORMAT));
                            } else {
                                va.push((dt.date ? _DP.formatDateInfo(dt.date, _DT.DATEOUTPUTFORMAT):'') + ' ' +
                                        (dt.time ? _DP.formatTimeInfo(dt.time, _DT.TIMEOUTPUTFORMAT) : ''));
                            }
                        }
                    }
                    this.set('value', va.join(listSep));
                },
                
                
                isValid: function isValid(){
                    var s = this.validationStatus;
                    if(!s) this.validate();
                    return this.validationStatus.code === _SC.VALID;
                },
                
                
                clearValidation: function clearValidation(){
                    this.set('validationStatus', {code:_SC.VALID});
                    if(this.onClearValidation) {
                        this.onClearValidation();  
                    }                    
                },
                
                
                doValidation: function doValidation(v){
                    var c = this.constraints,
                        regExp = c.regExp,
                        validator = c.validator, 
                        r = {id: this.id,code:_SC.VALID,msg:''},
                        dtp = this.dtp,
                        isInt = (DTP2TYPE[dtp] == 1),
                        isNumeric = (DTP2TYPE[dtp] == 2 || DTP2TYPE[dtp] == 5),
                        isString = (DTP2TYPE[dtp] == 3),
                        isDT = (DTP2TYPE[dtp] == 6),
                        isEmpty = _S.isEmpty(v),
                        vLen = String(v).length;
                        err = '',
                        _VAL = mstrmojo.locales.validation;
                    
                    
                    if(this.required && isEmpty) {
                        r.code = _SC.INVALID_EMPTY;
                        r.msg = _VAL.requiredFieldError;
                        return r;
                    }
                    
                    v = _S.trim(v);
                    
                    
                    if(!isEmpty && _containsInvalidChar(this,v)){
                        if(isInt) {
                            err = _VAL.integerDataType;
                        }
                        if(isNumeric) {
                            err = _VAL.numericDataType;
                        }
                        if(isDT) {
                            err = _VAL.dateDataType;
                        }
                        r.code = _SC.INVALID_CHAR;
                        r.msg = _VAL.invalidCharError.replace('#',err);
                        return r;
                    }
                    
                    
                    if(!isEmpty && isDT && _badDTString(this,v)){
                        r.code = _SC.INVALID_BAD_DATESTRING;
                        r.msg = _VAL.invalidDateStringError;
                        return r;
                    }
                    
                    
                    if(!isEmpty && (isNumeric || isInt) && _badNumericFormat(this,v)){
                        r.code = _SC.INVALID_BAD_NUMERICFORMAT;
                        r.msg = _VAL.invalidNumericFormatError; 
                        return r;
                    }
                    
                    
                    if(!isEmpty && (isInt || isNumeric || isDT) && _valueOutOfRange(this,v)){
                        r.code = _SC.INVALID_OUTOFRANGE;
                        if(c.min != null && c.max != null){
                            err = _VAL.outofRangeError.replace('#', '').replace('##', c.min).replace('###', c.max);
                        } else if(c.min != null){
                            err = _VAL.noLessMinError.replace('##', c.min).replace('#', '');  
                        } else if(c.max != null){
                            err = _VAL.noGreaterMaxError.replace('###', c.max).replace('#', ''); 
                        }
                        r.msg = err;
                        return r;
                    }
                    
                    
                    if (isString && c.minLen != null && c.maxLen != null){
                        if (vLen < c.minLen || vLen > c.maxLen){
                            r.code = _SC.INVALID;
                            r.msg = mstrmojo.desc(9211).replace(/#/, c.minLen).replace(/##/, c.maxLen);
                            return r;
                        }
                    }
                    
                    
                    if(regExp && !regExp.test(v)){
                        r.code = _SC.INVALID_REGEX;
                        r.msg = mstrmojo.desc(9205); 
                        return r;
                    }
                    
                    
                    var _t = validator && validator.apply(this,[v]);
                    
                    if(_t){
                        r.code = _t.code;
                        r.msg = _t.msg;
                        return r;
                    }
                    
                    
                    
                    return r;
                    
                }
                

            });
    
})();
(function(){
	mstrmojo.requiresCls("mstrmojo.num","mstrmojo.VisChartUtils");

	
	var percent = 0;
	
	var $NUM = mstrmojo.num;
	
	var NumUnits = [{n:1, s:""}, {n:1000, s:"K"}, {n:1000000, s:"M"}, {n:1000000000, s:"B"}, {n:1000000000000, s:"T"}, {n:1000000000000000, s:"Q"}];
	var DEFAULT_LEN_LIMIT = 3;
	var MAX_LEN_LIMIT = 5;
	
	function normalizeValue(val, interval, isFloor) {

		var ceilOrFloor = function(val, isFloor) {
			return isFloor ? Math.floor(val) : Math.ceil(val); 
		};
		
		var lab = ceilOrFloor(val/interval, isFloor) * interval;

		if(lab.toString().indexOf(".") >= 0 && interval < 1 && lab > 1) {
			lab = parseFloat(lab.toFixed(2));
		}

		if(lab > 0 && lab < 1 && interval > 1 / 1000) {
			lab = parseInt(ceilOrFloor(lab * 100, isFloor)) / 100;
		}
		return lab;
	}
	
	function updateSeriesRawValues(s, ds) {
		if(!ds) {
			ds = ','; 
		}
		var sl = s.length;
		for(var i = 0; i < sl; i++) {
			var rvs = s[i].rv,
				l = rvs.length;
			for(var j = 0; j < l; j++) {
				if(Number(rvs[j])) {
					break; 
				}
				rvs[j] = rvs[j].replace(ds,'.');
			}
		}
	}
	
	mstrmojo.VisChartData = mstrmojo.provide(
			"mstrmojo.VisChartData",
			
			{
				
				process: function prcss(w) {
	
					if((!w.baseModel && w.model) || w.model.vp) {
						this.setDerivedModel(w);
						
						var bm = w.baseModel,
							ch = bm.colHeaders,
							chl = ch.length,
							ds = ch[chl -1].items[0].ds;
						if(ds && ds !== '.') {
							updateSeriesRawValues(bm.series, ds);
						} else if(!ds) {
							updateSeriesRawValues(bm.series);
						}
					}
	
					
					
					var	model = w.model;
					var	values = model.series,
					l = values.length;
					
					if (l <= 0) {
						return;
					}
	
					
					var nlc = !w.isLinearChart && w.isDrawAxis && w.drawYAxisLabels,
						ms = "";
	
					percent = 0;
					
					
					var v = new Array(); 
					if (values && values[0] && values[0].rv.length) {
						for(var j = 0; j < l; j++) {
							var s = values[j].rv,
								sl = s.length,
								k = v.length;	
							for(var i = 0; i < sl; i++ ) {
								var val = s[i];
								
								if(!val || val.length == 0) {
									continue;
								}
								
								if(percent === 0) {
									
									percent = values[j].v[i].indexOf('%')  >= 0 ? 100 : 1;
								}
								
								v[k] = parseFloat(val);
								if(nlc && v[k].toString().length > ms.length) {
									ms = v[k].toString();
								}
								k++;
							}
						}
						v = v.sort(function sortArray(a,b){return a - b;});
					}
					model.mvalues = v;
					if(nlc) {
						
						model.mls = ms;
						model.ylbls = v;
					}
				},
	
				setDerivedModel: function sdm(w) {
					var m = w.model,
						s = m.series,
						sl = s.length,
						ri = m.ri,
						rows = m.rowHeaders,
						cols = m.colHeaders; 
					
					var rl = typeof(m.vp) !== 'undefined' && m.vp.rl && m.vp.rl.length > 0 ? m.vp.rl : null;
					
					w.baseModel = m;
					
					
					
					var rne = s[0].rv.length,
						rns = 0;
					if(rl && w.isTimeSeries) {
						var rs = parseInt(rl[0].rs),
						 	sr = rl[0].sr;
						for(var i = 0; i < rows.length; i++) {
							
							if(rows[i].id == sr) {
								rns = rne - (rows[i].l * rs) >= 0 ? rne - (rows[i].l * rs) : 0;
								break;
							}
						}
					}
					w.model = { categories:m.categories, mtrcs:m.mtrcs, series:s, colHeaders:cols, rowHeaders:rows, rne:rne, rns:rns, ri:ri};
					
				},
				
				processLinearData: function pld(w) {
					this.process(w);
					var model = w.model;
					var vals = model.mvalues,
					_max = w.getMaxValue(),
					_min = w.getMinValue();
					
					var _lbs = this.generateAxisLabels(w, _max, _min);
					model.mvalues = _lbs;
					
	
					var da = w.isDrawAxis && w.drawYAxisLabels;
					
					var useAbbr = w.isTimeSeries ? w.formatProp.condenseLabels : true;
					
					if(da) {
						var res = this.condenseLabels(_lbs, DEFAULT_LEN_LIMIT);
						if(useAbbr){
							var duplicatedCondensed = this.checkDuplicatedCondensed(res.condensedLabels);
							if(duplicatedCondensed){
								for (i=DEFAULT_LEN_LIMIT+1; i<MAX_LEN_LIMIT; ++i) {
									res = this.condenseLabels(_lbs, i);
									duplicatedCondensed = this.checkDuplicatedCondensed(res.condensedLabels);
									if (!duplicatedCondensed) {
										break;
									}
								}
								
								
								if (duplicatedCondensed) {
									useAbbr = false;
								}
							}
							model.mls = res.maxLabel;
							model.ylbls = res.condensedLabels;
						}
						
						if(!useAbbr){						
							var formatedStr = [];
							var ms = "";
							
							var items = model.colHeaders[model.colHeaders.length - 1].items;
							var formatMask = items && items[0] && items[0].f || "";
							
							for(var i = 0; i < _lbs.length; i++){
								formatedStr[i] = $NUM.formatByMask(formatMask, _lbs[i]);
								
								if(formatedStr[i].toString().length > ms.length) {
									ms = formatedStr[i].toString();
								}
							}
							
							model.mls = ms;
							model.ylbls = formatedStr;
						}
											
						
					}
	
				},
				
				checkDuplicatedCondensed: function checkDuplicatedCondensed(lbls){
					var duplicatedCondensed = false;
					for (var i=1; i<lbls.length; i++) {
						if (lbls[i] == lbls[i-1]) {
							duplicatedCondensed = true;
							break;
						}
					}
					
					return duplicatedCondensed;
				},
				
				condenseLabels: function condenseLabels(lbls, lenLimit){
					var ll = lbls.length;
					var ms = "";
					var _lbstr = new Array();					
					
					for(var i = 0; i < ll; i++) {
						
						
						_lbstr[i] = this.formatNumber(lbls[i], lenLimit);
						
						if(_lbstr[i].toString().length > ms.length) {
							ms = _lbstr[i].toString();
						}
					}
					
					return {condensedLabels:_lbstr, maxLabel:ms};
				},
				
				generateAxisLabels: function generateAxisLabels(w, _max, _min, intAsStep){
					var _lbs = new Array();
					
					if(_max == _min){
						if( _min < 0){
							_lbs.push(_min);
						}
						_lbs.push(0);
						if(_min > 0){
							_lbs.push(_min);
						}
						
						return _lbs;
					}
					
					var interval = this.calInterval(_max, _min, intAsStep);
									
					
					if(w.isTimeSeries && w.formatProp.useCustomAxisScale){
						var labelMax = _max;					
						var labelMin = _min;
					}else{
						var labelMax = normalizeValue(_max, interval, false);					
						var labelMin = normalizeValue(_min, interval, true);
						
					}
					
					
					if((_min - labelMin) > 0.9*interval){
						labelMin =  normalizeValue(_min, interval, false);
					}
					
					if((labelMax - _max) > 0.9*interval){
						labelMax =  normalizeValue(_max, interval, true);
					}
					_lbs = new Array();
					
					
	
	
	
	
	
					
					if( interval < ((labelMax - labelMin) / 30)){
						
						_lbs.push(labelMin);
						_lbs.push(labelMax);
					}else{
						var currentValue = labelMin;
						
						while(currentValue <= labelMax){
							_lbs.push(currentValue);
							if(currentValue == labelMin){
								currentValue  = Math.ceil((labelMin + interval/100)/interval)*interval;
							}else{
								currentValue = Math.ceil((currentValue + interval) * 1000) / 1000; 
							}
						}
						if(_lbs[_lbs.length - 1] < labelMax){
							_lbs.push(labelMax);
						}
					}
					
					return _lbs;
				},
				
				formatNumber: function formatNumber(number, lenLimit){
					var os = "",
						on = 1,
						posNum = number  * percent;
					if(posNum < 0){
						posNum = -number * percent;
						on = -1;
						os = "-";
					}
					
					if(posNum <= 1+1e-6){
						
						on *= posNum;
						if (posNum.toString().length <= lenLimit) {
							os += posNum;
						}
						else {
							var precision = 2;
							os += posNum.toFixed(precision);
							
							
							for (var i=os.length-1; i>=0; --i) {
								if (os.charAt(i) == '.') {
									break;
								}
								else if (os.charAt(i) != '0') {
									++i
									break;
								}
							}
							if (i < os.length) {
								os = os.substr(0, i);
							}
						}
					}else{
						
						var power = Math.log(posNum)/Math.LN10 + 1e-6;
						var n = parseInt(power / 3);					
						
						if (n >= NumUnits.length) {
							n = NumUnits.length - 1;
						}
						var fNum = posNum / NumUnits[n].n;
						var sNum = fNum.toString();
						
						if (sNum.length > lenLimit) {
							var separatorIdx = sNum.indexOf('.');
							var fracLen = separatorIdx < 0 ? 0 : sNum.length - separatorIdx + 1,
								intLen = separatorIdx < 0 ? sNum.length : separatorIdx;
							var nPrecision = lenLimit - intLen - 1;
							

							
							
							sNum = fNum.toFixed(nPrecision < 0 ? 0 : nPrecision);
							
						}
						on *= parseFloat(sNum) * NumUnits[n].n;
						os += sNum + NumUnits[n].s;
					}
					
					return os;				
				},
	
				calInterval: function cInt(_max, _min, intAsStep) {
					var interval,	
						diff = (_max - _min);
					if(diff == 0) {
						if(_max == 0) {
							_max = 1;
							_min = -1;
						} else {
							_max = _max * 2;
							_min = _min / 2;
						}
						diff = _max - _min;
					}
					
					interval = 1;
					if(diff < 1){
						while(diff < 1){
							diff *= 10;
							interval /= 10;
						}
					} else if(diff >= 10){
						while(diff >= 10){
							diff /= 10;
							interval *= 10;
						}
					}
	
					if(diff < 1.8){
						interval *= 0.2;
					} else if(diff < 3.1){
						interval *= 0.4;
					} else if(diff < 4.6){
						interval *= 0.5;
					} else if(diff >= 8.1){
						interval *= 2;
					}
	
					if(intAsStep){
						interval = Math.round(interval);
						if(interval < 1){
							interval = 1;
						}
					}else if((interval > 0 && interval < 1) && (parseInt(interval.toFixed(2) * 100) / 100) > 0) {
						interval = parseInt(interval.toFixed(2) * 100) / 100;
					}
					
					return interval;
				}
			});

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.num",
                         "mstrmojo.array",
                         "mstrmojo.DICFactory");

    var INPUT_VALUES_MANUAL = 1,
        POPUP_INLINE = 0,
        POPUP_ABOVE = 1,
        POPUP_BELOW = 2,
        decimal = '.',
        $D = mstrmojo.dom,
        $C = mstrmojo.css,
        $H = mstrmojo.hash,
        TAB_KEY = mstrmojo.Enum_Keys.TAB,

        isNumType = function (dt) {
            return (dt >= 1 && dt <= 7) || dt == 21 || dt == 22 || dt == 30;
        },

        
        convertEmtoPx = function (dom, v) {
            if ($D.isIE && !/px$/.test(v)) {
                var img = document.createElement('img'), pl;
                img.style.zIndex = -1;
                img.style.left = v;

                dom.appendChild(img);

                
                pl = img.style.pixelLeft;
                dom.removeChild(img);

                return pl + 'px';
            }
            return v;
        },

        _getScaleStyle = function (dom, n) {
            return parseInt(convertEmtoPx(dom, $C.getStyleValue(dom, n)), 10) || 0;
        },

        getPadding = function (dom) {
            return {
                lp: _getScaleStyle(dom, 'paddingLeft'),
                rp: _getScaleStyle(dom, 'paddingRight'),
                tp: _getScaleStyle(dom, 'paddingTop'),
                bp: _getScaleStyle(dom, 'paddingBottom')
            };
        },

        
        getFontStyle = function (dom) {
            var s = dom.currentStyle;
            if (!s) {
                s =  document.defaultView.getComputedStyle(dom, null);
            }
            return {
                fontFamily: s.fontFamily,
                fontSize: convertEmtoPx(dom, s.fontSize),
                fontStyle: s.fontStyle,
                fontVariant: s.fontVariant,
                fontWeight: s.fontWeight,
                textAlign: s.textAlign
            };
        },
        
        lockInfoWindow = function (widget, isLock) {
            var infowindow = mstrmojo.findAncestor(widget, 'scriptClass', 'mstrmojo.DocInfoWindow');
            if (!!infowindow) {
                infowindow.autoCloseLocked = isLock;
            }
        };

    mstrmojo._IsInputControl = {

        _mixinName: '_IsInputControl',

        
        dic: null,

        
        owner: null,

        
        openerNode: null,

        
        popupStyle: POPUP_INLINE,

        
        items: null,

        
        applyOnEnter: true,

        
        lv: null,

        init: function (props) {
            if (this._super) {
                this._super(props);
            }

            var dic = this.dic, dt = dic.dt, _DTP = mstrmojo.expr.DTP, dtObj, arr = [];

            
            
            if (mstrApp.useBinaryFormat) {
                if (dt == _DTP.DATE || dt == _DTP.TIME || dt == _DTP.TIMESTAMP) {
                    dtObj = mstrmojo.date.parseDateAndOrTime(this.value);

                    if (dtObj) {
                        if (dt != _DTP.TIME) {
                            arr.push(mstrmojo.date.formatDateInfo(dtObj.date, mstrmojo.locales.datetime.DATEOUTPUTFORMAT));
                        }

                        if (dt != _DTP.DATE) {
                            arr.push(mstrmojo.date.formatTimeInfo(dtObj.time, mstrmojo.locales.datetime.TIMEOUTPUTFORMAT));
                        }
                        this.value = arr.join(' ');
                    }
                }
            }

            
            this.lv = this.value;

            
            if (dic.wm && dic.w === undefined) {
                dic.wm = 0;
            }
        },

        
        showByDefault: false,

        
        hasPreview: false,

        
        
        getItems: function () {
            var dic = this.dic, m = [], i, v, nm = 0,
                dv = String(dic.itv),
                dx = dv && dv.indexOf(decimal), 
                isNumeric = isNumType(dic.dt);

            if (dx >= 0) {
                nm = dv.substring(dx + 1).length;
            }

            if (parseInt(dic.ipt, 10) === 0) { 
                for (i = 0, v = dic.min; v < dic.max + 0.00001; i++, v += dic.itv) {
                    m[i] = {'n': mstrmojo.num.toLocaleString(nm > 0 ? v.toFixed(nm) : v), 'v': v};
                }
            } else {
                m = dic.vls;
                mstrmojo.array.forEach(m, function (mi) {
                    if (mi.n === undefined) {
                        mi.n = isNumeric ? mstrmojo.num.toLocaleString(mi.v) : mi.v;
                    }
                });
            }

            return m;
        },

        font: null,

        
        onfontChange: function () {
            if (this.getInputNode) {
                var node = this.getInputNode(),
                    f = this.font;

                $H.forEach(f, function (o, i) {
                    node.style[i] = o;
                });
            }
        },

        
        getOpenerNodeStyle: function () {
            var s = this.group && this.group.ons,
                p = this.openerNode;

            if (!s) {
                s = getPadding(p);

                
                s.hp = s.lp + s.rp;
                s.vp = s.tp + s.bp;

                
                s.iw = Math.max(0, p.clientWidth - s.hp);
                s.ih = Math.max(0, p.clientHeight - s.vp);

                
                if (this.group) {
                    this.group.ons = s;
                }
            }
            return s;
        },

        
        onvalueChange: function () {
            if (this._super) {
                this._super();
            }

            
            this.dicChanged = true;

            if (this.showByDefault) {
                this.applyChanges();
            } else {
                if (this.popupStyle !== POPUP_INLINE && this.popup && this.popup.enableApply) {
                    this.popup.enableApply();
                }
            }
        },

        preBuildRendering: function () {
            if (this._super) {
                this._super();
            }

            this.openerNode = this.openerNode || this.owner.domNode;

            if (this.showByDefault) {
                this.openerStyle = this.getOpenerNodeStyle();
                if (this.inlineExtraCssText) {
                    this.cssText += ' ' + this.inlineExtraCssText;
                }
            }

            if (!this.placeholder) {
                this.placeholder = document.body.appendChild(document.createElement("div"));
            }
        },

        postBuildRendering: function () {
            var target = this.openerNode;

            if (this._super) {
                this._super();
            }

            
            if (!mstrmojo.isDescendant(this.owner, this)) {
                if (this.showByDefault) {
                    
                    target.replaceChild(this.domNode, target.lastChild);
                } else {
                    
                    this.set('font', getFontStyle(target));
                }
            }

            if (mstrmojo.DICConfig.isKeyNavigable(this.dic)) {
                this.registerKeyEvents(this.domNode);
            }
        },

        
        applyChanges: function () {
            var lv = this.lv, v = this.getCurValue ? this.getCurValue() : this.value, d = this.openerNode,
                dv = this.getDisplayValue ? this.getDisplayValue() : v,
                dt = this.dic.dt,
                _DTP = mstrmojo.expr.DTP,
                LD = mstrmojo.locales.datetime;

            if (String(v) !== String(lv)) {
                
                if (mstrApp.useBinaryFormat) {
                    if (dt == _DTP.TIME || dt == _DTP.TIMESTAMP) {
                        v = v.replace(new RegExp(LD.AM_NAME), 'AM').replace(new RegExp(LD.PM_NAME), 'PM');
                    }
                }

                this.lv = v;
                this.dv = dv;

                if (this.owner && this.owner.dataChanged) {
                    this.owner.dataChanged(this.k, lv, {dv: dv, v: v}, d);
                }
            }
            return true;
        },

        
        cancelChanges: function cancelChanges() {
            this.value = this.lv;
        },

        
        showInPopup: function () {

            this.popup = mstrmojo.DICFactory.createDICPopup(this.owner, this);

            if (this.focus) {
                this.focus();
            }
            
            this.setInfoWindowLock(true);
        },

        
        lockPopup: function () {
            this.setInfoWindowLock(false);
        },
        
        
        renderPreview: null,

        
        onTabDown: function (evt) {
            mstrmojo.dom.preventDefault(window, evt);

            
            if (this.applyChanges() !== false) {

                
                if (this.popup) {
                    this.popup.close();
                }

                
                this.owner.editNext(this.k);
                
                
                this.cleanup();
            }
        },

        
        cleanup: mstrmojo.emptyFn,
        
        
        registerKeyEvents: function (dom) {
            var me = this;

            $D.attachEvent(dom, 'keydown', function (evt) {
                var e = evt || window.event;
                if (e.keyCode === TAB_KEY) { 
                    me.onTabDown(evt);
                }
            });

            
            
            if ($D.isIE) {
                $D.attachEvent(dom, 'keyup', function (evt) {
                    var e = evt || window.event;
                    if (e.keyCode === TAB_KEY) {
                        me.focus();
                    }
                });
            }
        },
        
        
        setInfoWindowLock: function(isLock) {
        	lockInfoWindow(this.owner, isLock);
        }
    };
}());
(function() {
    mstrmojo.requiresCls("mstrmojo.hash",
            "mstrmojo.locales",
            "mstrmojo.array",
            "mstrmojo.date",
            "mstrmojo.string",
            "mstrmojo.android.ui.CalendarMarkupBuilder");

    var $A = mstrmojo.array,
        $H = mstrmojo.hash,
        $DL = mstrmojo.locales.datetime,
        $DN = $DL.dayNames_FULL,
        $S = mstrmojo.string,
        CLEARING_DIV_MKP = '<div class="clearingDiv"></div>',
        START_DIV = '<div {@attr}>',
        END_DIV = '</div>';
    
    function createAttrString(attr) {
        var str = [],
            len = -1;
        
        $H.forEach(attr, function (v, k) {
            str[++len] = k + '="' + v + '"';
        });
        
        return str.join(' ');
    }
    
    
    mstrmojo.android.large.ui.CalendarMarkupBuilder = $H.copy({
        getHeaderHTML: function getHeaderHTML(month, year) {
            var html = [],
                len = -1;

            $A.forEach($DN, function(v, i) {
                html[++len] = $S.apply(START_DIV, {}) + v.substring(0, 3) + END_DIV;
            });

            html[++len] = CLEARING_DIV_MKP;
            
            return html.join('');
        },

        
        getContentHTML: function getContentHTML(start, end, config) {
            var html = [],
                len = -1,
                startDate = new Date(start.y, start.m),
                endDate = (new Date(end.y, end.m)),
                CSS_PREFIX = 'mstrmojo-CalendarMV-';
            
            while (startDate <= endDate) {
                html[++len] =  $S.apply(START_DIV, {
                    attr: createAttrString({
                        m: startDate.getMonth() + 1,
                        y: startDate.getFullYear(),
                        "class": CSS_PREFIX + 'Container'
                    })
                });
                html[++len] = $S.apply(START_DIV, {
                    attr: createAttrString({
                        "class": CSS_PREFIX + 'MonthLabel'
                    })
                });
                
                html[++len] = mstrmojo.locales.datetime.MONTHNAME_SHORT[startDate.getMonth()] + '<br/>' +  startDate.getFullYear() + END_DIV;
                
                html[++len] = $S.apply(START_DIV, {
                    attr: createAttrString({
                        "class": CSS_PREFIX + 'DatesList'
                    })
                });
                
                html[++len] = this.getSingleMonthHelper(startDate.getMonth(), startDate.getFullYear(), config);
                html[++len] = END_DIV;
                html[++len] = CLEARING_DIV_MKP;
                html[++len] = END_DIV;
                
                
                startDate.setMonth(startDate.getMonth() + 1);
            }
            
            html[++len] = CLEARING_DIV_MKP;
            
            return html.join('');
        }
    }, $H.copy(mstrmojo.android.ui.CalendarMarkupBuilder));
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.hash");

    mstrmojo.touchManager = new mstrmojo.Obj({
        notify: function (srcId, touch) {
            return this.raiseEvent({
                name: 'touchesBegin',
                srcId: srcId,
                touch: touch
            });
        }
    });

    var $D = mstrmojo.dom,
        $DAE = $D.attachEvent,
        $DDE = $D.detachEvent,
        $MATH = Math,
        $C = window.mstrConfig,
        debug = false,                                                  
        activeWinListener = null,                                       
        defaultTouchConfiguration = $C && $C.allowDefaultTouches;

    
    var SWIPE_THRESHOLD = 10,
        TAP_TIMEOUT = 250,
        SELECT_DURATION = 400,
        MIN_DELTA_BETWEEN_MOVE_EVENTS = 100;

    
    var EVT_BEGIN = 'Begin',
        EVT_END = 'End',
        EVT_MOVE = 'Move',
        EVT_CANCEL = 'Cancel';

    
    var ACTION_SELECT = 1,
        ACTION_SWIPE = 2,
        ACTION_MULTI = 3,
        ACTION_TAP = 4;

    var actionMethodMap = {};
    actionMethodMap[ACTION_SELECT] = 'Select';
    actionMethodMap[ACTION_SWIPE] = 'Swipe';
    actionMethodMap[ACTION_MULTI] = 'Multi';
    actionMethodMap[ACTION_TAP] = 'Tap';

    
    
    $DAE(document.body, $D.TOUCHMOVE, function (evt) {
        
        if (!$C || !$C.allowDefaultTouches) {
            if (evt.preventDefault) {
                evt.preventDefault();
                return false;
            }
        }

        return true;
    });

    
    function getEvtIdentifier(evt) {
        var id = evt.identifier;
        return (id === undefined) ? 1 : id;
    }

    function debugLog(cmd, msg, widget, evt) {
        
        if (debug) {
            
            var touchId = (evt) ? getEvtIdentifier(evt) + ' ' : '';
            window.console.log(cmd + ':' + ((widget) ? ' ' + widget.scriptClass + ' ' + widget.id : '') + ' ' + touchId + (msg || ''));
        }
    }

    
    function isActive(widget) {
        return (activeWinListener === widget);
    }

    
    function detachWinEvts(widget) {
        
        if (!isActive(widget)) {
            
            return;
        }

        debugLog('detachWinEvts', '', widget);

        
        $DDE(window, $D.TOUCHMOVE, widget._tmCallback, true);
        $DDE(window, $D.TOUCHEND, widget._teCallback, true);
        $DDE(window, $D.TOUCHCANCEL, widget._teCallback, true);

        
        activeWinListener = null;
    }

    
    function attachWinEvts(widget) {
        
        if (isActive(widget)) {
            
            return;
        }

        
        var activeWidget = activeWinListener;
        if (activeWidget) {
            debugLog('forced deactivation', '', activeWidget);

            
            detachWinEvts(activeWidget);
        }

        debugLog('attachWinEvts', '', widget);

        
        $DAE(window, $D.TOUCHMOVE, widget._tmCallback, true);
        $DAE(window, $D.TOUCHEND, widget._teCallback, true);
        $DAE(window, $D.TOUCHCANCEL, widget._teCallback, true);

        
        activeWinListener = widget;
    }

    function getWidgetHandlerMethodName(evtName, action) {
        return 'touch' + ((action && actionMethodMap[action]) || '') + (evtName || '');
    }

    
    function getWidgetHandler(widget, evtName, action) {
        
        var methodName = getWidgetHandlerMethodName(evtName, action);

        
        return (widget[methodName] !== undefined) ? methodName : '';
    }

    
    function fireWidgetHandler(widget, evtName, touch, action, gesture) {
        
        gesture = gesture || widget.gestures[touch.id];

        var target = (gesture && gesture.bubbleTarget) || widget,
            methodName = getWidgetHandler(target, evtName, action);

        if (methodName) {
            debugLog('fire', methodName, target);

            
            touch.methodName = methodName;

            
            return target[methodName](touch);
        }
        debugLog('no handler', getWidgetHandlerMethodName(evtName, action), target);

        return true;
    }

    
    function createTouchObject(e, startTouch, changedTouch, lastTouch) {
        var pageX = changedTouch.pageX,
            pageY = changedTouch.pageY,
            timeStamp = e.timeStamp,
            id = getEvtIdentifier(changedTouch),
            delta = {
                x: $MATH.round(pageX - startTouch.pageX),
                y: $MATH.round(pageY - startTouch.pageY)
            };

        var evt = {
            id: id,
            evt: e,
            pageX: pageX,
            pageY: pageY,
            clientX: changedTouch.clientX,
            clientY: changedTouch.clientY,
            target: changedTouch.target,
            delta: delta,
            date: timeStamp,
            stop: function () {
                debugLog('event stopped', id);

                
                e.stopPropagation();
                e.cancelBubble = true;
            }
        };

        if (lastTouch) {
            
            var timeDelta = timeStamp - lastTouch.date,
                lastDelta = lastTouch.delta,
                accelDelta = {
                    x: $MATH.abs(delta.x - lastDelta.x),
                    y: $MATH.abs(delta.y - lastDelta.y)
                };

            
            evt.velocity = {
                x: accelDelta.x / timeDelta,
                y: accelDelta.y / timeDelta
            };

            
            evt.isVertical = (accelDelta.y > accelDelta.x);

            
            evt.accelDelta = accelDelta;

            
            var direction = evt.direction = {};

            
            if (pageX !== lastTouch.pageX) {
                direction.x = (pageX < lastTouch.pageX);
            } else if (pageX !== startTouch.pageX) {
                direction.x = (pageX < startTouch.pageX);
            }

            if (pageY !== lastTouch.pageY) {
                direction.y = (pageY < lastTouch.pageY);
            } else if (pageX !== startTouch.pageX) {
                direction.y = (pageY < startTouch.pageY);
            }
        }

        return evt;
    }

    
    function createGestureObject(touch, previousOneTouch, previousTwoTouch, evt) {
        return {
            s: touch,
            p1: previousOneTouch,
            p2: previousTwoTouch,
            evt: evt,
            target: evt.target
        };
    }

    
    function deleteBubbleTargetGesture(target, touchId) {
        if (target) {
            target.gestures[touchId] = null;
        }
    }

    
    function cancelTouch(widget, touchObject) {
        detachWinEvts(widget);

        fireWidgetHandler(widget, EVT_END, touchObject);
    }

    
    function cancelSelect(widget) {
        if (widget._selectHandle) {
            
            window.clearTimeout(widget._selectHandle);

            delete widget._selectHandle;

            debugLog('cancelSelect', '', widget);
        }
    }

    
    function touchesBegin(widget, e) {
        
        var which = e.which;
        if (which && which === 3) {
            debugLog('ignore', 'right mouse click', widget);

            
            return;
        }

        
        var gestures = widget.gestures,
            touches = e.touches || [ e ],
            changedTouch = (e.changedTouches && e.changedTouches[0]) || e,
            isWidgetActive = isActive(widget),
            touchObject = createTouchObject(e, changedTouch, changedTouch),          
            gesture = createGestureObject(touchObject, touchObject, touchObject, e);

        debugLog('touchBegin', '', widget, changedTouch);

        
        if (touches.length > 1) {
            
            if (!isWidgetActive) {
                
                touchObject.stop();

                debugLog('ignore', 'cross widget multitouch', widget, changedTouch);
                
                var activeWidget = activeWinListener;
                if (activeWidget && activeWidget.onCrossWidgetMultitouch !== undefined) {
                    debugLog('call onCrossWidgetMultitouch for', '', activeWidget);
                    activeWidget.onCrossWidgetMultitouch();
                }
                return false;

            }
        } else {
            
            if (isWidgetActive) {
                debugLog('forced deactivation', '', widget, changedTouch);

                
                detachWinEvts(widget);

                
                isWidgetActive = false;
            }
        }

        
        if (widget.singleNode && changedTouch.target !== widget._tn) {
            debugLog('ignore', 'target is not touch node', widget, changedTouch);

            return;
        }

        
        if (mstrmojo.touchManager.notify(widget.id, touchObject).ignore) {
            
            touchObject.stop();
            return;
        }

        
        if (!isWidgetActive) {
            
            var tagName = touchObject.target.tagName;
            tagName = tagName && tagName.toLowerCase();

            
            if (tagName === 'select' || tagName === 'input') {
                debugLog('ignore', 'target is input or select', widget, changedTouch);

                
                if (widget.monitorInputs) {
                    
                    fireWidgetHandler(widget, null, touchObject, ACTION_TAP);
                }

                
                return;
            }
        }

        
        gestures[touchObject.id] = gesture;

        
        if (isWidgetActive) {

            
            if (!widget.multiTouch) {
                
                cancelSelect(widget);

                
                var prevTouch = touches[touches.length - 2],
                    prevGesture = gestures[getEvtIdentifier(prevTouch)];

                fireWidgetHandler(widget, EVT_CANCEL, prevTouch, prevGesture.action, prevGesture);
            } else {
                
                gesture.action = ACTION_MULTI;

                
                if (widget._singleTouch) {
                    
                    cancelSelect(widget);

                    
                    widget._singleTouch.action = ACTION_MULTI;

                    
                    delete widget._singleTouch.bubbleTarget

                    
                    delete widget._singleTouch;

                    
                    fireWidgetHandler(widget, EVT_BEGIN, touchObject, ACTION_MULTI);
                }
            }

            
            touchObject.stop();

            
            return;
        }

        
        if (!$D.contains(widget._tn, e.target, true, widget.domNode)) {
            
            delete gestures[touchObject.id];

            
            return;
        }

        
        widget._singleTouch = gesture;

        
        if (fireWidgetHandler(widget, EVT_BEGIN, touchObject) === false) {
            
            return;
        }

        
        touchObject.stop();

        
        if (getWidgetHandler(widget, EVT_BEGIN, ACTION_SELECT)) {
            
            widget._selectHandle = window.setTimeout(function () {
                
                gesture.action = ACTION_SELECT;

                
                if (fireWidgetHandler(widget, EVT_BEGIN, touchObject, ACTION_SELECT) === false) {
                    
                    cancelTouch(widget, touchObject);
                }

                
                delete widget._selectHandle;
            }, SELECT_DURATION);
        }

        
        attachWinEvts(widget);
    }

    
    function touchesMoved(widget, e) {
        var changedTouch = (e.changedTouches && e.changedTouches[0]) || e,
            gesture = widget.gestures[getEvtIdentifier(changedTouch)];

        
        if (!gesture) {
            
            return;
        }

        var touchObject = createTouchObject(e, gesture.s, changedTouch, gesture.p2),
            action = gesture.action;

        
        gesture.p2 = gesture.p1;
        gesture.p1 = touchObject;

        
        if (!action && ($MATH.abs(touchObject.delta.x) > SWIPE_THRESHOLD || $MATH.abs(touchObject.delta.y) > SWIPE_THRESHOLD)) {
            
            action = gesture.action = ACTION_SWIPE;

            
            cancelSelect(widget);

            
            if (!getWidgetHandler(widget, EVT_BEGIN, action) && !getWidgetHandler(widget, EVT_MOVE, action)) {
                
                touchObject.methodName = getWidgetHandlerMethodName(EVT_BEGIN, action);

                
                return widget.bubbleTouchEvent(touchObject);
            }

            
            if (fireWidgetHandler(widget, EVT_BEGIN, touchObject, action) === false) {
                
                cancelTouch(widget, touchObject);
                return;
            }
        }

        
        if (action) {
            var lastMove = gesture.lastMove || gesture.s.date,
                delta = touchObject.date - lastMove;

            
            
            
            if (!mstrApp.isTouchApp() || delta >= MIN_DELTA_BETWEEN_MOVE_EVENTS) {
                gesture.lastMove = touchObject.date;
                fireWidgetHandler(widget, EVT_MOVE, touchObject, action);
            }
        }
    }

    
    function touchesEnd(widget, e) {
        var changedTouch = (e.changedTouches && e.changedTouches[0]) || e,
            touchCount = (e.touches && e.touches.length) || 0,          
            gestures = widget.gestures,
            touchId = getEvtIdentifier(changedTouch),
            gesture = gestures[touchId];

        
        if (!gesture) {
            debugLog('No gesture', touchId, widget, changedTouch);

            
            return;
        }

        var action = gesture.action,
            touchObject = createTouchObject(e, gesture.s, changedTouch, gesture.p2);

        
        if (!action) {
            
            cancelSelect(widget);

            
            if (!gesture.wasMulti) {
                action = ACTION_TAP;
            }
        }

        
        if (touchCount === 0) {
            
            detachWinEvts(widget);

            
            widget.gestures = [];

            debugLog('gestures', 'clear all', widget, changedTouch);
        } else {
            
            gestures[touchId] = null;

            debugLog('gestures', 'clear single', widget, changedTouch);
        }

        
        deleteBubbleTargetGesture(gesture.bubbleTarget, touchId);

        
        switch (action) {
        case ACTION_SWIPE:
        case ACTION_SELECT:
            
            touchObject.stop();
            fireWidgetHandler(widget, EVT_END, touchObject, action, gesture);
            break;

        case ACTION_MULTI:
            
            if (touchCount < 2) {
                
                fireWidgetHandler(widget, EVT_END, touchObject, action, gesture);

                
                if (touchCount === 1) {
                    
                    var remainingTouch = e.touches[0],
                        rebasedTouch = createTouchObject(e, remainingTouch, remainingTouch),
                        newGesture = createGestureObject(rebasedTouch, rebasedTouch, rebasedTouch, e);

                    
                    newGesture.wasMulti = true;

                    
                    gestures[getEvtIdentifier(remainingTouch)] = newGesture;

                    
                    widget._singleTouch = newGesture;
                }
            }

            
            if (touchCount > 0) {
                
                return;
            }
            break;

        case ACTION_TAP:
            
            if (!getWidgetHandler(widget, null, action)) {
                
                break;
            }
            
            
            

            
            var tapHandler = widget._tapHandler;
            if (tapHandler) {
                
                window.clearTimeout(tapHandler.h);
            }

            
            if (touchObject.date - gesture.s.date < SELECT_DURATION) {
                
                if (fireWidgetHandler(widget, 'Before', touchObject, action, gesture) === false) {
                    
                    break;
                }

                if (!widget.multiTap) {
                    
                    touchObject.count = 1;

                    
                    fireWidgetHandler(widget, null, touchObject, action, gesture);

                } else {
                    
                    if (tapHandler) {
                        
                        tapHandler.count++;
                    } else {
                        
                        tapHandler = widget._tapHandler = {
                            count: 1
                        };
                    }

                    
                    
                    tapHandler.h = window.setTimeout(function () {
                        
                        touchObject.count = tapHandler.count;

                        
                        fireWidgetHandler(widget, null, touchObject, action, gesture);

                        
                        delete widget._tapHandler;
                    }, TAP_TIMEOUT);
                }

            } else {
                
                delete widget._tapHandler;
            }
            break;
        }


        
        fireWidgetHandler(widget, EVT_END, touchObject, undefined, gesture);
    }

    
    function attachTouchEvents(widget) {

        
        var touchNode = widget._tn;
        if (!touchNode) {
            
            return;
        }

        
        if (!widget._tmCallback) {
            
            widget._tsCallback = function (e) {
                touchesBegin(widget, e);
            };
            widget._tmCallback = function (e) {
                touchesMoved(widget, e);
            };
            widget._teCallback = function (e) {
                touchesEnd(widget, e);
            };
        }

        
        $DAE(touchNode, $D.TOUCHSTART, widget._tsCallback);
    }

    
    mstrmojo._TouchGestures = mstrmojo.provide(
        "mstrmojo._TouchGestures",
        
        {
            _mixinName: 'mstrmojo._TouchGestures',

            
            singleNode: false,

            
            multiTouch: false,

            
            touchNode: null,

            
            multiTap: false,

            
            monitorInputs: false,

            
            postBuildRendering: function postBuildRendering() {
                if (this._super) {
                    this._super();
                }

                
                this._tn = this.touchNode || this.domNode;

                
                this.gestures = [];

                
                attachTouchEvents(this);
            },

            
            bubbleTouchEvent: function bubbleTouchEvent(touch) {
                var evtName = touch.methodName,
                    touchId = touch.id,
                    gesture = this.gestures[touchId],
                    p = this.parent;

                
                while (p) {
                    
                    var targetMethod = p[evtName],
                        touchBegin = p.touchBegin;

                    
                    if (targetMethod && (!touchBegin || fireWidgetHandler(p, EVT_BEGIN, touch) !== false)) {
                        
                        touch.methodName = evtName;

                        
                        deleteBubbleTargetGesture(gesture.bubbleTarget, touchId);

                        
                        gesture.bubbleTarget = p;

                        
                        p.gestures[touchId] = gesture;

                        
                        debugLog('bubble', ((this.k) ? ' ' + this.k : '') + '] bubbled ' + evtName + ' to [' + p.scriptClass + ((p.k) ? ' ' + p.k : '') + ']', this, touch);

                        
                        return targetMethod.call(p, touch);
                    }

                    
                    p = p.parent;
                }

                return false;
            },

            
            unrender: function unrender(ignoreDom) {
                
                if (isActive(this)) {
                    
                    detachWinEvts(this);
                }

                
                var touchNode = this._tn;
                if (touchNode) {
                    
                    $D.detachEvent(touchNode, $D.TOUCHSTART, this._tsCallback);
                }

                this._super(ignoreDom);
            },

            
            restoreDefaultTouches: function restoreDefaultTouches(resetFlag) {
                if ($C) {
                    
                    $C.allowDefaultTouches = resetFlag && defaultTouchConfiguration;
                }
            }
        }
    );

}());

(function() {
    mstrmojo.requiresCls("mstrmojo._Fetchable",
                         "mstrmojo.hash");

    var $H = mstrmojo.hash;
    
    function getDS() {
        var factory = mstrApp.modelFactory;
        if (factory) {
            return factory.newDataService('Element');
        } else {
            return mstrApp.viewFactory.newElementDataService();
        }
    }

    function getElementArity(elementID) {
        var count1, count2, startPos;

        count1 = -1;
        startPos = 0;
        while (startPos >= 0) {
            count1++;
            startPos = elementID.indexOf(":", startPos);
            if (startPos >= 0) 	startPos++;
        }

        count2 = -1;
        startPos = 0;
        while (startPos >= 0) {
            count2++;
            startPos = elementID.indexOf("*:", startPos);
            if (startPos >= 0) startPos++;
        }

        if (count1 < count2 + 1) {
            alert ("Unexpected format for element ID " + elementID);
        }

        return count1 - count2;
    }

	mstrmojo.requiresCls("mstrmojo.XMLBuilder", "mstrmojo.Obj");
	mstrmojo.mstr.WebElements = mstrmojo.declare(
			
			mstrmojo.Obj,
			
			[mstrmojo._Fetchable],
			
			{
			    scriptClass: 'mstrmojo.mstr.WebElements',
				
				source: null,
				
				items: null,
				duplicate: function() {
					return new mstrmojo.mstr.WebElements({
							source: $H.copy(this.source),
							browseConfig: $H.copy(this.browseConfig)
					});
				},
				
				
				browseConfig: null,				
				init: function(props) {
					var cf = props && props.browseConfig
					if (cf) {
						this.blockBegin = cf.blockBegin || 1;
						this.blockCount = cf.blockCount || 15;
					}
					if (this._super) {
						this._super(props);
					}
				},
				getBrowseConfig: function(bb){
					var config = this.browseConfig;
					return {
		                'attributeID': this.source && this.source.did || 0,
		                'blockBegin': bb || 1,
		                'blockCount': this.blockCount || -1,
		                'filterXML': config.filter && config.filter.getXML() || '',
		                'shortFilterXML' : config.shortFilterXML || '',
		                'searchPattern': config.searchPattern || '',
		                'matchCase' : !!config.matchCase,
		                'dataSourcesXML': config.dataSources || '',
		                'targetAttributeID':config.searchTarget && config.searchTarget.did || '',
		                'searchForms':config.searchForms || ''




					}
				},
				_retrieveItems: function(bb, callbacks){
				    var me = this;
					getDS().getElements(
							this.getBrowseConfig(bb)
							, 
							{
		                        success: function (res) {
		                            if (callbacks && callbacks.success) {
		                            	callbacks.success({
		                            		items: me.convertElems(res.items),
		                            		totalSize: res.totalSize
		                            	});
		                            }
		                        },
		                        failure: function (details) {
		                        	if (callbacks && callbacks.failure) {
		                        		callbacks.failure(details);
		                        	}
		                        }
		                    });

				},				
			    
				convertElems: function convertElems(items){
			        var ris = [],
			            items = items || [];
			        for (var i = 0; i < items.length; i ++) {
			            var item = items[i];
			            ris[i] = {
			                    vi: i,
			                    v: item.dssid,
			                    n: item.n,
			                    t: item.emt
			            }
			        }
			        return ris;
			    },

				
				
				
				buildShortXML: function buildShortAnswerXML(builder) {
					builder.addChild("mi");
			        builder.addChild("es");
			        if (this.source != null) {
			            this.source.buildShortObjectElt(builder);
			        }
			        
			        
			        var es = [].concat(this.items);
			        es.sort(function(e1, e2) {
			        	var n1 = e1.n,
			        	    n2 = e2.n,
			        	    res;
			        	if ( n1 === n2 ) {
			        		res = 0;
			        	} else if ( n1 < n2 ) {
			        		res = -1;
			        	} else {
			        		res = 1;
			        	}
			        	return res;
			        });
			        for (var i = 0; i < es.length; i++) {
			            var elt = es[i];
			            builder.addChild("e");
			            builder.addAttribute("ei", elt.v);
			            builder.addAttribute("emt", elt.t);
			            builder.addAttribute("art", getElementArity(elt.v));
			            builder.addAttribute("disp_n", elt.n);
			            builder.closeElement(); 
			        }
			        builder.closeElement(); 
			        builder.closeElement(); 
				}
				
			}
	);
})();
(function(){

    mstrmojo.requiresCls("mstrmojo.Obj");
    
    mstrmojo.StepperContentProvider = mstrmojo.declare(
        
        mstrmojo.Obj,
        
        
        null,
        
        {
            scriptClass: "mstrmojo.StepperContentProvider",
            
            
            item: null,
            
            
            renderer: null,
            
            
            min: null,
            
            
            max: null,
            
            
            interval: 1,

            
            minField: "min",
            
            
            maxField: "max",
            
            
            valField: "value",
            
            
            intField: "interval",
            
            
            canLoop: false,
            
            
            next: mstrmojo.emptyFn,
            
            
            prev: mstrmojo.emptyFn,
            
            
            hasPrev: mstrmojo.emptyFn,
            
            
            hasNext: mstrmojo.emptyFn,
            
            
            renderItemAt: mstrmojo.emptyFn
        }
    );
}());           
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.func",
                         "mstrmojo.Obj");

    var $HASH = mstrmojo.hash;
    
    
    var cnt = 0;

    
    var requestQueue = [];

    
    var graphRequests = {};

    
    var holdForGraphs = false;

    
    function handleSubmission(request) {
        var callback = request.callback;

        
        if (callback.submission) {
            
            callback.submission( this.userInteractionRequired( request ) );
        }

        
        this.submitRequest(request);
    }

    
    function submitNextInQueue() {
        
    	
    	
        if (requestQueue.length && !holdForGraphs) {
            
            handleSubmission.call(this, requestQueue.shift());
        }
    }

    
    mstrmojo.ServerProxy = mstrmojo.declare(
        mstrmojo.Obj,

        null,

        
        {
            scriptClass: 'mstrmojo.ServerProxy',

            
            transport: null,

            cnt: 0,

            
            request: function request(callback, params, override, config) {
                
                if (override) {
                    this.cancelRequests();
                }

                var proxyId = this.id,
                    transport = this.transport,
                    requestId = mstrmojo.now() + params.taskId + cnt++,
                    callbackCancel = callback.canceled || mstrmojo.emptyFn;

                
                callback.canceled = function (id) {
                    
                    callbackCancel();

                    
                    callback.complete(true);

                    
                    return transport.cancelRequest(id);
                };

                
                callback = mstrmojo.func.wrapMethods(callback, {
                    complete: function (id) {
                        
                        mstrmojo.all[proxyId].deleteRequest(id);
                    }
                });

                
                
                
                var existingRequests = !$HASH.isEmpty(this._requests),
                    newRequest = this.createRequest(requestId, callback, params, config),
                    
                    holdRequests = (holdForGraphs || existingRequests) && ! config.doNotHold;

                
                if (holdRequests) {
                    
                    requestQueue.push(newRequest);
                } else {
                    
                    handleSubmission.call(this, newRequest);
                }
            },

            
            createRequest: function createRequest(requestId, callback, params, config) {
                var reqsCollection = this._requests;

                
                if (!reqsCollection) {
                    
                    reqsCollection = this._requests = {};
                }

                
                var request = reqsCollection[requestId] = {
                    id: requestId,
                    callback: callback,
                    params: params,
                    config: config
                };

                
                return request;
            },

            
            submitRequest: function submitRequest(request) {
                this.transport.serverRequest(this.id, request.id, request);
            },

            
            cancelRequests: function cancelRequests() {
                var didCancel = false;

                
                $HASH.forEach(this._requests, function (request) {
                    
                    if (typeof request.gotResponse === "undefined") {
                        
                        didCancel |= request.callback.canceled(request.id);
                    }
                });

                
                this._requests = {};

                
                requestQueue = [];

                
                return didCancel;
            },

            
            response: function response(requestId, status, res) {

                
                $MAPF(false, "AndroidServerTransport", 'transportRequest');

                
                var request = this.getRequest(requestId);
                if (request) {
                    
                
                request.gotResponse = true;

                    
                var callback = request.callback,
                    methodName = (status && !res.mstrerr) ? 'success' : 'failure';  

                try {
                    
                    if (callback[methodName]) {
                        
                        callback[methodName](res, request);
                    }
                } finally {
                    
                    callback.complete(requestId);
                }
                }

                
                submitNextInQueue.call(this);
            },

            
            deleteRequest: function deleteRequest(requestId) {
                var requestCollection = this._requests;
                delete requestCollection[requestId];
            },

            
            getRequest: function getRequest(requestId) {
                var requestCollection = this._requests;
                return requestCollection && requestCollection[requestId];
            },
      
                  
            userInteractionRequired: function userInteractionRequired(request) {
                return false;
            },

            
            addLoadingGraph: function addLoadingGraph(key) {
                
                graphRequests[key] = true;

                
                holdForGraphs = true;
            },

            
            removeLoadingGraph: function removeLoadingGraph(key) {
                
                delete graphRequests[key];

                
                if ($HASH.isEmpty(graphRequests)) {
                    
                    holdForGraphs = false;

                    
                    submitNextInQueue.call(this);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.hash",
                         "mstrmojo.dom",
                         "mstrmojo.array");

    var $M = Math,
        $HS = mstrmojo.publisher.hasSubs,
        $HASH = mstrmojo.hash,
        $forEachHash = $HASH.forEach,
        $D = mstrmojo.dom;

    var VELOCITY_THRESHOLD = 0.15;      

    var INC_EDGE_START = 1,
        INC_EDGE_END = 2;

    
    var indicators = {
        y: {
            edge: [ 'top', 'bottom' ],   
            size: 0                      
        },

        x: {
            edge: [ 'left', 'right' ],   
            size: 0                      
        },

        
        clsName: 'mstrmojo-touch-scroll-indicator',

        
        init: function init() {
            
            var vertical = this.y,
                horizontal = this.x;

            
            if (!vertical.i) {
                
                var vIndicator = vertical.i = document.createElement('div');
                vIndicator.className = this.clsName;

                
                var hIndicator = horizontal.i = vIndicator.cloneNode();

                
                document.body.appendChild(vIndicator);
                document.body.appendChild(hIndicator);
            }
        },

        
        setGradient: function setGradient(indicator, scrollerAtMax, delta, containerMaxSize) {
            
            var indicatorEl = indicator.i,
                edge = indicator.edge[(scrollerAtMax) ? 1 : 0];

            
            var gradientSize = $M.min($M.round($M.min($M.abs(delta) / 200, 1) * 100), containerMaxSize / 2),
                start = 'left top',
                end = 'left bottom';

            
            if (scrollerAtMax) {
                
                end = start;

                
                if (edge === 'bottom') {
                    
                    start = 'left bottom';

                } else {
                    
                    start = 'right top';

                }

            
            } else if (edge === 'left') {
                
                end = 'right top';
            }

            
            if (gradientSize !== indicator.size) {
                
                indicatorEl.style.background = '-webkit-gradient(linear, ' + start + ', ' + end + ', from(rgba(39, 104, 162, .4)), to(rgba(39, 104, 162, 0)), color-stop(' + (gradientSize / 100) + ', rgba(39, 104, 162, 0)))';

                
                indicator.size = gradientSize;
            }
        },

        
        scrollAxis: function scroll(axis, touchPosition, constrainedPosition, widgetPosition, outOfBounds) {
            
            var delta = touchPosition - constrainedPosition,            
                isOutOfBounds = outOfBounds[axis] = (delta !== 0);      

            
            if (!isOutOfBounds) {
                
                this.hide(axis);
                return;
            }

            var indicator = this[axis],
                indicatorEl = indicator.i,
                indicatorStyle = indicatorEl.style,
                isVertical = (axis === 'y'),
                scrollerAtMax = (delta > 0),
                clsName = this.clsName + ' ' + indicator.edge[(scrollerAtMax) ? 1 : 0];

            
            if (!indicator.size || indicatorEl.className !== clsName) {

                
                indicatorEl.className = clsName;

                
                var px = 'px',
                    borderWidth = 3,
                    top = widgetPosition.y,
                    left = widgetPosition.x,
                    height = 100,
                    width = widgetPosition.w;

                
                if (isVertical) {
                    
                    if (scrollerAtMax) {
                        
                        top += widgetPosition.h - height - borderWidth;
                    }

                } else {
                    
                    width = height;
                    height = widgetPosition.h;

                    
                    if (scrollerAtMax) {
                        
                        left += widgetPosition.w - width - borderWidth;
                    }
                }

                
                indicatorStyle.top = top + px;
                indicatorStyle.left = left + px;
                indicatorStyle.width = width + px;
                indicatorStyle.height = height + px;

                
                indicatorStyle.display = 'block';
            }

            
            this.setGradient(indicator, scrollerAtMax, delta, (isVertical) ? widgetPosition.h : widgetPosition.w);
        },

        scroll: function scroll(scroller, position, constrainedX, constrainedY, scrollEl) {
            
            var x = position.x,
                y = position.y;

            
            if (x !== constrainedX || y !== constrainedY) {
                
                this.init();

                
                var widgetPosition = this._widgetPosition;
                if (!widgetPosition) {
                    var el = scroller.indicatorEl || scrollEl;
                    
                    widgetPosition = mstrmojo.dom.position(el.parentNode);
                }

                
                var outOfBounds = scroller._outOfBounds || {};

                
                this.scrollAxis('y', y, constrainedY, widgetPosition, outOfBounds);
                this.scrollAxis('x', x, constrainedX, widgetPosition, outOfBounds);

                
                this._widgetPosition = widgetPosition;

                
                scroller._outOfBounds = outOfBounds;

            } else {
                
                this.hideAll();

                
                delete scroller._outOfBounds;

            }
        },


        
        hide: function hide(axis) {
            
            var a = this[axis];
            if (a.size !== undefined) {
                
                a.i.style.display = 'none';
                a.i.className = this.clsName;

                
                a.size = 0;
            }
        },

        
        hideAll: function hideAll() {
            
            this.hide('y');
            this.hide('x');

            
            delete this._widgetPosition;
        }
    };

    
    function constrainPoint(value, offset) {
        return (offset) ? $M.max($M.min($M.round(value), offset.end), offset.start) : value;
    }

    function raiseScrollerEvent(scroller, evtName, evtObj) {
        
        evtObj.name = evtName;
        evtObj.id = scroller.identifier;

        
        scroller.raiseEvent(evtObj);
    }


    
    function stopDecelOnScrollDone() {
        
        
        
        var evtName = 'scrollDone',
            origin = this.origin;
        if ($HS(this.id, evtName) && origin) {
            raiseScrollerEvent(this, evtName, {
                x: origin.x,
                y: origin.y
            });
        }

        this.stopDeceleration();
    }

    
    function applyPosition(scroller, position, duration) {
        var scrollEl = scroller.scrollEl;
        
        
        if (!scrollEl) {
        	stopDecelOnScrollDone.call(scroller);
            return;
        }
        
        var positions = {
                x: position.x || 0,
                y: position.y || 0
            };

        
        $forEachHash(scroller._scrollBarEls, function (bar, axis) {
            var isX = (axis === 'x'),
                position = positions[axis],
                length = bar.length,
                ratio = bar.ratio,
                viewportSize = bar.viewportSize,
                minScale = 6 / length,
                minPosition = bar['base' + ((isX) ? 'Left' : 'Top')],
                maxPosition = minPosition + viewportSize - length,
                newPosition = $M.round(minPosition + (ratio * position));

            
            if (newPosition < minPosition) {
                newPosition = minPosition - position;
                length += position;
            } else if (newPosition > maxPosition) {
                var delta = (position - scroller.offset[axis].end) * ratio;
                newPosition = $M.min(maxPosition + delta, viewportSize + minPosition - 6) - 1;
                length -= delta;
            }

            
            var v = 0,
                translate = [v, v, v],
                scale = [1, 1, 1],
                idx = (isX) ? 0 : 1;

            translate[idx] = (newPosition - minPosition);
            scale[idx] = $M.min($M.max(length / bar.length, minScale), 1);

            $D.translate(bar, translate[0], translate[1], translate[2], ' scale3d(' + scale.join(',') + ')');
        });

        if (duration) {
            duration += 'ms';
        }

        
        if (scroller._isHosted) {
            
            var parentNode = scrollEl.parentNode;
            parentNode.scrollTop = positions.y;
            parentNode.scrollLeft = positions.x;
        } else {
            
            scrollEl.style[$D.CSS3_TRANSITION_DURATION] = duration || '0';    
            $D.translate(scrollEl, -positions.x, -positions.y, 0, scroller.transform, scroller.useTranslate3d);
        }

        
        if ($HS(scroller.id, 'scrollMoved')) {
            
            raiseScrollerEvent(scroller, 'scrollMoved', {
                x: position.x,
                y: position.y
            });
        }
    }

    
    function fnGetTime(finalVelocity, initialVelocity, friction) {
        return $M.ceil(1 + $M.log(finalVelocity / $M.abs(initialVelocity)) / $M.log(1 - friction));
    }

    
    function fnGetPosition(position, directionMultiplier, initialVelocity, timeInterval, friction) {
        return position + (directionMultiplier * (initialVelocity * (1 - $M.pow(1 - friction, timeInterval)) / friction));
    }

    
    function calculateAxisPosition(scroller, position, axis, direction, velocity, delta, totalTime) {
        var offset = scroller.offset[axis];     

        
        if (!offset) {
            
            return position;
        }

        var outOfBounds = scroller._outOfBounds,
            isAxisOutOfBounds = outOfBounds && outOfBounds[axis],   
            incFetch = offset.incFetch,                             
            friction = scroller.friction,
            start = offset.start,
            end = offset.end,
            limit = (direction) ? end : start;                      

        
        velocity = $M.abs(velocity);

        
        if (isAxisOutOfBounds) {
            
            direction = (position < start);
            limit = (direction) ? start : end;
        }

        var directionMultiplier = (direction) ? 1 : -1;

        
        if (isAxisOutOfBounds && (direction || !incFetch)) {
            
            
            
            var finalVelocity = VELOCITY_THRESHOLD * 3,
                a = 1 / (1 - friction),
                initialVelocity = finalVelocity / $M.pow((1 - friction), ($M.log(1 - $M.abs(position - limit) * (1 - a) / finalVelocity) / $M.log(a)) - 1);

            
            var calculatedPosition = $M.round(fnGetPosition(position, directionMultiplier, initialVelocity, delta, friction));

            
            if (direction ? (calculatedPosition >= limit) : (calculatedPosition <= limit)) {
                
                stopDecelOnScrollDone.call(scroller);

                
                return limit;
            }

            
            return calculatedPosition;

        }

        
        var pageSize = offset.pageSize,
            supportedEdges = offset.supportedEdges;


        
        var newPosition = fnGetPosition(position, directionMultiplier, velocity, delta, friction),
            bStart = (newPosition <= start),
            bEnd = (newPosition >= end);

        
        if (bStart || bEnd) {

            
            if (incFetch && ((bStart && ((supportedEdges & INC_EDGE_START) > 0)) ||
                    (bEnd && ((supportedEdges & INC_EDGE_END) > 0)))) {

                
                if (newPosition - end >= pageSize) {
                    
                    newPosition = end + pageSize;

                    
                    limit = newPosition;
                }

                if (!scroller.STATUS_INC_FETCH) {
                    
                    scroller.STATUS_INC_FETCH = true;

                    
                    raiseScrollerEvent(scroller, 'incFetch', {
                        edge: bEnd ? INC_EDGE_END : INC_EDGE_START
                    });
                }

            } else {

                
                if (scroller.bounces) {

                    
                    var bounceFriction = friction * 2,
                        bVelocity = scroller.bounceVelocity,
                        bTime = scroller.bounceTime,
                        bDistance = scroller.bounceDistance;

                    
                    if (!scroller.hasBounced) {
                        
                        bVelocity[axis] = $M.abs(VELOCITY_THRESHOLD / $M.pow(1 - friction, totalTime - delta - 1));

                        
                        bTime[axis] = fnGetTime(VELOCITY_THRESHOLD, bVelocity[axis], bounceFriction);

                        
                        bDistance[axis] = $M.abs(fnGetPosition(newPosition, directionMultiplier, bVelocity[axis], bTime[axis], bounceFriction) - newPosition);

                        
                        scroller.raiseEvent({
                            name: 'bounceOut',
                            id: scroller.identifier,
                            axis: axis,
                            direction: direction,
                            value: $M.round(newPosition)
                        });

                        
                        scroller.hasBounced = true;
                    }

                    var bounceLimit = Math.floor(bDistance[axis] / 2);

                    
                    var bouncePosition = fnGetPosition(limit, directionMultiplier, bVelocity[axis], delta, bounceFriction),
                        travelDistance = $M.abs(bouncePosition - limit);

                    
                    if ($M.abs(travelDistance) < bounceLimit) {
                        
                        return bouncePosition;
                    }

                    
                    if ($M.abs(travelDistance) >= bDistance[axis]) {
                        
                        stopDecelOnScrollDone.call(scroller);
                        return limit;
                    }

                    
                    var limitDistance = bounceLimit - (travelDistance - bounceLimit);
                    return $M.round(limit - ((direction) ? -limitDistance : limitDistance));  
                }

                
                newPosition = limit;
            }
        }

        
        return $M.round(newPosition);
    }

    
    function detachHostedScrollListener(el) {
        var scrollListener = this._scrollListener;
        if (scrollListener) {
            if (!el || el !== scrollListener.el) {
                $D.detachEvent(scrollListener.el, 'scroll', scrollListener.fn);
                delete this._scrollListener;

                return true;
            }

            return false;
        }

        return true;
    }

    
    var $TOUCHSCROLLER = mstrmojo.TouchScroller = mstrmojo.declare(
        mstrmojo.Obj,

        null,

        
        {
            scriptClass: "mstrmojo.TouchScroller",

            
            scrollEl: null,

            
            identifier: '',

            
            hScroll: false,

            
            vScroll: false,

            
            offset: null,

            
            origin: null,

            
            transform: '',

            
            friction: 0.0015,

            
            frameRate: 60,

            
            bounces: true,

            
            hasBounced: false,

            
            bounceDistance: {},

            
            bounceTime: {},

            
            bounceVelocity: {},

            
            showScrollbars: false,

            
            showIndicators: true,

            
            useTranslate3d: true,

            
            STATUS_INC_FETCH: false,

            
            init: function init(props) {
                this._super(props);

                
                indicators.init();
            },

            
            initScroller: function initScroller(props) {
                
                $HASH.copy(props, this);

                
                var scrollEl = this.scrollEl;
                if (scrollEl) {
                    
                    var isHosted = this._isHosted = false; 
                    if (isHosted) {
                        var parentNode = scrollEl.parentNode;

                        
                        if (detachHostedScrollListener.call(this, parentNode)) {
                            
                            parentNode.style.overflow = 'auto';

                            
                            var id = this.id,
                                listener = this._scrollListener = {
                                    el: parentNode,
                                    fn: function (evt) {
                                        var origin = mstrmojo.all[id].origin,
                                            target = evt.target;

                                        origin.x = target.scrollLeft;
                                        origin.y = target.scrollTop;
                                    }
                                };

                            
                            $D.attachEvent(parentNode, 'scroll', listener.fn);
                        }

                        
                        this.showScrollbars = false;
                    }
                }
            },

            
            canScroll: function canScroll() {
                return this.vScroll || this.hScroll;
            },

            
            updateScrollBars: function updateScrollBars(viewportCoords, scrollBarContainerElement) {
                var scrollEl = this.scrollEl;

                
                if (!this.showScrollbars || !scrollEl) {
                    
                    return;
                }

                var bars = this._scrollBarEls;

                
                if (!bars) {
                    var me = this;
                    bars = this._scrollBarEls = {
                        x: 'hScroll',
                        y: 'vScroll'
                    };

                    
                    $forEachHash(bars, function (scroll, axis) {
                        
                        if (me[scroll]) {
                            
                            var bar = document.createElement('div');
                            bar.className = 'mstrmojo-touch-scrollBar ' + axis + 'Axis';

                            
                            (scrollBarContainerElement || scrollEl.parentNode).appendChild(bar);
                            bars[axis] = bar;
                        } else {
                            
                            delete bars[axis];
                        }
                    });
                }

                
                if (!viewportCoords) {
                    
                    var parentNode = this.scrollEl.parentNode;
                    viewportCoords = {
                        top: 0,
                        right: parentNode.clientWidth,
                        bottom: parentNode.clientHeight,
                        left: 0
                    };
                }

                
                var offset = 9,
                    scrollBarCoords = {
                        x: {
                            left: viewportCoords.left,
                            top: viewportCoords.bottom - offset,
                            x: viewportCoords.right - viewportCoords.left,
                            d: 'Width'
                        },
                        y: {
                            left: viewportCoords.right - offset,
                            top: viewportCoords.top,
                            x: viewportCoords.bottom - viewportCoords.top,
                            d: 'Height'
                        }
                    };

                
                $forEachHash(bars, function (bar, axis) {
                    var barStyle = bar.style,
                        coords = scrollBarCoords[axis],
                        dimension = coords.d,
                        parentNode = bar.parentNode,
                        x = coords.x;

                    
                    var left = coords.left,
                        top = coords.top,
                        ratio = x / scrollEl['offset' + dimension],
                        length = Math.min(Math.round(x * ratio), x);

                    
                    bar.baseLeft = left;
                    bar.baseTop = top;
                    bar.ratio = ratio;
                    bar.viewportSize = x;
                    bar.length = length;

                    
                    barStyle.left = left + 'px';
                    barStyle.top = top + 'px';
                    barStyle[dimension.toLowerCase()] = length + 'px';
                });
            },

            
            toggleScrollBars: function toggleScrollBars(visible) {
                
                $forEachHash(this._scrollBarEls, function (bar) {
                    
                    bar.style.opacity = (visible) ? 1 : 0;
                });
            },

            
            scrollTo: function (x, y, duration) {
                
                if (!this.canScroll() && !(x === 0 && y === 0)) {
                    
                    
                    applyPosition(this, {
                        x: 0,
                        y: 0
                    });

                    
                    return;
                }

                
                var offset = this.offset,
                    origin = this.origin,
                    position = {
                        x: (this.hScroll) ? constrainPoint(x, offset.x) : 0,
                        y: (this.vScroll) ? constrainPoint(y, offset.y) : 0
                    };

                
                applyPosition(this, position, duration);

                
                origin.x = position.x;
                origin.y = position.y;
            },

            
            scrollToEnd: function (x, y, duration) {
                var origin = this.origin,
                    offset = this.offset,
                    result = {
                        x: 0,
                        y: 0
                    };

                
                if (origin && offset) {
                    
                    mstrmojo.array.forEach([ x, y ], function (scroll, idx) {
                        
                        var axis = (idx) ? 'y' : 'x',
                            axisOffset = offset[axis];

                        
                        result[axis] = (scroll) ? (axisOffset && axisOffset.end) || 0 : origin[axis];
                    });
                }

                
                this.scrollTo(result.x, result.y, duration);
            },

            
            scroll: function scroll(touch) {
                
                if (this._isHosted) {
                    
                    return;
                }

                var offset = this.offset,
                    scrollEl = this.scrollEl,
                    touchDelta = touch.delta,
                    touchDeltaX = touchDelta.x,
                    touchDeltaY = touchDelta.y;

                
                if (!scrollEl) {
                    
                    return;
                }

                
                if (!offset && this.showIndicators) {
                    
                    indicators.scroll(this, {
                        x: (this.noHScroll) ? 0 : -touchDeltaX,
                        y: (this.noVScroll) ? 0 : -touchDeltaY
                    }, 0, 0, scrollEl);

                    return;
                }

                
                var origin = this.origin,
                    position = {
                        x: (this.hScroll) ? $M.round(origin.x - touchDeltaX) : 0,
                        y: (this.vScroll) ? $M.round(origin.y - touchDeltaY) : 0
                    },
                    constrainedX = constrainPoint(position.x, offset.x),
                    constrainedY = constrainPoint(position.y, offset.y);

                
                if (!offset.scrollPast) {
                    
                    if (this.showIndicators) {
                        
                        indicators.scroll(this, position, constrainedX, constrainedY, scrollEl);
                    }

                    
                    position.x = constrainedX;
                    position.y = constrainedY;

                } else {
                    
                    var isXAxisOutOfBounds = (constrainedX !== position.x),
                        isYAxisOutOfBounds = (constrainedY !== position.y),
                        isOutOfBounds = (isXAxisOutOfBounds || isYAxisOutOfBounds),
                        outOfBounds = this._outOfBounds,
                        evtName = '';

                    
                    if (outOfBounds) {
                        
                        if (isXAxisOutOfBounds !== (outOfBounds.x === true) || isYAxisOutOfBounds !== (outOfBounds.y === true)) {
                            
                            evtName = 'scrollIn';
                        }

                    
                    } else if (isOutOfBounds) {
                        
                        evtName = 'scrollOut';
                    }

                    
                    if (evtName) {
                        
                        if ($HS(this.id, evtName)) {
                            
                            var direction = touch.direction;
                            raiseScrollerEvent(this, evtName, {
                                x: {
                                    position: position.x,
                                    direction: direction.x
                                },
                                y: {
                                    position: position.y,
                                    direction: direction.y
                                }
                            });
                        }

                        
                        if (isOutOfBounds) {
                            
                            this._outOfBounds = {
                                x: isXAxisOutOfBounds,
                                y: isYAxisOutOfBounds
                            };
                        } else {
                            
                            delete this._outOfBounds;
                        }
                    }
                }

                
                applyPosition(this, position);
            },

            
            scrollEnd: function scrollEnd(touch) {
                
                indicators.hideAll();

                
                if (!this.canScroll() || this._isHosted) {
                    
                    return;
                }

                var id = this.id,
                    friction = this.friction,
                    a = 1 / (1 - friction),
                    initialPosition = this.origin,
                    initialVelocity = touch.velocity,
                    direction = touch.direction,
                    startTime = new Date(),
                    outOfBounds = this._outOfBounds,
                    offset = this.offset,
                    canScrollAxis = {
                        x: this.hScroll,
                        y: this.vScroll
                    },
                    velocity = {},
                    position = {},
                    directionMultiplier = {},
                    totalTime = {},
                    totalDistance = {},
                    finalVelocity = {},
                    start = {},
                    end = {},
                    limit = {},
                    initializeVars = function (axis) {
                        
                        finalVelocity[axis] = VELOCITY_THRESHOLD;

                        
                        var axisOffset = offset[axis],
                            axisIsOutOfBounds = (outOfBounds && outOfBounds[axis]),
                            indicatorVisible = (axisIsOutOfBounds && (!axisOffset || !offset.scrollPast));

                        
                        position[axis] = (canScrollAxis[axis] && !indicatorVisible) ? initialPosition[axis] - touch.delta[axis] : initialPosition[axis];

                        if (axisOffset) {
                            
                            start[axis] = axisOffset.start;
                            end[axis] = axisOffset.end;

                            
                            if (axisIsOutOfBounds) {
                                if (!indicatorVisible) {
                                    
                                    direction[axis] = (position[axis] < start[axis]);
                                    limit[axis] = (direction[axis]) ? start[axis] : end[axis];

                                    
                                    if (direction[axis] || !axisOffset.incFetch) {
                                        
                                        
                                        
                                        finalVelocity[axis] = VELOCITY_THRESHOLD * 3;
                                        initialVelocity[axis] = finalVelocity[axis] / $M.pow((1 - friction), ($M.log(1 - $M.abs(position[axis] - limit[axis]) * (1 - a) / finalVelocity[axis]) / $M.log(a)) - 1);
                                    }
                                } else {
                                    
                                    position[axis] = constrainPoint(initialPosition[axis] - touch.delta[axis], axisOffset);
                                }
                            }
                        }

                        
                        velocity[axis] = (canScrollAxis[axis] && !indicatorVisible) ? $M.abs(initialVelocity[axis]) : 0;

                        directionMultiplier[axis] = (direction[axis] || false) ? 1 : -1;

                        
                        totalTime[axis] = fnGetTime(finalVelocity[axis], velocity[axis], friction);
                        totalDistance[axis] = fnGetPosition(position[axis], directionMultiplier[axis], velocity[axis], totalTime[axis], friction);
                    };

                
                initializeVars('x');
                initializeVars('y');

                
                initialPosition.x = position.x;
                initialPosition.y = position.y;

                
                var decelerateX = (velocity.x > 0),
                    decelerateY = (velocity.y > 0);

                
                if (!offset.scrollPast && !decelerateX && !decelerateY) {
                    
                    stopDecelOnScrollDone.call(this);

                    
                    var axis,
                        offsetObj,
                        bStart,
                        bEnd,
                        supportedEdges;

                    for (axis in offset) {
                        offsetObj = offset[axis];

                        supportedEdges = offsetObj.supportedEdges;

                        bStart = ((offsetObj.start === position[axis]) && ((supportedEdges & INC_EDGE_START) > 0));
                        bEnd = ((offsetObj.end === position[axis]) && ((supportedEdges & INC_EDGE_END) > 0));

                        
                        if (offsetObj.incFetch && (bStart || bEnd)) {
                            
                            this.STATUS_INC_FETCH = true;

                            
                            raiseScrollerEvent(this, 'incFetch', {
                                edge: (bEnd) ? INC_EDGE_END : INC_EDGE_START
                            });
                        }
                    }


                    
                    return;
                }

                
                this.hasBounced = false;
                this.bounceDistance = {};
                this.bounceTime = {};
                this.bounceVelocity = {};

                
                this.decelerating = true;

                var expectedInterval = Math.round(1000 / this.frameRate),           
                    prevTime = startTime,                                           
                    actualInterval,                                                 
                    axisIterator = {
                        x: decelerateX,
                        y: decelerateY
                    };

                
                this.decelerationTimer = window.setTimeout(function () {
                    var scroller = mstrmojo.all[id],
                        origin = scroller.origin,
                        curTime = new Date(),
                        delta = (curTime - startTime),
                        axis;

                    
                    if (scroller._halt) {
                        stopDecelOnScrollDone.call(scroller);
                        return;
                    }

                    
                    actualInterval = curTime - prevTime;
                    prevTime = curTime;

                    if (actualInterval > (expectedInterval + 5)) {
                        expectedInterval = expectedInterval + $M.round((actualInterval - expectedInterval) / 2);
                    }

                    
                    for (axis in axisIterator) {
                        
                        if (axisIterator[axis]) {
                            
                            var newPosition = calculateAxisPosition(scroller, position[axis], axis, direction[axis], velocity[axis], delta, totalTime[axis]);

                            
                            if (!isNaN(newPosition)) {
                                
                                origin[axis] = newPosition;
                            }
                        }
                    }

                    
                    applyPosition(scroller, origin);

                    
                    var stopDecel = (delta > totalTime.x && delta > totalTime.y);
                    if (!stopDecel && !scroller.bounces) {

                        
                        stopDecel = true;

                        
                        mstrmojo.hash.forEach(offset, function (axis, key) {
                            
                            var v = origin[key];

                            
                            if (v !== axis.end && v !== axis.start) {
                                
                                stopDecel = false;

                                
                                return false;
                            }
                        });
                    }

                    
                    if (stopDecel) {
                        stopDecelOnScrollDone.call(scroller);

                    } else if (scroller.decelerating) {
                        
                        scroller.decelerationTimer = window.setTimeout(arguments.callee, expectedInterval);
                    }

                }, expectedInterval);

            },

            
            stopDeceleration: function stopDeceleration() {
                
                var isDecelerating = !!this.decelerating;
                if (isDecelerating) {
                    
                    if (this.decelerationTimer) {
                        
                        window.clearTimeout(this.decelerationTimer);
                        delete this.decelerationTimer;
                    }

                    
                    delete this.decelerating;

                    
                    this.toggleScrollBars(false);
                }

                
                delete this._outOfBounds;
                delete this.hasBounced;
                delete this.bounceDistance;
                delete this.bounceTime;
                delete this.bounceVelocity;
                delete this._halt;

                return isDecelerating;
            },

            haltScroller: function haltScroller() {
                this._halt = !!this.decelerating;
            },

            unrender: function unrender() {
                
                delete this.scrollEl;
            },

            
            destroy: function destroy() {
                
                this.stopDeceleration();

                detachHostedScrollListener.call(this);

                this._super();
            }


        }
    );

    
    mstrmojo.TouchScroller.getScrollPositionTotals = function getScrollPositionTotals(widget) {
        var parent = widget.parent,
            scroller = widget._scroller,
            origin = mstrmojo.hash.copy((scroller && scroller.origin) || {      
                x: 0,
                y: 0
            });

        
        if (parent) {
            
            var parentOrigin = mstrmojo.TouchScroller.getScrollPositionTotals(parent);
            origin.x += parentOrigin.x;
            origin.y += parentOrigin.y;
        }

        return origin;
    };

    
    mstrmojo.TouchScroller.ScrollIndicators = indicators;

    
    $TOUCHSCROLLER.EnumIncFetchEdges = {
        start: INC_EDGE_START,
        end: INC_EDGE_END
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.array",
                         "mstrmojo.color",
                         "mstrmojo.hash",
                         "mstrmojo.num",
                         "mstrmojo.storage.DOMLocalStorage",
                         "mstrmojo.StringBuffer",
                         "mstrmojo.android.EnumMenuOptions");

    mstrmojo.requiresDescs(1089, 1143, 7830, 7831, 7832, 7859, 7860, 7861, 7862, 8621);

    var $A = mstrmojo.array,
        $AFE = $A.forEach,
        $HASH = mstrmojo.hash,
        $MENUS = mstrmojo.android.EnumMenuOptions,
        _cacheKey = "CacheEnabled",

        _verifyJsonKey = "VerifyJson",
        _diagnosticModeKey = "DiagnosticMode",

        EnumHSButtonType = {
            FOLDER: 1,
            RESULTSET: 2,
            REPORTS: 3,
            SETTINGS: 4,
            SHAREDLIBRARY: 5,
            SUBSCRIPTIONS: 8,
            HELP: 6
        };

    function isObject(o) {
        return (typeof o === 'object');
    }

    function getColor(clr) {
        
        if (isObject(clr)) {
            
            if (clr.tp) {
                return 'transparent';
            }

            
            clr = clr.clr;
        }

        
        return mstrmojo.color.decodeColor(clr);
    }

    function findServer(project) {
        var servers = this.getWebServersList(),
            res = null;
        $AFE(servers, function (server) {
            $AFE(server.pl, function (proj) {
                if (proj === project) {
                    res = server;
                    return false;
                }
            });
            return !res;
        });
        return res;
    }

    function iterateProjects(searchConfig, serversNode, projectCache) {
        var serverCache = projectCache ? projectCache.servers : [],
            projectFound = false;

        
        $AFE(serversNode, function (server) {

            
            $AFE(server.pl, function (project) {
                var id = project.pid;

                
                if (id !== undefined) {
                    
                    
                    if (projectCache) {
                        projectCache[id] = project;
                        serverCache[id] = server;
                    }

                    
                    if (project[searchConfig.n] === searchConfig.v) {
                        
                        projectFound = true;

                        
                        return false;
                    }
                }
            });

            
            if (projectFound) {
                
                return false;
            }
        });

        return projectFound;
    }

    
    function reconcileHSType(hsType) {

        var projectID = getHSProjectID.call(this, hsType),
            hscNode = this._cfg.hsc,
            projectExists;

        
        if (!projectID) {
            return;
        }

        projectExists = iterateProjects({
            n: 'pid',
            v: projectID
        }, this.getWebServersList());

        if (!projectExists) {

            
            hscNode.tp = 1;

            switch (hsType) {
            case 3:     
                delete hscNode.rs;
                break;
            case 4:     
                delete hscNode.fd;
                break;
            }
        }
    }

    
    function getHSProjectID(hsType) {

        var projectID,
            hscNode = this._cfg.hsc;

        switch (hsType) {
        case 3:     
            projectID = hscNode.rs.oi.pid;
            break;
        case 4:     
            projectID = hscNode.fd.oi.pid;
            break;
        }

        return projectID;
    }

    function buildCustomHomeScreen(hsc, asFolder) {
        var ths = this,
            cst = hsc.cst,
            btns = [],
            hscType = ths.getHomeScreenType(),
            devType = ths.getDeviceType();

        if (hscType === 1 &&  devType !== 4 ) {
            var addSubsButton = true;

	        
	        
	        

	        
	        $AFE(cst.btns, function (btn) {
	            

	            
	            
	            if ((btn.act === EnumHSButtonType.SUBSCRIPTIONS) || (btn.act === EnumHSButtonType.REPORTS)) {
	                
	                addSubsButton = false;
	                return false;
	            }
	        });

	        
	        
	        if (addSubsButton && (hscType === 1 || (devType === 4 && hscType === 2 && cst.fmt.vw.rpt))) {
	            btns.push({
	                act: EnumHSButtonType.SUBSCRIPTIONS,
	                txt: mstrmojo.desc(1089, 'Subscriptions'),
	                dsc: ""
	            });
	        }
        }

        
        $AFE(cst.btns, function (btn) {
            

            
            
            
            var xlt = ths.xlat[$A.find(ths.xlat, 'act', btn.act)],
	            
	            
	            
                txt = xlt ? (btn.cap === xlt.dcp ? xlt.cap : btn.cap) : btn.cap,
                dsc = xlt ? xlt.dsc : btn.dsc,
                b = {};

            if ( asFolder ) {
            	b.n = txt;
            	b.desc = dsc;
            } else {
            	b.txt = txt;
            	b.dsc = dsc;
            }
            
            var icon = btn.icn;
            if (isObject(icon)) {
                
                b.icn = icon.img;
            }

            
            var action = btn.act;

            
            if (isObject(action)) {
                
                
                
                var objInfo = (action.fd && action.fd.oi) || (action.rs && action.rs.oi) || action.rs;

                
                b.did = objInfo.did;
                
                b.t = objInfo.t;
                b.st = objInfo.st;
                b.pid = objInfo.pid;

                
                b.ab = objInfo.ab;
                
                b.csp = !!(action.fd && action.fd.csp);

            } else {

                
                b.act = action;

                
                if (b.act === EnumHSButtonType.SETTINGS && !ths.getGeneralSettings().uas) {
                    
                    b = null;
                }
            }

            
            if (b) {
                btns.push(b);
            }
        });

        var config = {
                btns: btns,
                fmt: {},
                ttl: ""
            },

            
            
            
            fmt = cst.btns ? cst.fmt : cst;

        
        if (fmt) {
            var bgFmt = fmt.bkg,
                btnFmt = fmt.btn;

            config.fmt = {
                bg: {
                    tp: bgFmt.tp,                                                
                    v: (bgFmt.tp === 1) ? getColor(bgFmt.fll.clr) : bgFmt.img    
                },
                btn: {
                    bc: getColor(btnFmt.brd),   
                    bg: getColor(btnFmt.fll),   
                    c: getColor(btnFmt.fnt),    
                    sty: btnFmt.stl             
                }
            };

            config.ttl = fmt.ttl.cap;
        }

        if (devType === 4) {        
            config.hlp = fmt.vw.hlp;            
        }

        return config;
    }

    function _loadConfiguration() {

        
        var cfg = mstrMobileApp.getConfiguration();



        
        
        return eval('(' + cfg + ')');
        
    }

    

    function _initializePrjCache(cfg) {
        
        cfg._hostUrls = {};
        cfg._projects = {
            servers: {}
        };
    }

    
    function _clearCachedValues() {
        
        delete this._hsType;
        delete this._hsCfg;
        delete this._wsl;
        delete this._gnl;
    }

    
    mstrmojo.MobileConfiguration = mstrmojo.declare(
        mstrmojo.Obj,

        null,

        
        {
            scriptClass : 'mstrmojo.MobileConfiguration',

            
            _cfg: null,

            
            xlat: null,

            init: function init(props) {

                var xl = this.xlat = [],
                    md = mstrmojo.desc;
                xl.push({   
                    act: 5,
                    cap: md(7832),
                    dsc: md(7859),
                    dcp: "Shared Library"
                });
                xl.push({   
                    act: 4,
                    cap: md(7831),
                    dsc: md(7861),
                    dcp: "Settings"
                });
                xl.push({  
                    act: 6,
                    cap: md(1143),
                    dsc: md(7862),
                    dcp: "Help"
                });
                xl.push({  
                    act: 3,
                    cap: md(7830),
                    dsc: md(7860),
                    dcp: "Reports"
                });
                xl.push({  
                    act: EnumHSButtonType.SUBSCRIPTIONS,
                    cap: md(1089),
                    dsc: md(7860),
                    dcp: "Subscriptions"
                });


                this._super(props);

                this._cfg = this._cfg || _loadConfiguration();

                
                _initializePrjCache(this);

                this.cacheEnabled = $LS.getItem(_cacheKey) || false;

                
                this.binaryMode = mstrMobileApp.useBinaryFormat();

                this.verifyJson = $LS.getItem(_verifyJsonKey) === true;

                this.diagnosticMode = mstrMobileApp.getDiagnosticMode();
            },

            
            getConfiguration: function () {

                return this._cfg;
            },

            
            saveConfiguration: function (silently) {

                
                _clearCachedValues.call(this);

                
                _initializePrjCache(this);

                mstrMobileApp.saveConfiguration(JSON.stringify(this._cfg), !!silently);
            },

            reloadDefaultConfiguration: function () {

                
                mstrMobileApp.reloadDefaultConfiguration();

                this._cfg = _loadConfiguration();

                
                _clearCachedValues.call(this);

                
                _initializePrjCache(this);
            },

            setWebServerList: function (wsl) {
                this._wsl = this._cfg.cty.wsl = wsl;

                
                _initializePrjCache(this);

                return this;
            },

            

            getWebServersList: function () {
                if (!this._wsl) {
                    this._wsl = this._cfg.cty.wsl || [];
                }
                return this._wsl;
            },

            

            getGeneralSettings: function () {
                if (!this._gnl) {
                    this._gnl = this._cfg.gnl;
                }
                return this._gnl;
            },

            getDefaultServerCreds: function () {
                var cty = this._cfg.cty;
                cty.wsdc = cty.wsdc || {
                    am: 1,
                    lo: '',
                    ps: ''
                };
                return cty.wsdc;
            },

			getBackgroundSyncSettings: function () {
				var gnl = this.getGeneralSettings();
				gnl.bss = gnl.bss || {
					ebs: false,
					ui: 4,
					tod: 0,
					wo: false,
					co: false
				};
				gnl.bss.wo = gnl.bss.wo || false; 
				gnl.bss.co = gnl.bss.co || false; 
				return gnl.bss;
			},

            setDefaultServerCreds: function (sd) {
                var cty = this._cfg.cty;

                $HASH.copy(sd, cty.wsdc);
                return this;
            },

            getCacheEnabled: function () {
                
                return false;

            },

            setCacheEnabled: function (c) {
                this.cacheEnabled = c;
                $LS.setItem(_cacheKey, c, -1);
            },

            getBinaryMode: function () {
                return this.binaryMode;
            },

            setBinaryMode: function (v) {
                if (this.binaryMode !== v) {
                    this.binaryMode = v;
                    mstrApp.serverProxy.closeAllSessions();
                    mstrApp.useBinaryFormat = v;
                    
                    mstrMobileApp.setBinaryFormat(v);
                }
            },

            
            getDeviceType: function () {
                return this._cfg.dt;
            },

            isSubscriptionEnabled: function () {
            	return this.getHomeScreenType() != 2 ? true : !!this._cfg.hsc.cst.fmt.vw.rpt;
            },

            getVerifyJson: function () {
                return this.verifyJson;
            },

            getDiagnosticMode: function () {
                return this.diagnosticMode;
            },

            setDiagnosticMode: function (v) {
                if (this.diagnosticMode !== v) {
                    this.diagnosticMode = v;

                    $LS.setItem(_diagnosticModeKey, v, -1);

                    mstrApp.diagnosticMode = v;

                    
                    mstrMobileApp.setDiagnosticMode(v);
                }
            },

            getSettingsAllowed: function getSettingsAllowed() {
                return this.getGeneralSettings().uas;
            },

            
            isMenuAllowed: function isMenuAllowed(menuItem, menuMask) {
                
                if ((menuMask & menuItem) > 0) {
                    
                    var generalSettings = this.getGeneralSettings(),
                    	vw = this._cfg.hsc.cst ?  this._cfg.hsc.cst.fmt.vw : {stg: true, hlp: true};

                    
                    switch (menuItem) {
                    case $MENUS.SETTINGS:
                        
                    	return !!generalSettings.uas && !!vw.stg;
                    case $MENUS.HELP:
                    	return !!vw.hlp;
                    case $MENUS.SHARE:
                    	var project = this.getProject(mstrApp.getCurrentProjectId());
                        return (!!generalSettings.es && project && !!project.es);

                    case $MENUS.LEARN:
                        
                        return !!generalSettings.slml;

                    default:
                        return true;
                    }
                }

                return false;
            },

            

            reconcileHomescreen: function reconcileHomescreen() {
                var ths = this,
                    hsType = ths.getHomeScreenType(),
                    hs = this._cfg.hsc;

                switch (hsType) {
                case 1:     
                	break;
                case 2:     
                    var btns = [];

                    

                    $AFE(hs.cst.btns, function (btn) {
                        var action = btn.act;

                        
                        if (isObject(action)) {
                            
                            var objInfo = (action.fd && action.fd.oi) || (action.rs && action.rs.oi) || action.rs;

                            
                            if (ths.getProject(objInfo.pid) !== undefined) {
                                
                                btns.push(btn);
                            }
                        } else {
                            
                            btns.push(btn);
                        }
                    });

                    
                    if (!btns.length) {
                        btns.push({
                            'act': 5,
                            'cap': mstrmojo.desc(7832),
                            'icn': 1
                        });
                    }
                    hs.cst.btns = btns;
                    break;

                case 3:     
                case 4:     
                	reconcileHSType.call(this, hsType);
                    break;
                }
            },

            
            getHomeScreenType: function () {
                if (!this._hsType) {
                    var hscNode = this._cfg.hsc;
                    if (hscNode) {
                        
                        
                        this._hsType = (typeof hscNode === 'number') ? hscNode : hscNode.tp;
                    }
                }

                return this._hsType;
            },

            getHomeScreen: function (asFolder) {
                
                if (!this._hsCfg) {
                    var type = this.getHomeScreenType(),
                        hsc = this._cfg.hsc,
                        cfg;

                    
                    switch (type) {
                    case 1: 
                    case 2: 
                        cfg = buildCustomHomeScreen.call(this, hsc, asFolder);
                        break;

                    case 3: 
                        cfg = hsc.rs;
                        
                        
                        if (cfg.oi) {
                            cfg = cfg.oi;
                        }
                        break;

                    case 4: 
                        cfg = hsc.fd;
                        
                        cfg.hlp = true;
                        break;
                    }

                    this._hsCfg = cfg;
                }

                return this._hsCfg;

            },

            getProjectByRealPid: function getProjectByRealPid(realPid) {
                var proj;
                $AFE(this.getWebServersList(), function (server) {
                    $AFE(server.pl, function (project) {
                        if (realPid === project.realPid) {
                            proj = project;
                            return false;
                        }
                    });

                    if (proj) {
                        return false;
                    }
                });
                return proj;
            },

            

            getProjectByServerAndProjectName: function getProjectByServerAndProjectName(serverName, port, projName) {
                var proj;
                $AFE(this.getWebServersList(), function (server) {
                    $AFE(server.pl, function (project) {
                        if ((serverName === project.sn) && (projName === project.pn)) {
                            if ((port === undefined) || (!!port && parseInt(port, 10) === project.sp)) {
                                proj = project;
                                return false;
                            }
                        }
                    });

                    
                    if (proj) {
                        return false;
                    }
                });
                return proj;
            },

            getHostUrlByRealPid: function getHostUrlByRealPid(realPid) {
                var proj = this.getProjectByRealPid(realPid);
                return this.getHostUrlByProject((proj && proj.pid) || realPid);
            },

            
            getWebServerUrlByProject: function getWebServerUrlByProject(projectId) {
                var servUrl = this.getHostUrlByProject(projectId);
                return servUrl.replace(/(servlet\/|asp\/)$/, '');
            },

            
            getCurrentProjectWebServerUrl: function getCurrentProjectWebServerUrl() {
                return this.getWebServerUrlByProject(mstrApp.getCurrentProjectId());
            },

            
            getHostUrlByProject: function getHostUrlByProject(projectId) {
                var urls = this._hostUrls;

                
                if (!urls[projectId]) {
                    
                    var server = this.getServerByProjectId(projectId);

                    if (server === undefined) {
                        throw new Error("Could not find server for project, pid=" + projectId);
                    }

                    var hostUrl = new mstrmojo.StringBuffer();

                    
                    hostUrl.append('http');

                    
                    if (server.rt) {
                        
                        hostUrl.append('s');
                    }

                    
                    hostUrl.append('://' + server.nm);

                    
                    var port = server.po;
                    if (port) {
                        hostUrl.append(':' + port);
                    }

                    
                    hostUrl.append('/' + server.pt + '/');

                    
                    hostUrl.append(((server.ty === 0) ? 'servlet' : 'asp') + '/');

                    
                    urls[projectId] = hostUrl.toString();
                }

                
                return urls[projectId];
            },

            
            getTaskUrlByProject: function getTaskUrlByProject(projectId) {
                
                var server = this.getServerByProjectId(projectId);
                if (server === undefined) {
                    throw new Error("Could not find server for project, pid=" + projectId);
                }
                return this.getHostUrlByProject(projectId) + mstrConfig.taskURL + ((server.ty === 1) ? '.aspx' : '');
            },

            
            getProject: function getProject(projectId) {
                
                var projects = this._projects;

                
                if (!projects[projectId]) {
                    
                    iterateProjects({
                        n: 'pid',
                        v: projectId
                    }, this.getWebServersList(), projects);
                }

                
                return projects[projectId];
            },

            
            getProjectHash: function getProjectHash() {
                var _result = {},
                    serverList = this.getWebServersList();
                if (serverList.length < 1) {
                	return _result;
                }

                var projects = this._projects,
                    dummyProjectID = mstrmojo.num.generateUniqueID(64);

                
                
                iterateProjects({
                    n: 'pid',
                    v: dummyProjectID
                }, serverList, projects);

                
                _result = $HASH.clone(projects);

                
                delete _result.servers;

                
                return _result;
            },

            
            getProjectList: function getProjectList() {
                var projectList = [];

                
                $HASH.forEach(this.getProjectHash(), function (project) {
                    
                    projectList.push({
                        did: project.pid,
                        n: project.pn,
                        desc: project.sn,
                        st: 'Project',
                        t: 8,
                        rtf: project.rtf    
                    });
                });

                return projectList;
            },

            
            clearLoginInfoForProject: function clearLoginInfoForProject(pid) {
                var cfg = this.getConfiguration(),
                    server = this.getServerByProjectId(pid),
                    project = this.getProject(pid),
                    creds = project.udc ? server.pdc : project.pc;

                creds.lo = creds.ps = "";
            },

            
            getLoginInfo: function (projectId) {
                var cfg = this.getConfiguration(),

                    server = this.getServerByProjectId(projectId),
                    serverCreds = server.wsc,
                    wsuid = serverCreds.lo || "",
                    wspwd = serverCreds.ps || "",
                    wsam = serverCreds.am,

                    project = this.getProject(projectId),
                    projectCreds = project.pc,
                    uid = projectCreds.lo || "",
                    pwd = projectCreds.ps || "",
                    am = projectCreds.am;

                
                if (server.udc) {
                    var wsdc = cfg.cty.wsdc;
                    wsam = wsdc.am;
                    wsuid = wsdc.lo || "";
                    wspwd = wsdc.ps || "";
                }

                
                if (project.udc) {
                    var pdc = server.pdc;
                    uid = pdc.lo;
                    pwd = pdc.ps;
                    am = pdc.am;
                }

                return {
                    wsuid: wsuid,
                    wspwd: wspwd,
                    wsam: wsam,

                    uid: uid,
                    pwd: pwd,
                    am: am
                };
            },

            
            updateLoginInfo: function updateLoginInfo(projectId, loginInfo) {
                var server = this.getServerByProjectId(projectId),
                    project = this.getProject(projectId),
                    creds = project.udc ? server.pdc : project.pc,
                    serverCreds = server.udc ? this.getDefaultServerCreds() : server.wsc;

                
                if (loginInfo.updateCfgAfterLogin & 0x01) {
                    serverCreds.lo = loginInfo.wsuid;
                    serverCreds.ps = loginInfo.wspwd;
                }

                
                if (loginInfo.updateCfgAfterLogin & 0x02) {
                    creds.lo = loginInfo.uid;
                    creds.ps = loginInfo.pwd;
                }

                this.saveConfiguration(false);
            },

            
            getProjectCount: function () {
                var wsl = this.getWebServersList(),
                    count = 0,
                    i = 0;

                for (i = 0; i < wsl.length; i++) {
                    if (wsl[i].pl) {
                        count += wsl[i].pl.length;
                    }
                }

                return count;
            },

            
            getServerByProjectId: function (projectId) {
                var projects = this._projects,
                    servers = projects.servers;

                
                if (!servers[projectId]) {
                    
                    iterateProjects({
                        n: 'pid',
                        v: projectId
                    }, this.getWebServersList(), projects);
                }

                
                return servers[projectId];
            },

            
            setPid: function setPid(project) {
                var oldPid = project.pid,
                    oldRealPid = project.realPid,
                    projCache = this._projects,
                    serverCache = projCache.servers,
                    pid = mstrmojo.num.generateUniqueID(32),
                    server = findServer.call(this, project);
                if (oldPid) {
                    delete projCache[oldPid];
                    delete serverCache[oldPid];
                }
                if (oldRealPid) {
                    delete projCache[oldRealPid];
                    delete serverCache[oldRealPid];
                }
                project.pid = pid;
                delete project.realPid;

                projCache[pid] = project;
                serverCache[pid] = server;
            },

            setRealPid: function setRealPid(project, value) {
                
                

                
                if (typeof project === 'string') {

                    
                    project = this.getProject(project);

                    
                    if (!project) {

                        
                        
                        return;
                    }
                }

                var oldRealPid = project.realPid,
                    projCache = this._projects,
                    serverCache = projCache.servers,
                    server = findServer.call(this, project);

                
                
                if (oldRealPid && oldRealPid !== project.pid) {
                    delete projCache[oldRealPid];
                    delete serverCache[oldRealPid];
                }
                project.realPid = value;

                projCache[value] = project;
                serverCache[value] = server;
                this.saveConfiguration(true);
            }
        }
    );

}());

  
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.hash");

    var CLASS_NAME = 'FolderDataService';

    
    mstrmojo.FolderDataService = mstrmojo.declare(
        mstrmojo.Obj,

        null,

        
        {
            scriptClass: "mstrmojo.FolderDataService",


            getData: function getData(params, callback, refresh) {
                $MAPF(true, CLASS_NAME);

                try {
                    
                    var folderId = (params && params.did) || this.did,
                        rtf = params.rtf;

                    
                    params = mstrmojo.hash.copy(params, {
                        taskId: 'folderBrowse',
                        styleName: 'MojoFolderStyle',
                        includeObjectDesc: true,
                        objectType: '8,3,55',
                        useEncoding: true,
                        dereferenceShortcuts: false
                    });

                    
                    if ( rtf ) {                        
                        
                        params.did = rtf.did;
                        params.folderID = rtf.did;
                        
                    
                    } else if (params && !params.systemFolder) {
                        
                        
                        params.folderID = folderId;
                    }

                    
                    if (refresh) {
                        
                        params.refresh = true;
                    }

                    
                    mstrApp.serverRequest(params, callback, {
                        src: CLASS_NAME + '::getData',
                        showWait: true,
                        hideWait: true,
                        delay: false
                    });

                    
                    return false;

                } finally {
                    $MAPF(false, CLASS_NAME);
                }
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.Obj");

    mstrmojo.maps.AndroidMapModel = mstrmojo.declare(
        mstrmojo.Obj,
        
        null,
        
        
        {            
            scriptClass: "mstrmojo.maps.AndroidMapModel",

            getVisProps: function() {
                return this.data.vp;
            },
            
            
            
            setPrompts: function setPrompts(prompts) {},

            getDataService: function getDataService() {},
                        
            execute: function execute(params, callback) {},
            
            answerPrompts: function answerPrompts(callback) {},
            
            getPageByTree: function getPageByTree(callback) {},                        
            
            sort: function sort (params, callback) {},
            
            pivot: function pivot (params, callback) {},
            
            drillGrid: function drillGrid (params, callback) {},
            
            drill2Grid: function drill2Grid (params, callback) {},            

            linkToObject: function linkToObject (params, callback) {},
            
            pageBy: function pageBy(pageByKeys, callback) {},
                        
            saveRWProps: function saveRWProps(nodeKey, props, type, loadData, callback) {}
         
        }
        
 
    );
})();
(function(){

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo._IsRptModel");
    
    
    mstrmojo.GraphModel = mstrmojo.declare(
        mstrmojo.Obj,
        
        [ mstrmojo._IsRptModel ],
        
        
        {            
            scriptClass: "mstrmojo.GraphModel"
        }
    );
}());

(function() {
   var objectNodeName = {
        1: "f", 

        2: "tm", 

        3: "rd", 

        4: "mt", 

        7: "amt", 

        8: "fd", 

        10: "p", 

        11: "fun", 

        12: "at", 



















        21: "fm" 











































































































    };
    function getObjectNodeName(objectType) {
    	return objectNodeName[objectType] || "resv";
    };
	mstrmojo.mstr.WebOI = mstrmojo.declare(
			
			mstrmojo.Obj,
			
			null,
			
			{
				
				did: '',
				
				t: 0,
				
				st: 0,
				
				n: '',
				
				desc: '',
				
				ab: '',
				
				icp: '',
				
				xml: '',
				
				getXML: function() {
					
					return this.xml || this.buildShortXML().toString();
				},
				buildShortXML: function(builder) {
					builder = builder || new mstrmojo.XMLBuilder();
			        builder.addChild(getObjectNodeName(this.t));
			        this.buildShortObjectAttributes(builder);
			        this.buildTypeSpecificShortXML(builder);
		            builder.closeElement();
		            return builder;
				},
				buildShortObjectAttributes: function(builder) {
			        builder.addAttribute("did", this.did);
			        builder.addAttribute("tp", this.t);
			        builder.addAttribute("stp", this.st);
			        builder.addAttribute("n", this.n);
				},
				buildTypeSpecificBody: function(builder) {
					
				},
				buildShortObjectElt: function(builder) {
			        builder.addChild(getObjectNodeName(this.t));
			        this.buildShortObjectAttributes(builder);
		            builder.closeElement();
				}
			}
	);
})();
(function() {
	
    mstrmojo.requiresDescs(8409);
    
    mstrmojo.prompt.WebPrompt = mstrmojo.declare(
        mstrmojo.Obj,
        
        null,

        
        {
            scriptClass: 'mstrmojo.prompt.WebPrompt',
            
            
            promptType: 0,
            
            
            prs: null,
            
            
            pt: 0,
            
            
            pin: 0,
            
            
            loc: null,
            
            
            title: '',
            
            
            mn: '',
            
            
            req: false,
            
            
            min: null,
            
            
            max: null,
            
            
            dataSourcesXML: '',
            
            getStyle: mstrmojo.emptyFn,
            
            
            getDisplayValue: mstrmojo.emptyFn,
            
            
            validate: function validate(v){
            	if (this.isAnswerEmpty(v) && this.req) {
            		 throw new Error(mstrmojo.desc(8409, 'This prompt (#) requires an answer.').replace('#', this.title)); 
            	}
            },
            
            
            prepareAnswer: function prepareAnswer(callbacks){
                var fn = callbacks && callbacks.success;
                if (fn) {
                    fn();
                }
            },
            
            
            getAnswerXML: function getAnswerXML() {
                var buf = new mstrmojo.XMLBuilder();
                this.buildShortPa(buf);
                return buf.toString();
            },
            
            
            buildShortAnswerXML: function buildShortAnswerXML(builder) {
                
                return builder;
            },
            
            
            buildShortPa: function buildShortPa(builder) {
                builder.addChild("pa");
                builder.addAttribute("pt", this.pt);
                
                var loc = this.loc;
                if (loc) {
                    builder.addAttribute("pin", loc.pin);
                    builder.addAttribute("did", loc.did);
                    builder.addAttribute("tp", loc.t);
                }
                
                
                this.buildShortAnswerXML(builder);
                builder.closeElement();
            },
            
            
            populateAnswer: function populateAnswer(ans){
                
            },
            
            
            setAnswerValue: mstrmojo.emptyFn,
            
            
            isAnswerEmpty: function isAnswerEmpty(v){
                
                return false;
            },
            
            
            populate: function populate(props) {
                this.promptType = props.ptp;
                this.pt = props.dptp;
                this.mn = props.mn;
                this.pin = props.pin;
                this.title = props.ttl;
                this.loc = props.loc;
                this.min = props.min || '';
                this.max = props.max || '';
                this.req = props.reqd;
                this.dataSourcesXML = props.dsrcs;
                
                
                var prs = this.prs = {};
                mstrmojo.array.forEach(props.prs, function (p) {
                    prs[p.n] = p.v;
                });
                this.hasAnswer = props.hasAns;
            },
            
            buildAnswerObject: function buildAnswerObject() {
                return {
                    
                    
                };
            },
            
            supported: function supported() {
            	return true;
            }
        }
    );
    
    mstrmojo.prompt.WebPrompt.TYPES = {
        CONSTANT_PROMPT: 1,
        CONSTANT_GEO_PROMPT: 1.5,
        ELEMENTS_PROMPT: 2            
    };
    
    mstrmojo.prompt.WebPrompt.STYLES = {
        TEXT: 1,
        LIST: 2,
        STEPPER: 3,
        SWITCH: 4,
        SLIDER: 5,
        CALENDAR: 6,
        TIME: 7,
        GEO: 8,
        BARCODE: 9
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.StringBuffer",
                         "mstrmojo.hash",
                         "mstrmojo.dom",
                         "mstrmojo._IsGraphDataService",
                         "mstrmojo.func");

    mstrmojo.requiresDescs(8445);

    var $H = mstrmojo.hash;
    var $DOM = mstrmojo.dom;
    var $PST = [mstrmojo.desc(8445, 'Loading')];
    var updateNum = 0;

    function submitRequest(params, callback, config) {
        var updateId = updateNum++,
        	updates = this.getTxUpdates(updateId);
        
        config = config || {};
        config.src = arguments.callee.caller.name;

        if (!mstrmojo.string.isEmpty(updates)) {
            params.updateChanges = updates;
        }

        
        mstrApp.serverRequest(params, this.wrapCallback(callback, updateId), config);
    }

    function addContentSize(request) {

    	
    	var availableDim = window.mstrMobileApp ? this.model.controller.getContentDimensions() : mstrApp.getContentDimensions();

        if (availableDim) {
            
            request.styleName = 'RWDocumentMobileStyle';
            request.availableWidth = availableDim.w;
            request.availableHeight = availableDim.h;
        }
    }

    
    mstrmojo.DocDataService = mstrmojo.declare(
        mstrmojo.Obj,

        [mstrmojo._IsGraphDataService],

        
        {
            scriptClass: "mstrmojo.DocDataService",

            wrapCallback: function wrapCallback(callback, updateId) {
                var me = this;
                return mstrmojo.func.wrapMethods({
                    success: function (res) {
                        if (res) {
                            me.rwb = res.bs || me.rwb;
                            me.msgId = res.mid || me.msgId;
                        }
                        me.clearTxUpdates(updateId);
                    }, failure: function (res) {
                    	me.resetTxUpdates(updateId);
                    }
                }, callback);
            },

            refresh: function refresh(params, callback) {

            	var isRefresh = !!params.useRefreshProgress,
            		pst = isRefresh ? [mstrmojo.desc(10078, 'Refreshing data. Please wait.')] : $PST;

            	delete params.useRefreshProgress;

            	submitRequest.call(this, $H.copy(params, {
                    taskId: 'docRefresh',
                    rwb: this.rwb,
                    rePrompt: false,
                    fresh: false,
                    regenerate: false
                }), callback,  {
                    showProgress:true,
                    hideProgress:true,
                    progressStateText: pst,
                    useRefreshProgress: isRefresh
                });
            },

            getTxUpdates: function getTxUpdates(t) {
                var m = this.model;
                return m && m.getTransactionUpdates && m.getTransactionUpdates(t);
            },

            clearTxUpdates: function clearTxUpdates(t) {
                var m = this.model;
                if (m && m.clearTransactionUpdates) {
                    m.clearTransactionUpdates(t);
                }
            },

            resetTxUpdates: function resetTxUpdates(t) {
                var m = this.model;
                if (m && m.resetTransactionUpdates) {
                    m.resetTransactionUpdates(t);
                }
            },

            loadDocLayout: function loadDocLayout(params, callback) {
                
                var taskParams = $H.copy(params, {
                    taskId: 'loadDocLayout',
                    rwb: this.rwb
                });

                
                addContentSize.call(this, taskParams);

                
                submitRequest.call(this, taskParams, callback, {
                        showProgress:true,
                        hideProgress:true,
                        progressStateText: $PST
                    }
                );

            },

            setCurrentDocLayout: function setCurrentDocLayout(layoutKey, callback) {
                callback = callback || null;

                submitRequest.call(this, {
                    taskId: 'setDocLayout',
                    rwb: this.rwb,
                    layoutKey: layoutKey
                }, callback, {
                    silent: (callback === null)
                });

                if(typeof mstrMobileApp !== 'undefined') {
                	mstrMobileApp.clearWebViewCache(false);
                }
            },

            fetchDocPage: function fetchDocPage(position, callback) {
                submitRequest.call(this, {
                    taskId: 'fetchDocPage',
                    rwb: this.rwb,
                    pos: position
                }, callback);
            },

            
            setCurrentPanel: function setCurrentPanel(panelKey, panelStackKey, selectorKeyContext, callback) {
                submitRequest.call(this, {
                    taskId: 'setCurrentPanel',
                    rwb: this.rwb,
                    key: panelKey,
                    panelStackKey: panelStackKey,
                    selectorKeyContext: selectorKeyContext
                }, callback, {
                    silent: true   
                });
            },

            
            requestNewPanel: function requestNewPanel(panelKey, panelStackKey, selectorKeyContext, dirtyKeys, useLoader, callback) {
                submitRequest.call(this, {
                    taskId: 'requestNewPanel',
                    rwb: this.rwb,
                    key: panelKey,
                    panelStackKey: panelStackKey,
                    selectorKeyContext: selectorKeyContext,
                    dirtyKeys: dirtyKeys
                }, callback, {
                    showProgress: useLoader,
                    hideProgress: useLoader,
                    progressStateText: $PST
                });
            },

            
            applyGraphSelectorAction: function applyGraphSelectorAction(selectorKeyContext, targetList, sliceID, x, y, callback, zoomFactor) {
                submitRequest.call(this, {
                    taskId: 'applyGraphSelectorAction',
                    rwb: this.rwb,
                    selectorKeyContext: selectorKeyContext,
                    ctrlKeys: targetList,
                    sliceID: sliceID,
                    x: x,
                    y: y,
                    zoomFactor : zoomFactor
                }, callback);
            },

            
            setDocSelectorElements: function setDocSelectorElements(selectorKeyContext, elemList, controlKey, includeClause, callback, zoomFactor, useAndroidTask, sdpKeys, tks, disablePU) {
                var params = {
                    taskId: 'setDocSelectorElements',
                    rwb: this.rwb,
                    selectorKeyContext: selectorKeyContext,
                    elemList: elemList,
                    ctlKey: controlKey,
                    zoomFactor : zoomFactor
                };

                if ($DOM.isAndroid || useAndroidTask) {
                    params.taskId = 'androidSetDocSelectorElements';
                }

                if (includeClause !== null && includeClause !== undefined) {
                    params.include = includeClause;
                }

                if(sdpKeys)
        		{
        		   params.sdpKeys = sdpKeys;
        		}
                if ( tks ) {
                    params.tks = tks;
                }
                
                if (disablePU) {
                	params.usePartialUpdate = '0';
                }

                submitRequest.call(this, params, callback, {
                    showProgress: true,
                    hideProgress: true,
                    progressStateText: $PST,
                    delay: true
                });
            },

            
            setDocVisSelectorElements: function setDocVisSelectorElements(selectorKeyContext, elemList, controlKey, includeClause, callback, zoomFactor, useAndroidTask, sdpKeys, tks) {
                var params = {
                    taskId: 'setDocVisSelectorElements',
                    rwb: this.rwb,
                    selectorKeyContext: selectorKeyContext,
                    elemList: elemList,
                    ctlKey: controlKey,
                    zoomFactor : zoomFactor
                };

                if ($DOM.isAndroid || useAndroidTask) {
                    params.taskId = 'androidSetDocSelectorElements';
                }

                if (includeClause !== null && includeClause !== undefined) {
                    params.include = includeClause;
                }

                if(sdpKeys)
                {
                   params.sdpKeys = sdpKeys;
                }

                if ( tks ) {
                    params.tks = tks;
                }

                submitRequest.call(this, params, callback, {
                    showProgress: true,
                    hideProgress: true,
                    progressStateText: $PST,
                    delay: true
                });
            },


            
            setMultiDocSelectorElements: function setMultiDocSelectorElements(selectorObjects, multiSelect, callback, zoomFactor) {
                var params = {
                    taskId: 'setMultiDocSelectorElements',
                    rwb: this.rwb,
                    multiSelect: multiSelect,
                    selectorObjects: selectorObjects,
                    zoomFactor : zoomFactor
                };

                submitRequest.call(this, params, callback, {
                    showWait: true,
                    hideWait: true,
                    delay: true
                });
            },

            
            setDocSelectorExpression: function setDocSelectorExpression(unitKeyContext, controlKey, objectId, objectType, expressionFunction, expressionFunctionType, includeClause, expressionConstants, dataType, callback, zoomFactor, unset) {
                var params = {
                    taskId: 'setDocSelectorExpression' + (unset ? 'Unset' : ''),
                    rwb: this.rwb,
                    unitKeyContext: unitKeyContext,
                    ctlKey: controlKey,
                    objectId: objectId,
                    objType: objectType,
                    expFunction: expressionFunction,
                    expFunctionType: expressionFunctionType,
                    zoomFactor : zoomFactor
                };

                if (includeClause !== null && includeClause !== undefined) {
                    params.include = includeClause;
                }

                if (expressionConstants !== null && expressionConstants !== undefined) {
                    params.expConstants = expressionConstants;
                }

                if (dataType !== null && dataType !== undefined) {
                    params.dataType = dataType;
                }

                submitRequest.call(this, params, callback);
            },

            
            setDocSelectorInclude: function setDocSelectorInclude(controlKey, includeClause, callback, objectID, objectType, zoomFactor) {
                var params = {
                    taskId: 'setDocSelectorInclude',
                    rwb: this.rwb,
                    include: includeClause,
                    ctlKey: controlKey,
                    zoomFactor : zoomFactor
                };

                if (objectID) {
                    params.objectID = objectID;
                }

                if (objectType) {
                    params.objType = objectType;
                }

                submitRequest.call(this, params, callback);
            },

            
            setDocUnsetSelector: function setDocUnsetSelector(unitKeyContext, ctlKey, callback, zoomFactor) {
                submitRequest.call(this, {
                    taskId: 'unsetSelector',
                    rwb: this.rwb,
                    unitKeyContext: unitKeyContext,
                    ctlKey: ctlKey,
                    zoomFactor: zoomFactor
                }, callback);
            },

            
            getRWGraphImage: function getRWGraphImage(params, callback) {
                var app = mstrApp,
                    id = this.id,
                    p = {
                        taskId: 'getRWGraphImage',
                        taskEnv: 'xhr',
                        imgType: 4,
                        messageID: this.msgId,
                        nodeKey: params.k,
                        sliceID: parseInt(params.sid, 10),
                        width: parseInt(params.w, 10),
                        height: parseInt(params.h, 10)
                    };

                
                
                
                if (app.onMobileDevice() && app.useBinaryFormat) {
                    
                    window.setTimeout(function () {
                        submitRequest.call(mstrmojo.all[id], p, callback);
                    }, 0);

                } else {
                    if (params.encodeImage) {
                        
                        p.taskContentEncoding = 'base64';

                        
                        delete p.taskEnv;

                        
                        submitRequest.call(this, p, {
                            success: function (res) {
                                callback.success('data:image/png;base64,' + res);
                            },
                            failure: function (err) {
                                (callback.failure || app.onerror)(err);
                            }
                        });

                    } else {
                        var cfg = app.getConfiguration(),
                            projectId = app.getCurrentProjectId(),
                            values = new mstrmojo.StringBuffer();

                        
                        p.__ts__ = new Date().getTime();
                        p.sessionState = app.getSessionState(projectId);

                        
                        $H.forEach(p, function (v, n) {
                            
                            values.append(n + '=' + encodeURIComponent(v));
                        });

                        
                        callback.success(cfg.getTaskUrlByProject(projectId) + '?' + values.toString('&'));
                    }
                }
            },

            getImage: function getImage(url) {
                var app = mstrApp,
                    config = app.getConfiguration();

                if (config && url && url.indexOf('://') === -1) {
                    
                    url = config.getHostUrlByProject(app.getCurrentProjectId()) + url;
                }

                return (mstrApp.useBinaryFormat) ? String(mstrMobileApp.getImage(url)) : url;
            },

            getDocImage: function getDocImage(url) {
                return this.getImage(url);
            },

            setQuickSwitchViewMode: function setQuickSwitchViewMode(gridKeyContext, displayMode) {
                submitRequest.call(this, {
                    taskId: 'setDisplayMode',
                    gridKeyContext: gridKeyContext,
                    messageID: this.msgId,
                    displayMode: displayMode
                }, null, {
                    silent: true
                });
            },

            setRWUnitProperties: function setRWUnitProperties(key, props, formatType, returnData, callback) {
                submitRequest.call(this, {
                    taskId: 'setRWUnitProperties',
                    rwb: this.rwb,
                    nodeKey: key,
                    props: props,
                    formatType: formatType,
                    returnData: returnData
                }, callback, {
                    silent: true
                });
            },

            setDocZoom: function setDocZoom(params, callback) {
                submitRequest.call(this, {
                    taskId: 'setDocZoom',
                    rwb: this.rwb,
                    zoomType: params.zoomType,
                    zoomFactor: params.zoomFactor
                }, callback);
            },

            sort: function sort(params, callback) {
                submitRequest.call(this, $H.copy(params, {
                    taskId: 'DocSort',
                    rwb: this.rwb
                }), callback);
            },

            pivot: function pivot(params, callback) {
                var request = $H.copy(params, {
                    messageID: this.msgId,
                    rwb: this.rwb
                });

                request.key = params.nodeKey;
                delete request.nodeKey;
                request.taskId = params.formID ? 'docPivotForm' : 'docPivot';

                submitRequest.call(this, request, callback);
            },

            drillGrid: function drillGrid(params, callback) {
                submitRequest.call(this, {
                    taskId: 'DocDrill',
                    messageID: this.msgId,
                    nodeKey: params.nodeKey,
                    drillPathIndex: params.drillPathIndex, 
                    drillPathKey: params.drillPathKey,
                    elementList: params.drillElements
                }, callback, {
                    showProgress: true,
                    hideProgress: true,
                    progressStateText: $PST,
                    delay: true
                });
            },

            changeDocGroupBy: function changeDocGroupBy(params, callback, config) {
                var request = {
                    taskId: 'changeDocGroupBy',
                    rwb: this.rwb,
                    messageID: this.msgId,
                    treesToRender: 3
                };

                if ( params.flags) {
                	request.flags = params.flags;
                }
                if (params.groupbyKey) {
                    request.groupByKey = params.groupbyKey;
                    request.elementID = params.elementId;
                } else {
                    request.gbUnits = params.gbUnits;
                }

                
                addContentSize.call(this, request);

                submitRequest.call(this, request, callback, config);
            },

            downloadGridData: function downloadGridData(params, callback) {
                submitRequest.call(this, {
                    taskId: 'DocXtabIncrementalFetch',
                    rwb: this.rwb,
                    nodeKey: params.nodeKey,
                    rowPosition: params.rowPosition,
                    maxRows: params.maxRows,
                    colPosition: params.colPosition,
                    sliceId: params.sliceId,
                    maxColumns: params.maxColumns
                }, callback);
            },

            txMarkRows: function txMarkRows(params, callback) {
                submitRequest.call(this, {
                    taskId: 'markRow',
                    rwb: this.rwb,
                    nodeKey: params.nodeKey,
                    sliceId: params.sliceId,
                    rowOrdinal: params.rowOrdinal,
                    actionType: params.actionType
                }, callback);
            },

            txChangeData: function txChangeData(params, callback) {
                submitRequest.call(this, {
                    taskId: 'changeData',
                    rwb: this.rwb,
                    nodeKey: params.nodeKey,
                    sliceId: params.sliceId,
                    cells: params.cells,
                    autoRefresh: params.autoRefresh
                }, callback);
            },

            sendTransactionActions: function sntTxActs(params, callback) {
                var request = {
                    taskId: 'DocTransaction',
                    rwb: this.rwb,
                    keyContext: params.keyContext,
                    actions: params.actions,
                    messageID: this.msgId
                    };

                
                if(params.txrcd) {
                    request.isPending = params.txrcd.pending;
                    request.timestamp = params.txrcd.timestamp;
                }

                submitRequest.call(this, request, callback, {silent: !!callback}); 
            },

            RWEventsTask: function RWEventsTask(params, callback){
                submitRequest.call(this, {
                    taskId: 'RWEventsTask',
                    rwb: this.rwb,
                    messageID: params.messageID,
                    styleName: params.styleName,
                    events: params.events
                }, callback);
            },

            getPageByTree: function getPageByTree(callback) {
                mstrApp.serverRequest({
                    taskId: 'getPageByTree',
                    msgID: this.msgId
                }, callback);
            },

            resetSelections: function resetSelections(unitKeyContext, disablePU, callback) {
            	submitRequest.call(this, {
            		taskId: 'resetSelections',
            		rwb: this.rwb,
            		unitKeyContext: unitKeyContext || '',
            		usePartDisplay: disablePU ? '0' : '1'
            	}, callback);
            }
        }
    );
}());

  
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.hash");

    var CLASS_NAME = 'SubscriptionsDataService';

    
    mstrmojo.SubscriptionsDataService = mstrmojo.declare(
        mstrmojo.Obj,

        null,

        
        {
            scriptClass: "mstrmojo.SubscriptionsDataService",


            getSubscriptions: function getSubscriptions(callback, noWait) {
                $MAPF(true, CLASS_NAME);

                try {
                    mstrApp.serverRequest(
                            {   
                                taskId: 'getSubscriptions'
                            },
                            callback,
                            {   
                                src: CLASS_NAME + '::getSubscriptions',
                                override: true,
                                showWait: !noWait,
                                hideWait: !noWait,
                                delay: false,
                                skipLogin: true,
                                noTaskURL: true
                            }
                        );
                    return false;

                } finally {
                    $MAPF(false, CLASS_NAME);
                }
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.hash");

    var $H = mstrmojo.hash,
        PENDING = 'pending',
        FAILED = 'failed';

    
    function getOfflineTransactions(callback) {
        if (mstrApp.isHosted()) {

            callback.success({});
        } else {
            mstrApp.serverRequest({
                taskId: 'getOfflineTransaction'
            }, callback, {
                noTaskURL: true,
                skipLogin : true
            });
        }

    }

    function noPendingQueue(list) {
        var noPending = true;
        $H.forEach(list, function (o) {
            if (o.pending && o.pending.length > 0) {
                noPending = false;
            }
        });

        return noPending;
    }

    
    function setBoardModel() {
        var me = this;

        
        getOfflineTransactions({
            success: function (res) {
                var updated = false, po, docs, list;

                
                me.emptyTransactionQueue = $H.isEmpty(res);

                
                $H.forEach(me.prjModel, function (v, k) {
                    if (!res[k]) {
                        po = me.prjModel[k];
                        if (po && po.list) {
                            delete me.prjModel[k];
                            updated = true;
                        }
                    }
                });

                
                $H.forEach(res, function (v, k) {
                    var p = mstrApp.getConfiguration().getProjectByRealPid(k);
                    
                    if (!p) {
                        
                        return;
                    }

                    po = me.prjModel[k];
                    if (!po) {
                        po = me.prjModel[k] = {pid: p.pid, realPid: k, pn: p.pn, list: v};
                        updated = true;
                    } else {
                        
                        if (!$H.equals(po.list, v)) {
                            po.list = v;
                            updated = true;
                        }
                    }
                });

                if (updated) {
                    list = {};
                    $H.forEach(me.prjModel, function (v) {
                        if (v) {
                            
                            docs = $H.clone(v.list);
                            
                            $H.copy(docs, list);
                            
                            $H.forEach(docs, function (o) {
                                o.p = v;
                            });
                        }
                    });
                    
                    me.ntfBoardModel.docsTx = list;

                    me.ntfBoardModel.raiseEvent({
                        name: 'recordChanged',
                        data: me.ntfBoardModel.docsTx
                    });
                }
            }
        });
    }

    var $MODEL = mstrmojo.OfflineTransactionModel = mstrmojo.declare(
        mstrmojo.Obj,
        null,
        {
            scriptClass: 'mstrmojo.OfflineTransactionModel',

            
            lastSubmission: false,

            
            emptyTransactionQueue: true,


            
            ntfBoardModel: null,

            
            prjModel: null,

            
            init: function init(props) {
                this._super(props);

                
                this.prjModel = {};

                
                this.ntfBoardModel = new mstrmojo.Obj({
                    
                    docsTx: {},

                    getOfflineRecords: function getOfflineRecords(did) {
                        return did ? this.docsTx[did] : this.docsTx;
                    }

                    
                });

                setBoardModel.call(this);
            },

            
            getBoardModel: function getBoardModel() {
                return this.ntfBoardModel;
            },

            
            hasOfflineTransactions: function hasOfflineTransactions() {
                return !this.emptyTransactionQueue;
            },

            editTransactionRecord: function editOfflineTransactionRecord(documentId, isPending, timeStamp, callback) {
                var bm = this.ntfBoardModel,
                    p = bm.docsTx[documentId].p,
                    dim = mstrApp.getContentDimensions();

                
                mstrApp.serverRequest({
                    taskId: 'editOfflineTransaction',
                    projectId: p.realPid,
                    documentId: documentId,
                    isPending: isPending,
                    timeStamp: timeStamp,
                    availableWidth: dim.w,
                    availableHeight: dim.h
                }, callback, {
                    projectId: p.pid,
                    skipLogin : true
                });
            },

            deleteTransactionRecord: function deleteTransactionRecord(documentId, isPending, timeStamp, callback) {
                var bm = this.ntfBoardModel,
                    rec = bm.docsTx[documentId],
                    p = rec.p,
                    d = rec[isPending ? PENDING : FAILED],
                    idx,
                    prjList,
                    me = this;

                mstrApp.serverRequest({
                    taskId: 'deleteOfflineTransaction',
                    projectId: p.realPid,
                    documentId: documentId,
                    isPending: isPending,
                    timeStamp: timeStamp
                }, {
                        
                    success: function () {
                        
                        idx = mstrmojo.array.find(d, 'timestamp', timeStamp);
                        if (idx !== -1) {
                            d.splice(idx, 1);
                        }
                        
                        
                        if (rec.pending.length === 0 && rec.failed.length === 0) {
                            delete bm.docsTx[documentId];
                            
                            if ($H.isEmpty(bm.docsTx)) {
                                me.emptyTransactionQueue = true;
                            }
                            
                            
                            prjList = me.prjModel[p.realPid];
                            if(prjList) {
                                
                                delete prjList.list[documentId];
                                
                                if($H.isEmpty(prjList.list)) {
                                    delete me.prjModel[p.realPid];
                                }
                            }                            
                            
                            
                            bm.raiseEvent({
                                name: 'recordChanged',
                                data: bm.docsTx
                            });
                        }

                        if (callback.success) {
                            callback.success(d);
                        }
                    }
                }, {
                    noTaskURL: true,
                    skipLogin : true
                });
            },

            
            submitOfflineTransaction: function submitOfflineTransaction() {
                
                if (!this.lastSubmission || !this.emptyTransactionQueue) {
                    $H.forEach(this.prjModel, function (v, k) {
                        
                        
                        if (v && v.list && !$H.isEmpty(v.list) && !noPendingQueue(v.list)) {
                            mstrApp.submitTransactionQueue(k, 'submitOfflineTransaction');
                        }
                    });
                }
            },

            onSubmitDone: function onSubmitDone(status) {
                this.lastSubmission = status;
                this.refresh();
            },

            refresh: function refresh() {
                setBoardModel.call(this);
            }
        }
    );

    $MODEL.PENDING = PENDING;
    $MODEL.FAILED = FAILED;
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.func");
    
    
    mstrmojo.ResSetLink = mstrmojo.declare(
        mstrmojo.Obj,
        
        null,
        
        
        {            
            scriptClass: "mstrmojo.ResSetLink",
            
            SAME_PROMPT: 1,
            DO_NOT_ANSWER: 2,
            CLOSE: 3,
            DYNAMIC: 4,
            STATIC: 5,
            CURRENT_UNIT: 6,
            ALL_VALID_UNITS: 7,
            USE_DEFAULT_ANSWER: 8,
            
            toXml: function toXml() {
                
                
                var me = this,
                    fnXMLAttribute = function(name, value) { 
                        return ' ' + name + '="' + value + '"';
                    },
                    fnXMLAttributeElement = function(name, value) {
                        return fnXMLAttribute(name, mstrmojo.string.encodeXMLAttribute(value));
                    },
                    xml = new mstrmojo.StringBuffer();

                                 
                
                var prms = this.prms,
                    prmCnt = prms && prms.length;
                
                
                
                if (prmCnt || me.aopam != me.DO_NOT_ANSWER) {
                    
                    xml.append('<hl' + fnXMLAttribute('mid', me.mid) + fnXMLAttribute('srct', me.srct) + fnXMLAttribute('aopam', me.aopam) + '>');
                    
                    if (prmCnt) {
                        
                        xml.append('<prms>');
                        
                        for (var i = 0; i < prmCnt; i++) {
                            var prm = prms[i];
                              
                            
                            
                            
                            xml.append('<prm' + fnXMLAttribute('id', prm.id) + fnXMLAttribute('am', prm.am) + fnXMLAttribute('pt', prm.pt));
                              
                            
                            if (prm.orid) {
                                xml.append(fnXMLAttribute('orid', prm.orid) + fnXMLAttribute('ortp', prm.ortp));
                            }
                            xml.append('>');  
                  
                            
                            switch (prm.am) {
                                case me.DO_NOT_ANSWER:
                                case me.CLOSE:
                                case me.USE_DEFAULT_ANSWER:
                                case me.SAME_PROMPT:
                                    break;
                                      
                                case me.STATIC:
                                    xml.append('<pa ia="1"><es>');
                                    var es = prm.pa.es,
                                        esLen = es && es.length || 0;
    
                                    for (var z = esLen - 1; z >= 0; --z) {
                                        var e = es[z];
                                        xml.append('<e' + fnXMLAttributeElement('ei', e.ei) + fnXMLAttribute('disp_n', e.disp_n) + fnXMLAttribute('emt', e.emt)  + '/>');
                                    }
                                      
                                    xml.append('</es></pa>');
                                    break;
                                      
                                case me.DYNAMIC:
                                case me.ALL_VALID_UNITS:
                                case me.CURRENT_UNIT:
                                    var pa = prm.pa;
                                    if (pa) {
                                        xml.append('<pa ia="1">');
                                        var a = pa.a;
                                        
                                        if (a) {
                                            xml.append('<a' + fnXMLAttribute('id', a.id) + fnXMLAttributeElement('n', a.n) + '>');
                                        }
                                        if ( prm.pt === 1) {
                                            
                                        	xml.append(mstrmojo.string.encodeXMLAttribute(pa.v));
                                        } else {             
	                                        xml.append('<es' + fnXMLAttribute('dispForms', a && a.dispForms >=0 ? a.dispForms : '') + '>'); 
	                                        var es = pa.es
	                                            esLen = es && es.length || 0;
	                                        for (var z = esLen - 1; z >= 0; --z) {
	                                            var e = es[z];
	                                            xml.append('<e' + fnXMLAttributeElement('ei', e.ei) + fnXMLAttribute('disp_n', e.disp_n) + fnXMLAttribute('emt', e.emt)  + '/>');
	                                        }
	                                        xml.append('</es>');
                                          
                                        if (a) {
                                            xml.append('</a>');
                                        }
                                        }
                                        xml.append('</pa>');
                                    }
                                    break;
                                    
                            }
                            xml.append('</prm>');
                        }
                        xml.append('</prms>');
                    }
                    xml.append('</hl>');
                }
                  
                return xml.toString();
            }


        }
    );
})();
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.Obj",
        "mstrmojo._LoadsScript",
        "mstrmojo._HasChildren",
        "mstrmojo.Binding",
        "mstrmojo._HasBindings");
    
    
    mstrmojo.Model = mstrmojo.declare(
        
        mstrmojo.Obj,

        
        [mstrmojo._LoadsScript, mstrmojo._HasChildren, mstrmojo._HasBindings],
                
        
        {
            
            scriptClass: "mstrmojo.Model",


            
            init: function init(props) {            
                this._super(props);

                
                if (this.children) {
                    this.initChildren();
                }
                
                
                
                
                if (!this.parent){
                    this.initBindings();
                }
            },
            
            
            destroy: function dst(skipCleanup) {
                if (this.children) {
                    this.destroyChildren(true);
                }
                if (this.bindings) {
                    this.destroyBindings();
                }
                this._super(skipCleanup);
            }
        }
    );
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo._LoadsScript",
                         "mstrmojo.Binding",
                         "mstrmojo._HasBindings",
                         "mstrmojo._HasMarkup",
                         "mstrmojo._HasTooltip");

    
    var $WIDGET = mstrmojo.Widget = mstrmojo.declare(
        
        mstrmojo.Obj,

        
        [mstrmojo._LoadsScript, mstrmojo._HasBindings, mstrmojo._HasMarkup, mstrmojo._HasTooltip],

        
        {
            
            scriptClass: "mstrmojo.Widget",

            
            domNode: null,

            
            hasRendered: false,

            
            visible: true,

            
            enabled: true,
            
            tooltip: '',

            
            cssClass: "",

            
            cssText: "",

            
            cssDisplay: 'block',

            
            init: function init(props) {
                this._super(props);

                
                
                
                
                
                
                var p = this.parent;
                if (!p || p.hasInitBindings) {
                    this.initBindings();
                }
            },

            
            destroy: function dst(skipCleanup) {
                if (this.hasRendered) {
                    this.unrender(skipCleanup);
                }
                if (this.bindings) {
                    this.destroyBindings();
                }
                this._super();
            },

            
            invalidate: mstrmojo.emptyFn
        }
    );

    
    $WIDGET.cssTextMarkupMethod = function () {
        this.domNode.style.cssText = this.cssText || '';
    };

    
    $WIDGET.visibleMarkupMethod = function () {
        this.domNode.style.display = (this.visible) ? this.cssDisplay : 'none';
    };

    $WIDGET.heightMarkupMethod = function () {
        this.domNode.style.height = this.height || '';
    };

    $WIDGET.widthMarkupMethod = function () {
        this.domNode.style.width = this.width || '';
    };

}());

(function() {
	
	var $A = mstrmojo.array,
	    
		_check = function(newChild, refNode) {
			var pos = -1;
	    	if (newChild == null || refNode == null) {
	    		
	    	} else {
	    		var chn = this.childNodes,
	    			pos = $A.indexOf(chn, refNode);
	    		if (pos < 0) {
	    			
	    		} 
	    	}
	    	return pos;
		},
		
	    _prep = function(newChild) {
			if (newChild.parentNode != null) {
				newChild.parentNode.removeChild(newChild);
			}
			newChild.parentNode = this;
	    };
	
	mstrmojo.mstr.WebNode = mstrmojo.declare(
			
			mstrmojo.Obj,
			
			null,
			
			{
				scriptClass: 'mstrmojo.mstr.WebNode',
			    
				exprType: 0, 
			    
			    nodeType: 0,	
			    
			    dataType: -1 , 
			    
			    dimType: 1, 
			    
			    childNodes: null,
			    
			    parentNode: null,
			    
			    getChildCount: function getChildCount(){
			    	return this.childNodes && this.childNodes.length || 0;
			    },
			    
			    insertBefore: function insertBefore(newChild, refNode) {
		    		var chn = this.childNodes,
	    				pos = _check.call(this, newChild, refNode);
			    	if ( pos < 0) {
			    		_prep.call(this, newChild);
			    		$A.insert(chn, pos, newChild);
			    	}
			    },

			    
			    insertAfter: function insertAfter(newChild, refNode) {
		    		var chn = this.childNodes,
    					pos = _check.call(this, newChild, refNode);
			    	if ( pos < 0) {
			    		_prep.call(this, newChild);
			    		$A.insert(chn, pos + 1, newChild);
			    	}
			    },

			    
			    replaceChild: function replaceChild(newChild, oldChild) {
		    		var chn = this.childNodes,
    					pos = _check.call(this, newChild, refNode);
			    	if ( pos < 0) {
			    		_prep.call(this, newChild);
			    		oldChild.parentNode = null;
			    		chn[pos] = newChild;
		    		}
			    },

			    
			    removeChild: function removeChild(childNode) {
			    	childNode.parentNode = null;
			    	$A.removeItem(this.childNodes, childNode);
			    },
			    
			    appendChild: function appendChild(newChild) {
			    	if (newChild) {
			    		_prep.call(this, newChild);
			    		if (!this.childNodes){
			    			this.childNodes = [];
			    		}
			    		this.childNodes.push(newChild);
			    	}
			    	
			    },
			    buildShortXML: function buildShortXML(builder) {
			    	builder.addChild('nd')
			    			.addAttribute('et', this.exprType)
			    			.addAttribute('nt', this.nodeType)
			    			.addAttribute('dmt', this.dimType)
			    			.addAttribute('ddt', this.dataType);
			    	
			    	var ch = this.childNodes;
			    	if (ch && ch.length) {
			    		for (var i = 0; i < ch.length; i ++) {
			    			ch[i].buildShortXML(builder);
			    		}
			    	}
			    	this.buildTypeSpecificShortXML(builder);
			    	builder.closeElement();
			    },
			    buildTypeSpecificShortXML: function buildTypeSpecificShortXML(builder) {
			    	
			    }
			}			
	);
})();

(function() {
	mstrmojo.requiresCls(
			"mstrmojo.mstr.EnumDataType",
			"mstrmojo.mstr.EnumNodeType",
			"mstrmojo.mstr.WebNode"
			);
	var $N_T = mstrmojo.mstr.EnumNodeType,
		$D_T = mstrmojo.mstr.EnumDataType;
	mstrmojo.mstr.WebConstantNode = mstrmojo.declare(
			
			mstrmojo.mstr.WebNode,
			
			null,
			
			{
				scriptClass: 'mstrmojo.mstr.WebTimeNode',
				nodeType: $N_T.NodeConstant,
				value: '',
				type: $D_T.DataTypeUnknown,
			    buildTypeSpecificShortXML: function buildTypeSpecificShortXML(builder) {
			        builder.addChild("cst")
			        		.addAttribute("ddt", this.type)
			        		.addText(this.value)
			        		.closeElement();
			    }
			}
			);
})();

(function() {
	mstrmojo.requiresCls(
			"mstrmojo.mstr.EnumNodeType",
			"mstrmojo.mstr.WebNode"
			);
	var $N_T = mstrmojo.mstr.EnumNodeType;
	mstrmojo.mstr.WebTimeNode = mstrmojo.declare(
			
			mstrmojo.mstr.WebNode,
			
			null,
			
			{
				scriptClass: 'mstrmojo.mstr.WebTimeNode',
				nodeType: $N_T.NodeTime,
				value: '',
			    
				time: null,
			    buildTypeSpecificShortXML: function buildTypeSpecificShortXML(builder) {
			    	
			        builder.addText(this.value);
			    }
				
			}
			);
})();

(function() {
	mstrmojo.requiresCls(
			"mstrmojo.mstr.EnumNodeType",
			"mstrmojo.mstr.WebNode"
			);
	var $N_T = mstrmojo.mstr.EnumNodeType;
	mstrmojo.mstr.WebFormShortcutNode = mstrmojo.declare(
			
			mstrmojo.mstr.WebNode,
			
			null,
			
			{
				scriptClass: 'mstrmojo.mstr.WebFormShortcutNode',
				nodeType: $N_T.NodeFormShortcut,
			    
			    attribute: null,
	
			    
			    form: null,
			    buildTypeSpecificShortXML: function buildTypeSpecificShortXML(builder) {
			    	if (this.attribute) {
			    		this.attribute.buildShortObjectElt(builder);
			    	}
			    	if (this.form) {
			    		this.form.buildShortObjectElt(builder);
			    	}
			    }
			    
			}
		);
})();

(function() {
	mstrmojo.requiresCls(
			"mstrmojo.mstr.EnumExpressionType",
			"mstrmojo.mstr.EnumNodeDimty",
			"mstrmojo.mstr.EnumFunction",
			"mstrmojo.mstr.EnumNodeType",
			"mstrmojo.mstr.EnumWebFunctionType",
			"mstrmojo.mstr.WebNode"
			);
	
	var $EXP_TP = mstrmojo.mstr.ExpressionType,
		$ND_DIM = mstrmojo.mstr.EnumNodeDimty,
		$F = mstrmojo.mstr.EnumFunction,
		$N_T = mstrmojo.mstr.EnumNodeType,
		$F_TP = mstrmojo.mstr.EnumWebFunctionType;
	
	var isMetricQualification = function(_expressionType) {
		return _expressionType == $EXP_TP.FilterSingleMetricQual 
		|| _expressionType == $EXP_TP.FilterMetricExpression
		|| _expressionType == $EXP_TP.FilterMultiMetricQual;
	};

	mstrmojo.mstr.WebOperatorNode = mstrmojo.declare(
			
			mstrmojo.mstr.WebNode,
			
			null,
			
			{
				scriptClass: 'mstrmojo.mstr.WebOperatorNode',
				nodeType: $N_T.NodeOperator,
				
				func: $F.FunctionReserved,
				
				funcType: $F_TP.WebFunctionTypeGeneric,
				property: '',
				onExprTypeChange: function(){
					if (isMetricQualification(this.exprType)){
						this.dimType = $ND_DIM.NodeDimtyUnspecified;
					}
				},
				on_set_func: function(n, v) {
					var ascending = false; 
					if (this.funcType == $F_TP.WebFunctionTypePercentQual ||
							this.funcType == $F_TP.WebFunctionTypeRankQual) {
								var mrpFunction = v;
								switch (mrpFunction) {
								case EnumWebMRPFunction.WebMRPFunctionTop:
									this.func = $F.FunctionLessEqual;
									this.property = "<pr ix=\"4\" v=\"0\"/>";
									break;

								case EnumWebMRPFunction.WebMRPFunctionBottom:
									this.func = $F.FunctionLessEqual;
									this.property = "<pr ix=\"4\" v=\"-1\"/>";
									break;

								case EnumWebMRPFunction.WebMRPFunctionBetween:
									this.func = $F.FunctionBetween;
									if (ascending) { 
										this.property = "";
									} else {
										this.property = "<pr ix=\"4\" v=\"0\"/>";
									}
									break;

								case EnumWebMRPFunction.WebMRPFunctionExcludeTop:
									this.func = $F.FunctionGreater;
									this.property = "<pr ix=\"4\" v=\"0\"/>";
									break;

								case EnumWebMRPFunction.WebMRPFunctionExcludeBottom:
									this.func = $F.FunctionGreater;
									this.property = "<pr ix=\"4\" v=\"-1\"/>";
									break;

								case EnumWebMRPFunction.WebMRPFunctionNotBetween:
									this.func = $F.FunctionNotBetween;
									if (ascending) { 
										this.property = "";
									} else {
										this.property = "<pr ix=\"4\" v=\"0\"/>";
									}
									break;

								case EnumWebMRPFunction.WebMRPFunctionEquals:
									this.func = $F.FunctionEquals;
									this.property = "";
									break;

								case EnumWebMRPFunction.WebMRPFunctionDifferentFrom:
									this.func = $F.FunctionNotEqual;
									this.property = "";
									break;
								   
								case EnumWebMRPFunction.WebMRPFunctionBanding:
									this.func = $F.FunctionBanding;
									this.property = "<pr ix=\"4\" v=\"0\"/>";
									break;

								case EnumWebMRPFunction.WebMRPFunctionBandingC:
									this.func = $F.FunctionBandingC;
									this.property = "<pr ix=\"4\" v=\"0\"/>";
									break;
								
								case EnumWebMRPFunction.WebMRPFunctionBandingP:
									this.func = $F.FunctionBandingP;
									this.property = "<pr ix=\"4\" v=\"0\"/>";
									break;
								
								case EnumWebMRPFunction.WebMRPFunctionBandingM:
									this.func = $F.FunctionBandingM;
									this.property = "<pr ix=\"4\" v=\"0\"/>";
									break;

								default:
									
								}

								if (this.funcType == $F_TP.WebFunctionTypePercentQual) {
									this.property += "<pr ix=\"5\" v=\"0\"/>";
								} else {
									this.property += "<pr ix=\"5\" v=\"-1\"/>";
								}

								var childNode = null;

								if (this.childNodes && this.childNodes.length > 0) {
									childNode = this.childNodes[0];
								}
								if (childNode != null) {
									childNode.setPropertyStr(property);
								}
							} else {
								this.func = v;
							}
					
				},
				buildTypeSpecificShortXML: function buildTypeSpecificShortXML(builder) {
					builder.addChild("op").addAttribute("fnt", this.func).closeElement();
					var ppt = this.property;
					if (ppt) {
						builder.addChild("prs").addRawXML(ppt).closeElement();
					}
				}

			}
			);
})();
(function () {

    mstrmojo.requiresCls(
        "mstrmojo.dom",
        "mstrmojo.css",
        "mstrmojo.Widget"
    );

    var $CSS = mstrmojo.css;

    
    mstrmojo.VisTooltip = mstrmojo.declare(

        mstrmojo.Widget,

        null,

        
        {
            scriptClass: 'mstrmojo.VisTooltip',

            cssClass: 'vis-tooltip',

            markupString:
                '<div class="{@cssClass}">' +
                    '<div class="vis-tooltip-container">' +
                        '<table class="vis-tooltip-table">' +
                        '</table>' +
                    '</div>' +
                '</div>',

            markupSlots: {
                domContainer: function () { return this.domNode.firstChild; },
                domTable: function () { return this.domNode.firstChild.firstChild; }
            },

            toggle: function toggle(show){
                if (show) {
                    this.domNode.style.display = 'block';
                } else {
                    this.domNode.style.display = 'none';
                }
            },

            displayInfo: function displayInfo(infoArr, pos) {
                var i, n, item, tbody, tr, td0, td1, td2,
                    doc = document,
                    table = this.domTable;

                table.innerHTML = '';
                n = infoArr.length;

                for (i = 0; i < n; i++) {
                    item = infoArr[i];
                    tbody = doc.createElement('tbody');
                    tr = doc.createElement('tr');
                    td0 = doc.createElement('td');
                    td1 = doc.createElement('td');
                    td2 = doc.createElement('td');
                    td0.setAttribute('class', 'vis-tooltip-name');
                    td1.setAttribute('class', 'vis-tooltip-space');
                    td2.setAttribute('class', 'vis-tooltip-value');

                    if (item === null) { 
                        tr.setAttribute('class', 'vis-tooltip-tr separator');
                    } else {
                        tr.setAttribute('class', 'vis-tooltip-tr');
                        td0.innerHTML = item.n + ':';
                        td2.innerHTML = item.v;
                    }

                    tr.appendChild(td0);
                    tr.appendChild(td1);
                    tr.appendChild(td2);
                    tbody.appendChild(tr);
                    this.domTable.appendChild(tbody);
                }

                if (pos) {
                    var loc = mstrmojo.dom.position(doc.body),
                        w = this.domNode.offsetWidth,
                        h = this.domNode.offsetHeight,
                        dx = pos.x + w - loc.x - loc.w,
                        dy = pos.y + h - loc.y - loc.h;

                    if (dx > 0) {
                        pos.x -= dx;
                    }
                    if (dy > 0) {
                        pos.y -= dy;
                    }

                    this.domNode.style.left = pos.x + 'px';
                    this.domNode.style.top = pos.y + 'px';
                }
            },

            doLayout: function doLayout(tableMaxWidth) {
                var table = this.domTable,
                    ttpStyle = $CSS.getComputedStyle(this.domNode),
                    tds = table.firstChild.firstChild.childNodes,
                    valueTDs = table.getElementsByClassName('vis-tooltip-value'),
                    i;

                var maxWidthForValue = tableMaxWidth - parseInt(ttpStyle.paddingLeft) - parseInt(ttpStyle.paddingRight);
                
                maxWidthForValue -= tds[0].offsetWidth;
                
                maxWidthForValue -= 10;
                

                for(i = 0; i < valueTDs.length; i++) {
                    valueTDs[i].style.maxWidth = maxWidthForValue + 'px';
                }
            },

            
            posTo: function posTo(pos){
                this.domNode.style.left = pos.x + 'px';
                this.domNode.style.top = pos.y + 'px';
            }
        }
    );

}());
(function(){

	mstrmojo.requiresCls("mstrmojo.Widget", "mstrmojo._ListSelections");
	
	
	mstrmojo.ListBase = mstrmojo.declare(
		
		mstrmojo.Widget,
		
		
		[mstrmojo._ListSelections],
		
        
		{
			scriptClass: "mstrmojo.ListBase",
			
		
            selectionPolicy: null,
            
			
			itemRenderer: null,
			
            
            icnCssText: '',
            
            
            icnCss: '',
            
            markupString: '<div id="{@id}" class="mstrmojo-ListBase {@cssClass}" style="{@cssText}" mstrAttach:click,mouseover>' + 
                              '<div class="{@icnCss}" style="{@icnCssText}">{@itemsHtml}</div>' + 
                          '</div>',
			
			markupSlots: {
                itemsContainerNode: function() { return this.domNode.firstChild; },
                scrollboxNode: function() { return this.domNode; }
			},
			
			markupMethods: {
                onvisibleChange: function() { this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; },
                onheightChange: function() { if (this.height) this.domNode.style.height = this.height; },
                onwidthChange: function() { if (this.width) this.domNode.style.width = this.width; }
			},
									
			
			buildRendering: function bldRnd() {
				
				this.itemsHtml = '';
				var len = this.items && this.items.length;
				if (len) {
					this.itemsHtml = this._buildItemsMarkup(
										0, 
										len-1, 
										this._markupPrefix && this._markupPrefix(),
										this._markupSuffix && this._markupSuffix(),
										this._itemPrefix && this._itemPrefix(),
										this._itemSuffix && this._itemSuffix()).join('');
				}
				
				
				
				
				this._super();	
				
				delete this.itemsHtml;
				
				this.addSlots({itemsNode: this.itemsContainerNode.firstChild});
			},
			
			_markupPrefix: null,
			_markupSuffix: null,
			_itemPrefix: null,
			_itemSuffix: null,
						
			
			_buildItemsMarkup: function( start,  end,  markupPrefix,  markupSuffix,  itemPrefix,  itemSuffix) {
				
				var markup = [],
					count = 0;
				markup[count++] = markupPrefix || '';

				
				var ir = this.itemRenderer,
					fn = ir && ir.render;
				if (fn && typeof(fn) == "function") {
					
					var PRE = itemPrefix || '',
						POST = itemSuffix || '',
						its = this.items,
						len = (its && its.length) || 0,
						me = this;
					for (var i=start, stop=Math.min(end+1, len); i<stop; i++) {
						markup[count++] = PRE;
						markup[count++] = fn(its[i], i, me);
						markup[count++] = POST;
					}
				}
								
				markup[count++] = markupSuffix || '';
				return markup;
			},
			
            			
            onselectionChange: function onselChg(evt) {
                if (!evt) {
                    return;
                }
                
                var ir = this.itemRenderer;
                if (!ir) {
                    return;
                }
                
                var unsel = ir.unselect,
                    its = this.items || [],
                    rem = evt.removed,
                    ix, el;
                
                if (unsel && rem) {
	                
	                for (var j=0, jLen=rem.length; j<jLen; j++) {
	                    ix = rem[j];
	                    el = this._getItemNode(ix);
	                    if (el) {
		                    unsel(el, its[ix], ix, this);
	                    }
	                }
				}
                
                var sel = ir.select,
                    added = evt.added;

                if (sel && added) {
                    
                    for (var i=0, len=added.length; i<len; i++) {
                        ix = added[i];
                        el = this._getItemNode(ix);
                        if (el) {
                            sel(el, its[ix], ix, this); 
                        }
                    }             
                }
                
                
                if (this.onchange) {
                	this.onchange();
                }
            },
            
            
            onselect: function onsel(evt) {
            	if (this.makeSelection && evt.idxs && evt.idxs.length) {
            		var selItem = this._getItemNode(evt.idxs[0]);
            		this.makeSelection({
            			selIdx: evt.idxs[0],
            			selItem: selItem
            		});
            	}
            },
            
            
            autoHide: false,
            
            
            init: function init( props) {
            	this._super(props);
				if (this.autoHide) {
					this.visible = !!(this.items && this.items.length);
				}
            }, 
            
            _getItemNode: function(idx) {
                var itemsNode = this.itemsContainerNode;
                return (itemsNode && itemsNode.childNodes[idx]) || null;
            }, 
            
            
			_set_items: function stitems(n, v) {
				if (this.autoHide) {
					this.set('visible', !!(v && v.length));
				}
				var was = this.items;
				this.items = v;
				if (was != v) {
					var hr = this.hasRendered;
					if (hr) {
						this.unrender();
					}
					
					
					
					
					this.clearSelect();

                    if (hr) {
                        this.render();
                    }
					return true;
				} else {
					return false;
				}
				return was != v;
			}
		}
	);
})();			
(function() {
    mstrmojo.requiresCls("mstrmojo._IsInputControl");

    
    mstrmojo.DefaultDIC = mstrmojo.declare(
        
        mstrmojo.Widget,
        
        null,
        
        {
            scriptClass: 'mstrmojo.DefaultDIC',
            
            isDummy: true,
            
            showInPopup: function(){
                mstrmojo.alert('The control style has not been supported yet.');
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.Widget");
    
    mstrmojo.Label = mstrmojo.declare(
        
        mstrmojo.Widget,
        
        null,
        
        {
            scriptClass: "mstrmojo.Label",
            
            
            text: null,

            markupString: '<div id="{@id}" class="mstrmojo-Label {@cssClass}" style="{@cssText}" mstrAttach:click>' + 
                          '</div>',
            
                        
            cssDisplay: 'block',
                          
            markupMethods: {
                ontextChange: function(){ this.domNode.innerHTML = (this.text != null) ? this.text : ''; },
                oncssTextChange: function() { this.domNode.style.cssText = (this.cssText != null) ? this.cssText : ''; },
                onvisibleChange: function(){ this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; }
            },
            
            

            
            autoHide: false,            
            
            
            _set_text: function sttxt(n, v) {
                if (this.autoHide) {
                    this.set('visible', (v!=null) && (v!=="")); 
                }
                var was = this.text;
                this.text = v;
                return was != v;
            }
        }
    );
    
})();
(function(){

	mstrmojo.requiresCls(
		"mstrmojo.Widget",
        "mstrmojo._Formattable");
	
	
	mstrmojo.DocHTMLContainer = mstrmojo.declare(
		
		mstrmojo.Widget,
		
		
        [mstrmojo._Formattable],
		
        
		{
			scriptClass: "mstrmojo.DocHTMLContainer",
			
			scrolling: "auto",
			
	        markupString: '<iframe id="{@id}" class="mstrmojo-DocHTMLContainer" title="{@tooltip}" style="{@domNodeCssText}" src="{@v}" scrolling="{@scrolling}"></iframe>',

            formatHandlers: {
                domNode: [ 'RW', 'B', 'F', 'background-color', 'text-align', 'white-space', 'fx' ]
            },
			
			markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },
            
            
            update: function update(node) {
                this.v = node.data.v;
                
                
                if(mstrApp && mstrApp.isTouchApp()) {
                	this.scrolling = "no";
                }
                
                
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }                
                
                this.thresholdId = node.data.tid;
                this.set('visible', !node.data.hidden);
            }
		}
	);
	
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.Widget");

    
    mstrmojo.StickySections = mstrmojo.declare(
        
        mstrmojo.Widget,
        
        null,
        
        {
            scriptClass: "mstrmojo.StickySections",

            markupString: '<div id="{@id}" style="{@cssText};overflow:hidden">' +
                              '<div class="mstrmojo-StickySections {@cssClass}">{@currentSectionTitle}</div>' +
                          '</div>',

            
            oncurrentSectionTitleChange: function oncurrentTitleChange(evt) {
                this.domNode.lastChild.innerHTML = this.currentSectionTitle;
            },


            
            onMove: function onMove(info) {
                var value = 0;

                
                if (info.isNextRowNewSection) {
                    
                    var position = info.position,
                        rowStart = info.rowStart,
                        directionValue = (rowStart > position) ? (this.domNode.offsetHeight + 1) : 0;

                    
                    value = (rowStart - position) - directionValue;
                }
                
                
                mstrmojo.dom.translate(this.domNode.lastChild, 0, value, 0, "", true);
                
                
                if (info.sectionName && info.sectionName !== this.currentSectionTitle) {
                    this.set('currentSectionTitle', info.sectionName);
                }
            }
        }
    );

}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.Widget",
        "mstrmojo._Formattable");
    
    
    mstrmojo.DocRoundRectangle = mstrmojo.declare(
        mstrmojo.Widget,
        
        [mstrmojo._Formattable],

        
        {
            scriptClass: "mstrmojo.DocRoundRectangle",
            
            markupString: '<div id="{@id}" class="mstrmojo-DocRoundRectangle" title="{@tooltip}" style="{@domNodeCssText}">' +
                            '<div class="mstrmojo-DocRoundRectangle-l1" style="{@tCornersCssText}{@tCornersCssGradText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l2" style="{@tCornersCssText}{@tCornersCssGradText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l3" style="{@tCornersCssText}{@tCornersCssGradText}"></div>' +
                            '<div style="{@rectNodeCssText}{@rectNodeGradCssText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l3" style="{@bCornersCssText}{@bCornersCssGradText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l2" style="{@bCornersCssText}{@bCornersCssGradText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l1" style="{@bCornersCssText}{@bCornersCssGradText}"></div>' +
                        '</div>', 
                        
            markupSlots: {
            	rectNode: function(){ return this.domNode.childNodes[3]; }
            },
            
            markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },	
            
            formatHandlers: {
                domNode: [ 'top', 'left', 'width', 'z-index', 'fx' ],
                rectNode: [ 'height', 'background-color' ],
                tCorners: [ 'background-color' ],
                bCorners: [ 'background-color' ]
            },
            
            update: function update(node) {
                
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }
                
                this.thresholdId = node.data.tid;
                this.set('visible', !node.data.hidden);
            },
            
            
            preBuildRendering: function preBuildRendering() {
            	var rtn = this._super();

            	var f = this.getFormats(),
            		topOnly = !!this.defn.topc,							
            		delta = (topOnly) ? 4 : 8,							
            		$2 = '(\\d*px)',									
            		h = Math.max(parseInt(f.height, 10) - delta, 0);	
            	
            	
            	if (f.height === '100%') {
            		
            		$2 = '(100%)';
            		
            		h = this.parent.height() - delta;
            	}
            	
            	
            	this.rectNodeCssText = this.rectNodeCssText.replace(new RegExp('(.*height:)' + $2 + '(.*)'), '$1' + h + 'px$3');
            	
            	
            	if (topOnly) {
            		
            		this.bCornersCssText = 'display:none;';
            	}
            	
            	return rtn;
            },
            
            
            formatGradient: function formatGradient(gp, flt) {
            	
            	var gd = mstrmojo.css.buildGradient(gp.t, gp.sc, gp.ec);
            	
            	
            	if (!gd) {
            		
            		return;
            	}
            	
            	var gdt = gd.n + ':' + gd.v + ';',
            		bc = 'background-color:';
            	
            	
            	this.rectNodeGradCssText = gdt;
            	
            	
            	if (gp.t === 0) {
            		
            		this.tCornersCssGradText = bc + gp.sc + ';';
            		this.bCornersCssGradText = bc + gp.ec + ';';
            	} else {
            		
            		this.tCornersCssGradText = this.bCornersCssGradText = gdt;
            	}
            }
            
        }
    );
    
})();
(function(){
    
    mstrmojo.requiresCls("mstrmojo.array", "mstrmojo.css", "mstrmojo.string", "mstrmojo.dom");
    
    var $A = mstrmojo.array,
        $C = mstrmojo.css,
        $S = mstrmojo.string,
        $D = mstrmojo.dom,
        _US = 'unselected',
        CSS_DISPLAY = 'inline-block';
    
    mstrmojo.ImageToggle = mstrmojo.declare(
        mstrmojo.Widget,
        null,
        
        {
            scriptClass: 'mstrmojo.ImageToggle',
            
            
            unset: null,
            
            useAnimation: true,
            
            markupString: '<div class="mstrmojo-ImageToggle {@cssClass}" style="{@cssText}" tabindex="{@tabIndex}"  mstrAttach:click,blur,keydown ></div>',
            
            tabIndex: 0,
            
            markupMethods: {
                onimageListChange: function() {
                    var imgs = this.imageList && this.imageList.slice(), 
                        me = this,
                        ust = this.unset, i, div, img;
                    
                    if(!$S.isEmpty(ust) && imgs) {
                        imgs.push({n: ust, v: ust, _ust: true});
                    }
                    if(this.domNode && imgs) {
                        me.domNode.innerHTML = '';
                        me.domNode.style.minHeight = Math.min(20, me.height) + 'px';
                        me.domNode.style.minWidth = Math.min(20, me.width) + 'px';
                        me._loadedImgs = imgs.length;
                        mstrmojo.array.forEach(imgs, function(imgObj, i) {
                            div = document.createElement('div');
                            div.style.cssText = 'display:none;font-size:0px !important;line-height:' + me.height + 'px !important;';
                            
                            img = document.createElement('img');
                            img.alt = img.title = imgObj.v;
                            img.style.verticalAlign = 'middle';
                            img.style.maxHeight = me.height + 'px';
                            
                            img.style.maxWidth = (me.width - 1) + 'px'; 
                            
                            if (!mstrmojo.dom.isIE) {
                                
                                img.onerror = function() {
                                    this.src = '../images/image_not_found.jpg';
                                };
                            }
                            div.appendChild(img);
                            me.domNode.appendChild(div);
                            img.src = imgObj.n || '../images/image_not_found.jpg';
                            
                            
                            if(imgObj._ust) {
                                me.ustImgIdx = i;
                            }
                            me._imgs[i] = div;
                        });
                        
                        this._setSelectedValue();
                    } 
                },
                onvalueChange: function() {
                    this._setSelectedValue();
                }
            },
            
            imageList: null,
            
            value: null,
            
            selectedIndex: -1,
            
            preBuildRendering: function preBldRnd() {
                if(this._super) {
                    this._super();
                }
                
                this._imgs = [];
            },

            _setSelectedValue: function setSltV() {
                var me = this, 
                    s = this.selectedIndex, 
                    imgs = this.imageList;
                
                if(imgs) {
                    
                    if(imgs[s]) {
                        me._imgs[s].style.display = 'none';
                    }
                    $A.forEach(this.imageList, function(img, i) {
                        if(img.v == me.value) {
                            $C.removeClass(me.domNode, _US);
                            me.selectedIndex = i;
                            me._imgs[i].style.display = CSS_DISPLAY;
                            return ;
                        }
                    });
                    
                    if(this.selectedIndex === -1) {
                        if(!this.unset) {
                            
                            $C.addClass(this.domNode, _US);
                        } else {
                            var div = this._imgs[this.ustImgIdx],
                                img = div.lastChild;
                            
                            img.alt = img.title = this.value;
                            div.style.display = CSS_DISPLAY; 
                        }
                    }
                }
            },
            
            onclick: function onclk() {
                var imgs = this.imageList,
                    len = imgs && imgs.length,
                    d = 300,
                    s = this.selectedIndex,
                    ls = s,
                    p = this.domNode,
                    e1, e2, c, t, me = this;
                
                c = (s === -1 && this.ustImgIdx !== null) ? this._imgs[this.ustImgIdx] : this._imgs[s];
                s = (s + 1) % len;
                t = this._imgs[s];
                $C.removeClass(p, _US);
                this.selectedIndex = s;
                
                if (this.useAnimation){
                    e2 = new mstrmojo.fx.FadeIn({
                        duration: d,
                        
                        interval: ($D.isIE8 ? (d/3) : (d/10)),
                        target: t,
                        preStart: function(){
                            this.target.style.display = CSS_DISPLAY;
                        }
                    });
                    
                    e1 = new mstrmojo.fx.FadeOut({
                        duration: d,
                        
                        interval: ($D.isIE8 ? (d/3) : (d/10)),
                        target: c,
                        onEnd: function() {
                            c.style.display = 'none';
                            
                            if(ls === -1) {
                                me._imgs.splice(me.ustImgIdx, 1);
                                p.removeChild(c);
                                delete me.ustImgIdx;
                            }
                            e2.play();
                        }
                    });
    
                    
                    if(c) {
                        e1.play();
                    }else {
                        e2.play();
                    }
                }else {
                    if (c){
                        c.style.display ='none';
                        if(ls === -1) {
                            me._imgs.splice(me.ustImgIdx, 1);
                            p.removeChild(c);
                            delete me.ustImgIdx;
                        }
                    }
                    t.style.display = CSS_DISPLAY;
                }
                
                this.value = this.imageList[s].v;
            },
            
            onkeydown: function(evt){
                var hWin = evt.hWin, 
                    e = evt.e || hWin.event;
                
                if (e.keyCode === mstrmojo.Enum_Keys.SPACE){ 
                    mstrmojo.dom.preventDefault(hWin, e);
                    this.onclick();
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo.dom",
                         "mstrmojo._IsAnchorable");

    var POS_LEFT = 1,
        POS_RIGHT = 2,
        POS_TOP = 3,
        POS_BOTTOM = 4;
    var AREA_TYPE_TITLE = 'title',
        AREA_TYPE_CONTENT = 'content';

    
    mstrmojo.VisTextTooltip = mstrmojo.declare(
        mstrmojo.Widget,

        [mstrmojo._IsAnchorable],

        {
            scriptClass: 'mstrmojo.VisTextTooltip',

            left: 0,

            top: 0,

            zIndex: 10,

            boundaryNodeName : "boundary",

            popupNodeName : 'infoNode',

            baseTipClass: 'mstrmojo-vis-tip',

            anchorOffset : 1,

            anchorOrientation : 'h',

            anchor: null,

            boundary: null,

            tipNodeColor: '#ffffff',

            utils: mstrmojo.VisChartUtils,

            touchAreaType: AREA_TYPE_CONTENT,

            markupString: '<div id="{@id}" class="{@cssClass}" style="top:{@top}px;left:{@left}px;z-index:{@zIndex};position:absolute;{@cssText};">' +
                    '<div class="timeseries-slider-tooltip" style="display: block"></div>' +
                    '<div class="mstrmojo-vis-tip" style="display: block"></div>' +
                '</div>',

            markupSlots: {
                infoNode: function () { return this.domNode.firstChild; },
                tipNode: function () { return this.domNode.childNodes[1]; }
            },

            toggle: function toggle(show) {
                if (show) {
                    this.domNode.style.display = 'block';
                } else {
                    this.domNode.style.display = 'none';
                }
            },

            updateContent: function (anchor, touchAreaType, text) {
                this.fillContent(anchor, touchAreaType, text);
                this.positionDialog();
            },

            
            fillContent: function fC(anchor, touchAreaType, text) {
                this.anchor = anchor;
                this.touchAreaType = touchAreaType;
                this.domNode.firstChild.innerHTML = text || this.anchor.innerText;
                this.toggle(true);
            }

            

        }

    );

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo.dom",
                         "mstrmojo.hash",
                         "mstrmojo.css");

    var $DOM = mstrmojo.dom,
        $HASH = mstrmojo.hash,
        $CSS = mstrmojo.css;

    
    mstrmojo.Button = mstrmojo.declare(
        
        mstrmojo.Widget,

        
        null,

        
        {
            scriptClass: 'mstrmojo.Button',

            
            iconClass: '',

            
            innerIconClass: '',

            
            title: '',

            
            text: '&nbsp;',

            
            enabled: true,

            
            selected: false,

            
            cssDisplay: 'block',

            
            markupString: '<div id="{@id}" class="mstrmojo-Button {@cssClass} {@iconClass}" title="{@title}" style="{@cssText}" mstrAttach:touchstart,click,mousedown,mouseup>' +
                            '<div class="mstrmojo-Button-text {@innerIconClass}"></div>' +
                          '</div>',

            
            markupSlots: {
                textNode: function () { return this.domNode.firstChild; }
            },

            
            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; },
                onenabledChange: function () {
                    $CSS[this.enabled ? 'removeClass' : 'addClass'](this.domNode, ['disabled']);
                },

                onselectedChange: function () {
                    $CSS[this.selected ? 'addClass' : 'removeClass'](this.domNode, ['selected']);
                },

                ontextChange: function () {
                    this.textNode.innerHTML = this.text;
                },

                onwidthChange: function () {
                    var w = this.width;
                    if (w) {
                        this.domNode.style.width = w;
                    }
                }
            },

            oniconClassChange: function oniconClassChange(evt) {
                if (this.hasRendered && this.domNode) {
                    var old = evt.valueWas,
                        v = evt.value;
                    this.domNode.className = this.domNode.className.replace(old, '') + ' ' + v;
                }
            },

            
            onclick: mstrmojo.emptyFn,

            ontouchend: function ontouchend(evt) {
                this.onclick(evt);
            }
        }
    );

    
    mstrmojo.Button.newIconButton = function (t, c, fn, b, ps) {
        
        var btn = {
            scriptClass: 'mstrmojo.Button',
            title: t,
            cssClass: c,
            text: '',
            onclick: fn
        };

        
        if (b) {
            
            btn.bindings = b;
        }

        
        $HASH.copy(ps, btn);

        return btn;
    };

    
    mstrmojo.Button.newInteractiveButton = function (t, fn, haloColor, ps) {
        
        var btn = {
            scriptClass: 'mstrmojo.Button',
            cssClass: 'mstrmojo-InteractiveButton',
            text: t,
            glowClass: "glow"
        };

        
        if (fn) {
            btn.onclick = fn;
        }

        
        if (haloColor && ($DOM.isFF || $DOM.isWK)) {
            
            $HASH.copy({
                onmousedown: function () {
                    $CSS.applyShadow(this.domNode, 0, 0, 10, haloColor);
                },
                onmouseup: function () {
                    $CSS.removeShadow(this.domNode);
                }
            }, btn);
        }

        
        $HASH.copy(ps, btn);

        return btn;
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo.dom");

    var baseCssClass = 'mstrmojo-Image';

    
    mstrmojo.Image = mstrmojo.declare(

        mstrmojo.Widget,

        null,

        
        {
            scriptClass: "mstrmojo.Image",

            markupString: '<div id="{@id}" class="' + baseCssClass + ' {@cssClass}" style="{@cssText}" mstrAttach:click>' +
                              '<image src="{@src}" mstrAttach:load />' +
                          '</div>',


            markupSlots: {
                imgNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onsrcChange: function () {
                    
                    var imgNode = this.imgNode;
                    if (imgNode) {
                        
                        imgNode.src = this.src || '../javascript/mojo/css/images/1ptrans.gif';
                    }
                },
                oncssClassChange: function () {
                    
                    var domNode = this.domNode;
                    if (domNode) {
                        
                        domNode.className = this.cssClass || baseCssClass;
                    }
                },
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },

            
            src: '',

            
            getImageSize: function getImageSize() {
                var imgNode = this.imgNode;
                return {
                    w: imgNode.clientWidth,
                    h: imgNode.clientHeight
                };
            }
        }
    );

    
    mstrmojo.Image.baseCssClass = baseCssClass;

}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.Widget",
        "mstrmojo._Formattable");
    
    
    mstrmojo.DocRectangle = mstrmojo.declare(
        mstrmojo.Widget,
        
        [mstrmojo._Formattable],

        
        {
            scriptClass: "mstrmojo.DocRectangle",

            markupString: '<div id="{@id}" class="mstrmojo-DocRectangle" title="{@tooltip}" style="{@domNodeCssText}"></div>', 

            markupMethods: {
                onheightChange: function(){
                    if (this.height) {
                        this.domNode.style.height = this.height + 'px';
                    }
                },
                onwidthChange: function(){
                    if (this.width) {
                        this.domNode.style.width = this.width + 'px';
                    }
                },
				onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },
            
            formatHandlers: {
                domNode: ['RW', 'B', 'background-color', 'fx']
            },
            
            
            preBuildRendering: function preBuildRendering() {
            	var rtn = this._super(),
            		defn = this.defn;
            	
            	
            	if (defn.r) {
            		
               		this.domNodeCssText += mstrmojo.css.buildRoundCorners(defn.r, defn.topc);
            	}
            	
            	return rtn;
            },
            
            
            postBuildRendering: function() {
                var rtn = this._super();
                   
                
                var fmts = this.fmts;
                if (fmts) {
                    var b = fmts.border || fmts['border-width'],
                        bw = b && (parseInt(b, 10) / 72 * this.model.dpi ); 
                        
                    if (bw) {
                        if (fmts.height == '100%') {
                            this.set('height', this.domNode.clientHeight - 2 * bw);
                        }
                        if (fmts.width == '100%') {
                            this.set('width', this.domNode.clientWidth - 2 * bw);
                        }
                    }
                }
                return rtn;
            },
            
            update: function update(node) {
                
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }
                
                this.thresholdId = node.data.tid;
                
				this.set('visible', !node.data.hidden);
				
                if (this._super) {
                    this._super(node);
                }
            }
        }
    );
    
})();
(function () {

    mstrmojo.requiresCls(
        "mstrmojo.Widget"
    );
    
    var HOLD_INTERVAL = 50,
        HOLD_THRESHOLD = 500;
    
    
    mstrmojo.Stepper = mstrmojo.declare(
        
        mstrmojo.Widget,
            
        
        null,
            
        {

            scriptClass: "mstrmojo.Stepper",
            
            
            orientation: 'vertical',
            
            
            provider: null,
            
            
            title: '',
            
            markupString:   '<div id="{@id}" class="mstrmojo-Stepper {@orientation} {@cssClass}" mstrAttach:click,mousedown,mouseup,selectstart>' +
                                '<div class="title">{@title}</div>' +
                                '<div class="next">+</div>' +
                                '<div class="text">{@itemHtml}</div>' +
                                '<div class="prev">-</div>' +
                            '</div>',
                            
            markupSlots: {
                titleNode: function() { return this.domNode.firstChild; },
                nextNode: function () { return this.domNode.children[1]; },
                textNode: function () { return this.domNode.children[2]; },
                prevNode: function () { return this.domNode.lastChild; }
            },
            
            
            preBuildRendering: function preBuildRendering() {
                
                this.itemHtml = this.provider.renderItemAt();
                
                
                this._super();
            },
            
            
            processEvent: function processEvent(target) {
                
                if (target === this.textNode || target === this.titleNode) {
                    
                    return;
                }
                
                var provider = this.provider,
                    mthd = ((target === this.nextNode) ? 'Next' : 'Prev');

                
                if (provider['has' + mthd]()) {
                    
                    provider[mthd.toLowerCase()]();
                    
                    
                    this.updateDisplayText();
                }
            },
            
            
            updateDisplayText: function updateDisplayText(){
                this.textNode.innerHTML = this.provider.renderItemAt();
            },
            
            
            startStepperInterval: function startStepperInterval(evt, fn) {
                var me = this;
                
                this._holdTimer = setInterval(function () {
                    
                    me[fn](evt);
                }, HOLD_INTERVAL);
            },
            
            
            stopStepperInterval: function stopStepperInterval() {
                
                if (this._holdTimer) {
                    clearInterval(this._holdTimer);
                    delete this._holdTimer;
                }
            },
            
            
            onclick: function onclick(evt) {
                this.processEvent(evt.e.target);
            },
    
            
            onmousedown: function onmousedown(evt) {
                
                if (!this._holdTimer && !this._startHoldTimer) {
                    var me = this;
                    
                    this._startHoldTimer = setTimeout(function () {
                        
                        delete me._startHoldTimer; 
                        
                        
                        me.startStepperInterval(evt, 'onclick');
                        
                    }, HOLD_THRESHOLD);
                }
            },
            
            
            onmouseup: function onmouseup() {
                
                if (this._startHoldTimer) {
                    clearTimeout(this._startHoldTimer);
                    delete this._startHoldTimer;
                }
                
                
                this.stopStepperInterval(this);
            },
            
            
            onselectstart: function onselectstart() {
                return false;
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls( "mstrmojo.publisher",
    					"mstrmojo.Widget",
                         "mstrmojo.fx",
                         "mstrmojo.locales",
                         "mstrmojo.expr",
                         "mstrmojo.date",
                         "mstrmojo.css");
    
    var _DT = function(){ return mstrmojo.locales.datetime; },
        $D = mstrmojo.dom,
        $E = mstrmojo.expr,
        DTP = $E.DTP,
        $P = mstrmojo.date,
        _P = mstrmojo.publisher,
        $H = mstrmojo.hash,
        $A = mstrmojo.array,
        $RMV = $A.removeIndices,
        $C = mstrmojo.css;
    
    var _pre_table = '<table border="0" cellpadding="0" cellspacing="0">',
        _post_table = '</table>';
    function _pre_table_with_style(style){
    	return '<table border="0" cellpadding="0" cellspacing="0" style="' + style + '">';
    }
    function _getLeadingBlanks(y,m,fdw){
        var fd = $P.getFirstDateOfMonth(y,m);
        return (fd.getDay() - fdw + 8) % 7;
    }
    
    
    function parseDateAndTimeToJSON(value) {
        
        var dt = $P.parseDateAndOrTime(value),
            d, t, r;
        
        
        if(dt){
            
            r = {};
            d = dt.date;
            t = dt.time;
            if(d) {
                $H.copy(d, r);
            }
            if(t) {
                $H.copy(t, r);
            }
        }
        
        
        return r;
    }
    
    
    
    function isDateInDateTimeRange(day, month, year, min, max) {
        var d = $P.formatDateInfo({day: day, month: month, year: year}, _DT().DATEOUTPUTFORMAT);
        
        return $P.inDateTimeRange(d, min, max) == 0;
    }
    
    
    function updateTraversalIcons(widget, prev, next) {
        var db = widget.decreaseButton,
            ib = widget.increaseButton,
            cssPrefix = 'mstrmojo-Calendar',
            updateCSS = function (node, className, date) {
                
        		var disabled = !isDateInDateTimeRange(date.d, date.m, date.y, widget.min, widget.max);
                node.className = (cssPrefix + className) + (disabled ? ' disabled' : '');
                node.disabled = disabled; 
            };

        
        updateCSS(db, '-decrease', prev);
        updateCSS(ib, '-increase', next);
    }
    
    
    function isDateSelected(selectedDates, day, month, year) {
        var i = 0,
            len = selectedDates.length,
            sd;
    
        for (i = 0; i < len; i++) {
            
            sd = selectedDates[i];
            
            
            if (sd && sd.day === day && sd.month === month && sd.year === year) {
                return i;
            }
        }
        
        return -1;
    }
    
    function isToday(day,month,year){
    	var td = new Date();
    	return (td.getFullYear() == year)
    		&& ((td.getMonth() + 1) == month)
    		&& (td.getDate() == day);
    }
    
    
    function removeSelection(widget, index) {
        var divs = widget.dayView.getElementsByTagName('div'),
            sd = widget.selectedDates,
            date = sd[index],
            by = widget.browseYear,
            bm = widget.browseMonth,
            l = $P.getDaysOfMonth(by, bm), 
            pm = $P.getPreMonth(by,bm),
            pl = $P.getDaysOfMonth(pm.y, pm.m), 
            lb = _getLeadingBlanks(by, bm, widget.firstDayOfWeek),
            inx = ((date.month == bm) ? date.day + lb -1:
                 (date.month > bm ? date.day + lb + l -1 : 
                     lb - pl + date.day -1)),
            d = divs[inx];
        
        
        
        if(d){
           	toggleSelectionStyle(d, widget, false);
        }
        
        
        $RMV(sd, index, 1);
    }
    
    function clearSelection(widget) {
        var sd = widget.selectedDates;
        
        while(sd.length) {
            removeSelection(widget, 0);
        }
    }
    
    function addSelectionByElems(widget, elem) {
        var ymd = getYMDFromElem(widget, elem),
            sds = widget.selectedDates;
        
        sds.push({
            day: ymd.d, 
            month: ymd.m, 
            year: ymd.y
        });
        
        toggleSelectionStyle(elem, widget, true);
    }
    
    function addSelectionByDates(widget, dates) {
        if (!dates || !dates.length) return null;
        var sds = widget.selectedDates;
        for(var i = 0, len = dates.length; i < len; i++) {
            var d = dates[i],
                div = getElemFromDate(widget, d);
            sds.push({
                day: d.d, 
                month: d.m, 
                year: d.y
            });
            
            if (div) {
            	toggleSelectionStyle(div, widget, true);
            }
        }
    }
    
    function getElemFromDate(widget, d) {
        var divs = widget.dayView.getElementsByTagName('div'),
            ldivs = divs.length,
            by = widget.browseYear,
            bm = widget.browseMonth,
            pm = $P.getPreMonth(by,bm),
            pl = $P.getDaysOfMonth(pm.y, pm.m), 
            nm = $P.getNextMonth(by, bm),
            l = $P.getDaysOfMonth(by, bm), 
            lb = _getLeadingBlanks(by, bm, widget.firstDayOfWeek); 
            
        var fdate = lb > 0 ? {y:pm.y , m:pm.m, d:divs[0].innerHTML} : {y:by, m:bm, d:divs[0].innerHTML},
            ldate = (divs.length - l -lb) > 0 ? {y:nm.y, m:nm.m, d:divs[ldivs-1].innerHTML} : {y:by, m:bm, d:divs[ldivs-1].innerHTML},
            diff_fdate = diffDates(fdate, d),
            diff_ldate = diffDates(d, ldate),
            index = null;
        
        
        if (diff_fdate >= 0 && diff_ldate >=0) {
            var ma = 0;
            if (diff_fdate < lb) ma = -1;
            if (diff_ldate < (divs.length - lb -l)) ma = 1;
            index = ((ma == 0) ? d.d + lb - 1 :
                (ma == 1 ? d.d + lb + l - 1 : 
                    lb - pl + d.d -1));
            return divs[index];
        } else {
            return null;
        }
    }
    
    function getShiftSelection(widget, div) {
        var sd = widget.selectedDates,
            length = sd.length;
    
        if (!length) {
            return null;
        }
    
        var ld = sd[length - 1],
            cd = getYMDFromElem(widget, div),
            df = diffDates({y:ld.year, m:ld.month, d:ld.day}, cd),
            selection = [],
            inc = df > 0,
            sz = Math.abs(df);
            
        for(var i= 0;i <= sz; i++){
            var nd = new Date(cd.y, cd.m -1, cd.d);
            nd.setDate(nd.getDate() + (inc?-i:i));
            var y = nd.getFullYear(), m = nd.getMonth() + 1, d = nd.getDate();
            if (widget.isDateDisabled(d, m, y, widget.min, widget.max)) continue;
            selection.push({'y':y,'m':m,'d':d});
        }
        
        return selection;

    }
    
    function diffDates(from, to) {
        var fd = new Date(from.y, from.m - 1, from.d),
            td = new Date(to.y, to.m - 1, to.d);
        
        return (td - fd)/1000/3600/24;
    }
    function getYMDFromElem(widget, elem) {
        var by = widget.browseYear,
            bm = widget.browseMonth,
            d = parseInt(elem.innerHTML,10),
            ma =  parseInt(elem.getAttribute("m"),10)
            ymd = null;
        
        ymd = (ma === 0) ? {y: by, m: bm} : (ma === 1 ? $P.getNextMonth(by,bm) : $P.getPreMonth(by,bm));  
        ymd.d = d;
        return ymd;
    }
    
    
    function getLastSelectedDate(w) {
        var sds = w.selectedDates,
            length = sds.length;
        
        return (length === 0) ? null : sds[length - 1];
    }
    
    function toggleSelectionStyle(elem, widget, select) {
        var c = widget.selectedColor;
        $C.toggleClass(elem,['selected', widget.selectedCssStyle], select);
        elem.parentNode.style.backgroundColor = select?c:'';
        elem.style.backgroundColor = select?c:'';
    }
    
    function selectedStyle(widget){
    	return widget.selectedColor?('style="background-color:'+widget.selectedColor+';"'):'';
    }
    
    function findTarget(t) {
        return (t.tagName.toLowerCase() == 'td') ? t.firstChild : t;
    }
    
    mstrmojo.Calendar = mstrmojo.declare(
        
        mstrmojo.Widget,
        
        null,
        
        
        {
            scriptClass: "mstrmojo.Calendar",
            
            
            cssPrefix: '',
            
            
            browseMonth: null,
            
                        
            browseYear: null,
            
                        
            yearRangStart: null,
            
            
            selectedDates: null,
            
            
            
            selectedColor:'',
            
            isMultiSelect: false,
            
            
            
            hilightToday: false,
            
            
            yearViewSize: 5,
            
            cssTextDay:'',
            cssTextMonth:'',
            cssTextYear:'',
            cssTextWeekDay:'',
            cssTextHeader:'',
            cssTextMonthYearLabel:'',
            
            forceNonEmptySelection: false,
            
            
            showCurMonthDatesOnly:false,
            
            
            currentView: 'day',
            
            
            duration:600,
            
            
            timeDelimiter:':',
            
            
            dtp:DTP.DATE,
            
            
            value: '',
            
            
            firstDayOfWeek: 1, 
            
            
            changeValueOnOK: false,
            
            
            okLabel: mstrmojo.desc(1442,'OK'),
            
            
            monthNames: function(i){return _DT().MONTHNAME_SHORT[i];},
            
            
            dayNames: function(i){return _DT().dayShortNames[i];},
            
            
            min: null,
            
            
            max: null,
            
            
            supportedViews: {
                day: true,
                month: true,
                year: true,
                hour: true,
                minute: true,
                second: true
            },
            
            
            sDirMatrix:{
                day:{'month':'down','year':'down','hour':'up','minute':'up','second':'up'},
                month:{'day':'up','year':'left','hour':'up','minute':'up','second':'up'},
                year:{'day':'up','month':'right','hour':'up','minute':'up','second':'up'},
                hour:{'day':'down','month':'down','year':'down','minute':'left','second':'left'},
                minute:{'day':'down','month':'down','year':'down','hour':'right','second':'left'},  
                second:{'day':'down','month':'down','year':'down','hour':'right','minute':'right'} 
            },
            
            markupString:'<div id="{@id}" class="{@cssPrefix} mstrmojo-Calendar {@cssClass}" style="{@cssText}" mstrAttach:mousedown,mouseup,mouseover,mouseout>' + 
                            '<div class="mstrmojo-Calendar-header" style="{@cssTextHeader}">' +
                                '<div class="mstrmojo-Calendar-decrease"></div>' +
                                '<div class="mstrmojo-Calendar-increase"></div>' +
                                '<div class="mstrmojo-Calendar-title">' +
                                  '<span class="mstrmojo-Calendar-monthLabel" style="{@cssTextMonthYearLabel}">{@browseMonth}</span>' +
                                  '<span class="mstrmojo-Calendar-comma">,</span>' +
                                  '<span class="mstrmojo-Calendar-yearLabel" style="{@cssTextMonthYearLabel}">{@browseYear}</span>' +        
                                '</div>' +                             
                            '</div>' +
                            '<div class="mstrmojo-Calendar-body" style="{@cssTextBody}">' +
                                '<div class="mstrmojo-Calendar-dayView"></div>' +    
                            '</div>' +
                            '<div class="mstrmojo-Calendar-timePart">' +
                                '<span class="mstrmojo-Calendar-hourLabel">00</span>' +
                                '<span class="mstrmojo-Calendar-timeDelimiter">{@timeDelimiter}</span>' +                                
                                '<span class="mstrmojo-Calendar-minuteLabel">00</span>' +    
                                '<span class="mstrmojo-Calendar-timeDelimiter">{@timeDelimiter}</span>' +    
                                '<span class="mstrmojo-Calendar-secondLabel">00</span>' +    
                            '</div>' +
                            '<div class="mstrmojo-Calendar-tools">' +
                                '<div class="mstrmojo-Calendar-ok"> {@okLabel} </div>' + 
                            '</div>' +                            
                         '</div>',
            
            markupMethods: {
                onvisibleChange: function(){this.domNode.style.display = this.visible ? 'block' : 'none';},                
                onbrowseMonthChange:function(){this.monthLabel.innerHTML = this.monthNames(this.browseMonth - 1);},
                onbrowseYearChange:function(){this.yearLabel.innerHTML = this.browseYear;},
                ondtpChange:function(){this.timePart.style.display = (this.dtp === DTP.TIMESTAMP || this.dtp === DTP.TIME) ? "block" : "none";},
                onvalueChange:function(){
                    if(this.lastValue === undefined || this.value !== this.lastValue){
                            this.updateSelectedDate();
                        }
                },
                onchangeValueOnOKChange:function(){this.tools.style.display = (this.changeValueOnOK ? "block" : "none");}
            },
            
            markupSlots: {
                monthLabel: function(){return this.domNode.firstChild.lastChild.firstChild;},
                yearLabel: function(){return this.domNode.firstChild.lastChild.lastChild;},
                decreaseButton:function(){return this.domNode.firstChild.firstChild;},
                increaseButton:function(){return this.domNode.firstChild.childNodes[1];},                
                bodyContainer: function(){return this.domNode.childNodes[1];},
                dayView:function(){return this.domNode.childNodes[1].firstChild;},
                monthView:function(){return this.domNode.childNodes[1].childNodes[1];},
                yearView:function(){return this.domNode.childNodes[1].lastChild;},
                timePart:function(){return this.domNode.childNodes[2];},
                hourLabel:function(){return this.domNode.childNodes[2].firstChild;},
                minuteLabel:function(){return this.domNode.childNodes[2].childNodes[2];},
                secondLabel:function(){return this.domNode.childNodes[2].childNodes[4];},
                tools:function(){return this.domNode.childNodes[3];},
                okButton: function(){return this.domNode.childNodes[3].firstChild;}
            },
            
            init:function init(props){
                if(this._super) {
                    this._super(props);
                }
                if(this.duration<1) {
                    this.duration = 1;  
                }
                
                
                if (!this.selectedDates) {
                    this.selectedDates = [];
                }
                
                this.timeVal = { hour: 0, min: 0, sec: 0 };
            },
            
            
            getSelectedDatesAsString: function getSelectedDatesAsString(format) {
                var result = [];
                
                
                $A.forEach(this.selectedDates, function (sd) {
                    result.push($P.formatDateInfo(sd, format || _DT().DATEOUTPUTFORMAT));
                });
                
                return result;
            },
            
            
            updateSelectedDate: function updateSelectedDate(){
                var v = this.value,
                    tv = this.timeVal,
                    sds = this.selectedDates,
                    r, update = function (me, r) {
                        me.set('browseYear',r.year);
                        me.set('browseMonth',r.month);
                        me.updateTimePart();
                        me.updateView(me.currentView);
                    };
                
                
                if (sds.length === 0) {
                    
                    if(v){
                        
                        r = parseDateAndTimeToJSON(v);
                        
                        if (r && r.hour !== undefined){
                            tv.hour = r.hour;
                            tv.min = r.min;
                            tv.sec = r.sec;
                        }
                    }
                    
                    
                    if(!r){
                        
                        r = $P.getDateJson(new Date());
                    }
                    
                    
                    if (this.isDateDisabled(r.day, r.month, r.year, this.min, this.max)) {
                        
                        if (this.min && $P.compareDate(r, this.min) < 0) {
                            r = parseDateAndTimeToJSON(this.min);
                        } else if (this.max && $P.compareDate(r, this.max) > 0) {
                            r = parseDateAndTimeToJSON(this.max);
                        }
                    }
                    
                    
                    sds.push(r);
                    
                    update(this, r);                 

                } else {
                    
                    r = sds[0];
                    
                    if (this.value != null) {

                        update(this, r);                 
                    }
                }
                
            },
            
            
            updateValue: function updateValue(){
                var sd = getLastSelectedDate(this),
                    v = '';
                
                if (sd) {
                    v = $P.formatDateInfo(sd,_DT().DATEOUTPUTFORMAT);
                    if (this.dtp !== DTP.DATE) {
                        v += ' ' + $P.formatTimeInfo(this.timeVal, _DT().TIMEOUTPUTFORMAT);
                    } 
                }
                
                this.lastValue = v;                
                this.set('value', v);                
                
                if(this.onValueUpdate) {
                    this.onValueUpdate();
                }                
            },   
            
            
            updateTimePart:function updateTimePart(){
                var time = this.timeVal,
                    hh = time.hour || 0,
                    twelve = (hh % 12 === 0) ? 12 : (hh % 12);
                this.hourLabel.innerHTML = hh < 12 ? twelve + _DT().AM_NAME : twelve + _DT().PM_NAME;
                this.minuteLabel.innerHTML = $P.formatInteger(time.min || 0, 2);
                this.secondLabel.innerHTML = $P.formatInteger(time.sec || 0, 2);
            },                  
            
            
            premousedown: function(evt){
                var e = evt.e,
                    t = $D.eventTarget(evt.hWin,e);
                if(t === this.decreaseButton || t === this.increaseButton){
                	if($D.isFF){ 
                		$D.stopPropogation(window,e);
                	}
                    return true;
                }else{
                	
                	return this.processEvent(t, e);
                }
            },
                
            premouseup: function(evt){
            	var e = evt.e;
            	if(e.ctrlKey || e.shiftKey){
            		$D.clearBrowserHighlights();
            	}
            	var t = $D.eventTarget(evt.hWin,e);
                if(t === this.decreaseButton && !t.disabled){
                    this.decrease();
                    return true;
                }
                
                if(t === this.increaseButton && !t.disabled){
                    this.increase();
                    return true;
                }
            	
            },
                
            processEvent: function(t, e) {
                var cv = this.currentView,
                    sds = this.selectedDates,
                    sd = getLastSelectedDate(this),
                    y, m, d, ma, v; 
                
                
                if(t === this.okButton && this.changeValueOnOK){
                    this.updateValue();
                }
                
                if(t === this.monthLabel){
                    if(cv !== 'month') {
                        this.switchViewTo('month');
                    }
                    return true;
                }
                
                if(t === this.yearLabel){
                	if (cv !== 'year') {          
                		this.adjustYearStart();
                		this.switchViewTo('year');
                    	return true;
                	}
                }
                
                if(t === this.hourLabel){                  
                    if(cv !== 'hour') {
                        this.switchViewTo('hour');
                    }
                    return true;
                }                
                
                if(t === this.minuteLabel){                  
                    if(cv !== 'minute') {
                        this.switchViewTo('minute');
                    }
                    return true;
                }
                
                if(t === this.secondLabel){
                    if(cv !== 'second') {
                        this.switchViewTo('second');
                    }
                    return true;
                }    
                
                if($D.contains(this.hourView, t, false,this.domNode)){
                    var ha = t.getAttribute('h');
                    
                    v = parseInt(t.innerHTML, 10);
                    
                    if(!isNaN(ha) && !isNaN(v)){
                        ha = parseInt(ha,10);
                        this.timeVal.hour = v%12 + ha * 12;
                        this.updateTimePart();  
                        this.switchViewTo('day');
                        if(!this.changeValueOnOK){
                            this.updateValue(); 
                        }                       
                    }
                    return true;                     
                }
                
                if($D.contains(this.minuteView, t, false,this.domNode)){
                    v = parseInt(t.innerHTML, 10);
                    if(!isNaN(v)){
                        this.timeVal.min = v;
                        this.updateTimePart();
                        this.switchViewTo('day');
                        if(!this.changeValueOnOK){
                            this.updateValue();        
                        }
                    }
                    return true;                    
                }  
                
                if($D.contains(this.secondView, t, false,this.domNode)){
                    v = parseInt(t.innerHTML, 10);
                    if(!isNaN(v)){
                        this.timeVal.sec = v;
                        this.updateTimePart();
                        this.switchViewTo('day');
                        if(!this.changeValueOnOK){
                            this.updateValue(); 
                        }
                    }
                    return true;                    
                }                  
                
                if($D.contains(this.dayView, t, false,this.domNode)){
                    
                    var by = this.browseYear,
                        bm = this.browseMonth,
                        pnm;
                    
                    t = findTarget(t);
                    d = parseInt(t.innerHTML,10);
                    ma = parseInt(t.getAttribute("m"),10);
                    
                    if(!isNaN(d) && !isNaN(ma)){
                        pnm = (ma === 0) ? {y: by, m: bm} : (ma === 1 ? $P.getNextMonth(by,bm) : $P.getPreMonth(by,bm));  
                        
                        
                        if(this.isDateDisabled(d, pnm.m, pnm.y, this.min, this.max) || e.button==2) {
                            return true;
                        }
                        
                        var selIndex = isDateSelected(sds, d, bm, by),
                        	ms = sds.length > 1,
                        	nonEmpty = this.forceNonEmptySelection,
                        	ims = this.isMultiSelect,
                            ctrl = ims && e.ctrlKey,
                            shift = ims && e.shiftKey,
                            dates = null;
                       
                        if (shift) { 
                            dates = getShiftSelection(this, t);
                            clearSelection(this);
                            addSelectionByDates(this, dates);
                        } else if(ctrl){
                            if(selIndex === -1){
                                addSelectionByElems(this, t);
                            }else{
                            	if(!nonEmpty || ms){
                            		removeSelection(this, selIndex);
                            	}
                            }
                        }else{
                            clearSelection(this);
                            if (ms || selIndex === -1 || nonEmpty) {
                                addSelectionByElems(this, t);
                            }
                        }
                        if (this.onselect || _P.hasSubs(this.id, "select") ) {
                                this.raiseEvent({
                                    name: "select", 
                                    value: this.selectedDates
                                });
                        }
                        
                        if(ma === 1) {
                            this.increase();
                        } else if(ma === -1) {                       
                            this.decrease();
                        }  
                        
                        if(!this.changeValueOnOK){
                            this.updateValue();
                        }
                    }
                    return true;
                }
                
                if($D.contains(this.monthView, t, false,this.domNode)){
                	t = findTarget(t);
                    m = parseInt(t.getAttribute('m'),10);
                    if(!isNaN(m)){
                        this.set("browseMonth", m + 1);
                        this.switchViewTo('day');
                    }
                    return true;
                }

                if($D.contains(this.yearView, t, false,this.domNode)){
                	t = findTarget(t);
                    y = parseInt(t.innerHTML,10);
                    if(!isNaN(y)){
                        this.set("browseYear", y);
                        this.switchViewTo('day');
                    }
                    return true;
                }
                
                return true;
            },             
            
            
            decrease: function(){
                var v = this.currentView,
                    newView = v,
                    y = this.browseYear,
                    m = this.browseMonth,
                    yrs = this.yearRangStart,
                    pre;
                
                switch(v){
                case 'day':
                    pre = $P.getPreMonth(y, m);
                    this.set('browseMonth', pre.m);
                    this.set('browseYear', pre.y);
                    break;
                case 'month':
                    this.set('browseYear', y - 1);
                    break;
                case 'year':
                    this.yearRangStart = yrs - this.yearViewSize * this.yearViewSize;
                    break;
                case 'hour':
                        newView = 'second';
                    break;
                case 'minute':
                        newView = 'hour';
                    break;
                case 'second':
                        newView = 'minute';
                    break;
                }

                
                this.switchViewTo(newView,'right');
            },
            
                        
            increase: function(){
                var v = this.currentView,
                    newView = v,
                y = this.browseYear,
                m = this.browseMonth,
                yrs = this.yearRangStart,
                next;

                switch(v){
                case 'day':
                    next = $P.getNextMonth(y, m);
                    this.set('browseMonth', next.m);
                    this.set('browseYear', next.y);
                    break;
                case 'month':
                    this.set('browseYear', y + 1);
                    break;
                case 'year':
                    this.yearRangStart = yrs + this.yearViewSize * this.yearViewSize;
                    break;
                case 'hour':
                        newView = 'minute'; 
                    break;
                case 'minute':
                        newView = 'second'; 
                    break;
                case 'second':
                        newView = 'hour';
                    break;                    
                }                
                
                
                this.switchViewTo(newView,'left');
            },         
            
            
            updateView: function(v){
                var html = this[v + 'ViewHTML']();
                this[v + 'View'].innerHTML = html;
            },
            adjustYearStart: function(){
            	this.yearRangStart = this.browseYear - 10 - this.browseYear%5;
            },
            

            switchViewTo: function(v,dr){
                var cn = 'mstrmojo-Calendar-' + v + 'View', 
                    div = document.createElement('div'),
                    cv = this[this.currentView + 'View'],
                    hn = v + 'ViewHTML',
                    plb = this[this.currentView + 'Label'],
                    nlb = this[v + 'Label'];
                
                
                if (!this.supportedViews[v]) {
                    return;
                }
                
                if(!dr) {
                    dr = this.sDirMatrix[this.currentView][v];
                }
                
                div.className = cn;
                div.innerHTML = this[hn]();
                
                this.currentView = v;
                
                
                if(plb){
                    mstrmojo.css.removeClass(plb, ['highlight']);
                }
                if(nlb){
                    mstrmojo.css.addClass(nlb, ['highlight']);
                }
                
                this[v + 'View'] = div;
                
                this._slideIntoView(cv,div,dr);
            },  

            
            _slideIntoView: function(c, t, d){
                var p = this.bodyContainer,
                    v = (d === 'left' || d === 'right') ? c.offsetWidth : c.offsetHeight,
                    pn = (d === 'left' || d === 'right') ? 'left' : 'top',
                    pv = (d === 'left' || d === 'up') ? v : -v, 
                    e1 = new mstrmojo.fx.AnimateProp({
                        props: {},
                        duration:this.duration,
                        interval:this.duration/10,
                        target:c,
                        onEnd:function(){
                            p.removeChild(c);
                        }
                    }),      
                    e2 = new mstrmojo.fx.AnimateProp({
                        props: {},
                        duration:this.duration,
                        interval:this.duration/10,                        
                        target:t
                    }); 
                                    
                t.style[pn] = pv + 'px';
    
                p.appendChild(t);
    
                e1.props[pn] = {start:0,stop:-pv, suffix:'px'};
                e2.props[pn] = {start:pv, stop:0, suffix:'px'};
    
                e1.play();
                e2.play();

            },
            
            
            dayViewHTML: function(){
                var y = this.browseYear,
                    m = this.browseMonth,
                    dm = $P.getDaysOfMonth(y,m),
                    pm = $P.getPreMonth(y,m),
                    dpm = $P.getDaysOfMonth(pm.y, pm.m),
                    nm = $P.getNextMonth(y,m),
                    lb = _getLeadingBlanks(y,m,this.firstDayOfWeek),
                    html = [],
                    scStyle = selectedStyle(this),
                    c = 0,
                    sd = this.selectedDates,
                    min = this.min,
                    max = this.max,
                    date, status, i, j,
                    showCurStyle = this.showCurMonthDatesOnly?'style="visibility:hidden;"':'';
                
                
                updateTraversalIcons(this, {d: dpm, m: pm.m, y: pm.y}, {d: 1, m: nm.m, y: nm.y});
                
                html.push(_pre_table_with_style(this.cssTextDay));
                html.push(this._dayViewTHead());
                
                html.push('<tr>');
                for(i=0;i<lb;i++){
                    
                    date = dpm-lb+i+1;
                    
                    
                    status = this.isDateDisabled(date, pm.m, pm.y, min, max) ? 'disabled' : '';
                    
                    html.push('<td '+showCurStyle + '><div class="mstrmojo-Calendar-day-pre ' + status + '" m="-1">');
                    html.push(date);
                    html.push('</div></td>');
                    c++;
                }
                for(i=0;i<dm;i++){
                    
                    date = i+1;
                    
                    
                    status = this.isDateDisabled(date, m, y, min, max) ? ' disabled' : '';
                    var td = isToday(date,m,y),
                    	tdCssClass = td?' today':'',
                    	sel = isDateSelected(sd, date, m, y) !== -1;
                    tdCssClass = (this.hilightToday && td)? ' hilightToday':tdCssClass;
                    html.push('<td '+ (td?('class="'+tdCssClass+'" '):' ')+(sel?scStyle:'') + '><div class="mstrmojo-Calendar-day-cur' + (sel ? (' selected ') : '') + status + '" m="0"'+ (sel?scStyle:'') + '>');
                    html.push(i+1);
                    html.push('</div></td>');
                    if((++c)%7 === 0) {
                        html.push("</tr><tr>");
                    }
                }
                for(j=c;j<42;j++){
                    
                    date = c-dm-lb+1;
                    
                    
                    status = this.isDateDisabled(date, nm.m, nm.y, min, max) ? 'disabled' : '';
                    
                    html.push('<td '+showCurStyle+'><div class="mstrmojo-Calendar-day-next ' + status + '" m="1">');
                    html.push(date);
                    html.push('</div></td>');   
                    if((++c)%7 === 0 && c!==42) {
                        html.push("</tr><tr>");   
                    }
                }
                html.push('</tr>');
                html.push(_post_table);
                return html.join('');
            },
            
                        
            _dayViewTHead: function(){
                var html = [],
                    pre = '<thead><tr class="mstrmojo-Calendar-thead"'+' style="'+ this.cssTextWeekDay+';">',
                    post = '</tr></thead>',
                    fd = this.firstDayOfWeek - 1,
                    dayNames = this.dayNames,
                    i;
                
                html.push(pre);
                for(i = fd; i < fd + 7; i++){
                   html.push('<td>');
                   html.push(dayNames(i%7));
                   html.push('</td>');
                }
                html.push(post);
                return html.join('');
            },
            
                        
            monthViewHTML: function(){
                var html = [],
                    bm = this.browseMonth - 1,
                    by = this.browseYear,
                    i;
                updateTraversalIcons(this, {d: 31, m: 12, y: by - 1}, {d: 1, m: 1, y: by + 1});
                html.push(_pre_table_with_style(this.cssTextMonth));
                html.push('<tr>');
                for(i=0;i<12;i++){
                    html.push('<td '+ ((i === bm)?selectedStyle(this):'') + '><div class="mstrmojo-Calendar-month' + ((i === bm) ? ' selected' : '')+'" m="');
                    html.push(String(i));
                    html.push('">');                        
                    html.push(this.monthNames(i));
                    html.push('</div></td>');
                    if(i%3 === 2) {
                        html.push("</tr><tr>");
                    }
                }
                html.pop();
                html.push("</tr>");
                html.push(_post_table);
                return html.join('');
            },
            
                        
            yearViewHTML: function(){
                var start = this.yearRangStart,
                    html = [],
                    by = this.browseYear,
                    y, i,
                    ysz = this.yearViewSize;
                
                updateTraversalIcons(this, {d: 31, m: 12, y: start - 1}, {d: 1, m: 1, y: start + ysz*ysz});
                
                html.push(_pre_table_with_style(this.cssTextYear));
                html.push('<tr>');
                for(i=0;i<ysz*ysz;i++){
                    y = start + i;
                    html.push('<td '+ ((by===y)?selectedStyle(this):'') +'><div class="mstrmojo-Calendar-year' +  ((by===y) ? ' selected' : '') + '">');
                    html.push(y);
                    html.push('</div></td>');
                    if(i%ysz === (ysz-1)) {
                        html.push("</tr><tr>");     
                    }
                }
                html.pop();
                html.push("</tr>");
                html.push(_post_table);
                return html.join('');
            },
            
                        
            hourViewHTML: function(){
                var html = [],
                    hh = this.timeVal.hour,
                    i;
                html.push(_pre_table);
                html.push('<tr><td colspan="6"><div class="mstrmojo-Calendar-hourTitle">');
                html.push(_DT().AM_NAME);
                html.push('</div></td></tr>');
                for(i=0;i<12;i++){
                    html.push('<td><div class="mstrmojo-Calendar-hour' +  ((i === hh)? ' selected' : '') + '" h="0">');
                    html.push((i === 0) ? 12 : i);
                    html.push('</div></td>');
                    if(i === 5) {
                        html.push("</tr><tr>");
                    }
                }
                html.push('</tr><tr><td colspan="6"><div class="mstrmojo-Calendar-hourTitle">');
                html.push(_DT().PM_NAME);
                html.push('</div></td></tr>');                
                for(i=0;i<12;i++){
                    html.push('<td><div class="mstrmojo-Calendar-hour' + (((12 + i) === hh) ? ' selected' : '') + '" h="1">');
                    html.push((i === 0) ? 12 : i);
                    html.push('</div></td>');
                    if(i === 5) {
                        html.push("</tr><tr>");
                    }
                }
                html.push("</tr>");
                html.push(_post_table);
                return html.join('');
            },
            
                        
            minuteViewHTML: function(){
                return this._minuteSecondViewHTML(this.timeVal.min, "mstrmojo-Calendar-minute");
            },
            
                        
            secondViewHTML: function(){
                return this._minuteSecondViewHTML(this.timeVal.sec, "mstrmojo-Calendar-second");
            },
            
                        
            _minuteSecondViewHTML: function(s,c){
                var html = [],
                    i;
                
                html.push(_pre_table);
                html.push('<tr>');
                for(i=0;i<60;i++){
                    html.push('<td><div class="');
                    html.push(c);
                    html.push((i === s) ? ' selected">' : '">');
                    html.push(i);
                    html.push('</div></td>');
                    if(i%10 === 9) {
                        html.push("</tr><tr>");
                    }
                }
                html.pop();
                html.push("</tr>");
                html.push(_post_table);
                return html.join('');                
            },
            
            isDateDisabled: function(day, month, year){
                 var d = $P.formatDateInfo({day: day, month: month, year: year}, _DT().DATEOUTPUTFORMAT);
                 
                 
                 return !isDateInDateTimeRange(day, month, year, this.min, this.max);
            },
            unrender: function unrender(ignoreDom) {
                
                delete this.lastValue;
                this._super(ignoreDom);
            }
        }
    );
    
}());

(function () {
    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo.css",
                         "mstrmojo.dom",
                         "mstrmojo.num",
                         "mstrmojo._TouchGestures");

    var $D = mstrmojo.dom,
        $CSS = mstrmojo.css,
        $MIN = Math.min,
        $MAX = Math.max,
        $RND = Math.round,
        $NUM = mstrmojo.num,
        $CD = $NUM.countOfDecimals;

    

    
    function initCal() {
        var cs = document.defaultView.getComputedStyle,
            ns = [this.leftNode, this.rightNode],
            ps = [ 'border-left-width', 'padding-left', 'margin-left', 'border-right-width', 'padding-right', 'margin-right' ],
            ds = [0, 0],
            i,
            j;

        
        for (i = 0; i < ns.length; i++) {
            var styl = cs(ns[i]);
            for (j = 0; j < ps.length; j++) {
                ds[i] += parseInt(styl.getPropertyValue(ps[j]), 10) || 0;
            }
        }

        this._lnExt = ds[0];
        this._rnExt = ds[1];

        
        if (!this._thumbLen) {
            this._thumbLen = parseInt(this.thumbNode.offsetWidth, 10);
        }

        
        
        this._length = this.domNode.clientWidth;
        this._effLen = $RND(this._length - this._thumbLen);
        this._unitLen = this._effLen / (this.max - this.min);
        
    }

    
    function position(v) {
        
        var min = this.min,
            unitLength = this._unitLen,
            thumbLength = this._thumbLen / 2,
            lLen = $RND((v - min) * unitLength);

        
        this.leftNode.style.width = (lLen + thumbLength - this._lnExt) + 'px';

        
        this.rightNode.style.width = (this._effLen - lLen + thumbLength - this._rnExt) + 'px';

        
        
        
        $D.translate(this.thumbNode, $MAX($MIN(lLen, (this.max - min) * unitLength), 0), 0);
    }

    
    function calValueWDelta(v, delta) {
        var interval = this.interval;
        return $MIN($MAX(this.min, parseFloat(v, 10) + $RND(delta / this._unitLen / interval) * interval), this.max).toFixed(this._intervalDecimals); 
    }

    
    function calValueWX(x) {
        return calValueWDelta.call(this, this.min, x - $D.position(this.domNode, true).x - this._thumbLen / 2);
    }

    function getTouchRedirectFn(methodName) {
        return function (touch) {
            return this['touchSelect' + methodName](touch);
        };
    }
    
    mstrmojo.ui.MobileSlider = mstrmojo.declare(
        mstrmojo.Widget,

        [ mstrmojo._TouchGestures ],

        
        {
            markupString: '<div class="mstrmojo-MobileSlider" style="visibility:hidden;">' +
                              '<div class="v"></div>' +        
                              '<div class="bk"></div>' +        
                              '<div class="th"><div></div></div>' +        
                              '<div class="min">{@minText}' + '</div>' +     
                              '<div class="max">{@maxText}</div>' + 
                          '</div>',

            markupSlots: {
                leftNode: function () { return this.domNode.childNodes[0]; },
                rightNode: function () { return this.domNode.childNodes[1]; },
                thumbNode: function () { return this.domNode.childNodes[2]; },
                minNode: function () { return this.domNode.childNodes[3]; },
                maxNode: function () { return this.domNode.childNodes[4]; }
            },

            markupMethods: {
                onvalueChange: function () {
                    if (this.hasRendered) {
                        
                        position.apply(this, [this.value]);
                    }

                    if (this.slidingValue !== this.value) {
                        this.set('slidingValue', this.value);
                    }
                },
                onslidingValueChange: function () {
                    if (this.hasRendered) {
                        position.apply(this, [this.slidingValue]);
                    }
                }

            },
            
            value: 0,

            
            slidingValue: 0,

            
            max: 10,

            
            min: 0,

            
            interval: 1,

            
            _intervalDecimals: 0,

            
            init: function init(props) {
                this._super(props);
                this._intervalDecimals = $CD(this.interval, '.'); 
            },

            onintervalChange: function onintervalChange(n, v) {
                this._intervalDecimals = $CD(v, '.'); 
            },

            preBuildRendering: function preBuildRendering() {
                
                this.minText = $NUM.toLocaleString(this.min);
                this.maxText = $NUM.toLocaleString(this.max);

                this._super();
            },

            
            postBuildRendering: function postBuildRendering() {
                this._super();

                
                initCal.call(this);

                
                position.call(this, this.value);

                
                this.domNode.style.visibility = 'visible';
            },

            resize: function resize() {
                
                initCal.call(this);

                
                position.call(this, this.value);
            },
            

            
            touchBegin: function touchBegin(touch) {
                touch.stop();
            },

            
            touchSelectBegin: function touchSelectBegin(touch) {
                
                var target = touch.target;
                if (!target || target !== this.thumbNode) {
                    
                    return this.bubbleTouchEvent(touch);
                }

                
                $CSS.addClass(this.domNode, 'active');

                
                this.slidingValue = this.value;
            },

            
            touchSelectMove: function touchSelectMove(touch) {
                this.set('slidingValue', calValueWDelta.apply(this, [ this.value, touch.delta.x || 0 ]));
            },

            
            touchSelectEnd: function touchSelectEnd(touch) {
                
                $CSS.removeClass(this.domNode, 'active');

                this.set('slidingValue', calValueWDelta.apply(this, [this.value, touch.delta.x || 0 ]));
                this.set('value', this.slidingValue);
            },

            touchSwipeBegin: getTouchRedirectFn('Begin'),

            touchSwipeMove: getTouchRedirectFn('Move'),

            touchSwipeEnd: getTouchRedirectFn('End'),

            
            
            onclick: function onclick(evt, hWin) {
                this.touchTap({
                    clientX: $D.getMousePosition(evt.e, hWin).x
                });
            },

            
            
            touchTap: function touchTap(touch) {
                this.set('value', calValueWX.call(this, touch.clientX));
            }
        }
    );
}());
(function() {
	mstrmojo.requiresCls("mstrmojo.array",
						 "mstrmojo.BarcodeReader",
						 "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton");
	
	var $ARR = mstrmojo.array;
	
	mstrmojo.android.inputControls.BarcodeDIC = mstrmojo.declare(
			
		mstrmojo.Widget,
		
		[mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton],
		
		{
			scriptClass: 'mstrmojo.android.inputControls.BarcodeDIC',
			
			markupString: '<div></div>',
			
			
            showInPopup: function(){
            	var me = this;
            	var callback = {
	                success: function (val) {
	                	if (val !== '') {
	                		
	                		
	                		if (!!me.dic.em) {
	                			me.value = me.dic.vls[parseInt(val, 10)].v;
	                		} else {
	                			me.value = val;
	                		}
	                		
		                	me.applyChanges();
	                	}
	                },
	                
	                failure: function (val) {}
	            };
            	
            	
            	var params = {'barcodeDIC': true};
            	
            	if (!!me.dic.em) {
            		var vls = [];
            		$ARR.forEach(me.dic.vls, function(o, i){
            			
            			vls[i] = o.m || o.v;
            		});
            		
            		params.vls = vls;
            	}
            	
            	mstrmojo.BarcodeReader.readBarcodes(params, callback, this.popupTitle);
            }
		}
	)
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.array",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    

    var $C = mstrmojo.css,
        $EF = mstrmojo.emptyFn,
        $D = mstrmojo.dom,
        $HANDLE_WIDTH = 32,
        $CSS = mstrmojo.css,

        types = { 
            SINGLE: 1,
            INCLUDE: 2,
            EXCLUDE: 3
        },

        f = { 
            CONTINUOUS_STEPS: -1,
            UNSET: -4641
        },

        tmp = {}, 

        
        getSliderWidth = function (t) {
            if (!tmp[t.id + "cw"]) {

                var width = parseInt($C.getComputedStyle(t.sliderContainer).width, 10);
                if (isNaN(width)) {

                    width = parseInt($C.getComputedStyle(t.domNode.parentNode).width, 10);
                }

                tmp[t.id + "cw"] = width;
            }
            return tmp[t.id + "cw"];
        },

        
        getSingleStep = function (t, left, handle) {
            var range = t.type !== types.SINGLE,
                handleWidth = $HANDLE_WIDTH,
                l = !!left ? (left - (handleWidth / 2)) :  parseInt(handle.style.left, 10),
                st = t.steps,
                contWidth = getSliderWidth(t) - handleWidth,
                gap = Math.round(contWidth / (st - (!range ? 1 : 0))), 
                maxStep = range ? t.rightStep : st - 1;

            return Math.min(maxStep, Math.round(l / gap));
        },

        
        getRightStep = function (t) {
            var rcStyle = t.rangeContainer.style,
                width = parseInt(rcStyle.width, 10) - $HANDLE_WIDTH,
                left = parseInt(rcStyle.left, 10),
                st = t.steps, 
                contWidth = getSliderWidth(t) - $HANDLE_WIDTH,
                gap = Math.round(contWidth / st);

            return Math.max(0,
                            Math.min(Math.round((left + width) / gap),
                                     st));
        },

        
        getLeftForSingle = function (t, step) {
            var st = t.steps,
                w = getSliderWidth(t),
                hs = $HANDLE_WIDTH;
            return Math.min(w - hs, Math.max(0, ((w / (st - 1) * step) - hs / 2))) + "px";
        },

        
        getLeftForRange = function (t, leftStep) {

            var st = t.steps,
                w = getSliderWidth(t) - $HANDLE_WIDTH;

            return ((w / st) * leftStep) + "px";
        },

        
        getWidthForRange = function (t, leftStep, rightStep) {
            var st = t.steps, 
                w = getSliderWidth(t) - $HANDLE_WIDTH,
                ch = rightStep - leftStep;

            return ((ch * w) / st) + $HANDLE_WIDTH + "px";
        },

        
        positionSingleStep = function (t, step) {
            var singleHandle = t.singleHandle;
            if (singleHandle) {
                singleHandle.style.left = getLeftForSingle(t, step);
            }
        },

        
        positionRangeStep = function (t, leftStep, rightStep) {
            var ic = t.rangeContainer,
                sty,
                handleWidth = (t.rangeLHandle.clientWidth || $HANDLE_WIDTH) + 5;

            if (ic) {
                var ircStyle = t.innerRangeContainer.style;

                sty = ic.style;
                sty.left = getLeftForRange(t, leftStep);
                sty.width = getWidthForRange(t, leftStep, rightStep);

                
                ircStyle.left = parseInt(sty.left, 10) + handleWidth + 'px';
                ircStyle.width = Math.max(parseInt(sty.width, 10) - (2 * handleWidth), 0) + 'px';
            }
        },

        
        snapHandle = function (t, l, handle) {
            var range = t.type !== types.SINGLE,
                step = getSingleStep(t, l, handle), 
                stepName = range ? "leftStep" : "singleStep",
                func;

            if (step !== t[stepName]) {
                t.set(stepName, step);
                this.step = step;
            } else {
                func = range ? positionRangeStep : positionSingleStep;
                func(t, step, t.rightStep);
            }
        },

        
        snapRangeHandles = function (t, left, handle) {
            var rangeContainer = t.rangeContainer,
                step,
                leftStep = t.leftStep,
                grabDrag = (handle === rangeContainer || handle === t.innerRangeContainer);

            if (handle === t.rangeRHandle || grabDrag) {
                step = getRightStep(t);
                leftStep += grabDrag ? step - t.rightStep : 0; 

                positionRangeStep(t, leftStep, step);
                if (t.rightStep !== step) {
                    t.set("rightStep", step);
                    if (grabDrag) {
                        t.set("leftStep", leftStep);
                    }
                }
            } else if (handle === t.rangeLHandle) {
                snapHandle(t, left, rangeContainer);
            }
        },

        
        snapHandles = function (t, target) {
            switch (t.type) {
            case types.SINGLE:
                snapHandle(t, null, t.singleHandle);
                break;
            case types.EXCLUDE:
            case types.INCLUDE:
                snapRangeHandles(t, null, target);
                break;
            }
        },


        
        jumpRangeHandle = function (t, tapPosition) {
            var rangeContainer = t.rangeContainer,
                rcStyle = rangeContainer.style,
                width = parseInt(rcStyle.width, 10),
                left = parseInt(rcStyle.left, 10),
                leftStep = t.leftStep,
                rightStep = t.rightStep,
                nuRs = rightStep,
                nuLs = leftStep;

            if (tapPosition > 0 && tapPosition < left && leftStep > 0) {
                nuRs--;
                nuLs--;
            } else if (tapPosition > (left + width) && tapPosition < getSliderWidth(t)) {
                nuRs++;
                nuLs++;
            }
            positionRangeStep(t, nuLs, nuRs);
            t.set("leftStep", nuLs);
            t.set("rightStep", nuRs);
        },


        
        moveHandle = function (slider, node, handle, position, deltaX) {

            
            var width = handle.style.width;

            
            if (width === '') {
                
                width = $C.getComputedStyle(handle).width;
            }

            
            position = Math.min(Math.max(0, position + (deltaX || 0)), getSliderWidth(slider) - parseInt(width, 10));

            
            node.style.left = position + 'px';

            return position;
        },

        
        moveRangeLHandle = function (t, originalPosition, originalWidth, deltaX) {
            var rangeContainer = t.rangeContainer,
                rangeLHandle = t.rangeLHandle,
                contWidth = getSliderWidth(t) - $HANDLE_WIDTH,
                gap = Math.round(contWidth / t.steps), 
                newWidth = originalWidth - deltaX,
                handlePos;

            if (newWidth >= (gap + $HANDLE_WIDTH)) {
                handlePos = moveHandle(t, rangeContainer, rangeLHandle, originalPosition, deltaX);

                if ((originalPosition + deltaX) > 0) {
                    rangeContainer.style.width = newWidth + "px";
                }
                return handlePos;
            }
        },


        moveRangeRHandle = function (t, originalPosition, originalWidth, deltaX) {
            var rangeContainer = t.rangeContainer,
                max = getSliderWidth(t) - parseInt(rangeContainer.style.left, 10),
                newWidth = originalWidth + deltaX,
                contWidth = getSliderWidth(t) - $HANDLE_WIDTH,
                gap = Math.round(contWidth / t.steps), 
                handlePos;

            if (newWidth >= (gap + $HANDLE_WIDTH)) {
                handlePos = Math.min(max, newWidth);
                rangeContainer.style.width = handlePos + "px";

                return handlePos;
            }
        },

        
        prepareSummary = function (t) {
            var singleStep, leftStep, rightStep, summary;
            switch (t.type) {
            case types.SINGLE:
                singleStep = parseInt(this.step, 10) === f.UNSET ?  getSingleStep(t, null, t.singleHandle) : this.step;
                summary = t.buildSummary(singleStep);
                this.step = f.UNSET;
                break;
            case types.EXCLUDE:
            case types.INCLUDE:
                leftStep = getSingleStep(t, null, t.rangeContainer);
                rightStep = getRightStep(t);
                summary = t.buildSummary(null, leftStep, rightStep);
                break;
            }

            return summary;
        };

    
    mstrmojo.android.selectors.MobileSliderSelector = mstrmojo.declare(

        mstrmojo.Widget,

        [ mstrmojo._TouchGestures, mstrmojo._ListSelections ],

        
        {

            

            width: 0, 

            type : f.UNSET, 

            value : f.UNSET, 

            steps : f.UNSET, 

            include : f.UNSET,

            

            

            initState : $EF, 

            buildSummary : $EF, 

            updateMinMaxLabels : $EF, 

            flushSelections : $EF, 

            

            step: f.UNSET,  

            singleStep : f.UNSET, 

            leftStep : f.UNSET, 

            rightStep : f.UNSET, 

            cssDisplay: 'block',

            scriptClass: "mstrmojo.android.selectors.MobileSliderSelector",

            useRichTooltip: true,

            markupString : '<div class="mstrmojo-sliderSel" id="{@id}">' +
                                '<div></div>' + 
                                '<div class="mstrmojo-sliderSelSummary">&nbsp;</div>' + 
                                '<div class="mstrmojo-sliderSelScrollerContainer">' + 
                                    '<div class="mstrmojo-sliderSelScrollerHandle" style="display:none;">' + 
                                        '<div class="mstrmojo-sliderSelScrollerHandle1 leftHandle"><div></div></div>' + 
                                        '<div class="mstrmojo-sliderSelScrollerHandle1 rightHandle"><div></div></div>' + 
                                    '</div>' +
                                   '<div class="mstrmojo-sliderSelScrollerHandle2" style="display:none;"><div></div></div>' + 
                                   '<div class="mstrmojo-sliderSelScrollerHandleArea" style="display:none;position:absolute"></div>' +
                               '</div>' +
                               '<div class="mstrmojo-sliderSelLabels">' + 
                                   '<label class="mstrmojo-sliderSelLL">&nbsp;</label>' +
                                   '<label class="mstrmojo-sliderSelLR">&nbsp;</label>' +
                               '</div>' +
                           '</div>',

            markupSlots : {
                editor: function () { return this.domNode.childNodes[0]; },
                summary: function () { return this.domNode.childNodes[1]; },
                sliderContainer: function () { return this.domNode.childNodes[2]; },
                innerRangeContainer: function() {return this.domNode.childNodes[2].childNodes[2];},
                rangeContainer: function () { return this.domNode.childNodes[2].childNodes[0]; },
                rangeLHandle: function () { return this.domNode.childNodes[2].childNodes[0].childNodes[0]; },
                rangeRHandle: function () { return this.domNode.childNodes[2].childNodes[0].childNodes[1]; },
                singleHandle: function () { return this.domNode.childNodes[2].childNodes[1]; },
                minLabel: function () { return this.domNode.childNodes[3].childNodes[0]; },
                maxLabel: function () { return this.domNode.childNodes[3].childNodes[1]; }
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? this.cssDisplay : 'none'; },
                
                ontypeChange: function () {
                    var s,
                        i = "none",
                        scClassName = "mstrmojo-sliderSelScrollerContainer",
                        handleClassName = "Handle1";

                    switch (this.type) {
                    case types.SINGLE:
                        s = 'block';
                        break;
                    case types.EXCLUDE:
                        scClassName = "mstrmojo-sliderSelScrollerContainerExcl";
                        handleClassName = "Handle2";
                        i = 'block';
                        break;
                    case types.INCLUDE:
                        i = 'block';
                        break;
                    }

                    this.rangeContainer.style.display = i;
                    this.innerRangeContainer.style.display = i;
                    this.sliderContainer.className = scClassName;
                    this.rangeLHandle.className = "mstrmojo-sliderSelScrollerHandleX leftHandle".replace("HandleX", handleClassName);
                    this.rangeRHandle.className = "mstrmojo-sliderSelScrollerHandleX rightHandle".replace("HandleX", handleClassName);

                    this.singleHandle.style.display = s;
                },
                onconstantsChange: function () {
                    this.updateMinMaxLabels();
                },
                onvalueChange: function () {
                    prepareSummary(this);
                }
            },

            postBuildRendering: function postBuildRendering() {
                var rtn = this._super();
                this.initState();

                var d = this.tooltipNode || this.domNode;

                $D.detachEvent(d, 'mouseover', this._ontooltipover);
                $D.detachEvent(d, 'mouseout', this._ontooltipout);

                return rtn;
            },

            onsingleStepChange : function () {
                positionSingleStep(this, this.singleStep);
            },

            onleftStepChange : function () {
                positionRangeStep(this, this.leftStep, this.rightStep);
            },

            onrightStepChange : function () {
                positionRangeStep(this, this.leftStep, this.rightStep);
            },

            
            touchSwipeBegin: function (touch) {
                var target = touch.target;
                if (!target) {
                    return false;
                }

                this.touchTap(touch);

                
                var glowTargets = this._glowing = [];

                
                $CSS.addClass(target, 'glow');
                glowTargets.push(target);

                
                this._sliderTarget = target;

                var singleHandle = this.singleHandle,
                    rangeContainer = this.rangeContainer,
                    left,
                    style;

                switch (target) {
                case singleHandle:
                    left = singleHandle.style.left;
                    
                    tmp.shl = parseInt(!!left ? left : 0, 10);
                    break;

                case rangeContainer:
                case this.innerRangeContainer:
                case this.rangeLHandle:
                case this.rangeRHandle:
                    style = rangeContainer.style;
                    left = style.left;
                    
                    tmp.icl = parseInt(!!left ? left : 0, 10);
                    
                    tmp.icw = parseInt(style.width, 10);
                    break;
                case this.sliderContainer:
                    
                    $CSS.addClass(singleHandle, 'glow');
                    glowTargets.push(singleHandle);
                    break;

                default:
                    this.bubbleTouchEvent(touch);
                }

                this._initTooltip();

                if (this.type === types.SINGLE) {
                    this.touchSelectMove(touch, true);
                }
            },

            
            touchSwipeMove: function (touch, ignoreNodeWidth) {
                var target = touch.target;
                if (!target) {
                    return false;
                }

                
                target = this._sliderTarget;

                var singleHandle = this.singleHandle,
                    rangeContainer = this.rangeContainer,
                    rangeLHandle = this.rangeLHandle,
                    rangeRHandle = this.rangeRHandle,
                    deltaX = touch.delta.x,
                    leftPos;


                switch (target) {
                case singleHandle:
                    leftPos = moveHandle(this, singleHandle, singleHandle, tmp.shl, deltaX);
                    break;
                case rangeRHandle:
                    leftPos = moveRangeRHandle(this, tmp.icl, tmp.icw, deltaX);
                    break;
                case rangeLHandle:
                    leftPos = moveRangeLHandle(this, tmp.icl, tmp.icw, deltaX);
                    break;
                case rangeContainer:
                case this.innerRangeContainer:
                    if (this.type === types.INCLUDE) {
                        leftPos = moveHandle(this, rangeContainer, rangeContainer, tmp.icl, deltaX);
                    }
                    break;
                case this.sliderContainer:
                    leftPos = moveHandle(this, singleHandle, singleHandle, touch.clientX - $D.position(this.sliderContainer, true).x);
                    break;
                }

                this._updateTooltip(touch.evt, target, leftPos, ignoreNodeWidth);
            },

            
            touchSwipeEnd: function (touch) {

                var target = (touch.target === this.sliderContainer) ? this.singleHandle : this._sliderTarget,
                    l = this.leftStep,
                    r = this.rightStep,
                    s = this.singleStep;

                
                mstrmojo.array.forEach(this._glowing, function (glowTarget) {
                    
                    $CSS.removeClass(glowTarget, 'glow');
                });

                
                
                snapHandles(this, target);

                if (l !== this.leftStep || r !== this.rightStep || s !== this.singleStep) {
                    this.flushSelections();
                }

                this.hideTooltip(touch.evt, this);
            },

            
            touchTap: function (touch) {
                var target = touch.target;
                if (!target) {
                    return false;
                }

                var sliderContainer = this.sliderContainer,
                    clientX = touch.clientX,
                    containerTapped = (sliderContainer === target),
                    tapPosition = clientX - $D.position(sliderContainer, true).x,
                    l = this.leftStep,
                    r = this.rightStep,
                    s = this.singleStep;

                switch (this.type) {
                case types.SINGLE:
                    if (containerTapped) {
                        snapHandle(this, tapPosition, this.singleHandle);
                    }
                    break;
                case types.INCLUDE:
                    if (containerTapped) {
                        jumpRangeHandle(this, tapPosition);
                    }
                    break;
                    
                }

                if (l !== this.leftStep || r !== this.rightStep || s !== this.singleStep) {
                    prepareSummary(this);
                    this.flushSelections();
                }
            },

            touchSelectBegin: function (touch) {
                this.touchSwipeBegin(touch);
            },
            touchSelectMove: function (touch) {
                this.touchSwipeMove(touch, true);
            },
            touchSelectEnd: function (touch) {
                this.touchSwipeEnd(touch);
            },

            touchEnd: function touchEnd(touch) {
                this.hideTooltip(touch.evt, this);
            },

            _initTooltip: function _initTooltip() {

                this.set('richTooltip', {refNode : this.domNode,
                                         posType: mstrmojo.tooltip.POS_BOTTOMCENTER,
                                         contentNodeCssClass: 'mstrmojo-sliderTip'});
            },

            _updateTooltip: function _updateTooltip(event, target, leftPos, ignoreNodeWidth) {

                this.showTooltip(event, this);
                var containerNode = $D.position(this.sliderContainer, false),
                    dposDomNode = $D.position(this.domNode, false),
                    boxContainer = mstrmojo.boxmodel.offset(this.sliderContainer),
                    breachedTopBoundary = (containerNode.y < 90),
                    ttN = this.richTooltip,
                    content = prepareSummary(this),
                    nodeWidth;

                if (ignoreNodeWidth) {

                    nodeWidth = ($HANDLE_WIDTH / 2);
                } else {

                    nodeWidth = target.style.width;

                    if (nodeWidth === "") {
                        nodeWidth = $C.getComputedStyle(target).width;
                    }
                    nodeWidth = parseInt(nodeWidth, 10) / 2;
                }

                ttN.content = '<div class="mstrmojo-sliderTip-top">' + content + '</div>' +
                              '<div class="mstrmojo-sliderTip-bottom' + (breachedTopBoundary ? ' down' : '') + '">' + '</div>';

                ttN.top = dposDomNode.y - boxContainer.top - 20 + (breachedTopBoundary ? 100 : 0);
                ttN.left = leftPos + nodeWidth + (dposDomNode.x - boxContainer.left);

                this.richTooltip = null;
                this.set('richTooltip', ttN);
            },

            onselectionChange: function onselChg() {
                
                if (this.onchange) {
                    this.onchange();
                }

                if (this.makeSelection) {
            		this.makeSelection({
            			selItem: this.type === types.SINGLE ? this.singleHandle : this.rangeContainer
            		});
            	}
            },

            
            slideHosted: function (single, left, right) {
                if (single !== null && single !== undefined) {
                    this.set("singleStep", single);
                }
                if (left !== null && left !== undefined) {
                    this.set("leftStep", left);
                }
                if (right !== null && right !== undefined) {
                    this.set("rightStep", right);
                }
                this.flushSelections();
                prepareSummary(this);
            }

        }
    );

    var $MSL = mstrmojo.android.selectors.MobileSliderSelector;

    $MSL.TYPES = types;
    $MSL.FLAGS = f;

}());
(function(){

    var AUTO_TR = '<tr>';
    var TBL_MKP_START = ['<table cellspacing="0" cellpadding="0" style="table-layout:', null,
                                                   ';width:', null,
                                                   ';mstr-tablestyle-slot" ', null,
                                                   '>', null,
                                                   '<tbody>'];
    var NBSP = "&nbsp;";
    var STITCH_TOP_CSS = "fsbp_1 ";
    var STITCH_MIDDLE_CSS = "fsbp_2 ";
    var STITCH_BOTTOM_CSS = "fsbp_3 ";
    var STACK_TOP = 1,
        STACK_MIDDLE = 2,
        STACK_BOTTOM = 3,
        NO_STACK = 4,
        FULL_STACK = 5,
        STACK_CSS = {
        1: ' stack-top',
        2: ' stack-middle',
        3: ' stack-bottom',
        4: ' no-stack',
        5: ' stack-full'
    };

    var $CSS = mstrmojo.css;

    var BASEFORM_PICTURE = 4;

    
    function stitchBottomCells(cells, tbody) {
        for(var i=0, iLen = cells.length; i < iLen; i++) {
            var c = cells[i];
            var d = tbody.rows[c.rows].cells[c.cells];
            if(d) {
                mstrmojo.css.addClass(d, STITCH_TOP_CSS);
            }
        }

    }

    mstrmojo.requiresCls(
            "mstrmojo.Widget");

    mstrmojo.GridBase = mstrmojo.declare(
        
        mstrmojo.Widget,

        
        null,

        
        {
            scriptClass: "mstrmojo.GridBase",

            
            markupString: '<span id="{@id}" class="mstrmojo-Grid {@cssClass}" style="{@cssText}"></span>',

            markupSlots: {
                gridContainerNode: function(){ return this.domNode; }
            },

            
            autoFitWindow:false,

            
            tableLayout:null,

            
            numAutoHeightRows:0,

            
            cp:null,

            
            rc:0,

            
            cc:0,

            
            cws:null,

            
            rh:null,

            
            totalColWidth: 0,

            
            start:0,

            
            end:0,

            forceFixedSizes:true,

            
            hiliteCellsMap: null,

            
            eiMap: null,

            
            init: function init_Grid( props) {
                
                this._super(props);
            },

            
            numColumnCanMerge: 0,

            
            preBuildRendering: function preBuildRendering(res) {
                var cp = this.cp;
                if(!cp) {
                    return;
                }
                cp.initContent();
                this.rc = cp.rc || 0;           
                this.cws = cp.colWidths || [];  
                this.cc = this.cws.length;              

                this.tdWidths = cp.tdWidths || [];	
                this.tdCnt = this.tdWidths ? this.tdWidths.length : 0;	

                this.start = 0;
                this.end = this.rc - 1;

                
                this.numAutoHeightRows = cp.getNumAutoHeightRows && cp.getNumAutoHeightRows() || 0;

                this.hiliteCellsMap= {};
                this.eiMap= {};
                this.posMap = [];
                this.thPosMap = [];

                
                this.totalColWidth = 0;

                
                
            },

            
            buildRendering: function buildRendering(res) {
                
                var ret = this._super(res);

                this.renderGrid();

                return ret;
            },

            
            renderGrid: function renderGrid(append) {
                
                var containerNode = this.getGridContainer();

                
                this.preBuildGridTable();

                
                this.buildGridTable(containerNode, append);

             
                this.postBuildGridTable();
            },

            
            getGridContainer: function getGridContainer() {
                return this.gridContainerNode;
            },


            
            buildGridTable: function buildGridTable( gridContainer, append) {
                
                var tms = this.getTableStartMarkup();

                
                var tme = this.getTableEndMarkup();

                
                if(append) {
                    this.mergeHdrsAcrossBlks = true;
                }

                
                var tInnerHTML = this.buildTableRowsMarkup(this.start, this.end, tms, tme).join('');

                if(append) {
                    
                    var creationContainer = document.createElement('div');
                    creationContainer.innerHTML = tInnerHTML;

                    var cn = gridContainer.firstChild,
                        tBodies = cn && cn.tBodies,
                        ntBody = creationContainer.firstChild.tBodies[0],
                        mh = this.matchedHdrsAcrossBlks;

                    cn.appendChild(ntBody);

                    if(mh && mh.length > 0) {
                        stitchBottomCells(mh, tBodies[tBodies.length - 2]);
                    }
                } else {
                    
                gridContainer.innerHTML = tInnerHTML;
                }
            },

            getTableStartMarkup : function _bldTableSMkp() {
                
                var gw = this._getGridWidths(),
                       mkp = TBL_MKP_START;

                mkp[1] = gw.tableLayout;

                mkp[3] = gw.totalColWidths;

                
                
                mkp[5] = this.tableCssClass ? "class=" + this.tableCssClass : '';

                mkp[7] = '<colgroup>' + gw.colgroup + '</colgroup>';

                if(this.tbodyStyle) {
                    mkp[8] = '<tbody style="' + this.tbodyStyle + '">';
                }
                return mkp.join('');
            },

            getTableEndMarkup : function _bldTableEMkp() {
                return '</tbody></table>';
            },

            
            _getGridWidths : function _initGridWidths() {
                var gw = {};

                
                var totalColWidths = '',
                    colgroup = [],
                    tl='fixed',
                    cws = this.cws,
                    cols = cws.length;

                if (cols) {
                    totalColWidths = 0;
                    colgroup = [];
                    
                    
                    for (var i=0; i<cols; i++) {
                        if(cws[i].w !== "") {
                            totalColWidths += parseInt(cws[i].w, 10);
                        }
                    }

                    for (i=0; i<cols; i++) {
                        var width = cws[i];
                        if(width.w !== "") {
                            
                            var w = parseInt(width.w, 10);

                            
                            if (mstrmojo.dom.isIE7) {
                                if(w === 0) {
                                    colgroup.push('<col style="width:0%;display:none"></col>');
                                } else {
                                    colgroup.push('<col style="width:' + (w / totalColWidths * 100) + '%"></col>');
                                }
                            } else if (mstrmojo.dom.isWK && w === 0) {
                                
                                
                                colgroup.push('<col style="width:-1px"></col>');
                            } else {
                                colgroup.push('<col style="width:' + width.w +'"></col>');
                            }
                        } else {
                            colgroup.push('<col />');
                            
                            tl = 'auto';
                        }
                    }

                    
                    this.totalColWidth = totalColWidths;
                }

                
                
                gw.colgroup = colgroup.join('');

                
                tl = this.tableLayout || tl;

                if(this.autoFitWindow) {
                    
                    tl = this.tableLayout || tl || 'fixed';
                    totalColWidths = '100%';
                } else if(tl == 'fixed') {
                    totalColWidths += 'px';
                } else {
                    totalColWidths = 'auto';
                }

                
                gw.totalColWidths = totalColWidths;
                gw.tableLayout = tl;

                return gw;
            },


            
            
            _CELL_MARKUP: ['<td rowSpan="', null, '" colSpan="', null, '" class="', null, '" ei="',null, '" style="', null, '" r="', null, '">', null, '</td>'],

            
            buildTableRowsMarkup: function _buildRowsMarkup( start,  end,  markupPrefix,  markupSuffix) {
                
                
                
                
                
                var markup = [],
                    i = 0;
                markup[i++] = markupPrefix || '<table><tbody>';

                
                var cp = this.cp,
                    
                    rh = cp.getRowHeight(),
                    
                    TD = this._CELL_MARKUP,
                    
                    TR = rh ? '<tr style="height:' + (rh ? rh + 'px' : '') + '">' : AUTO_TR;

                
                var firstRow = true,
                    lastMatched = true,
                    nlr = [], rhi; 

                this.matchedHdrsAcrossBlks = [];

                for (var r = start; r<=end; r++) {
                    
                    rhi = i++;
                    
                    markup[rhi] = r < this.numAutoHeightRows ? AUTO_TR : TR;
                    var cells = cp.getRowCells(r);

                    
                    var maxRowspan = end + 1 - r;

                    var umCellsLen = 0;
                    
                    if(!this.mergeHdrsAcrossBlks) {
                    
                    if(firstRow && start > 0 && cells.length < cp.colWidths.length) {
                        
                        var umCells = cp.getUnmergedCells(start);
                        if (umCells) {
                            umCellsLen = umCells.length;
                        }
                        for(var j in umCells) {
                            var p = umCells[j];
                            
                            if(p.rs > maxRowspan) { 
                                TD[1] = maxRowspan;
                                
                                TD[5] = STITCH_MIDDLE_CSS + p.css;
                            } else { 
                                TD[1] = p.rs || 1; 
                                
                                TD[5] = STITCH_BOTTOM_CSS + p.css;
                            }
                            if(p.cet) {
                                TD[5] += " mstrmojo-selected-cell";
                                this.addHilitePosition(p.cet, r, j);
                            }
                            if(p._ei) {
                                this.addExtraInfoMap(p._ei, r, j);
                                TD[5] += " pt";
                            }
                                TD[9] = "";
                                TD[13] = NBSP;
                            TD[3] = p.cs;
                            TD[7] = p._ei !== undefined ? p._ei : "";;

                            markup[i++] = TD.join('') ;
                        }
                        firstRow = false;
                    }
                    }

                    for (var c=0, len=cells.length; c<len; c++) {
                        var cell = cells[c], rt;
                        if(cell.rs && cell.rs > maxRowspan) {
                            TD[1] = maxRowspan;
                            TD[5] = STITCH_TOP_CSS + cell.css;
                            if(cell._ei) {
                                this.addExtraInfoMap(cell._ei, r, c);
                            }

                        } else {
                            TD[1] = cell.rs || 1;
                            TD[5] = cell.css;
                        }

                        if (cell.rowType !== STACK_TOP){
                            TD[5] += " xtab-td ";
                        }

                        if(cell.cet) {
                            TD[5] += "sc_" + this.parent.k;
                            this.addHilitePosition(cell.cet, r, c);
                        }

                        rt = cell.rowType;
                        if(rt) {
                            
                            TD[5] += STACK_CSS[rt] || '';
                            
                            var srh = cp.getRowHeight(rt);
                            if(srh) {
                                markup[rhi] = '<tr style="height:' + (srh ? srh + 'px' : '') + '">';
                            }
                        }

                        TD[3] = cell.cs || 1;
                        
                        TD[7] = cell._ei !== undefined ? cell._ei : "";

                        if (cell.fs || cell._e){
                            this.addTitleHeaderPositionMap(r, c + umCellsLen, cell);
                        }

                        if (cell._ei != null){
                            this.addPositionMap(cell._ei, r, c + umCellsLen);
                        }

                        TD[11] = r;
                        if(cell.ts === BASEFORM_PICTURE) {

                            
                            
                            
                            
                            

                            

                            var imgUrl = cell.v;
                            
                            if(this.imgCacheMap) {
                                var m = this.imgCacheMap,
                                    v = imgUrl && imgUrl.replace(/\\/g, '/');

                                if(m.cachedImg[v]) {
                                    cell.v = imgUrl = m.baseURL + m.cachedImg[v];
                                } else {
                                    if(v && !m.unCachedImg[v]) {
                                        
                                        m.unCachedImg[v] = v;
                                    }
                                }
                            } else {
                                var ds = this.parent && this.parent.controller && this.parent.controller.model && this.parent.controller.model.dataService;
                                if ( ds && ds.getImage ) {
                                    imgUrl = ds.getImage(imgUrl);
                                }
                            }

                            
                            if(cell.rowType) {
                            	
                            	
                            	
                            	
                            	
                                var height = (cp.getRowHeight(cell.rowType) || cp.rh || rh),
                                	fsHeight = height,
                                	cws = this.tdWidths,
                                	colIdx = cell.colIdx,
                                	colWidth = 0;
                                if (colIdx!=='undefined' && colIdx>-1 && cws && cws.length>colIdx) {
                                	var cw = cws[colIdx] && cws[colIdx].w;
                                	if (cw !== 'undefined') {
                                		colWidth = parseInt(cw, 10);
                                	}
                                }
                                var maxWidth = colWidth>30 ? (colWidth-30) : 0;
                                    
                                
                                
                                
                                TD[13] = '<div><div style="top:' + (-parseInt(fsHeight/2, 10)) + 'px;height:' + height + 'px;line-height:' + height + 'px !important;">&nbsp;<img style="max-height:' + height + 'px; max-width: ' + maxWidth + 'px;" src="' + imgUrl + '"></img></div></div>';
                            
                            } else if (this.parent.gridData.lhv) {
                                
                                TD[9] = "background-image:url('" + imgUrl + "');background-repeat:no-repeat;background-position:center " + (cell.rs > 1 ? 'top' : 'center') + ";";
                                TD[13] = NBSP;
                            } else {
                                
                                TD[9] = '';
                                TD[13] = '<img src="' + imgUrl + '"></img>';
                                
                                
                                if (cell.css && cell.css.indexOf('hl') > -1){
                                    TD[13] = '<span>' + TD[13] + '</span>';
                                }
                            }

                        } else {
                            TD[9] = "";
                            
                            TD[13] = cell.v || cell.n || NBSP;
                            
                            
                            if (cell.css && cell.css.indexOf('hl') > -1){
                                TD[13] = '<span>' + TD[13] + '</span>';
                            }
                        }

                        
                        
                        
                        if(c < this.numColumnCanMerge) {
                            
                            
                            
                            if(r === start && this.mergeHdrsAcrossBlks) {
                                var lr = this.rowHdsAcrossBlks;
                                
                                
                                
                                if(lastMatched && cell.v && lr && lr[c]) {
                                    if(cell.v === lr[c].v) { 
                                        TD[1] = cell.rs || 1;
                                        TD[5] = STITCH_BOTTOM_CSS + cell.css;
                                        TD[13] = "";
                                        
                                        
                                        this.matchedHdrsAcrossBlks.push(lr[c]);
                                    } else {
                                        lastMatched = false;
                                    }
                                }
                            }

                            if(TD[1] >= maxRowspan && cell.v) { 
                                nlr.push({rows: r-start, cells: c, v:cell.v});
                            }
                        }
                        markup[i++] = TD.join('');
                    }
                    
                    markup[i++] = '</tr>';
                }

                
                markup[i++] =  markupSuffix || '</tbody></table>';

                
                this.rowHdsAcrossBlks = nlr;
                return markup;
            },

            addHilitePosition: function(key, row, cell) {
                var hm = this.hiliteCellsMap[key];
                if(!hm) {
                    this.hiliteCellsMap[key] = {pos: [], nodes: []};
                }
                this.hiliteCellsMap[key].pos.push({row: row, cell: cell, page: 0});
            },

            addExtraInfoMap: function(ei, r, c) {
                if(!this.eiMap[ei]) {
                    this.eiMap[ei] = [];
                }
                this.eiMap[ei].push({row:r, cell:c, page: 0});
            },

            addPositionMap: function(ei, r, c){
                
                if(!this.posMap[ei]) {
                    this.posMap[ei] = {row:r, cell:c, page:0};
                }
            },

            addTitleHeaderPositionMap: function(r, c, o){
                this.thPosMap.push({row:r, cell:c, page:0, obj:o});
            },

            
            clearHilites: function(key) {
                
                var hc = this.hiliteCellsMap[key],
                    ns = hc && hc.nodes,
                    parent = this.parent;

                if(ns) {
                    if (ns.length == 0 && hc.pos) {
                        ns = this.getNodesByPositions(hc.pos);
                    }
                    for(var i = 0, iLen = ns.length; i < iLen; i++) {
                        var nd = ns[i],
                            cn = nd.className,
                            cell = parent.getCellForNode(nd);
                        
                        if ( cell ) {
                            delete cell.cet;
                        }
                        $CSS.removeClass(nd, "sc_" + parent.k);
                    }
                    this.hiliteCellsMap[key].nodes = [];
                }
            },

            
            setHilites: function(key, node) {
                $CSS.addClass(node, "sc_" + this.parent.k);

                if(!this.hiliteCellsMap[key]) {
                    this.hiliteCellsMap[key] = {pos:[], nodes:[]};
                }
                this.hiliteCellsMap[key].nodes.push(node);
                
                var cell = this.parent.getCellForNode(node);
                if ( cell ) {
                    cell.cet = key;
                }

            },

            
            getNodesByPositions: function(pos) {
                var tbl = this.tableNode,
                    arr = [];

                for(var i in pos) {
                    var v = pos[i];
                    arr.push(tbl.tBodies[0].rows[v.row].cells[v.cell]);
                }
                return arr;
            },

            preBuildGridTable : function preBuildGridTable() {
                
            },

            
            postBuildGridTable : function postBuildGridTable() {
                this.addSlots({tableNode: this.gridContainerNode && this.gridContainerNode.firstChild});
                
            }
        }   
    );

})();



(function(){
    var regExH = /"height", "[0-9.]+"/g;
    var regExW = /"width", "[0-9.]+"/g;
    var regExH1 = /height="?[0-9.]+"?/g;
    var regExW1 = /width="?[0-9.]+"?/g;
    
    mstrmojo.requiresCls("mstrmojo.Widget", 
                         "mstrmojo._Formattable",
                         "mstrmojo._IsSelectorTarget");
    
    
    mstrmojo.DocVisualization = mstrmojo.declare(
        
        mstrmojo.Widget,
        
        
        [mstrmojo._Formattable, mstrmojo._IsSelectorTarget],
        
        
        {
            scriptClass: "mstrmojo.DocVisualization",

            markupString:   '<div id={@id} class="mstrmojo-docvisualization" title="{@tooltip}" style="{@domNodeCssText}">{@htmlText}</div>',
            
            formatHandlers: {
                domNode: [ 'RW', 'T', 'B', 'fx']
            },
                            
            
            update: function update(node) {
                if (this._super) {
                    this._super(node);
                }
                
                var d = node.data;
                this.htmlText = d.htmlText;
                this.jsText = d.jsText;
                this.selData = d.selData;
                this.ctrLink = d.ctrLink;
                this.vp = d.vp;
            	this.eg = d.eg;
            	
            	if (this.eg) {
            		this.htmlText = this.eg;
            	}
            },
            
            preBuildRendering: function () {
                if (this._super) {
                    this._super();
                }
                var fmts = this.getFormats();
                if (!fmts) {
                    return;
                }
                var h = fmts.height;
                if (h) { 
                    h = h.replace('px','');
                }
                var w = fmts.width;
                if (w) {
                    w = w.replace('px','');
                }
                if (this.jsText) {
                    this.jsText = this.jsText.replace(regExH, '"height", "' + h + '"').replace(regExW, '"width", "' + w + '"');
                }
            },
            
            postBuildRendering: function pstBldRnd(){
                if (this._super) {
                    this._super();
                }
                
                eval(this.jsText);

            }, 
            
            resize: function () {
                if (this.eg) {
                    
                    return;
                }
                var embedNode = this.domNode.firstChild.firstChild.firstChild;
                if (!embedNode) {
                    return;
                }
                var fmts = this.getFormats();
                var h = fmts.height;
                if (h) {
                    h = h.replace('px','');
                }
                var w = fmts.width;
                if (w) {
                    w = w.replace('px','');
                }
                if(mstrmojo.dom.isIE){ 
                    embedNode.firstChild.setAttribute("height", h);
                    embedNode.firstChild.setAttribute("width", w);
                }else{
                    embedNode.innerHTML = embedNode.innerHTML.replace(regExH1, 'height="' + h + '"').replace(regExW1, 'width="' + w + '"');
                }

            },
            
            makeSelections: function (selections) {
                var shuffledData = {},
                    i, j, attId, e;
                
                
                for (i = 0; i < selections.length; i++) {
                    var attIdI = selections[i].attId;
                    if (!shuffledData[attIdI]) {
                        shuffledData[attIdI] = [];
                    }
                    shuffledData[attIdI] = shuffledData[attIdI].concat(selections[i].values);    
                }

                var sep = '\u001E',
                    sep1 = '\u001F';
                var ckJoined = '',
                    eidJoined = '',
                    cklJoined = '';
                var tksArray = [];
                for (attId in shuffledData) {
                
                    var sd = this.getSelectionData(attId);
                    if (!sd) {
                    	
                    	continue;
                    }
                    var ctrLink = this.ctrLink[attId];
                    var values = shuffledData[attId];

                    if (sd && values && values.length>0) { 
                        
                        sd.sel = values;
                        sd.ias = false;
                        for (e in values) {
                            if (e === "u;") {
                                sd.ias = true; 
                                break;
                            }
                        }
                    }
                    
                    if (ctrLink.gbTargets) {
                        var t = ctrLink.targets = [],
                            gbt = ctrLink.gbTargets,
                            cgbmap = this.model.getCGBMap();
                        for(j = 0; j < gbt.length; j++) {
                            var targetKey = cgbmap[gbt[j]];
                            if (targetKey) {
                                t.push(targetKey);
                            }
                        }
                        delete ctrLink.gbTargets;
                    }
                    ckJoined += ctrLink.ctxt + sep1;
                    eidJoined += values.join(sep) + sep1;
                    cklJoined += ctrLink.ck + sep1;
                    tksArray = tksArray.concat(ctrLink.targets);

                } 
                
                
                ckJoined = ckJoined.substring(0, ckJoined.length-1);
                eidJoined = eidJoined.substring(0, eidJoined.length-1); 
                cklJoined = cklJoined.substring(0, cklJoined.length-1);
				
				if(tksArray.length == 0)
				{ 
					return;
				}
                var evt = {
                        ck: ckJoined,
                        eid: eidJoined,
                        src: this.k,
                        tks: tksArray.join(sep),
                        type: this.defn.t,
                        ctlKey: cklJoined,
                        include: true,
                        isDocVis: true 
                    };
                this.model.slice(evt);
            },
            
            getAllSelectionData: function () {
                return this.selData;
            },
            
            getSelectionData: function (attId) {
                var selData = this.selData,
                    k;
                
                if (selData && selData.attl){
                    var attl = selData.attl;
                    if (attId) {
                        return attl[attId];
                    }
                    else {
                        for (k in attl) {
                            
                            return attl[k];
                        }
                    }
                }
            },
            
            saveVisProps: function (widgetPropsXml) {
				var props = {};                                                               
                props[this.k] = {
                	FormattingWidget: "WidgetProps" + '\u001F' + widgetPropsXml
                };
                        
                mstrApp.docModel.saveRWProps(this.k, props , 1, false, {success:function() {}});
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.publisher",
                         "mstrmojo.Widget",
                         "mstrmojo._HasChildren");

    var _P = mstrmojo.publisher;

    
    mstrmojo.Container = mstrmojo.declare(
        
        mstrmojo.Widget,

        
        [ mstrmojo._HasChildren ],

        
        {
            
            scriptClass: "mstrmojo.Container",

            
            defaultChildSlot: "containerNode",

            
            init: function init(props) {
                this._super(props);

                
                if (this.children) {
                    this.initChildren();
                }

                
                
                
                
                var p = this.parent;
                if (!p || p.hasInitBindings) {
                    this.initBindings();
                }
            },

            
            destroy: function dst(skipCleanup) {
                if (this.children) {
                    this.destroyChildren(true);
                }
                if (this.bindings) {
                    this.destroyBindings();
                }
                this._super(skipCleanup);
            },

            
            unrender: function unrn(ignoreDom) {
                var c = this.children,
                    len = (c && c.length) || 0,
                    i;
                for (i = len - 1; i > -1; i--) {
                    c[i].unrender(true);
                }
                this._super(ignoreDom);

            },

            
            postBuildRendering: function pstBR() {
                var ret = this._super ? this._super() : undefined;
                if (ret !== false) {
                    this.renderChildren();
                    
                    ret = true;
                }
                return ret;
            },

            
            renderChildren: function rnCh() {
                var ch = this.children,
                    len = (ch && ch.length) || 0,
                    i;

                for (i = 0; i < len; i++) {
                    var c = ch[i];
                    if (this.childRenderCheck(c)) {
                        c.render(null);
                    }
                }
            },

            
            childRenderCheck: function chRnCk(c) {
                if (c && !c.hasRendered) {
                    var s = c.slot || this.defaultChildSlot;
                    return !!this[s];
                }
                return false;
            },

            
            addChildren: function addCh(c, idx, silent) {
                var arr = this._super(c, idx, silent);
                if (arr) {
                    this.childRenderOnAddCheck(arr);
                }
                return arr;
            },

            
            removeChildren: function rmCh(c, silent) {
                var c2r = c ? [c] : (this.children || []),
                    len = c2r.length,
                    i;

                
                for (i = len - 1; i > -1; i--) {
                    var w = c2r[i],
                        dn = w && w.domNode;
                    if (dn) {
                        var s = this[(w.slot || this.defaultChildSlot)];
                        if (dn.parentNode === s) {
                            s.removeChild(dn);
                        }
                    }
                }

                
                return this._super(c, silent);
            },

            
            childRenderOnAddCheck: function childRndrOnAddChk(ch) {
                if (this.hasRendered && ch) {
                    var len = ch.length,
                        i;

                    for (i = 0; i < len; i++) {
                        var c = ch[i];
                        if (this.childRenderCheck(c)) {
                            c.render();
                        } else if (c && c.hasRendered) {
                            this.onchildRenderingChange(c);
                        }
                    }
                }
            },

            
            preserveChildDomOrder: true,

            
            onchildRenderingChange: function onChldChngRndr(child) {
                var d = child && child.domNode;
                if (!d) {
                    return;
                }

                
                var sdef = this.defaultChildSlot,
                    s = child.slot || sdef,
                    n = this[s],
                    ch = this.children;

                if (!n) {
                    
                    if (d.parentNode) {
                        d.parentNode.removeChild(d);
                    }
                } else {
                    
                    
                    if (d.parentNode === n) {
                        return;
                    }
                    
                    if (!this.preserveChildDomOrder) {
                        
                        n.appendChild(d);
                    } else {
                        
                        var sib,
                            i;

                        for (i = ch.length - 1; i >= 0; i--) {
                            var c = ch[i];

                            
                            if (c === child) {
                                
                                break;
                            }

                            
                            if (s === (c.slot || sdef)) {
                                
                                var cNode = c.domNode;

                                
                                if (cNode && cNode.parentNode === n) {
                                    
                                    sib = cNode;
                                }
                            }
                        }

                        
                        if (sib) {
                            
                            n.insertBefore(d, sib);
                        } else {
                            
                            n.appendChild(d);
                        }
                    }
                }

                
                if (_P.hasSubs(this.id, "childrenRendered")) {
                    var klen = ch.length,
                        k;

                    
                    for (k = 0; k < klen; k++) {
                        
                        
                        if (!ch[k].domNode) {
                            
                            return;
                        }
                    }

                    
                    this.raiseEvent({
                        name: "childrenRendered"
                    });
                }
            }
        }
    );

}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.Widget",
        "mstrmojo._Formattable");

    
    mstrmojo.DocLine = mstrmojo.declare(
        mstrmojo.Widget,
        
        [mstrmojo._Formattable],

        
        {
            scriptClass: "mstrmojo.DocLine",

            markupString: '<div id="{@id}" class="mstrmojo-DocLine" title="{@tooltip}" style="{@domNodeCssText}"></div>', 
            
            formatHandlers: {
                domNode: [ 'RW', 'border-top', 'border-left', 'fx' ]
            },
			
			markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },
            
            update: function update(node) {
                
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }
                
                this.thresholdId = node.data.tid;
				
				this.set('visible', !node.data.hidden);

                if (this._super) {
                    this._super(node);
                }
            },
            
            getFormats : function getFormats(){
                var fmts = this._super();
                if(fmts && parseInt(fmts.height, 10) === 0) { 
                    fmts.height = "1px";
                }
                return fmts;
            }
        }
    );
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.func",
        "mstrmojo.Model",
        "mstrmojo._CanProxyCallback",
        "mstrmojo.EnumRWUnitType",
        "mstrmojo.DocDataService",
        "mstrmojo.StringBuffer",
        "mstrmojo.EnumReadystate");

    var $RWTYPES = mstrmojo.EnumRWUnitType,
        $RS = mstrmojo.EnumReadystate,
        $HFE = mstrmojo.hash.forEach,
        $WRAP = mstrmojo.func.wrapMethods,
        $A = mstrmojo.array;

    
    var observables = {
        isObservable: function (defn) {
            
            var t = defn && defn.t;

            
            if (!t || !(t in this) || defn.scriptClass) {
                
                return false;
            }

            
            return (t !== $RWTYPES.SUBSECTION || !defn.dt);
        },

        makeObservable: function (defn) {
            
            defn.audibles = this[defn.t] || {};

            
            if ('readyState' in defn.audibles) {
                
                defn.readyState = $RS.IDLE;
            }

            
            return new mstrmojo.Model(defn);
        }
    };

    observables[$RWTYPES.PANELSTACK] = {
        '*': false,
        selKey: true,    
        readyState: true
    };

    observables[$RWTYPES.GRID] = {
        '*': false,
        readyState: true,
        ds: true    
    };

    observables[$RWTYPES.GRAPH] = {
        '*': false,
        readyState: true,
        ds: true    
    };

    observables[$RWTYPES.GRIDGRAPH] = {
        '*': false,
        qsm: true,
        ds: true    
    };

    observables[$RWTYPES.SUBSECTION] = {
        '*': false,
        resize: true,
        adjustSize: true
    };

    observables[$RWTYPES.VISUALIZATION] = {
        '*': false,
        ds: true    
    };

    observables[$RWTYPES.SELECTOR] = {
        '*': false,
            cek: true,    
            ds: true
    };

    observables[$RWTYPES.MOJOVISUALIZATION] = {
        '*': false,
        ds: true    
    };


    
    function getLayout(node, lytKey) {

        
        
        var lyt = node.layoutMap && node.layoutMap[lytKey];
        if (lyt) {
            return lyt;
        }

        var lyts = node.layouts,
            cnt = (lyts && lyts.length) || 0,
            i = 0;

        for (i = 0; i < cnt; i++) {
            if (lyts[i].k == lytKey) {
                return lyts[i];
            }
        }

        return null;
    }

    
    function lookupDefn(defn, lytKey, key) {
        var lyt = getLayout(defn, lytKey);

        if (key == lytKey) {
            
            lyt._lkz = lytKey;

            return lyt;

        } else if (lyt) {
            
            var unit = lyt.units[key];
            
            if (unit) {
                
                if (unit.t == $RWTYPES.GRIDGRAPH) {
                    
                    
                    if (!lyt.units[key + '_0']) {

                        
                        lyt.units[key + '_0'] = {
                            ck: unit.ck,  
                            fmts: unit.fmts.gd,    
                            txi: unit.txi, 
                            t: $RWTYPES.GRID
                        };

                        
                        lyt.units[key + '_1'] = {
                            ck: unit.ck,  
                            fmts: unit.fmts.gp,    
                            t: $RWTYPES.GRAPH
                        };
                    }
                }

                
                if (observables.isObservable(unit)) {
                    
                    unit = lyt.units[key] = observables.makeObservable(unit);
                }

                
                unit._lkz = lytKey;
            }

        }

        return lyt && lyt.units[key];
    }
    
    function filterSectionsByTypes(node, isPartial, types, include) {
        var children = this.getChildren(node, isPartial, 0);
        
        return (mstrApp.isMobile ? (mstrmojo.array.filter(children, function (sec) {
                                            var idx = types && types.indexOf(sec.defn.t),
                                            	dk = sec.defn.dk;
                                            return include? (idx > -1 && dk === -1) : (idx < 0 || dk !== -1);
                                        })) : (include ? [] : children));
    }

    
    var fnBuildId = function(data, lk) {
        var id = new mstrmojo.StringBuffer();

        
        if (lk) {
            
            id.append('*l' + lk);
        }

        
        id.append('*k' + data.k);

        
        if ('wid' in data) {
            
            id.append('*x' + data.wid);
        }

        
        id.append('*t' + this.buildTime);

        return id.toString();
    };

    
    function getTxUpdates(t) {
        var i, w,
        d = this.delta,
        pu = this.pendingUpdate,
        updates = [];

        
        if(!pu) {
            pu = this.pendingUpdate = {};
        }

        if(!mstrmojo.hash.isEmpty(d)) {
            updates.push('<updates>');
            for(i in d) {
                if(d.hasOwnProperty(i)) {
                    w = d[i];
                    updates.push(w.getUpdates());
                }
            }
            
            pu[t] = d;
            
            this.delta = {};

            updates.push('</updates>');
        }
        return updates.join('');
    }

    
    function fnGetTargetDefn(keys, delim) {
        var defs;
        if ( keys ) {
	        keys = keys.split(delim || '\u001E');
	        for (var i = 0, cnt = keys.length; i < cnt; i++) {
	            defs = defs || {};
	            defs[keys[i]] = lookupDefn.call(this, this.defn, this.currlaykey, keys[i]);
	        }
        }
        return defs;
    }

    function unloadAffectedLayouts(me, data) {
        var ulkeys = data.ulkeys,
        
            view = me.controller.view;
        if (view && view.unloadLayouts && ulkeys && ulkeys.length) {
            view.unloadLayouts(ulkeys);
        }
    }

    
    function isInfoWindowPS(key, layoutKey) {
        var defn = this.getLayoutUnitDefn(key, layoutKey);
        return (defn && defn.t === $RWTYPES.PANELSTACK && defn.ifw);
    }

    function isCurrentSlice(node, sid){
        return !sid || (node.wid == sid);
    }

    
    function hasAllSelectedInGB() {
        var lyts = this.data && this.data.layouts,
            lyt = lyts[$A.find(lyts, 'k', this.getCurrentLayoutKey())],
            gbs = lyt && lyt.gbys && lyt.gbys.groupbys,
            isAllSelected = false;

        $A.forEach(gbs, function (gb) {
            if (gb.unit && gb.unit.elms && gb.unit.elms[gb.unit.idx].v === 'u;' ) {
                isAllSelected = true;
                return false;
            }
        });

        return isAllSelected;
    }
    
    mstrmojo.DocModel = mstrmojo.declare(
        
        mstrmojo.Model,

        
        [mstrmojo._CanProxyCallback],

        
        {
            scriptClass: 'mstrmojo.DocModel',

            audibles: {
                '*': false,
                data: true
            },

            
            features: null,

            
            dataCache: null,

            
            controller: null,

            
            sdp : null,

            
            init: function init(props) {
                this._super(props);

                if (!this.features) {
                    this.features = new mstrmojo.Model();
                    this.disposables.push(this.features);
                }
                this.ondefnChange();

                
                this.buildTime = mstrmojo.now();
            },

            
            makeObservable: function makeObservable(defn) {
                return observables.makeObservable(defn);
            },

            
            getTargetDefn: function(keys) {
                return fnGetTargetDefn.call(this,keys);
            },

            getTargetInfoWin: function(keys) {
            	var ret = [],
            		tgtDefs = fnGetTargetDefn.call(this, keys);
            	if (tgtDefs) {
            		var tgt;
            		for (tgt in tgtDefs) {
            			if (tgtDefs[tgt] && tgtDefs[tgt].ifw) {
            				ret.push(tgt);
            			}
            		}
            	}

            	return ret;
            },

            
            getUnitDefinitions: function(keys, delim) {
                return fnGetTargetDefn.call(this,keys, delim);
            },

            
            hasFeatures: function rsFts( featList){
                var fs = this.features;
                if (!fs) {
                    return false;
                }

                var arr = featList.split(',');
                for (var i=0, len=arr.length; i<len; i++){
                    var s = arr[i],
                        neg = s.match(/^\!/);
                    if (neg) {
                        s = s.replace("!", "");
                    }
                    if (neg ? this.features[s] : !this.features[s]) {
                        return false;
                    }
                }
                return true;
            },

            
            ondefnChange: function ondefnChg(){
                var defn = this.defn,
                    lyts = defn && defn.layouts,
                    lytMap = {};
                if (defn) {
                defn.layoutMap = lytMap;

                for (var i = 0, cnt = lyts && lyts.length || 0; i < cnt; i++) {
                    var lyt = lyts[i];
                    lytMap[lyt.k] = lyt;
                }
                }
            },

            
            formatResolver: {

                
                getFormat: function getFormats(defn, thresholdId) {
                    
                    var fmts = ((defn && defn.fmts) || null);

                    
                    if (thresholdId) {
                        
                        var ts = defn.thresholds,
                            tFmts = ts && ts[thresholdId];

                        
                        if (tFmts) {
                            
                            var fx = {},
                                p;

                            
                            for (p in fmts) {
                                fx[p] = tFmts[p] || fmts[p];
                            }

                            
                            for (p in tFmts) {
                                var formatValue = tFmts[p];
                                fx[p] = (typeof(formatValue) === "string") ? (formatValue + " !important") : formatValue;
                            }

                            
                            fmts = fx;
                        }
                    }

                    
                    return fmts;
                }
            },

            
            getSelectedXtabStyles: function getSelectedGridStyles(k)  {
                var sk = k || this.currlaykey;
                var ss = {};

                var lyts = this.data && this.data.layouts;
                for (var i in lyts) {
                    if (lyts[i].k === sk) {
                        ss = lyts[i].xtabStyles;
                        break;
                    }
                }

                return ss;
            },

            
            getChildren: function getCh(node, isPartial, start, count, includeTotal) {
                
                var layoutKey = this.currlaykey;

                
                if (node) {
                    
                    var defn = node.defn;
                    layoutKey = (defn && defn._lkz) || node.k;
                }

                
                
                var dc = this.getLayoutDataCache(layoutKey),
                    useCache = (!isPartial && !mstrmojo.hash.isEmpty(dc)),
                    lookin;

                
                if (!node) {
                    
                    lookin = this.data;
                } else {
                    
                    var src = node.data || node;

                    
                    if (useCache) {
                        
                        lookin = dc[fnBuildId.call(this, src, layoutKey)];

                        
                        lookin = (lookin && lookin.data) || lookin || src;
                    } else {
                        
                        lookin = src;
                    }
                }

                
                var arr = lookin ? (lookin.sections || lookin.subsections || lookin.objects || lookin.panels || lookin.layouts || lookin.children) : [],
                    ch = [];

                var len = (arr && arr.length) || 0;
                if (len) {
                    var defn = this.defn,
                        traversingLayouts = !node,
                        ck = node ? layoutKey : null,                                           
                        type = (node && ((node.defn) ? node.defn.t : lookupDefn.call(this, defn, ck, node.k).t));        

                    
                    var isGridGraph = (type === $RWTYPES.GRIDGRAPH),
                        isDetails = (type === $RWTYPES.DETAILS);

                    for (var i = start || 0, stop = (isNaN(count)) ? len : i + count; i < stop; i++) {
                        var item = arr[i];
                        if (isGridGraph) {
                            
                            item.k = node.k;
                            item.wid = node.data.wid;
                        }
                        var key = item.k,
                            id = fnBuildId.call(this, item, ck),
                            df;

                        
                        
                        
                        if (!traversingLayouts && !isPartial && isInfoWindowPS.call(this, key, ck)) {
                            var unitDef = this.getLayoutUnitDefn(key),
                                unit = {
                                        data:item,
                                        defn: unitDef,
                                        id: id,
                                        k: key,
                                        p: lookin
                                    };
                            dc[id] = unit;
                            
                            
                            if(!this.infoWinByKey || !this.infoWinByKey[key]) { 
                                var infoWindows = this.infoWindows = this.infoWindows || {};
                                var infoWinByKey = this.infoWinByKey = this.infoWinByKey || {};
                                infoWindows[unitDef.n] = infoWinByKey[key] = unit;
                            }
                            continue;
                        }

                        
                        if (isGridGraph) {

                            
                            id += '_' + i;

                            
                            df = lookupDefn.call(this, defn, ck, item.k + '_' + i);

                        } else {
                            df = lookupDefn.call(this, defn, ck || item.k, item.k);    
                        }


                        
                        if (isDetails) {
                            
                            
                            df.dt = true;
                        }

                        
                        ch.push({
                            k: item.k,
                            id: id,
                            defn: df,
                            data: useCache ? (dc[id] && dc[id].data) || item : item
                        });
                    }
                }
                   
                return includeTotal ? { nodes: ch, total: len } : ch;
            },

            
            getInfoWindow: function getInfoWindow(name) {
                var infoWindows = this.infoWindows;
                return infoWindows && infoWindows[name];
            },

            
            getFixedHeaders: function(node, isPartial) {
                return filterSectionsByTypes.call(this, node, isPartial, [$RWTYPES.PAGEHEADER], true);
            },
            
            getFixedFooters: function(node, isPartial) {
                return filterSectionsByTypes.call(this, node, isPartial, [$RWTYPES.PAGEFOOTER], true);
            },
            getNonFixedSections: function(node, isPartial) {
                return filterSectionsByTypes.call(this, node, isPartial, [$RWTYPES.PAGEHEADER, $RWTYPES.PAGEFOOTER], false);
            },
            
            getLayoutUnitDefn: function getLayoutUnitDefn(key, layoutKey) {
                return lookupDefn.call(this, this.defn, layoutKey || this.currlaykey, key);
            },

            getUnitInstance: function getUnitInstance(key, widgetID) {
                return mstrmojo.all[fnBuildId.call(this, {
                    k: key,
                    wid: widgetID
                }, this.currlaykey)];
            },

            getFirstUnitInstanceByName: function getFirstUnitInstanceByName(name) {
                var lyt = getLayout(this.defn, this.currlaykey);
                if (lyt) {
                    
                    var units = lyt.units;
                    for (u in units) {
                        var unit = units[u];
                        if ( unit.n === name ) {
                           return this.getUnitInstance(u,1);
                        }
                    }
                }
                return null;
            },

            
            getSelectedKey: function getSelK( node) {
                return (!node && this.currlaykey) || null;
            },

            getCurrentLayoutKey: function getCurrentLayoutKey() {
                return this.currlaykey;
            },

            getCurrentLayoutDef: function getCurrentLayoutDef() {
                var layouts = this.defn && this.defn.layouts;
                return layouts && layouts[$A.find(layouts, 'k', this.currlaykey)];
            },

            
            replaceLayout: function replaceLayout(key, node) {
                var dc = this.dataCache;

                
                if (dc && dc[key]) {
                    
                    dc[key] = {};
                }

                
                var lyts = (this.data && this.data.layouts) || (this.defn && this.defn.layouts);
                for (var i = (lyts && lyts.length - 1) || 0; i >= 0; i--) {
                    if (lyts[i].k === key) {
                        break;
                    }
                }

                
                this.bs = node.bs;

                
                this.zf = node.zf;

                
                if (node.data) {
                    this.data.layouts[i] = node.data.layouts[i];
                    
                    this.data.elems = node.data.elems;
                }

                
                if (node.defn) {
                    this.defn.layouts[i] = node.defn.layouts[i];

                    
                    this.ondefnChange();
                }

            },

            
            loadLayout: function loadLayout(layoutJSON, unloadCache, restoreIW) {
                this.replaceLayout(layoutJSON.currlaykey, layoutJSON);

                this.raiseEvent({
                    name: 'rebuildLayout',
                    unloadCache: !!unloadCache, 
                    restoreIW: !!restoreIW 
                });
            },

            
            getTransactionUpdates: function getTransactionUpdates(t) {
                return this.txDiscardTargets ? '' : getTxUpdates.call(this, t);
            },

            
            clearTransactionUpdates: function clearTransactionUpdates(t) {
                this.clearTxDeltaUpdate(t);
            },

            
            resetTransactionUpdates: function resetTransactionUpdates(t) {
            	var pu = this.pendingUpdate,
            		d = this.delta;

            	
            	if(pu && pu[t]) {
            		
            		$HFE(pu[t], function(v, i) {
            			if(d && !d[i]) {
            				d[i] = v;
            			}
            		});
            		
            		delete pu[t];
            	}
            },

            getDataService: function getDataService() {
                var dataService = this.dataService,
                    me = this;
                if (!dataService) {
                    var params = {
                        rwb: this.bs,
                        msgId: this.mid,
                        model: this
                    };

                    if (mstrApp.modelFactory) {
                        dataService = mstrApp.modelFactory.newDataService('Document', params);
                    } else {
                        dataService = mstrApp.viewFactory.newDocDataService(params);
                    }

                    this.dataService = dataService;
                    this.disposables.push(dataService);
                }
                return dataService;
            },

            partialUpdate: function partialUpdate(data, targetDefinitions) {
                
                var updatedDataCache = this.updateDataCache(data, targetDefinitions);

                
                this.raiseEvent({
                    name: 'partialUpdate',
                    tree: data,                 
                    ids: updatedDataCache
               });

                return updatedDataCache;
            },

            
            transactionUpdate: function(res, evt){
                
                if (!res.data){
                    return;
                }

                var me = this,
                    tgtDefs;

                
                if (evt && evt.tks) {
                    tgtDefs = fnGetTargetDefn.call(this, evt.tks);
                }
                
                if(res.pukeys) {
                    tgtDefs = fnGetTargetDefn.call(this, res.pukeys);

                    
                    var tgt;
                    for (tgt in tgtDefs) {
                        if (tgtDefs[tgt] && tgtDefs[tgt].cek) {
                            tgtDefs[tgt].cek = null;
                        }
                    }
                }

                
                if(res.txrcd) {
                    this.txrcd = res.txrcd;
                } else {
                    
                    delete this.txrcd;
                }

                
                
                
                var ids = this.updateDataCache(res.data, tgtDefs, evt && evt.sid),
                    ue = {
                            name: 'partialUpdate',
                            tree: res.data,   
                            ids: ids
                        };

                
                if(!mstrmojo.hash.isEmpty(ids.ifws)){
                    if (evt && evt.type === $RWTYPES.GRID) {
                        ue.anchor = evt.anchor;
                    } else {
                        
                        ids.ifws = {};
                    }
                }

                
                this.raiseEvent(ue);

                return ids;
            },

            deltaUpdate: function dltUdt(w) {
                var d = this.delta;
                if(!d) {
                    d = this.delta = {};
                }
                d[w.id] = w;
            },

            
            clearTxDeltaUpdate: function clrDltUdt(t) {
                var widgetsToClearTx = this.txDiscardTargets,
                    clearAll = !widgetsToClearTx, 
                    pu = this.pendingUpdate,
                    me = this,
                    id;

                
                if(!clearAll) {
                    
                    $HFE(widgetsToClearTx, function(v, id) {
                        if(me.delta && me.delta[id]) {
                            me.delta[id].clear();
                            delete me.delta[id];
                        }
                    });
                }

                
                if(pu && pu[t]) {
                    
                    $HFE(pu[t], function(w) {
                        w.clear();
                    });
                	delete this.pendingUpdate[t];
                }

            },

            
            sendTransactionActions: function sendTransactionActions(ck, at, callbacks) {

                var me = this, params;
                if(!callbacks) {
                    callbacks = {
                        success: function(res){
                            
                            me.transactionUpdate(res);
                        }
                    };
                }

                me.getDataService().sendTransactionActions({
                    keyContext: ck,
                    actions: at,
                    txrcd: this.txrcd
                }, callbacks);
            },

            
	     addSDP: function addSDP(sdpKey, primaryWidgetInfo) {
		    if (!sdpKey || !primaryWidgetInfo) {
			return;
		    }
		    if(!this.sdp){
			this.sdp = {};
		    }
		    this.sdp[sdpKey] = {k: primaryWidgetInfo.k,visName:primaryWidgetInfo.visName};

	     },

	    
            removeSDP: function removeSDP(sdpKey) {
		    if (!sdpKey || !this.sdp[sdpKey]) {
			return;
		    }

		    
		    delete this.sdp[sdpKey];

            },

            
            slice: function slice(evt) {
                try {
                    
                    
                    if (!evt || (!mstrmojo.dom.isAndroid && !evt.tks && !evt.multiSelect && (evt.type === 3 || (evt.type === $RWTYPES.GRAPH && evt.tty != 1)))) {
                        return;
                    }

                    var dataCacheUpdate = null,
                        me = this,
                        dataService = this.getDataService(),

                        
                        tgtDefs = evt.tks ? fnGetTargetDefn.call(this, evt.tks) : null,

                        
                        orignalTargetDefs = tgtDefs,

                        
                        fnSetReadyState = function (v) {
                            
                            $HFE(orignalTargetDefs, function (targetDef, key) {
                                
                                if (targetDef && targetDef.set) {
                                    
                                    targetDef.set('readyState', v);
                                }
                            });
                        },

                        
                        fnGetWidget = function (k, wid) {
                            return mstrmojo.all[fnBuildId.call(me, {
                                k: k,
                                wid: wid
                            }, me.currlaykey)];
                        },

                        
                        callback = this.newCallback({
                            method: 'slice',

                            submission: function () {
                                
                                fnSetReadyState($RS.WAITING);
                            },

                            success: function (res) {

                                if (evt.disablePU) {
                                    me.loadLayout(res, evt.isUConDS, evt.restoreIW); 
                                    
                                    return;
                                }
                                
                                if (res.pukeys) {
                                    tgtDefs = fnGetTargetDefn.call(me, res.pukeys);
                                }
                                unloadAffectedLayouts(me, res);

                                
                                
                                dataCacheUpdate = me.updateDataCache(res.data, tgtDefs,evt && evt.sid);
                                if (typeof(res) == 'object') {
                                    
                                    mstrmojo.hash.copyProps(['bs', 'exopt', 'dty'], res, me);
                                }

                                var ue = {
                                        name: 'partialUpdate',
                                        tree: res.data,   
                                        ids: dataCacheUpdate
                                 };

                                 
                                if(!mstrmojo.hash.isEmpty(ue.ids.ifws)){
                                    if (evt && !evt.suppressIW && (evt.type === $RWTYPES.GRID || evt.type === $RWTYPES.GRAPH)) { 
                                        ue.anchor = evt.anchor;
                                    } else {
                                        
                                        
                                        ue.ids.ifws = {};
                                    }
                                }

                                
                                me.raiseEvent(ue);
                            },

                            complete: function () {
                                
                                fnSetReadyState($RS.IDLE);
                            }
                        });

                    
                    if (evt.type == 3) {
                        
                        var panelStackKey = evt.tks,
                            panelKey = evt.eid;

                        
                        if (!panelStackKey) {
                            
                            return;
                        }


                        
                        var pnlDef = lookupDefn(this.defn, this.currlaykey, panelKey);
                        if (!pnlDef) {
                            
                            return;
                        }

                        
                        var dirtyKeys = panelKey,

                            panelStackDefn = tgtDefs[panelStackKey],

                            
                            fnActivatePanel = function () {
                                panelStackDefn.set('selKey', panelKey);
                            },

                            
                            fnPanelState;

                        
                        panelStackDefn.newSelKey = panelKey;

                        
                        if (pnlDef.l) {

                            
                            var dk = pnlDef.dirtyKeys;

                            
                            
                            if (!!dk) {

                                
                                dirtyKeys = mstrmojo.hash.keyarray(dk).join(',');

                                
                                orignalTargetDefs = tgtDefs = fnGetTargetDefn.call(this, dirtyKeys, ',');

                                
                                fnPanelState = function () {
                                    
                                    fnActivatePanel();

                                    
                                    $HFE(dataCacheUpdate.upd, function (v, updatedId) {
                                        
                                        var updatedWidget = mstrmojo.all[updatedId];

                                        
                                        if (updatedWidget && updatedWidget.setDirty) {
                                            updatedWidget.setDirty(false);
                                        }
                                    });
                                };

                            } else {
                                
                                dataService.setCurrentPanel(panelKey, evt.tks, evt.ck, this.newCallback({
                                    method: 'slice',
                                    success: fnActivatePanel
                                }));
                                return;
                            }

                        } else {
                            
                            fnPanelState = function () {
                                    
                                fnActivatePanel();

                                    
                                    pnlDef.l = true;
                            };
                                }

                        
                        var fnSuccess = callback.success;
                        callback.success = function (res) {

                                
                            var lyt = getLayout(res.defn, me.currlaykey),
                                oldLyt = getLayout(me.defn, me.currlaykey),
                                fnAppendNewProps = function (oldObj, newObj) {
                                        for (var u in newObj) {
                                            
                                            
                                            if (oldObj[u] === undefined) {
                                                oldObj[u] = newObj[u];
                                            }
                                        }
                                    },
                                    newUnits = lyt && lyt.units,
                                    oldUnits = oldLyt && oldLyt.units,
                                    newCGBMap = lyt && lyt.cgbMap,
                                    oldCGBMap = oldLyt && oldLyt.cgbMap;

                                
                                if (newUnits) {
                                fnAppendNewProps(oldUnits, newUnits);
                                }

                                
                                if (newCGBMap) {
                                    fnAppendNewProps(oldCGBMap, newCGBMap);

                                    
                                    me.raiseEvent({
                                        name: 'CGBMapChange',
                                        cgbMap: oldCGBMap
                                    });
                                }

                            
                            fnSuccess(res);

                            
                            fnPanelState();

                            
                            var panelStack = fnGetWidget(evt.tks, 0);
                            if (panelStack) {
                                panelStack.clearDirtyChild(panelKey);
                            }
                        };

                        
                        dataService.requestNewPanel(panelKey, evt.tks, evt.ck, dirtyKeys, !evt.hasLoader, callback);

                    } else {

                        
                        callback = $WRAP(callback, {
                            success: function (res) {

                                
                                $HFE(orignalTargetDefs, function (def, targetKey) {
                                    
                                    var targetWidget = fnGetWidget(targetKey, 1);

                                    
                                    if (!targetWidget) {

                                          
					  

					  
					  

					  if (!!me.sdp && !!me.sdp[targetKey]) {
						var sdpData = me.getLayoutDataCache(me.getCurrentLayoutKey());
						var sdpId = fnBuildId.call(me, {k: targetKey, wid: 1}, me.currlaykey);
						me.raiseEvent({name: 'secondaryDataSliced',key:targetKey,data:sdpData[sdpId].data});
					  }

                                        
                                        return;
                                    }

                                    
                                    if (dataCacheUpdate && !(targetKey in dataCacheUpdate.def)) {

                                        
                                        if(targetWidget.setDirty) {
                                    	    targetWidget.setDirty(true);
                                        }

                                    
                                    } else if (def.t == $RWTYPES.PANELSTACK) {

                                        
                                        targetWidget.setDirtyChildren();
                                    }
                                });
                            }
                        });

                        var args, methodName;

                        
                        if (evt.type == $RWTYPES.GRAPH) {
                            
                            methodName = 'applyGraphSelectorAction';
                            args = [ evt.ck, evt.cks, evt.sid, evt.x, evt.y, callback, me.zf];
                        } else {

                            
                            
                        if(evt.isMultipleEvents){
                            methodName = 'RWEventsTask';
                            params = {
                                    messageID: this.mid,
                                    styleName: 'RWDocumentMojoStyle',
                                    events: evt.events
                            };
                            args = [params, callback];
                        } else if ('eid' in evt) { 
                                methodName = evt.isDocVis ? 'setDocVisSelectorElements' : 'setDocSelectorElements';
                                args = [ evt.ck, evt.eid, evt.ctlKey, evt.include, callback , me.zf];
                                
                                var hasAllInGB = hasAllSelectedInGB.call(this);
                                if (evt.isUConDS || hasAllInGB) {
                                	evt.disablePU = true;
                                    args = args.concat([null, 0, null, true]);
                                }
                                
                                if (hasAllInGB) {
                                    evt.restoreIW = true;
                                }

                				 
                				 

                				 if (me.sdp) {
                					var sdpreqKeys = {};
                					$HFE(me.sdp, function(obj, key){
                						if (me.sdp[key]) {
                							sdpreqKeys[key] = obj.visName;
                						}

                					});

                					args[7] = JSON.stringify(sdpreqKeys);

                				 }
                                 args[8] = evt.tks;
                            } else if (evt.multiSelect) {
                                if (evt.selectorObjects.length > 0) {
                                    methodName = 'setMultiDocSelectorElements';
                                    args = [evt.selectorObjects, evt.multiSelect, callback, me.zf];
                                }
                            } else {
                                
                                
                                if ('srct' in evt && evt.srct == 4) {
                                    if (evt.onlyInclude){
                                        methodName = 'setDocSelectorInclude';
                                        args = [ evt.ckey, evt.include, callback, evt.srcid, evt.srct, me.zf];

                                    } else {
                                        methodName = 'setDocSelectorExpression';
                                        args = [ evt.ck, evt.ckey, evt.srcid, evt.srct, evt.f, evt.ft, evt.include, evt.cs, 5, callback, me.zf];

                                        if (!evt.cs) {
                                            args[7] = null;
                                            args[8] = null;

                                            if (evt.changeQual) {
                                                
                                                dataService.setRWUnitProperties(evt.ckey, evt.ckey + '\u001F' + 'FormattingSelector' + '\u001F' + 'MetricConditionType' + '\u001F' +evt.qt, 1, false, null);

                                                args.push(evt.unset);
                                            }
                                        }

                                    }
                                } else if (evt.unset) {
                                    methodName = 'setDocUnsetSelector';
                                    args = [ evt.ck, evt.ckey, callback, me.zf];

                                } else {
                                    methodName = 'setDocSelectorInclude';
                                    args = [ evt.ckey, evt.include, callback, null, null, me.zf ];

                                }
                            }
                        }

                        if (methodName) {
                            dataService[methodName].apply(dataService, args);
                        }
                    }

                } catch (ex) {
                    mstrmojo.err(ex);
                }
            },

            
            getLayoutDataCache: function getLayoutDataCache(key) {
                
                if (!key) {
                    return null;
                }

                var dc = this.dataCache;
                
                if (!dc) {
                    
                    dc = this.dataCache = {};
                }

                
                if (!dc[key]) {
                    
                    dc[key] = {};
                }

                return dc[key];
            },

            
            updateDataCache: function updDC(tree, tks, sid) {

                var me = this,
                    dc = this.getLayoutDataCache(this.getCurrentLayoutKey()),
                    _result = {
                        ifws: {},    
                        upd: {},    
                        tgts: {},   
                        def: {},    
                        secs: {}    
                    };

                
                function findTgtDescendants(node, wasInst, activeKey) {

                    var isInst = false,   
                        chnodes = me.getChildren(node, true), 
                        w;              

                    
                    if (!chnodes.length) {
                        
                        return;
                    }

                    
                    if (wasInst) {
                        
                        w = mstrmojo.all[node.id];

                        
                        
                        isInst = !node.id || !!w;
                    }

                    var nodeDefn = node.defn,
                        nodeData = node.data,
                        selectedPanelKey;

                    
                    if (nodeDefn && nodeDefn.t === $RWTYPES.PANELSTACK && nodeDefn.od) {
                        
                        selectedPanelKey = nodeData.selKey;
                    }

                    
                    for (var cnt in chnodes) {
                        var ch = chnodes[cnt],
                            childKey = ch.k,
                            id = ch.id,
                            localActiveKey = null;

                        
                        if (mstrmojo.all[id]) {
                            isInst = true;
                        }

                        
                        if (childKey in tks) {

                            if (isInfoWindowPS.call(me, childKey) && isCurrentSlice(ch.data, sid)) {
                                
                                dc[id] = ch;

                                
                                if (!activeKey) {
                                    
                                    _result.ifws[childKey] = me.infoWinByKey[childKey].id; 
                                }
                            }

                            
                            localActiveKey = childKey;

                            
                            if (isInst) {
                                
                                
                                if (selectedPanelKey && selectedPanelKey !== childKey) {
                                    
                                    continue;
                                }

                                
                                if (!activeKey) {
                                _result.tgts[id] = true;
                                }

                                var secDef = w && w.defn,
                                    ty = secDef && secDef.t,
                                    ck = secDef && secDef.ck;

                                
                                if (ty === $RWTYPES.SUBSECTION && (ck && (childKey in ck))) {
                                    
                                    _result.secs[w.id] = true;
                                }
                            }
                        }

                        
                        if ((activeKey || localActiveKey) && (!selectedPanelKey || selectedPanelKey === childKey)) {
                            
                            dc[id] = ch;

                            
                            _result.def[childKey] = true;

                            
                            if (isInst) {
                                
                                _result.upd[id] = true;
                            }
                        }

                        
                        findTgtDescendants(ch, isInst, activeKey || localActiveKey);
                    }
                }

                
                if (tree && tree.layouts && tks) {
                    
                    findTgtDescendants(mstrmojo.array.filter(tree.layouts, function (l) {
                            return (l.loaded);
                        }, {
                            max: 1
                        })[0], true);
                }

                return _result;
            },
            
            getCGBMap: function getCGBMap(){
                var lyt = getLayout(this.defn, this.currlaykey);

                return lyt && lyt.cgbMap;
            },

            executeLink: function executeLink(url, target, src) {
                
                
                
                if (url.indexOf('prevMsgID') > 0) {
                    var replacement = 'prevMsgID=' + this.mid;
                    url = url.replace(/prevMsgID=0($|&)/g, function (match, cap) {
                        if (cap == '&') {
                            return replacement += '&';
                        } else {
                            return replacement;
                        }
                    });
                    
                    if (mstrmojo.dom.isIE) {
                        url += '&cb' + mstrmojo.now() + '=1';
                    }
                }

                url = mstrmojo.addCSRFTokenToURL(url);

                this.controller.onLink(
                        this,
                        {
                            url: url,
                            target: target,
                            src: src || null
                        }
                 );
            },

            showInfoWin: function showInfoWin(key, anchor, orientation, invalidate, anchorPosition) {
                var ifwunit = this.infoWinByKey && this.infoWinByKey[key];
                if (ifwunit === undefined) { 
                    return;
                }
                this.raiseEvent({
                    name: 'showInfoWin',
                    psId: ifwunit.id,
                    psKey: ifwunit.k,
                    anchor: anchor,
                    anchorOrientation: orientation,
                    anchorPosition: anchorPosition,
                    invalidate: invalidate
                });
            },

            
            downloadGridData: function downloadGridData(params) {
                var me = this,
                    widgetID = params.xtabId,
                    memo = params.memo,
                    w = mstrmojo.all[widgetID],
                    dataService = this.getDataService();

                var callback = this.newCallback({
                        success: function (res) {
                            
                            function findWidgetData( node,  wID) {
                                
                                var chnodes = me.getChildren(node, true);

                                
                                for (var cnt in chnodes) {
                                    var ch = chnodes[cnt];
                                    if(wID == ch.id) {
                                        return ch;
                                    }

                                    
                                    var w = findWidgetData(ch, wID);
                                    
                                    if(w) {
                                        return w;
                                    }
                                }
                                return null;
                            }

                            
                            var tree = res.data,
                                newGridData = null,
                                nodeDef, 
                                lyt = tree && getLayout(tree, me.currlaykey);

                            
                            if (lyt) {
                                newGridData = findWidgetData(lyt, widgetID);
                            }

                            if (newGridData && w) {
                                w.dataDownloaded(newGridData, memo);
                            }

                            if(lyt && lyt.xtabStyles) {
                                me.raiseEvent({
                                    name: 'updateStyles',
                                key: lyt.k,
                                    updatedStyles: lyt.xtabStyles
                                });
                            }

                            
                            nodeDef = lookupDefn.call(me, me.defn, me.currlaykey, params.nodeKey);
                            if(nodeDef && nodeDef.t === $RWTYPES.GRIDGRAPH && memo.recalculating) {
                                var gg = w.parent,
                                    gp = gg && gg.getGraphWidget();
                                if(gg && gp && gg.updateGraph) {
                                    gg.updateGraph(findWidgetData(lyt, gp.id));
                                }
                            }

                        },

                        failure: function() {
                            if(w.dataDownloadErr) {
                                w.dataDownloadErr();
                            }
                        }
                });

                dataService.downloadGridData(params, callback);
            },

            
            saveRWProps: function saveRWProps(nodeKey, props, type, loadData, callback) {
                var data = [],
                    d = '\u001F';

                
                $HFE(props, function (o, key) {
                    
                    $HFE(o, function (v, p) {
                        
                        data.push(key + d + p + d + v);
                    });
                });

                
                if (!data.length) {
                    
                    return;
                }

                
                    if (loadData) {
                    
                    var g = lookupDefn.call(this, this.defn, this.currlaykey, nodeKey),
                        fnReadyState = function (rs) {
                            g.set('readyState', rs);
                        };

                    
                    callback = $WRAP(callback, {
                        submission: function () {
                            
                            fnReadyState($RS.WAITING);
                        },

                        complete: function () {
                            
                            fnReadyState($RS.IDLE);
                        }
                    });
                }

                
                this.getDataService().setRWUnitProperties(nodeKey, data.join('\u001E'), type || 1, loadData, callback);
            },

            loadPartialData: function loadPartialData(data, nodeKey){
                
                var tgtDef =  {};
                tgtDef[nodeKey] = lookupDefn.call(this, this.defn, this.currlaykey, nodeKey);


                
                
                var ids = this.updateDataCache(data, tgtDef),
                    dc = this.getLayoutDataCache(this.getCurrentLayoutKey()),
                    me =  this;

                
                mstrmojo.array.forEach(data.layouts, function (l) {
                    if(l && l.xtabStyles) {
                        me.raiseEvent({
                            name: 'updateStyles',
                            key: l.k,
                            updatedStyles: l.xtabStyles
                        });
                    }
                });

                
                $HFE(ids, function (col, meth) {
                    if (meth === 'upd') {
                        $HFE(col, function (v, id) {
                            
                            var w = mstrmojo.all[id];
                            
                            if (w && w.update) {
                                w.update(dc[id]);
                            }
                        });
                    }
                });
            },

            
            addAutoWidthID: function addAutoWidthID (id) {
                var aws = this.aws || {},
                    units = aws[this.currlaykey] || [];

                
                units.push(id);

                
                aws[this.currlaykey] = units;

                
                this.aws = aws;
            },

            
            getAutoWidthIDs: function getAutoWidthIDs() {
                var aws = this.aws,
                    l = this.currlaykey;

                
                var ids = aws && aws[l];
                if (ids) {
                    
                    delete aws[l];
                }

                return ids;
            }
        }
    );
})();

(function(){

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.array",
                         "mstrmojo.StringBuffer",
                         "mstrmojo.ResSetLink");
    
    var ROW_AXIS = 1,
        COL_AXIS = 2;
    
    var ATTRIBUTE_SORT = 2,
        COLUMN_SORT = 4;
    
    var DRILLING_ACTION = 1,
        HYPERLINK_ACTION = 4;
    
    
    
    function getTitlesAxis(gts, ax) {
        return gts[((ax === ROW_AXIS) ? 'row' : 'col')];
    }
    
    function getCellLinksContainer(cell, title) {
        var linkMap = title.lm;
        
        
        return linkMap && linkMap[cell.mix || 0];
    }
    
    function getCellDrillsContainer(cell, title) {
        var drillList = title.dp;
        
        return drillList && drillList[cell.mix || 0];
    }
    
    
    function buildLink(linksContainer, linkInfo, cell) {
        var link = new mstrmojo.ResSetLink({
            mid: this.getMessageId(),
            srct: 2,
            aopam: linkInfo.daMode
        });          
        
        var answers = linkInfo.ans,
            answerCnt = answers && answers.length;
          
        if (answerCnt) {
            
            
            var prms = link.prms = [],
                i = 0;

            for (i = 0; i < answerCnt; i++) {
                var answer = answers[i];
                  
                
                var pid = answer.pid,
                    am = parseInt(answer.m, 10),
                    prm = {
                        id: pid,
                        am: am,
                        
                    	pt: answer.pt
                    };
                prms.push(prm); 
                if (answer.po) {
                    prm.orid = answer.po.did;
                    prm.ortp = answer.po.t;
                }
                  
      
                
                switch (am) {
                    case link.DO_NOT_ANSWER:
                    case link.CLOSE:
                    case link.USE_DEFAULT_ANSWER:
                    case link.SAME_PROMPT:
                        break;
                          
                    case link.STATIC:
                        var statElems = answer.es,
                        staticLen = (statElems && statElems.length) || 0,
                        z;

                        prm.pa = {
                            es:[]        
                        };
                    for (z = staticLen - 1; z >= 0; --z) {
                            var statElem = statElems[z];
                            prm.pa.es.push({
                                ei: statElem.id,
                                disp_n: statElem.n,
                                emt: 1
                            });
                        }
                          
                        break;
                          
                    case link.DYNAMIC:
                    case link.ALL_VALID_UNITS:
                    case link.CURRENT_UNIT:
                        var dynUnits = answer.dunits;       
                        if (dynUnits && dynUnits.length && cell) {
                            var pa = prm.pa = {};

                            
                            var pCell = cell,
                                
                                isMetricValue = (cell.mix !== undefined) && (cell._lp || cell._tp);
                                  
                                
                                if (isMetricValue) {
                                    
                                    
                                    pCell = cell._lp || cell._tp;
                                }
                                  
                        var axis = parseInt(pCell.axis, 10);
                                while (pCell) {
                                    
                                	  var pTitle = this.getPTitle(pCell, axis); 

                                    
                                    if (pTitle && mstrmojo.array.find(dynUnits, 'id', pTitle.id) >= 0) {
                                    if (am !== link.DYNAMIC) {
                                        pa.a = {
                                            id: pTitle.id,
                                            n: pTitle.n,
                                            dispForms: pTitle.dfi
                                        };
                                    }
                                    if ( answer.pt === 1 ) {
                                        
                                    	pa.v = pCell.v;
                                    	break;
                                    } else {
                                        
                                        var eid = pCell._e.id,
                                            dsn = pCell._e.n; 
                                        
                                        pa.es = [];
                                        pa.es.push({
                                            ei: eid,
                                            emt: 1,
                                            disp_n: dsn 
                                        });
                                    }
                                    
                                    if (am === link.CURRENT_UNIT) {
                                            break;
                                        }
                                    }

                                    
                                   pCell = this.getPCellParentNode(pCell, axis);
                                    
                                    
                                    if (isMetricValue && !pCell && axis === ROW_AXIS) {
                                        
                                        axis = COL_AXIS;
                                          
                                        
                                        pCell = cell._tp;
                                    }
                                }
                        }
                        break;
                }
            }
        }
        return link;
    }
        
    
    function getDrillElements(cells) {
        var titleInfo = this.getCellTitleInfo(cells[0]),
            elements = [],
            fnAddCell= function (cell) {
                if (cell) {
                    if ( mstrApp.useBinaryFormat ) {
                    	if ( cell._e ) {
	                        elements.push(cell.axis + 'A' + (cell.ui + 1) + 'A' + cell._e.id);
                    	}
                        fnAddCell(cell._p);
                    } else {
                        elements.push(cell.axis + 'A' + (cell.ui + 1) + 'A' + cell.o);
                    }
                }
            },
            i,
            len;
        
        if (!titleInfo.isSrcTitle) {            
            for (i = 0, len = cells.length; i < len; i++) {
                var c = cells[i];            
                
                if (c.mix !== undefined && (c._lp || c._tp)) {
                    fnAddCell(c._lp);
                    fnAddCell(c._tp);
                } else {
                    fnAddCell(c);
                }
            }
        }

        return (mstrApp.useBinaryFormat) ? elements : elements.join(',');
    }
    
    
    mstrmojo.XtabModel = mstrmojo.declare(
        mstrmojo.Obj,
        
        null,
        
        
        {            
            scriptClass: "mstrmojo.XtabModel",
            
            getMessageId: function getMessageId() {
                return this.data.mid;
            },
            
            
            getCellTitleInfo: function getCellTitleInfo(cell, dataBlock) {
                var gts = dataBlock ? dataBlock.gts : this.data.gts;
                
                
                
                
                
                var title = null;
                
                
                if (cell.mix === undefined) {
                    title = getTitlesAxis(gts, cell.axis)[cell.tui || cell.ui];
                    
                } else {
                    
                    
                    var findMetricTitle = function(titles) {
                        var len = (titles && titles.length) || 0,
                            i;

                        for (i = len - 1; i >= 0; --i) {
                            if (parseInt(titles[i].otp, 10) === -1) {
                                
                                return titles[i];
                            }
                        }
                        
                        
                        return null;
                    };
                    
                    
                    title = findMetricTitle(gts.col) || findMetricTitle(gts.row); 
                }
                
                return {
                    isSrcTitle: (cell.o === undefined), 
                    title: title
                };            
            },
            
            
            getCellLinksInfo: function getCellLinksInfo(cell, title) {
                if (!title) {
                    var titleInfo = this.getCellTitleInfo(cell);
                    title = titleInfo && titleInfo.title;
                }
                
                return getCellLinksContainer(cell, title);
            },

            
            getCellDrillsInfo: function getCellDrillsInfo(cell, title) {
                if (!title) {
                    var titleInfo = this.getCellTitleInfo(cell);
                    title = titleInfo && titleInfo.title;
                }
                return getCellDrillsContainer(cell, title);
            },
            
            getLinkDrillAction: function getLinkDrillAction(cells) {
                return this.getActionObject(cells);
            },

            getAction: function getAction(cells) {
                return this.getActionObject(cells);
            },

            getActionObject: function getActionObject(cells) {
                var actionType = cells[0] && cells[0].at,
                    _rtn = null;

                
                if (actionType) {
                    
                    if (actionType & HYPERLINK_ACTION) {
                        _rtn = {
                            h: 'onLink',
                            a: this.getLinkAction(cells[0])
                        };
                        
                    
                    } else if (actionType & DRILLING_ACTION) {
                        _rtn = {
                            h: 'onDrill',
                            a: this.getDrillAction(cells)
                        };
                    }
                }
                
                return _rtn;
            },
            
            
            getSortAction: function getSortAction(cell, isAsc) {
                var titleInfo = this.getCellTitleInfo(cell),
                    title = titleInfo.title,
                    subTotalsPos = this.data.gts[((cell.axis === ROW_AXIS) ? 'row' : 'col') + 'SubPos'],
                    elems = [],
                    unitAxis = title.axis,
                    sortType,
                    unitID,
                    unitType,
                    formId;
                
                
                isAsc = (isAsc === null || isAsc === undefined) ? !(cell && cell.so) : isAsc;
                
                
                if (titleInfo.isSrcTitle) {
                    sortType = ATTRIBUTE_SORT;
                    unitID = title.id;
                    unitType = title.otp;
                    formId = title.fid;
                    
                } else {
                    
                    sortType = COLUMN_SORT;
                    unitType = 4;
                    unitAxis = ROW_AXIS;
                    subTotalsPos = this.data.gts.rowSubPos;
                    
                    
                    
                    do {
                        
                        var e = cell._e;
                        if (e) {
                        
                        if (e.oid) {
                            unitID = e.oid;
                            
                        } else {
                            
                            elems.push(e.id);
                            
                        }                
                        }
                        
                        
                        cell = cell._p;
                        
                    } while (cell);
                }
                
                
                var action = {
                    sortType: sortType,
                    axis: unitAxis, 
                    isAsc: isAsc, 
                    unitID: unitID, 
                    unitType: unitType, 
                    elementList: elems.join('\u001E'), 
                    subTotalsPos: subTotalsPos
                };
                
                
                if (unitID) {
                    
                    action.unitID = unitID;
                }

                
                if (formId) {
                    
                    action.formId = formId;
                }
                
                
                var sortKey;
                if (sortType === COLUMN_SORT) {
                    sortKey = [ '', '', action.elementList || '', action.axis ];
                } else {
                    sortKey = [ action.formId, '21' ];
                }
                sortKey = [ action.unitType, action.unitID ].concat(sortKey);
                action.sortKey = sortKey.join('!');
                
                
                return action;

            },
            
            
            getPivotAction: function getPivotAction(cell, btn) {
                var isForm = false,                                
                    isMetric = cell.hasOwnProperty('mix'),         
                    ax = (isMetric) ? null : cell.axis,            
                    pos = ((isMetric) ? cell.mix : cell.ui) + 1,   
                    isMT = (cell.otp === -1);                      
                
                
                if (!isNaN(btn)) {
                    ax = btn;           
                    pos = 1;            
                    
                    
                    if (isMetric) {
                        isMetric = false;   
                        isMT = true;        
                    }
                    
                } else {
                    
                    var dec = (btn === 'u' || btn === 'l');
    
                    
                    if (!isMetric) {
                        
                        var axis = getTitlesAxis(this.data.gts, ax),        
                            cnt = 0,                                        
                            info = {},                                      
                            bCur = false;                                   
                        
                        
                        mstrmojo.array.forEach(axis, function (u) {
                            
                            if (info[u.id]) {
                                
                                info[u.id].frm++;
                                
                            } else {
                                
                                cnt++;
                                
                                
                                info[u.id] = {
                                    pos: cnt,
                                    frm: 1
                                };
                                
                                
                                if (u.id === cell.id) {
                                    
                                    bCur = true;
                                } else if (bCur) {
                                    
                                    return false;
                                }
                            }
                            
                        });
                        
                        
                        pos = info[cell.id].pos;
    
                        
                        var fix = cell.fix;
                        if (fix) {
                            
                            
                            if (!dec || fix > 1) {
                                
                                if (dec || fix !== info[cell.id].frm) {
                                    
                                    pos = fix;
                                    
                                    
                                    isForm = true;
                                }
                            }
                        }
                    }
                    
                    
                    pos = pos + ((dec) ? -1 : 1);
                }
                
                
                var action = {
                    pos: pos        
                };
                
                
                if (isForm) {
                    
                    action.formID = cell.fid;
    
                } else if (!isMetric) {
                    
                    action.axis = ax;
                }
                
                
                if (!isMT) {
                    
                    var mSrc = (isMetric) ? cell._e : cell;
                    
                    
                    if (!isForm) {
                        action.objectType = mSrc.otp;
                    }
                    
                    
                    action.objectId = (isMetric) ? mSrc.oid : cell.id;
                }
                
                return action;
            },
            
            
            isPvtButtonVisible: function isPvtButonVisible(c, btn) {
                var ax = c.axis,                                         
                    axis = getTitlesAxis(this.data.gts, ax),             
                    isMetric = c.hasOwnProperty('mix');
                
                
                if (!isNaN(btn)) {
                    
                    if (parseInt(btn, 10) === ax) {
                        return false;
                    }
                    
                    
                    if (isMetric) {
                        
                        return !!axis[c.ui]._hid;
                    }
                    
                    
                    return true;
                }
    
                var es = axis[c.ui].es,                           
                    pos = c.ui,                                   
                    len = (isMetric) ? es.length : axis.length;   
                    
                
                if (len === 1) {
                    
                    return false;
                }
                        
                
                if (ax === ((isMetric) ? COL_AXIS : ROW_AXIS)) {
                    
                    if (btn === 'u' || btn === 'd') {
                        return false;
                    }
                } else {
                    
                    if (btn === 'l' || btn === 'r') {
                        return false;
                    }
                }
                
                
                if ((isMetric) ? c._e === es[0] : pos === 0) {
                    
                    if (btn === 'l' || btn === 'u') {
                        return false;
                    }
                }
                    
                
                if (isMetric ? c._e === es[len - 1] : pos === len - 1) {
                    
                    if (btn === 'r' || btn === 'd') {
                        return false;
                    }
                }
                
                
                return true;
            },
            
            
            getDrillAction: function getDrillAction(cells) {
                var titleInfo = this.getCellTitleInfo(cells[0]),
                    title = titleInfo.title,
                    drillPath = title.dp[cells[0].mix || 0];
                
                return {
                    srcMsgId: this.data.mid,
                    isWithin: drillPath.within,
                    drillPathKey: drillPath.k,
                    drillPathIndex: drillPath.dpi,
                    drillElements: getDrillElements.call(this, cells)
                };
            },
            
            getPTitle: function getPTitle(pCell, axis){
            	var gts = this.data.gts;
           		return getTitlesAxis(gts, axis)[pCell.tui];
            },
            
            getPCellParentNode: function getPCellParentNode(pCell, axis){
            	 
            	return pCell._p;
            },
                        
            
            getLinkAction: function getLinkAction(cell, idx) {
                var titleInfo = this.getCellTitleInfo(cell),
                    title = titleInfo.title;                
                return this.getLinkActionImpl(cell, title, idx);
            },
            
            getLinkActionImpl: function getLinkActionImpl(cell, title, idx) {
                var linksContainer = getCellLinksContainer(cell, title),    
                    linkArray = linksContainer && linksContainer.links,
                    linkTarget = (linksContainer.onw) ? '_blank' : '';
                
                
                if (idx === null || idx === undefined) {
                    
                    idx = (linksContainer && linksContainer.di) || 0;    
                }
                
                
                var linkInfo = linkArray && linkArray[idx];           
                if (!linkInfo) {
                    
                    return null;
                }
                
                
                var action = {
                    linkInfo: linkInfo,
                    linkTarget: linkTarget
                };
                
                
                var url = linkInfo.url;
                if (url) {
                    
                    var currentElement = '&CurrentElement';
                    if (cell && title && url.indexOf(currentElement) > -1) {
                        url = url.replace(currentElement, cell._e.id);
                    }

                    
                    action.url = url;

                } else {
                    
                    var target = linkInfo.target,
                        evt,
                        idField;
                    
                    
                    switch (parseInt(target && target.t, 10)) {
                        case 55:                
                            
                            if (parseInt(target.st, 10) === 14081) { 
                                
                                evt = 2048001;   
                                idField = 'objectID';

                            } else {
                                
                                evt = 32001;   
                                idField = 'documentID';
                            }
                            break;
                            
                        case 3:                 
                            
                            evt = 4001;         
                            idField = 'reportID';
                            
                            
                        action.reportViewMode = ((parseInt(target.st, 10) === 0x301) ? 2 : 1);
                            break;
                            
                        default: 
                            
                            return null;
                    }
                    
                    
                    action.evt = evt;
                    action[idField] = target.did;
                    action.srcMsgId = this.getMessageId();
                    
                    
                    var link = buildLink.call(this, linksContainer, linkInfo, cell);
                    if (link) {
                        action.link = link;
                    }
                    
                    
                    
                    
                    
                    return action;
                }
            },
            
            
            getDownloadAction: function getDownloadAction(rowPosition, maxRows,  colPosition, maxCols, widgetID, memo) {
                return {
                    xtabId: widgetID,
                    rowPosition: rowPosition,
                    maxRows: maxRows,
                    colPosition: colPosition,
                    maxColumns: maxCols,
                    memo: memo
                };
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.prompt.WebPrompt", 
                         "mstrmojo.locales",
                         "mstrmojo.num", 
                         "mstrmojo.date",
                         "mstrmojo.mstr.EnumDataType");
                         
	mstrmojo.requiresDescs(8398,8399,8400,8401,8402,8403,8404,8405,8406);
    
    var promptStyles = mstrmojo.prompt.WebPrompt.STYLES,
        _DT = function(){return mstrmojo.locales.datetime;},
        $DT = mstrmojo.mstr.EnumDataType,
        $NUM = mstrmojo.num,
        $DATE = mstrmojo.date,
        $M = Math;
    
    
    function inRange(v) {
        var min = parseFloat(this.min, 10),
            max = parseFloat(this.max, 10),
            hasMin = !isNaN(min),
            hasMax = !isNaN(max);
        if (hasMin && v < min) {
            return -1;
        } else if (hasMax && v > max) {
            return 1;
        } else {
            return 0;
        }
    }
    
    
    var validateFns = {};
    
    validateFns[$DT.DataTypeBool] = function (ans) {
        if ("0" !== ans || "1" !== ans) {
            throw new Error(mstrmojo.desc(8398, 'Invalid answer: #. Boolean values required.').replace('#', ans));
        }
    };
    
    validateFns[$DT.DataTypeBigDecimal] = 
        validateFns[$DT.DataTypeLong] =
        validateFns[$DT.DataTypeDouble] = 
        validateFns[$DT.DataTypeDecimal] =
        validateFns[$DT.DataTypeReal] =
        validateFns[$DT.DataTypeInteger] = 
        validateFns[$DT.DataTypeFloat] =
        validateFns[$DT.DataTypeNumeric] = function (ans) {
            
    	    
            if (!isNaN(ans)) {
                var num = parseFloat(ans, 10);
                switch (inRange.call(this, num)) {
                case -1: 
                    throw new Error(mstrmojo.desc(8399, 'Invalid answer: #. Answer is smaller than the minimum limit: ##.').replace('##', this.min).replace('#', $NUM.toLocaleString(ans)));
                
                case 1:  
                    throw new Error(mstrmojo.desc(8400, 'Invalid answer: #. Answer is bigger than the maximum limit: ##.').replace('##', this.max).replace('#', $NUM.toLocaleString(ans)));
                }
            } else if (ans) { 
                throw new Error(mstrmojo.desc(8401, 'Not a number'));
            }
        };

    validateFns[$DT.DataTypeChar] = function (ans) {
        
        if ( ans ) {
            switch (inRange.call(this, (ans && ans.length) || 0)) {
            case -1: 
                throw new Error(mstrmojo.desc(8402, 'Invalid answer: #. The length of the answer is smaller than the minimum limit: ##.').replace('##', this.min).replace('#', ans));
            
            case 1:  
                throw new Error(mstrmojo.desc(8403, 'Invalid answer: #. The length of the answer is bigger than the maximum limit: ##.').replace('##', this.max).replace('#', ans));
            }
        }
    };
    
    validateFns[$DT.DataTypeDate] = function (ans) {
        switch (mstrmojo.date.inDateTimeRange(ans, this.min, this.max)) {
        case -1: 
            throw new Error(mstrmojo.desc(8404, 'Invalid answer: #. The date/time is earlier than the earliest limit: ##.').replace('##', this.min).replace('#', ans));
        
        case 1:  
            throw new Error(mstrmojo.desc(8405, 'Invalid answer: #. The date/time is later than the latest limit: ##.').replace('##', this.max).replace('#', ans));
        }
    };
    
    
    function getNumberOfDecimals(myNumber){

        myNumber = String(myNumber);
        var pointIndex = myNumber.indexOf('.');

        return (pointIndex == -1) ? 0 : myNumber.length - pointIndex - 1;
    }    
    
    
    function canStep(isUp) {
        
        var interval = this.prs.Interval || 1;
        
        if (!isUp) {
            interval = -interval;
        }
        
        var displayValue = parseFloat(this.getDisplayValue(true, true),10),
            intervalValue = parseFloat(interval, 10),
            multFactor = $M.pow(10, $M.max(getNumberOfDecimals(displayValue), getNumberOfDecimals(intervalValue)));
        
        
        
        var v = parseInt(($M.round(displayValue*multFactor) + $M.round(intervalValue*multFactor)), 10) / multFactor,
            status = {
                v: v,
                s: true         
            };
        
        
        try {
            this.validate(v);
        } catch (ex) {
            
            
            status.s = false;
        }
        
        return status;
    }
    
    
    function step(isUp) {
        
        var status = canStep.call(this, isUp);
        
        
        if (status.s) {
            
            this.answer = String(status.v);
        }
    }
    
    
    mstrmojo.prompt.WebConstantPrompt = mstrmojo.declare(
        mstrmojo.prompt.WebPrompt,
        
        null,
        
        
        {
            scriptClass: 'mstrmojo.prompt.WebConstantPrompt',
            
            
            answer: '',
            
            
            preAnswer: '',
            
            
            defAnswer: '',
            
            
            dataType: 8, 
            
            
            isNumericDataType: function isNumericDataType() {
            	switch(this.dataType) {
            	case $DT.DataTypeInteger:
            	case $DT.DataTypeUnsigned:
            	case $DT.DataTypeNumeric:
            	case $DT.DataTypeDecimal:
            	case $DT.DataTypeReal:
            	case $DT.DataTypeDouble:
            	case $DT.DataTypeFloat:
            	case $DT.DataTypeShort:
            	case $DT.DataTypeLong:
                case $DT.DataTypeBigDecimal:
            		return true;
            	default:
            		return false;
            	}
            },
            
            getStyle: function getStyle() {
                
                
                var style = this._style;
                if (!this._style) {
                    
                    var promptProperties = this.prs;
                    switch (promptProperties.DisplayStyle) {
                    case 'Stepper':
                        style = promptStyles.STEPPER;
                        break;
                        
                    case 'Switch':
                        style = promptStyles.SWITCH;
                        break;
                        
                    case 'Slider':
                        style = promptStyles.SLIDER;
                        break;
                        
                    case 'Text box':
                        
                        if (this.dataType === 14) {
                            
                            style = promptStyles[(promptProperties.ShowTime === "-1") ? 'TIME' : 'CALENDAR'];
                            break;
                        }
                        
                        
                        style = promptStyles.TEXT;
                        break;
                        
                    case 'Barcode':
                        style = promptStyles.BARCODE;
                        break;
                    }

                    
                    if (!style) {
                        throw new Error(mstrmojo.desc(8406, 'WebConstantPrompt::getStyle - Unknown prompt style.'));
                    }
                    
                    
                    this._style = style;
                }
                
                return style;
                
            },
            
            getDisplayValue: function getDisplayValue(calculateDefault, replaceAnswerWithDefault) {
                
                var displayValue = this.answer || this.defAnswer,
                    isEmpty = (displayValue === undefined || displayValue === null),
                    style = this.getStyle();
                
                switch (style) {
                case promptStyles.STEPPER:
                    
                    if (calculateDefault && (isEmpty || (this.dataType === 6 && isNaN(parseFloat(displayValue, 10))))) {
                        
                        var min = parseFloat(this.min, 10),
                            max = parseFloat(this.max, 10);
                            
                        if (isNaN(min) || isNaN(max)) {
                            displayValue = 0;
                        } else {
                            
                            if (0 > min && max > 0) {
                                
                                displayValue = 0;
                                
                            } else {
                                
                                displayValue = (Math.abs(min - 0) > Math.abs(max - 0)) ? max : min;
                                
                            }
                        }
                        
                        
                        if (replaceAnswerWithDefault) {
                            
                            this.setAnswerValue(String(displayValue));
                        }
                    }

                    break;
                    
                case promptStyles.SWITCH:
                    var prs = this.prs,
                        onValue = prs.OnValue,
                        offValue = prs.OffValue;
                    
                    
                    if (calculateDefault && (displayValue !== onValue && displayValue !== offValue)) {
                        
                        displayValue = offValue;

                        
                        if (replaceAnswerWithDefault) {
                            
                            
                            this.answer = offValue;
                        }
                    }
                    
                    
                    displayValue = (displayValue === onValue);
                    break;
                    
                case promptStyles.SLIDER:
                    
                    if (calculateDefault && (isEmpty || displayValue === '')) {
                        
                        displayValue = this.min;
                        
                        
                        if (replaceAnswerWithDefault) {
                            
                            this.setAnswerValue(String(displayValue));
                        }
                    }
                    break;
                }
                
                return (style == promptStyles.SWITCH) ? displayValue : 
                                                        this.isNumericDataType()? mstrmojo.num.toLocaleString(String(displayValue)) : displayValue;            
            },                
            
            
            validate: function validate(v) {
                v = (v === undefined || v === null) ? this.answer : v;
                this._super(v);
                this._validateFn(v);
            },
            
            
            isAnswerEmpty: function isAnswerEmpty(v) {                
                v = (v === undefined || v === null) ? this.answer : v; 
                return (v === undefined || v === null || v === '');
            },

            
            populate: function populate(props) {
                this.answer = props && props.ans && props.ans.text;
                this.dataType = props && props.datatp;
                
                this._validateFn = validateFns[this.dataType];
                
                this._super(props);

                var prs = this.prs;
                
                
                
                if (prs.DisplayStyle === 'Wheel') {
                    prs.DisplayStyle = 'Stepper';
                }
                
                switch (prs.DisplayStyle) {
                case 'Switch':
                	
                	if (prs.OnValue === undefined || prs.OnValue === null) {
                		prs.OnValue = '1';
                	}
                	if (prs.OffValue === undefined || prs.OffValue === null) {
                		prs.OffValue = '0';
                	}
                	break;
                case 'Slider':
                case 'Stepper':
                    this.interval = parseFloat(this.prs.Interval) || 1;
                    this.min = $NUM.parseNumeric(this.min);
                    this.max = $NUM.parseNumeric(this.max);  
                    
                    if (!this.min) {
                        this.min = 0; 
                    }
                    
                    if (this.answer === undefined || this.answer === null || this.answer < this.min) { 
                    	this.answer = this.min;
                    }
                    if (this.answer > this.max) {
                    	this.answer = this.max;
                    }
                    break;
                case 'Text box':
                    
                    if (this.dataType === 14 && prs.ShowTime === "-1") {
                        this.interval = parseFloat(this.prs.Interval) || 1; 
                        
                        var answer = $DATE.parseDateAndOrTime((this.answer || ''));
                        var min = $DATE.parseDateAndOrTime((this.min || ''));
                        var max = $DATE.parseDateAndOrTime((this.max || ''));
                        
                        defaultTimeInfo = {
                                match: "12:00:00 AM",
                                hour: 0,
                                min: 0,
                                sec: 0
                            };
                        
                        var defaultTime = $DATE.formatTimeInfo(defaultTimeInfo, _DT().TIMEOUTPUTFORMAT);
                        if(answer && !answer.time) {
                            this.answer = this.answer + ' ' + defaultTime;
                        }
                        
                        if(min && !min.time) {
                            this.min = this.min + ' ' + defaultTime;
                        }
                         
                        if(max && !max.time) {
                            this.max = this.max + ' ' + defaultTime;
                        }
                    }
                    break;
                }

            },
            
            populateAnswer: function populateAnswer(answer) {
            	
            	if (answer && answer.text) {
            		this.answer = answer.text;
            	}                
            },
            
            buildAnswerObject: function buildAnswerObject() {
                var ob = this._super();
                ob.ans = {
                    text: this.answer
                };
                
                return ob;
            },
            
            setAnswerValue: function setAnswerValue(v) {
            	if(this.isNumericDataType()) {
            		v = mstrmojo.num.toString(v, false);
            	}
            	
                this.validate(v);
                this.answer = v;
            },
            
            
            getAnswerXML: function getAnswerXML() {
                return this.answer;
            },
            
            
            buildShortAnswerXML: function buildShortAnswerXML(builder) {
            builder.addText(this.isNumericDataType()?mstrmojo.num.toLocaleString(this.answer || ""): (this.answer || "")); 
            },
            
            
            stepUp: function stepUp() {
                if (this.getStyle() === promptStyles.STEPPER) {
                    step.call(this, true);
                }
            },
            
            
            canStepUp: function canStepUp() {
                return (this.getStyle() === promptStyles.STEPPER && canStep.call(this, true).s);
            },
            
            
            stepDown: function stepDown() {
                if (this.getStyle() === promptStyles.STEPPER) {
                    step.call(this, false);
                }
            },

            
            canStepDown: function canStepDown() {
                return (this.getStyle() === promptStyles.STEPPER && canStep.call(this, false).s);
            },
            
            
            toggleSwitch: function toggleSwitch() {
                if (this.getStyle() === promptStyles.SWITCH) {
                    
                    var promptProperties = this.prs,
                        answer = (this.getDisplayValue(true, false)) ? promptProperties.OffValue : promptProperties.OnValue;
        
                    
                    this.set('answer', answer);
                }
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.prompt.WebPrompt");
    
    
    mstrmojo.prompt.WebUnsupportedPrompt = mstrmojo.declare(
        mstrmojo.prompt.WebPrompt,
        
        null,
        
        
        {
            scriptClass: 'mstrmojo.prompt.WebUnsupportedPrompt',
            
            
            answerXml: '',
            
            
            populate: function populate(props) {
                this._super(props);
                if ( props.ans && props.ans.xml) {
                	this.answerXml = props.ans.xml;
                }
            },
            
            
            getAnswerXML: function getAnswerXML() {
                return this.answerXml;
            },
            
            
            buildShortPa: function buildShortPa(builder) {
        		builder.addRawXML(this.answerXml);
            },
            
            buildAnswerObject: function buildAnswerObject() {
                var ob =  this._super();
                if ( this.answerXml ) {
	                ob.ans = {
	                    xml: this.answerXml
	                };
                }
                return ob;
            },
            
            supported: function supported() {
            	return false;
            }
        }
    );
}());

(function() {
    mstrmojo.requiresCls("mstrmojo.prompt.WebPrompt",
                         "mstrmojo.array");
    
    var $ARR = mstrmojo.array;
    
    
    mstrmojo.prompt.WebGeoConstantPrompt = mstrmojo.declare(

        mstrmojo.prompt.WebPrompt,

        null,

        
        {
            scriptClass: 'mstrmojo.prompt.WebGeoConstantPrompt',
            
            
            promptType: 1.5,
            
            
            geos: null,
			getStyle: function getStyle() {
				return mstrmojo.prompt.WebPrompt.STYLES.GEO;
			},            
            getDisplayValue: function getDisplayValue() {
                var err = this._isErr;
                if (err) {
                    return 'Error while updating location: ' + err;
                }
                
                
                var me = this,
                    rtn = '';
                
                
                $ARR.forEach(this.geos, function (prompt) {
                    var ans = prompt.answer;
                    
                    
                    if (ans === '') {
                        
                        rtn = '&lt;Update Current Location&gt;';
                        return false;
                    } else {
                    	var geoCoord = prompt.prs["GeographicCoordinate"];
                    	if (typeof(geoCoord) == 'undefined' || geoCoord != "1"){
                            me.la = ans;
                        } else {
                            me.lo = ans;
                        }
                    }
                }); 
                
                if ( me.displayLoc ) {

                    rtn = me.displayLoc;
                    
                } else {
                    me.mn = "Searching...";
                    if (typeof(me.la) == 'undefined') {
                		me.la = '';
                	}
                	if (typeof(me.lo) == 'undefined') {
                		me.lo = '';
                	}
                    if (!( me.la == '' && me.lo == '' )) {
    			        
                    	
    			        rtn = '(' + me.la + ',' + me.lo + ')';
			        }
                }
                
                return rtn;
            },
            
            getDisplayLocation: function(list) {
                var me = this,
                    la = this.la,
                    lo = this.lo;
                
                
                if ( la != '' && lo != '' ) {                    
                    
					mstrmojo.GeoLocation.findAddress(
						{lat: la, lng: lo}, 
						{
							success: function(results) {
							    me.mn = ''
							    me.displayLoc = results[0].formatted_address;
							    list.updateItem(me._renderIdx);
							},
							failure: function(results, status) {
							    me.mn = '';
							}
						}
					);
                }
                
            },
            
            
            validate: function validate(latitude, longitude) {
                
                return true;
            },
            
            
            buildShortPa: function buildShortPa(builder) {
                
                $ARR.forEach(this.geos, function(g) {
                    g.buildShortPa(builder);
                });
            },
            
            add: function add(p){
                var g = this.geos = this.geos || []; 
                g.push(p);
            },
            
            setAnswerValue: function setAnswerValue(latitude, longitude) {
                try {
                    delete this.displayLoc;
                    
                    this.validate(latitude, longitude);
                    this.setLocation(latitude, longitude);
                } catch (ex) {
                    
                    
                    this.setError(ex);
                    
                    return false;
                }
                
                return true;
            },
            
            setError: function setError(v) {
                this._isErr = v;
            },
            
            setLocation: function setLocation(latitude, longitude) {
                
                $ARR.forEach(this.geos, function (prompt) {
                    
                    switch ((prompt.prs && prompt.prs.GeographicCoordinate) || '0') {
                        case '0':
                            
                            prompt.set('answer', String(latitude));
                            break;
                            
                        case '1':
                            
                            prompt.set('answer', String(longitude));
                            break;
                    }
                });
            }
        });
}());

(function() {
    mstrmojo.requiresCls(
            "mstrmojo.mstr.WebOI"
    );
	mstrmojo.mstr.WebFilter = mstrmojo.declare(
			
			mstrmojo.mstr.WebOI,
			
			null,
			
			{
				scriptClass: 'mstrmojo.mstr.WebFilter',
				t: 1,
				
				expression: null,
				buildTypeSpecificShortXML: function buildTypeSpecificShortXML(builder) {
					if (this.expression) {
						this.expression.buildShortXML(builder);
					}
				}
			}
		);
	
})();

(function() {
    mstrmojo.requiresCls(
            "mstrmojo.mstr.WebOI"
    );
	mstrmojo.mstr.WebAttributeForm = mstrmojo.declare(
			
			mstrmojo.mstr.WebOI,
			
			null,
			
			{
				scriptClass: 'mstrmojo.mstr.WebAttributeForm',
				t: 21
			}
		);
	
})();

(function() {
    mstrmojo.requiresCls(
            "mstrmojo.mstr.WebOI",
            "mstrmojo.mstr.WebElements"
    );

	mstrmojo.mstr.WebAttribute = mstrmojo.declare(
			mstrmojo.mstr.WebOI,
			null,
			{
				scriptClass: 'mstrmojo.mstr.WebAttribute',
				t: 12,
				
				elemTotalSize: 0,
				
				browseConfig: null,
				init: function(props) {
					
					var bc = this.browseConfig = {};
					if (props) {
						if(props.bb) {
							bc.blockBegin = props.bb;
							delete props.bb;
						}
						if (props.bc) {
							bc.blockCount = props.bc
							delete props.bc;
						}
						
						if (props.sz) {
							this.totalSize = props.sz;
							delete props.sz;
						}
					}
					
					this.browseConfig = {};
					
					
					if (this._super) {
						this._super(props);
					}
				},
				
				getElements: function(config){
					config = mstrmojo.hash.copy((this.browseConfig ||{}), (config || {}));
					
					return new mstrmojo.mstr.WebElements({
                    	source: this, 
                    	totalSize: this.totalSize || 0,
                    	browseConfig: config
                    });
				}
			}
			);
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom","mstrmojo.TouchScroller");
    
    var $D = mstrmojo.dom,
    	$M = Math;
    
    function constrainPoint(value, offset) {
        return (offset) ? $M.max($M.min($M.round(value), offset.end), offset.start) : value;
    }

    
    mstrmojo._NeedSyncScroller = mstrmojo.provide(

        "mstrmojo._NeedSyncScroller",

        
        {
           init: function init(props){
	    	   if(this._super){
	    		   this._super(props);
	    	   }
	    	   
	        	 if(!this.lisenters){
	        		 this.lisenters = [];
	        	 }  
        	 
           },

           initScroller : function initScroller(scroller) {
        	   if(this._super){
        		   this._super(scroller);
        	   }
        	   
				
				this._scrollMovedListener = this._scroller.attachEventListener('scrollMoved', this.id, function (evt) {
					this.onScrollMoved(evt);
				});
				
				
				this._scrollDoneListener = this._scroller.attachEventListener('scrollDone', this.id, function (evt) {
					this.onScrollDone(evt);
				});
           },
           
           onScrollMoved: function onScrollMoved(evt){
        	   if(this._super){
        		   this._super(evt);
        	   }
        	   this.syncScroller(evt, true);
           },
           
           onScrollDone: function onScrollDone(evt){
        	   if(this._super){
        		   this._super(evt);
        	   }
        	   
        	   this.syncScroller(evt, false);
        	   
        	   
           },
           
           syncScroller: function sScroller(evt, showScrollBar){
        	   if(!evt || evt.x == undefined || evt.y == undefined){
        		   return;
        	   }
        	   var lisenters = this.lisenters,
        	   		lisCount = this.lisenters.length;
        	   for(var i = 0 ; i < lisCount; i++ ){
        		   var scroller = lisenters[i]._scroller,
        		   		offset = scroller.offset;
      				
      				
        		   scroller.origin = {
       					x : scroller.hScroll ? evt.x : 0,
       					y : scroller.vScroll ? evt.y : 0
       				};
        		   $D.translate(scroller.scrollEl, -scroller.origin.x, -scroller.origin.y, 0, scroller.transform, scroller.useTranslate3d);
        		   
        		   scroller.toggleScrollBars(showScrollBar);
        		   mstrmojo.hash.forEach(scroller._scrollBarEls, function (bar, axis) {
        	            var isX = (axis === 'x'),
        	                position = evt[axis],
        	                length = bar.length,
        	                ratio = bar.ratio,
        	                viewportSize = bar.viewportSize,
        	                minScale = 6 / length,
        	                minPosition = bar['base' + ((isX) ? 'Left' : 'Top')],
        	                maxPosition = minPosition + viewportSize - length,
        	                newPosition = $M.round(minPosition + (ratio * position));

        	            
        	            if (newPosition < minPosition) {
        	                newPosition = minPosition - position;
        	                length += position;
        	            } else if (newPosition > maxPosition) {
        	                var delta = (position - scroller.offset[axis].end) * ratio;
        	                newPosition = $M.min(maxPosition + delta, viewportSize + minPosition - 6) - 1;
        	                length -= delta;
        	            }

        	            
        	            var v = 0,
        	                translate = [v, v, v],
        	                scale = [1, 1, 1],
        	                idx = (isX) ? 0 : 1;

        	            translate[idx] = (newPosition - minPosition);
        	            scale[idx] = $M.min($M.max(length / bar.length, minScale), 1);

        	            $D.translate(bar, translate[0], translate[1], translate[2], ' scale3d(' + scale.join(',') + ')');
        	        });
        		   
        	   }
           },
           
           addSyncScroller: function addSyncScroller(l){
        	   this.lisenters.push(l);
           },
           
           destroy: function destroy(){
        	   this.lisenters = null;
        	   
        	   
	            if(this._scrollDoneListener){
	            	this._scroller.detachEventListener(this._scrollDoneListener);
	            	delete this._scrollDoneListener;
	            }
	            if(this._scrollMovedListener){
	            	this._scroller.detachEventListener(this._scrollMovedListener);
	            	delete this._scrollMovedListener;
	            }
	            
        	   this._super();
           }

        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.TouchScroller",
                         "mstrmojo.hash");

    var $HASH = mstrmojo.hash;

    
    mstrmojo._HasTouchScroller = mstrmojo.provide(

        "mstrmojo._HasTouchScroller",

        
        {
            _meta_usesSuper: true,

            
            scrollerConfig: {},

            
            allowTouchBubble: true,

            
            scrollerSetupDelay: undefined,

            init: function init(props) {
                this._super(props);

                
                this.scrollerConfig = $HASH.clone(this.scrollerConfig);
            },

            
            updateScrollerConfig: function updateScrollerConfig() {
                return this.scrollerConfig;
            },

            
            updateScroller: function updateScroller(noScrollToOrigin, duration) {
                var scroller = this._scroller;

                
                if (scroller) {
                    
                    var cfg = this.updateScrollerConfig();

                    
                    scroller.initScroller(cfg);

                    
                    if (!noScrollToOrigin) {
                        
                        var origin = cfg.origin;
                        if (origin) {
                            
                            scroller.scrollTo(origin.x, origin.y, duration);
                        }
                    }

                    
                    scroller.updateScrollBars();
                }
            },

            
            initScroller: mstrmojo.emptyFn,

            
            useSelectScroll: false,

            
            postBuildRendering: function postBuildRendering() {
                var scroller = this._scroller;

                
                if (!scroller) {
                    
                    scroller = this._scroller = new mstrmojo.TouchScroller();

                    
                    this.initScroller(scroller);
                } else {  
                    scroller.haltScroller();
                }

                
                if (!this.layoutConfig) {
                    var $this = this,
                        delay = this.scrollerSetupDelay;

                    if (!isNaN(delay)) {
                        window.setTimeout(function () {
                            $this.updateScroller();
                        }, delay);

                    } else {
                        
                        this.updateScroller();
                    }
                }

                
                if (this._super) {
                    this._super();
                }
            },

            
            afterLayout: function afterLayout() {
                this._super();

                
                this.updateScroller();
            },

            getScrollPos: function getScrollPos() {
                return $HASH.copy(this._scroller.origin || {
                    x: 0,
                    y: 0
                });
            },

            
            shouldTouchBubble: function shouldTouchBubble(touch) {
                
                if (!this.allowTouchBubble) {
                    
                    return false;
                }

                
                var scroller = this._scroller,
                    isVertical = touch.isVertical,
                    axis = (isVertical) ? 'y' : 'x';

                
                return (!scroller[((isVertical) ? 'v' : 'h') + 'Scroll'] || scroller.offset[axis][touch.direction[axis] ? 'end' : 'start'] === scroller.origin[axis]);
            },

            
            touchBegin: function touchBegin(touch) {
                
                this._scroller.haltScroller();

                return (this._super && this._super(touch)) || true;
            },

            
            touchSwipeBegin: function touchSwipeBegin(touch) {
                
                if (this.shouldTouchBubble(touch)) {
                    
                    if (this.bubbleTouchEvent(touch) === false) {
                        
                        this._touchCanceled = true;
                    }

                    
                    return;
                }

                
                if (this._super) {
                    
                    this._super(touch);
                }

                
                this._scroller.toggleScrollBars(true);
            },

            
            touchSelectBegin: function touchSelectBegin(touch) {
                
                if (this._super) {
                    
                    this._super(touch);
                }

                
                if (this.useSelectScroll) {
                    
                    this.touchSwipeBegin(touch);
                }
            },

            
            touchSwipeMove: function touchSwipeMove(touch) {
                
                if (!this._touchCanceled) {
                    
                    if (this._super) {
                        
                        this._super(touch);
                    }
                }

                
                this._scroller.scroll(touch);
            },

            
            touchSelectMove: function touchSelectMove(touch) {
                
                if (!this._touchCanceled) {
                    
                    if (this._super) {
                        
                        this._super(touch);
                    }
                }

                
                if (this.useSelectScroll) {
                    
                    this.touchSwipeMove(touch);
                }
            },

            
            touchSwipeEnd: function touchSwipeEnd(touch) {
                
                touch.evt.handled = true;

                
                if (!this._touchCanceled) {
                    
                    if (this._super) {
                        
                        this._super(touch);
                    }
                }

                
                this._scroller.scrollEnd(touch);
            },

            
            touchSelectEnd: function touchSelectEnd(touch) {
                
                if (this._touchCanceled) {
                    
                    return;
                }

                
                if (this._super) {
                    
                    this._super(touch);
                }

                
                if (this.useSelectScroll) {
                    
                    this.touchSwipeEnd(touch);
                }
            },

            touchEnd: function touchEnd(touch) {
                
                if (this._touchCanceled) {
                    
                    delete this._touchCanceled;
                    return;
                }

                if (this._super) {
                    this._super(touch);
                }
            },

            unrender: function unrender(ignoreDom) {

                
                var scroller = this._scroller;
                if (scroller) {
                    
                    scroller.unrender();
                }

                
                delete this.scrollerConfig.scrollEl;

                this._super(ignoreDom);
            },


            
            destroy: function destroy() {
                
                if (this._scroller) {
                    
                    this._scroller.destroy();
                    delete this._scroller;
                }

                
                if (this._super) {
                    
                    this._super();
                }
            }

        }
    );

}());
(function () {

    mstrmojo.requiresCls(
        "mstrmojo.dom",
        "mstrmojo._TouchGestures",
        "mstrmojo.TouchScroller"
    );

    var $forEachArray = mstrmojo.array.forEach,
        $forEachHash = mstrmojo.hash.forEach,
        $D = mstrmojo.dom;

    
    function translate(node, c) {
        var i;
        for (i in node) {
            $D.translate(node[i], c[0], c[1], c[2]);
        }
    }

    
    function preventMove(t) {
        var abs = Math.abs;
        return {
            x: (abs(t.accelDelta.x) < abs(t.accelDelta.y)),
            y: (abs(t.accelDelta.y) < abs(t.accelDelta.x))
        };
    }

    
    function raiseScrolledOutEvent(scroller, e) {
        scroller.raiseEvent({
            name: 'scrolledOut',
            value: e.value,
            axis: e.axis,
            direction: e.direction
        });
    }

    
    function setupScroller(el, offset, v, h, frameRate, showBar, friction, indEl) {
        var scroller = new mstrmojo.TouchScroller({
            scrollEl: el,
            vScroll: v,
            hScroll: h,
            frameRate: frameRate,
            showScrollbars: showBar,
            offset: offset,
            origin: {
                x: 0,
                y: 0
            },
            bounces: false,    
            useTranslate3d: false, 
            indicatorEl: indEl
        });

        
        if (friction) {
            scroller.friction = friction;
        }

        return scroller;
    }

    
    function stopDeceleration(scroller) {
        var i;
        
        for (i in scroller) {
            
            if (scroller[i].decelerating) {
                scroller[i].stopDeceleration();
            }
        }
    }

    
    var PREVENT_MOVEMENT = {
        x: false,
        y: false
    };

    
    function getAxis() {
        var prevent = PREVENT_MOVEMENT;

        
        if (!prevent.x) {
            return 'x';
        }
        if (!prevent.y) {
            return 'y';
        }
        
        return null;
    }

    
    var isContainerScrollElement = {
        x: false,
        y: false
    };

    
    function syncScrollEl(xtab, d) {
        
        var currentAxis = getAxis(),
            scrollPast = xtab.scrollerConfig.scrollPast;

        
        if (!currentAxis || !scrollPast) {
            
            return !!currentAxis && !scrollPast;
        }

        function syncHelper(axis) {
            var container = xtab.viewport,
                node = xtab._TSN[axis],
                scroller = xtab._scroller[axis],
                curPosition = xtab.tPos[axis],
                newPosition = d[axis],
                isCntrScrllEl = isContainerScrollElement[axis],
                otherAxis = (axis === 'x') ? 'y' : 'x',
                otherScroller = xtab._scroller[otherAxis],
                isContainerOnOtherAxis = isContainerScrollElement[otherAxis],
                i;

            
            
            if (!otherScroller[0].decelerating && isContainerOnOtherAxis) {
                
                
                syncHelper(otherAxis);
            }

            
            if (curPosition <= 0 && newPosition > 0) {

                if (!isCntrScrllEl) {
                    if (isContainerOnOtherAxis) {
                        
                        return false;
                    }

                    
                    translate(node, [0, 0, 0]);

                      
                    for (i in scroller) {
                        scroller[i].scrollEl = container;
                    }

                    
                    isContainerScrollElement[axis] = true;
                }
            } else {

                if (isCntrScrllEl) {
                    
                    translate([container], [0, 0, 0]);

                    
                    for (i in scroller) {
                        scroller[i].scrollEl = node[i];
                    }

                    
                    isContainerScrollElement[axis] = false;
                }
            }

            
            return true;
        }

        
        return syncHelper(currentAxis);
    }

    function handleScrollEvents(xtab, evt) {
        var axis = evt.axis,
            incRender = xtab.scrollboxHeightFixed,
            evtName = evt.name;

        if (xtab.ss) {
            
            var rowInfo = xtab.zones._BR.getRowInfoByPosition(evt[axis]);

            
            rowInfo.position = evt[axis];

            
            xtab.ss.onMove(rowInfo);
        }

        
        
        xtab.tPos[axis] = evt[axis];

        if (evtName === 'scrollDone') {
            
            $forEachHash(xtab._scroller, function (scrollers) {
                $forEachArray(scrollers, function (scroller) {
                    scroller.toggleScrollBars(false);
                });
            });

            
            if (!syncScrollEl(xtab, evt)) {
                return true;
            }
        }

        
        if (axis === 'y') {

            
            var fnEnd = function (newPosition) {
                
                if (!xtab._isDownloading && (-newPosition <= xtab._TMAX[axis])) {
                    
                    if (xtab.onScrolledToLastRow) {
                        xtab.onScrolledToLastRow();
                    }
                }
            };

            
            if (evtName === 'scrollDone') {
                
                delete xtab._isDecelerating;

                
                if (xtab._cachedDownload) {
                    
                    xtab.dataDownloaded();
                } else {
                    
                    fnEnd(evt.y);
                }

                
                if (incRender) {
                    
                    var newPosition = evt.y;

                    xtab.notifyScrollListeners({
                        x: evt.x,
                        y: Math.max(newPosition, 0)
                    });
                }

            } else if (evtName === 'scrollDecel') {
                
                xtab._isDecelerating = true;

                
                fnEnd(evt.fY);

                
                if (incRender) {
                    
                    xtab.notifyScrollListeners({
                        x: evt.fX,
                        y: evt.fY
                    });
                }
            } else if (evtName === 'scrollOut') {
                
                xtab._isDecelerating = true;

                
                fnEnd(evt.y.position);
            }
        }
    }

    function getScrollerOffsets(widget, axis) {
        var abs = Math.abs,
            offset = {};

        
        var axisOffset = offset[axis] = {
            start: widget._TMIN[axis],
            end: abs(widget._TMAX[axis])
        };

        
        offset.scrollPast = widget.scrollerConfig.scrollPast;

        
        if (axis === 'y') {
            
            if (widget.useSeamlessIncFetch) {
                
                axisOffset.incFetch = !widget.endFetching;

                
                axisOffset.pageSize = widget.scrollboxHeight - ((parseInt(widget.gridData.rh, 10) || 25) * 4);
            }
        }

        return offset;
    }

    function createScrollers(widget) {
        
        widget._scroller = {
            x: [],
            y: []
        };

        var viewportCoords = widget._viewportCoords;

        
        $forEachHash(widget._TSN, function (nodes, axis) {
            var offset = getScrollerOffsets(widget, axis),
                isY = (axis === 'y'),
                isX = (axis === 'x'),
                len = nodes.length;

            
            $forEachArray(nodes, function (node, idx) {
                
                var scroller = setupScroller(node,
                        offset,
                        isY,
                        isX,
                        widget.frameRate,
                        (idx === len - 1) && widget.scrollerConfig.showScrollbars,
                        widget.scrollerFriction,
                        widget.domNode);

                scroller.updateScrollBars(viewportCoords, widget.domNode);

                widget._scroller[axis][idx] = scroller;
            });

            
            
            var zeroScroller = widget._scroller[axis][0],
                evts = [ 'scrollDone', 'scrollMoved' ];

            if (zeroScroller) {
                
                if (isY) {
                    
                    evts = evts.concat([ 'scrollDecel', 'scrollOut' ]);
                }

                
                $forEachArray(evts, function (evtName) {
                    
                    zeroScroller.attachEventListener(evtName, widget.id, function (evt) {
                        
                        evt.axis = axis;
                        handleScrollEvents(widget, evt);
                    });
                });
            }
        });
    }

    
    function updateOffsets(dimension) {
        
        if (this.hasRendered) {
            
            this[dimension + 'Limit'] = parseInt(this[dimension], 10);

            
            if (this.zones) {
                
                var me = this; 
                window.setTimeout(function () {
                    if (me.hasRendered) {
                        
                        me.setOffsets();
                        
                        
                        me.setupScrollers();
                    }
                }, 0);
            }
        }
    }

    
    mstrmojo._HasXtabTouchScroll = mstrmojo.provide(
        "mstrmojo._HasXtabTouchScroll",
        
        {
            
            noScrolling: false,

            
            useTouchScrolling: true,

            
            scrollerConfig: {
                showScrollbars: false,
                scrollPast: false
            },

            
            _TSN: null,

            
            tPos: {
                x: 0,
                y: 0
            },

            
            _TMIN: {
                x: 0,
                y: 0
            },

            
            setupTNs: function setupTNs() {
                
                this._TSN.x = this._TSN.y = [this.domNode];
            },

            
            touchBegin: function touchBegin(touch) {
                
                if (!this.noScrolling) {
                    
                    touch.stop();

                    if (!this._isDownloading) {
                        if (this.toolbarMgr) {
                            this.toolbarMgr.closeToolbar();
                        }

                        var scrollers = this._scroller,
                            min = this._TMIN,
                            max = this._TMAX;

                        
                        $forEachHash(this.tPos, function (position, axis) {
                            
                            
                            if (position >= min[axis] && position <= Math.abs(max[axis])) {
                                
                                stopDeceleration(scrollers[axis]);
                            }
                        });
                    }

                    
                    
                    var xScrollers = this._scroller.x;
                    $forEachHash(xScrollers, function (scroller) {
                        scroller.origin.x = xScrollers[0].origin.x;
                    });
                }

                
                return true;
            },

            
            touchSwipeBegin: function touchSwipeBegin(touch) {
                
                if (this.noScrolling) {
                    
                    return this.bubbleTouchEvent(touch);
                }

                
                if (this._isDownloading) {
                    
                    return false;
                }

                PREVENT_MOVEMENT = preventMove(touch);

                
                var axis = PREVENT_MOVEMENT.y ? 'x' : 'y',
                    scroller = this._scroller[axis][0],
                    offset = scroller.offset,
                    offsetVal = offset[axis][touch.direction[axis] ? 'end' : 'start'];

                
                if (!offset.scrollPast && offsetVal === scroller.origin[axis]) {
                    var bubbleTouchEvent = this.bubbleTouchEvent(touch);

                    
                    
                    if (bubbleTouchEvent !== undefined) {
                        return bubbleTouchEvent;
                    }
                }

                
                var s = this._scroller;

                
                if (!syncScrollEl(this, touch.delta)) {
                    return true;
                }

                
                
                if (!PREVENT_MOVEMENT.x) {
                    stopDeceleration(s.x);
                }
                if (!PREVENT_MOVEMENT.y) {
                    stopDeceleration(s.y);
                }

                
                $forEachHash(this._scroller, function (scrollers, axis) {
                    
                    if (!PREVENT_MOVEMENT[axis]) {
                        
                        $forEachArray(scrollers, function (scroller) {
                            scroller.toggleScrollBars(true);
                        });
                    }
                });

                return true;
            },

            
            touchSwipeMove: function touchSwipeMove(touch) {
                
                
                if (!syncScrollEl(this, touch.delta)) {
                    return true;
                }

                var scrollers = this._scroller;

                $forEachArray([ 'x', 'y' ], function (axis) {
                    if (!PREVENT_MOVEMENT[axis]) {
                        $forEachHash(scrollers[axis], function (scroller) {
                            scroller.scroll(touch);
                        });
                    }
                });
            },

            
            touchSwipeEnd: function touchSwipeEnd(touch) {
                var prevent = PREVENT_MOVEMENT,
                    axis = null,
                    delta = touch.delta,
                    direction = touch.direction;

                if (!prevent.x && delta.x !== 0) {
                    axis = 'x';
                    direction = direction.x ? 'left' : 'right';
                }
                if (!prevent.y && delta.y !== 0) {
                    axis = 'y';
                    direction = direction.y ? 'up' : 'down';
                }

                if (axis) {
                
                    raiseScrolledOutEvent(this, {
                        axis: axis,
                        value: this.tPos[axis],
                        direction: direction
                    });

                    
                    var scroller = this._scroller[axis],
                        i;
                    if (!prevent[axis]) {
                        for (i in scroller) {
                            scroller[i].scrollEnd(touch);
                        }
                    }
                }

            },

            
            gridPagesRendered: function gridPagesRendered() {
                if (this._super) {
                    this._super();
                }

                this.setOffsets();
            },

            
            renderEmptyGrid: function renderEmptyGrid() {
                if (this._super) {
                    this._super();
                }

                this.noScrolling = true;
            },

            postBuildRendering: function postBuildRendering() {

                if (this._super) {
                    this._super();
                }

                
                if (this.zones && !this.gridData.eg) {
                    var me = this;

                    
                    
                    window.setTimeout(function () {
                        
                        if (me.hasRendered) {
                            me._TSN = {
                                x: [],        
                                y: []         
                            };

                            
                            me.setupTNs();
                            
                            
                            me.setupScrollers();
                        }
                    }, 0);
                }
            },

            
            setOffsets: function setOffsets() {
                var me = this,
                    domNode = this.domNode,
                    zones = this.zones,
                    TR = zones._TR,
                    BL = zones._BL,
                    isDocNotFullScreen = (!this.isFullScreenWidget && this.isDocXtab),
                    viewportCoords = this._viewportCoords = {
                        top: TR ? TR.cp.rc * parseInt(this.gridData.rh, 10) : 0,
                        
                        right: isDocNotFullScreen ? this.widthLimit : parseInt(this.width, 10),
                        bottom: isDocNotFullScreen ? this.heightLimit : parseInt(this.height, 10),
                        left: BL ? BL.totalColWidth : 0
                    };

                
                $forEachHash(this._scroller, function (scrollers, axis) {
                    
                    $forEachArray(scrollers, function (scroller) {
                        
                        scroller.offset = getScrollerOffsets(me, axis);

                        
                        scroller.updateScrollBars(viewportCoords, domNode);

                        
                        var origin = scroller.origin;
                        if (origin) {
                            
                            scroller.scrollTo(origin.x, origin.y);
                        }
                    });
                });
            },
            
            
            setupScrollers: function setupScrollers() {
                
                var gd = this.gridData,
                    MAX_OFFSETS = this._TMAX,
                    noScrolling = this.noScrolling = ((gd && gd.co) || (!this.scrollerConfig.scrollPast && MAX_OFFSETS.x === 0 && MAX_OFFSETS.y === 0));

                
                if (!noScrolling && !this._scroller) {
                    
                    isContainerScrollElement = {
                        x: false,
                        y: false
                    };

                    
                    
                    translate(this._TSN.x, [0, 0, 0]);
                    translate(this._TSN.y, [0, 0, 0]);

                    
                    createScrollers(this);
                }
            },

            
            onwidthChange: function onwidthChange() {
                updateOffsets.call(this, 'width');

                
                if (this._super) {
                    this._super();
                }
            },

            
            onheightChange: function onheightChange() {
                updateOffsets.call(this, 'height');

                
                if (this._super) {
                    this._super();
                }
            },

            
            unrender: function unrender(ignoreDom) {
                 
                $forEachHash(this._scroller, function (scrollers) {
                    
                    $forEachArray(scrollers, function (scroller) {
                        
                        scroller.destroy();
                    });
                });
                
                
                delete this._scroller;

                if (this._super) {
                    this._super(ignoreDom);
                }
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.TouchScroller");
            
    
    var OFFSET_PROP = {
        v: {
            axis: 'y',
            dimension: 'height'
        }, 
        h: {
            axis: 'x',
            dimension: 'width'
        }
    };

    
    mstrmojo.android._IsIncFetchList = mstrmojo.provide(

        "mstrmojo.android._IsIncFetchList",

        
        {
            _mixinName: 'mstrmojo.android._IsIncFetchList',

            
            supportsIncFetch: true,

            
            ifDataHelper: null,
            
            
            ifDirection: 'v',
            
            
            supportedEdges: mstrmojo.TouchScroller.EnumIncFetchEdges.end,

            
            initScroller: function initScroller(scroller) {
                this._super(scroller);

                
                var dataHelper = this.ifDataHelper;
                if (dataHelper) {
                    
                    scroller.attachEventListener('incFetch', this.id, function (evt) {
                        
                        if (!this.supportsIncFetch) {
                            
                            return;
                        }
                        
                        
                        var me = this;
                        dataHelper.next({
                            success: function (e, items) {
                                me.addItems(items || e.items);
                                me._scroller.STATUS_INC_FETCH = false;
                            },

                            failure: function (res) {
                                mstrmojo.alert("Error in fetching next: " + res);
                            }
                        }, evt.edge);
                    });
                }
            },

            
            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    incFetch = this.supportsIncFetch,
                    dir = this.ifDirection,
                    offsetProp = OFFSET_PROP[dir];

                
                if (cfg[dir + 'Scroll']) {
                    var offset = cfg.offset[offsetProp.axis];

                    
                    offset.incFetch = incFetch;
                    offset.supportedEdges = this.supportedEdges;
                    offset.pageSize = incFetch ? (parseInt(this[offsetProp.dimension], 10) - 100) : 0;

                    
                    this.scrollerConfig = cfg;
                }

                return cfg;
            },

            
            addItems: function addItems(items) {
                
                this._super(items);

                
                this.supportsIncFetch = ((this.ifDataHelper.totalSize === -1) || (this.items.length < this.ifDataHelper.totalSize));

                
                if (this.updateScroller) {
                    
                    this.updateScroller();
                }
            }
        }
    );
}());
(function(){
    mstrmojo.requiresCls("mstrmojo.TouchScroller", "mstrmojo.dom");

    var LOCK_OFF = 0,
        LOCK_ROW = 1,
        LOCK_COL = 2,
        LOCK_BOTH =3,
        
        TAB_INFO = 'CellInfo',
        TAB_DRILL = 'Drill',
        TAB_LINK = 'Link',

        
        TOUCH_OFFSET = 25,
        CONTENT_LINE_HEIGHT = 40,
        TITLE_HEIGHT = 55,
        TITLE_BORDER_HEIGHT = 6,
        MAX_ENTRIES = 4,
        isTablet = false,
        
        CSS_TAB = 'InfoViewer-Tab',
        CSS_TAB_WRAPPER = 'InfoViewer-TabWrapper',
        CSS_SCOLL_TAB = 'InfoViewer-nTab',
        CSS_SHOW_ALL = 'showAll',
        CSS_DRILL_TO = 'drillTo',
        CSS_LINK_TO = 'linkTo',
        CSS_GLOW = 'glow',
        
        $CSS = mstrmojo.css,

        EVENT_HANDLERS = [];
        
        
        EVENT_HANDLERS[CSS_TAB] = EVENT_HANDLERS[CSS_SCOLL_TAB] = function(dom){
            var cssClass = dom.className;
            
            
            if (cssClass == CSS_TAB){
                cssClass = dom.parentNode.className;
            }
            
            
            for (var i = 0, len = this.tabs.length; i < len; i++){
                if (cssClass.indexOf(this.tabs[i].name) > -1){
                    this.setCurrentTab(i);
                    break;
                }
            }
            
            
            this.xtab.magnifier.resizeAndPosition();
        };
    
        
        EVENT_HANDLERS[CSS_DRILL_TO] = function(){
            mstrApp.closeDialog();
            this.xtab.controller.onDrill(this.xtab, this.drillPaths[0].act);
        };
        
        
        EVENT_HANDLERS[CSS_LINK_TO] = function(dom){
            mstrApp.closeDialog();
            this.xtab.controller.onLink(this.xtab, this.linkPaths[dom.getAttribute('lnk')].act);
        };
        
        
        EVENT_HANDLERS[CSS_SHOW_ALL] = function(dom){
            
            this.tabs[this.currentTabIndex].expanded = true;
            
            $CSS.removeClass(this.xtab.magnifier.containerNode, 'hideMore');
            
            
            this.xtab.magnifier.resizeAndPosition();
        };
    
    
    mstrmojo.XtabMagnifierHelper = mstrmojo.declare(
            
        mstrmojo.Obj,
        
        null,
        
        {
            xtab: null,
            
            cellInfo: null, 
            
            selectedCell: null,
            
            drillPaths: null,
            
            linkPaths: null,
            
            tabs: [],
            
            currentTabIndex: 0,
            
            init: function(props){
                this._super(props);
                
                isTablet = mstrApp.isTablet();
                
                
                var dpi = mstrMobileApp.getDeviceDPI();
                if (dpi <= 120) { 
                    CONTENT_LINE_HEIGHT = 26;
                    TITLE_HEIGHT = 35; 
                    TOUCH_OFFSET = 15; 
                } else if (dpi <= 160) { 
                    CONTENT_LINE_HEIGHT = 35;
                    TITLE_HEIGHT = 46; 
                    TOUCH_OFFSET = 20;
                } else if (dpi <= 213) {
                    CONTENT_LINE_HEIGHT = 46;
                    TITLE_HEIGHT = 61;
                    TOUCH_OFFSET = 26;
                } else if (dpi <= 240){ 
                    CONTENT_LINE_HEIGHT = 53;
                    TITLE_HEIGHT = 69;
                    TOUCH_OFFSET = 30;
                } else { 
                    CONTENT_LINE_HEIGHT = 70;
                    TITLE_HEIGHT = 92;
                    TOUCH_OFFSET = 40;
                }
                
                if (!isTablet) {
                
                	MAX_ENTRIES = 3;
                }
                
                this.titleHeight = TITLE_HEIGHT;
            },
            
            
            glowOnTap: function(dom){
                var glowCssClass = [CSS_TAB_WRAPPER, CSS_SHOW_ALL, CSS_DRILL_TO, CSS_LINK_TO],
                    cssClass = dom.className;

                if (cssClass == CSS_TAB){
                    dom = dom.parentNode;
                    cssClass = dom.className;
                }
                
                for (var i = 0, len = glowCssClass.length; i < len; i++){
                    if (cssClass.indexOf(glowCssClass[i]) > -1){
                        $CSS.addClass(dom, CSS_GLOW);
                 
                        
                        setTimeout(function(){
                            $CSS.removeClass(dom, CSS_GLOW);
                        }, 200);
                        
                        break;
                    }
                }
            },
            
            
            handleTouchTap: function(dom){
                this.glowOnTap(dom);
                
                
                for (n in EVENT_HANDLERS){
                    if (dom.className.indexOf(n) > -1){
                        EVENT_HANDLERS[n].call(this, dom);
                    }
                }
            },
            
            
            handleTouchSwipe: function(touch){
                
                if (!isTablet){
                    var directionX = touch.direction.x,
                        delta = touch.delta,
                        idx = this.currentTabIndex,
                        tabLen = this.tabs.length,
                        totalWidth = parseInt(this.xtab.magnifier.width, 10),
                        minDeltaX = isNaN(totalWidth) ? 50 : totalWidth * 0.2; 
                    
                    
                    if (Math.abs(delta.x) > minDeltaX){
                        if (delta.x > 0){
                            
                            idx = (idx + tabLen - 1) % tabLen;
                        }else {
                            idx = (idx + tabLen + 1) % tabLen;;
                        }
                        
                        
                        if (idx != this.currentTabIndex){
                            this.setCurrentTab(idx);
                            
                            this.xtab.magnifier.resizeAndPosition();
                        }
                    }
                }
            },
            
            
            resolveTouchEvent: function(touch){
                var x = touch.pageX, y = touch.pageY,
                    dom = document.elementFromPoint(x, y),
                    xtab = this.xtab, zones = xtab.zones, td, z;
                
                
                while (dom){
                	var c = dom.className;
                    
                    if (!td && dom.tagName === 'TD' && c && c.toLowerCase().indexOf('xtab-td') >= 0){
                        td = dom;
                    }
                    
                    if (/mstrmojo-XtabZone/.test(c)){
                        
                        for (var i in zones){
                            if (dom == zones[i].domNode){
                                z = zones[i];
                            }
                        }
                        
                        break;
                    }
                    dom = dom.parentNode;
                }

                
                if (td && z){
                    return {
                        cell: td,
                        zone: z,
                        pos: {x: x - TOUCH_OFFSET, y: y - TOUCH_OFFSET, w: TOUCH_OFFSET*2, h: TOUCH_OFFSET*2}
                    };
                }
                
                
                return null;
            },
            
             
            resolveInfoToDisplay: function(touchObj){
                var td = touchObj.cell,
                    zone = touchObj.zone,
                    xtab = this.xtab,
                    lv = xtab.lockHeadersCase,
                    r = parseInt(td.getAttribute('r'), 10),
                    colTitleCell, umCells, row, i, tdIndex, 
                    si, rhc, colIdx, c, cs, i, iLen, j, jLen, k, kLen, listOfPairs = [], me = this,
                    addPair = function(title, value, isSelected){
                        if (isSelected){
                            me.selectedCell = value;

                            
                            listOfPairs.unshift({
                                title: title,
                                value: value
                            });
                        }else {
                            listOfPairs.push({
                                title: title,
                                value: value
                            });
                        }
                    };
                
                
                delete this.selectedCell;
                    
                
                if (lv == LOCK_OFF || lv == LOCK_ROW){
                    
                    r = r - (Math.max(xtab.titlesCP.rc, xtab.chsCP.rc) || 0);
                }else if (zone.slot == '_TR' || zone.slot == '_TL'){
                    r = -1;
                }
                
                
                if (r < 0){
                    
                    colTitleCell = xtab.getCellForNode(td);
                    
                    
                    if (colTitleCell && colTitleCell.o !== undefined){
                        addPair(xtab.model.getCellTitleInfo(colTitleCell).title, colTitleCell, true);
                    }else {
                        return null;
                    }
                }else{
                    umCells = xtab.rhsCP.getUnmergedCells(r) || [];

                    row = {
                        rh: umCells.concat(xtab.rhsCP.getRowCells(r)),
                        vs: xtab.valuesCP.getRowCells(r),
                        ch: []
                    };
                   
                    for( i = 0, iLen = xtab.chsCP.rc; i < iLen; i++) {
                        row.ch.push(xtab.chsCP.getRowCells(i));
                    }
                    
                    
                    tdIndex = td.cellIndex;

                    
                    if (lv == LOCK_OFF || lv == LOCK_COL || zone.slot == '_BL'){ 
                      
                        if (td.parentNode.sectionRowIndex === 0){
                            si = tdIndex;
                        }else {
                            
                            si = tdIndex + umCells.length;
                        }
                    }else { 
                        
                        si = tdIndex + row.rh.length;
                    }
                    
                    rhc = row && row.rh.length;
                    
                    
                    if (si >= rhc){
                        
                        si -= rhc;
                        
                        for (j = 0, jLen = row.ch.length; j < jLen; j++) {
                            colIdx = 0;
                            for (k = 0, kLen = row.ch[j].length; k < kLen; k++) {
                                c = row.ch[j][k];
                                cs = (c && c.cs) || 1; 
                
                                
                                if((si >= colIdx) && (si < colIdx + cs)) {
                                    if(c.mix !== undefined) { 
                                        addPair(c, row.vs[si], true);
                                    } else if (c.ui != null || c.tui != null){ 
                                        addPair(xtab.model.getCellTitleInfo(c).title, c); 
                                    }
                                    break;
                                }
                                
                                colIdx += cs;
                            }
                        }
                        
                        
                        if (!this.selectedCell ){
                            addPair(null, row.vs[si], true);
                        }
                        
                        
                        si = -1;
                    }
                    
                    
                    for(i = 0, iLen = rhc; i < iLen; i++) {
                        c = row.rh[i];
                        addPair(xtab.model.getCellTitleInfo(c).title , c, i == si);
                        
                        
                        if (i == si){
                            break;
                        }
                    }
                }
                
                this.cellInfo = listOfPairs;

                
                if (this.cellInfo){
                    this.tabs = [];
                    
                    
                    this.tabs.push({name: TAB_INFO, label: mstrmojo.desc(10638, 'Info'), expanded: false, content: this.cellInfo});
                    
                    
                    var selectedCell = this.selectedCell,
                        drillable = (selectedCell.v !== undefined) && !!(selectedCell.at & 1),
                        linkable = !!(selectedCell.at & 4);
                
                    if (drillable){
                        this.drillPaths = [];
                        this.drillPaths.push({
                            n: xtab.model.getCellDrillsInfo(selectedCell).n,
                            act: xtab.model.getDrillAction([selectedCell])
                        });
                        
                        this.tabs.push({name: TAB_DRILL, label: mstrmojo.desc(145, 'Drill'), expanded: false, content: this.drillPaths});
                    }else {
                        this.drillPaths = null;
                    }
                    
                    if (linkable){
                        this.linkPaths = [];
                        var lInf = xtab.model.getCellLinksInfo(selectedCell);
                        for (var i = 0, len = lInf.links.length;i < len;i++){
                            this.linkPaths.push({
                                n: lInf.links[i].n, 
                                act: xtab.model.getLinkAction(selectedCell, i)
                            });
                        }
                        
                        this.tabs.push({name: TAB_LINK, label: mstrmojo.desc(8149, 'Link'), expanded: false, content: this.linkPaths});
                    }else{
                        this.linkPaths = null;
                    }
                }
                
                return this.cellInfo;
            },
            
            
            createTitle: function(parentNode){
                var mks = [], 
                    i = 0,
                    tabs = this.tabs,
                    len = tabs.length,
                    tab, idx;
                
                for (; i < len; i++){
                    tab = tabs[i];

                    if (isTablet){
                        mks.push('<div class="', CSS_TAB_WRAPPER, ' ', tab.name, '" style="height:' + (TITLE_HEIGHT - TITLE_BORDER_HEIGHT) + 'px;" >');
                        mks.push('<div class="', CSS_TAB, '">', tab.label, '</div>');
                        mks.push('</div>');
                    } else {
                        mks.push('<div class="', CSS_SCOLL_TAB , ' ', tab.name, '" >', tab.label, '</div>');
                    }
                }
                
                parentNode.style.lineHeight = parentNode.style.height = TITLE_HEIGHT + 'px';
                parentNode.innerHTML = mks.join('');
                
                
                this.setCurrentTab();
            },
            
            
            createContent: function(parentNode){
                var info = this.cellInfo, 
                    drillPaths = this.drillPaths,
                    linkPaths = this.linkPaths,
                    mks = [], rows = [],
                    xtab = this.xtab,
                    addPair = function(l, r, selected) {
                        function _cellMarkup(c, cs) {          
                            var cmk = [],
                                lineHeight = (cs === 'value' && !isTablet) ? CONTENT_LINE_HEIGHT/2 : CONTENT_LINE_HEIGHT;
                            
                            cmk.push('<td><div class="', cs, '" style="line-height:', lineHeight, 'px;max-height:', CONTENT_LINE_HEIGHT, 'px;" >');
                            
                            if (c){
                                if (c.ts == 4){ 
                                    var imgURL = (c.n || c.v),
                                        ds = xtab.controller && xtab.controller.model && xtab.controller.model.dataService;
                                    if ( ds && ds.getImage ) {
                                        imgURL = ds.getImage(imgURL);
                                    }
                                    cmk.push('<img src="' + imgURL + '"/>');
                                }else{
                                    cmk.push(c.n || c.v || '&nbsp;');
                                }
                            }
                            
                            cmk.push('</div></td>');
                            return cmk.join('');
                        };
                        rows.push('<tr style="height:', CONTENT_LINE_HEIGHT, 'px">', _cellMarkup(l, 'title'), _cellMarkup(r, 'value'), '</tr>');
                    },
                    i, len;
                    
                
                if (info == null){
                    return;
                }
                
                
                for (i = 0, len = info.length; i < len; i++){
                    addPair(info[i].title, info[i].value);
                }
                mks.push('<table class="content">');
                mks.push(rows.join(''));
                mks.push('</table>');
                
                
                
                if (drillPaths){
                    mks.push('<div class="actionMenu hide">');
                    for (var i = 0, len = drillPaths.length; i < len; i++){
                        mks.push('<div class="drillTo" style="line-height:', CONTENT_LINE_HEIGHT, 'px">', drillPaths[i].n, '</div>');
                    }
                    mks.push('</div>');
                }
                
                if (linkPaths){
                    mks.push('<div class="actionMenu hide">');
                    for (var i = 0, len = linkPaths.length; i < len; i++){
                        mks.push('<div class="linkTo" style="line-height:', CONTENT_LINE_HEIGHT, 'px" lnk="', i, '">', linkPaths[i].n, '</div>');
                    }
                    mks.push('</div>');
                }
                mks.push('<div class="', CSS_SHOW_ALL, '" style="line-height:', CONTENT_LINE_HEIGHT, 'px" >' + mstrmojo.desc(8995, 'See all...') + '</div>');
                
                parentNode.innerHTML = mks.join('');  
            },

            
            setCurrentTab: function(idx){
                var tabIndex = idx || 0,
                    tabs = this.tabs,
                    tab = tabs[tabIndex],
                    tabLen = tabs.length,
                    magnifier = this.xtab.magnifier,
                    tabs = magnifier.titleNode.children,
                    contents = magnifier.containerNode.children,
                    i, len, contentInfo;
                
                this.currentTabIndex = tabIndex;
                
                
                for (i = 0 ; i < tabLen; i++){
                    $CSS.toggleClass(tabs[i], 'selected', i == tabIndex);
                    
                    if (!isTablet){
                        if (tabLen <= 2){
                            $CSS.toggleClass(tabs[i], 'left', i != tabIndex);
                        }else {
                            $CSS.toggleClass(tabs[i], 'left', i == (tabIndex + tabLen - 1) % tabLen);
                        }
                        $CSS.toggleClass(tabs[i], 'right', i == (tabIndex + tabLen + 1) % tabLen);
                    }
                }
                
                
                for (i = 0, len = contents.length - 1; i < len; i++){
                    $CSS.toggleClass(contents[i], 'hide', i != tabIndex);
                    
                    if (i == tabIndex){
                        this.contentNode = contents[i];
                    }
                }
                
                
                $CSS.toggleClass(magnifier.containerNode, 'hideMore', !tab.expanded && tab.content.length > MAX_ENTRIES);
            },
            
            
            
            getContentHeight: function(){
                function calculateHeight(tab){
                    var content = tab.content,
                        entryNum = content.length,
                        expanded = tab.expanded;
                    
                    return (!expanded && entryNum > MAX_ENTRIES) ? (CONTENT_LINE_HEIGHT + 1) * (MAX_ENTRIES + 1) : (CONTENT_LINE_HEIGHT + 1) * entryNum;
                }
                
                var tabs = this.tabs;
                
                if (isTablet){
                    return calculateHeight(tabs[this.currentTabIndex]);
                }else{
                    var max = 0;
                    for (var i = 0, len = tabs.length; i < len; i++){
                        max = Math.max(calculateHeight(tabs[i]), max);
                    }
                    return max;
                }
            }
        });
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.StepperContentProvider");
    
    
    function has(cp, direction) {
        
        var boundary = direction ? cp.max : cp.min,
            altBoundary = direction ? cp.min : cp.max,
            newVal = cp.getVal(direction ? 1 : -1);
        
        return (
                boundary === null ||
                
                (direction ? (newVal <= boundary) : (newVal >= boundary)) ||
                
                (altBoundary !== null && cp.canLoop));
    }
    
    
    function traverse(cp, direction) {
        var min = cp.min,
            max = cp.max,
            multiplier = direction ? 1 : -1,
            newVal = cp.getVal(multiplier),
            loop = cp.canLoop,
            isOutOfBounds = direction ? (max !== null && newVal > max) : (min !== null && (newVal < min));
        
        
        if(isOutOfBounds) {
            
            if (loop) {
                newVal = ((newVal - min) % (max - min + 1)) + min;
                newVal = (newVal >= min) ? newVal : newVal + (max - min + 1); 
            } else {
                return;
            }
        }
        
        
        cp.curVal = newVal;
        
        
        cp.item[cp.valField] = cp.curVal;
        
        
        if (cp.onTraverse){
            cp.onTraverse();
        }
    }
    
    
    mstrmojo.NumStepperContentProvider = mstrmojo.declare(
        
        mstrmojo.StepperContentProvider,
        
        
        null,
        
        
        {
            scriptClass: "mstrmojo.NumStepperContentProvider",
            
            curVal: null,
            
            
            init: function(props){
                
                this._super(props);
                
                
                this.initProps(props);
            },
            
            
            initProps: function initProps() {
                var minVal = this.isInfinite(this.minField)?  null:this.item[this.minField],
                    maxVal = this.isInfinite(this.maxField)?  null:this.item[this.maxField];
                    intVal = this.item[this.intField];
                
                if(minVal !== null && typeof minVal !== undefined) {
                    this.min = minVal;
                }

                if(maxVal !== null && typeof maxVal !== undefined) {
                    this.max = maxVal;
                }
                    
                if(intVal !== null && typeof intVal !== undefined) {
                   this.interval = intVal;
                }
                
                this.curVal = this.item[this.valField];
                if( this.curVal === null || typeof this.curVal === 'undefined') {
                    
                    this.curVal = (this.min !== null) ? this.min : 0;
                }
            },
            
            
            isInfinite: function isInfinite(fieldName){
                return (typeof fieldName === 'undefined' || fieldName === null || this.item[fieldName] === null || typeof this.item[fieldName] === 'undefined');
            },
            
            
            next: function(){
                traverse(this, true);
            },
            
            
            prev: function(){
                traverse(this, false);
            },
            
            
            hasPrev: function(){
                return has(this, false);
            },
            
            
            hasNext: function(){
                return has(this, true);
            },
            
            
            renderItemAt: function(delta){
                
               var val = this.getVal(delta);
               
               
               return (this.renderer)? this.renderer.render(val, this) : val;
            },
            
            
            getVal: function(delta){
                
               delta = (delta)? delta: 0;
               
               
               return this.curVal + this.interval * delta;
            }
        }
    );
}());           
(function () {
    mstrmojo.requiresCls("mstrmojo._TouchGestures",
                         "mstrmojo.css",
                         "mstrmojo.dom",
                         "mstrmojo.hash");

    
    mstrmojo.android.ui._IsTouchLink = mstrmojo.provide(
        'mstrmojo.android.ui._IsTouchLink',

        
        mstrmojo.hash.copy(mstrmojo._TouchGestures, {
            _mixinName: 'mstrmojo.android.ui._IsTouchLink',

            ontouchend: function (evt) {
                
                if (!this.linkEnabled) {
                    return;
                }

                
                if (!evt.e.handled) {
                    
                    var domNode = this.domNode,
                        mask = document.createElement('div'),
                        id = this.id;

                    
                    mask.className = 'activeLink on';
                    domNode.appendChild(mask);

                    
                    window.setTimeout(function () {
                        
                        var link = mstrmojo.all[id];
                        if (link && link.hasRendered) {
                            mstrmojo.dom.attachOneTimeEvent(mask, 'webkitTransitionEnd', function () {
                                
                                domNode.removeChild(mask);
                            });

                            
                            mstrmojo.css.removeClass(mask, 'on');
                        }
                    }, 200);

                    
                    this.onclick();
                }
            }
        })
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.NumStepperContentProvider", "mstrmojo.date");
    
    var $D = mstrmojo.date;
    
    mstrmojo.DateStepperContentProvider = mstrmojo.declare(
        
        mstrmojo.StepperContentProvider,
        
        
        null,
        
        
        {
            scriptClass: "mstrmojo.DateStepperContentProvider",
            
            curVal: null,
            
            init: function(props){
                this._super(props);
                
                
                var item = this.item,
                    intVal = item[this.intField],
                    val = item[this.valField],
                    minF = this.minField,
                    maxF = this.maxField,
                    min = item[minF],
                    max = item[maxF];
                
                
                this.min = min && $D.getDateFromDateInfo(min);
                this.max = max && $D.getDateFromDateInfo(max);
                
                
                this.curVal = val ? $D.getDateFromDateInfo(val) : (this.min ? new Date(this.min) : new Date());
                
                
                this.createChildProviders();
            },
            
            
            
            
            
            createChildProviders: function(){
                var me = this;
                
                mstrmojo.array.forEach(['year', 'month', 'day'], function(n){
                    me[n + 'CP'] = new mstrmojo.NumStepperContentProvider({
                                        item: { interval:1 },
                                        canLoop: true,
                                        updateConfig: function(v, max, min){
                                            this.curVal = v;
                                            this.max = max;
                                            this.min = min;
                                        },
                                        onTraverse: function(){
                                            
                                            me.traverse(n, this.curVal);
                                        }
                                    });
                });
                
                this.updateChildProviders();
            },
            
            
            updateChildProviders: function(){
                var max = this.max,
                    min = this.min,
                    year = this.curVal.getFullYear(),
                    month = this.curVal.getMonth(),
                    day = this.curVal.getDate(),
                    
                    atMaxYear = max && (year === max.getFullYear()),
                    atMinYear = min && (year === min.getFullYear()),
                    
                    atMaxMonth = atMaxYear && (month === max.getMonth()),
                    atMinMonth = atMinYear && (month === min.getMonth());
                
                
                this.yearCP.updateConfig(year, max ? max.getFullYear() : null, min ? min.getFullYear() : null);
                
                
                this.monthCP.updateConfig(month + 1, atMaxYear ? max.getMonth() + 1 : 12, atMinYear ? min.getMonth() + 1 : 1);
                
                
                this.dayCP.updateConfig(day, atMaxMonth ? max.getDate() : mstrmojo.date.getDaysOfMonth(year, month + 1), atMinMonth ? min.getDate() : 1);
            },
            
            
            traverse: function(field, value){
            
                var v = this.curVal,
                    y = (field === 'year') ? value : this.curVal.getFullYear(),
                    m = (field === 'month') ? value : this.curVal.getMonth() + 1, 
                    d = (field === 'day') ? value : this.curVal.getDate();
                
                
                d = Math.min(mstrmojo.date.getDaysOfMonth(y, m), d);
                
                
                v.setFullYear(y, m - 1, d);
                
                
                if (this.max){
                    v = Math.min(this.max, v); 
                }
                if (this.min){
                    v = Math.max(this.min, v); 
                }
                
                this.curVal = new Date(v);
                
                this.updateChildProviders(); 
                
                if (this.onTraverse){
                    this.onTraverse();
                }
            }
        }
    );
}());           
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.Container",
                         "mstrmojo.ListBase",
                         "mstrmojo.android._IsList",
                         "mstrmojo.android._IsIncFetchList",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller");
    
    var $A = mstrmojo.array,
        $HC = mstrmojo.hash.copy,
        EDGES_ENUM = mstrmojo.TouchScroller.EnumIncFetchEdges,
        EDGE_START = EDGES_ENUM.start,
        INC_FETCH_SIZE = 50,
        BUFFER_SIZE = 20,
        NO_DELAY = false;
    
    
    function createIncFetchDataHelper(start, end) {
        
        if (this.end === null || isNaN(this.end) || this.start === null || isNaN(this.start)) {
            this.ifDirection = 'h';
            
            
            this.supportedEdges = 0;
            $A.forEach(['start', 'end'], function (edge) {
                this.supportedEdges += isNaN(this[edge]) ? EDGES_ENUM[edge] : 0;
            }, this);
            
            var $this = this,
                i;
            
            
            this.ifDataHelper = new mstrmojo.Obj({
                totalSize: -1,
                
                next: function next(callbacks, edge) {
                    
                    var evtItems = [],
                        adjustedIndex = -1;
                    
                    
                    evtItems = evtItems.concat($this.items);
                    
                    if (edge === EDGE_START) {
                        for (i = 0; i < INC_FETCH_SIZE; i ++) {
                            evtItems.splice(0, 0, {
                                n: --start
                            });
                        }
                        
                        
                        evtItems = evtItems.splice(0, INC_FETCH_SIZE + BUFFER_SIZE);
                        
                        
                        end = start + INC_FETCH_SIZE + BUFFER_SIZE - 1;
                        
                        
                        adjustedIndex = INC_FETCH_SIZE;
                    } else {
                        
                        for (i = 0; i < INC_FETCH_SIZE; i ++) {
                            evtItems.push({
                                n: ++end
                            });
                        }
                        
                        
                        evtItems = evtItems.splice(evtItems.length - INC_FETCH_SIZE - BUFFER_SIZE);
                        
                        
                        start = end - INC_FETCH_SIZE - BUFFER_SIZE;
                        
                        
                        adjustedIndex = BUFFER_SIZE - 3;
                    }
                    
                    
                    $this.set('items', evtItems);
                    
                    window.setTimeout(function() {
                        
                        NO_DELAY = true;
                        
                        
                        $this.singleSelect(adjustedIndex);
                    }, 0);
                    
                    
                    callbacks.success({
                        items: undefined
                    });
                }
            });
        }
    }
    
    
    mstrmojo.android.ui.CalendarYearList = mstrmojo.declare(

        
        mstrmojo.ListBase,

        
        [ mstrmojo.android._IsList, mstrmojo._TouchGestures, mstrmojo._HasTouchScroller, mstrmojo.android._IsIncFetchList ],
        
        
        {
            scriptClass: "mstrmojo.android.ui.CalendarYearList",
            
            
            years: undefined,
            
            scrollerConfig: {
                bounces: false,
                showScrollbars: false,
                scrollPast: true
            },
            
            getItemMarkup: function (item, idx) {
                return '<{@tag} class="item {@cls}" idx="{@idx}" style="{@style}">' +
                           '<span>{@n}</span>' +
                           '<div class="marker"></div>' +
                       '</{@tag}>';
            },
            
            postCreate: function postCreate(props) {
                
                if (this._super) {
                    this._super();
                }
                
                var start = (this.start) || (new Date(0)).getFullYear(),
                    end = (this.end) || ((new Date()).getFullYear() + 5),
                    current = start,
                    items = this.items = this.items || [];
                
                
                while (end >= current) {
                    items.push({
                        n: current++
                    });
                }
                
                
                createIncFetchDataHelper.call(this, start, end);
            },
            
            postBuildRendering: function postBuildRendering() {
                this._super();
                
                
                var width = this.ITEMS_NODE_WIDTH = this.itemsNode.clientWidth;
                
                
                this.updateScroller();
                
                
                this.singleSelectByField(this.initialYear, 'n');
                
                this._scroller.attachEventListener('scrollDone', this.id, function (evt) {
                    
                    var fraction = (evt.x + (parseInt(this.width, 10) - width)/2) / width,
                        intVal = Math.floor(fraction),
                        newIdx = intVal;
                    
                    
                    newIdx += ((fraction - intVal) > 0.3) ? 1 : 0;
                    
                    
                    if (newIdx !== this.selectedIndex) {
                        
                        this.singleSelect(newIdx);
                    } else {
                        
                        this.onchange();
                    }
                    
                });
            },
            
            
            onchange: function() {
                var idx = this.selectedIndex;
                
                if (idx >= 0) {
                    var itemWidth = this.ITEMS_NODE_WIDTH,
                        scrollToPos = (idx * itemWidth) - (parseInt(this.width, 10) - itemWidth)/2;

                    
                    this._scroller.scrollTo(scrollToPos, undefined, NO_DELAY ? 0 : 200);
                    
                    
                    this.raiseEvent({
                        name: 'yearChanged',
                        value: this.selectedItem.n
                    });
                    
                    
                    NO_DELAY = false;
                }
            },
            
            
            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    icn = this.itemsContainerNode,
                    w = parseInt(this.width, 10);

                
                if (isNaN(w)) {
                    
                    w = this.domNode.clientWidth;
                }

                
                cfg.scrollEl = icn;

                
                cfg.noVScroll = true;

                
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                
                var offsetEnd = Math.max(icn.clientWidth - w, 0),
                    
                    enableScroll = cfg.hScroll = (offsetEnd !== 0);
                
                
                if (enableScroll) {
                    cfg.offset = {
                        
                        
                        x: $HC({
                            start: 0,
                            end: offsetEnd
                        }, cfg.offset && cfg.offset.x)
                    };
                    
                } else {
                    cfg.offset = undefined;
                }
                
                return cfg;
            },
            
            
            destroy: function destroy() {
                if (this.ifDataHelper) {
                    this.ifDataHelper.destroy();
                    delete this.ifDataHelper;
                }
                
                this._super();
            }
            
        }
    );
    
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android._IsList",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android.selectors._SupportsHoriz",
                         "mstrmojo.css");

    
    mstrmojo.android.selectors.CheckList = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._TouchGestures, mstrmojo.android._IsList, mstrmojo._HasTouchScroller, mstrmojo.android.selectors._SupportsHoriz ],

        
        {
            scriptClass: "mstrmojo.android.selectors.CheckList",

            hasEvenRows: true,

            init: function init(props) {
                this._super(props);

                
                var cls = [ 'selector-checklist' ];

                
                if (this.multiSelect) {
                    
                    cls.push('multi');
                }

                
                mstrmojo.css.addWidgetCssClass(this, cls);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._Formattable",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.hash");

    
    mstrmojo.android.HTMLContainer = mstrmojo.declare(
        mstrmojo.Widget,

        
        [ mstrmojo._Formattable, mstrmojo._HasTouchScroller, mstrmojo._TouchGestures ],

        
        {
            scriptClass: "mstrmojo.android.HTMLContainer",

            markupString:   '<div id="{@id}" class="mstrmojo-HTMLContainer {@cssClass}" title="{@tooltip}" style="{@domNodeCssText}">' +
                                '<div>{@v}</div>' +
                            '</div>',

            markupSlots: {
                valueNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                domNode:  [ 'RW', 'B', 'F', 'P', 'background-color', 'fx', 'text-align', 'white-space' ]
            },

            
            update: function update(node) {
                var d = node.data,
                    v = d.v || '';

                
                var div = document.createElement('div');
                div.innerHTML = '<textarea>' + v + '</textarea>';
                v = '<div style="display:none">&nbsp;</div>' + div.firstChild.value + '&nbsp;';     

                
                div = null;

                
                this.v = v;
                
                
                if (this.thresholdId || d.tid) {
                	
                	delete this.fmts;
                }

                
                this.thresholdId = d.tid;

                
                this.scrollerConfig = {
                    bounces: false,
                    showScrollbars: false
                };
            },

            
            postBuildRendering: function postBuildRendering() {

                
                var scripts = this.domNode.getElementsByTagName('script'),
                    len = scripts.length,
                    i;

                for (i = 0; i < len; i++) {
                    
                    eval(scripts[i].innerHTML);
                }

                return this._super();
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    scrollEl = this.valueNode,
                    domNode = this.domNode,
                    fmts = this.getFormats(),
                    iterator = {
                        'Height': {
                            a: 'y',
                            s: 'v'
                        },
                        'Width': {
                            a: 'x',
                            s: 'h'
                        }
                    },
                    offset = {};

                
                cfg.scrollEl = scrollEl;

                mstrmojo.hash.forEach(iterator, function (info, dimension) {
                    
                    if (cfg['no' + info.s.toUpperCase() + 'Scroll']) {   
                        
                        return;
                    }

                    
                    var widgetSize = parseInt(fmts[dimension.toLowerCase()], 10);

                    
                    if (isNaN(widgetSize)) {
                        
                        widgetSize = domNode['client' + dimension];
                    }

                    
                    var offsetEnd = Math.max(scrollEl['offset' + dimension] - widgetSize, 0),
                        enableDimensionScroll = cfg[info.s + 'Scroll'] = (offsetEnd !== 0);

                    
                    if (enableDimensionScroll) {
                        
                        offset[info.a] = {
                            start: 0,
                            end: offsetEnd
                        };
                    }
                });

                
                cfg.offset = offset;

                
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                return cfg;
            }

        }
    );

}());
(function () {

	mstrmojo.requiresCls("mstrmojo.Widget",
						 "mstrmojo.VisHeatMapColorTheme",
						 "mstrmojo._TouchGestures",
						 "mstrmojo._HasTouchScroller",
						 "mstrmojo.dom",
						 "mstrmojo.css"
						 );
	
	var STEP_X = 1200,
		STEP_Y = 800;
	
	var LABEL = {
		ON: 0,
		OFF: 1,
		PROPORTIONAL: 2
	};
	
	var FMT = {
		LABEL_CTNR_THRES: 6, 
        LABEL_CTNR_WIDTH_THRES: 32,
		LGD_GUTTER: 5, 
        LABEL_PADDING: 2 
	};
	
	var CSSATTR = {
		"heatmap-one-level-1": {},
		"heatmap-two-level-2": {},
		"heatmap-multi-level-1": {},
		"heatmap-multi-level-2": {},
		"heatmap-multi-level-3": {},
		init: false
	};
	
	function getCSSColor(rgb) {
		var c = 0x1000000 + rgb; 
		var str = '#' + c.toString(16).substring(1).toUpperCase();
		return str;
	}
	
	function wfs(root, f) {
		var arr = [root];
		while (arr.length !== 0) {
			var node = arr.shift();
			if (node === undefined || node.deleted) {
				continue;
			}
			
			f(node);
			
			var children = node.entityChildren;
			if (children !== undefined) {
				var l = children.length;
				for (var i = 0; i < l; i++) {
					arr.push(children[i]);
				}
			}
		}
	}
	
	function dfs(root, f, indexString) {
		if(root.deleted) {
			return;
		}
		if(indexString === undefined){
			f(root);
		}else{
			f(root, indexString);
		}
		
		if(root.entityChildren === undefined){
			return;
		}
		var arr = root.entityChildren,
			l = arr.length;
		for(var i = 0; i < l; i++){
			var e = arr[i];
			if(indexString === undefined){
				dfs(e, f);
			}else{
				var param = indexString;
				if (!param) {
					param = i.toString();
				} else {
					param = param + ":" + i;
				}
				dfs(e, f, param);
			}
		}					
	}
	
	function getLabelCSS(l, n) {
		var css;
		if (n === 1) {
			if (l === 0) {
				css = "heatmap-one-level-1";
			}
		} else if (n === 2) {
			if (l === 0) {
				css = "heatmap-multi-level-1";
			} else if (l === 1) {
				css = "heatmap-two-level-2";
			}
		} else if (n >= 3) {
			if (l === 0) {
				css = "heatmap-multi-level-1";
			} else if (l === 1) {
				css = "heatmap-multi-level-2";
			} else if (l === 2) {
				css = "heatmap-multi-level-3";
			}
		}

		return css;
	}

	function intersect(lhs, rhs) {
        if(!lhs || !rhs) {
                return false;
        }
		if (rhs.x >= lhs.x + lhs.w ||
			rhs.y >= lhs.y + lhs.h ||
			rhs.x + rhs.w <= lhs.x ||
			rhs.y + rhs.h <= lhs.y) {
			return false;
		} else {
			return true;
		}
	}
	
	function rectIntersection(a, b) {
		var x = Math.max(a.x, b.x);
		var y = Math.max(a.y, b.y);
		var w = Math.min(a.x + a.w, b.x + b.w) - x;
		var h = Math.min(a.y + a.h, b.y + b.h) - y;
		if (w < 0 || h < 0) {
			return {
				x : NaN,
				y : NaN,
				w : NaN,
				h : NaN
			};
		}
		return {
			x : x,
			y : y,
			w : w,
			h : h
		};
	}
	
	mstrmojo.VisHeatMapCanvas = mstrmojo.declare(
		
		mstrmojo.Widget,
		
		null,
		
		{
			scriptClass: 'mstrmojo.VisHeatMapCanvas',
			
			parent: null,
			
			root: null,
			
			colorTheme: null,
			
			attributes: [],
			
			scale: 1.0,
			
			labelSetting: 0, 
			
			showMetric: false,
			
			bgColor: '#333333',
			
			numImages: 0,
			
			offsetX: 0,
			offsetY: 0,
			
			markupString: 
			'<div style="position:absolute; width:{@width}px; height:{@height}px">' +
				'<canvas width={@width} height={@height} style="visibility: hidden; z-index:0"></canvas>' +
				'<span></span>' +
			'</div>',
			
			markupSlots: {
				domCanvas:	function () { return this.domNode.firstChild; },
				domSpan:	function () { return this.domNode.childNodes[1]; },
				domImage:	function () { return this.domNode.childNodes[2]; }
			},
			
			buildRendering: function () {
				var that = this;
				var backup = mstrmojo.string.apply;
				mstrmojo.string.apply = function (tmpl, obj) {
					if (!tmpl) {
						return "";
					}
					return tmpl.replace(/\{([^\}]+)\}/gm,
						function tokenRepl(token, prop) {						
							var s = token.replace(/@/g, 'that.');
							var res = eval(s);
							return res === undefined ? '' : res;
						}
					);
				};
				
				if (this._super) {
					this._super();
				}
				
				mstrmojo.string.apply = backup;
			},
			
			postBuildRendering: function () {
				this.initCSSATTR();
				
				this.draw();

				if (this._super) {
					this._super();
				}
			},
			
			removeImageAndLabels: function () {
				var dom = this.domNode,
					labels = dom.childNodes,
					n = labels.length;
				for (var i = n-1; i > 1; i--) {
					var node = labels[i];
					dom.removeChild(node);
				}
				this.numImages = 0;
			},
			
			removeLabels: function () {
				var dom = this.domNode,
					labels = dom.childNodes,
					n = labels.length,
					stop = 1 + this.numImages;
				for (var i = n-1; i > stop; i--) {
					var node = labels[i];
					dom.removeChild(node);
				}
			},
			
			updateOffsets: function (x, y) {
				this.offsetX = x;
				this.offsetY = y;
				this.removeLabels();
				this.drawLabels();
			},
			
			draw: function (x, y) { 
				if (x !== undefined)	this.offsetX = x;
				if (y !== undefined)	this.offsetY = y;
				this.removeImageAndLabels();
				this.drawRects();
				this.drawLabels();
			},
			
			drawRects: function () {
				var w = this.width,
					h = this.height,
					k = this.scale,
					cw = Math.ceil(w * k),
					ch = Math.ceil(h * k),
					cvs = this.domCanvas,
					dom = this.domNode,
					fragment = document.createDocumentFragment(),
					row = Math.ceil(ch / STEP_Y),
					col = Math.ceil(cw / STEP_X),
					count = 0;
				
				for (var i = 0; i < row; i++) {
					for (var j = 0; j < col; j++) {
						var window = {
							x: j * STEP_X,
							y: i * STEP_Y,
							w: STEP_X,
							h: STEP_Y
						};
						if (i + 1 === row) { 
							window.h = ch - window.y;
						}
						if (j + 1 === col) { 
							window.w = cw - window.x;
						}

						cvs.setAttribute('width', window.w);
						cvs.setAttribute('height', window.h);
						var cxt = cvs.getContext("2d");
						cxt.fillStyle = this.bgColor;
						cxt.fillRect(0, 0, window.w, window.h);
						
						var drawPiece = function (e, idx) {
							var rect = e.size;
							if (e.entityChildren === undefined && !e.deleted && intersect(window, rect)) {
								var x1 = Math.max(rect.x - window.x, 0),
									y1 = Math.max(rect.y - window.y, 0),
									x2 = Math.min(rect.x + rect.w - window.x, window.w),
									y2 = Math.min(rect.y + rect.h - window.y, window.h);
								cxt.fillStyle = e.color;
								cxt.fillRect(x1, y1, x2-x1, y2-y1);
							}
							e.idx = idx; 
						};

						dfs(this.root, drawPiece, '');
						
						var res = cvs.toDataURL();
						var img = document.createElement('img');
						img.src = res;
						img.style.position = 'absolute';
						img.style.left = window.x + 'px';
						img.style.top = window.y + 'px';
						img.setAttribute("draggable", "false");
						img.setAttribute("orgx", window.x);
						img.setAttribute("orgy", window.y);
						fragment.appendChild(img);
						count++;
					}
				}
				
				cvs.setAttribute('width', 0);
				cvs.setAttribute('height', 0);
				dom.style.width = cw + 'px';
				dom.style.height = ch + 'px';
				dom.appendChild(fragment);
				this.numImages = count;
			},
			
			drawLabels: function () {
				var l = this.attributes.length,
					that = this,
					dom = this.domNode,
					gut = FMT.LGD_GUTTER,
                    padding = FMT.LABEL_PADDING,
					window = {
						x: this.offsetX,
						y: this.offsetY,
						w: this.width,
						h: this.height
					};
				
				var caches = [],
					layout = [{}, {}, {}];
					
				var ext = Math.floor( Math.log(this.scale) / Math.log(2) ); 
				ext = Math.min(ext, l - 3);
				ext = Math.max(ext, 0);
				this._ext = ext; 
				
				var drawText = function (e) {
					if (e === that.root || e.deleted) {
						return;
					}
					
					var rect = e.size,
						w = rect && rect.w,
						h = rect && rect.h;

					if (!intersect(window, rect)) {
						return;
					}
						
					if (w < FMT.LABEL_CTNR_WIDTH_THRES + 2 * FMT.LABEL_PADDING || h < FMT.LABEL_CTNR_THRES) { 
						return;
					}
					
					var str = e.text,
						idx = e.idx,
						level = e.level - ext;
						
					if (level >= 0 && level < 3) {
						var tw, th, 
							labelCSS = getLabelCSS(level, l),
							font = CSSATTR[labelCSS].font,
							fontSize = CSSATTR[labelCSS].fontSize,
							o = {
								s: {},
								e: e,
								m: 0, 
								css: labelCSS
							};
							
						if (that.showMetric === true && e.entityChildren === undefined) {
							var loc = {};
							mstrmojo.hash.copy(rect, loc);
							
							if (l > 1 && level === 0) { 
								loc.w -= 2 * gut;
								loc.h -= gut;
							} else {
								loc.w -= 2*padding;
							}
							
							var lh, txtS; 
							
							if (that.labelSetting === LABEL.PROPORTIONAL) {
								lh = 9;
								var step = 8,
									shrink = false,
									txtS = that.getTextSize(str, font, lh, true, false, loc.w); 

								while (step >= 1) {
									if (txtS.h < loc.h) {
										lh += step;
									} else {
										if (lh === 9) { 
											break;
										}
										if (lh >= loc.w) {
											break;
										}
										if (!shrink) {
											step /= 2;
										}
										shrink = true;
										lh -= step;
									}
									
									txtS = that.getTextSize(str, font, lh, true, false, loc.w);
									
									if (shrink) {
										step = step >> 1;
									}
								}
								
								if (txtS.h > loc.h && lh > 9) {
									lh--;
								}
								if (lh > loc.w) {
									lh = loc.w;
								}

                                o.fs = lh;
								
							} else {
								lh = fontSize;
							}
							
							o.lh = lh; 
							
							txtS = that.getTextSize(str, font, lh, true, false, loc.w);
							
							tw = Math.min(txtS.w, loc.w);
							th = txtS.h;
							
							if (th > loc.h) {
								th = Math.floor(loc.h / lh) * lh;
							}
						} else {
							if (caches[level] === undefined) {
								caches[level] = {};
							}
							
							var cache = caches[level];
								
							if (cache[str] === undefined) {
								var txtS = that.getTextSize(str, font, fontSize, true),
								tw = txtS.w,
								th = txtS.h;
								if (l > 1 && level === 0) {
									tw += 2 * gut;
									th += gut;
								}
								cache[str] = {w: tw, h: th};
							} else {
								tw = cache[str].w;
								th = cache[str].h;
							}
							
							if (th > h) return;
							
							o.lh = th;
							
                            var p ;
                            if (l > 1 && level === 0) {
                                    p = 2 * gut;
                            } else {
                                    p = 2 * padding;
                            }
							if (tw > w - p) {
								var trunw = tw >> 1,
                                    lineCount = Math.floor(h/o.lh);
                                
								if (trunw > (w - p)*lineCount) {
                                        return;
                                }
                                tw = w - p;
                                
                                if( (l == 1 && level == 0) || (l == 2 && level == 1) || (l >2 && level == 2) ) {
                                        
                                        var ts = that.getTextSize(str, font, fontSize, true, false, w-p, true);
                                        th *= Math.floor(Math.min(ts.h, h) / o.lh);
                                        o.isLowestLevel = true;
                                }
							}
						}
						
						var x = rect.x + ((w - tw) >> 1),
							y = rect.y + ((h - th) >> 1);
						
						o.s = {x: x, y: y, w: tw, h: th};
						layout[level][idx] = o;
					}
					
				};
				
				if (that.labelSetting !== LABEL.OFF) {
					wfs(this.root, drawText);
					this.layoutLabels(layout);
				}
			},
			
			layoutLabels: function (layout) {
				var that = this,
					doc = document,
					fragment = doc.createDocumentFragment();
			
				function generateLabel(o) {
					var s = o.s,
						e = o.e,
						css = o.css,
						color = that.getLabelColor(s, e),
						hasM = o.fs !== undefined;
						
					var div = doc.createElement('div'); 
					if (hasM) {
                        div.setAttribute('style', 'font-size: ' + o.fs + 'px' + ' !important');
						
						div.className = css + ' heatmap-showMetric-text';
					} else {
						div.className = css + ' heatmap-trun-text';
					}
					div.style.position = 'absolute';
					div.style.color = color;
					div.style.backgroundColor = 'rgba(255, 255, 255, 0)';
					div.style.zIndex = '1';
					div.style.left = s.x + 'px';
					div.style.top = s.y + 'px';
					div.style.width = s.w + 'px';
					div.style.height = s.h + 'px';
					div.style.lineHeight = o.lh + 'px';
                    if(o.isLowestLevel) {
                            div.style.textOverflow = 'ellipsis';
                            div.style.wordBreak = 'normal';
                    }
					
					
					div.setAttribute("idx", e.idx);
					div.innerHTML = e.text;
					fragment.appendChild(div);
				}
				
				var L0 = layout[0],
					L1 = layout[1],
					L2 = layout[2],
					idx;
				
				for (idx in L1) {
					var info = L1[idx],
						bbox = info.s,
						node = info.e,
						prt = node.parentEntity,
						pinfo = L0[prt.idx];
					
					if (pinfo === undefined) {
                        generateLabel(info);
                        continue;
                    }

					var pbox = pinfo.s,
						inter = rectIntersection(bbox, pbox);
					
					var rmIt = false;
					if (inter.w > 5 || inter.h > 5) { 
						if (pbox.y <= bbox.y) {
							var delta = ((pbox.y + pbox.h - bbox.y) >> 1) + 1;
							if (pinfo.m !== 2 && (pbox.y - delta >= prt.size.y) && (bbox.y + bbox.h + delta <= node.size.y + node.size.h)) {
								pbox.y -= delta;
								bbox.y += delta;
								pinfo.m = 1;
							} else {
								rmIt = true;
							}
						} else {
							var delta = ((bbox.y + bbox.h - pbox.y) >> 1) + 1;
							if (pinfo.m !== 1 && (pbox.y + pbox.h + delta <= prt.size.y + prt.size.h) && (bbox.y - delta >= node.size.y)) {
								pbox.y += delta;
								bbox.y -= delta;
								pinfo.m = 2;
							} else {
								rmIt = true;
							}
						}
					}
					
					if (rmIt !== true) {
						generateLabel(info);
					}
				}

				for (idx in L0) { 
					generateLabel(L0[idx]);
				}
				
				for (idx in L2) {
					rmIt = false;
					
					var info2 = L2[idx],
						node2 = info2.e,
						node1 = node2.parentEntity,
						node0 = node1.parentEntity,
						idx1 = node1.idx,
						idx0 = node0.idx,
						info1 = L1[idx1],
						info0 = L0[idx0];
						
					if (info1 !== undefined) {
						var inter12 = rectIntersection(info1.s, info2.s);
						if (!isNaN(inter12.w)) {
							rmIt = true;
						}
					}
					if (rmIt === false && info0 !== undefined) {
						var inter02 = rectIntersection(info0.s, info2.s);
						if (!isNaN(inter02.w)) {
							rmIt = true;
						}
					}
						
					if (rmIt !== true) {
						generateLabel(info2);
					}
				}
				
				this.domNode.appendChild(fragment);
			},
			
			getLabelColor: function (s, e) {
				var level = e.level - this._ext;
				if (level === 0) {
					return '#FFFFFF';
				}
			
				var ct = this.colorTheme;
				if (e.entityChildren === undefined) {
					return getCSSColor(ct.getContrastColor( parseInt(e.color.substring(1, e.color.length), 16) ));
				}
			
				var stack = [e],
					ls = 0,
					ds = 0;
			
				while (stack.length !== 0) {
					var node = stack.shift(),
						ch = node.entityChildren,
						n = node.entityChildren.length;
					
					for (var i=0; i<n; i++) {
						var child = ch[i];
						if (child.deleted)	continue;
						
						var rect = rectIntersection(s, child.size);
						if (child.entityChildren === undefined) {
							if (!isNaN(rect.w)) {
								if (ct.isBrightColor( parseInt(child.color.substring(1, child.color.length), 16) )) {
									ls += rect.w * rect.h;
								} else {
									ds += rect.w * rect.h;
								}
							}
						} else {
							if (!isNaN(rect.w)) {
								stack.push(child);
							}
						}
					}
				}
				
				if(ls > ds){
					return '#000000';
				} else {
					if (level === 1) {
						return '#e6e7e8';
					} else {
						return '#d1d3d4';
					}
				}
			},
			
			getEntity: function (pos) {
				var ox = pos.x,
					oy = pos.y,
					target;
					
				var hitTest = function (node) {
					if (node.entityChildren === undefined && !node.deleted && node.size) {
						var size = node.size,
							x1 = size.x,
							y1 = size.y,
							x2 = x1 + size.w,
							y2 = y1 + size.h;
						
						if (ox >= x1 && ox <= x2 && oy >= y1 && oy <= y2) {
							target = node;
						}
					}
				};
				
				var dfsReturnOnFound = function (root, f) {
					if(root.deleted) {
						return;
					}
					
					f(root);
					
					var arr = root.entityChildren;
					if (arr !== undefined) {
						var l = arr.length;
						for (var i = 0; i < l; i++) {
							var e = arr[i];
							dfsReturnOnFound(e, f);
							if (target !== undefined) {
								return;
							}
						}
					}
				};
				
				dfsReturnOnFound(this.root, hitTest);
				
				return target;
			},
			
			initCSSATTR: function () {
				if (CSSATTR.init === false) {
					var dom = this.domSpan;
					for (var css in CSSATTR) {
						if (css === 'init')	continue;
						dom.setAttribute('class', css);
						var res = document.defaultView.getComputedStyle(dom);
						CSSATTR[css].fontSize = parseInt(res['fontSize']);
						CSSATTR[css].font = res['fontFamily'];
					}
				}
			},
			
			getTextSize: function (str, fontName, fontSize, isBold, isItalic, width, normalBreak) {
				var dom = this.domSpan,
                    breakMethod = 'break-all';
                if (normalBreak) {
                        breakMethod = 'normal';
                }

                dom.className = '';
				dom.innerHTML = str;
				dom.style.cssText = "position:absolute; visibility:hidden; z-index:-1; font-family:" + fontName + 
				"; font-size:" + fontSize + "px; font-weight:" + (isBold ? 'bold' : 'normal') + 
				"; font-style:" + (isItalic ? 'italic' : 'normal') + "; line-height:" + fontSize + "px;";
				
				var w = dom.offsetWidth;
				if (width !== undefined && w > width) {
					dom.style.cssText += "overflow:hidden; word-break:" + breakMethod + "; width:" + width + "px;";
					w = dom.offsetWidth;
				}
				
				return {w: w, h: dom.offsetHeight};
			}
		}
	);

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android._IsList",
                         "mstrmojo.css",
                         "mstrmojo.dom",
                         "mstrmojo.array");

    var $DOM = mstrmojo.dom,
        $CSS = mstrmojo.css;

    
    function selectNode(touch, mthName) {
        var item = $DOM.findAncestorByAttr(touch.target, 'idx', true, this.domNode);
        if (item) {
            var v = item.value,
                ir = this.itemRenderer;

            ir[mthName](item.node, this.items[v], v, this);
        }
    }

    
    mstrmojo.android.SimpleList = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo.android._IsList, mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        
        {
            scriptClass: "mstrmojo.android.SimpleList",

            scrollerConfig: {
                bounces: false,
                showScrollbars: false
            },

            
            highlightOnSelect: false,

            
            hasEvenRows: false,

            
            rowHeight: -1,
            
            
            itemsFloat: false,

            
            init: function init(props) {
                this._super(props);

                
                if (!mstrApp.isTouchApp()) {
                    
                    $CSS.addWidgetCssClass(this, [ 'hosted' ]);
                }
            },

            
            updateItem: function updateItem(idx) {
                
                var div = document.createElement('div'),
                    item = this.items[idx],
                    me = this;

                
                div.innerHTML = this.itemRenderer.render(this.items[idx], idx, this);

                
                var newEl = div.firstChild;
                this.itemsContainerNode.replaceChild(newEl, this._getItemNode(idx));

                
                mstrmojo.array.forEach(item.dependents, function (d) {
                    me.updateItem(d._renderIdx);
                });

                return newEl;
            },

            
            setDimensions: function setDimensions(h, w) {
                
                if (this.height !== h || this.width !== w) {
                    
                    this.height = h;
                    this.width = w;

                    
                    var dn = this.domNode;
                    if (dn) {
                        dn.style.height = h;
                        dn.style.width = w;

                        
                        this.updateScroller();
                    }
                }
            },
            
            buildRendering: function buildRendering() {
                var rtn = this._super();
                
                
                if (this.itemsFloat) {
                    
                    var clearDiv = document.createElement('div');
                    clearDiv.className = 'clear-me';

                    
                    this.itemsContainerNode.appendChild(clearDiv);
                }

                return rtn;
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    icn = this.itemsContainerNode,
                    h = parseInt(this.height, 10);

                
                if (isNaN(h)) {
                    
                    h = this.domNode.clientHeight;
                }

                
                cfg.scrollEl = icn;

                
                cfg.noHScroll = true;

                
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                
                var offsetIdx = cfg.offsetIdx;
                if (offsetIdx) {
                    
                    delete cfg.offsetIdx;

                    
                    cfg.origin.y = this.getItemOffset(offsetIdx);
                }

                
                var offsetEnd = Math.max(this.getItemsContainerHeight() - h, 0);

                
                var enableScroll = cfg.vScroll = (offsetEnd !== 0 && cfg.noVScroll !== true);
                if (enableScroll) {
                    
                    cfg.offset = {
                        y: {
                            start: 0,
                            end: offsetEnd
                        }
                    };
                } else {
                    
                    cfg.offset = null;
                }

                return cfg;
            },

            
            getItemOffset: function getItemOffset(idx) {
                var node = this._getItemNode(idx);
                return Math.max(node.offsetTop - parseInt($CSS.getStyleValue(node, 'marginTop'), 10), 0);
            },

            
            getOffsetIndex: function getOffsetIndex() {
                var cfg = this.scrollerConfig,
                    origin = cfg && cfg.origin,
                    y = origin && origin.y;

                
                if (y) {
                    
                    var rowHeight = this.rowHeight;
                    if (this.hasEvenRows && rowHeight !== -1) {
                        
                        return Math.round(y / rowHeight);
                    }

                    var nodes = this.itemsContainerNode.childNodes,
                        min = 0,
                        max = nodes.length - 1;

                    
                    while (max >= min) {
                        var mid = min + max >> 1,
                            testNode = nodes[mid],
                            nodeY = testNode.offsetTop,
                            nodeH = testNode.offsetHeight;

                        
                        if (y < nodeY - nodeH) {
                            
                            max = mid - 1;

                        
                        } else if (y > nodeY + (nodeH * 2)) {
                            
                            min = mid + 1;

                        } else {
                            
                            return mid;
                        }
                    }
                }

                
                return 0;
            },

            
            scrollToItem: function scrollToItem(idx, duration) {
                
                var scroller = this._scroller;
                if (scroller) {
                    
                    scroller.scrollTo(0, this.getItemOffset(idx), duration || 0);
                }
            },

            
            getItemsContainerHeight: function getItemsContainerHeight() {
                var hasEvenRows = this.hasEvenRows,
                    rtn;

                
                if (!hasEvenRows || this.rowHeight === -1) {
                    
                    if (hasEvenRows) {
                        
                        var firstItem = this._getItemNode(0);
                        if (firstItem) {
                            
                            this.rowHeight = firstItem.offsetHeight;
                        }
                    } else {
                        
                        this.rowHeight = -1;
                    }

                    
                    rtn = this.itemsContainerNode.offsetHeight;
                } else {
                    
                    var items = this.items;
                    rtn = (this.rowHeight * ((items && items.length) || 0));
                }

                return rtn;
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                
                if (this.highlightOnSelect) {
                    
                    selectNode.call(this, touch, 'select');
                }

                this._super(touch);
            },

            touchSelectMove: function touchSelectMove(touch) {
                
                this._selectMove = true;

                this._super(touch);
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                var wasMoved = this._selectMove;
                delete this._selectMove;

                
                if (!wasMoved) {
                    
                    this.touchTap(touch);

                } else {
                    
                    if (this.highlightOnSelect) {
                        
                        selectNode.call(this, touch, 'unselect');
                    }
                }
            },
            
            
            touchend: mstrmojo.emptyFn
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android._IsList",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android.selectors._SupportsHoriz",
                         "mstrmojo.color",
                         "mstrmojo.css");

    
    function getItemRenderMethod(isSelected) {
        return function (el, item, idx, widget) {
            
            var style = el.style,
                clsMethod = 'remove',
                bgColor = 'transparent',
                color = 'inherit';

            
            if (isSelected) {
                
                clsMethod = 'add';
                bgColor = widget.selColor;
                color = widget._txtColor;
            }

            
            style.backgroundColor = bgColor;
            style.color = color;

            
            mstrmojo.css[clsMethod + 'Class'](el, mstrmojo.android._IsList.SELECTED_CLS);
        };
    }

    
    mstrmojo.android.selectors.LinkBar = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._TouchGestures, mstrmojo.android._IsList, mstrmojo._HasTouchScroller, mstrmojo.android.selectors._SupportsHoriz ],

        
        {
            scriptClass: "mstrmojo.android.selectors.LinkBar",

            
            selColor: '#60b1f6',

            minItemHeight: 29,

            getItemMarkup: function (item) {
                var itemMarkup = this._itemMarkup;
                if (!itemMarkup) {
                    
                    this._itemMarkup = itemMarkup = this._super(item).replace('{@n}', '<div>{@n}<div style="background-color:' + (this.parent.getFormats().color || '#000') + ';"></div></div>');
                }

                return itemMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                
                var props = this._super(item, idx);

                
                if (props.sel) {
                    
                    props.style += 'color:' + this._txtColor + ';background-color:' + this.selColor + ';';
                }

                return props;
            },

            preBuildRendering: function preBuildRendering() {
                
                this.cssClass += ' selector-linkbar';

                
                this._txtColor = mstrmojo.color.getContrastingColor(this.selColor, ['#ffffff', '#000000']);

                return this._super();
            }
        }
    );

    var linkBar = mstrmojo.android.selectors.LinkBar.prototype,
        itemRenderer = linkBar.itemRenderer;

    
    linkBar.itemRenderer = {
        render: itemRenderer.render,
        select: getItemRenderMethod(true),
        unselect: getItemRenderMethod(false)
    };

}());

(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo.android._IsList",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller");

    var DURATION = 200;

    
    function collapsePath() {
        
        if (!this._expanded) {
            
            return false;
        }

        
        this._tchHandler.clear();
        delete this._tchHandler;

        
        this._expanded = false;

        
        this.set('width', this._collapsedWidth);

        var id = this.id;
        window.setTimeout(function () {
            var path = mstrmojo.all[id];

            
            path.updateScroller(false, DURATION);

            
            path._scroller.scrollToEnd(true, false, DURATION);
        }, DURATION);

        
        return true;
    }

    
    mstrmojo.android.ui.PathView = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo.android._IsList, mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        
        {
            scriptClass: 'mstrmojo.android.ui.PathView',

            scrollerConfig: {
                bounces: false,
                showScrollbars: false
            },

            
            setDimensions: function setDimensions(h, w) {
                
                if (!this._expanded) {
                    
                    this.set('width', w);

                    
                    if (this.hasRendered) {
                        
                        this.updateScroller();

                        
                        var scroller = this._scroller;
                        if (scroller) {
                            
                            scroller.scrollToEnd(true, false, DURATION);
                        }
                    }
                }
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    icn = this.itemsContainerNode,
                    w = parseInt(this.width, 10);

                
                if (isNaN(w)) {
                    
                    w = this.domNode.clientWidth;
                }

                
                cfg.scrollEl = icn;

                
                cfg.noVScroll = true;

                
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                
                var offsetEnd = Math.max(icn.clientWidth - w, 0);

                
                var enableScroll = cfg.hScroll = (offsetEnd !== 0);
                if (enableScroll) {
                    
                    cfg.offset = {
                        x: {
                            start: 0,
                            end: offsetEnd
                        }
                    };
                } else {
                    
                    cfg.offset = null;
                }

                return cfg;
            },

            onitemsChange: function onitemsChange(evt) {
                
                var domNode = this.domNode;
                if (domNode) {
                    
                    domNode.style.height = (this.items.length) ? '' : 0;
                }

                
                if (!collapsePath.call(this) && evt.value.length > evt.valueWas.length) {
                    
                    this._scroller.scrollToEnd(true, false, DURATION);
                }
            },

            postselectionChange: function (evt) {
                var added = evt.added,
                    item = added && this.items[added[0]];

                
                if (item) {
                    
                    item.fn();
                }
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                
                if (this._expanded) {
                    
                    collapsePath.call(this);
                    return;
                }

                
                if (!this._scroller.canScroll()) {
                    
                    return;
                }

                
                var idx = this.getItemIdxTouch(touch);
                if (idx > -1) {
                    
                    this._collapsedWidth = this.width;

                    
                    var newWidth = mstrApp.getContentDimensions().w,
                        id = this.id;

                    
                    this._expanded = true;

                    
                    delete this.scrollerConfig.origin;

                    
                    this.set('width', newWidth + 'px');

                    
                    this.updateScroller(false, DURATION);

                    
                    this._tchHandler = mstrmojo.touchManager.attachEventListener('touchesBegin', id, function (evt) {
                        
                        if (evt.srcId !== id) {
                            
                            collapsePath.call(this);
                        }
                    });
                }
            },

            
            touchSelectEnd: mstrmojo.emptyFn
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.array",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $A = mstrmojo.array,
        $CSS = mstrmojo.css,
        $D = mstrmojo.dom,
        FirstMonthIdx = 1,
        SELECTED_CSS_CLASS = 'selected',
        HTML_ATTR_DAY = 'd',
        HTML_ATTR_MONTH = 'm',
        HTML_ATTR_YEAR = 'y';

    function processSelectedDate(node, d, m, y) {
        var i,
            sel = this.selected = this.selected || [],
            date;

        for (i = 0; i < sel.length; i++) {
            date = sel[i];
            if (date.day === d && date.month === m && date.year === y) {
                sel.splice(i, 1);
                return false;
            }
        }

        
        var newItem = {
            node: node,
            day: d,
            month: m,
            year: y
        };
        newItem.n = mstrmojo.date.formatDateInfo(newItem, mstrmojo.locales.datetime.DATEOUTPUTFORMAT);
        sel.push(newItem);

        return true;
    }
    
    function updateMonthViewHTML(y) {
        this.contentNode.innerHTML = this.markupBuilder.getContentHTML({
            m: 0, 
            y: y
        }, {
            m: 11,
            y: y
        }, {
            incl: false
        });
    }
    
    function updateItemsSelection(optionalItems, add) {
        var monthsHTML = this.contentNode.children,
        datesHTML;
    
        $A.forEach(optionalItems || this.selected, function(item) {
            
            if (item && item.year === this.current.y) {
                var selectedDateObj = new Date(item.year, item.month - FirstMonthIdx, 1);
                
                $A.forEach(monthsHTML, function(monthNode) {
                    if (parseInt(monthNode.getAttribute(HTML_ATTR_MONTH), 10) === item.month) {
                        $CSS.toggleClass(monthNode.getElementsByClassName('mstrmojo-CalendarMV-DatesList')[0].children[item.day + (selectedDateObj.getDay()) - 1], SELECTED_CSS_CLASS, add);
                        return false;
                    }
                });
            }
            
            datesHTML = undefined;
        }, this);
    }
    
    
    function scrollToMonth(m, oldM) {
        var monthCache = this.MONTH_CACHE,
            current = monthCache[parseInt(m, 10)],
            prev = monthCache[parseInt(oldM, 10)],
            SELECTED_MONTH_CSS_CLASS = 'selectedMonth';
        
        if (oldM !== undefined) {
            $CSS.toggleClass(prev.node, SELECTED_MONTH_CSS_CLASS, false);
        }
        
        $CSS.toggleClass(current.node, SELECTED_MONTH_CSS_CLASS, true);
        
        
        if (this._scroller) {
            this._scroller.scrollTo(0, current.top, 200);
        }
        
        
        if (!(mstrApp.isTablet() && mstrApp.isLandscape())) {
            this.headerNode.innerHTML = this.markupBuilder.getHeaderHTML(m, this.current.y);
        }
    }
    
    
    function updateCurrentYear(year, month) {
        
        updateMonthViewHTML.call(this, this.current.y);
        
        
        this.updateScroller();
    
        
        var i = 0,
            h = parseInt(this.height, 10) - this.headerNode.clientHeight, 
            contentNode = this.contentNode,
            rootOffsetTop = contentNode.offsetTop,
            children = contentNode.children,
            selected = this.selected,
            yearSelected = $A.find(selected, 'year', year),
            hasSelected = yearSelected !== -1, 
            monthCache = this.MONTH_CACHE = [{}];
        
        for (i = 0; i < children.length - 1; i ++) {
            var node = children[i],
                nodeHeight = node.clientHeight;
            
            monthCache.push({
                node: node,
                top: node.offsetTop - rootOffsetTop - (h - nodeHeight) / 2,
                height: nodeHeight
            });
        }
        
        
        this._scroller.scrollTo(0, 0);
        
        
        scrollToMonth.call(this, month || (hasSelected && selected[yearSelected].month) || FirstMonthIdx);
        
        this.selectItems();
    }
    
    
    mstrmojo.android.ui.CalendarMonthView = mstrmojo.declare(

        
        mstrmojo.Widget,

        
        [mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

        
        {
            scriptClass: "mstrmojo.android.ui.CalendarMonthView",

            config: undefined,

            markupString: '<div id="{@id}" class="mstrmojo-Calendar-MonthView">' +
                              '<div class="mstrmojo-CalendarMV-Header"></div>' +
                              '<div class="mstrmojo-CalendarMV-Content">' + 
                                  '<div></div>' +
                              '</div>' +
                          '</div>',

            markupSlots: {
                headerNode: function () { return this.domNode.firstChild; },
                contentNode: function () { return this.domNode.lastChild.lastChild; }
            },

            
            range: undefined,

            
            selected: undefined,

            
            multiSelect: true,

            
            current: undefined,
            
            scrollerConfig: {
                bounces: false,
                showScrollbars: false,
                showIndicators: false
            },

            postCreate: function postCreate() {
                
                if (this._super) {
                    this._super();
                }

                var calMonthWidget = this,
                    initialYear = this.initialYear,
                    initialMonth = this.initialMonth;
                
                if (isNaN(initialMonth) || isNaN(initialYear)) {
                    throw new Error(mstrmojo.desc(96, 'Error'));
                }
                
                
                this.current = new mstrmojo.Obj({
                    m: initialMonth,
                    y: initialYear,
                    
                    onyChange: function onyChanged() {
                        updateCurrentYear.call(calMonthWidget, this.y);
                    },
                    
                    _set_m: function _set_m(n, v) {
                        var valueWas = this.m;
                        
                        
                        this.m = v;
                        
                        scrollToMonth.call(calMonthWidget, this.m, valueWas);
                    }
                });
            },

            postBuildRendering: function postBuildRendering() {
                var builder = this.markupBuilder,
                    current = this.current;

                
                this._super();

                
                this.headerNode.innerHTML = builder.getHeaderHTML(current.m, current.y);
                
                
                updateCurrentYear.call(this, current.y, current.m);
                
                
                this._scroller.attachEventListener('scrollDone', this.id, function (evt) {
                    var monthCache = this.MONTH_CACHE,
                        abs = Math.abs,
                        scrolledPos = evt.y,
                        curr,
                        next,
                        newIdx,
                        i;
                    
                    
                    for (i = 1; i < monthCache.length - 1; i ++) {
                        curr = monthCache[i].top;
                        next = monthCache[i + 1].top;
                        
                        
                        if ((curr <= scrolledPos) && (scrolledPos <= next)) {
                            
                            newIdx = i + ((abs(next - scrolledPos) < abs(curr - scrolledPos)) ? 1 : 0);
                            
                            
                            break;
                        }
                    }
                    
                    this.current.set('m', newIdx);
                });
            },

            touchTap: function touchTap(touch) {
                
                var monthObj = $D.findAncestorByAttr(touch.target, HTML_ATTR_MONTH, true, this.domNode);
                
                if (monthObj) {
                    var item = touch.target,
                        d = parseInt(item.getAttribute(HTML_ATTR_DAY), 10),
                        m = parseInt(monthObj.value, 10),
                        y = parseInt(monthObj.node.getAttribute(HTML_ATTR_YEAR), 10);

                    if (!isNaN(d)) {
                        if (this.singleSelect) {
                            $A.forEach(this.selected, function(date) {
                                $CSS.toggleClass(date.node, SELECTED_CSS_CLASS, false);
                            });

                            this.selected = [];
                        }

                        $CSS.toggleClass(item, SELECTED_CSS_CLASS, processSelectedDate.call(this, item, d, m, y));
                        
                        this.raiseEvent({
                            name: 'selectionChanged',
                            items: this.selected
                        });
                    }
                    
                    if (!isNaN(m)) {
                        this.current.set('m', m);
                    }
                }
                
                
                return false;
            },
            
            
            selectItems: function selectItems(newItems) {
                updateItemsSelection.call(this, newItems, true);
            },
            
            unselectItems: function unselectItems(removedItems) {
                updateItemsSelection.call(this, removedItems, false);
            },
            
            touchSelectBegin: function touchSelectBegin(touch) {
            },

            touchSelectMove: function touchSelectMove(touch) {
            },

            touchSelectEnd: function touchTap(touch) {
            },
            
            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    icn = this.contentNode,
                    h = parseInt(this.height, 10);

                
                if (isNaN(h)) {
                    
                    h = this.domNode.clientHeight;
                }

                
                cfg.scrollEl = icn;

                
                cfg.noHScroll = true;

                
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                
                var offsetIdx = cfg.offsetIdx;
                if (offsetIdx) {
                    
                    delete cfg.offsetIdx;

                    
                    cfg.origin.y = this.getItemOffset(offsetIdx);
                }

                
                var offsetEnd = Math.max(icn.clientHeight + this.headerNode.clientHeight - h, 0);

                
                var enableScroll = cfg.vScroll = offsetEnd !== 0;
                if (enableScroll) {
                    
                    cfg.offset = {
                        y: {
                            start: 0,
                            end: offsetEnd
                        }
                    };
                } else {
                    
                    cfg.offset = null;
                }

                return cfg;
            },
            
            destroy: function destroy() {
                
                if (this.current) {
                    this.current.destroy();
                    delete this.current;
                }
                
                
                delete this.MONTH_CACHE;
                
                this._super();
            }

        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Label",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo._TouchGestures");

    mstrmojo.android.TextArea = mstrmojo.declare(
        mstrmojo.Label,

        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        {
            scriptClass: "mstrmojo.android.TextArea",

            markupString: '<div id="{@id}" class="mstrmojo-TextArea {@cssClass}" style="{@cssText}">' +
                              '<div>{@text}</div>' +
                          '</div>',

            markupMethods: {
                ontextChange: function () { this.domNode.firstChild.innerHTML = this.text || ''; },
                oncssTextChange: function () { this.domNode.style.cssText = this.cssText || ''; },
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? this.cssDisplay : 'none'; },
                onheightChange: function () { this.domNode.style.height = this.height || 'auto'; }
            },

            
            allowTouchBubble: false,

            updateScrollerConfig: function updateScrollerConfig() {

                var cfg = this._super(),
                    domNode = this.domNode,
                    scrollEl = domNode.firstChild,
                    h = parseInt(this.height, 10);

                
                if (isNaN(h)) {
                    
                    h = domNode.clientHeight;
                }

                
                cfg.bounces = false;

                
                cfg.scrollEl = scrollEl;

                
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                
                var offsetEnd = Math.max(scrollEl.offsetHeight - h, 0);

                
                var enableScroll = cfg.vScroll = (offsetEnd !== 0);
                if (enableScroll) {
                    
                    cfg.offset = {
                        y: {
                            start: 0,
                            end: offsetEnd
                        }
                    };
                }

                return cfg;
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo._IsPanelStack",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo._HasBuilder",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.TouchScroller",
                         "mstrmojo.css");

    var $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom,
        $M = Math,

        SWITCH_DURATION = 700;

    function clearAnimationTimeout() {
        
        var handle = this._animHandle;
        if (handle) {
            
            window.clearTimeout(handle);
            delete this._animHandle;
        }
    }

    function clearAnimationFlag() {
        
        delete this._animHandle;

        
        this._isAnimating = false;
    }

    
    function applyTransform(duration, value, force, simulateEvt) {
        
        var lastValue = this._translateX;
        if (force || value !== lastValue) {




            
            this._translateX = value;

            
            clearAnimationTimeout.call(this);

            
            if (duration) {
                
                this._isAnimating = true;
            }

            
            var nodeStyle = this.containerNode.style;
			nodeStyle[$DOM.CSS3_TRANSITION_DURATION] = duration + 'ms';
			nodeStyle[$DOM.CSS3_TRANSFORM] = $DOM.createTranslateString(-value);

            
            if (simulateEvt) {
                var id = this.id;
                this._animHandle = window.setTimeout(function () {
                    
                    var w = mstrmojo.all[id];

                    
                    if (mstrmojo.all[id]._isAnimating) {

                        
                        clearAnimationFlag.call(w);
                    }
                }, duration * 3);
            }

            if (this._scroller) {
                this._scroller.raiseEvent({
                    name: 'transformAnim',
                    x: value,
                    y: 0
                });
            }
        }
    }

    
    function renderSelector() {
        
        if (!this.defn.dk) {
            return;
        }
        var panels = this.children,
            i = 0,
            cnt = panels.length,
            selectedIdx = this.selectedIdx,
            btnMarkup = [];

        
        for (i = 0; i < cnt; i++) {
            
            btnMarkup.push('<div idx="' + i + '" class="');

            
            if (i === selectedIdx) {
                btnMarkup.push('on');
            }

            
            btnMarkup.push('"><div></div></div>');
        }

        
    	var selectorBtnsNode = this.selectorBtns,
    		dpi = mstrMobileApp.getDeviceDPI();

		
    	
		var tabWidths = {
				160:	26,
				213:	26,
				240:	38,
				320:	57
			},
			btnWidth = tabWidths[dpi] || ( tabWidths[160] * dpi / 160 );  
		
        selectorBtnsNode.style.width = (cnt * btnWidth) + 'px';

        
        selectorBtnsNode.innerHTML = btnMarkup.join('');

        
        this.selector.style.display = 'block';
    }

    
    mstrmojo.android.DocPanelStack = mstrmojo.declare(

        mstrmojo.Container,

        [ mstrmojo._Formattable, mstrmojo._IsSelectorTarget, mstrmojo._HasBuilder, mstrmojo._HasTouchScroller, mstrmojo._IsPanelStack, mstrmojo._TouchGestures ],

        
        {
            scriptClass: "mstrmojo.android.DocPanelStack",

            btnMarkup: '',

            markupString: '<div id="{@id}" title="{@tooltip}" class="mstrmojo-DocPanelStack {@cssClass}" style="{@domNodeCssText}">' +
                            '<div></div>' +
                            '<div class="mstrmojo-PanelSelector">' +
                                '<div class="mstrmojo-SelectorBtns"></div>' +
                            '</div>' +
                          '</div>',

            markupSlots: {
                containerNode: function () { return this.domNode.firstChild; },
                selector: function () { return this.domNode.lastChild; },
                selectorBtns: function () { return this.domNode.lastChild.firstChild; }
            },

            formatHandlers: {
                domNode: [ 'RW', 'B' ]
            },

            scrollerConfig: {
                bounces: false,
                showScrollbars: false,
                vScroll: false,
                hScroll: true
            },

            
            addChildren: function addChildren(panels, idx, silent) {

                this._super(panels, idx, silent);

                var containerNodeStyle = this.containerNode.style,
                    formats = this.getFormats(),
                    width = this._pnlWidth = parseInt(formats.width, 10),
                    height = parseInt(formats.height, 10),
                    selectedIdx = this.selectedIdx;

                
                var newPosition = this.selectedIdx * width;

                
                containerNodeStyle.width = (width * panels.length) + 'px';

                
                if (!$DOM.isWinPhone) {
                    applyTransform.call(this, 0, newPosition);
                } else {
                    containerNodeStyle.msTransform = newPosition;
                }

                
                var i = 0,
                    cnt = panels.length;

                for (i = 0; i < cnt; i++) {
                    var panel = panels[i];

                    
                    panel.visible = true;

                    
                    panel.selected = (i === selectedIdx);

                    
                    panel.updatePanelDimensions(i * width, height, width);
                }

                
                renderSelector.call(this);

                
                this.updateScroller();

                return true;
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                
                renderSelector.call(this);

                
                var id = this.id;
                mstrmojo.dom.attachEvent(this.containerNode, $DOM.CSS3_TRANSITION_END, function (evt) {

                    var widget = mstrmojo.all[id];
                    if (evt.target !== widget.containerNode) {
                        return true;
                    }





                    
                    clearAnimationTimeout.call(widget);

                    
                    evt.stopPropagation();

                    
                    clearAnimationFlag.call(widget);

                    return false;
                });

                return true;
            },

            
            setInfoWindowDimensions: function setInfoWindowDimensions(d) {
                
                var parent = this.parent;
                if (parent.scriptClass === 'mstrmojo.DocPortlet') {
                    
                    parent.setInfoWindowDimensions(d);
                }

                var h = d.h,
                    w = d.w,
                    domNodeStyle = this.domNode.style,
                    panels = this.children,
                    len = panels.length,
                    px = 'px',
                    i;

                
                domNodeStyle.height = h + px;
                domNodeStyle.width = w + px;

                
                this.containerNode.style.width = (w * len) + px;

                
                this._pnlWidth = w;

                
                this._translateX = (this.selectedIdx || 0) * w;

                
                for (i = 0; i < len; i++) {
                    
                    panels[i].updatePanelDimensions(i * w, h, w, true);
                }

                
                this.updateScroller();
            },

            getTitle: function getTitle() {
                
                return this.title;
            },

            
            initScroller: function initScroller(scroller) {
                
                scroller.attachEventListener('scrollDone', this.id, function (evt) {
                    
                    this._translateX = evt.x;
                });
            },

            
            updateScrollerConfig: function updateScrollerConfig() {
                var children = this.children,
                    length = children && children.length,
                    cfg = this._super();

                
                cfg.noVScroll = true;

                
                if (length) {
                    var position = this._translateX || 0,
                        width = this._pnlWidth,
                        offset;

                    
                    offset = {
                        start: $M.max(position - width, 0),                                      
                        end: $M.min(position + width, length * width - width)                    
                    };

                    
                    mstrmojo.hash.copy({
                        scrollEl: this.containerNode,

                        offset: {
                            x: offset,
                            scrollPast: false
                        },

                        origin: {
                            x: position,
                            y: 0
                        }
                    }, cfg);
                }

                return cfg;
            },

            onselectedIdxChange: function onselectedIdxChange(evt) {
                var selector = this.selectorBtns,
                    buttons = selector && selector.childNodes;

                
                if (buttons) {
                    
                    $CSS.addClass(buttons[evt.value], 'on');
                    $CSS.removeClass(buttons[evt.valueWas], 'on');
                }
            },

            
            onselectedKeyChange: function onselKeyChg(evt) {

                this._super(evt);

                
                var width = this._pnlWidth,
                    position = this.selectedIdx * width;

                
                if ($DOM.isWinPhone) {
                    
                    var containerNode = this.containerNode;
                    containerNode.style.position = 'relative';

                    
                    (new mstrmojo.fx.AnimateProp({
                        props: {
                            left: {
                                isStyle: true,
                                start: position,
                                stop: this.prevSelectIdx * width,
                                suffix: 'px',
                                ease: mstrmojo.ease.linear
                            }
                        },
                        duration: 0,
                        target: containerNode
                    })).play();

                } else {
                    
                    applyTransform.call(this, 0, position);
                }

                
                this.updateScroller(true);
            },

            touchBegin: function touchBegin(touch) {
                
                if (this._isAnimating) {
                    
                    touch.stop();





                    
                    return false;
                }

                
                if (!this.defn.sw && !$DOM.contains(this.selector, touch.target, true, this.domNode)) {
                    
                    return false;
                }





                return this._super(touch);
            },

            touchTap: function touchTap(touch) {
                var target = touch.target,
                    domNode = this.domNode;

                
                if ($DOM.contains(this.selector, target, true, domNode)) {
                    var selectorBtnsNode = this.selectorBtns,
                        panelIdx = -1;

                    
                    if ($DOM.contains(selectorBtnsNode, target, true, domNode)) {
                        
                        panelIdx = $DOM.findAncestorByAttr(target, 'idx', true, selectorBtnsNode).value;
                    } else {
                        
                        panelIdx = this.selectedIdx + ((touch.clientX - domNode.offsetLeft < (this._pnlWidth / 2)) ? -1 : 1);
                    }

                    
                    if (panelIdx > -1) {
                        
                        var panel = this.children[panelIdx];
                        if (panel) {
                            
                            this.selectPanel(panel.k);
                        }
                    }
                } else {
                    
                    var ctrl = this.controller;
                    if (ctrl && ctrl.viewTap) {
                        
                        ctrl.viewTap();
                    }
                }
            },

            touchSwipeBegin: function touchSwipeBegin(touch) {




                
                if (this.defn.sw || $DOM.contains(this.selector, touch.target, true, this.domNode)) {
                    return this._super(touch);
                }

                
                return this.bubbleTouchEvent(touch);
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                
                touch.evt.handled = true;

                
                mstrmojo.TouchScroller.ScrollIndicators.hideAll();

                var x = this._translateX || 0,
                    width = this._pnlWidth,
                    offset = this._scroller.offset.x,                                           
                    position = $M.max($M.min(x - touch.delta.x, offset.end), offset.start),     
                    delta = x - position,                                                       
                    absDelta = $M.abs(delta),                                                   
                    duration = SWITCH_DURATION,
                    isRevertAction = (absDelta < width * 0.2);

                
                if (isRevertAction) {
                    
                    position = x;
                    duration *= absDelta / width;
                } else {
                    
                    position = x + ((delta < 0) ? width : -width);
                    duration *= (width - absDelta) / width;
                }





                
                applyTransform.call(this, $M.round(duration), position, true, isRevertAction);
                
                this.selectPanel(this.children[position / width].k, true);
            }
        }
    );

}());
(function () {
        mstrmojo.requiresCls("mstrmojo._HasTouchScroller",
                             "mstrmojo.dom");

        var $D = mstrmojo.dom;

        function rectIntersection(a, b) {
                var x = Math.max(a.x, b.x);
                var y = Math.max(a.y, b.y);
                var w = Math.min(a.x + a.w, b.x + b.w) - x;
                var h = Math.min(a.y + a.h, b.y + b.h) - y;
                if (w < 0 || h < 0) {
                        return {
                                x : NaN,
                                y : NaN,
                                w : NaN,
                                h : NaN
                        };
                }
                return {
                        x : x,
                        y : y,
                        w : w,
                        h : h
                };
        }

        function copyRect (a){
                return {x: a.x, y: a.y, w: a.w, h: a.h};
        }

        mstrmojo.SmoothScroll = mstrmojo.provide(
                
                
                "mstrmojo.SmoothScroll",
                {

                        
                        
                        viewRect: null,
                        
                        scrollerRect: null,

                        
                        unitRect: null,

                        cachedUnits: [],

                        demarcationUnits: {left: null, right: null, top: null, bottom: null},

                        
                        viewCutX: function(){
                        },

                        storeUnits: function() {
                                this.cachedUnits = [];
                                var ir = copyRect(this.unitRect),
                                    len = Math.ceil(this.scrollRect.h / ir.h),
                                    i;

                                for(i = 0; i < len; i++, ir.y += ir.h){
                                        
                                        var unit = this.getUnitFromPoint(ir.x + ir.w/2, ir.y+ir.h/2);
                                        if(!unit){
                                                continue;
                                        }
                                        this.cachedUnits.push(unit);
                                        
                                }
                        },

                        appendUnits: function(i1, i2) {
                                var cus  = this.cachedUnits,
                                    i;
                                for(i = i1; i <= i2; i++){
                                        var unit = cus[i];
                                        if(!unit){
                                                return ;
                                        }
                                        if(unit.outside == true){
                                                unit.outside = false;
                                                var p = unit._parentNode,
                                                    cn = p.children;
                                                p.insertBefore(unit, cn[unit._oldIndex]);
                                                p.style.paddingTop = '';
                                                delete unit._parentNode;
                                                delete unit._oldIndex;
                                        }
                                }
                                console.log(i2-i1+1 + ' units added.');
                        },
                        removeUnits: function(i1, i2) {
                                var cus  = this.cachedUnits,
                                    i;
                                for(i = i1; i <= i2; i++){
                                        var unit = cus[i];
                                        if(!unit){
                                                return ;
                                        }
                                        if(unit.outside != true){
                                                var p = unit.parentNode,
                                                    cn = p.children;
                                                unit._parentNode = p;
                                                
                                                unit._oldIndex = 0;
                                                p.removeChild(unit);
                                                p.style.paddingTop = this.unitRect.h + 'px';
                                                unit.outside = true;
                                        }
                                }
                                console.log(i2-i1+1 + ' units removed.');
                        },
                                    

                        
                        viewCutY: function(e) {
                                if(!this.viewRect || !this.scrollRect || !this.unitRect){
                                        return;
                                }
                                var y1 = e ? e.y : this._scroller.origin.y,
                                    y2 = y1 + this.viewRect.h;
                                if(!this._scroller || !this._scroller.scrollEl){
                                        console.log("no scrollEl.");
                                        return ;
                                }

                                var scrollEl = this._scroller.scrollEl;

                                var i1 = Math.floor(y1 / this.unitRect.h),
                                    i2 = Math.floor(y2 / this.unitRect.h),
                                    cus = this.cachedUnits,
                                    len = cus.length;
                                    delta = 0;
                                this.removeUnits(0,i1-1);
                                
                                this.appendUnits(i1,i2);
                                this.removeUnits(i2+1, len);
                                
                                delta = i1;
                                
                                console.log("do viewCut.");
                        },

                        updateScroller: function(o, d) {
                                if(this._super){
                                        this._super(o, d);
                                }
                                var $P = mstrmojo.dom.position;
                                if(!this.unitRect || !this.unitRect.w || !this.unitRect.h){
                                        var su = this.cachedUnits[0];
                                        if(!su){
                                                return ;
                                        }
                                        this.unitRect =  $P(su);
                                }
                                if(this.viewNode){
                                        this.viewRect = $P(this.viewNode);
                                }
                                this.scrollRect = {x: this.unitRect.x, y: this.unitRect.y, w: this.unitRect.w, h:this.unitRect.h * this.cachedUnits.length}; 
                                if(!this.viewRect || !this.scrollRect || !this.unitRect){
                                        return;
                                }
                                
                                this.viewCutY(this._scroller.origin);
                        },
                        

                        getUnitFromPoint: function (x, y) {
                                var cache = [],
                                    found = false;
                                do{
                                        var target = document.elementFromPoint(x,y);
                                        if(target == lastTarget){
                                                break;
                                        }
                                        if(target.offsetHeight == this.unitRect.h && target.offsetWidth == this.unitRect.w){
                                                found = true;
                                        }else{
                                                target.__metaDisplay = target.style.display;
                                                cache.push(target);
                                                target.style.display = 'none';
                                        }
                                        var lastTarget = target;
                                }while(!found && target != document.body);
                                
                                var ret = target;
                                
                                while(cache.length){
                                        var target = cache.pop();
                                        target.style.display = target.__metaDisplay;
                                        delete target.__metaDisplay;
                                }

                                if(found){
                                        return ret;
                                }else{
                                        return null;
                                }
                        },

                        
                        postBuildRendering: function(c) {
                                if(this._super){
                                        this._super(c);
                                }
                                console.log("event binded!");
                                this.smoothSwipeListener = this._scroller.attachEventListener("scrollMoved", this.id, this.viewCutY);
                        },

                        unrender: function () {
                                
                                if(this._super){
                                        this._super();
                                }
                        }






                        










                }
        );
        
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android._IsList",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android.selectors._SupportsHoriz",
                         "mstrmojo.css");

    var itemMarkup,
        LINE_REG_EXP = /line-height:(\d*)px/,
        $CSS = mstrmojo.css;
    
    
    function toggleGlow(doGlow) {
        
        if (this.parent.defn.ct !== '4') {
            
            return;
        }

        mstrmojo.css[((doGlow) ? 'add' : 'remove') + 'Class'](this.domNode, 'glow');
    }

    
    mstrmojo.android.selectors.ButtonBar = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._TouchGestures, mstrmojo.android._IsList, mstrmojo._HasTouchScroller, mstrmojo.android.selectors._SupportsHoriz ],

        
        {
            scriptClass: "mstrmojo.android.selectors.ButtonBar",

            cssClass: 'selector-btnbar',

            getItemMarkup: function getItemMarkup(item) {
                if (!itemMarkup) {
                    itemMarkup = this._super(item).replace('{@n}', '<div>{@n}</div>');
                }

                return itemMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                
                var props = this._super(item, idx),
                    style = props.style,
                    lineHeight = style.match(LINE_REG_EXP);

                
                if (lineHeight) {
                    
                    props.style = style.replace(LINE_REG_EXP, 'line-height:' + (parseInt(lineHeight[1], 10) - 2) + 'px');
                }

                return props;
            },
            
            touchBegin: function touchBegin() {
                toggleGlow.call(this, true);
            },
            
            touchEnd: function touchEnd() {
                toggleGlow.call(this);
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.XtabModel",
                         "mstrmojo.array",
                         "mstrmojo.func");
    
    var MX = 'Metrics',
        SELECTOR_ACTION = 2;
    
    
   function _resolveCGBToTKS(cgbMap) {
       
       if (!cgbMap) return;
       
       var scm = this.scm,
           delim = '\u001E',
           i = 0,
           id = null,
           curSelector = null,
           cgb = null,
           cgbKey = null,
           targetKey = null,
           updatedTks = false;
       
       for (id in scm) {
           curSelector = scm[id];
           cgb = curSelector.cgb;
           
           
           
           for (i in cgb) {
               cgKey = cgb[i];
               targetKey = cgbMap[cgKey];
               
               
               if (targetKey) {
                   if (!curSelector.tks){
                       curSelector.tks = targetKey;
                       updatedTks = true;
                   } else if (curSelector.tks && (curSelector.tks.indexOf(targetKey) < 0)) {
                       curSelector.tks += delim + targetKey;
                       updatedTks = true;
                   }
               }
           }
       }
       
       return updatedTks;
   }
    
    function createSelectorMap () {
        var data = this.data,
            gridTitles = data.gts;
        
        
        if (!gridTitles) {
            
            return;
        }
        
        var map;
        
        
        mstrmojo.array.forEach([ gridTitles.row, gridTitles.col ], function (axis) {
            
            for (var i = 0, cnt = axis.length; i < cnt; i++) {
                
                var unit = axis[i];
                if (unit.sc) {
                    
                    map = map || {};
                    
                    
                    map[unit.id || MX] = unit.sc;
					
					if (unit.fid) { 
						map[unit.id + "_"+ unit.fid] = unit.sc;
					}
                }
            }
        });
        
        this.scm = map;
        
        _resolveCGBToTKS.call(this, this.docModel.getCGBMap());
    }
    
    function submitToDataService(methodName, args) {
        var dataService = this.getDataService();
        dataService[methodName].apply(dataService, args);
    }

    
    mstrmojo.DocXtabModel = mstrmojo.declare(
        mstrmojo.XtabModel,
        
        null,
        
        
        {            
            scriptClass: "mstrmojo.DocXtabModel",
            
            docModel: null,
            
            init: function init(props) {
                this._super(props);
                
                this.docModel.attachEventListener('CGBMapChange', this.id, function(evt) {
                    
                });                
            },
            
            ondataChange: function ondataChange(evt) {
                createSelectorMap.call(this);
            },
            
            getMessageId: function getMessageId() {
                return this.docModel.mid;
            },
            
            getDataService: function getDataService() {
                return this.docModel.getDataService();
            },            
            
            getAction: function getAction(cells, domNode, isReselect) {
                var cell = cells[0],
                    actionType = cell && cell.at;

                var action;
                
                if (actionType) {
                    
                    if (actionType & SELECTOR_ACTION) {
                        
                        var titleInfo = this.getCellTitleInfo(cell),
                            title = titleInfo && titleInfo.title,
                            titleId = title && title.id,
                            selectorControlMap = this.scm;
                    
                        
                        this.sti = {
                            titleId: titleId || MX
                        };
                        
                        
                        var sc = (titleId && selectorControlMap[titleId]) || selectorControlMap[MX];
                        
                        
                        if (sc) {
                            var xtab = this.xtab,
                                shouldDeselectCurrentCell = (xtab.allowToggleSelections && sc.all && isReselect),
                                selectAllElements = (titleInfo.isSrcTitle || shouldDeselectCurrentCell);
                            
                            this.sti.deselectCurrent = shouldDeselectCurrentCell;
                            
                            
                            action = {
                                h: 'onGridSelector',
                                a: {
                                    type: mstrmojo.EnumRWUnitType.GRID,
                                    anchor: domNode,
                                    ck: sc.ck,
                                    tks: sc.tks,
                                    eid: selectAllElements ? 'OA:(All)' : cell._e.id,
                                    ctlKey: sc.ckey,
                                    sliceId: xtab.sid,
                                    isUConDS: sc.isUConDS
                                }
                            };
                        }        
                    }
                }
                
                
                if ( ! action ) {
                    var action = this._super(cells);
                }
                
                if ( action && action.a ) {
                    action.a.sliceId = this.xtab.sid;
                }
                return action;

            },
            
            getDownloadAction: function getDownloadAction( rowPosition,  maxRows,   colPosition,  maxCols,  widgetID,  memo) {
                
                var action = this._super(rowPosition, maxRows, colPosition, maxCols, widgetID, memo);
                action.sliceId = this.xtab.sid;
                return action;
            },
            
            
            getDrillAction: function getDrillAction(cells) {
                var action = this._super(cells);                
                action.srcMsgId = this.docModel.mid;
                
                return action;
            },    
            
            sort: function sort (params, callback) {
                
                submitToDataService.call(this, 'sort', arguments);
            },
            
            pivot: function pivot (params, callback) {
                
                submitToDataService.call(this, 'pivot', arguments);
            },
            
            drillGrid: function drillGrid (params, callback) {
                submitToDataService.call(this, 'drillGrid', arguments);
            },
            
            downloadGridData: function downloadGridData (params, callback) {
                submitToDataService.call(this, 'downloadGridData', arguments);
            },
            
            loadLayout: function loadLayout(res) {
                
                this.docModel.loadLayout(res);
            }
        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.XtabModel",
                         "mstrmojo._IsRptModel",
                         "mstrmojo.func");

    
    mstrmojo.RptXtabModel = mstrmojo.declare(
        mstrmojo.XtabModel,

        [ mstrmojo._IsRptModel ],

        
        {
            scriptClass: "mstrmojo.RptXtabModel",

            init: function init(props) {
                this._super(props);
                this.dataService = (mstrApp.modelFactory && mstrApp.modelFactory.newDataService('Xtab', props)) || mstrApp.viewFactory.newXtabDataService(props);
            },

            getPageByTree: function getPageByTree(callback) {
                
                
                if ((!this.data.ghs || !this.data.ghs.phs) && !this.data.phs) {
                    
                    return;
                }
                this._super(callback);
            },


            
            downloadGridData: function downloadGridData(params) {
                var widgetID = params.xtabId,
                    memo = params.memo,
                    w = mstrmojo.all[widgetID],
                    dataService = this.getDataService();

                var callback = {
                    
                    success: function (res) {
                        
                        if (res && w) {
                            
                            w.dataDownloaded({
                                data: res
                            }, memo);

                            
                            w.updateXtabStyles(res.cssString);
                        }
                    },

                    
                    failure: function () {
                        if (w.dataDownloadErr) {
                            w.dataDownloadErr();
                        }
                    }
                };

                
                dataService.downloadGridData(params, callback);
            },

            destroy: function destroy() {
                if (this.dataService) {
                    this.dataService.destroy();
                }
                this._super();
            }
        }
    );
}());
(function () {
    
    mstrmojo.requiresCls("mstrmojo.DocModel",
                         "mstrmojo.func",
                         "mstrmojo.hash");

    var $FWM = mstrmojo.func.wrapMethods,
        $HSH = mstrmojo.hash;
    
    function wrapCallback (callback) {
        var model = this;
        return $FWM({
            success: function (res) {
                mstrmojo.hash.copy(res, model);
            }
        }, callback);
    }
    
    function submitToDataService(methodName, args) {
        var dataService = this.getDataService();
        dataService[methodName].apply(dataService, args);
    }

    function getPromptsCallback() {
        var model = this;
        
        return function (res) {
            model.setPrompts(model.getDataService().getPrompts());
        };
    }

    mstrmojo.ResultSetDocumentModel = mstrmojo.declare(

        mstrmojo.DocModel,
        
        null,
        
        
        {
            scriptClass: 'mstrmojo.ResultSetDocumentModel',
            
            setPrompts: function setPrompts(prompts) {
                this.prompts = prompts;
                if ( prompts ) {
                    prompts.host = this;
                }
            },
                
            execute: function execute(params, callback, resParams) {
                var model = this,
                
                    
                    
                    p = $HSH.copy( params, {
                        dssId: params.did
                    } ), 
                    cbs;
                                        
                p.objType = params.objType || params.t;

                if ( params.forceExec) {
                    
                    p.freshExec = true;
                    p.doNotUpdateCaches = true;
                }
                
                cbs = $FWM({
                    success: function (res) {
                        $HSH.copy(res, model);
                        
                        
                        
                        model.setPrompts(model.getDataService().getPrompts());
                    },
                    prompts: getPromptsCallback.call(model)
                    
                }, callback);
                
                submitToDataService.call(this, 'execute', [p, model.newCallback($HSH.copy({method: 'execute'}, cbs)), resParams]);
            },
            
            open: function open(params, callback) {
                var model = this;
                
                if(params.data) {
                    $HSH.copy(params.data, model);
                }
                
                if(callback.success) {
                    callback.success(model);
                }
                
                if(callback.complete){
                    callback.complete(model);
                }
            },
            
            answerPrompts: function answerPrompts(callback) {
                submitToDataService.call(this, 'answerPrompts', [ this.prompts, wrapCallback.call(this, callback) ]);
            },
            
            linkToObject: function linkToObject (params, callback) {
                var model = this,
            		cb = $FWM({
	                    prompts: getPromptsCallback.call(this)
	                }, callback),
	                sc = cb.success;
                cb.success = function(res) {
                    $HSH.copy(res, model);
                    
                    model.setPrompts(model.getDataService().getPrompts());
                    
                    
                	model.gbElements = params.groupByElements;
                	sc(res);
                	delete model.gbElements;
                };
                submitToDataService.call(this, 'linkToObject', [ params, cb]);
            },
            
            getPageByTree: function getPageByTree(callback) {
            	this.getDataService().getPageByTree(callback);
            }

        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo.EnumRWUnitType");

    var HTML_CONTAINER = mstrmojo.EnumRWUnitType.HTMLCONTAINER;

    
    mstrmojo.DocTextfield = mstrmojo.declare(
        
        mstrmojo.Container,

        
        [ mstrmojo._Formattable ],

        
        {
            scriptClass: "mstrmojo.DocTextfield",

            markupString:   '<div id="{@id}" class="mstrmojo-DocTextfield {@cssClass}" title="{@tooltip}" style="{@domNodeCssText}">' +
                                '<div class="mstrmojo-DocTextfield-valueNode" style="{@valueNodeCssText}" mstrAttach:click >{@v}</div>' +
                                '{@buttonNodeMarkup}' +
                            '</div>',

            markupSlots: {
                valueNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                domNode:  [ 'T', 'z-index' ],
                valueNode: [ 'D', 'B', 'F', 'P', 'background-color', 'fx', 'text-align', 'white-space', 'overflow' ]
            },

            markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },

            
            update: function update(node) {
                var d = node.data,
                    v = d.v || '';

                
                if (node.defn.t === HTML_CONTAINER) {
                    
                    var div = document.createElement('div');
                    div.innerHTML = '<textarea>' + v + '</textarea>';
                    v = '<div style="display:none">&nbsp;</div>' + div.firstChild.value;
                    
                    div = null;
                }

                
                this.v = v;

                
                if (this.thresholdId || d.tid) {
                    
                    delete this.fmts;
                }

                
                this.thresholdId = d.tid;

				this.set('visible', !node.data.hidden);

                if (this._super) {
                    this._super(node);
                }
            },

            
            postBuildRendering: function postBuildRendering() {

                var $D = mstrmojo.dom,
                    f = this.getFormats(),
                    rotateValue = f.fx && f.fx.rt,
                    i,
                    len;

                
                if (rotateValue && !$D.isIE && $D.supports($D.cssFeatures.TEXT_ROTATION)) {
                    
                    
                    var dn = this.domNode;

                    
                    switch (rotateValue) {
                    case 1:    
                        
                        
                        
                        
                        dn.style.left = (parseInt(f.left, 10) + dn.offsetHeight) + 'px';
                        break;

                    case 3: 
                        
                        dn.style.top = (parseInt(f.top, 10) + dn.offsetWidth) + 'px';
                        break;
                    }
                }

                
                if (this.defn.t === HTML_CONTAINER) {
                    
                    var scripts = this.domNode.getElementsByTagName('script');
                    for (i = 0, len = scripts.length; i < len; i++) {
                        
                        eval(scripts[i].innerHTML);
                    }
                }

                return this._super();
            },

            getAnchor: function getAnchor() {
                return this.valueNode;
            }

        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._IsPopup",
                         "mstrmojo._CanAutoClose");

    
    mstrmojo.Popup = mstrmojo.declare(
        
        mstrmojo.Container,
        
        [mstrmojo._IsPopup, mstrmojo._CanAutoClose],
        
        {
            scriptClass: "mstrmojo.Popup",

            shadowNodeCssClass: "mstrmojo-popup-shadow",

            contentNodeCssClass: "mstrmojo-popup-content",

            cssDisplay : "block",

            markupString: '<div id="{@id}" class="mstrmojo-Popup {@cssClass}" style="{@cssText}" '
                + '><div class="mstrmojo-Popup-shadow {@shadowNodeCssClass}"></div><div class="mstrmojo-Popup-content {@contentNodeCssClass}"></div>',

            markupSlots: {
                containerNode: function () { return this.domNode.lastChild; },
                shadowNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? this.cssDisplay : 'none'; },
                onleftChange: function () { this.domNode.style.left = (this.left != null) ? this.left : ''; },
                ontopChange: function () { this.domNode.style.top = (this.top != null) ? this.top : ''; }
            },
            
            
            buildRendering: function buildRendering() {
                
                var ph = this.placeholder;

                
                if (this._super()) {
                    
                    if (!this.parent && !ph) {
                        var node = this.placeNode || document.body;

                        
                        node.appendChild(this.domNode);
                    }
                    return true;
                }

                return false;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container");

    var $WIDGET = mstrmojo.Widget;

    mstrmojo.Box = mstrmojo.declare(

        mstrmojo.Container,

        null,

        {
            scriptClass: "mstrmojo.Box",

            markupString: '<div id="{@id}" class="mstrmojo-Box {@cssClass}" style="{@cssText}"></div>',

            markupSlots: {
                containerNode: function () { return this.domNode; }
            },

            markupMethods: {
                onvisibleChange: $WIDGET.visibleMarkupMethod,
                onheightChange: $WIDGET.heightMarkupMethod,
                onwidthChange: $WIDGET.widthMarkupMethod
            }
        }
    );

}());
(function() {
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.Container", "mstrmojo._IsPopup", "mstrmojo.boxmodel", "mstrmojo.css");

    var _B = mstrmojo.boxmodel,
    _D = mstrmojo.dom,
    _CURSOR_HEGIHT = 20;
    
    function attScrll(o, me) {
        var p = o && o.parent;
        while (p){
            if (p.connectScrollbox){
                p.connectScrollbox(me);
            }
            p = p.parent;
        }
    }
    
    function detScrll(o, me) {
        var p = o && o.parent;
        while (p){
            if (p.disconnectScrollbox){
                p.disconnectScrollbox(me);
            }
            p = p.parent;
        }
    }
    
    var _position = function(me){
        
        if (me.visible) {
            
            
            var ref = me.refNode,
                
                
                
                offset = ref ? _B.offset(ref, document.body) : {
                                                                left: _D.getHorizontalScroll(),
                                                                top: _D.getVerticalScroll()
                                                            },
            s = me.domNode.style, 
            c = me.containerNode,
            l = me.left,
            t = me.top,
            p = me.posType,
            T = mstrmojo.tooltip,
            p_r = (p === T.POS_TOPRIGHT) || (p === T.POS_BOTTOMRIGHT), 
            p_b = (p === T.POS_BOTTOMLEFT) || (p === T.POS_BOTTOMRIGHT) || (p === T.POS_BOTTOMCENTER), 
            offLeft = offset.left,
            offTop = offset.top,
            containerOffWidth = c.offsetWidth;
                                                            
            if (l !== null) {
                
                s.left = Math.max(parseInt(l, 10) + offLeft - (p_r ? (containerOffWidth):
                                                                     ((p===T.POS_BOTTOMCENTER) ? (containerOffWidth / 2) : 0))
                                   , 0) + 'px';                
            }
            if (t !== null){
                
                s.top = Math.max(parseInt(t, 10) + offTop - ((p_b)? (c.offsetHeight):0), 0) + 'px';
            }
        }
    };

    var _repaint = function(me) {
        me.containerNode.className = ('mstrmojo-Tooltip-content ' + me.contentNodeCssClass);
        me.containerNode.style.cssText = me.contentNodeCssText;
        me.containerNode.innerHTML = me.content;
        if (!me.content) {
            me.set('_tempVis', false);
        } else {
            me.set('_tempVis', true);
        }
        _position(me);
        if (me.optimizePos) {
        	
        	me.optimizePos();
        }
    };

    
    function _dlyPaint(me) {
        if (!me._dp){
            me._dp = window.setTimeout(function() {
                me._dp = null;
                _repaint(me);
            }, 50);
        }
    }
    
    var _update = function(me, w, e, win) {
        
        var r = w && (w.richTooltip || w.tooltip),
            mp = e ? _D.getMousePosition(e, win || self) : null,
            isStr = r && (typeof(r) === 'string'),
            l = isStr ? null : (r && r.left || 0),
            t = isStr? null: (r && r.top || 0);
        me.set('contentNodeCssClass', isStr ? '' : (r && r.contentNodeCssClass || ''));
        me.set('contentNodeCssText', isStr ? '' : (r && r.contentNodeCssText || ''));
        me.set('content', (isStr) ? r : (r && r.content || ''));
        me.set('refNode', isStr ? null : r && r.refNode || null);
        me.set('posType', isStr ? 1: r && r.posType || 1);
        me.set('left', (isStr || l === undefined || l === null) ? (mp && mp.x || me.left) : l);
        me.set('top', (isStr || r === undefined || r === null) ? (mp && (mp.y + _CURSOR_HEGIHT) || me.top): t);        
    };
    
    mstrmojo.Tooltip = mstrmojo.declare(
            mstrmojo.Container,
            [mstrmojo._IsPopup],
            {
                scriptClass: 'mstrmojo.Tooltip',
                
                content: null,
                
                top: null,
                
                left: null,
                
                refNode: null,
                
                posType: 1, 
                
                markupString: '<div id="{@id}" class="mstrmojo-Tooltip {@cssClass}" style="{@cssText}">' +
                                '<div class="mstrmojo-Tooltip-shadow {@shadowNodeCssClass}"></div>' + 
                                '<div class="mstrmojo-Tooltip-content {@contentNodeCssClass}" style="{@contentNodeCssText}"></div>' +
                              '</div>',
                
                markupSlots: {
                    containerNode: function(){ return this.domNode.lastChild; },
                    shadowNode: function() { return this.domNode.firstChild; }
                },
                
                markupMethods: {
                    onvisibleChange: function(){ 
                        if (this.visible){
                            
                            var s = this.domNode.style;
                            s.visibility = 'hidden';
                            s.display = 'block';
                            
                            _position(this);
                            s.visibility = this.content? 'visible' : 'hidden';
                        } else {
                            this.domNode.style.display = 'none'; 
                        }
                    },
                    on_tempVisChange: function() {
                        this.domNode.style.visibility = this._tempVis ? 'visible' : 'hidden'; 
                    },
                    onleftChange: function(){ _dlyPaint(this); },
                    ontopChange: function(){ _dlyPaint(this); },
                    onrefNodeChange: function() {_dlyPaint(this); },
                    onposTypeChange: function() {_dlyPaint(this); },
                    oncontentNodeCssClassChange: function (){_dlyPaint(this);},
                    oncontentNodeCssTextChange: function() {_dlyPaint(this);},
                    oncontentChange: function() {_dlyPaint(this);}
                },
                
                preBuildRendering: function() {
                    
                    if (!this.slot && !this.placeholder) {
                        this.placeholder = document.body.appendChild(document.createElement('div'));
                    }
                    if (this._super) {
                        this._super();
                    }
                },
                _on_tooltip_change: function(evt){
                    _update(this, evt && evt.src);
                },
                
                _set_opener: function(n, v) {
                    var ov = this.opener;
                    
                    
                    
                    
                    if ((v !== ov)){
                        if (v) {
                            attScrll(v, this);
                        }
                        if (ov) {
                            detScrll(ov, this);
                        }                        
                        if (ov && ov.detachEventListener) {
                            ov.detachEventListener(this._richSubs);
                            ov.detachEventListener(this._ttpSubs);
                        }
                        if (v && v.attachEventListener) {
                            this._richSubs = v.attachEventListener('richTooltipChange', this.id, '_on_tooltip_change');
                            this._ttpSubs = v.attachEventListener('tooltipChange', this.id, '_on_tooltip_change');
                        }
                        this.opener = v;
                        return true;
                    }
                    return false;
                },
                
                updatePopupConfig: function(config, opener){
                    _update(this, opener, config && config.e, config && config.win);
                },
                
                onscroll: function() {
                    
                    if (this.visible && this.nudge) {
                        this.nudge();
                    }
                }
            }
    );

    
    var ttpInst = null;
    mstrmojo.tooltip = {
            
            POS_TOPLEFT: 1,
            POS_BOTTOMLEFT: 2,
            POS_TOPRIGHT: 3,
            POS_BOTTOMRIGHT: 4,
            POS_BOTTOMCENTER: 5,
            
            open: function(opener, e, win, config) {
                
                
                if (!ttpInst || !mstrmojo.all[ttpInst.id]) {
                    ttpInst = new mstrmojo.Tooltip();
                }
                
                if (!config) {
                    config = {};
                }
                config.e = e;
                config.win = win;
               ttpInst.open(opener, config);
            },
            
            close: function() {
                if (ttpInst) {
                    ttpInst.close();
                }
            }
    };
})();
(function(){


    mstrmojo.requiresCls("mstrmojo._HasBuilder",
                         "mstrmojo._HasLayout",
                         "mstrmojo.Container");

    var DARK_BORDER_WIDTH = 1;

    mstrmojo.maps.jsmap.AndroidDocMapInfoWindow = mstrmojo.declare(
        
        mstrmojo.Container,
        
        
        [ mstrmojo._HasBuilder, mstrmojo._HasLayout ],
        
        
        {
            scriptClass: "mstrmojo.maps.jsmap.AndroidDocMapInfoWindow",
            
            markupString: '<div class="mstrmojo-DocInfoWindow-wrapper">' +
                              '<div id="{@id}" class="mstrmojo-DocInfoWindow"></div>' +
                          '</div>',

            markupSlots: {
                infoNode: function() { return this.domNode.firstChild; },
                containerNode: function() { return this.domNode.firstChild; }
            },
                        
            getChildren: function getChildren(){
                
                var m = this.model,
                    c = m.getLayoutDataCache(m.getCurrentLayoutKey())[this.psId],
                    f = c.defn.fmts;
                
                
                f.left = DARK_BORDER_WIDTH + 'px';
                f.top = DARK_BORDER_WIDTH + 'px';
                
                return [c];
            }
        });

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo._HasBuilder",
                         "mstrmojo._CanMeasureChildren",
                         "mstrmojo._CanRenderDocOnScroll",
                         "mstrmojo.dom");

    
    mstrmojo.DocLayout = mstrmojo.declare(
        
        mstrmojo.Container,

        
        [mstrmojo._Formattable, mstrmojo._HasBuilder, mstrmojo._CanMeasureChildren, mstrmojo._CanRenderDocOnScroll],

        
        {
            scriptClass: "mstrmojo.DocLayout",

            markupString: '<div id="{@id}">' +
                              '<div class="mstrmojo-DocLayout {@cssClass}" style="{@domNodeCssText}"></div>' +
                          '</div>',

            markupSlots: {
                containerNode: function () { return this.domNode.firstChild; },
                popupNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                domNode: [ 'B', 'background-color', 'D', 'min-height', 'width' ]
            },

            alias: 'docLayout',
            markupMethods: {
                onminHeightChange: function () {
                    var mh = this.minHeight;
                    if (!mh) {
                        var fmts = this.getFormats();
                        mh = fmts && fmts['min-height'];
                    }
                    if (mh) {
                        this.containerNode.style[mstrmojo.css.MINHEIGHT] = mh;
                    }
                }
            },

            getHeight: function getHeight() {
                var h = 0;

                
                mstrmojo.array.forEach(this.children, function (child) {
                    h += child.height();
                });

                
                return h || this.containerNode.offsetHeight;
            },

            getWidth: function getWidth() {
                
                var children = this.children;
                return (children && children.length) ? children[0].width() : this.containerNode.offsetWidth;
            },

            preBuildRendering: function preBuildRendering() {
                var f = this.getFormats();

                
                if (f && f['min-width'] !== undefined) {
                    
                    f.width = f['min-width'];
                }

                this._super();
            },

            
            renderChildren: function renderChildren() {
                this._super();

                this.resizeOrReposition();
            },

            
            resizeOrReposition: function resizeOrReposition() {
                var containerNode = this.containerNode;

                
                if (!!this.defn.aw) {
                    
                    var aws = this.model.getAutoWidthIDs(),
                        len = (aws && aws.length) || 0,
                        mx = 0,             
                        all = mstrmojo.all,
                        i;

                    
                    if (!len) {
                        
                        return;
                    }

                    
                    for (i = 0; i < len; i++) {
                        
                        mx = Math.max(this._getWidgetRightMostPosition(all[aws[i]]), mx);
                    }

                    
                    mx = Math.max(this.getLayoutMinWidth(), mx);

                    
                    if (mx > parseInt(this.getFormats().width, 10)) {
                        
                        containerNode.style.width = mx + 'px';
                    }
                }

                
                var zoomToFit = this.model.zt;
                if (mstrApp.isMobile && zoomToFit) {

                    
                    var viewerNode = this.parent.domNode;
                    if (viewerNode) {

                        
                        var controller = this.model.controller,
                            isPortrait = !!controller.orientation,
                            verticalMargin = 0,                        
                            parent = this.parent,
                            parentHeight = parent.getHeight() - parent.fixedHeaderNode.clientHeight - parent.fixedFooterNode.clientHeight; 

                        
                        if (zoomToFit === 2) {

                            
                        	
                            if (!controller.toolBarDelegated) {
                            	parentHeight -= controller.getBottomToolBarHeight();
                            }

                            
                            verticalMargin = Math.round(isPortrait ? Math.max((parentHeight - this.getHeight()), 0) / 2 : 0) + 'px';
                        }

                        
                        containerNode.style.margin = verticalMargin + ' auto';

                        
                        var me = this;
                        window.setTimeout(function () {
                            controller.nudgeWidget(me.id, {
                                left: containerNode.offsetLeft,
                                top: containerNode.offsetTop
                            });
                        }, 0);
                    }
                }
            },

            
            getLayoutMinWidth: function getLayoutMinWidth() {
                return 0;
            },

            
            _getWidgetRightMostPosition: function getLayoutMinWidth(w) {
                return parseInt(w.getFormats().left, 10) + (w.getDim && w.getDim().w || w.domNode.offsetWidth);
            },

            
            renderCtrlsInViewport: function renderCtrlsInViewport() {
                this._super();

                this.resizeOrReposition();
            },

            
            adjustAutoWidth: function adjustAutoWidth(w) {
                
                if (!this.defn.aw || !w) {
                    
                    return;
                }

                
                var cs = this.containerNode.style,
                    wd = parseInt(cs.width, 10) || 0;      

                
                var me = this;
                window.setTimeout(function(){
                    var mx = me._getWidgetRightMostPosition(w);

                    
                    if (mx > wd) {
                        
                        cs.width = mx + 'px';
                    }
                }, 1);
            },

            
            _getModelChildNodes: function _getModelChildNodes(node, isPartial, start, count, includeTotal) {
                
                
                var nds = this.model.getNonFixedSections(node, isPartial);

                
                var len = nds.length;

                count = isNaN(count) ? len : count;
                start = start || 0;

                if (start > 0 || count < len) {
                    nds = nds.slice(start, start + count);
                }

                return includeTotal ? {
                    nodes: nds,
                    total: len
                } : nds;
            },
            
            getChildren: function getChildren(node, isPartial, start, count, includeTotal) {
                return this._getModelChildNodes(node || this.node, isPartial || false, start, count, includeTotal);
            },

            getCaptureDimensions: function getCaptureDimensions() {
            	var domNode = this.domNode,
            		position = {};

            	if(!this.domNode) {
            		return;
            	}

            	position = mstrmojo.dom.position(domNode);

            	position.w = Math.min(domNode.offsetWidth, position.w);
            	position.h = Math.min(domNode.offsetHeight, position.h);

            	return position;
            },

            preserveChildDomOrder: false,

            postBuildRendering: function postBuildRendering(){

            	if (window.mstrMobileApp !== undefined) {
            		this.defn.lastOrientation = mstrMobileApp.getOrientation();
            	}

            	this._super();
            }

        }
    );

}());
(function(){

	mstrmojo.requiresCls("mstrmojo.Container",
						 "mstrmojo._HasScrollbox",
						 "mstrmojo._HasLayout",
						 "mstrmojo._ShowsStatus");
	

	function getDimension(dimension) {
	    var domNode = this.domNode,
	    x = parseInt(this[dimension.toLowerCase()], 10);

	    return (isNaN(x)) ? domNode['offset' + dimension] : x;
	}	
	
	
	mstrmojo.DocLayoutViewer = mstrmojo.declare(
		
		mstrmojo.Container,
		
		
		[mstrmojo._Formattable, mstrmojo._HasScrollbox, mstrmojo._HasLayout, mstrmojo._ShowsStatus],
		
		
		{
			scriptClass: "mstrmojo.DocLayoutViewer",
			
			markupString: '<div id="{@id}" class="mstrmojo-DocLayoutViewer {@cssClass}" style="{@domNodeCssText}">' +
							'<div></div>' +
							'<div>' +
								'<div class="mstrmojo-progress" style="display:none">' +
									'<div class="mstrmojo-progress-barbg">' +
										'<div class="mstrmojo-progress-bar"></div>' +
									'</div>' +
									'<div class="mstrmojo-progress-text"></div>' +
								'</div>' +
								'<div id="{@id}_fh"></div>' + 
								'<div id="{@id}_scrollboxNode" class="mstrmojo-DocLayoutViewer-layout" style="{@_scrollCssText}"></div>' +
								'<div id="{@id}_ff"></div>' + 
							'</div>' +
							'<div></div>' +
						  '</div>',
						
			markupMethods: {
				onvisibleChange: function(){ this.domNode.style.display = this.visible ? 'block' : 'none'; },
				onborderChange: function(){ if (this.border) { this.domNode.style.border = this.border; }}
			},
			
			markupSlots: {
				groupBy: function(){ return this.domNode.firstChild; },
				layout: function() { return this.domNode.childNodes[1].childNodes[2]; },
				scrollboxNode: function() { return this.domNode.childNodes[1].childNodes[2]; },
				containerNode: function() { return this.domNode.childNodes[1].childNodes[2]; },
				incFetchNode: function() { return this.domNode.lastChild; },
				fixedHeaderNode: function() {return this.domNode.childNodes[1].childNodes[1]; },
				fixedFooterNode: function() {return this.domNode.childNodes[1].childNodes[3]; },
				
				_STATUS: function(){ return this.domNode.childNodes[1].firstChild; },
				_STATUS_TXT: function(){ return this.domNode.childNodes[1].firstChild.lastChild; },
				_STATUS_BAR: function(){ return this.domNode.childNodes[1].firstChild.firstChild.firstChild; }
			},
			
			layoutConfig: {
				h: {
					groupBy: 'auto',
					fixedHeaderNode: 'auto',
					layout: '100%',
					fixedFooterNode: 'auto',
					incFetchNode: 'auto'
				},
				w: {
					layout: '100%'
				}
			},

			
			scrollboxHeightFixed: true,
			scrollboxWidthFixed: true,
			
			
			getHeight: function getHeight() {
			    return getDimension.call(this, 'Height');
			},

			
			getWidth: function getWidth() {
			    return getDimension.call(this, 'Width');
			},   
            
			
			afterLayout: function afterLayout() {
				this._super();

				
				this.notifyScrollListeners();
			},
			
			preBuildRendering: function preBuildRendering() {
				
				
				
				if ( this.parent ) {
					var p = this.parent[this.slot].style,
						h = this.height,
						w = this.width;
					
					this.height = (h !== 'auto') ? h : p.height;
					this.width = (w !== 'auto') ? w : p.width;
				}
				
				
				this.zf = this.model.zf;
				this.bs = this.model.bs;
				
				






























				
				return this._super ? this._super() : true;
			},
			setSlotDimensions: function setSlotDimensions(slot, h, w) {
				
				if (slot === 'layout') {
					
					
					
					this.scrollboxHeight = parseInt(h, 10);
					this.scrollboxWidth = parseInt(w, 10);
				}
				
				this._super(slot, h, w);
			}, 
			
			onaddChild: function onaddChild(evt) {
				if (!isNaN(evt.index)) {
					var nc = this.children[evt.index];
					if (nc && nc.slot === "groupBy") {
						this.docGroupBy = nc;
					}
				}
			}
		}
	);
	
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo._ContainsDocObjects",
                         "mstrmojo._HasBuilder",
                         "mstrmojo.css",
                         "mstrmojo.array");

    var $CSS = mstrmojo.css;

    var ITEM_SPA = 2;
    
    function passDirtyKeyToAncestorPanel(pnl, methodName, key) {
        
        var p = pnl.parent.parent;

        
        if (p && p instanceof mstrmojo.DocPanel) {
            
            p[methodName + 'DirtyKey'](key);
        }
    }

    
    function setDirtyChildrenOnDescendant(key, panel, allDirty) {
        
        if (key === panel.k) {
            
            mstrmojo.array.forEach(panel.children, function (child) {
                
                if (child.setDirtyChildren) {
                    
                    child.setDirtyChildren(allDirty);
                }
            });
        }
    }

    
    mstrmojo.DocPanel = mstrmojo.declare(
        
        mstrmojo.Container,

        
        [ mstrmojo._Formattable, mstrmojo._ContainsDocObjects, mstrmojo._HasBuilder ],

        
        {
            scriptClass: "mstrmojo.DocPanel",

            
            visible: false,

            
            selected: false,

            cssDisplay: 'block',

            
            
            topStart: ITEM_SPA,
            
            
            contentWidth: 0,
            
            markupString: '<div id="{@id}" class="mstrmojo-DocPanel {@cssClass}" style="{@cssText}{@domNodeCssText}">' +
                              '<div class="mstrmojo-DocSubPanel-content" style="height:100%;width:100%;position:absolute;{@containerNodeCssText}"></div>' +
                          '</div>',

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; }
            },

            markupSlots: {
                containerNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                containerNode: [ 'background-color', 'fx' ]
            },

            title: '',

            
            init: function init(props) {
                this._super(props);

                
                if (!this.title) {
                    
                    this.title = this.node.defn.ttl || '';
                }
                
            },

            
            childRenderCheck: function childRenderCheck(c) {
                return (this._super(c) && this.selected);
            },

            postBuildRendering: function postBuildRendering() {
                var c = $CSS.addClass;
                
                if (!this.defn.l && !this._forceRender) {
                    
                    c(this.domNode, 'placeholder');
                }

                return this._super();
            },

            onselectedChange: function onselectedChange(evt) {
                this.set('visible', !!evt.value);
                
                if (evt.value) {
                    
                    this.renderChildren();
                }
                this.model && this.model.raiseEvent({name: 'panelSelected',panelId:this.id, panelVisible:!!evt.value});
            },

            
            refresh: function refresh() {
                
                if (!this.hasRendered) {
                    
                    return;
                }

                
                
                if (!this.selected) {
                    
                    if (!this.children) {
                        this.builtChildren = false;
                    }

                    
                    this._forceRender = true;

                    
                    this._super();

                    
                    delete this._forceRender;

                } else {
                    
                    var c = this.children || [],
                        i;

                    for (i = c.length - 1; i >= 0; i--) {
                        c[i].refresh();
                    }
                    
                    
                    if (this._isFP()) {
                        this.refreshFP();
                    }
                }
            },

            
            setDirty: function setDirty(isDirty) {
                var mth = ((isDirty) ? 'add' : 'remove') + 'DirtyKey';
                this[mth](this.k);
            },

            
            addDirtyKey: function addDirtyKey(key) {
                
                var d = this.defn,
                    hash = d.dirtyKeys || {};

                
                hash[key] = true;

                
                d.dirtyKeys = hash;

                
                setDirtyChildrenOnDescendant(key, this, true);

                
                passDirtyKeyToAncestorPanel(this, 'add', key);
            },

            
            removeDirtyKey: function removeDirtyKey(key) {
                
                passDirtyKeyToAncestorPanel(this, 'remove', key);

                
                setDirtyChildrenOnDescendant(key, this, false);

                
                var defn = this.defn,
                    dk = defn.dirtyKeys;

                
                if (!dk) {
                    
                    return;
                }

                
                delete dk[key];

                
                if (!mstrmojo.hash.isEmpty(dk)) {
                    
                    return;
                }

                
                delete defn.dirtyKeys;
            },
            
            renderChildren: function rnCh() {   
                var ch = this.children;
                if (ch && (this._isFP() || this._isFSP())) {
                    
                    for (var i=0,len=ch&&ch.length||0; i<len; i++) {
                        ch[i].orgPos = i;
                    }
                    
                    ch.sort(function(l,r) {
                        var lz = (l.getFormats() && l.getFormats()['z-index']) || 0,
                            rz = (r.getFormats() && r.getFormats()['z-index']) || 0;
                        
                        
                        return lz - rz || l.orgPos - r.orgPos;
                    });                                                   
                }
                
                if (this._isFP()) {     
                    if (ch) {
                        
                        
                        var ocw = this.domNode.clientWidth - 2 * ITEM_SPA
                        
                        
                        this.topStart = ITEM_SPA + 1;
                        
                        for (var i=0,len=ch&&ch.length||0; i<len; i++) {
                            var cw = this.domNode.clientWidth - 2 * ITEM_SPA;
                            this.contentWidth = (cw > 0) ? cw : 0;
                            
                            if (cw != ocw) {    
                                
                                this.topStart = ITEM_SPA;
                                for (var j=0; j<i; j++) {
                                    var oc = ch[j];
                                    oc.refresh();                                                                  
                                    if (oc.getContainerHeight) {
                                        this.topStart += oc.getContainerHeight() + ITEM_SPA;
                                    }
                                }
                            }
                            
                            var c = ch[i];
                            if (this.childRenderCheck(c)) {
                                c.render(null);    
                                                           
                                if (c.getContainerHeight) {
                                    this.topStart += c.getContainerHeight() + ITEM_SPA;
                                }
                            }
                        }
                    }
                } else {
                    this._super();
                } 
            },

            
            refreshFP: function() {
                if (!this.hasRendered) {
                    return;
                }
                
                var ch = this.children;
                this.topStart = ITEM_SPA;  
                var cw = this.domNode.clientWidth - 2 * ITEM_SPA;
                this.contentWidth = (cw > 0) ? cw : 0;
                
                
                for (var i=0,len=ch&&ch.length||0; i<len; i++) {
                    var c = ch[i];
                    if (c.relocate) {
                        c.relocate(this.topStart, this.contentWidth);
                    }
                                                   
                    if (c.getContainerHeight) {
                        this.topStart += c.getContainerHeight() + ITEM_SPA;
                    }
                }
            },
            
            getChildren: function getChildren(){                
                var ch = this.model.getChildren(this.node, false);
                
                if (this._isFP() || this._isFSP()) {
                    for (var i=0,len=ch&&ch.length||0; i<len; i++) {
                        var c = ch[i];
                        if (this._isFP() && !c.defn.iifp) {
                            c.defn.iifp = true; 
                        }
                        if (this._isFSP() && !c.defn.iifs) {
                            c.defn.iifs = true; 
                        }
                    }
                }
                
                return ch;
            },
            
            
            _isFP: function() { 
                return this.parent.defn.ifp;
            },
            
            
            _isFSP: function() {
                return this.parent.defn.ifsp;
            }
                
        }
    );

}());
(function(){

	mstrmojo.requiresCls("mstrmojo.Container");
	
	
	
	var PREFIX = "slot";
	
	
	mstrmojo.HBox = mstrmojo.declare(
		
		mstrmojo.Container,
		
		
		null,
		
		
		{
			scriptClass: "mstrmojo.HBox",
			
			cellCssClass: "",
			
			cellSpacing: 0,
			
			cellPadding: 0,
						
			markupString: '<table id="{@id}" class="mstrmojo-HBox {@cssClass}" style="{@cssText}" cellspacing="{@cellSpacing}" cellpadding="{@cellPadding}">{@colHTML}<tr>{@tableHtml}</tr></table>',
			
			colHTML: '',

			markupSlots: {
				containerNode: function() { return this.domNode.rows[0]; }
			},
			
			markupMethods: {
				onvisibleChange: function() { this.domNode.style.display = this.visible ? mstrmojo.css.DISPLAY_TABLE : 'none'; }
			},

			 
			buildRendering: function bldRn() {
				
				this.tableHtml = '';
				var t = [],
					ch = this.children,
					len = (ch && ch.length) || 0,
					i;
				
				if (len) {
					var counter = 0,
						css = this.cellCssClass ?
								' class="mstrmojo-HBox-cell ' + this.cellCssClass + '" ' :
								'',
						tdHtml = '<td ' + css + '></td>';
					for (i=0; i<len; i++) {
						t[counter++] = tdHtml;
						ch[i].slot = PREFIX+i;
					}
					this.tableHtml = t.join('');
				}				

				
				this._super();				
				
				
				
				
				if (len) {
					var slots = {},
						tds = this.containerNode.cells;
					for (i=0; i<len; i++) {
						slots["slot"+i] = tds[i];
					}
					this.addSlots(slots);
				}
			},
			
			addChildren: function addChild(widget, idx, silent) {
				if (!widget) {
					return widget;
				}
				
				
				if (idx === undefined || isNaN(idx) || idx < 0) {
				    var ch = this.children;
					idx = (ch && ch.length) || 0;
				}
				
				var i = 0,
				    cnt;
				
				
				if (widget.constructor === Array) {
					for (i = 0, cnt = widget.length; i < cnt; i++) {
						widget[i].slot = PREFIX + (idx + i);
					}
				} else {
					
					widget[i].slot = PREFIX + idx;
				}
				
				
				return this._super(widget, idx, silent);
			},
			
			
			childRenderCheck: function childRndrChk( child) {
				if (child && !child.hasRendered) {
					var slotName = child.slot || this.defaultChildSlot;
					return !!this[slotName] || slotName.match(/^slot[\d]+$/);
				}
				return false;
			},
			
			onchildRenderingChange: function chRnChg( obj) {
				var child = (obj && obj.src) || obj,
					d = child && child.domNode;
				
				if (d) {
					
					var s = child.slot;
					
					if (!this[s]) {
						
						
						var match = s && s.match(/^slot([\d]+)$/);
						if (match) {
							
							
							var idx = parseInt(match[1], 10),
								cn = this.containerNode,
								cells = cn.cells,
								cLen = (cells&&cells.length) || 0,
								slots = {};
							for (var i = cLen; i <= idx; i++) {
								var td = cn.insertCell(i);
								slots["slot"+i] = td;
								if (this.cellCssClass) {
									td.className = this.cellCssClass;
								}
							}
							this.addSlots(slots);
						}
					}
				}
				
				
				this._super(obj);
			}			
		
		}
	);
	
})();
(function(){
	mstrmojo.requiresCls('mstrmojo.Container', 'mstrmojo.css');
	
	
	var C_PREFIX = '',	
        R_PREFIX = 'row-',
        TABLE = mstrmojo.css.DISPLAY_TABLE;

	mstrmojo.Table = mstrmojo.declare(
		
		mstrmojo.Container,
		
		null,
		
		{
			scriptClass: 'mstrmojo.Table',
			cellCssClass: '',
			
			rows: -1,
			
			cols: -1,
			
			_trows: -1,
			
			cellPadding: 0,
			cellSpacing: 0,
			
			
			layout: null,
			markupString: '<table id="{@id}" class="mstrmojo-Table {@cssClass}" style="{@cssText}" cellpadding="{@cellPadding}" cellspacing="{@cellSpacing}">{@tableHtml}</table>',
			markupSlots: {
				containerNode: function() { return this.domNode; }
			},
            markupMethods: {
                onvisibleChange: function() { this.domNode.style.display = this.visible ? TABLE : 'none'; }
            },
			preBuildRendering: function preBR () {
				
				var rs = [],
					ccc = this.cellCssClass;
				if (this.layout){
					var rlen = this._trows = this.layout.length;
					
					for (var i = 0; i < rlen; i ++ ){
						var r = this.layout[i],
							cells = r.cells,
							clen = cells.length,
							cs =[];
						
						for (var j = 0; j < clen; j ++) {
							var c = cells[j], 
								att = '';
							att += ((c.cssClass || ccc)? ' class="' + (c.cssClass || ccc) + '"' : '');
							att += (c.cssText? ' style="' + c.cssText + '"' : '');
							att += (c.rowSpan? ' rowspan="' + c.rowSpan + '"' : '');
							att += (c.colSpan? ' colspan="' + c.colSpan + '"' : '');
							cs[j] = '<td' + att + '></td>';
						} 
						var rAtt = '';
						rAtt += (r.cssClass? ' class="' + r.cssClass + '"' : '');
						rAtt += (r.cssText? ' style="' + r.cssText + '"' : '');
						rs[i] = '<tr' + rAtt + '>' + cs.join('') + '</tr>';
					} 
				} else{
					this._trows = this.rows;
					var att = (ccc? ' class="' + ccc + '"' : ''),
						cs = [];
					
					for (var i = 0; i < this.rows; i ++) {
						for (var j = 0; j < this.cols; j ++) {
							cs[j] = '<td' + att + '></td>';
						}
						rs[i] = '<tr>' + cs.join('') + '</tr>';
					}
				}
				this.tableHtml = rs.join('');
				
				if (this._super) {
				    this._super();
			    }
			},
			
			postBuildRendering: function postBuildRendering() {
				
				if (this._trows){
					var slots = {},
						trs = this.containerNode.rows,
						rlen = trs.length;
					
					for (var i = 0; i < rlen; i ++) {
						var cells = trs[i].cells,
							clen = cells.length;
						slots[R_PREFIX + i] = trs[i];
						
						for (var j = 0; j < clen; j ++) {
							slots[C_PREFIX + i + ',' + j] = cells[j];
						}						
					}
					
					this.addSlots(slots);
				}
				
				this._super();
			},
			
			childRenderCheck: function childRndrChk( child) {
				if (child && !child.hasRendered) {
					var slotName = child.slot || this.defaultChildSlot;  
					return !!this[slotName] || slotName.match(/^([\d]+),([\d]+)$/);
				}
				return false;
			},
			
			on_child_change_rendering: function onChldChngRndr( obj) {
				var child = (obj && obj.src) || obj,
				d = child && child.domNode;
				if (d) {
					
					var s = child.slot;
					
					if (!this[s]) {
						
						
						var match = s && s.match(/^([\d]+),([\d]+)$/);
						if (match) {
							
							
							var ri = parseInt(match[1], 10), 
								ci = parseInt(match[2], 10), 
								cn = this.containerNode,	 
								rslot = this[(R_PREFIX + ri)],	
								slots = [];
							
							if (!rslot) {
								var rs = cn.rows,
								rlen = rs && rs.length || 0;
								
								for (var i = rlen; i <= ri; i ++) {
									slots[R_PREFIX + i] = cn.insertRow(); 
								}
								
								rslot = slots[R_PREFIX + ri];
							}
							
							var cLen = rslot.cells && rslot.cells.length || 0;
							for (var i = cLen; i <= ci; i++) {
								var td = rslot.insertCell(i);
								slots[C_PREFIX + ri + ',' + i] = td;
								if (this.cellCssClass) {
									td.className = this.cellCssClass;
								}
							}
							this.addSlots(slots);
						}
					}
				}
				
				this._super(obj);
				
			}
		}
	);
})();
(function(){


    mstrmojo.requiresCls("mstrmojo._HasBuilder",
                         "mstrmojo._HasLayout",
                         "mstrmojo.Container");

    var DARK_BORDER_WIDTH = 1;

    mstrmojo.maps.androidmap.AndroidDocMapInfoWindow = mstrmojo.declare(
        
        mstrmojo.Container,
        
        
        [ mstrmojo._HasBuilder, mstrmojo._HasLayout ],
        
        
        {
            scriptClass: "mstrmojo.maps.androidmap.AndroidDocMapInfoWindow",
            
            markupString: '<div class="mstrmojo-androidmap-DocInfoWindow-wrapper">' +
                              '<div id="{@id}" class="mstrmojo-androidmap-DocInfoWindow"></div>' +
                          '</div>',

            markupSlots: {
                infoNode: function() { return this.domNode.firstChild; },
                containerNode: function() { return this.domNode.firstChild; }
            },
                        
            getChildren: function getChildren(){
                
                var m = this.model,
                    c = m.getLayoutDataCache(m.getCurrentLayoutKey())[this.psId],
                    f = c.defn.fmts;
                
                
                f.left = DARK_BORDER_WIDTH + 'px';
                f.top = DARK_BORDER_WIDTH + 'px';
                
                return [c];
            }
        });

}());
(function(){

    mstrmojo.requiresCls("mstrmojo.Container",
        "mstrmojo._Formattable",
        "mstrmojo._ContainsDocObjects",
                         "mstrmojo._CanGrowOrShrink",
        "mstrmojo.boxmodel");
    
    
    mstrmojo.DocSubsection = mstrmojo.declare(
        
        mstrmojo.Container,
        
        
        [ mstrmojo._Formattable, mstrmojo._ContainsDocObjects, mstrmojo._HasBuilder, mstrmojo._CanGrowOrShrink ],
        
        
        {
            scriptClass: "mstrmojo.DocSubsection",

            markupString: '<div id="{@id}" class="mstrmojo-DocSubsection" style="{@domNodeCssText}"></div>',
            
            markupSlots: {
                containerNode: function() { return this.domNode; }
            },
            
            formatHandlers: {
                domNode: [ 'D', 'B', 'background-color', 'fx' ]
            },
            
            update: function update(node) {
                
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }
                
                this.thresholdId = node.data.tid;
                
                if (this._super) {
                    this._super(node);
                }
            },
            
            postBuildRendering: function postBldRndr() {
                var d = this.defn;
            
                
                if (d.hc || d.vc) {
                    var dn = this.domNode,
                        f = this.getFormats(),
                        id = this.id,
                        oH = f.height,  
                        oW = f.width;
                    
                    
                    d.attachEventListener('resized', id, function () {
                        if ('height' in f) {
                            dn.style.height = f.height;
                        }
                        
                        if ('width' in f) {
                            dn.style.width = f.width;
                        }
                    });
                    
                    
                    d.attachEventListener('adjustSize', id, function (e) {
                        var ds = dn.style,
                        	orgHeight = ds.height;
                        
                        
                        if (d.hc && ds.width !== oW) {
                            
                            ds.width = oW;
                        }
                        
                        
                        if (d.vc && ds.height !== oH) { 
                            
                            ds.height = oH;
                        }
                        
                        this.performCanGrowCanShrink(this.children);

                        
                        e.heightReduced = (parseInt(orgHeight, 10) > parseInt(ds.height, 10));
                    });
                }
                
                return (this.renderMode !== 'scroll') ? this._super() : true;
            },

            childRenderOnAddCheck: function childRenderOnAddCheck(children) {
                return (this.renderMode !== 'scroll') ? this._super(children) : false;
            },
            
            
            onchildRenderingChange: function chRnChg(obj) {
                this._super(obj);
                
                
                if (this.renderMode !== 'scroll') {
                	var parentSlot = this.parent.slot, 
                	    dontShrink = parentSlot === 'fixedHeaderNode' || parentSlot === 'fixedFooterNode'; 
                    this.performCanGrowCanShrink([ (obj && obj.src) || obj ], dontShrink);
                }
            },
            
            
            portalMaximized: function portalMaximized() {
                var d = this.defn,
                    vc = d.vc,    
                    hc = d.hc;    
                
                
                if (!hc && !vc) {
                    
                    return {};
                }
                
                
                delete d.vc;
                delete d.hc;
                delete d.ck;    
                
                var f = this.getFormats(),
                    m = this.model,
                    ss = this.domNode,
                    me = this;

                
                var props = {
                    HideIfEmpty: -1
                };

                
                var fn = function (h, v, s) {
                    var p = h.toLowerCase(),
                        as = parseInt(ss.style[p], 10);    
                    
                    
                    v = ((v === undefined) ? as : Math.max(parseInt(v, 10), as)) + 'px';
                    
                    
                    if (f[p] !== v) {
                        
                        f[p] = v;

                        
                        props[h] = mstrmojo.boxmodel.px2Inches(m, v);
                        
                        
                        delete me['_fixed' + h];
                    }
                    
                    
                    s = s || '';
                    props['Max' + h] = 0;
                    props['CanGrow' + s] = 0;
                    props['CanShrink' + s] = 0;
                };

                
                if (vc) {
                    fn('Height', f.normHeight);
                }
                
                
                if (hc) {
                    fn('Width', f.normWidth, 'Horizontal');
                }
                
                
                d.raiseEvent({
                    name: 'resized'
                });
                
                return props;
            },
            
            adjustSectionSize: function adjustSectionSize() {
                var d = this.defn;
                
                if (d.vc || d.hc) {
                    return d.raiseEvent({
                        name: 'adjustSize'
                    });
                }
                
                return null;
            },
            
            refresh: function refresh() {
                if (!this.hasRendered) {
                    return;
                }
                                    
                var c = this.children || [];
                for (var i = c.length - 1; i >= 0; i--) {
                	c[i].refresh && c[i].refresh();
                }
            },
            
            
            preserveChildDomOrder: false
        }
    );
    
}());


(function(){

    mstrmojo.requiresCls(
        "mstrmojo.Container",
        "mstrmojo._HasBuilder",
        "mstrmojo._Formattable",
        "mstrmojo._HasToolbar");
    
    var ELEM_SEP = "\u001E";
    
    var GD = 1;
    var GP = 2;
    
    
    var ggHelper = {
            
        TOP: 0,
        
        BOTTOM: 1,
        
        LEFT: 2,
        
        RIGHT: 3,
        
        vert: [ 'height', 'width', 'top' ],
        
        horiz: [ 'width', 'height', 'left' ],
        
        updateStyle: function (gg) {
            var qsm = gg.defn.qsm;
            if (!qsm) {
                return;
            }
            if (gg.getFormats().width) {
                return;
            }
            var child = null;
            if (qsm == GD) {
                child = gg.containerNode.firstChild; 
            }
            else {
                child = gg.containerNode.lastChild; 
            }
            if(!child){
                return;
            }
            var h = child.clientHeight + 'px';
            var w = child.clientWidth + 'px';
            
            var dnStyle = gg.domNode.style;
            dnStyle.height = h;
            dnStyle.width = w;
            
            if (gg.parent.updateStyle){
                gg.parent.updateStyle(h, w);
            }

        },
        
        repositionChildren: function (gg) {
        
            var f = gg.getFormats(),
                h = parseInt(f.height, 10),                                 
                w = parseInt(f.width, 10);                                    
        
            var ch = gg.children,
                gdf = ch[0].getFormats(),    
                gpf = ch[1].getFormats();    
            
            var isVert = (gg.defn.gp < this.LEFT),    
                x = (isVert) ? h : w,
                y = (isVert) ? w : h,
                dd = this[((isVert) ? 'vert' : 'horiz')];
            
            
            var gs = Math.round(x * (gg.defn.ga / 100));
            
            
            gdf[dd[0]] = gs + 'px';    
            gdf[dd[1]] = y + 'px';    
            
            
            gpf[dd[0]] = (x - gs) + 'px';     
            gpf[dd[1]] = y + 'px';            
            
            
            if ((gg.defn.gp % 2) === 0) {
                
                gpf[dd[2]] = gs + 'px';
            } else {
                
                gdf[dd[2]] = (x - gs) + 'px';
            }
            this.resizeChildren(ch[0], ch[1]);
        },
        stackChildren: function(gg) {
            var ch = gg.children,
            f = gg.getFormats(),
            gf;
            
            for (var i = ch.length - 1; i >= 0; i --){
              gf = ch[i].getFormats();
              gf.width = f.width;
              gf.height = f.height;
            }
            this.resizeChildren(ch[0], ch[1]);
        },
        resizeChildren: function(gd, gp) {
            
            gd.renderPortalState();

            
            var gpf = gp.getFormats();
            gp.resizeForDisplayState(parseInt(gpf.height, 10), parseInt(gpf.width, 10), true);
        },
        
        
        
        changeVisibility: function(gg, show) {
            var cd = gg.children,
                qsm = gg.defn.qsm,
                gds = show && (!qsm || gg.viewMode === GD),
                gps = show && (!qsm || gg.viewMode === GP);
            
            if(cd && cd.length > 0) {
                if (cd[0].visible !== gds) {
                    cd[0].set('visible', gds);
                }
                if (cd[1].visible !== gps){
                    cd[1].set('visible', gps);
                }
            }
            gg.visible = show;
        },
        
        
        setViewMode: function setViewMode(gg) {
            var cd = gg.children,
                vs = gg.visible;
            
            if(gg.defn.qsm && cd && cd.length > 0) {
                var ggm = gg.viewMode;
                cd[0].set('visible', (ggm == GD) && vs );
                cd[1].set('visible', (ggm == GP) && vs);
            }
        },
        
        clearFormatCache: function clearFormatCache(gg) {
            var cd = gg.children;
            for (var i = 0, len = cd && cd.length || 0; i < len; i ++) {
                cd[i].clearCache();
            }
        }
        
    };
    
    
    mstrmojo.DocGridGraph = mstrmojo.declare(
        
        mstrmojo.Container,
        
        
        [ mstrmojo._HasBuilder, mstrmojo._Formattable, mstrmojo._IsSelectorTarget],
        
        
        {
            scriptClass: "mstrmojo.DocGridGraph",
            
            markupString: '<div id="{@id}" title="{@tooltip}" class="mstrmojo-DocGridGraph" style="{@domNodeCssText}">' +
                            '<div class="mstrmojo-DocGridGraph-msg"></div>' +
                            '<div class="mstrmojo-DocGridGraph-container"></div>' +
                          '</div>',
                        
            markupSlots: {
                msgNode: function(){ return this.domNode.firstChild; },
                containerNode: function(){ return this.domNode.lastChild; }
            },
            
            formatHandlers: {
                
                domNode: [ 'RW', 'B', 'background-color', 'fx', 'font' ]
            },
            
            
            viewMode: null,
            
            visible: true,
            
            resize: function resize() {
                
                this.clearCache();                
                
                ggHelper.clearFormatCache(this);
                var f = this.getFormats(),
                w = parseInt(f.width,10),
                h = parseInt(f.height,10);
                
                if (w > 0 && h > 0) {
                    ggHelper.changeVisibility(this, true);
                    
                    if (!this.defn.qsm) {
                        ggHelper.repositionChildren(this);
                    } else {
                        ggHelper.stackChildren(this);
                    }
                }else {
                    
                    ggHelper.changeVisibility(this, false);
                }
            },
            
            postBuildRendering: function postBuildRendering() {
                this._super();
                
                var eg = this.node.data.eg;
                if (eg === undefined) {
                    
                    this.msgNode.style.display = "none";
                    
                    this.containerNode.style.display = "block";
                } else {
                    this.msgNode.innerHTML = eg;
                    this.msgNode.style.display = "block";
                    this.containerNode.style.display = "none";
                }
                
                
                var qsm = this.defn.qsm;
                if(!this.viewMode && qsm) {
                    this.viewMode = qsm;
                }
                
                
                var d = this.node.defn;
                
                
                
                
                d.attachEventListener("qsmChange", this.id, function (evt){
                    
                    this.viewMode = evt.value;
                    
                    
                    ggHelper.setViewMode(this);
                    
                    
                    this.model.getDataService().setQuickSwitchViewMode(this.defn.tt + ELEM_SEP + this.k, this.viewMode);
                    
                    ggHelper.updateStyle(this);
                });

                ggHelper.setViewMode(this);
                ggHelper.updateStyle(this);
                
                
                if(!qsm) {
                    this.resize();
                }
            },

            getGridWidget: function() {
                return this.children[0];
            },
            
            getGraphWidget: function() {
                return this.children[1];
            },
            
            
            updateGraph: function(node) {
                var gp = this.getGraphWidget();
                
                if(gp) {
                    gp.update(node);
                    gp.refresh();
                }
            },
                                    
            quickSwitch: function quickSwitch() {
                
                var gd = this.viewMode != GP;                
                
                
                this.defn.set('qsm', (gd ? GP : GD));
                
                return true;
            }
        }
    );
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable");

    mstrmojo.DocImage = mstrmojo.declare(
        
        mstrmojo.Container,

        
        [mstrmojo._Formattable],

        
        {
            scriptClass: "mstrmojo.DocImage",

            markupString: '<div id="{@id}" class="mstrmojo-DocImage" title="{@tooltip}" style="{@domNodeCssText}">' +
                                '<div style="{@shadowNodeCssText}"><img src="{@v}" style="{@imgNodeCssText}" mstrAttach:click></div>' +
                                '{@buttonNodeMarkup}' +
                          '</div>',

            markupSlots: {
                imgNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },	

            
            update: function update(node) {
                var ds = this.model.getDataService(),
                    v = node.data.v;

                this.v = (ds && ds.getDocImage && ds.getDocImage(v)) || v;

                
                if (this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }

                this.thresholdId = node.data.tid;
                this.set('visible', !node.data.hidden);

                
                if (this._super) {
                    this._super(node);
                }
            },

            formatHandlers: {
                domNode: ['left', 'top', 'z-index' ],
                shadowNode: ['width', 'height', 'B', 'fx' ],
                imgNode: [ 'height', 'width' ]
            },

            preBuildRendering: function preBuildRendering() {
                if (this._super) {
                    this._super();
                }

                
                if (!mstrmojo.dom.isIE7) {
                    var fmt = this.getFormats(),
                        ds = (fmt.fx && fmt.fx.ds) || 0,  
                        border = mstrmojo._Formattable.getBorderWidths(this);

                    this.domNodeCssText += 'width:' + ((parseInt(fmt.width, 10) || 0) + ds + border.w) + 'px;' + ' height: ' +  ((parseInt(fmt.height, 10) || 0) + ds + border.h) + 'px;';
                }
            },
            
            getAnchor: function getAnchor() {
            	return this.imgNode;
            }
        }
    );

}());

(function () {

    mstrmojo.requiresCls("mstrmojo.Container"); 
    
    mstrmojo.requiresDescs(9936, 9937);
    
    
    var IMAGE_MARGIN_BOTTOM = 25,
    	$DESC = mstrmojo.desc;

    
    mstrmojo.android.ui.NoProjectsView = mstrmojo.declare(
        mstrmojo.Container,

        null,

        
        {
            scriptClass: "mstrmojo.android.ui.NoProjectsView",

            markupString: '<div id="{@id}" class="mstrmojo-NoProjectsView">' +
            				'<div>' + 
                              '<div class="mstrmojo-NoProjectsViewImage"></div>' +
                              '<div class="mstrmojo-NoProjectsViewMsg1">{@msg1}</div>' +
                              '<div class="mstrmojo-NoProjectsViewMsg2">{@msg2}</div>' +
                            '</div>' + 
                          '</div>',

            markupSlots: {
                wrapperNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod
            },            	

            preBuildRendering: function preBuildRendering(){
            	
            	this.msg1 = $DESC(9936, 'No projects have been configured.');
            	this.msg2 = $DESC(9937, 'Contact your administrator');
            },
            
            postBuildRendering: function postBuildRendering() {
            	
            	this._super();
            	
            	var wrapperNode = this.wrapperNode;
            	
            	wrapperNode.style.marginTop = (-(wrapperNode.clientHeight/2) - IMAGE_MARGIN_BOTTOM) + 'px';
            }           
        }
    );
    
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget", "mstrmojo.css");

    var _C = mstrmojo.css;

    
    function _hideEmpty(me) {
        var el = me.inputNode;

        var v = (me.value != null) ? String(me.value) : '';

        if (v !== el.value) {
            el.value = v;
        }
        if (el.mstrmojoEmpty) {
            _C.removeClass(el, [me.emptyClass]);
            el.mstrmojoEmpty = null;
        }
    }

    
    function _showEmpty(me) {
        var el = me.inputNode;
        el.value = me.emptyText || '';
        _C.addClass(el, [me.emptyClass]);
        el.mstrmojoEmpty = true;
    }

    
    function _dom2value(me) {
        var inputNode =  me.inputNode;
        if(inputNode) {
            me.readingDom = true; 
            me.set("value",  inputNode.value);
            me.readingDom = false;
        }
    }

    var _KEYCODENAME = {
        9: 'Tab',
        13: 'Enter',
        27: 'Esc',
        38: 'ArrowUp',
        40: 'ArrowDown'
    };

    
    mstrmojo.TextBox = mstrmojo.declare(
        
        mstrmojo.Container,

        
        null,

        
        {
            scriptClass: 'mstrmojo.TextBox',

            
            value: '',

            
            type: 'text',

            
            hint: '',

            
            readOnly: false,

            
            size: '',

            
            maxLength: '',

            cssDisplay: 'inline',

            
            tabIndex: '',

            
            autoComplete: true,
            autoCorrect: true,
            autoCapitalize: true,
            
            placeholderText: '',

            markupString: '<input id="{@id}" placeholder="{@placeholderText}" class="mstrmojo-TextBox {@cssClass}"  style="{@cssText}" ' +
                                 'title="{@tooltip}" type="{@type}" ' +
                                 'value="" size="{@size}" maxlength="{@maxLength}" index="{@tabIndex}"' +
                                 'min="{@min}" max="{@max}" placeholder="{@hint}"' +
                                 ' mstrAttach:focus,keyup,blur,paste,cut,input,click ' +
                              '/>',

            markupSlots: {
                inputNode: function () { return this.domNode; }
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; },
                oncssClassChange: function () { this.inputNode.className = "mstrmojo-TextBox " + (this.cssClass || ''); },
                onhintChange: function () { this.inputNode.setAttribute('placeholder', this.hint); },
                onenabledChange: function () {
                    this.inputNode.disabled = !this.enabled;
                    mstrmojo.css.toggleClass(this.inputNode, 'disabled', !this.enabled);
                },
                onvalueChange: function () {
                    
                    var v = this.value,
                        em = (v === null) || (v === "");

                    
                    if (em) {
                        
                        
                        if (!this.hasFocus) {
                            _showEmpty(this);
                        } else {
                            this.inputNode.value = "";
                        }
                    } else {
                        _hideEmpty(this);
                    }
                },
                ontooltipChange: function () {
                    this.domNode.title = this.tooltip;
                },
                onreadOnlyChange: function () { this.inputNode.readOnly = this.readOnly; }
            },

            
            emptyText: '',

            
            emptyClass: 'mstrmojo-empty',

            postBuildRendering: function postBuildRendering() {
                this._super();

                
                var e = this.inputNode;
                e.setAttribute("autocomplete", this.autoComplete ? "on" : "off");
                e.setAttribute("autocorrect", this.autoCorrect ? "on" : "off");
                e.setAttribute("autocapitalize", this.autoCapitalize ? "on" : "off");
            },

            focus: function focus() {
                this.inputNode.focus();
            },

            
            prefocus: function prefocus() {
                this.hasFocus = true;
                
                _hideEmpty(this);
            },

            
            preblur: function preblur() {
                window.setTimeout(function () {
                    
                }, 200);
                this.hasFocus = false;
                _dom2value(this);
                var v = this.value;
                if ((v === null || v === "") && this.emptyText) {
                    
                    _showEmpty(this);
                }
            },

            
            prekeyup: function pku(evt) {
                
                var hWin = evt.hWin,
                    e = evt.e || hWin.event;

                _dom2value(this); 
                var n = _KEYCODENAME[e.keyCode];
                if (this['on' + n]) {
                    this['on' + n](evt);
                }
            },
            
            
            preinput: function pku(evt) {
                
                var hWin = evt.hWin,
                    e = evt.e || hWin.event;

                _dom2value(this); 
            },
            

            
            prepaste: function prepaste() {
                this.delaySetValue(this);
            },

            
            precut: function precut() {
                this.delaySetValue(this);
            },

            
            delaySetValue: function delaySetValue(tgt) {
                window.setTimeout(function () {
                    _dom2value(tgt);
                }, 100);
            },

            
            setInvalidState: function setInvalidState(msg) {
                
                mstrmojo.css.addClass(this.inputNode, ['err']);

                
                if (msg) {
                    
                    this.domNode.setAttribute('title', msg);
                }
            },

            
            cleanUp: function cleanUp() {
                
                this.inputNode.value = '';

                
                mstrmojo.css.removeClass(this.domNode, ['err']);

                
                this.domNode.setAttribute('title', this.tooltip);
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._HasLayout",
                         "mstrmojo.array");

    var $ARR = mstrmojo.array,
        $LAYOUT = {
            containerNode: '100%',
            node1: '100%',
            node2: '100%'
        };

    
    mstrmojo.android.ui.ViewSwitcher = mstrmojo.declare(

        mstrmojo.Container,

        [ mstrmojo._HasLayout ],

        
        {
            scriptClass: "mstrmojo.android.ui.ViewSwitcher",

            markupString: '<div id="{@id}" class="mstrmojo-AndroidSwitcher {@cssClass}" style="{@cssText}">' +
                              '<div class="switch-slider">' +
                                  '<div class="switch-page"></div>' +
                                  '<div class="switch-page"></div>' +
                              '</div>' +
                              '<div class="overlay"></div>' +
                          '</div>',

            markupSlots: {
                
                containerNode: function () { return this.domNode; },
                sliderNode: function () { return this.domNode.firstChild; },
                node1: function () { return this.domNode.firstChild.firstChild; },
                node2: function () { return this.domNode.firstChild.lastChild; },
                overlayNode: function () { return this.domNode.lastChild; }
            },

            markupMethods: {
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod
            },

            layoutConfig: {
                h: $LAYOUT,
                w: $LAYOUT
            },

            
            getSlots: function getSlots() {
                var curVisSlot = this._curSlot || 'node1',
                    nextVisSlot = (curVisSlot === 'node1') ? 'node2' : 'node1';

                return {
                    current: this[curVisSlot],
                    next: this[nextVisSlot],
                    slot: nextVisSlot
                };
            },

            
            addChildren: function addChildren(children, idx, silent) {
                
                $ARR.forEach(children, function (child) {
                    
                    if (child.slot === 'overlayNode') {
                        
                        child.ignoreLayout = true;
                    }
                });

                this._super(children, idx, silent);
            },

            
            prepareNewView: function prepareNewView(view, slot) {
                
                view.height = this.height;
                view.width = this.width;

                
                view.visible = true;

                
                view.slot = slot;
            },

            
            switchView: function switchView(view, isBackOperation) {
                
                var currentChild = this.getCurrentView();

                
                if (view === currentChild) {
                    
                    return;
                }

                var slotInfo = this.getSlots(),
                    newCtrl = this.getViewController(view),
                    oldCtrl = this.getViewController(currentChild);

                
                if (currentChild) {
                    
                    if (oldCtrl && oldCtrl.beforeViewHidden) {
                        
                        oldCtrl.beforeViewHidden(isBackOperation);
                    }
                }

                
                this.prepareNewView(view, slotInfo.slot);

                
                if (newCtrl && newCtrl.beforeViewVisible) {
                    
                    newCtrl.beforeViewVisible(isBackOperation);
                }

                
                this.addChildren([ view ]);

                
                if (currentChild) {
                    
                    this.removeChildren(currentChild);
                    currentChild.unrender();

                    
                    if (oldCtrl && oldCtrl.afterViewHidden) {
                        
                        oldCtrl.afterViewHidden(isBackOperation);
                    }
                }

                
                if (newCtrl && newCtrl.afterViewVisible) {
                    
                    newCtrl.afterViewVisible(isBackOperation);
                }

                
                this.stackViews(slotInfo.slot);

                
                this.afterSwitch(view);
            },

            
            replaceView: function replaceView(view, targetView, noDestroy) {
                var idx = $ARR.indexOf(this.children, targetView);

                
                if (idx === -1) {
                    
                    return;
                }

                
                var currentSlot = targetView.slot;

                
                $ARR.forEach([ view, targetView ], function (v) {
                    
                    if (v.parent === this) {
                        
                        this.removeChildren(v, true);
                        v.unrender();
                        
                        if(!noDestroy) { 
                        	v.destroy();
                        }
                    }
                }, this);

                
                this.prepareNewView(view, currentSlot);

                
                this.addChildren([ view ]);

                return view;
            },

            
            stackViews: function stackViews(slotName) {
                
                $ARR.forEach([ 1, 2 ], function (idx) {
                    
                    var name = 'node' + idx,
                        slot = this['node' + idx];

                    
                    if (slot) {
                        
                        slot.style.zIndex = (name === slotName) ?  3 : 1;
                    }
                }, this);
            },

            
            getCurrentView: function getCurrentView() {
                var slot = this._curSlot || 'node2',
                    view;

                
                $ARR.forEach(this.children, function (child) {
                    
                    if (child.slot === slot) {
                        
                        view = child;
                        return false;
                    }
                });

                return view;
            },

            
            getViewController: function getViewController(view) {
                return view ? view.controller || view : null;
            },

            
            afterSwitch: function afterSwitch(view) {
                
                this._curSlot = view.slot;
            },
            
            doLayout: function doLayout() {
                var node1 = this.node1.style,
                    node2 = this.node2.style;
                
                
                node1.height = node2.height = this.height;
                node1.width = node2.width = this.width;
                
                this._super();
            }

        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
            "mstrmojo.color",
            "mstrmojo.css",
            "mstrmojo.GridBase");

    var $C = mstrmojo.css,
        $CLR = mstrmojo.color;
    
    
    function findContainerByMethodName(w, func) {
        var anc = w && w.parent;
        while (anc && anc.scriptClass.indexOf('DocPanelStack') === -1) {
            if(func in anc) {
                return anc;
            }
            anc = anc.parent;
        }
        return null;
    };
    
    function repaint(node) {
        var img = document.createElement('img');
        node.appendChild(img);
        node.removeChild(img);
    };
    
    function getTableRowCells(ri, grid) {
        var page = Math.floor(ri/grid.rowsPerPage),
            row = ri % grid.rowsPerPage,
            tbl = grid.tableNode.tBodies[page];
            r = tbl.rows[row].cells;

        return r;
    }
    
    
    function renderingCleanUp() {
        
        var timer = this._renderTimer;
        if (timer) {
            
            self.clearInterval(timer);
            
            
            delete this._renderTimer;
            
            
            this.renderingRows = false;
        }
    }
    
    mstrmojo.Grid = mstrmojo.declare(
        
        mstrmojo.GridBase,
        
        
        null,
        
        
        
        
        {
            scriptClass: "mstrmojo.Grid",

            
            rowsPerPage: 0,
            
            
            effectiveRh: 0,

            
            numPagesRendered: 0,
            
            
            totalPages: 0,
            
            
            pageStatus: null,
            
            
            _defaultPageHeight: 0,
            
            
            renderPause: 10,

            
            rhMin: 15,
            
            
            defaultRowsPerPage: 100,
            
            
            minRowsPerPage: 50,
                        
            
            init: function init_Grid( props) {
                
                this._super(props);
                
                
                this.forceFixedSizes = true;

            },

            
            
            
            initPageSettings: function intiPageSettings() {
                
                var p = this.parent,
                        rpp = this.defaultRowsPerPage;

                
                this.effectiveRh = this.rh || this.rhMin || 1;

                if(p && p.numRowFixed) {
                    
                    
                    
                    rpp = this.cp.getAvailableRowsCount();
                } else if (p && p.scrollboxHeightFixed) {
                    
                
                    
                    rpp = Math.ceil(p.scrollboxHeight/this.effectiveRh);
                    
                    
                    rpp = Math.max(rpp, this.minRowsPerPage);
                }

                this.pageStatus = [];
                
                
                this.rowsPerPage = rpp;

                this.initPageStatus(this.pageStatus);
                
                this._defaultPageHeight = this.rowsPerPage * this.effectiveRh;
            },            
            
            
            
            initPageStatus: function initPageStatus( pageStatus) {
                var rpp = this.rowsPerPage;
                
                this.totalPages = rpp && Math.ceil(this.cp.rc/rpp) || 0;
                pageStatus = pageStatus || this.pageStatus;

                
                for(var i=0;i< this.totalPages ;++i) {
                    
                    var startIndex = i*rpp,
                    endIndex = startIndex + rpp - 1,
                    dataAvailable = this.cp.isDataAvailable(startIndex, endIndex);

                    
                    if(!pageStatus[i]) {
                        pageStatus[i] = {};
                    }
                    
                    
                    pageStatus[i].onDemand = !dataAvailable;
                }
            },

            
            buildRendering: function buildRendering( tcn) {
                if (this.renderMode == "vscroll") {
                    
                    this.initPageSettings();

                    
                    var ps0 = this.pageStatus[0],
                            isOnDemand = ps0 && ps0.onDemand;
                    
                    this.start = 0;
                    this.end = -1;
                    
                    if(!isOnDemand) {
                        
    
                        
                        
                        this.end = Math.min(this.cp.rc, this.rowsPerPage) - 1;
                    }
                        
                    
                    
                    this.preRenderPages();
                    
                    
                    this.preRenderPage(0, !isOnDemand);
                }

                
                this._super();
                
                if (this.renderMode == "vscroll") {
                	var p = this.parent,
                	    me = this,
                    	setMinHeight = function() {
                            me.gridContainerNode.style[mstrmojo.css.MINHEIGHT] = (me.cp.rc * me.effectiveRh) + 'px';
                	    };
                    
                    
                	if (mstrmojo.dom.isIE7) {
                	    
                        this.gridContainerNode.style.zoom = '1';
                        window.setTimeout(setMinHeight,10);
                	} else {
                	    setMinHeight();
                	}
                	
                    
                    if (!this.connectedScrollbox) {
                        if (p && p.connectScrollbox) {
                            p.connectScrollbox(this);
                            this.connectedScrollbox = true;
                        }
                    }
                    
                    
                    this.postRenderPage(0, !isOnDemand);
                    this.postRenderPages();                    

                    
                    
                    var afc = p && !p.scrollboxHeightFixed && !p.numRowFixed;
                    if(afc && this.numPagesRendered >= this.totalPages && !isOnDemand) {
                        
                        this.postRenderingCleanup();
                    } else if(isOnDemand || afc) {
                        this.onscroll();
                    }
                } else {
                    this.configureActions();
                }
                
            },

            
            preRenderPages: function prePages() {
                
            },

            
            postRenderPages: function postPages() {
                this.configureActions();
            },
            
            configureActions: function configureActions() {
                
                var p = this.parent;
                if(p && p.configureActions) {
                    p.configureActions();
                }
            },
                        
            
            preRenderPage: function prePage( idx,  bFillCells) {
                
                this.pageNum = idx;
            },

            
            postRenderPage: function postPage( idx,  bFillCells,  el) {
                
                if (idx+1 > this.numPagesRendered) {
                	this.numPagesRendered = idx+1;
                }
                
                var arr = this.pageStatus,
                    status = arr[idx];
                if (!status) {
                    
                    status = arr[idx] = {};
                }
                if (bFillCells) {
                    
                    status.filled = true;
                    status.dirty = false;
                }
                
                
                
                
                var cnStyle = this.gridContainerNode.style;
                if(idx == this.totalPages - 1 && cnStyle) {
                    cnStyle[mstrmojo.css.MINHEIGHT]= '';    
                }
                
            },            
            
            
            invalidAllPages: function() {
                for(var i=0;i< this.totalPages ;++i) {
                    var ps = this.pageStatus[i];
                    if(ps.filled) {
                        ps.dirty = true;
                    }
                    ps.onDemand = true;
                    ps.filled = false;
                    ps.isDownloading = false;
                }
                this.thPosMap = [];
                this.posMap = [];
            },
            
            
            _startPageRenderThread: function startRndrThd() {
                var id = this.id;
                
                
                this.renderingRows = true;
                
                
                this._renderTimer = self.setInterval(function() {
                    try {
                        
                        var grid = mstrmojo.all[id];
                        
                        if (!grid) return;
                        
                        var pages = grid.getPagesToRender();
                        
                        
                        if (pages.length > 0) {
                            grid.preRenderPages();
                            grid.renderPages(pages);
                            grid.postRenderPages();
                            grid._postPagesClearup = true;  
                            
                        } else {
                            if (grid._postPagesClearup) {
                                grid.postRenderPagesCleanup();
                                grid._postPagesClearup = false;                                                    
                            }
                            
                            
                            renderingCleanUp.call(grid);
                            
                            if (grid.isRenderingComplete()) {
                                grid.postRenderingCleanup();
                            }
                        }
                        
                    } catch (ex) {
                        
                        renderingCleanUp.call(mstrmojo.all[id]);
                        
                        
                        throw ex;
                    }
                        
                }, this.renderPause);
            },
            
            
            onscroll: function onscroll(setMask) {
                
                if (!this.renderingRows) {
                    
                    if(setMask === true) {
                        var p = this.parent;
                        if(p && p.maskNode) {
                            $C.addClass(p.maskNode, 'wait');
                        }
                    }
                    this._startPageRenderThread();
                }
            },

            
            isRenderingComplete: function isRdrComplete() {
                
                if (this.end >= this.cp.rc - 1) {
                    
                    
                    for (var arr=this.pageStatus, i = this.totalPages-1; i >-1; i--) {
                        if (!arr[i] || !arr[i].filled) {
                        	return false;
                        }
                    }
                    return true;
                }
                return false;
            }, 
            
            
            renderPages: function renderPages( pages) {
                for(var i=0,len=pages.length;i<len;++i) {
                    this.renderPage(pages[i].idx, pages[i].fill);
                }
            },
            
            
            renderPage: function renderPage( idx,  bFillCells) {
                
                var arrStatus = this.pageStatus,
                    alreadyRendered = (this.numPagesRendered >= idx+1);
                if (alreadyRendered) {
                    
                    
                    if (!bFillCells || (arrStatus[idx] && arrStatus[idx].filled)) {
                    	return;
                    }
                }

                var rpp = this.rowsPerPage,
                    dn = this.domNode;
                
                
                this.start = idx * rpp;
                this.end = Math.min(this.start + rpp, this.cp.rc) - 1; 

                
                this.preRenderPage(idx, bFillCells);
                
                
                
                var tempTable = this.tempTable;
                if (!tempTable) {
                    tempTable = this.tempTable = dn.ownerDocument.createElement('div');
                }
                
                
                
                var tInnerHTML = bFillCells ?
                        this.buildTableRowsMarkup(this.start, this.end, '<table><tbody n="' + this.pageNum + '">', '</tbody></table>').join('') :
                            '<table><tbody n="' + this.pageNum + '"><tr><td style="height:' + (this.effectiveRh * (this.end-this.start+1))+ 'px">&nbsp;</td></tr></tbody></table>';
                        tempTable.innerHTML = tInnerHTML; 

                
                var tbody = tempTable.firstChild.tBodies[0],
                    tn = this.tableNode;
                
                
                
                if (!alreadyRendered) {
                    tn.appendChild(tbody);
                } else {
                    
                    tn.replaceChild(tbody, tn.tBodies[idx]);
                }
                                
                
                this.postRenderPage(idx, bFillCells, tbody);
            },
            
            
            getPagesToRender: function getPagesToRender() {
                var pages = [],
                    p = this.parent,
                    
                    pageSize  = this._defaultPageHeight,
                    tBodies = null,
                    stats = this.pageStatus,
                    me = this;
                    
                
                function pageHeight(idx) {
                    
                    var stat = stats[idx];
                    if (stat && (stat.filled || stat.dirty)) {
                        
                        if (!stat.height) {
                            if (!tBodies) {
                            	tBodies = me.tableNode.tBodies;
                            }
                            stat.height = tBodies[idx].offsetHeight;
                        }
                        return stat.height;
                    } else {
                        
                        return pageSize;
                    }
                }

                
                
                var y = 0,
                    topPageIdx = null,
                    bottomPageIdx = null,
                    scrollTop = p.scrollboxTop;
                for (var i=0, len=this.totalPages, arr = this.pageStatus; i<len; i++) {
                    y += pageHeight(i);
                    if (y >= scrollTop) {
                        topPageIdx = i;
                        break;
                    }
                }
                
                if (topPageIdx === null) {
                    
                    topPageIdx = bottomPageIdx = len-1;
                } else {
                    
                    var scrollBottom = p.scrollboxBottom;
                    
                    
                    
                    
                    if(isNaN(scrollBottom) && p.numRowFixed) {
                        scrollBottom = scrollTop;
                    }
                    
                    for (var j=topPageIdx+1; j<len; j++) {
                        
                        
                        
                        if (y > scrollBottom) {
                            bottomPageIdx = j-1;
                            break;
                        }
                        y += pageHeight(j);
                    }
                }
                
                if (bottomPageIdx === null) {
                    bottomPageIdx = len-1;
                }
                
                
                for(var n=this.numPagesRendered;n<topPageIdx;++n) {
                    pages.push({idx: n, fill: false});
                }                   
                
                
                
                var arrStats = this.pageStatus,
                        numRowsToDownload = 0,
                        rpp = this.rowsPerPage,
                        showStatus = false;
                
                for (var m=topPageIdx;m<=bottomPageIdx;++m) {
                    var stat = stats[m];
                    if (!stat || !stat.filled) {
                        
                        if(stat && stat.onDemand) {
                            showStatus = true;
                            
                            
                            
                            if(!stat.isDownloading && !this.isDownloading){ 
                                numRowsToDownload += rpp; 
                                stat.isDownloading = true;
                                this.isDownloading = true;
                                var startIndex = m*rpp,
                                        endIndex = startIndex + rpp - 1;
                                
                                
                                this.cp.download(startIndex, endIndex);
                                
                            }
                            
                            
                            pages.push({idx: m, fill: false});
                        } else {
                            pages.push({idx: m, fill: true});
                        }
                    }
                }

                
                if(showStatus) {
                	this.parent.showDownloadStatus(numRowsToDownload);
                } else {
                    if (this.parent.closeDownloadStatus) this.parent.closeDownloadStatus();
                }
                
                return pages;
            },            

            
            addHilitePosition: function(key, row, cell) {
                var hm = this.hiliteCellsMap[key];
                if(!hm) {
                    this.hiliteCellsMap[key] = {pos: [], nodes: []};
                }
                var r = row - (this.pageNum || 0) * this.rowsPerPage;
                this.hiliteCellsMap[key].pos.push({row: r, cell: cell, page: this.pageNum});                
            },
            
            
            setHilites: function(key, node) {
                var ei = node.getAttribute('ei'),
                    pos = this.eiMap[ei],
                    arr = this.getNodesByPositions(pos);
                
                if(!arr.length) {
                    this._super(key, node);
                    return ;
                }
                
                for(var i = 0, iLens = arr.length; i < iLens; i++) {
                    this._super(key, arr[i]);
                }
            },
            
            addExtraInfoMap: function(ei, row, cell) {
                if(!this.eiMap[ei]) {
                    this.eiMap[ei] = [];
                }
                
                this.eiMap[ei].push(this.getPosObj(row, cell));
            },            
            
            addPositionMap: function(ei, row, cell){
                
                if(!this.posMap[ei]) {
                    this.posMap[ei] = this.getPosObj(row, cell);
                }
            },
            
            addTitleHeaderPositionMap: function(row, cell, o){
                var pos = this.getPosObj(row, cell);
                pos.obj = o;
                this.thPosMap.push(pos);
            },

            getPosObj: function(r, c){
                return {row: r - this.pageNum * this.rowsPerPage, cell: c, page: this.pageNum};
            },
            
            getNodeByPosition: function(pos) {
                return this.tableNode.tBodies[pos.page].rows[pos.row].cells[pos.cell];
            },            
            
            getRowIdxByCell: function(cell) {
                var pos = this.posMap[cell._ei];
                return pos.page * this.rowsPerPage + pos.row;
            },
            
                        
            getNodesByPositions: function(pos) {
                var arr = [];
                
                for(var i in pos) {
                    var v = pos[i],
                        p = (v && v.page) || 0,
                        r = v && v.row,
                        c = v && v.cell;
                    
                    arr.push(this.tableNode.tBodies[p].rows[r].cells[c]);
                }
                
                return arr;
            },
            
            
            getPageHeight: function getPageHeight(idx) {
                var tbd = this.tableNode.tBodies;
                return (tbd && tbd[idx] && tbd[idx].offsetHeight) || 0;
            },
            
            
            getTargetCell: function(x, y) {
                var h = 0, 
                    i = 0;
                
                
                for(var len = this.totalPages; i < len; i++) {
                    h += this.getPageHeight(i);
                    if(y <= h) {
                        break;
                    }
                }
                var tbody = this.tableNode.tBodies[i];

                if (tbody){
                    
                    for(var i = 0, len = tbody.rows.length; i < len; i++) {
                        var row = tbody.rows[i];
                        
                        for(var j = 0, jLen = row.cells.length; j < jLen; j++) {
                            var cell = row.cells[j];
                            
                            if(cell.offsetTop + cell.offsetHeight >= y) {
                                
                                if(x >= cell.offsetLeft && x <= cell.offsetLeft + cell.offsetWidth) {
                                    return cell;
                                }
                            } else {
                                break;
                            }
                        }
                    }
                }
            },
            
            postRenderPagesCleanup: function _postRenderPagesCleanup() {
                var p = this.parent;
                
                if(p && p.gridData && p.gridData.afc) {
                    var tb = this.tableNode;
                    
                    if(tb && (this.lastWidth != tb.offsetWidth)) {
                        if(p.onGridWidthChanged) {
                            p.onGridWidthChanged();
                        }
                        mstrmojo.array.forEach(this.pageStatus, function(s) {
                            delete s.height;
                        });
                        this.lastWidth = tb.offsetWidth;
                    }
                    var w = findContainerByMethodName(p, 'adjustAutoWidth');
                    if(w) {
                        w.adjustAutoWidth(p);
                    }
                }
                
                if(p.gridPagesRendered) {
                    p.gridPagesRendered();
                }                
                
                
                if(mstrmojo.dom.isIE && !mstrmojo.dom.isIE8) {
                    repaint(this.domNode);
                }
                
                
                if(p && p.maskNode) {
                    $C.removeClass(p.maskNode, 'wait');
                }
                
                this.hightLightChangedCells();
            },
            
            hightLightChangedCells: function hightLightChangedCells() {
                var ucs = this.cp.getUpdatedRows(),
                    me = this, cells,
                    r, rcells, ci, i, c, ri, doms = [];
                if(ucs) {
                    
                    mstrmojo.hash.forEach(ucs, function(v, k) {
                        ri = parseInt(k, 10);
                        cells = me.cp.getRowCells(ri);
                        r = getTableRowCells(ri, me);
                        rcells = r.length;
                        ci = cells.length - 1;
                        
                        if(ci >= 0) {
                            for(i = rcells - 1; i >= 0; i--) {
                                c = r[i];
                                if(ci<0) {
                                    break;
                                }
                                if(cells[i]._d) {
                                    var bgColor = c.style.backgroundColor,
                                        ftColor = c.style.color;
                                    doms.push({dom: c, bgcolor: bgColor, ftcolor: ftColor});
                                    c.style.backgroundColor = $CLR.getHighlightColor($CLR.rgbStr2rgb(mstrmojo.css.getStyleValue(c, 'backgroundColor'), true));
                                    c.style.color = $CLR.getContrastingColor($CLR.rgbStr2hex(mstrmojo.css.getStyleValue(c, 'backgroundColor')), ['#ffffff', '#000000']);
                                    delete cells[i]._d;
                                }
                                ci--;
                            }
                        }
                    });
                    
                    if(doms.length > 0) {
                        window.setTimeout(function() {
                            mstrmojo.array.forEach(doms, function(domCell) {
                                
                                domCell.dom.style.backgroundColor = domCell.bgcolor;
                                domCell.dom.style.color = domCell.ftcolor;
                            });
                        }, 300);
                    }
                }
            },
            
            
            getRowInfoByPosition: function (y) {
                return this.cp.getRowCellInfo(y);
            },
            
            
            postRenderingCleanup: function _postRenderingCleanup() {
                var p = this.parent;
                
                if (p && this.connectedScrollbox) {
                	p.disconnectScrollbox(this);
                }
                this.connectedScrollbox = false;  
                
                
                if (p && !p.scrollboxHeightFixed) {
                   var c = findContainerByMethodName(p, 'performCanGrowCanShrink');
                   if (c) {
                	   c.performCanGrowCanShrink([p], true);
                   }
                }             
            },
            
            unrender: function unrender(ignoreDom) {
                
                renderingCleanUp.call(this);
                
                
                if (this.connectedScrollbox) {
                    this.parent.disconnectScrollbox(this);
                    this.connectedScrollbox = false;
                }
                
                this.numPagesRendered = 0;
                this.lastWidth = 0;
                this.isDownloading = false;
                
                this._super(ignoreDom);
            },
            
            dataDownloaded: function dataDownloaded() {
                this.isDownloading = false;
                this.initPageStatus();
                this.onscroll();
            }
        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.android.selectors.MobileSliderSelector",
                         "mstrmojo.hash");
    
    var $M = mstrmojo.android.selectors.MobileSliderSelector,
        $F = $M.FLAGS,
        $T = $M.TYPES;
    
    
    mstrmojo.android.selectors.Slider = mstrmojo.declare(

        mstrmojo.android.selectors.MobileSliderSelector,

        null,
        
        
        {
            scriptClass: "mstrmojo.android.selectors.Slider",
            
            items : $F.UNSET,
            
            initState: function initState() {
                if (!!this.items) {
                    
                    this.leftStep = this.rightStep = this.singleStep = null;
                    
                    this.set('type', (!this.multiSelect) ? $T.SINGLE : (this.include) ? $T.INCLUDE : $T.EXCLUDE);
                    this.set('steps', this.items.length);
                    this.value = null;
                    this.set('value', this.selectedIndices);
                }
            },
            
            
            onvalueChange : function onvalueChange() {
                var values = this.value,
                    mn = mstrmojo.hash.any(values, true),
                    mx = mn;
                
                if (this.type === $T.SINGLE) {
                    this.set('singleStep', parseInt(mn) || 0);
                    
                } else {
                    var p;
                    
                    for (p in values) {
                        mn = Math.min(p, mn);
                        mx = Math.max(p, mx);
                    }
                    
                    
                    mn = mn || '0';
                    if (mx === undefined || mx === null) {                        
                        mx = String(this.steps - 1);
                    }
                    
                    this.set('leftStep', parseInt(mn, 10));         
                    this.set('rightStep', parseInt(mx, 10) + 1);    
                }
            },
            
            
            flushSelections: function flushSelections() {
                if (this.type === $T.SINGLE) {
                    this.select([ this.singleStep ]);
                    
                } else {
                    var s = [],
                        i = this.leftStep;
                    
                    for (; i < this.rightStep; i++) {
                        s.push(i);
                    }
                    
                    this.select(s);
                }
            },
            
            
            buildSummary: function buildSummary(singleStep, leftStep, rightStep) {
                var items = this.items,
                    s = (singleStep !== null) ? singleStep : leftStep;
                
                
                if (s === undefined || s === null || isNaN(s) || !items.length) {
                    
                    return;
                }
                
                var summary = (singleStep === null && leftStep !== rightStep - 1) ? items[leftStep].n + " - " + items[rightStep - 1].n : (items[s] && items[s].n) || '';
                
                this.summary.innerHTML = summary;
                
                return summary;
            }
            
        }
    );
    
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Calendar",
                         "mstrmojo._TouchGestures");
    
    
    mstrmojo.MobileCalendar = mstrmojo.declare(
        
        mstrmojo.Calendar,
        
        [mstrmojo._TouchGestures],
        
        
        {
            scriptClass: "mstrmojo.MobileCalendar",
            
            
            cssPrefix: 'mobile-calendar',

            
            monthNames: function(i){ return mstrmojo.locales.datetime.MONTHNAME_FULL[i]; },
            
            
            
            supportedViews: {
                day: true,
                month: true,
                year: true
            },
            
            
            premousedown: function premousedown(e) {
                
                if (!mstrApp.isTouchApp()) {
                    return this._super(e);
                }
            },
            
            
            touchTap: function touchTap(touch) {
                
                this.processEvent(document.elementFromPoint(touch.pageX, touch.pageY));
                
                return false;
            }
        }
    );
    
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Stepper",
                         "mstrmojo._TouchGestures");
      
    
    mstrmojo.ui.MobileStepper = mstrmojo.declare(
        
        mstrmojo.Stepper,
            
        
        [ mstrmojo._TouchGestures ],
            
        {

            scriptClass: "mstrmojo.ui.MobileStepper",
            
            
            onclick: function onclick(evt) {
                
                if (!mstrApp.isTouchApp()) {
                    this._super(evt);
                }
                return false;
            },

            
            onmousedown: function onmousedown(evt) {
                
                if (!mstrApp.isTouchApp()) {
                    this._super(evt);
                }
                return false;
            },
            
            
            onmouseup: function onmouseup(evt) {
                
                if (!mstrApp.isTouchApp()) {
                    this._super(evt);
                }
                return false;
            },
            
            
            touchSelectBegin: function touchSelectBegin(touch) {
                
                this.startStepperInterval(touch, 'touchTap');
            },
            
            
            touchSelectEnd: function touchSelectEnd(touch) {
                
                this.stopStepperInterval();
            },
            
            
            touchTap: function touchTap(touch) {
                this.processEvent(touch.target);
            },
            
            
            touchBegin: function touchBegin(touch){
                var dom = touch.target;
                if (dom == this.nextNode || dom == this.prevNode){
                    mstrmojo.css.addClass(dom, 'glow');
                }
            },
            
            
            touchEnd: function touchEnd(touch){
                var dom = touch.target;
                if (dom == this.nextNode || dom == this.prevNode){
                    mstrmojo.css.removeClass(dom, 'glow');
                }
            }
        }
    );
    
    
    
    mstrmojo.ui.MobileStepper.prototype.markupString = mstrmojo.ui.MobileStepper.prototype.markupString.replace(',mousedown,mouseup', '');
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Image",
                         "mstrmojo._TouchGestures");

    
    mstrmojo.android.ui.Image = mstrmojo.declare(

        mstrmojo.Image,

        [ mstrmojo._TouchGestures ],

        
        {
            scriptClass: "mstrmojo.android.ui.Image",
            
            touchTap: mstrmojo.emptyFn
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.Button",
                         "mstrmojo.url");

    mstrmojo.requiresDescs(1442, 2140);
    
    var $NIB = mstrmojo.Button.newInteractiveButton;

    mstrmojo.android.inputControls.SignatureDIC = mstrmojo.declare(

        mstrmojo.Widget,

        [ mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: 'mstrmojo.android.inputControls.SignatureDIC',

            markupString: '<div></div>',

            
            hasSignature: false,

            
            showInPopup: function showInPopup() {
                var ownerObj = this.ownerCell || this.owner;

                
                if (ownerObj.mdf) {
                    var me = this;
                    mstrmojo.confirm('Continuing will erase the existing signature. Do you want to proceed?', [ $NIB(mstrmojo.desc(2140, 'Cancel'), null, null), $NIB(mstrmojo.desc(1442, 'Ok'), function () {
                        me.captureSignature();
                    }, null) ]);
                } else {
                    this.captureSignature();
                }
            },

            
            captureSignature: function captureSignature() {
                mstrMobileApp.captureSignature(JSON.stringify({
                    serverURL: mstrApp.getConfiguration().getTaskUrlByProject(mstrApp.getCurrentProjectId()),
                    sessionState: mstrApp.getSessionState(),
                    showGuideLine: this.dic.sgl
                }), 'mstrmojo.all["' + this.id + '"].signatureCaptured');
            },

            
            signatureCaptured: function signatureCaptured(imagePath) {
                this.value = mstrmojo.url.getAbsoluteURL(imagePath, mstrApp.getConfiguration().getCurrentProjectWebServerUrl());

                this.applyChanges();
            },

            renderPreview: function renderPreview() {
                var previewValue = '',
                    ownerObj = this.ownerCell || this.owner,
                    openerNode = this.openerNode,
                    sigValue = this.value;

                
                if (ownerObj.mdf && /^(http|https).+(png|jpg)$/.test(sigValue)) {
                    previewValue = '<img src="' + this.value + '" style="max-height:' + openerNode.clientHeight + 'px;max-width:' + (openerNode.clientWidth - 30) + 'px;"></img>\u00a0';
                }

                this.renderPreviewButton(openerNode, previewValue);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Button",
                         "mstrmojo.css",
                         "mstrmojo.hash");

    var $CSS = mstrmojo.css,
        $HASH = mstrmojo.hash,
        cssGlow = 'glow';

    
    var $BTN = mstrmojo.android.ui.Button = mstrmojo.declare(
        mstrmojo.Button,

        [ mstrmojo._TouchGestures ],

        
        {
            scriptClass: 'mstrmojo.android.ui.Button',

            onclick: mstrmojo.emptyFn,

            touchBegin: function touchBegin() {
                
            	if ( this.enabled ) {
                    $CSS.addClass(this.domNode, cssGlow);
            	}
            }, 

            touchTap: function touchTap(touch) {
                
            	if ( this.enabled ) {
	                this.onclick({
	                    e: touch.evt
	                });
            	}
            },

            
            touchSelectBegin: mstrmojo.emptyFn,

            touchSelectEnd: function touchSelectEnd(touch) {
                
            	if ( this.enabled ) {
                    this.onclick({
                        e: touch.evt
                    });
            	}
            },

            touchEnd: function touchEnd() {
                
                $CSS.removeClass(this.domNode, cssGlow);
            }
        }
    );

    
    $BTN.prototype.markupString = $BTN.prototype.markupString.replace(new RegExp(' mstrAttach:[a-zA-Z,]*'), '');

    
    $BTN.newButton = function newButton(text, fnClick, props) {
        
        var btn = {
            scriptClass: 'mstrmojo.android.ui.Button',
            text: text
        };

        
        if (fnClick) {
            btn.onclick = fnClick;
        }

        
        $HASH.copy(props, btn);

        return btn;
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.OfflineTransactionModel",
                         "mstrmojo.Button");

    
    mstrmojo._CanSupportOfflineTransactions = mstrmojo.provide(
        "mstrmojo._CanSupportOfflineTransactions",
        {
            _mixinName: "mstrmojo._CanSupportOfflineTransactions",

            getTransactionNotificationController: function getTransactionNotificationController() {
                var ctl = this.txNtfCtlr;

                
                if (this.oflnTxModel && (!ctl || !mstrmojo.all[ctl.id])) {
                    ctl = this.txNtfCtlr = mstrApp.controllerFactory.newController('Transactions', {
                        model: this.oflnTxModel,
                        rootCtrl: mstrApp.rootController
                    });
                }

                return ctl;
            },

            submitTransactionQueue: function submitTransactionQueue(projectId, taskId) {
                mstrMobileApp.submitOfflineTransactions(projectId, taskId, 'mstrApp.onSubmitTransactionQueueDone');
            },

            
            onSubmitTransactionQueueDone: function onSubmitTransactionQueueDone(status, res) {
                if (this.oflnTxModel) {
                    this.oflnTxModel.onSubmitDone(status);
                }

                
                if (status) {
                    
                    mstrApp.rootController.generateActionToolbar();
                    mstrmojo.toast(mstrmojo.desc(9724, 'All pending transactions have been successfully submitted'));
                } else {
                    mstrmojo.toast(mstrmojo.desc(9261, 'A background transaction submission failed'));
                }
            },

            submitOfflineTransaction: function submitOfflineTransaction() {
                if (this.oflnTxModel) {
                    this.oflnTxModel.submitOfflineTransaction();
                }
            }

        }
    );

}());
(function() {
    mstrmojo.requiresCls("mstrmojo.css", "mstrmojo.ImageToggle", "mstrmojo._IsInputControl");
    
    
    mstrmojo.ToggleDIC = mstrmojo.declare(
        mstrmojo.ImageToggle,
        
        [mstrmojo._IsInputControl],
        
        {                  
            scriptClass: 'mstrmojo.ToggleDIC',
            
            init: function(props){
                this._super(props);
                
                this.unset = this.dic.ust;
            },
            
            focus: function(){
                this.domNode.focus();
            },
            
            onvalueChange: function(){
                
            },
            
            onblur: function(e){
                var evt = e.e || e,
                    dom = this.domNode,
                    ofst = mstrmojo.boxmodel.offset(dom, document.body);
                if(evt.clientX > ofst.left && evt.clientX < ofst.left + dom.offsetWidth && evt.clientY > ofst.top && evt.clientY < ofst.top + dom.offsetHeight) {
                    this.domNode.focus();    
                } else {
                    this.applyChanges();
                }
            },
            
            postBuildRendering: function(){
                if (this._super){
                    this._super();
                }
                
                if (this.showByDefault){
                    var ops = this.openerStyle;
                    
                    this.width = ops.iw;
                    this.height = ops.ih;
                    this.set('imageList', this.dic.vls);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Label",
                         "mstrmojo._TouchGestures");

    
    mstrmojo.android.ui.Label = mstrmojo.declare(

        mstrmojo.Label,

        [ mstrmojo._TouchGestures ],

        
        {
            scriptClass: "mstrmojo.android.ui.Label",

            
            touchTap: mstrmojo.emptyFn
        }
    );
}());
(function () {    

    
    mstrmojo.requiresCls(
            "mstrmojo.Label",
            "mstrmojo.css",
            "mstrmojo.hash");
    
    
    mstrmojo.TristateCheckBox = mstrmojo.declare(
            
            mstrmojo.Label,
            
            
            null,
            
            
            {
                scriptClass:'mstrmojo.TristateCheckBox', 
                grayed: true,
                checked: true,
                cssClass: 'tristate',                
                onclick: function() {
                    if (this.grayed) {
                        this.set('grayed', !this.grayed);
                    } else {
                        this.set('checked', !this.checked);
                    }
                },
                markupMethods: mstrmojo.hash.copy({
                    oncheckedChange: function() {
                        mstrmojo.css.toggleClass(this.domNode, 'checked', this.checked);
                    },
                    ongrayedChange: function() {
                        mstrmojo.css.toggleClass(this.domNode, 'grayed', this.grayed);
                    },
                    onenabledChange: function() {
                        mstrmojo.css.toggleClass(this.domNode, 'disabled', !this.enabled);
                    }
                }, mstrmojo.hash.copy(mstrmojo.Label.prototype.markupMethods))
            }
    ); 
    
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._IsList");

    var markup;

    
    mstrmojo.SuggestionList = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._IsList ],

        
        {
            scriptClass: 'mstrmojo.SuggestionList',

            itemField: 'n',

            getItemMarkup: function (item, idx) {
                
                if (!markup) {
                    var itemField = this.itemField;
                    markup = this._super(item).replace('>{@n}<', ' title="{@' + itemField + '}">{@' + itemField + '}<');
                }

                
                return markup;
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx),
                    itemField = this.itemField;

                
                props[itemField] = item[itemField];

                return props;
            },

            onclick: function onclick(evt) {
                this._super(evt);

                var parent = this.parent,
                    opener = parent.opener;

                
                opener.suggestionShown = false;

                
                var item = this.selectedItem;
                if (item) {
                    
                    opener.handleSuggestionItemSelect(item);
                }

                
                parent.close();
            },

            bindings: {
                itemField: 'this.parent.opener.itemField',
                items: 'this.parent.opener.suggestionItems'
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo.android._IsList",
                         "mstrmojo.android._HasLingeringListSelections",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.css");

    var itemMarkup,
    	$D = mstrmojo.dom,
    	$TRANS_DURATION = $D.CSS3_TRANSITION_DURATION;

    
    mstrmojo.android.ui.ActionToolbarButtons = mstrmojo.declare(
        mstrmojo.ListBase,

        [ mstrmojo.android._IsList, mstrmojo.android._HasLingeringListSelections, mstrmojo._TouchGestures ],

        
        {
            scriptClass: 'mstrmojo.android.ui.ActionToolbarButtons',

            init: function init(props) {
                this._super(props);

                
                mstrmojo.css.addWidgetCssClass(this, 'mstrmojo-ActionToolbar-buttons');
            },

            cssDisplay: 'table',

            icnCssText: 'display:table-row',

            getItemMarkup: function getItemMarkup(item) {
                if (!itemMarkup) {
                    itemMarkup = this._super(item).replace('>{@n}', ' title="{@n}"><div></div>');
                }

                return itemMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                
                var props = this._super(item, idx);

                
                props.addCls(item.cls);

                
                return props;
            },

            listHooks: {
                select: function (el) {
                    
                    el.style[$TRANS_DURATION] = 0;

                    
                    this.setClearHandler(200);
                },
                unselect: function (el) {
                    
                    el.style[$TRANS_DURATION] = '300ms';
                }
            },

            preselectionChange: function preselectionChange(evt) {
                
                if (evt.added) {
                    
                    return !!this.parent.active;
                }

                
                return true;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo.android._IsList",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    
    function cleanUpMenu() {
        
        var handler = this._tchHandler;
        if (handler) {
            
            handler.clear();
            delete this._tchHandler;
        }

        
        this.clearSelect();

        
        mstrApp.setMenuStatus(this.id, false);
    }

    
    mstrmojo.android.ui.Menu = mstrmojo.declare(
        mstrmojo.ListBase,

        [ mstrmojo.android._IsList, mstrmojo._TouchGestures ],

        
        {
            scriptClass: 'mstrmojo.android.ui.Menu',

            init: function init(props) {
                this._super(props);

                
                mstrmojo.css.addWidgetCssClass(this, 'mstrmojo-ActionMenu');
                
                this._lastVisible = this.visible;
            },

            
            setMaxWidth: false,

            markupMethods: {
                onvisibleChange: function () {
                    var isVisible = !!this.visible,
                        domNode = this.domNode,
                        domNodeStyle = domNode.style;

                    
                    domNodeStyle.display = (isVisible) ? this.cssDisplay : 'none';
                    
                    
                    if (this.parent && this.parent.propogateMenuVisibleChange && isVisible != this._lastVisible) {
                    	this._lastVisible = isVisible;
                    	this.parent.propogateMenuVisibleChange(isVisible);
                    }
                    
                    
                    if (isVisible && this.setMaxWidth) {
                        
                        domNodeStyle.maxWidth = (Math.round(mstrApp.getScreenDimensions().w * 0.98) - mstrmojo.dom.position(domNode).x) + 'px';
                    }
                }
            },

            onvisibleChange: function onvisibleChange(evt) {
                
                if (evt.value) {
                    
                    var id = this.id;
                    this._tchHandler = mstrmojo.touchManager.attachEventListener('touchesBegin', id, function (evt) {
                        
                        if (evt.srcId !== id) {
                            
                            this.set('visible', false);

                            
                            evt.ignore = true;
                        }
                    });

                    
                    mstrApp.setMenuStatus(id, true);

                } else {
                    
                    cleanUpMenu.call(this);
                }
            },

            onUnRender: function onUnRender() {
                
                cleanUpMenu.call(this);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android._IsList",
                         "mstrmojo.array",
                         "mstrmojo.css");

    var $ARR = mstrmojo.array,
        $CSS = mstrmojo.css,
        $MATH = Math,
        cssFixed = 'fixed';

    
    function positionTabs(selectedIdx, offset) {
        var domNode = this.domNode,
            width = domNode.clientWidth,
            map = this._itemSizeMap,
            preIdx = selectedIdx - 1,
            postIdx = selectedIdx + 1;

        
        offset = offset || 0;

        
        $ARR.forEach(this.itemsContainerNode.childNodes, function (node, idx) {
            
            var left = 0;

            
            if (idx === selectedIdx) {
                
                left = (width / 2) - (map[idx] / 2);

            
            } else if (idx === postIdx) {
                
                left = width - map[idx];

            
            } else if (idx !== preIdx) {
                
                left = -(width / 2);

                
                if (idx > postIdx) {
                    
                    left = width + (-1 * left);
                }
            }

            
            var leftPosition = $MATH.round(left + offset / 2) + 'px';
            if (node.style.left !== leftPosition) {
                
                node.style.left = leftPosition;
            }

            
            node.style.left = (left + offset / 2) + 'px';
        });
    }

    
    mstrmojo.android.ui.ScrollableTabs = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._TouchGestures, mstrmojo.android._IsList ],

        
        {
            scriptClass: 'mstrmojo.android.ui.ScrollableTabs',

            multiSelect: false,

            init: function init(props) {
                this._super(props);

                
                mstrmojo.css.addWidgetCssClass(this, 'mstrmojo-ScrollableTabs');
            },

            
            setCurrentTab: function setCurrentTab(idx) {
                
                this.clearSelect();

                
                this.singleSelect(idx, true);

                
                this.itemRenderer.select(this._getItemNode(idx), this.items[idx], idx, this);

                
                positionTabs.call(this, idx);
            },

            
            tabSelected: mstrmojo.emptyFn,


            
            postitemsChange: function postitemsChange() {
                
                var itemSizeMap = this._itemSizeMap = [],
                    items = this.items,
                    domNode = this.domNode;

                
                if (items && items.length) {
                    
                    $ARR.forEach(this.itemsContainerNode.childNodes, function (node, idx) {
                        
                        itemSizeMap[idx] = node.offsetWidth;
                    });
                } else {
                    
                    this.set('visible', false);
                }

                
                $CSS.addClass(domNode, cssFixed);

                
                positionTabs.call(this, $MATH.max(this.selectedIndex || 0, 0));

                window.setTimeout(function () {
                    
                    $CSS.removeClass(domNode, cssFixed);
                }, 0);
            },

            
            postselectionChange: function postselectionChange(evt) {
                
                var added = evt.added;
                if (added) {
                    
                    this.tabSelected(this.items[added[0]]);
                }
            },

            
            enterScroll: function enterScroll() {
                
                $CSS.addClass(this.domNode, cssFixed);
            },

            
            scroll: function scroll(delta) {
                
                positionTabs.call(this, this.selectedIndex, delta);
            },

            
            exitScroll: function exitScroll(idx) {
                
                $CSS.removeClass(this.domNode, cssFixed);

                
                this.setCurrentTab(idx);
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.ListBase");

    
    mstrmojo.SelectBox = mstrmojo.declare(
        
        mstrmojo.ListBase,
        
        
        null,
        
         
        {
            scriptClass: "mstrmojo.SelectBox",
            
            size: 10,
            
            cssDisplay: 'inline',
            
            markupString: '<select id="{@id}" class="mstrmojo-SelectBox {@cssClass}" style="{@cssText}" size="{@size}" {@multipleHtml} ' +
                                     'mstrAttach:keyup,change >' + 
                                     '{@itemsHtml}' + 
                                 '</select>',
            
            markupSlots: {
                itemsContainerNode: function(){return this.domNode; },
                scrollboxNode: function(){return this.domNode; }
            },
            
            
            markupMethods: {
                onvisibleChange: function(){ this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; },
                onenabledChange: function(){ this.domNode.disabled = !this.enabled;}
            },

            
            itemCssClass: "mstrmojo-selectbox-item",

            
            itemDisplayField: 'n',

            
            itemIdField: 'v',
            
            
            showItemTooltip: false,
                        
            
            itemRenderer: {
                render: function( item,  idx,  widget) {
                    var itemNm = mstrmojo.string.htmlAngles((widget.getItemName) ? widget.getItemName(item, idx) : (widget.itemDisplayField && item[widget.itemDisplayField]));
                    
                    return '<option class="' + widget.itemCssClass + '" ' +
                                'value="' + ((widget.getItemValue) ? widget.getItemValue(item, idx) : (widget.itemIdField && item[widget.itemIdField])) + '" ' + 
                                ((widget.selectedIndices[idx]) ? 'selected="true" ' : '') + ((widget.showItemTooltip)? 'title="' + mstrmojo.string.encodeXMLAttribute(itemNm)+ '"' : '') + '>' +
                                    itemNm + 
                           '</option>';
                },
                select: function( el,  item,  idx,  widget) {
                    el.selected = true;
                },
                unselect: function( el,  item,  idx,  widget) {
                    el.selected = false;
                }
            },
            
            
            buildRendering: function bldRnd(){
                this.multipleHtml = this.multiSelect ? ' multiple="true" ' : '';
                this._super();
                delete this.multipleHtml;
            },
            
            _getItemNode: function(idx) {
                
                var s = this.scrollboxNode;
                return s && s.options[idx];
            },

            
            prechange: function prechg(evt) {
                
                
                
                if (this._syncDom) {
                    return;
                }
                
                this._syncDom = true;

                var el = this.scrollboxNode;
                
                
                if (this.multiSelect) {
                    
                    var os = el.options,
                        idxs = [];
                    for (var i=0, len=os.length; i<len; i++) {
                        if (os[i].selected) {
                            idxs.push(i);
                        }
                    }
                    this.select(idxs);
                } else {
                    
                    this.singleSelect(el.selectedIndex);
                }
                
                delete this._syncDom;
            },
            
            
            prekeyup: function(evt) {
                var el = this.scrollboxNode,
                isChanged = false; 

                if (this.multiSelect) {
                    
                    var os = el.options;
                    for (var i=0, len=os.length; i<len; i++) {
                        if (os[i].selected !== !!this.selectedIndices[i]) {
                            isChanged = true;
                            break;
                        }
                    }

                } else {
                   if (el.selectedIndex !== this.selectedIndex) {
                       isChanged = true;
                   }
                }
                if (isChanged) { 
                    var e = evt;
                    e.name = "change";
                    this.raiseEvent(evt);
                }
            },
            
            
            onselectionChange: function onselchg(evt){
                if (!this._syncDom) {
                    this._super(evt);
                }
            }
            
        }
    );
    
})();            

(function() {
	mstrmojo.requiresCls(
			"mstrmojo.mstr.EnumFunction",
			"mstrmojo.mstr.EnumWebFunctionType",
			"mstrmojo.mstr.EnumExpressionType",
			"mstrmojo.mstr.EnumNodeType",
			"mstrmojo.mstr.EnumDataType",
			"mstrmojo.mstr.WebOperatorNode",
			"mstrmojo.mstr.WebFormShortcutNode",
			"mstrmojo.mstr.WebConstantNode",
			"mstrmojo.mstr.WebTimeNode"
			);
	var $F = mstrmojo.mstr.EnumFunction,
		$F_TP = mstrmojo.mstr.EnumWebFunctionType,
		$EXP_TP = mstrmojo.mstr.EnumExpressionType,
		$N_T = mstrmojo.mstr.EnumNodeType,
		$D_T = mstrmojo.mstr.EnumDataType;
	mstrmojo.mstr.WebExpression = mstrmojo.declare(
			
			mstrmojo.Obj,
			
			null,
			
			{
				scriptClass: 'mstrmojo.mstr.WebExpression',
				
				rottNode: null,
				init: function(props) {
					if (!props) {
						props = {};
					}
					if (!props.rootNode) {
						props.rootNode = new mstrmojo.mstr.WebOperatorNode({
							exprType: $EXP_TP.FilterBranchQual,
							funcType: $F_TP.WebFunctionTypeGeneric,
							func: $F.FunctionAnd
						});
					}
					if (this._super) {
						this._super(props);
					}
				},
				
				createOperatorNode: function createOperatorNode(expressionType, func, parent){
					if (!parent) {
						parent = this.rootNode;
					}
					var node = new mstrmojo.mstr.WebOperatorNode({exprType:expressionType});
					node.set('func', func);
					parent.appendChild(node);
					return node;
				},
				createFormShortcutNode:function createFormShortcutNode(attr, form, parent){
					if (!parent) {
						parent = this.rootNode;
					}
					
					var node = new mstrmojo.mstr.WebFormShortcutNode({
						attribute: attr,
						form: form
					});
					parent.appendChild(node);
					return node;
				},
				createValueNode: function createValueNode(value, dataType, parent) {
					var node = null;
					switch (dataType) {
					case $D_T.DataTypeDate:
					case $D_T.DataTypeTime:
					case $D_T.DataTypeTimeStamp:
						return this.createTimeNode(value, parent);
					default: 
						return this.createConstantNode(value, dataType, parent);
					}
				},
				createConstantNode: function createConstantNode(value, dataType, parent) {
					if (!parent) {
						parent = this.rootNode;
					}
					var  node = new mstrmojo.mstr.WebConstantNode({
						value: value,
						type: dataType
					});
					parent.appendChild(node);
					return node;
				},
				
				createTimeNode: function(time, parent){
					var node = new mstrmojo.mstr.WebTimeNode({
						value: time
					});
					if (!parent) {
						parent = this.rootNode;
					}
					parent.appendChild(node);
					return node;
				},
				newAQSubExpression: function(attr,  form,  func, dt, value){
					if (func < 0) {
						func = $F.FunctionEquals;
					}
					var subExpr = this.createOperatorNode($EXP_TP.FilterSingleBaseFormQual, func),
						fmNode = this.createFormShortcutNode(attr, form, subExpr),
						valNode = this.createValueNode(value, dt, subExpr);
					return subExpr;
				},
				buildShortXML: function buildShortXML(builder) {
					builder.addChild('exp');
					var rt = this.rootNode;
					if (rt) {
						if (rt.exprType == $EXP_TP.FilterBranchQual
							&& rt.nodeType == $N_T.NodeOperator) {
							if (!rt.childNodes || !rt.childNodes.length) {
								
							} else if (rt.childNodes.length == 1) {
								if (rt.func == $F.FunctionAnd || rt.func == $F.FunctionOr) {
									rt.childNodes[0].buildShortXML(builder);
								} else { 
									rt.buildShortXML(builder);
								}
							} else { 
								rt.buildShortXML(builder);
							}
						} else { 
							rt.buildShortXML(builder);
						}
					}
					builder.closeElement(); 
				}
				
			}
			);
	
})();

(function() {
    mstrmojo.requiresCls("mstrmojo.prompt.WebPrompt",
                         "mstrmojo.array",
                         "mstrmojo.mstr.EnumDataType",
                         "mstrmojo.mstr.WebAttribute",
                         "mstrmojo.mstr.WebElements",
                         "mstrmojo.mstr.WebAttributeForm",
                         "mstrmojo.mstr.WebExpression",
                         "mstrmojo.mstr.WebFilter");
    
    mstrmojo.requiresDescs(8407,8408,8759);
    
    var $ARF = mstrmojo.array.forEach;
    var promptStyles = mstrmojo.prompt.WebPrompt.STYLES;

    
    var geoMapping = {
        0: 'country',
        1: 'administrative_area_level_1',
        2: 'locality',
        3: 'postal_code'
    };
    
    function findGeoValue (results, p) {
        results = results || [];
        
        var mapping = (p && p.prs && p.prs.GeographicMapping) || 0,
            type = geoMapping[mapping],
            fnd = false,
            v = '';
        
        $ARF(results, function (r) {
            $ARF(r.address_components, function (a) {
                $ARF(a.types, function (ti) {
                    if (ti === type) {
                        v = a.short_name;
                        fnd = true;
                        return false;
                    }
                });
                
                if (fnd) {
                    return false;
                }
            });
            
            if (fnd) {
                return false;
            }
        });        
        return v;
    }
    
    var $F = mstrmojo.mstr.EnumFunction,
        $D_T = mstrmojo.mstr.EnumDataType;

    function populateElementsFromDateAnswer(callbacks) {
        var dates = this.dateAnswer,
            len = dates && dates.length, 
            i = 1;
        if (len) {
            var form = new mstrmojo.mstr.WebAttributeForm({did: this.origin.dateFormID}),
                expr = new mstrmojo.mstr.WebExpression(),
                filter = new mstrmojo.mstr.WebFilter({expression: expr}),
                node = expr.newAQSubExpression(this.origin, form, $F.FunctionIn, $D_T.DataTypeDate, dates[0]);
            
            for (; i < len; i ++) {
                expr.createTimeNode(dates[i], node);
            }
            
            var elems = this.origin.getElements({
                shortFilterXML: filter.getXML(),
                blockBegin: 1,
                blockCount: -1
            });
            
            var me = this,
                fnSuccess = callbacks.success;
            callbacks.success = function() {
                me.dateAnswer = null;
                me.answer.set('items', elems.items);
                
                if ( ! elems.items.length && callbacks.failure ) {
                    callbacks.failure(mstrmojo.desc(8759, "No data found for the selected date(s)."));
                } else {
                    fnSuccess();
                }
            };
            
            elems.getItems(0, callbacks);
        } else {
            this.answer.set('items', []);
            this.dateAnswer = null;
            callbacks.success();
        }
    } 
    
    
    mstrmojo.prompt.WebElementsPrompt = mstrmojo.declare(
        
        mstrmojo.prompt.WebPrompt,
        
        null, 
        
        {
            scriptClass: 'mstrmojo.prompt.WebElementsPrompt',
            
            answer: '',
            
            preAnswer: '',
            
            defAnswer: '',
            
            suggestion: null,
            
            origin: null,
            
            filter: null,
            
            dateAnswer: null,
            
            getStyle: function getStyle() {
                var style = this._style;
                if (!style) {
                    var promptProperties = this.prs;
                    
                    
                    if (promptProperties['DisplayStyle'] === 'Calendar' && !!this.origin.dateFormID) {
                    	style = promptStyles.CALENDAR;
                    } else {
                        style = promptStyles.LIST;
                    }
                    
                    this._style = style;
                }
                
                return style;
            },
            
            
            syncDateAnswer: function syncDateAnswer(callbacks) {
                if (this.dateAnswer) {
                    populateElementsFromDateAnswer.call(this,  callbacks);
                } else {
                    callbacks.success();
                }
            },
            
            validate: function validate(v){
            	
            	this._super(v);
            	v = (v === undefined || v === null) ? (this.answer && this.answer.items) : v;
                var cnt = (v && v.length) || 0,
                    min = parseInt(this.min, 10),
                    max = parseInt(this.max, 10),
                    errText = '';
                
                if (!isNaN(min) && cnt < min){
                    errText = mstrmojo.desc(8407, 'You have made (#) selections, which is fewer selections than the required (##) for this prompt. Please make more selections.').replace('##', min).replace('#', cnt);
                } else if (!isNaN(max) && cnt > max) {
                    errText = mstrmojo.desc(8408, 'You have made (#) selections, which is more selections than are allowed (##) for this prompt. Please remove some selections.').replace('##', max).replace('#', cnt);
                }
                
                if (errText) {
                    throw new Error(errText);
                }
            },
            
            isAnswerEmpty: function isAnswerEmpty(v){
            	v = (v === undefined || v === null) ? (this.answer && this.answer.items) : v;
            	return (!v) || (v.length == 0);
            },
            
            
            getAvailable: function getAvailable() {
            	var res;
            	if (this.suggestion && this.suggestion.items.length > 0) {
	            	res = this.suggestion;
            	} else {
                    res = this.origin.getElements();
            	}
            	
            	return res;
            },
            
            canSearch: function canSearch() {
                
                return ! (this.suggestion && this.suggestion.items.length > 0);
            },
            
            getDisplayValue: function getDisplayValue() {
            	
            	if (this.getStyle() == mstrmojo.prompt.WebPrompt.STYLES.CALENDAR && this.dateAnswer) {
            		return this.dateAnswer.join(',');
            	}
            	else {
                    var answer = this.answer,
                    items = (answer && answer.items) || [],
                    i = 0,
                    len = items.length,
                    value = [];
                
	                
	                for (; i < len; i++) {
	                    value.push(items[i].n);
	                }
	                
	                
	                return value.join(', ');
            	}
            },
            
            getAnswerAsDateArray: function() {
            	var dateUtil = mstrmojo.date,
            		dates = [],
            		i,
            		dateObj,
            		dateAnswer = this.dateAnswer,
            		answer = this.answer && this.answer.items;
            	if (this.getStyle() == mstrmojo.prompt.WebPrompt.STYLES.CALENDAR) {
            		if (dateAnswer) {
            			for (i = 0; i < dateAnswer.length; i ++) {
            			        dateObj = dateUtil.parseDate(dateAnswer[i]);
            			        dateObj.n = dateObj.match;
            				dates.push(dateObj);
            			} 
            		} else if (answer) {
            			for (i = 0; i < answer.length; i ++) {
            			        dateObj = dateUtil.parseDate(answer[i].n);
            			        dateObj.n = dateObj.match;
            				dates.push(dateObj);
            			}
            		}
            	} 
            	return dates;
            },
            
            
            getSearch: function getSearch(searchPattern, matchCase, onTarget) {
                var cfg = {
                        searchPattern: searchPattern,
                        matchCase: matchCase
                    };
                if (onTarget) {
                    cfg.searchTarget = this.searchTarget;
                }
                return this.origin.getElements(cfg);
            },
            
            
            populate: function populate(props) {
                this._super(props);
                
                var ans = (props && props.ans && props.ans.elms) || [];
                
                
                this.answer = new mstrmojo.mstr.WebElements({
                    items: ans, 
                    totalSize: ans.length,
                    blockBegin: 1,
                    blockCount: -1
                });
                
                
                var org = props && props.orgn;
                if (org) {
                    this.origin = new mstrmojo.mstr.WebAttribute(org);
                    
                    if (this.dataSourcesXML) {
                    	this.origin.browseConfig.dataSources = this.dataSourcesXML;
                    }
                    
                    var prs = this.prs;
                    if (prs && prs.DisplayStyle === 'GeoLocation' && prs.LookupForm){
                        var att = prs.LookupForm.split('~');
                        this.searchTarget = new mstrmojo.mstr.WebAttribute({
                            did: att[0],
                            t: att[1],
                            st: att[3],
                            n: att[2]
                        });
                        
                    }
                    
                    this.answer.source = this.origin;
                }
                
                
                var suggest = props && props.suggest;
                if (suggest) {
                	var suggestion = this.suggestion = new mstrmojo.mstr.WebElements({
                		items: suggest
                	});
                }
                
                var fil = props && props.fres;
                if (fil) {
                    this.filter = new mstrmojo.mstr.WebOI(fil);
                    if (org){
                        this.origin.browseConfig.filter = this.filter;
                    }
                }
            },
            
            populateAnswer: function(answer) {
                this.answer.items = mstrmojo.hash.cloneArray(answer.ans.elms);
            },
            
            
            buildAnswerObject: function buildAnswerObject() {
                var ob =  this._super();
                ob.ans = {
                    elms: mstrmojo.hash.cloneArray(this.answer.items)
                };
                return ob;
            },
            
            prepareAnswer: function prepareAnswer(callbacks){
                this.syncDateAnswer(callbacks);
            },
            
            setAnswerValue: function setAnswerValue(v) {
                this.validate(v);
                
                if (this.getStyle() == mstrmojo.prompt.WebPrompt.STYLES.CALENDAR) {
                    this.set('dateAnswer', v);
                } else {
                    this.answer.set('items', v);
                }
            },
            
            getAnswersCount: function getAnswersCount() {
                
                if(this.dateAnswer) {
                    
                    return this.dateAnswer.length;
                } else if(this.answer) {
                    
                    return this.answer.items.length;
                }
                
                return 0;
            },              
            
            
            buildShortAnswerXML: function buildShortAnswerXML(builder) {
                if (this.dateAnswer) {
                    alert('need to sync date answers first.');
                } else {
                    if (this.answer) {
                        this.answer.buildShortXML(builder);
                    }
                }
            },
            
            getGeoTargetValue: function getGeoTargetValue(callbacks) {
                
                var me = this;
                mstrmojo.GeoLocation.getCurrentAddress(
                        {
                            success: function (address) {
                                var loc = findGeoValue(address, me);
                                if (callbacks && callbacks.success) {
                                    callbacks.success(loc);
                                }
                            }, 
                            failure: function(err){
                                if (callbacks && callbacks.failure) {
                                    callbacks.failure(err);
                                }
                            }
                        }
                    );








            }
        }
    );
}());
(function(){
    mstrmojo.requiresCls(
            "mstrmojo.Table",
            "mstrmojo.SelectBox",
            "mstrmojo._CanValidate");

    
mstrmojo.MCSUtil = mstrmojo.provide(
        "mstrmojo.MCSUtil",
        {
            
            _GENERIC: 1,
            _RANK: 2,
            _PERCENT: 3,

            
            OP: {
                _EQUALS: 0,
                _NOT_EQUALS: 1,
                _GREATER: 2,
                _GREATER_EQUAL: 3,
                _LESS: 4,
                _LESS_EQUAL: 5,
                _BETWEEN: 6,
                _NOT_BETWEEN: 7,
                _IN: 8,
                _NOT_IN: 9,
                _IS_NULL: 10,
                _IS_NOT_NULL: 11
            },

            
            Q: {
                _G: 0,
                _RT: 1,
                _RB: 2, 
                _PT: 3,
                _PB: 4 
            },

            MRPFN : {
                    'TOP' :1,
                    'BOTTOM' :2,
                    'BETWEEN' :3,
                    'EXCLUDETOP' :4,
                    'EXCLUDEBOTTOM' :5,
                    'NOTBETWEEN' :6,
                    'EQUALS' :7,
                    'DIFFERENTFROM' :8,

                    
                    'EQUALSDESCENDING': 15,
                    'NOTEQUALSDESCENDING': 16,  
                    'GREATERTHANDESCENDING': 4,  
                    'GREATERTHANEQUALSDESCENDING': 18,
                    'LESSTHANDESCENDING': 20,
                    'LESSTHANEQUALSDESCENDING': 1,   
                    'BETWEENDESCENDING': 13,
                    'NOTBETWEENDESCENDING': 14,
                    'INDESCENDING': 22,
                    'NOTINDESCENDING': 24,

                    
                    'EQUALSASCENDING': 7,      
                    'NOTEQUALSASCENDING': 8,    
                    'GREATERTHANASCENDING': 5, 
                    'GREATERTHANEQUALSASCENDING': 17,
                    'LESSTHANASCENDING': 19,
                    'LESSTHANEQUALSASCENDING': 2,  
                    'BETWEENASCENDING': 3,      
                    'NOTBETWEENASCENDING': 6,   
                    'INASCENDING': 21,
                    'NOTINASCENDING': 23
            },

            FN : {
                    'EQUALS' :6,
                    'NOTEQUALS' :7,
                    'GREATERTHAN' :8,
                    'GREATERTHANEQUALS' :10,
                    'LESSTHAN' :9,
                    'LESSTHANEQUALS' :11,
                    'BETWEEN' :17,
                    'NOTBETWEEN' :44,
                    'ISNULL' :54,
                    'ISNOTNULL' :55,
                    'IN' :22,
                    'NOTIN' :57,
                    'CONTAINS' :76,
                    'NOTCONTAINS' :79,
                    'BEGINSWITH' :77,
                    'NOTBEGINSWITH' :80,
                    'ENDSWITH' :78,
                    'NOTENDSWITH' :81,
                    'LIKE' :18,
                    'NOTLIKE' :43,
                    'AND' :19,
                    'OR' :20,
                    'NOT' :21,
                    'RANK' :23,
                    'RANKPERCENT' :59,
                    'TUPLE' :1000
            },

            F: [
                [6, 7, 8, 10, 9, 11, 17, 44, 22, 57, 54, 55], 
                [15, 16, 4, 18, 20, 1, 13, 14, 22, 24], 
                [7, 8, 5, 17, 19, 2, 3, 6, 21, 23] 
            ],

            getQuaByFunc: function(f, ft) {
                var $F = this.F,
                $Q = this.Q,
                $A = mstrmojo.array;

                var isTop = function(f) {
                    if ($A.indexOf($F[1], f) !== -1) {
                        return true;
                    } else {
                        return false;
                    }
                };

                if (ft === undefined || ft == this._GENERIC) {
                    return $Q._G;
                    } else {
                    if (isTop(f)) {
                        return (ft == this._RANK)? $Q._RT : $Q._PT;
                    } else {
                        return (ft == this._RANK)? $Q._RB : $Q._PB;
                    }
                }
            },

            getFuncInfo: function(operator, qualify) {
                var ft, f;
                switch(qualify) {
                case  this.Q._G:
                    ft = this._GENERIC;
                    f = 0;
                    break;

                case this.Q._RT:
                    ft = this._RANK;
                    f = 1;
                    break;

                case this.Q._RB:
                    ft = this._RANK;
                    f = 2;
                    break;

                case this.Q._PT:
                    ft = this._PERCENT;
                    f = 1;
                    break;

                case this.Q._PB:
                    ft = this._PERCENT;
                    f = 2;
                    break;

                default:
                    return {};
                }

                return {
                    ft: ft,
                    f: this.F[f][operator]
                };

            },

            
            getOpIdxByfunc: function(f, ft) {
                if (!f || !ft) { return -1; }

                var $F = this.F,
                $Q = this.Q,
                $A = mstrmojo.array,
                r = -1;

                switch(ft) {
                case  this._GENERIC:
                    r = $A.indexOf($F[0], f);
                    break;

                case this._RANK:
                case this._PERCENT:
                    r =  $A.indexOf($F[1], f);
                    if (r == -1) {
                        r = $A.indexOf($F[2], f);
                    }
                    break;

                }
                return r;
            },

            getIncludeByOp: function(op){
                var o = this.OP;
                switch(op){
                case o._EQUALS:
                case o._GREATER_EQUAL:
                case o._LESS_EQUAL:
                case o._BETWEEN:
                case o._IN:
                    return true;
                }
                return false;
            },

            formatNumber: function(qlfy, num, numFmts) { 
                if (qlfy == $M.Q._G)  {
                    var $N = mstrmojo.num;
                    return (numFmts.fm)? $N.formatByMask(numFmts.fm, num) : $N.format(numFmts.cat, numFmts.dp, numFmts.curr, num);
                } else if(qlfy == $M.Q._RB || qlfy == $M.Q._RT) {
                    return parseInt(num);
                } else if (qlfy == $M.Q._PB || qlfy == $M.Q._PT ) {
                    return parseFloat(num) + '%';
                }
            }
        });

var $M = mstrmojo.MCSUtil,
$V = mstrmojo.validation,
$E = mstrmojo.expr,
$NM = mstrmojo.num,
allOprs =   [{n: mstrmojo.desc(2795, "Equals"), v:$M.OP._EQUALS},
          {n: mstrmojo.desc(2796, "Does not equals"), v: $M.OP._NOT_EQUALS},
          {n: mstrmojo.desc(521, "Greater than"), v: $M.OP._GREATER},
          {n: mstrmojo.desc(522, "Greater than or equal to"), v:$M.OP._GREATER_EQUAL},
          {n: mstrmojo.desc(523, "Less than"), v: $M.OP._LESS},
          {n: mstrmojo.desc(524, "Less than or equal to"), v: $M.OP._LESS_EQUAL},
          {n: mstrmojo.desc(519, "Between (enter value1;value2)"), v: $M.OP._BETWEEN},
          {n: mstrmojo.desc(614, "Not between (enter value1;value2)"), v: $M.OP._NOT_BETWEEN},
          {n: mstrmojo.desc(898, "In (enter value1;value2; ...;valueN)"), v: $M.OP._IN},
          {n: mstrmojo.desc(2394, "Not In (enter value1;value2; ...;valueN)"), v: $M.OP._NOT_IN},
          {n: mstrmojo.desc(2202, "Is null"), v: $M.OP._IS_NULL},
          {n: mstrmojo.desc(2203, "Is not null"), v: $M.OP._IS_NOT_NULL}],
oprs = allOprs.slice(0, 10),
cellCss = "padding:2px 2px 2px 2px",
oprsNull = allOprs.slice(10, 12);




var checkRange = function(v, r, isPercent, unary, category) {
    if (category == 2) return r; 

    var vs = String(v).split(";"),
    invalid = $V.STATUSCODE.INVALID_VALIDATOR,
    valid = $V.STATUSCODE.VALID;

    if (unary && vs && vs.length >1) {
        r.code = invalid;
    } else {
        for (var i = 0; i < vs.length; i++) {
            var _v = parseFloat(vs[i], 10);
            if ( isNaN(_v) ||
                    (isPercent && ( (vs[i].match(/^\d+(\.\d+)?%$/) == null && vs[i].match(/^\d+(\.\d+)?$/) == null) || _v < 0 || _v > 100) ) ||
                    (!isPercent && vs[i].match(/\d+$/) == null)) {
                r.code = invalid;
            }
            if (r.code != valid) break;
        }
    }

    if (r.code != valid) {
        r.msg = mstrmojo.desc(6103, "Please fix any invalid data");
    }
    return r;
};

var calcTxtWidth = function(fs){
    fs = parseFloat(fs);
    if(isNaN(fs)){
        return "54px";
    }else{
        return (fs * 72 / 16) + "pt;";
    }
},
txtFontChange = function(me){
    if (me.hasRendered) {
        var s = me.domNode.style;
        s.font = me.font;
        s.width = calcTxtWidth(s.fontSize);
    } else {
        var m = me.font.match(/[^\s]*?pt/) || [];
        me.cssText = me.cssText + " font:" + me.font + "; width:" + calcTxtWidth(m[0]);
    }
},
isNumericDT = function(dt){
    if((dt >= 8 && dt <= 16) || (dt >= 23 && dt <= 25) || dt == 30){
        return false;
    }
    return true;
};

 mstrmojo.MetricQualification = mstrmojo.declare(
         
         mstrmojo.Table,
         
         null,
         {
             scriptClass: "mstrmojo.MetricQualification",
             cssClass: "qs",
             cssText: "width:100%",
             markupMethods: {
                 onvisibleChange: function() { this.domNode.style.display = this.visible ? mstrmojo.css.DISPLAY_TABLE : 'none'; }
             },

             getClientHeight: function getClientHeight(){
                 return this.domNode.clientHeight + 2;
             },

             rows: 1,
             cols: 4,
             layout: [{cells: [{cssText: "width:100%"}, {cssText: "width:56px"}, {cssText: "width:56px"}, {cssText: "width:18px"}]}],
             init: function(props) {
                 if (this._super)
                     this._super(props);

                 this._init();
             },

             _init: function(reset) {
                 switch(this.qua) {
                 case 0:
                     this.low = (this.da && this.da.low) || 0;
                     this.high = (this.da && this.da.high) || 0;
                     break;

                 case 1:
                 case 2:
                     this.low = 1;
                     this.high  = (this.da && this.da.cnt) || 0;
                     break;

                 case 3:
                 case 4:
                     this.low = 0;
                     this.high = 100;
                     break;
                 }


                 if (reset) {
                     this.cs = [];
                     this.f = this.ft = null;
                 }
                 var op=  $M.getOpIdxByfunc(this.f, this.ft),
                     opId;
                 if(this.qua == 0 || this.dt == 30){
                     opId = (op == $M.OP._IS_NOT_NULL || isNumericDT(this.dt)) ? (op == -1) ? $M.OP._GREATER_EQUAL : op : $M.OP._IS_NULL;
                 }else{
                     opId = (op == -1) ? $M.OP._GREATER_EQUAL : op;
                 }


                 this.set("opId", opId);

                 var in_cs = (this.cs && this.cs.length > 0)? $NM.toLocaleString(this.cs[0].v) : "";

                 if (this.opId ==  $M.OP._IN || this.opId ==  $M.OP._NOT_IN) {
                     for (var i = 1; i < this.cs.length; i++){
                         in_cs += ";" + $NM.toLocaleString(String(this.cs[i].v));
                     }
                 } else {
                     this.set("cs2", (this.cs && this.cs.length >1)? $NM.toLocaleString(this.cs[1].v) : "");
                 }
                 this.set("cs1", in_cs);

                 this.vldTbL.validate();
                 this.vldTbH.validate();

                 this.changeQual = false;
             },
             updateData: function udtDt(da, props){
                 this.da = da;

                 
                 
                 this.updateExpr(props);
             },

             updateExpr: function udtEp(props) {
                 if (props) {
                     this.cs = props.cs;
                     this.f = props.f;
                     this.ft = props.ft;
                     this.qua = props.qua;
                 }
                 this._init();
             },

             onquaChange: function onqChg(evt){
                 this._init(true);
                 this.func.items = (this.qua!=0)? oprs : isNumericDT(this.parent.dt) ? allOprs : oprsNull;
                 this.func.refresh();
                 this.changeQual = true;
                 this.onchange();
             },

             children: [{
                 slot: "0,0",
                 alias:"func",
                 scriptClass: "mstrmojo.SelectBox",
                 cssText: "width:100%",
                 size:1,
                 bindings: {
                     sv: "this.parent.opId",
                     font: "this.parent.font"
                 },

                 onfontChange:function(){
                     if (this.hasRendered) {
                         this.domNode.style.font = this.font;
                     } else {
                         this.cssText = "width:100%;font:" + this.font;
                     }
                 },
                 onsvChange: function(){
                     if (this.sv !== null && this.sv !==undefined){
                         this.set('selectedItem', {v:this.sv});
                     }
                 },
                 postCreate: function(){
                     if (mstrmojo.dom.isIE) {
                         this.itemDisplayField = 'n';
                         this.showItemTooltip = true;
                     }
                     this.items = (this.parent.qua!=0)? oprs: isNumericDT(this.parent.dt) ? allOprs : oprsNull;
                 },
                 onchange: function() {
                     var p = this.parent,
                     itm = this.selectedItem;
                     if (itm && itm.v !== null && itm.v !== undefined) {
                         p.set("opId", itm.v);
                     }

                     if(mstrApp.isMobile && (itm.v === $M.OP._IS_NULL || itm.v == $M.OP._IS_NOT_NULL)) {
                         if(p.onchange) {
                             p.onchange();
                         }
                     }
                 }

                 }, {
                 slot: "0,1",
                 alias: "vldTbL",
                 scriptClass : "mstrmojo.ValidationTextBox",
                 required: true,
                 dtp: $E.DTP.VARCHAR,
                 constraints: {
                     trigger: $V.TRIGGER.ALL,
                     validator: function(v){
                         var  r = {id: this.id, code: $V.STATUSCODE.VALID, msg: '' },
                         p = this.parent;
                         checkRange(v, r, (p.qua==3||p.qua==4),  (p.opId != 8 && p.opId !=9), (p.numFmts && p.numFmts.cat));
                         return r;
                     }
                 },
                 bindings: {
                     visible: "this.parent.opId!=10&&this.parent.opId!=11",
                     value: "this.parent.cs1",
                     font: "this.parent.font"
                 },

                 onfontChange:function(){
                     txtFontChange(this);
                 },

                 onValid: function() {
                     var p = this.parent,
                         box = this.domNode;
                     p.set("cs1", this.value);

                     if(box && box.value.length > 6){
                         box.title = box.value;
                     }else if(box){
                         box.title = "";
                     }

                 },
                 onvisibleChange: function() {
                     if(!this.visible){
                         this.parent.set("cs1", "");
                     }
                 },
                 onkeyup: function(evt){
                     var hWin = evt.hWin,
                         e = evt.e || hWin.event,
                         p = this.parent,
                         box = evt.src.domNode;
                     if (e.keyCode === 13 && p.apply && p.apply.enabled){
                         p.apply.onclick();
                     }

                 }

             }, {
                 slot: "0,2",
                 alias: "vldTbH",
                 scriptClass : "mstrmojo.ValidationTextBox",
                 required: true,
                 dtp: $E.DTP.VARCHAR,
                 constraints: {
                     trigger: $V.TRIGGER.ALL,
                     validator: function(v){
                         var  r = {id: this.id, code: $V.STATUSCODE.VALID, msg: '' },
                         p = this.parent;
                         checkRange(v, r, (p.qua==3||p.qua==4),  (p.opId != 8 && p.opId !=9), (p.numFmts &&p.numFmts.cat));
                         return r;
                     }
                 },
                 bindings : {
                     visible : "this.parent.opId ==7 ||this.parent.opId ==6", 
                     value: "this.parent.cs2",
                     font: "this.parent.font"
                 },

                 onfontChange:function(){
                     txtFontChange(this);
                 },

                 onValid: function() {
                     this.parent.set("cs2", this.value);

                     var box = this.domNode;

                     if(box && box.value.length > 6){
                         box.title = box.value;
                     }else if(box){
                         box.title = "";
                     }
                 },
                 onvisibleChange: function() {
                     if(!this.visible){
                         this.parent.set("cs2", "");
                     }
                 },
                 onkeyup: function(evt){
                     var hWin = evt.hWin,
                         e = evt.e || hWin.event,
                         p = this.parent;
                     if (e.keyCode === 13 && p.apply && p.apply.enabled){
                         p.apply.onclick();
                     }
                 }

             },  {
                    slot: "0,3",
                    alias: "apply",
                    title: mstrmojo.desc(2164, "Apply"),
                    scriptClass : "mstrmojo.Button",
                    cssClass : 'icn apply',
                    bindings: {
                        enabled: "(!this.parent.vldTbL.visible ||!this.parent.vldTbL.validationStatus.code)"+
                        "&& (!this.parent.vldTbH.visible||!this.parent.vldTbH.validationStatus.code)"
                   },

                    onclick: function(){
                        var p = this.parent,
                        isPercent = (p.qua == $M.Q._PT || p.qua == $M.Q._PB);
                        p.cs = [];

                        var toPrcnt = function(v){
                            return v + ((isPercent && !String(v).match(/^\d+%$/))? '%' : '');
                        };

                        var type = function(cat, qua){
                            return ((cat == 2 || cat == 3) && qua == 0)? 14 : 5;
                        };

                        if (p.opId == $M.OP._IN || p.opId == $M.OP._NOT_IN){
                            var _cs = String(p.cs1).split(";");
                            for (var i = 0; i < _cs.length; i++) {
                                if(!mstrmojo.string.isEmpty(_cs[i])) p.cs.push({dtp:5, v: toPrcnt(_cs[i])});
                            }
                        }  else {
                            if (p.vldTbL.visible) p.cs.push({dtp: type((p.numFmts && p.numFmts.cat), p.qua), v: toPrcnt(p.cs1)});
                            if (p.vldTbH.visible)  p.cs.push({dtp:  type((p.numFmts && p.numFmts.cat), p.qua), v: toPrcnt(p.cs2)});
                        }

                        if (p.onchange) {
                            p.onchange();
                        }

                        if (p.makeSelection) {
                        	p.makeSelection();
                        }
                    }
             }]
         });
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.ScrollableTabs",
                         "mstrmojo.css",
                         "mstrmojo.dom",
                         "mstrmojo.hash");

    var $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom,
        $HASH = mstrmojo.hash;

    
    mstrmojo.android.ui.LayoutSelector = mstrmojo.declare(

        mstrmojo.android.ui.ScrollableTabs,

        null,

        
        {
            scriptClass: 'mstrmojo.android.ui.LayoutSelector',

            init: function init(props) {
                this._super(props);

                
                var markupMethods = this.markupMethods = $HASH.copy(this.markupMethods);
                markupMethods.onvisibleChange = function () {
                    
                    var fadeHandle = this._hFade;
                    if (fadeHandle) {
                        
                        window.clearTimeout(fadeHandle);

                        
                        delete this._hFade;
                    }

                    
                    var items = this.items;
                    if (!items || items.length <= 1) {
                        
                        return;
                    }

                    var isVisible = !!this.visible,
                        domNode = this.domNode;

                    
                    if (isVisible) {
                        
                        domNode.style.marginTop = 0;
                    }

                    
                    $CSS.toggleClass(domNode, 'open', isVisible);
                };

            },

            
            initiateFade: function initiateFade(delay) {
                var id = this.id;
                this._hFade = window.setTimeout(function () {
                    
                    var widget = mstrmojo.all[id];
                    if (widget) {
                        
                        widget.set('visible', false);
                    }
                }, delay || 2000);
            },

            
            postBuildRendering: function postBuildRendering() {
                
                var id = this.id;
                $DOM.attachEvent(this.domNode, 'webkitTransitionEnd', function () {
                    
                    var widget = mstrmojo.all[id];
                    if (!widget.visible) {
                        
                        widget.domNode.style.marginTop = '-10000px';
                    }
                });

                return this._super();
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Box",
                         "mstrmojo.android.ui._CanBeFullScreen",
                         "mstrmojo.array",
                         "mstrmojo.css",
                         "mstrmojo.android.ui.ActionToolbarButtons",
                         "mstrmojo.android.ui.Menu",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo._TouchGestures");

    var $ARR = mstrmojo.array,
        $CSS = mstrmojo.css,
        TYPE_MENU = 1,
        TYPE_BUTTON = 2,
        MENUS = mstrmojo.android.EnumMenuOptions,
        MNU_SHARE = MENUS.SHARE,
        MNU_ANNOTATION = MENUS.ANNOTATION;

    
    function useNativeMenu() {
        return false;
    }

    
    function buttonClicked(evt) {
        
        if (!this.active) {
            
            return;
        }

        var added = evt.added,                      
            src = evt.src,                          
            item = added && src.items[added[0]],    
            menu = this.menu;

        
        if (!item) {
            
            return;
        }

        
        if (item.isMenu) {
            
            if (mstrMobileApp && mstrMobileApp.genMapPreview) {
                
                mstrMobileApp.genMapPreview();
            }
            menu.set('visible', !menu.visible);

        } else {
            
            if (item.grp !== MNU_SHARE && item.grp !== MNU_ANNOTATION) {
                mstrApp.closeAllDialogs();
            } 
            
            if (src === menu) {
                
                menu.set('visible', false);
                
                if (mstrMobileApp && mstrMobileApp.showMapView) {
                    
                    mstrMobileApp.showMapView(0);
                }
            	
            	
            }

            
            mstrmojo.all[this._actController].handleMenuItem(item.grp, item.act);
        }
    }

    
    function getMenuItems() {
        var menuItems = [],
            icons = this.icons,
            groups = this.groups,
            actions = this.actions;

        
        $ARR.forEach(this.labels, function (label, idx) {
            
            menuItems.push({
                cls: 'ic' + icons[idx],
                grp: parseInt(groups[idx], 10),
                act: parseInt(actions[idx], 10),
                n: label
            });
        });

        
        return menuItems;
    }

    
    function extractButtons(maxCnt) {
        var buttons = [],
            icons = this.icons,
            groups = this.groups,
            actions = this.actions,
            labels = this.labels;

        
        $ARR.forEach(this.types, function (type, idx) {
            
            if (type === TYPE_BUTTON) {
                
                buttons.push({
                    cls: 'ic' + icons[idx],
                    act: parseInt(actions[idx], 10),
                    grp: parseInt(groups[idx], 10),
                    idx: idx,
                    n: labels[idx]
                });

                
                if (buttons.length === maxCnt) {
                    
                    return false;
                }
            }
        });

        var i;

        
        for (i = buttons.length - 1; i >= 0; i--) {
            
            var button = buttons[i],
                menuIdx = button.idx;

            
            delete button.idx;

            
            this.types.splice(menuIdx, 1);
            this.groups.splice(menuIdx, 1);
            this.labels.splice(menuIdx, 1);
            this.actions.splice(menuIdx, 1);
            this.checked.splice(menuIdx, 1);
            this.icons.splice(menuIdx, 1);
        }

        
        return buttons;
    }

    
    var $TOOLBAR = mstrmojo.android.ui.ActionToolbar = mstrmojo.declare(
        mstrmojo.Box,

        [ mstrmojo.android.ui._CanBeFullScreen ],

        
        {
            scriptClass: 'mstrmojo.android.ui.ActionToolbar',

            
            active: true,

            init: function init(props) {
                this._super(props);

                
                $CSS.addWidgetCssClass(this, 'mstrmojo-ActionToolbar');
            },

            children: [{
                scriptClass: 'mstrmojo.android.ui.ActionToolbarButtons',
                alias: 'buttons'
            }, {
                scriptClass: 'mstrmojo.android.ui.Menu',
                alias: 'menu',
                visible: false
            }],

            
            addChildren: function addChildren(children, idx, silent) {
                this._super(children, idx, silent);

                
                $ARR.forEach(this.children, function (child) {
                    child.attachEventListener('selectionChange', this.id, buttonClicked);
                }, this);
            },

            
            setActions: function setActions(id, tbCfg) {
                
                var buttonItems = [],
                    useNative = useNativeMenu();

                
                var btnCount = tbCfg.getBtnCount(tbCfg.minBtnCount, tbCfg.maxBtnCount);
                if (btnCount) {
                    
                    buttonItems = extractButtons.call(tbCfg, btnCount);
                }

                
                if (tbCfg.size()) {
                    
                    if (useNative) {
                        
                        mstrMobileApp.setSysMenu(id, tbCfg.groups, tbCfg.labels, tbCfg.actions, tbCfg.checked, tbCfg.icons);

                    } else {
                        
                        buttonItems.push({
                            cls: 'menu',
                            isMenu: true,
                            n: 'Menu'
                        });

                        
                        this.menu.set('items', getMenuItems.call(tbCfg));
                    }
                }

                
                this.buttons.set('items', buttonItems);

                
                this._actController = id;

                
                this.raiseEvent('renderComplete');

                
                this.resetFullScreen();
            },

            onactiveChange: function onactiveChange() {
                
                $CSS.toggleClass(this.domNode, 'inactive', !this.active);
            },

            
            reset: function reset() {
                
                this.menu.set('visible', false);
            },

            
            onEnterFullScreen: function onEnterFullScreen() {
                this.reset();
            },

            
            propogateMenuVisibleChange: function propogateMenuVisibleChange(isVisible) {
                mstrmojo.touchManager.raiseEvent({
                    name: 'actionBarMenuStateChange',
                    value: isVisible
                });
            }
        }
    );

    
    function addItem(type, groupId, label, action, checked, icon) {
        this.types.push(type);
        this.groups.push(String(groupId));
        this.labels.push(String(label));
        this.actions.push(String(action));
        this.checked.push(String(!!checked));
        this.icons.push(icon || -1);
    }

    
    $TOOLBAR.newToolbarConfig = function newToolbarConfig() {
        
        var cfg = {
            addMenuItem: function addMenuItem(groupId, label, action, checked, icon) {
                
                addItem.call(this, TYPE_MENU, groupId, label, action, checked, icon);

                
                this.mnuCount++;
            },

            addToolbarBtn: function addToolbarBtn(groupId, label, action, checked, icon) {
                
                addItem.call(this, TYPE_BUTTON, groupId, label, action, checked, icon);

                
                this.btnCount++;
            },

            getBtnCount: function getBtnCount(minCnt, maxCnt) {
                
                var btnCnt = this.btnCount;

                
                if (this.mnuCount) {
                    
                    btnCnt++;
                }

                
                var actualCnt = Math.min(btnCnt, maxCnt);

                
                if (actualCnt < minCnt) {
                    
                    return 0;
                }

                
                if (actualCnt === maxCnt) {
                    
                    if (!useNativeMenu() && (this.mnuCount || (btnCnt > actualCnt))) {
                        
                        actualCnt--;
                    }
                }

                
                return actualCnt;
            },

            clear: function clear() {
                
                this.btnCount = 0;
                this.mnuCount = 0;
                this.maxBtnCount = 5;
                this.minBtnCount = 1;
                this.types = [];
                this.groups = [];
                this.labels = [];
                this.actions = [];
                this.checked = [];
                this.icons = [];
            },

            size: function size() {
                return this.labels.length;
            }
        };

        
        cfg.clear();

        
        return cfg;
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._SupportsEllipsisText",
                         "mstrmojo.android.ui.Label",
                         "mstrmojo.android.ui.Menu",
                         "mstrmojo.css");

    var $CSS = mstrmojo.css,
        cssOversize = 'oversize',
        cssMultiLine = 'multiline',
        cssTest = [ cssOversize, cssMultiLine ];

    
    mstrmojo.android.ui.TitleLabel = mstrmojo.declare(

        mstrmojo.Container,

        [ mstrmojo._SupportsEllipsisText ],

        
        {
            scriptClass: "mstrmojo.android.ui.TitleLabel",

            markupString: '<div id="{@id}" class="mstrmojo-AndroidTitleLabel {@cssClass}" style="{@cssText}">' +
                          '</div>',

            markupSlots: {
                containerNode: function () { return this.domNode; }
            },

            markupMethods: {
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },

            children: [{
                scriptClass: 'mstrmojo.android.ui.Label',
                alias: 'lbl',
                touchTap: function () {
                	
                	mstrApp.closeAllDialogs();
                	
                    
                    var titleLabel = this.parent,
                        list = titleLabel.list,
                        items = list.items,
                        count = items && items.length;

                    
                    if (!list.visible && count) {
                        
                        if (titleLabel._isDropDown && count === 2) {
                            
                            list.singleSelect((!list.selectedIndex) ? 1 : 0);

                        } else {
                            
                        	list.set('visible', true);
                        	
                        	if (mstrMobileApp && mstrMobileApp.genMapPreview) {
                                
                                mstrMobileApp.genMapPreview();
                        	}
                        }
                    }
                }
            }, {
                scriptClass: 'mstrmojo.android.ui.Menu',
                alias: 'list',
                selectionPolicy: 'reselect',
                visible: false,
                setMaxWidth: true
            }],

            addChildren: function addChildren(children, idx, silent) {
                this._super(children, idx, silent);

                
                this.list.attachEventListener('selectionChange', this.id, function (evt) {
                    var added = evt.added,
                        list = this.list;

                    
                    list.set('visible', false);
                    
                    if (mstrMobileApp && mstrMobileApp.showMapView) {
                       
                       mstrMobileApp.showMapView(0);
                    }
               	    


                    
                    if (!added) {
                        
                        return;
                    }

                    
                    var item = list.items[added[0]];
                    if (item.isTitle) {
                        
                        return;
                    }

                    
                    if (this._isDropDown) {
                        
                        this.setText(item.n);
                    }

                    
                    this.raiseEvent({
                        name: 'listSelectionMade',
                        item: item
                    });
                });
            },

            onRender: function onRender() {
                
                var testLbl = this._testLbl = this.lbl.domNode.cloneNode(false),
                    domNode = this.domNode;

                mstrmojo.css.addClass(testLbl, 'test');

                
                testLbl.removeAttribute('onclick');
                testLbl.removeAttribute('id');

                
                domNode.insertBefore(testLbl, domNode.lastChild);
            },

            unrender: function unrender(ignoreDom) {
                
                delete this.testLbl;

                this._super(ignoreDom);
            },

            
            setText: function setText(text) {
                
                this.checkTextFit(text);
            },

            
            checkTextFit: function checkTextFit(text) {
                var displayLabel = this.lbl,
                    displayLabelNode = displayLabel.domNode,
                    testLabelNode = this._testLbl,
                    offset = this._compOffset;

                
                text = (text === undefined) ? displayLabel.text : text;

                
                if (offset === undefined) {
                    
                    var compStyle = $CSS.getComputedStyle(displayLabelNode);
                    offset = parseInt(compStyle.paddingLeft, 10) + parseInt(compStyle.paddingRight, 10);

                    
                    this._compOffset = offset;
                }

                
                testLabelNode.style.width = (displayLabelNode.parentNode.offsetWidth - offset) + 'px';

                
                testLabelNode.innerHTML = text;

                
                var displayHeight = displayLabelNode.offsetHeight,
                    isMultiLine = (testLabelNode.offsetHeight > displayHeight);

                
                $CSS.toggleClass(displayLabelNode, cssTest, isMultiLine);

                
                displayLabel.set('text', text);

                
                if (isMultiLine) {
                    
                    if (!this.ellipsize('ttl', displayLabelNode, true)) {
                        
                        $CSS.addClass(testLabelNode, cssOversize);

                        
                        testLabelNode.innerHTML = displayLabelNode.innerHTML;

                        
                        if (testLabelNode.offsetHeight === displayHeight) {
                            
                            $CSS.removeClass(displayLabelNode, cssMultiLine);
                        }

                        
                        $CSS.removeClass(testLabelNode, cssTest);
                    }
                }
            },

            
            setListItems: function setListItems(items, selectedIdx) {
                var hasItems = (items && items.length),
                    isDropDown = (selectedIdx !== undefined),
                    list = this.list;

                
                $CSS.toggleClass(this.domNode, 'has-items', hasItems);

                
                this._isDropDown = !!isDropDown;

                
                if (hasItems) {
                    
                    if (!isDropDown) {
                        
                        items = [{
                            n: mstrmojo.desc(9850, 'RECENTLY OPENED'),
                            isTitle: true
                        }].concat(items);
                    } else {
                        
                        this.setText(items[selectedIdx].n);
                    }
                }

                
                list.set('items', items);

                
                if (isDropDown) {
                    
                    list.singleSelect(selectedIdx, true);
                }
            },

            
            clearListItems: function clearListItems() {
                
                var list = this.list,
                    rtn = {
                        items: [].concat(list.items),
                        idx: list.selectedIndex
                    };

                
                mstrmojo.css.removeClass(this.domNode, 'has-items');

                
                list.set('items', []);

                
                return (rtn.idx > -1) ? rtn : null;
            },

            
            reset: function reset() {
                
                this.list.set('visible', false);

                
                this.checkTextFit();
            }
        }
    );

}());
(function() {
    mstrmojo.requiresCls("mstrmojo.TristateCheckBox", "mstrmojo._IsInputControl");
    
    
    mstrmojo.CheckBoxDIC = mstrmojo.declare(
        mstrmojo.TristateCheckBox,
        
        [mstrmojo._IsInputControl],
        
        {
            scriptClass: 'mstrmojo.CheckBoxDIC',
            
            markupString: '<div id="{@id}" class="mstrmojo-Label {@cssClass}" style="{@cssText}" tabindex="1" mstrAttach:click,keydown></div>',
            
            cssText: 'width: 0; margin:0 auto; max-height: 18px; cursor: pointer;',
            
            onclick: function() {
                
                
                if (this.grayed) {
                    this.set('grayed', !this.grayed);
                    this.set('checked', true);
                } else {
                    this.set('checked', !this.checked);
                }
            },                        
            
            oncheckedChange: function(e) {
                this.set('value', this[this.checked ? 'onValue' : 'offValue']); 
            },
            
            preBuildRendering: function(){
                this._super();
                
                var vls = this.dic.vls;
                this.offValue = vls[0].v;
                this.onValue = vls[1].v;
                
                this.grayed = (this.onValue !== this.value) && (this.offValue !== this.value);
                this.checked = (this.onValue === this.value);
            },
            
            postBuildRendering: function(){
                this._super();
                
                this.domNode.style.height = this.openerStyle.ih + 'px';
            },
            
            onkeydown: function(evt){
                var hWin = evt.hWin, 
                    e = evt.e || hWin.event;
                
                if (e.keyCode === mstrmojo.Enum_Keys.SPACE){ 
                    mstrmojo.dom.preventDefault(hWin, e);
                    this.onclick();
                }
            },
            
            focus: function(){
                this.domNode.focus();
            }
        }
    );
})();

(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.Image",
                         "mstrmojo.Label",
                         "mstrmojo.Box",
                         "mstrmojo.Button",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.android.ui.Label",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    
    var PREVIEW_CLS_NAME = mstrmojo.Image.baseCssClass + ' prv',
        $DOM = mstrmojo.dom,
        $CSS = mstrmojo.css;

    
    function togglePreviewCtrl(preview, opacity) {
        var imgNode = preview.imgNode;
        
        
        if ( imgNode ) {
        var imgNodeStyle = preview.imgNode.style;
        imgNodeStyle[$DOM.CSS3_TRANSITION_DURATION] = opacity ? '300ms' : 0;
        imgNodeStyle.opacity = opacity;
    }
    }

    
    function openObject() {
        var params = this.imgPreview.params,
            item = params && params.item;

        
        if (item) {
            
            this.onOpenItem();

            
            mstrmojo.all[params.ctrlId].executeItem(item);
        }
    }

    
    function positionScrollNode() {
        
        if (mstrApp.isTablet()) {
            
            this.updateScroller();

            
            return;
        }

        var compStyle = this._scrollStyle,
            scrollNode = this.scrollNode,
            scrollNodeContainer = scrollNode.parentNode,
            scrollView = scrollNodeContainer.parentNode;

        
        if (!compStyle) {
            
            var scrollViewCompStyle = $CSS.getComputedStyle(scrollView),
                scrollNodeCompStyle = $CSS.getComputedStyle(scrollNode);

            
            this._scrollStyle = compStyle = {
                p: parseInt(scrollViewCompStyle.paddingLeft, 10) + parseInt(scrollViewCompStyle.paddingRight, 10),
                b: 0,    
                sp: parseInt(scrollNodeCompStyle.paddingLeft, 10) + parseInt(scrollNodeCompStyle.paddingRight, 10)
            };
        }

        var px = 'px',
            scrollViewPadding = compStyle.p,
            scrollContainerBorder = compStyle.b,
            scrollElPadding = compStyle.sp,
            widgetHeight = parseInt(this.height, 10),
            widgetWidth = parseInt(this.width, 10),
            staticNode = this.staticNode,
            staticHeight = staticNode.offsetHeight,
            staticWidth = staticNode.offsetWidth,
            scrollLeft = 0,
            scrollWidth = (widgetWidth - scrollViewPadding),
            scrollHeight = (widgetHeight - staticHeight - scrollViewPadding);

        
        if (!this.controller.orientation) {
            
            scrollLeft = staticWidth;
            scrollWidth = (widgetWidth - staticWidth - scrollViewPadding);
            scrollHeight = widgetHeight - scrollViewPadding;
        }

        
        var scrollViewStyle = scrollView.style;
        scrollViewStyle.left = scrollLeft + px;
        scrollViewStyle.width = scrollWidth + px;
        scrollViewStyle.height = scrollHeight + px;

        
        var scrollNodeContainerStyle = scrollNodeContainer.style;
        scrollNodeContainerStyle.width = (scrollWidth - scrollContainerBorder) + px;
        scrollNodeContainerStyle.height = (scrollHeight - scrollContainerBorder) + px;

        
        scrollNode.style.width = (scrollWidth - scrollContainerBorder - scrollElPadding) + px;

        
        this.updateScroller();
    }

    
    var $PV = mstrmojo.android.ui.PropertiesView = mstrmojo.declare(
        mstrmojo.Container,

        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        
        {
            scriptClass: "mstrmojo.android.ui.PropertiesView",

            markupString: '<div id="{@id}" class="mstrmojo-PropertiesView {@cssClass}" style="{@cssText}">' +
                              '<div class="mstrmojo-PropertiesViewStatic"></div>' +
                              '<div class="mstrmojo-PropertiesViewScroll">' +
                                  '<div>' +
                                      '<div></div>' +
                                  '</div>' +
                              '</div>' +
                          '</div>',

            markupSlots: {
                staticNode: function () { return this.domNode.firstChild; },
                scrollNode: function () { return this.domNode.lastChild.firstChild.firstChild; }
            },

            markupMethods: {
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod
            },

            children: [{
                scriptClass: 'mstrmojo.Image',
                slot: 'staticNode',
                alias: 'imgPreview',
                cssClass: 'prv',
                visible: false,
                onload: function () {
                    
                    togglePreviewCtrl(this, 1);
                }
            }, {
                scriptClass: 'mstrmojo.Box',
                slot: 'staticNode',
                cssClass: 'btns',
                alias: 'btns',
                children: [mstrmojo.android.ui.Button.newButton(mstrmojo.desc(1900, 'View'), function () {
                    
                    openObject.call(this.parent.parent);
                }, {
                    alias: 'btnView',
                    cssClass: 'mstrmojo-GlowButton',
                    visible: false
                }), {
                    scriptClass: 'mstrmojo.android.ui.Label',
                    alias: 'txView',
                    cssClass: 'txOffline',
                    visible: false,
                    txData: {},
                    ontxDataChange: function ontxDataChange() {
                        if (!this.txData) {
                            this.set('visible', false);

                            
                            this.txData = {};
                        }
                    },
                    touchTap: function () {
                        var ctrl = mstrApp.getTransactionNotificationController(),
                            ctrlContext = ctrl && ctrl.rootCtrl.getCurrent();
                        
                        
                        if (ctrlContext) {
                            
                            if (ctrlContext.ctrlType !== 2048) {
                                ctrlContext = ctrlContext.getController('ctrlType', 2048);
                            }
                            ctrl.showNotificationBoard(ctrlContext || ctrl.rootCtrl, this.did, this.n);
                        }
                    }
                }]
            }, {
                scriptClass: 'mstrmojo.Label',
                slot: 'scrollNode',
                alias: 'lblName',
                cssClass: 'nm',
                visible: false
            }, {
                scriptClass: 'mstrmojo.Label',
                slot: 'scrollNode',
                alias: 'lblDesc',
                cssClass: 'ds'
            }, {
                scriptClass: 'mstrmojo.Label',
                slot: 'scrollNode',
                alias: 'lblCachedOn',
                cssClass: 'ch',
                text: ''
            }],

            afterViewVisible: function afterViewVisible() {
                positionScrollNode.call(this);
            },

            rootOrientationChange: function rootOrientationChange() {
                positionScrollNode.call(this);
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    scrollEl = this.scrollNode;

                
                cfg.scrollEl = scrollEl;

                
                cfg.noHScroll = true;

                
                cfg.origin = {
                    x: 0,
                    y: 0
                };

                
                var offsetEnd = Math.max(scrollEl.offsetHeight - scrollEl.parentNode.clientHeight, 0);

                
                var enableScroll = cfg.vScroll = (offsetEnd !== 0);
                if (enableScroll) {
                    
                    cfg.offset = {
                        y: {
                            start: 0,
                            end: offsetEnd
                        }
                    };
                } else {
                    
                    cfg.offset = null;
                }

                
                $CSS.toggleClass(this.domNode, 'can-scroll', enableScroll);

                return cfg;
            },

            
            onOpenItem: mstrmojo.emptyFn,

            
            updateView: function updateView(params) {
                var imgPreview = this.imgPreview,
                    lblName = this.lblName,
                    lblDescription = this.lblDesc,
                    lblCachedOn = this.lblCachedOn,
                    btnView = this.btns.btnView,
                    btnTx = this.btns.txView,
                    item = params.item,
                    viz = 'visible',
                    txt = 'text';

                
                var txtDescription = params.desc || params.defaultMsg;
                lblDescription.set(txt, txtDescription);
                lblDescription.set(viz, !!txtDescription);

                
                if (!item) {
                    
                    imgPreview.set(viz, false);
                    lblName.set(viz, false);
                    lblCachedOn.set(viz, false);
                    btnView.set(viz, false);
                    btnTx.set(viz, false);
                    delete imgPreview.params;

                } else {
                    
                    var sizes = mstrmojo.android.ui.PropertiesView.getPreviewSizes();

                    
                    if (mstrApp.isTablet() && this.controller.orientation) {
                        
                        sizes.reverse();
                    }

                    
                    
                    
                    mstrMobileApp.getScreenShot(this.id, item.pid || mstrApp.getCurrentProjectId(), item.did, sizes[0].h, sizes[0].w);

                    
                    var oldParams = imgPreview.params;
                    if (!oldParams || oldParams.did !== params.did) {
                        
                        imgPreview.set('cssClass', PREVIEW_CLS_NAME + ' i' + params.st);

                        
                        imgPreview.set('src', '');
                    }

                    
                    imgPreview.params = params;

                    
                    imgPreview.set(viz, true);

                    
                    var txtTitle = params.ttl;
                    lblName.set(txt, txtTitle);
                    lblName.set(viz, !!txtTitle);

                    
                    var cachedTime = params.cached;
                    lblCachedOn.set(txt, cachedTime);
                    lblCachedOn.set(viz, (cachedTime !== undefined));

                    
                    if (params.avail) {
                        
                        btnView.set(viz, true);

                        
                        var did = params.did;
                        if (did) {
                            var txCtlr = mstrApp.getTransactionNotificationController(),
                                isVisible = (txCtlr && txCtlr.hasTransactionQueue(did));

                            
                            btnTx.set('did', did);
                            btnTx.set('n', params.ttl);
                            btnTx.set('visible', isVisible);

                            
                            if (isVisible) {
                                
                                txCtlr.addWidgetListener(did, btnTx);
                            }
                        }

                    } else {
                        
                        btnView.set(viz, false);
                        btnTx.set(viz, false);

                    }
                }

                positionScrollNode.call(this);
            },

            
            onPreviewReady: function onPreviewReady(src) {
                
                if (src) {
                    var imgPreview = this.imgPreview;

                    
                    if (imgPreview.src !== src) {
                        
                        togglePreviewCtrl(imgPreview, 0);

                        
                        imgPreview.domNode.className = PREVIEW_CLS_NAME;

                        
                        imgPreview.set('src', src);
                    }
                }
            }
        }
    );


    
    var phoneDpiSizes = {
            160: {
                h: 150,
                w: 200
            },
            213: {
                h: 150,
                w: 200
            },
            240: {
                h: 225,
                w: 300
            },
            320: {
                h: 300,
                w: 400
            },
            480: {
                h: 300,
                w: 400
            }
        },
        tabletPortraitDpiSizes = {
            160: {
                h: 334,
                w: 400
            },
            213: {
                h: 334,
                w: 400
            },
            240: {
                h: 501,
                w: 600
            },
            320: {
                h: 668,
                w: 800
            }
        },
        tabletLandscapeDpiSizes = {
            160: {
                h: 337,
                w: 400
            },
            213: {
                h: 337,
                w: 400
            },
            240: {
                h: 506,
                w: 930
            },
            320: {
                h: 674,
                w: 1240
            }
        };

    
    $PV.getPreviewSizes = function () {
        
        var sizes = [],
            dpi = mstrMobileApp.getDeviceDPI();

        
        if (mstrApp.isTablet()) {
            
            sizes.push(tabletLandscapeDpiSizes[dpi]);

            
            sizes.push(tabletPortraitDpiSizes[dpi]);

        } else {
            
            sizes.push(phoneDpiSizes[dpi]);

        }

        
        return sizes;
    };
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.ToggleDIC",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.url",
                         "mstrmojo.array");

    mstrmojo.android.inputControls.ToggleDIC = mstrmojo.declare(

        mstrmojo.ToggleDIC,

        [ mstrmojo._TouchGestures, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: 'mstrmojo.android.inputControls.ToggleDIC',

            useAnimation: false,

            init: function init(props) {
                this._super(props);

                
                mstrmojo.array.forEach(this.dic.vls, function (v) {
                    v.n = mstrmojo.url.getAbsoluteURL(v.n, mstrApp.getConfiguration().getCurrentProjectWebServerUrl());
                });
            },

            touchTap: function touchTap() {
                this.onclick();
            },

            onclick: function onclick() {
                this._super();
                this.applyChanges();
            },

            
            onblur: mstrmojo.emptyFn
        }
    );
}());


(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.Button");

    var $BTN = mstrmojo.android.ui.Button.newButton;

    
    mstrmojo._CanMakeServerProxyRequests = mstrmojo.provide(
        'mstrmojo._CanMakeServerProxyRequests',

        
        {
            _mixinName: 'mstrmojo._CanMakeServerProxyRequests',


            
            cancelRequests: function cancelRequests() {
            	return this.serverProxy.cancelRequests();
            },

            
            serverRequest: function serverRequest(params, callback, config) {
                var app = this;

                try {
                    
                    callback = callback || {};

                    
                    config = config || {};

                    
                    config.projectId = config.projectId || this._currentProjId;

                    
                    config.mobileConfig = this.getConfiguration();

                    
                    var mthName = config.src || (arguments.callee && arguments.callee.caller.name);

                    
                    
                    var fnHideIndicator = function (flagToCheck) {
                        
                        if (config[flagToCheck + 'Wait']) {
                            
                            app.hideMessage();
                        }

                        
                        if (config[flagToCheck + 'Progress']) {
                            mstrMobileApp.hideProgress();
                        }
                    };

                    
                    if (!config.silent) {
                        
                        callback = mstrmojo.func.wrapMethods(callback, {
                            submission: function ( userInteractionRequired ) {

                                
                                if ( !userInteractionRequired ) {

                                
                                if (config.showWait) {
                                        
                                        app.showMessage();
                                    }

                                    
                                    if (config.showProgress) {
                                    	mstrMobileApp.showProgress(config.progressStateText, !!config.useRefreshProgress );
                                    }
                                }
                            },

                            failure: function (res) {
                            	
                            	fnHideIndicator('show');

                            	
                                if (res && res.requireDeviceCertificate) {
                                	
                                	
                                        var okFn = function() {
                		                try {
                		                    mstrApp.rootController.spawn(mstrApp.controllerFactory.newController("Settings", {}), {
                                                viewFn: "getCertificateAuthenticationFieldsView"
                                            });
                		                } catch (err) {
                                            res.method = mthName;
                                            mstrApp.handleError(err, app);
                		                }
                                	};
                                	mstrmojo.confirm(
                                			'Missing/invalid/expired device certificate detected. Would you like to get a new one?',
                                			[$BTN(mstrmojo.desc(1442, 'OK'), okFn), $BTN(mstrmojo.desc(221, 'Cancel'))]
                                			);

                                    return;
                                }

                                if ( ! (config.noErrorMessage || res.noErrorMessage)) {
                                    
                                    res.method = mthName;

                                    
                                    mstrApp.handleError(res, app);
                                }
                            },

                            complete: function () {
                            	
                            	fnHideIndicator('hide');
                            },

                            canceled: function() {
                            	
                            	
                            	fnHideIndicator('show');
                            }
                        });
                    }

                    
                    
                    try {
                        app.serverProxy.request(callback, params, !!config.override, config);
                    } catch (ex1) {
                        
                        callback.failure(ex1);
                    }

                } catch (ex2) {
                    
                    mstrApp.handleError(ex2, this);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.date",
                         "mstrmojo.Stepper",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.DateStepperContentProvider",
                         "mstrmojo.NumStepperContentProvider");

    var $A = mstrmojo.array,
        $D = mstrmojo.date,
        $H = mstrmojo.hash,
        $BTN = mstrmojo.android.ui.Button.newButton,
        DTP = mstrmojo.expr.DTP,
        DT = {
            interval: 1
        },
        H = {
            min: 1,
            max: 12,
            interval: 1,
            value: 12
        },
        H24 = {
            min: 0,
            max: 23,
            interval: 1,
            value: 0
        },
        M = {
            min: 0,
            max: 59,
            interval: 1
        };

    function createChildren() {
        var dtp = this.dtp,
            sc = this.stepperClass,
            value = this[this.valueField],
            children = [],
            dateText,
            timeText;

        if (this._hasDate) {
            children.push({
                scriptClass: sc,
                slot:  'monthNode',
                alias: 'monthStepper',
                title: mstrmojo.desc(871), 
                provider: this.dateProvider.monthCP
            }, {
                scriptClass: sc,
                slot:  'dayNode',
                alias: 'dayStepper',
                title: mstrmojo.desc(872), 
                provider: this.dateProvider.dayCP
            }, {
                scriptClass: sc,
                slot:  'yearNode',
                alias: 'yearStepper',
                title: mstrmojo.desc(873), 
                provider: this.dateProvider.yearCP
            });
        }

        if (this._hasTime) {
            children.push({
                scriptClass: sc,
                slot:  'hourNode',
                alias: 'hourStepper',
                provider: this.hourProvider
            }, {
                scriptClass: sc,
                slot:  'minNode',
                alias: 'minStepper',
                provider: this.minProvider
            });
        }

        
        if (!this.hideSwitchers) {
            if (dtp !== DTP.TIME) {
                dateText = (value && value.date) ? $D.formatDateInfo(value.date, mstrmojo.locales.datetime.DATEOUTPUTFORMAT) : mstrmojo.desc(2052); 
                children.push($BTN(dateText, function () { this.parent.toDateView(); }, { alias: 'dateToggle', slot: 'switcherNode', cssClass: '', selected: true }));
            }

            if (dtp !== DTP.DATE) {
                timeText = (value && value.time) ? $D.formatTimeInfo(value.time, mstrmojo.locales.datetime.TIMEOUTPUTFORMAT) : mstrmojo.desc(2170); 
                children.push($BTN(timeText, function () { this.parent.toTimeView(); }, { alias: 'timeToggle', slot: 'switcherNode', cssClass: '', selected: dtp == DTP.TIME }));
            }
        }

        if (this._hasDate) {
            this.viewCssClass = 'dateView';
        } else if (this._hasTime) {
            this.viewCssClass = 'timeView';
        }

        this.addChildren(children);
    }

    function createProviders() {
        var propNames = [this.valueField, 'min', 'max'],
            dateItem = $H.copy(DT),
            hourItem = this.is24HourMode ? $H.copy(H24) : $H.copy(H),
            minItem = $H.copy(M),
            value = this[this.valueField],
            timeValue = value && value.time,
            me = this;

        
        $A.forEach(propNames, function (p) {
            dateItem[p] = $H.copy(me[p]);
        });

        if (this._hasDate) {
            this.dateProvider = new mstrmojo.DateStepperContentProvider({
                item: dateItem,
                valField: this.valueField,
                canLoop: true,
                onTraverse: function () {
                    
                    me.updateDate();
                }
            });
        }

        if (this._hasTime) {
            
            if (this.minuteInterval !== undefined) {
                minItem.interval = this.minuteInterval;
            }

            
            delete this.minuteInterval;

            if (timeValue) {
                
                if (!this.is24HourMode) {
                    hourItem.value = timeValue.hour % 12 || 12;
                    
                    this.set('meridiem', (timeValue.hour < 12));
                } else {
                    hourItem.value = timeValue.hour;
                }
                minItem.value = timeValue.min;
            }

            
            this.hourProvider = new mstrmojo.NumStepperContentProvider({
                item: hourItem,
                valField: 'value',
                canLoop: true,
                onTraverse: function () {
                    me.updateTime();
                }
            });

            
            this.minProvider = new mstrmojo.NumStepperContentProvider({
                item: minItem,
                valField: 'value',
                canLoop: true,
                renderer: {
                    render: function (v) {
                        return String(v).length == 1 ? ('0' + v) : v;
                    }
                },
                onTraverse: function () {
                    me.updateTime();
                }
            });
        }
    }

    
    mstrmojo.DateTimePicker = mstrmojo.declare(
        
        mstrmojo.Container,

        
        null,

        {

            scriptClass: "mstrmojo.DateTimePicker",

            
            value: null,

            
            min: null,

            
            max: null,

            
            meridiem: true,

            
            hideSwitchers: false,

            
            minuteInterval: null,

            
            is24HourMode: false,

            
            dtp: mstrmojo.expr.DTP.TIMESTAMP,

            
            viewCssClass: '',

            
            valueField: 'value',

            
            stepperClass: 'mstrmojo.Stepper',

            markupString: "<div id='{@id}' class='mstrmojo-DateTimePicker' style='{@cssText}'>" +
                              "<div class='switcher'></div>" +
                              "<div class='{@viewCssClass}'>" +
                                  "<span class='stepNode month'></span>" +
                                  "<span class='stepNode day'></span>" +
                                  "<span class='stepNode year'></span>" +
                                  "<span class='stepNode hour'></span>" +
                                  "<span class='stepNode min'></span>" +
                                  "<span class='meridiem' mstrAttach:click></div>" +
                              "</div>" +
                          "</div>",

            markupSlots: {
                switcherNode: function () { return this.domNode.firstChild; },
                viewNode: function () { return this.domNode.children[1]; },
                monthNode: function () { return this.domNode.children[1].children[0]; },
                dayNode: function () { return this.domNode.children[1].children[1]; },
                yearNode: function () { return this.domNode.children[1].children[2]; },
                hourNode: function () { return this.domNode.children[1].children[3]; },
                minNode: function () { return this.domNode.children[1].children[4]; },
                meridiemNode: function () { return this.domNode.children[1].children[5]; }
            },

            markupMethods: {
                onmeridiemChange: function () {
                    
                    if (this.is24HourMode) {
                        this.meridiemNode.display = 'none';
                    } else {
                        this.meridiemNode.innerHTML = this.meridiem ? mstrmojo.locales.datetime.AM_NAME : mstrmojo.locales.datetime.PM_NAME;
                    }
                },
                onviewCssClassChange: function () {
                    this.viewNode.className = this.viewCssClass;
                }
            },

            
            init: function init(props) {
                
                this._super(props);

                var dtp = this.dtp;

                this._hasDate = (dtp === DTP.DATE || dtp === DTP.TIMESTAMP);
                this._hasTime = (dtp === DTP.TIME || dtp === DTP.TIMESTAMP);

                
                createProviders.call(this);

                
                createChildren.call(this);
            },

            
            getDateTime: function getDateTime() {
                return {
                    date: this.getDate(),
                    time: this.getTime()
                };
            },

            
            getDate: function getDate() {
                if (this._hasDate) {
                    var dateInfo = this.dateProvider.curVal;

                    return {
                        year: dateInfo.getFullYear(),
                        month: dateInfo.getMonth() + 1,
                        day: dateInfo.getDate()
                    };
                }

                return null;
            },

            
            getTime: function getTime() {
                if (this._hasTime) {
                    return {
                        hour: !this.is24HourMode ? $D.capitalHour(this.hourProvider.curVal, this.meridiem ? ' AM' : ' PM') : this.hourProvider.curVal,
                        min: this.minProvider.curVal
                    };
                }
                return null;
            },

            
            getDateTimeString: function getDateTimeString() {
                var str = '';
                if (this._hasDate) {
                    str += $D.formatDateInfo(this.getDate(), mstrmojo.locales.datetime.DATEOUTPUTFORMAT);
                }
                if (this._hasDate && this._hasTime) {
                    str += ' ';
                }
                if (this._hasTime) {
                    str += $D.formatTimeInfo(this.getTime(), mstrmojo.locales.datetime.TIMEOUTPUTFORMAT);
                }
                return str;
            },

            
            updateDate: function updateDate() {
                if (this.hasRendered) {
                    
                    var me = this;
                    $A.forEach(['year', 'month', 'day'], function (n) {
                        me[n + 'Stepper'].updateDisplayText();
                    });
                }

                if (this.dateToggle) {
                    
                    this.dateToggle.set('text', $D.formatDateInfo(this.getDate(), mstrmojo.locales.datetime.DATEOUTPUTFORMAT));
                }
            },

            
            updateTime: function updateTime() {
                if (this.timeToggle) {
                    
                    this.timeToggle.set('text', $D.formatTimeInfo(this.getTime(), mstrmojo.locales.datetime.TIMEOUTPUTFORMAT));
                }
            },

            
            toDateView: function toDateView() {
                this.set('viewCssClass', 'dateView');
                this.dateToggle.set('selected', true);
                var timeToggle = this.timeToggle;
                if (timeToggle) {
                    timeToggle.set('selected', false);
                }
            },

            
            toTimeView: function toTimeView() {
                this.set('viewCssClass', 'timeView');
                var dateToggle = this.dateToggle;
                if (dateToggle) {
                    dateToggle.set('selected', false);
                }
                this.timeToggle.set('selected', true);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.array",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    mstrmojo.requiresDescs(221);

    var $CSS = mstrmojo.css,
        $BTN = mstrmojo.android.ui.Button.newButton;

    
    mstrmojo.android.DropDownList = mstrmojo.declare(

        mstrmojo.Widget,

        [ mstrmojo._TouchGestures ],

        
        {
            scriptClass: "mstrmojo.android.DropDownList",

            cssDisplay: 'block',

            markupString: '<div id="{@id}" class="mstrmojo-AndroidDropDownList {@cssClass}" mstrAttach:click><div>{@value}</div></div>',

            markupSlots: {
                valueNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? this.cssDisplay : 'none'; },
                onvalueChange: function () {
                    var value = this.value,
                        options = this.options;

                    
                    if (options) {
                        var idx = mstrmojo.array.find(options, 'v', value),
                            item = options[idx];

                        
                        this.valueNode.innerHTML = item.n;

                        
                        if (value !== "-1" && options[0].v === "-1") {
                            
                            options.shift();

                            
                            idx--;
                        }

                        
                        this.idx = idx;
                    }
                }
            },

            
            options: null,

            
            value: '',

            
            name: '',

            
            idx: 0,

            singleSelectByField: function singleSelectByField(value) {
                this.set('value', value);
            },

            
            touchTap: function touchTap() {
                
                var id = this.id,
                    domNode = this.domNode,
                    app = mstrApp;

                app.showDialog({
                    autoClose: true,
                    title: this.name,
                    fadeOnClose: false,
                    cssClass: 'dropDownList',
                    onClose: function () {
                        $CSS.removeClass(domNode, 'down');
                    },
                    children: [{
                        scriptClass: 'mstrmojo.ui.MobileCheckList',
                        items: this.options,
                        multiSelect: false,
                        isElastic: true,
                        selectedIndex: this.idx,
                        hasEvenRows: true,
                        postselectionChange: function (evt) {
                            
                            
                            mstrApp.closeDialog();

                            
                            mstrmojo.all[id].set('idx', evt.added[0]);
                        }
                    }],
                    buttons: [ $BTN(mstrmojo.desc(221, 'Cancel'), function () {
                        mstrApp.closeDialog();
                    }) ]
                });

                $CSS.addClass(domNode, 'down');
            },

            touchSelect: function touchSelect() {
                this.touchTap();
            },

            onidxChange: function onidxChange() {
                
                var options = this.options;
                if (options) {
                    
                    this.set('value', options[this.idx].v);
                }
            },

            preBuildRendering: function preBuildRendering() {
                this._super();

                
                var options = this.options;
                if (options) {
                    
                    this.value = options[this.idx].v;
                }
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Box",
                         "mstrmojo._HasLayout",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.ui.Image",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $LAYOUT = {
        containerNode: '100%'
    };

    
    mstrmojo.android.ui.ResultSetView = mstrmojo.declare(

        mstrmojo.Box,

        [ mstrmojo._HasLayout, mstrmojo._TouchGestures ],

        {
            scriptClass: "mstrmojo.android.ui.ResultSetView",

            layoutConfig: {
                h: $LAYOUT,
                w: $LAYOUT
            },

            init: function init(props) {
                this._super(props);

                
                mstrmojo.css.addWidgetCssClass(this, 'mstrmojo-ResultSetView');
            },

            rootOrientationChange: mstrmojo.emptyFn,

            addChildren: function addChildren(children, idx, silent) {
                
                if (!this.btnFullScreen) {
                    
                    children = children.concat([{
                        scriptClass: 'mstrmojo.android.ui.Image',
                        alias: 'btnFullScreen',
                        cssClass: 'btnFullScreen',
                        ignoreLayout: true,
                        visible: false,
                        touchTap: function () {
                            
                            this.parent.controller.viewTap();
                        }
                    }]);
                }

                this._super(children, idx, silent);
            },

            
            delegateToolbar: function delegateToolbar(tbCfg) {
                return false;
            },

            
            setActionToolbarStatus: mstrmojo.emptyFn,

            
            getMaskNode: mstrmojo.emptyFn,

            touchTap: function touchTap() {
                
                this.controller.viewTap();
            },

            enterFullScreen: function enterFullScreen() {
                this.btnFullScreen.set('visible', true);
            },

            exitFullScreen: function exitFullScreen() {
                this.btnFullScreen.set('visible', false);
            },

            flashFullScreen: mstrmojo.emptyFn,

            cancelFlashFullScreen: mstrmojo.emptyFn,

            getPosition: function getPosition() {
                var domNode = this.domNode;
                return domNode ? mstrmojo.dom.position(domNode) : undefined;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.MobileCalendar",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton");

    mstrmojo.android.inputControls.CalendarDIC = mstrmojo.declare(
        mstrmojo.MobileCalendar,

        [ mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: "mstrmojo.android.inputControls.CalendarDIC",

            
            onpopupResized: function onpopupResized(e) {
                var dn = this.domNode;
                if (dn) {
                    dn.style.zoom = parseInt((95 * e.width / dn.offsetWidth), 10) + '%';
                }
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls(
            "mstrmojo.GridBase",
            "mstrmojo.Grid");

    
    mstrmojo.XtabZone = mstrmojo.declare(
        
        mstrmojo.Grid,

        
        null,

        
        {
            
            scriptClass: "mstrmojo.XtabZone",

            
            markupString: '<div id="{@id}" class="mstrmojo-XtabZone" style="position:relative;{@cssText}"></div>',

            
            markupSlots: {
                gridContainerNode: function(){ return this.domNode; }
            }
        }   
    );

}());

(function(){

    
    mstrmojo.XtabCP = mstrmojo.declare(
        null,

        
        null,

        
        {
            
            scriptClass: "mstrmojo.XtabCP",

            
            base:null,

            
            lookupBase:null,

            
            colWidths:null,

            
            forceAutoRowHeight:false,

            
            startIndexInContainer:0,

            
            updatedRows: null,

            
            preServeUpdatedRows: true,

            
            init:function init( props) {
                mstrmojo.hash.copy(props, this);
            },

            
            initContent: function initContent( startIndexInContainer) {
                this.startIndexInContainer = startIndexInContainer || this.startIndexInContainer || 0;
                var s = this.base.show,
                items = this.base.items;
                this.rc =  s && items ? items.length : 0;
                this.colWidths = s && this.base.cws || [];
                this.isDownloading = false;
                this.isDownloaded = true;
                this.invalidData = false;
            },

            
            isDataAvailable:function isDataAvailable( startRow,  endRow) {
                return !this.invalidData;
            },

            
            download:function download( startRow,  endRow) {
                if(!this.isDownloaded && !this.isDownloading && this.dataSource) {
                    this.isDownloading = true;
                    this.dataSource.download(0);
                }
            },

            invalid:function invalid() {
                this.invalidData = true;
                this.isDownloading = false;
                this.isDownloaded = false;
                this.preServeUpdatedRows = true;
                if(this.gridData) {
                    this.oldGridData = this.gridData;
                    this.oldBase = this.base;
                    this.updatedRows = {};
                }
            },

            
            getRowHeight: function getRowHeight() {
                return this.gridData.rh;
            },
            
            
            getNumAutoHeightRows: function () {
                return this.forceAutoRowHeight ? this.rc : 0;
            },

            
            getAvailableRowsCount: function getAvailableRowsCount() {
                return this.rc;
            },

            getUpdatedRows: function getUpdatedRows() {
                return this.updatedRows;
            },

            
            getRowCells: function ( ri) {
                var bi = this.base.items,
                    r = bi[ri],             
                    cells = r.items,
                    lb = this.lookupBase,
                    ics = this.interactiveCellsArray,
                    cssBase = this.gridData.css,
                    e = null,
                    totalSet = false,
                    oldGd, oldBase, oldItems, oldCells;

                if(this.oldGridData) {
                    oldGd = this.oldGridData;
                    oldBase = this.oldBase;
                    oldItems = oldBase && oldBase.items;
                    oldCells = oldItems[ri] && oldItems[ri].items;
                }

                for (var ci=0, len=cells && cells.length || 0; ci<len; ci++) {
                    var cell = cells[ci];
                    if (cell) {
                        cell.v = cell.v || cell.n;
                        if (lb && !cell._e) {
                            var unit = lb[cell.tui];
                            e = unit && unit.es[cell.idx];
                            if (e) {
                                cell.v = cell.v || e.n; 
                                if(e.rv) {
                                    cell.rv = e.rv;
                                }
                                
                                cell._e = e;
                            }
                        }
                        if(!cell.css) {
                            cell.css = cssBase[cell.cni].n;
                        }

                        
                        if(!cell._d && oldCells && this.preServeUpdatedRows) {
                            var oldCell = oldCells[ci];
                            if(!oldCell || (oldCell.rs !== cell.rs)) {
                                this.preServeUpdatedRows = false;
                                this.updatedRows = {};
                            } else if((oldCell.v && cell.v !== oldCell.v)) {
                                data = {};
                                if(cell.v !== oldCell.v) {
                                    data.v = oldCell.v;
                                }
                                if(cell.css !== oldCell.css) {
                                    data.css = oldCell.css;
                                }
                                cell._d = data;
                                
                                this.updatedRows[this.startIndexInContainer + ri] = true;
                            }
                        }

                        
                        

                        
                        
                        cell._gd = this.gridData._bidx || 0;

                        
                        if(cell.at > 0 && ics) {
                            
                            if(cell._ei === undefined || ics[cell._ei] !== cell) {
                                cell._ei = ics.push(cell) - 1;
                            }

                        }
                        
                        if(this.axis) {
                            cell.axis = this.axis;
                        }

                        
                        var parentIndices = cell.pi;
                        if(parentIndices) {
                            
                            if(parentIndices.ri !== undefined && parentIndices.ci !== undefined) {
                                
                                cell._p = bi[parentIndices.ri].items[parentIndices.ci];
                            } else {
                                
                                var ghs = this.gridData.ghs,
                                        leftPi = parentIndices.left,
                                        topPi = parentIndices.top;

                                
                                if(leftPi) {
                                    cell._lp = ghs.rhs.items[leftPi.ri].items[leftPi.ci];
                                }

                             
                                if(topPi) {
                                    cell._tp = ghs.chs.items[topPi.ri].items[topPi.ci];
                                }
                            }
                        }

                    }
                }

                return cells;
            },

            
            getUnmergedCells: function getUnmergedCells(ri) {
                var ac = [],
                    rows = this.base.items,
                    cssBase = this.gridData.css,
                    cell = rows[ri].items[0], 
                    pi = cell && cell.pi, 
                    r = pi && pi.ri, 
                    c = pi && pi.ci; 

                while(pi && r > -1 && c > -1) {
                    
                    cell = cell._p || rows[r].items[c];
                    var _c = {};
                    
                    mstrmojo.hash.copy(cell, _c);
                    if(!_c.css) {
                        _c.css = cssBase[_c.cni].n;
                    }
                    
                    _c.rs = cell.rs - ri + r; 
                    
                    ac.splice(0, 0, _c);
                    
                    pi = cell && cell.pi;
                    r = pi && pi.ri;
                    c = pi && pi.ci;
                }

                return ac;
            }
        }
    );
})();

(function(){
    
    mstrmojo.XtabVACP = mstrmojo.declare(
        
        mstrmojo.XtabCP,

        
        null,

        
        {
            scriptClass: "mstrmojo.XtabVACP",

            
            cps:[],

            initContent: function initContent( startIndexInContainer) {
                this.startIndexInContainer = startIndexInContainer || 0;
                this.rc = 0;
                this.type = 0;
                this.colWidths = [];
                for(var i=0;i<this.cps.length;++i) {
                    var cp = this.cps[i];
                    
                    cp.initContent(this.startIndexInContainer + this.rc);
                    this.rc += cp.rc;
                    this.type |= cp.type;
                    var cws = cp.colWidths;
                    
                    if(cws && (cws.length > this.colWidths.length)) {
                        this.colWidths = cws;
                    }
                }
            },

            getNumAutoHeightRows: function () {
                
                
                
                return this.cps[0].getNumAutoHeightRows();
            },

            
            getRowHeight: function getRowHeight() {
                return this.cps[0].getRowHeight();
            },            
            
            
            getRowCells: function ( ri) {
                var i = 0,
                cp = this.cps[i];

                
                while(ri >= cp.rc) {
                    
                    ri -= cp.rc;
                    cp = this.cps[++i];
                }
                return cp.getRowCells(ri);
            },

            
            
            getUnmergedCells: function(ri) {
                var i = 0,
                cp = this.cps[i];

                while(ri >= cp.rc) {
                    ri -= cp.rc;
                    cp = this.cps[++i];
                }

                return cp.getUnmergedCells(ri);
            },

            isDataAvailable:function isDataAvailable( startIndex,  endIndex) {
                var targetCPs = this._getCPs(startIndex, endIndex);

                for(var i=0;i<targetCPs.length;++i) {
                    if(!targetCPs[i].isDataAvailable(startIndex, endIndex)) {
                        return false;
                    }
                }

                return true;
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                var rowDownloaded = 0;

                for(var i=0;i<this.cps.length;++i) {
                    var cp = this.cps[i];
                    if(cp.isDataAvailable()) {
                        rowDownloaded += cp.getAvailableRowsCount();
                    }
                }

                return rowDownloaded;
            },

            _getCPs: function getCPs( startIndex,  endIndex) {
                var i = 0,
                cp = this.cps[i],
                si = cp && cp.startIndexInContainer,
                targetCPs = [];

                
                if(cp) {
                    startIndex -= si;
                    endIndex -= si;
                }

                
                while(cp && startIndex >= cp.rc) {
                    
                    startIndex -= cp.rc;
                    endIndex -= cp.rc;

                    
                    cp = this.cps[++i];
                }

                
                while(cp && endIndex >= cp.rc) {
                    endIndex -= cp.rc;
                    targetCPs.push(cp);
                    
                    cp = this.cps[++i];
                }

                
                if(cp) {
                    targetCPs.push(cp);
                }

                return targetCPs;
            },

            invalid: function invalid() {
                for(var i=0;i<this.cps.length;++i) {
                    var tcp = this.cps[i];
                    tcp.invalid();
                }
                this.updatedRows = {};
            },

            getUpdatedRows: function getUpdatedRows() {
                var v = {};
                for(var i=0;i<this.cps.length;++i) {
                    var tcp = this.cps[i];
                    if(!tcp.preServeUpdatedRows) {
                        return {};
                    } else {
                        mstrmojo.hash.copy(tcp.getUpdatedRows(), v);
                    }
                }
                this.updatedRows = v;
                return v;
            },

            download: function download( startIndex,  endIndex) {
                var targetCPs = this._getCPs(startIndex, endIndex);

                for(var i=0;i<targetCPs.length;++i) {
                    var tcp = targetCPs[i];
                    tcp.download(startIndex, endIndex);
                }
            }
        }
    );
})();

(function(){
    
    mstrmojo.XtabHACP = mstrmojo.declare(
        
        mstrmojo.XtabCP,

        
        null,

        
        {
            scriptClass: "mstrmojo.XtabHACP",

            
            cps:[],

            initContent: function initContent( startIndexInContainer) {
                this.startIndexInContainer = startIndexInContainer || 0;
                this.type = 0;
                this.colWidths = [];

                for(var i=0;i<this.cps.length;++i) {
                    this.cps[i].initContent(this.startIndexInContainer);
                    this.type |= this.cps[i].type;

                    var cw = this.cps[i].colWidths;

                    
                    
                    if(cw) {
                        this.colWidths = this.colWidths.concat(cw);
                    }
                }

                this.rc = Math.max(this.cps[0].rc, this.cps[1].rc);

                
                
            },

            getNumAutoHeightRows: function () {
                return Math.max(this.cps[0].getNumAutoHeightRows(), this.cps[1].getNumAutoHeightRows());
            },

            getRowCells: function ( ri) {
                var cps = this.cps,
                    cells = [];
                for (var i=0,len=cps.length; i<len; i++) {
                    
                    
                    if (cps[i].getAvailableRowsCount() > 0 && cps[i].rc > ri) {
                        var tmp = cps[i].getRowCells(ri);
                        if (tmp) {
                            cells = cells.concat(tmp);
                        }
                    }
                }
                return cells;
            },

            
            getRowHeight: function getRowHeight() {
                return this.cps[0].getRowHeight();
            },            
            
            getUnmergedCells: function(ri) {
                return this.cps[0].getUnmergedCells(ri);
            },

            isDataAvailable:function isDataAvailable( startIndex,  endIndex) {
                
                return this.cps[1].isDataAvailable(startIndex, endIndex);
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                return Math.max(this.cps[0].getAvailableRowsCount(), this.cps[1].getAvailableRowsCount());
            },

            invalid: function invalid() {
                var i, len, cp;
                for(i=0,len=this.cps.length; i<len; ++i) {
                    cp = this.cps[i];
                    cp.invalid();
                }
                this.updatedRows = {};
            },

            getUpdatedRows: function getUpdatedRows() {
                var v = {};
                for(var i=0;i<this.cps.length;++i) {
                    var tcp = this.cps[i];
                    if(!tcp.preServeUpdatedRows) {
                        return {};
                    } else {
                        mstrmojo.hash.copy(tcp.getUpdatedRows(), v);
                    }
                }
                this.updatedRows = v;
                return v;
            },

            download: function download( startIndex,  endIndex) {
                var cp = this.cps[1];
                cp.download(startIndex, endIndex);
            }
        }
    );
})();

(function(){

    
    mstrmojo.XtabTitlesCP = mstrmojo.declare(
        
        mstrmojo.XtabCP,

        
        null,

        
        {
            scriptClass: "mstrmojo.XtabTitlesCP",

            init:function init( props) {
                this._super(props);
            },

            download:function download( startRow,  endRow) {
            },

            initContent: function initContent( startIndexInContainer) {
                this.startIndexInContainer = 0;
                
                
                if (!this.cts) {
                    this.cts = mstrmojo.hash.clone(this.gridData.gts.col);
                }
                
                
                var gts = this.gridData.gts,
                    isLockHeaders = (this.gridData.lhv !== 0),
                    rts = gts.row || [],
                    dataCts = gts.col || [],
                    s = gts.show,
                    rec = gts.rec,                  
                    cts = this.cts || [],
                    nRts = rts.length,              
                    nCts = cts.length,              
                    cssBase = this.gridData.css;    

                this.base = {
                    items:[]
                };

                
                this.rc = s && cts.length || 0;

                if (this.rc === 0 && s) {
                    
                    this.rc = nRts > 0 ? 1 : 0;
                }

                this.colWidths = s && gts.cws || [];

                
                if(!this.rc) {
                    return;
                }

                
                var cells = {items:[]},
                    lrs = 1,
                    lastCell,               
                    i;

                
                for(i = 0; i < nRts; ++i) {
                    rts[i].axis = 1;                    
                    rts[i].ui = i;
                    cells.items.push(rts[i]);
                }

                
                if (nCts > 0) {
                    cts[0].axis = 2;                    
                    cts[0].ui = 0;
                    dataCts[0].axis = 2;               
                    dataCts[0].ui = 0;
                    
                    lrs = cts[0].rs || 1;

                    
                    if (isLockHeaders && lrs > 1) {
                        
                        cts[0].rs = 1;
                        
                        
                        lastCell = mstrmojo.hash.clone(cts[0], {});

                        
                        lastCell.n = '&nbsp;';
                        
                        
                        cts[0].cni = cssBase.push({
                            n: (cssBase[cts[0].cni].n || '') + ' fsbp_1'
                        }) - 1;
                    }

                    cells.items.push(cts[0]);
                }

                var bi = this.base.items;
                bi.push(cells);

                
                for(i = 1; i < nCts; ++i) {
                    
                    if (lrs > 1) {
                       
                       var cnt = lrs;

                       
                        while(cnt-- > 1) {
                            
                            if (isLockHeaders) {
                                
                                var clone = mstrmojo.hash.clone(lastCell, {});

                                
                                clone.cni = cssBase.push({
                                    n: (cssBase[clone.cni].n || '') + ' fsbp_' + ((cnt == 1) ? '3' :  '2')
                                }) - 1;
                                
                                
                                bi.push({
                                    items: [ clone ]
                                });
                            } else {
                                
                                bi.push({items:[]});
                            }
                        }
                    }
                    
                    cts[i].axis = 2;
                    cts[i].ui = i;
                    dataCts[i].axis = 2;             
                    dataCts[i].ui = i;
                    
                    lrs = cts[i].rs || 1;

                    
                    if (isLockHeaders && lrs > 1) {
                        
                        cts[i].rs = 1;
                        lastCell = mstrmojo.hash.clone(cts[i], {});
                        lastCell.n = '&nbsp;';
                        
                        
                        cts[i].cni = cssBase.push({
                            n: (cssBase[cts[i].cni].n || '') + ' fsbp_1'
                        }) - 1;
                    }

                    bi.push({items:[cts[i]]});
                }

                this.rc = bi.length;

                
                if(rec) {
                    this._removeExtraColumn(rts, cts);
                }
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                return this.rc;
            },

            isDataAvailable:function isDataAvailable( startRow,  endRow) {
                return true;
            },

            
            _removeExtraColumn: function removeExtraColumn(rts, cts) {
                var nRts = rts && rts.length,
                         nCts = cts && cts.length,
                         gts = this.gridData.gts,
                         mRts = gts.row || [],
                         mCts = gts.col || [],
                         mnRts = mRts.length,
                         mnCts = mCts.length;

                
                if(!nRts || !nCts) {
                    
                    if(nCts === 1) {
                        

                        
                        var lct = cts[nCts-1];

                        if(lct.otp == -1) {
                            
                            
                            if(mnCts > 0) {
                                mCts[mnCts-1]._hid = true;
                            }

                            
                            this.base.items=[];
                            this.rc = 0;
                        }
                    }
                    return;
                }

                var lrt = rts[nRts-1], 
                    rc = this.rc, 
                    bi = this.base.items; 

                
                
                if(lrt) {
                    
                    if(lrt.otp == -1) {
                        
                        if(mnRts > 0) {
                            mRts[mnRts-1]._hid = true;
                        }
                        bi[0].items.splice(nRts-1, 1);
                    } else {
                        

                        
                        
                        var idx = rc > 1 ? rc -1 : 0,
                                r = bi[idx],
                                len = r.items.length;

                        
                        if(len > 0 && mnCts > 0) {
                            mCts[mnCts-1]._hid = true;
                        }

                        
                        var afi = lrt.fix;
                        
                        if(afi) {
                            
                            for(var i = 0; i < afi; i++) {
                                r.items[len - 1 + i] = rts[nRts - afi + i];
                            }
                        } else {
                            
                            r.items[len-1] = lrt;
                        }

                        
                        
                        
                        for(var j = 0, iLen = nCts -1; j < iLen; j++) {
                            cts[j].cs = afi ? afi : lrt.cs;
                        }

                        
                        
                        var rm = afi ? afi : 1;
                        bi[0].items.splice(nRts- rm, rm);
                    }
                }
                return;
            }
        }
    );
})();

(function(){
        mstrmojo.XtabOnDemandCP = mstrmojo.declare(
            
            mstrmojo.XtabCP,

        
        null,

        
        {
            scriptClass: "mstrmojo.XtabOnDemandCP",

            
            blockNum:0,

            listeners: null,

            initContent: function initContent( startIndexInContainer) {
                if(startIndexInContainer !== undefined) {
                    this.startIndexInContainer = startIndexInContainer;
                }
                this.isDownloaded = (this.base !== null);
                this.isDownloading = false;

                if(this.base) {
                    this._super(this.startIndexInContainer);
                    this.notifyListeners();
                }
            },

            addCPListener: function addCPListener(cp) {
                if(!this.listeners) {
                    this.listeners = [];
                }

                this.listeners.push(cp);
            },

            notifyListeners: function notifyListeners() {
                var i, cps = this.listeners,
                    count = (cps && cps.length) || 0;

                for(i = 0; i < count; i++) {
                    if(cps[i] && cps[i].onDemandDataReady) {
                        cps[i].onDemandDataReady(this);
                    }
                }
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                return this.isDownloaded ? this.rc : 0;
            },

            download:function() {
                if(!this.isDownloaded && !this.isDownloading) {
                    this.isDownloading = true;
                    this.dataSource.download(this.blockNum);
                }
            },

            invalid: function() {
                if(this._super) {
                    this._super();
                }
                this.isDownloaded = false;
                this.isDownloading = false;
            },

            isDataAvailable:function isDataAvailable( startRow,  endRow) {
                return this.isDownloaded;
            }
        }
    );
})();


(function(){

    
    var TITLE = 1,
        COL_HEADERS = 2,
        ROW_HEADERS = 4,
        VALUES = 8,        
        STACK_TOP = 1,
        STACK_MIDDLE = 2,
        STACK_BOTTOM = 3,
        NO_STACK = 4,
        FULL_STACK = 5,
        GROUPING_SECTION = 6,
        TITLE_ROW = 7,
        RHMAP = {},
        DPICONVERSION = {
            120: 0.75,
            240: 1,
            320: 1.5
        },
        RHConstants = {
            1: 30, 
            2: 26, 
            3: 20, 
            4: 70, 
            5: 40, 
            6: 34, 
            7: 40 
        },        
        BASEFORM_PICTURE = 4,
        SUBTOTAL = 1,
        CSS = {
            TITLE: 'ig-title',
            GROUPING: 'iggroup',
            BANDING: 'igbanding',
            RIGHT_ALIGN: 'rtAlign',
            LEFT_ALIGN: 'leftAlign',
            TOTAL_ROW: 'total'
        },
        $H = mstrmojo.hash,
        $A = mstrmojo.array;
    
    
    function hasGroupingEnabled(cps, gd) {
        var cp = cps[0],
            gts = gd.gts,
            gridTitleCount = gts.cws.length;

        return (gd.vp.gr === '1' && (gridTitleCount > 1));

    }

    
    function updateCellCSS(cell, info) {
        var applyCSS = function(cell, css) {
            if (css && cell && cell.css && cell.css.indexOf(css) < 0) {
                cell.css += ' ' + css;
            }
        };

        
        var type = info.type,
            col = info.col,
            colCount = (col && col.cl) || 0,
            isTitle = (type === COL_HEADERS || type === TITLE);

        
        if (type === COL_HEADERS || type === VALUES) {
            applyCSS(cell, CSS.RIGHT_ALIGN);
        } else if (type === TITLE || type === ROW_HEADERS) {
            applyCSS(cell, CSS.LEFT_ALIGN);
        }
        
        
        if (isTitle) {
            
            
            if (col && col.tg && colCount > 1) {
                
                
                if (!cell._v) {
                    
                    
                    cell._v = cell.v;
                    
                    
                    cell.v = "<span class='toggleHeader'>" + cell.v + "</span>";
                }
            }
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            applyCSS(cell, CSS.TITLE);
        }
        
        
        $A.forEach(info.extraCss, function(css) {
            applyCSS(cell, css);
        });
    }

    function findAttributeCPIndex(cg) {
        return 0;
    }

    
    function getStackLevel(cols) {
        var i, cg = cols.cg, len = cg && cg.cgc, v = 1;
        for(i = 0; i < len; i++) {
            
            if(cg && cg[i] && !cg[i].tg && cg[i].cl > v) {
                v = cg[i].cl;
            }
        }
        return v;
    }
    
    function getStackPos(index, stackLevel) {
        
        var pos = NO_STACK;
        if(stackLevel > 1) {
            if(index === 0) {
                pos = STACK_TOP;
            } else if (index === stackLevel - 1) {
                pos = STACK_BOTTOM;
            } else {
                pos = STACK_MIDDLE;
            }
        }
        return pos;
    }
    
    
    function getColumnIndex(colStacks, ciis, index, vp) {
    	var cg = vp && vp.cols && vp.cols.cg,
    		i,
    		totalIndex = 0,
    		sum = 0;
    	if (cg) {
    		for (i=0; i<ciis; i++) {
    			if (colStacks[i]) {
    				totalIndex += colStacks[i].length;
    			}
    		}
    		totalIndex += (index+1);
    		for (i=0; i<cg.cgc; i++) {
    			sum += cg[i].cl;
    			if (sum >= totalIndex) {
    				return i;
    			}
    		}
    	}
    	return -1;
    }

    
    function getStackedRow(colStacks, index, stackLevel, vp) {
        var a = [], c, i, len, size;

        for(i = 0, len = colStacks.length; i < len; i++) {
            
            
            if(colStacks[i].length === 1) {
                
                c = colStacks[i][0];
                
                c.rowType = (c.rowType !== TITLE_ROW) ? getStackPos(index, stackLevel) : TITLE_ROW;

                
                c.singleStack = (stackLevel > 1);
                
                
                c = $H.copy(c);
                
                
                if(c.ts === BASEFORM_PICTURE) {
                    
                    if(stackLevel === 1) {
                        c.rowType = NO_STACK;
                        
                        c.colIdx = getColumnIndex(colStacks, i, index, vp);
                    } else if(!index) {
                        
                    	
                        
                    	c.colIdx = getColumnIndex(colStacks, i, index, vp);
                    } else {
                        
                        delete c.ts;
                        c.v = '';
                    }
                
                } else if(index) {
                    c.v = '';
                }
            } else {
                
                c = colStacks[i][index];
                if(!c) {
                    
                    
                    size = colStacks[i].length;
                    c = $H.copy(colStacks[i][size-1], {});
                    c.v = '';
                    if (c.hasOwnProperty('ts')) {
                    	delete c.ts;
                    }
                } else if (c.ts ===BASEFORM_PICTURE) {
                	c.colIdx = getColumnIndex(colStacks, i, index, vp);
                }
                
                c.rowType = (c.rowType !== TITLE_ROW) ? getStackPos(index, stackLevel) : TITLE_ROW;
            }
            a.push(c);
        }
        return a;
    }

    
    function getOriginRowIndex(ri) {
        if(ri === 0) {
            return 0;
        }
        
        var sc = this.sectionMap[ri - 1] || 0;
        
        
        return Math.floor((ri - sc)/this.stackLevels);
    }


    
    function getSectionInfo(offset) {
        var i, s, si = this.sectionInfo,
            len = si.length,
            rh = this.srh,
            ls = this.lastSectionIndex;

        
        s = si[ls];
        if(offset >= s.rs && offset < (s.rs + rh)) {
            return s;
        }
        
        if(offset < s.rs) {
            
            i = ls-1;
            if(i <= 0) {
                this.lastSectionIndex = 0;
                return null;
            }

            do {
                s = si[i];
                if(offset > s.rs && offset <= (s.rs + rh)) {
                    this.lastSectionIndex = i;
                    return s;
                }
            } while(offset < s.rs && --i > 0);

            this.lastSectionIndex = i;
            return s;
        
        } else {
            i = ls+1; 
            if(i >= len) {
                this.lastSectionIndex = len - 1;
                return null;
            }

            do {
                s = si[i];
                if(offset > s.rs && offset <= (s.rs + rh)) {
                    this.lastSectionIndex = i;
                    return s;
                }
            } while(offset > (s.rs + rh) && ++i < len);

            this.lastSectionIndex = i-1;
            return null;
        }
    }
    
    
    function addExtraColumnCell(cells, tgcc, ei, rh) {
        var c = cells[0],
            i, len = cells.length,
            rt = c && c.rowType,
            nc = {v: '', css: 'empty-igcell', rowType: rt};

        if(ei !== undefined && c && (rt === STACK_TOP || rt === NO_STACK || rt === FULL_STACK)) {
            nc = {
                v: '<div><div class="IG-ActionArrow-IMG" style="height:' + rh + 'px;top:-' + (0.5*RHMAP[rt]) + 'px;"></div></div>', 
                css: 'IG-ActionArrow',
                _ei: ei
            };
        }
        
        
        for(i = len - 1; i >= len - tgcc; i--) {
            c = cells && cells[i];
            if(c) {
                c.css += ' IG-lastdatacolumn';
            }
        }
        cells.push(nc);
    }
    
        
    function calculateCWS(vp, width, isTdWidths) {
        var cols = vp.cols,
            cg = cols.cg,
            extraColumn = [{w: '0px'}];

        
        if (cols && width) {
            var cws = cols.cws,
                cwsInPx = [],
                len = cws.length,
                excludeWidth = 0,
                autoColWidth = (parseInt(vp.ar, 10) === 1) ? (width / len) : -1,
                w, cw, unsignedcol = false, excludeCol = 0,
                adjustedWidth = width,
                totalW = 0,
                i;
    
            
            for (i = 0; i < len; i++) {
                cw = cwsInPx[i] = cws[i];
                w = cw.w;
                if(w === "") {
                    unsignedcol = true;
                } else if(cw.xc) {
                    excludeWidth += parseInt(w);
                    adjustedWidth -= excludeWidth;
                    excludeCol++;
                } else {
                    totalW += parseFloat(w, 10);
                }
            }
            
            if(unsignedcol || totalW < 100) {
                autoColWidth = adjustedWidth/(len-excludeCol);
            }

            for (i = 0; i < len; i++) {
                cw = cws[i];
                if(cw.xc) {
                    
                    continue;
                
                } else if (autoColWidth === -1) {
                    
                    w = parseInt(cw.w, 10) * adjustedWidth / 100;
    
                    
                    if (!w && w !== 0) {
                        w = parseInt(adjustedWidth / cg.cgc, 10);
                    }
                } else {
                    
                    w = (parseInt(cw.w, 10) < 0) ? 0 : autoColWidth;
                }
    
                
                cwsInPx[i] = {w: w + 'px'};
            }
            
            if (isTdWidths) {
            	
            	return cwsInPx;
            }
            
            var newCWS = [],
                cnt = 0;
            
            
            for (i = 0; i < len; i ++) {
                var c = cg[i],
                    
                    count = c.tg ? c.cl : 1, 
                    j = 0;
                
                
                for (j = 0; j < count; j++) {
                    var wi = '0px';
                    
                    if (j === c.cc) {
                        wi = cwsInPx[i].w;
                    }
                    
                    newCWS[cnt+j] = {w: wi};
                }
                
                
                cnt += count;
            }
            return newCWS.concat(extraColumn);
        } else {
        	if (isTdWidths) {
        		
        		return null;
        	} else {
        		return cp.cws.concat(extraColumn);
        	}            
        }
    }
    
    function clearStackCols () {
        delete this.lastStackCols;
        delete this.lastAttRow;
        delete this.lastMtxRow;
    }
    
    
    mstrmojo.InteractiveGridHACP = mstrmojo.declare(
        
        mstrmojo.XtabHACP,

        
        null,

        
        {
            scriptClass: "mstrmojo.InteractiveGridHACP",

            
            sectionMap: [],

            
            stackLevels: 1,

            gridWidth: 480,
            
            tdWidths: null,
            
            lastSectionIndex: 0,

            adjustCPMaps: function adjustCPMaps() {
                var cps = this.cps,
                    attCP = this.cps[0],
                    rc = Math.max(cps[0].rc, cps[1].rc);

                
                if(attCP.type !== TITLE) {
                    var gd = this.gridData,
                        getParentElement = function(cp, n) {
                            var items = cp.base.items,
                                es = cp.lookupBase[0].es,
                                tgt = items[n].items[0],
                                cell = es && es [tgt.idx];
                            return (cell && cell.n) || ((tgt.pi && es[tgt.pi.ri || 0]) || '');
                        },
                        i, j, sc = 1, count, lastSection, curP,
                        start = 0, end = -1,
                        m, cpc, lastRow = 0,
                        shouldGroupEls = this.groupEnabled;

                    for(m = 0, i = 0, cpc = attCP.cps ? attCP.cps.length : 1; m < cpc; m++) {
                        var cp = attCP.cps ? attCP.cps[m] : attCP,
                            cprc = cp.rc;
                        
                        start = end + 1;
                        end = start + cprc - 1;
                        
                        if(cp.isDataAvailable(start, end)) {
                            
                            if(cp.lastRow) {
                                lastRow = cp.lastRow;
                                lastSection = cp.lastSection;
                            } else {
                                i = lastRow || 0;
                                for(j = 0, sc = this.sectionMap[i-1] || 0; j < cprc; j++) {
                                    var stackLevel = this.stackLevels;

                                    curP = getParentElement(cp, j);
                                    
                                    if(shouldGroupEls && curP !== lastSection) {
                                        lastSection = curP;
                                        this.sectionInfo.push({
                                            sn: curP, 
                                            rs: this.srh*sc + this.stackedRh*Math.floor((i-sc)/this.stackLevels) 
                                        });
                                        this.sectionMap[i] = ++sc;
                                        i++;
                                    }
                                    
                                    while(stackLevel) {
                                        this.sectionMap[i] = sc;
                                        stackLevel--;
                                        i++;
                                    }
                                }
                                
                                lastRow = cp.lastRow = i;
                                
                                cp.lastSection = curP;
                            }
                        } else {
                            
                            break;
                        }
                    }
                    
                    this.rc = (this.stackLevels > 1 ? rc * this.stackLevels : rc) + (shouldGroupEls ? sc : 0);
                }
            },

            onDemandDataReady: function onDemandDataReady() {
                this.adjustCPMaps();
            },

            initContent: function initContent( startIndexInContainer) {
                var cps = this.cps,
                    gd = this.gridData = cps[0].gridData || cps[0].cps[0].gridData,
                    vp = gd.vp = this.gridVp = this.gridVp || gd.vp, 
                    daf = vp.daf && vp.daf.split(":"),
                    cols = vp.cols,
                    cg = cols.cg,
                    cws = cols.cws,
                    attCP = cps[findAttributeCPIndex(cg)],
                    attLB = gd.gts.row,
                    gts = gd.gts,
                    grouping = hasGroupingEnabled(cps, gd),
                    notTitleCP = attCP.type !== TITLE,
                    i, len, _c, vcps, cf, cp, igcp,
                    dpi = mstrApp.isTablet() ? 240 : mstrMobileApp.getDeviceDPI();
                
                
                $H.forEach(RHConstants, function(h, rowType) {
                    RHMAP[rowType] = h * DPICONVERSION[dpi];
                });
                
                
                if(notTitleCP) {
                    if (vp.dafIdx === undefined && daf) {
                        
                        
                        for (i = 0; i < attLB.length; i++) {
                            
                            if (attLB[i].id === daf[0] && attLB[i].fid === daf[1]) {
                                
                                vp.dafIdx = i;
                                break;
                            }
                        }                        
                    }
                }
                
                
                for(i = 0; i < cg.cgc; i++) {
                    if(cg[i] && cg[i].tg) {
                        
                        break;
                    }
                }
                
                if(i === cg.cgc) {
                    gd.gts.show = false;
                    gd.ghs.chs.show = false;
                }
                

                this._super(startIndexInContainer);
                
                this.colWidths = calculateCWS(vp, this.gridWidth);
                
                this.tdWidths = calculateCWS(vp, this.gridWidth, true);
                
                
                if(notTitleCP) {
                    
                    this.stackLevels = getStackLevel(cols);

                    
                    if(this.stackLevels > 1) {
                        
                        this.srh = RHMAP[GROUPING_SECTION];
                        
                        this.rh = RHMAP[NO_STACK];
                        
                        this.mrh = RHMAP[STACK_BOTTOM];
                        
                        this.stackedRh = RHMAP[STACK_TOP] + (this.stackLevels - 2)*RHMAP[STACK_MIDDLE] + RHMAP[STACK_BOTTOM];
                    } else {
                        this.srh = RHMAP[GROUPING_SECTION];
                        this.rh = this.stackedRh = this.mrh = RHMAP[NO_STACK];
                    }
                    
                    
                    if(grouping || this.stackLevels > 1) {
                        
                        this.sectionMap = [];

                        
                        this.sectionInfo = [];

                        
                        this.groupEnabled = grouping;

                        
                        this.adjustCPMaps();
                        
                        
                        vcps = this.cps[0].cps;
                        if(vcps) {
                            igcp = this;
                            
                            for(i = 0, len = vcps.length; i < len; i++) {
                                cp = vcps[i];
                                
                                if(cp && cp.addCPListener) {
                                    cp.addCPListener(igcp);
                                }
                            }
                        }                                                
                    }
                }
            },

            getUnmergedCells: function(ri) {
                return;
            },

            
            getResolvedGroupHeader: function(r, c) {
                var gd = this.gridData,
                    es = gd.gts.row[c].es,
                    cell = gd.ghs.rhs.items[r].items[c];

                if(cell) {
                    if(!cell.css) {
                        cell.css = gd.css[cell.cni].n + ' iggroup';
                        cell.n = es[cell.idx].n;
                    }
                } else {
                    return { css: ' iggroup', n: ''};
                }

                return cell;
            },

            getRowCells: function ( ri) {
                var cps = this.cps,
                    cells = [],
                    gd = this.gridData,
                    vp = gd.vp,
                    cg = vp.cols.cg,
                    attCP = cps[findAttributeCPIndex(cg)],
                    enableGrouping = this.groupEnabled,
                    showBanding = vp.bn === "1",
                    stackCols = [],
                    oi = getOriginRowIndex.call(this, ri),
                    eiDfa, 
                    eiInteractiveRow,
                    lastToggledColumn = 1,
                    onTotalRow,
                    totalCell,
                    rowCells,
                    i, j, len, c, 
                    tc;

                
                if (enableGrouping && (this.sectionMap[ri] !== this.sectionMap[ri-1])) {
                        
                        
                        var cell = $H.copy(attCP.getRowCells(oi)[0], {});

                        
                        cell.cs = this.colWidths.length;

                        
                        cell.rowType = GROUPING_SECTION;

                        
                        updateCellCSS(cell, {
                            col: null,
                            type: attCP.type,
                            extraCss: [CSS.GROUPING]
                        });

                        return [cell];
                }

                
                if(!ri) {
                    clearStackCols.call(this);
                }
                
                
                this.lastAttRow = this.lastAttRow || (cps[0].rc ? cps[0].getRowCells(oi) : []);
                this.lastMtxRow = this.lastMtxRow || (cps[1].rc ? cps[1].getRowCells(oi) : []);

                
                rowCells = this.lastAttRow;
                len = rowCells.length;
                if (len > 0 && rowCells[0].stt) {
                    onTotalRow = true;
                    for(i = 0; i < len; i++) {
                        c = rowCells[i];
                        if(c.stt === SUBTOTAL) {
                            totalCell = c;
                            break;
                        }
                    }
                }
                
                if(!this.lastStackCols) {
                    
                    $A.forEach([this.lastAttRow, this.lastMtxRow], function(row){
                        for (i = 0; i < row.length; i++) {
                            if (row[i]._ei !== undefined) {
                                
                                if (vp.dafIdx >= 0) {
                                    tc = attCP.getRowCells(oi)[vp.dafIdx];
                                }

                                
                                eiDfa = (vp.dafIdx >= 0) ? (tc && tc._ei) : "";
                                
                                
                                return false;
                            }
                        }
                    }, this);

                    
                    var addInfo = function(cell, cp) {
                        if (cell && (cp.type === TITLE || cp.type === COL_HEADERS)) { 
                            if(colGroup.tg === false) {
                                cell.n = cell.v = "";
                            }
                            cell.rowType = TITLE_ROW;
                        }
                        
                        
                        
                        
                        updateCellCSS(cell, {
                            col: colGroup,
                            type: cp.type,
                            extraCss: [((cp.type === VALUES || cp.type === ROW_HEADERS) && showBanding && (oi % 2 === 1)) ? CSS.BANDING : null, onTotalRow ? CSS.TOTAL_ROW : null]
                        });
                        
                        if(cell) {
                            
                            cell.cs = 1;
                            
                            
                            if (cell._ei===undefined && vp.dafIdx !== undefined) {
                                cell._ei = eiDfa;
                            }
                        }

                    };

                    this.lastRowIndex = 0;
                    for (j = 0; j < cg.cgc; j++) {
                        var colGroup = cg[j],
                            mCol = colGroup['mix' + colGroup.cc],
                            isMetric = mCol !== undefined,
                            cp = cps[isMetric ? 1 : 0],
                            k, p, ci, 
                            trc = {n:'', stt: SUBTOTAL, css: 'xtab-td'};
                            arr = [];

                        
                        if(colGroup.tg) {
                            
                            for (var i = 0; i < colGroup.cl; i ++) {
                                arr = [];
                                
                                
                                ci = isMetric ? colGroup['mix' + i] : colGroup.attForms[i].idx;
                                
                                
                                var rowCells = isMetric ? this.lastMtxRow : this.lastAttRow;
                                
                                
                                c = rowCells[ci];
                                
                                
                                if(onTotalRow) {
                                    if(!c) {
                                        c = trc;
                                    } else if(c && c.stt === SUBTOTAL) {
                                        
                                        
                                        c =$H.copy(totalCell, trc);
                                    } else {
                                        c = $H.copy(c, {});
                                    }
                                } else {
                                    c = $H.copy(c, {});
                                }
    
                                
                                addInfo(c, cp);
    
                                arr.push(c);
                                
                                stackCols.push(arr);
                            }
                            
                            
                            if(j+1 === cg.cgc) {
                                lastToggledColumn = colGroup.cl;
                            }

                        
                        } else {
                            for(k = 0, len =colGroup.cl; k < len; k++) {
                                
                                if(isMetric) {
                                    p = colGroup['mix' + k];
                                    if(p!== undefined) {
                                        c = this.lastMtxRow[p];
                                    }
                                
                                } else {                                                                        
                                    p = colGroup.attForms[k];
                                    if(p) {
                                        c = this.lastAttRow[p.idx];
                                    }
                                    
                                    
                                    if (onTotalRow && !c){
                                        c = trc;
                                    }

                                }

                                
                                addInfo(c, cp);

                                arr.push(c);
                            }
                            
                            stackCols.push(arr);
                        }
                    }
                    this.lastStackCols = stackCols;
                }

                cells = getStackedRow(this.lastStackCols, this.lastRowIndex++, this.stackLevels, vp);

                if(this.lastRowIndex >= this.stackLevels) {
                    clearStackCols.call(this);
                }









                
                








                
                
                return cells;
            },

            
            getRowHeight: function getRowHeight(type) {
                var rh = RHMAP[NO_STACK];
                return RHMAP[type] || rh;
            },

            isDataAvailable:function isDataAvailable( startRow,  endRow) {
                if(!this.onDemandIF || !this.cps[1].cps) {
                    return true;
                } else {
                    var maxRow = this.sectionMap.length, s;
                    
                    if(!maxRow) {
                        return this.cps[1].isDataAvailable(startRow, endRow);
                    }
                    
                    if(endRow > maxRow) {
                        if(startRow < maxRow) {
                            s = getOriginRowIndex.call(this, startRow);
                            return this.cps[1].isDataAvailable(s, s + (endRow-startRow));
                        } else {
                            return false;
                        }
                    } else {
                        return this.cps[1].isDataAvailable(getOriginRowIndex.call(this, startRow), getOriginRowIndex.call(this, endRow));
                    }
                }
            },

            download: function download( startIndex,  endIndex) {
                var si = getOriginRowIndex.call(this, startIndex),
                    ei = si + Math.ceil((endIndex - startIndex)/this.stackLevels),
                    cp = this.cps[0], i, tcp,
                    targetCPs = !cp.cps? [cp] : this.cps[0]._getCPs(si, ei);

                for(i=0;i<targetCPs.length;++i) {
                    tcp = targetCPs[i];
                    tcp.download(si, ei);
                }
            },

            
            getRowCellInfo: function (offset) {
                
                
                var sectionInfo = getSectionInfo.call(this, offset + this.srh),
                    lastSection, i = this.lastSectionIndex;
                if(sectionInfo) {
                    lastSection = this.sectionInfo[i - 1]; 
                    return {
                        rowStart: sectionInfo.rs,
                        isNextRowNewSection: true,
                        sectionName: lastSection && lastSection.sn 
                    };
                } else {
                    return {
                        isNextRowNewSection: false,
                        sectionName: this.sectionInfo[i].sn
                    };
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.ViewSwitcher",
                         "mstrmojo.dom",
                         "mstrmojo.array");

    var $MATH = Math,
        $DOM = mstrmojo.dom,
        $ARR = mstrmojo.array;

    
    function translate(el, x, duration, easing) {
        
        if (isNaN(x)) {
            
            x = parseInt(x, 10);
        }

        
        var elementStyle = el.style;
        elementStyle[$DOM.CSS3_TRANSITION] = $DOM.CSS3_PREFIX + 'transform ' + (duration || 0) + 'ms ' + (easing || 'ease');
        elementStyle[$DOM.CSS3_TRANSFORM] = 'translateX(' + x + 'px)';
    }

    
    function insertScrollView(view, sliderX, isForward) {
        
        var slotInfo = this.getSlots(),
            currentSlot = slotInfo.current,
            nextSlot = slotInfo.next,
            nextSlotName = slotInfo.slot,
            targetPosition = 0;

        
        $ARR.forEach($ARR.filter(this.children, function (child) {
            return (child.slot === nextSlotName);
        }), function (child) {
            
            this.removeChildren(child);
            child.unrender();
        }, this);

        
        this.prepareNewView(view, nextSlotName);

        
        try {
            
            var id = this.id;
            window.setTimeout(function () {
                
                mstrmojo.all[id].addChildren([ view ]);
            }, 0);

            
            if (nextSlot && currentSlot) {
                
                targetPosition = isForward ? parseInt(this.width, 10) : 0;

                
                if (isForward) {
                    nextSlot.style.zIndex = 3;
                    currentSlot.style.zIndex = 1;
                }
            }

        } catch (e) {
            
            mstrmojo.Obj.free(view);
            throw e;
        }

        return {
            start: sliderX,
            target: targetPosition,
            newView: view,
            oldView: this.getCurrentView(),
            isForward: isForward
        };
    }


    function positionSliderNode(newPosition, oldPosition, callback, useAnimation, velocity) {
        var sliderNode = this.sliderNode,
            duration = 0,
            easing = '',
            fnPosition = function () {
                
                translate(sliderNode, -newPosition, duration, easing);

                
                if (callback) {
                    
                    if (duration) {
                        
                        window.setTimeout(callback, duration + 100);
                    } else {
                        
                        callback();
                    }
                }
            };

        
        if (useAnimation) {
            
            var delta = $MATH.abs((newPosition || 0) - (oldPosition || 0));

            
            duration = $MATH.round(delta / parseInt(this.width, 10) * 700);                     
            easing = 'ease';                                                                    

            
            if (velocity) {
                
                duration = $MATH.min(duration, $MATH.round(delta / velocity));

                
                easing += '-out';
            }

            
            this._animating = true;

            
            window.setTimeout(fnPosition, 20);

        } else {
            
            fnPosition();
        }
    }

    
    function cleanUpScroll(activeChild, inactiveChild) {
        
        this.removeChildren(inactiveChild);

        
        inactiveChild.unrender();

        
        this._curSlot = activeChild.slot;

        
        delete this._animating;
    }


    
    mstrmojo.android.ui.ViewSlider = mstrmojo.declare(

        mstrmojo.android.ui.ViewSwitcher,

        null,

        
        {
            scriptClass: "mstrmojo.android.ui.ViewSlider",

            
            switchView:  function switchView(view, isBackOperation) {
                var slotInfo = this.getSlots();

                
                translate(this.sliderNode, 0);
                translate(slotInfo.current, 0);
                translate(slotInfo.next, 0);

                this._super(view, isBackOperation);
            },

            
            isAnimating: function isAnimating() {
                return !!this._animating;
            },
                       
                        
            resetSliderNodes: function (isForward) {

                var slotInfo = this.getSlots(),
                    width = parseInt(this.width, 10),
                    sliderX = -width,                   
                    currentX = width,                   
                    nextX = 0;                          
                
                if (isForward) {
                    sliderX = 0;
                    currentX = 0;
                    nextX = width;
                }                

                
                translate(this.sliderNode, sliderX);
                translate(slotInfo.current, currentX);
                translate(slotInfo.next, nextX);
                
                return {
                	sliderX: sliderX,
                	currentX: currentX,
                	nextX: nextX
                };
            },            

            
            beginScroll: function (touch, view) {
                
                if (this.isAnimating()) {
                    
                    return false;
                }
                
                var isForward = touch.delta.x < 0,
                	positions = this.resetSliderNodes(isForward);                

                
                var info = this._scrollInfo = insertScrollView.call(this, view, positions.sliderX, isForward);

                
                this.scrollStarted(info);

                
                this.scroll(touch);
            },

            
            scroll: function scroll(touch) {
                var info = this._scrollInfo,
                    x = touch.delta.x;

                
                if (info) {
                    
                    if (info.isForward !== (x < 0)) {
                        
                        positionSliderNode.call(this, 0);

                        
                        this.beginScroll(touch);

                    } else {
                        
                        positionSliderNode.call(this, -(info.start + x));

                        
                        this.scrollProgress(info, x);

                    }
                }
            },

            
            endScroll: function endScroll(touch) {
                
                var info = this._scrollInfo;
                if (!info) {
                    
                    return;
                }

                var delta = touch.delta.x,                  
                    newPosition = -info.start,              
                    isComplete = false,                     
                    velocity = 0,                           
                    id = this.id;

                
                if ($MATH.abs(delta) / parseInt(this.width, 10) > 0.25) {
                    
                    newPosition = info.target;
                    isComplete = true;
                    velocity = touch.velocity.x;
                }

                
                this.scrollStopped(info, isComplete);

                
                positionSliderNode.call(this, newPosition, newPosition - delta, function () {
                    
                    mstrmojo.all[id]['scroll' + (isComplete ? 'Complete' : 'Canceled')](info);
                }, true, velocity);

                
                delete this._scrollInfo;
            },

            
            scrollStarted: mstrmojo.emptyFn,

            
            scrollProgress: mstrmojo.emptyFn,

            
            scrollStopped: mstrmojo.emptyFn,

            
            scrollCanceled: function scrollCanceled(info) {
                cleanUpScroll.call(this, info.oldView, info.newView);
            },

            
            scrollComplete: function scrollComplete(info) {
                cleanUpScroll.call(this, info.newView, info.oldView);
            }
        }
    );
}());
(function() {

    mstrmojo.requiresCls("mstrmojo.TextBox","mstrmojo._CanValidate");

    var _C = mstrmojo.css,
        _V = mstrmojo.validation,
        _TR = _V.TRIGGER,
        _SC = _V.STATUSCODE,
        _MK = mstrmojo.TextBox.prototype.markupMethods;
    
    
    mstrmojo.ValidationTextBox = mstrmojo.declare(
        
        mstrmojo.TextBox,
        
        
        [mstrmojo._CanValidate],
        
        
        {
            scriptClass: 'mstrmojo.ValidationTextBox',
            
            validationDelay: 500,
            
            markupMethods: {
                onvisibleChange: _MK.onvisibleChange,
                onvalueChange: _MK.onvalueChange,
                onenabledChange: _MK.onenabledChange,
                onreadOnlyChange: _MK.onreadOnlyChange,
                ontooltipChange: _MK.ontooltipChange,                
                onvalidationStatusChange: function(){
		            var vs = this.validationStatus;
		            if(!vs) {
		                return;
		            }
		            var it = this.inputNode,
		                isInvalid = (vs.code > _SC.VALID),
		                css = this.constraints.invalidCssClass;   
		                
		            _C.toggleClass(it, css ? css : ['mstrmojo-TextBox-ErrValidation'], isInvalid);
		            if(isInvalid){
		                it.setAttribute('title', vs.msg);
		            }else{
		                if (this._original_tooltip !== undefined && this._original_tooltip !== null) {
		                    it.setAttribute('title', this._original_tooltip);
		                }
		            }                   
		        }
            },

            
            postBuildRendering: function pstBR(){
                if(this._super) {
                    this._super();
                }
                
                
                this._original_tooltip = this.inputNode.title;  
            },
            
            
            prekeyup: function pku(evt) {
                if(this._super){
                    this._super(evt);   
                }
                var tri = (this.constraints.trigger & _TR.ONKEYUP) > 0;
                if(tri){
                    if (this.validationDelay > 0){
                        if(this._valDelayTimer){
                            window.clearTimeout(this._valDelayTimer);
                        }
                        
                        if(!this._validateHandler){
                            var me = this;
                            this._validateHandler = function(){
                                me.validate();      
                                if(me._valDelayTimer){
                                    window.clearTimeout(me._valDelayTimer);
                                    delete me._valDelayTimer;
                                }                        
                            };
                        }
                        
                        this._valDelayTimer = window.setTimeout(this._validateHandler, this.validationDelay);
                    }else{
                        this.validate();
                    }
                }
            },
            
            preinput: function(evt) {
                if(this._super){
                    this._super(evt);   
                }
                var tri = (this.constraints.trigger & _TR.ONKEYUP) > 0;
                if(tri){
                    this.validate();   
                }
            },
            
            
            preblur: function pb(evt) {
                if(this._super){
                    this._super(evt);   
                }
                var tri = (this.constraints.trigger & _TR.ONBLUR) > 0;
                if(tri){
                    this.validate();   
                }
            },

            
            clearValidation: function clearValidation(){
                if(this._super){
                    this._super();   
                }
                var it = this.inputNode,
                    css = this.constraints.invalidCssClass;
                _C.removeClass(it, css ? css : ['mstrmojo-TextBox-ErrValidation']);
                it.title = this._original_tooltip; 
            }            
        });
})();            
(function() {

    mstrmojo.requiresCls("mstrmojo.TextBox");

    
    mstrmojo.TextArea = mstrmojo.declare(
        
        mstrmojo.TextBox,
        
        
        null,
        
        
        {
            
            scriptClass: 'mstrmojo.TextArea',
                                                
            markupString: '<textarea id="{@id}" class="mstrmojo-TextArea {@cssClass}"  style="{@cssText}" '
                                + 'title="{@tooltip}" '
                                + 'placeholder="{@placeholderText}" '
                                + 'rows="{@rows}" cols="{@cols}" maxlength="{@maxLength}" index="{@tabIndex}"' +
                                ' mstrAttach:focus,keydown,keyup,blur ' +                              
                              '></textarea>',
                          
            
            maxLength: 256,
            
            markupSlots: {
                inputNode: function(){ return this.domNode; }
            },
            
            postCreate: function() {
                this.markupMethods = mstrmojo.hash.copy(this.markupMethods);
                this.markupMethods.oncssClassChange = function() { 
                    this.domNode.className = "mstrmojo-TextArea " + (this.cssClass||'');
                    };
            },
            
            onkeydown: function(e) {
                var strLen = (this.value && this.value.length) || 0;

                if (this.maxLength <= strLen) {
                    
                    this.isDeleteKeys = e.e.keyCode === 8 || e.e.keyCode === 46;
                    this.isArrowKeys = e.e.keyCode === 37 || e.e.keyCode === 38 || e.e.keyCode === 39 || e.e.keyCode === 40;
                    
                    
                    var hasSelection = (this.domNode.selectionEnd !== undefined) ? (this.domNode.selectionEnd - this.domNode.selectionStart) > 0 :
                                       document.selection.createRange().text.length > 0;

                    if (!this.isDeleteKeys && !this.isArrowKeys && !hasSelection) {

                        
                        if (mstrmojo.dom.isIE7 || mstrmojo.dom.isIE8) {
                            var dn = this.domNode;
                            dn.blur();

                            window.setTimeout(function(){dn.focus();}, 1);
                        }

                        mstrmojo.dom.preventDefault(window, e.e);
                        return false;
                    }
                 }
             }
        }
      );
        
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.TextBox",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.css",
                         "mstrmojo.dom");

    var SEARCH_DELAY = 500,
        $CSS = mstrmojo.css;

    
    var delayStrategy = {
        onkeyup: function (sv, sp) {
            
            var hndl = sv._searchTimer;
            if (hndl) {
                window.clearTimeout(hndl);
            }

            sv._searchTimer = window.setTimeout(function () {
                
                sv.searchFunc(sp);

                
                delete sv._searchTimer;
            }, SEARCH_DELAY);
        },

        onEnter: function (sv, sp) {
            sv.searchFunc(sp);
        }
    };

    
    mstrmojo.android.ui.SearchBox = mstrmojo.declare(
        mstrmojo.TextBox,

        [ mstrmojo._TouchGestures ],

        
        {
            
            searchResult: null,

            
            searchStrategy: delayStrategy,

            
            searchFunc: mstrmojo.emptyFn,

            
            clearFunc: mstrmojo.emptyFn,

            monitorInputs: true,

            
            clearSearch: function clearSearch() {
                this.clearFunc();
            },

            onkeyup: function onkeyup() {
                
                
            },

            onEnter: function onEnter() {
            	                                  
                this.searchStrategy.onEnter(this, this.searchValue || this.value);
                delete this.searchValue;
            },

            onvalueChange: function onvalueChange() {
                
                $CSS.toggleClass(this.domNode, 'clear', !!this.value.length);
            },

            touchTap: function (evt) {
                var domNode = this.domNode,
                    e = evt.evt;

                
                if (evt.pageX - mstrmojo.dom.position(e.target).x > (domNode.offsetWidth - parseInt($CSS.getStyleValue(domNode, 'paddingRight'), 10))) {
                    
                    this.set('value', '');

                    
                    this.clearSearch();
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo.Label",
                         "mstrmojo.TextBox",
                         "mstrmojo.css",
                         "mstrmojo.array");

    
    mstrmojo.android.ui.TextInput = mstrmojo.declare(

        mstrmojo.Container,

        null,

        
        {
            scriptClass: "mstrmojo.android.ui.TextInput",

            markupString: '<div id="{@id}" class="mstrmojo-AndroidTextInput {@cssClass}" style="{@cssText}">' +
                          '</div>',

            markupSlots: {
                containerNode: function () { return this.domNode; }
            },

            markupMethods: {
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod,
                onlabelTxtChange: function () {
                    var lbl = this.lbl,
                        text = this.labelTxt;

                    
                    lbl.set('visible', !!text);

                    
                    lbl.set('text', text || '');
                },
                ontextValueChange: function () { this.txt.set('value', this.textValue || ''); },
                ontextTypeChange: function () { this.txt.set('type', this.textType || 'text'); }
            },

            
            labelTxt: '',

            
            textValue: '',

            
            textType: 'text',

            init: function init(props) {
                this._super(props);

                
                this.parent.attachEventListener('widthChange', this.id, function (evt) {
                    
                    var width = parseInt(evt.value, 10),
                        textBoxDomNode = this.txt.domNode,
                        txtStyle = mstrmojo.css.getComputedStyle(textBoxDomNode);

                    
                    mstrmojo.array.forEach([ 'padding', 'margin' ], function (prop) {
                        width -= parseInt(txtStyle[prop + 'Left'], 10);
                        width -= parseInt(txtStyle[prop + 'Right'], 10);
                    });

                    
                    textBoxDomNode.style.width = width + 'px';
                });

                
                var cfg = this.getTextCfg();

                
                cfg.alias = 'txt';
                cfg.cssDisplay = 'block';

                
                this.addChildren([ cfg, {
                    scriptClass: 'mstrmojo.Label',
                    cssClass: 'lblErr',
                    alias: 'lblErr',
                    visible: false
                } ]);
            },

            
            getTextCfg: function getTextCfg() {
                return {
                    scriptClass: 'mstrmojo.TextBox',
                    onEnter: function () {
                        var parent = this.parent,
                            fnEnter = parent.onEnter;

                        
                        if (fnEnter) {
                            
                            fnEnter.call(parent, this.value);
                        }
                    }
                };
            },

            
            getValue: function getValue() {
                return this.txt.value;
            },

            children: [{
                scriptClass: 'mstrmojo.Label',
                alias: 'lbl'
            }],

            onRender: function () {
                this._super();

                
                this.txt.focus();
            }
        }
    );
}());
(function() {

    mstrmojo.requiresCls("mstrmojo.Widget", "mstrmojo.css", "mstrmojo.TextBox");
    
    
    mstrmojo.TextBoxWithLabel = mstrmojo.declare(
        
        mstrmojo.TextBox,
        
        
        null,
        
        
        {
            scriptClass: 'mstrmojo.TextBoxWithLabel',
                        
            
            label: '',
            
            
            rightLabel: '',
            
            cssDisplay: 'inline',
            
            type: "text",
                 
            markupString: '<div class="mstrmojo-TextBoxWithLabel {@cssClass}" style="{@cssText}">' +
                            '<span class="mstrmojo-TextBox-label">{@label}</span>' +
                            '<input id="{@id}" class="mstrmojo-TextBox {@inputNodeCssClass}"  style="{@inputNodeCssText}" '
                                + 'title="{@tooltip}" type="{@type}" '
                                + 'value="{@value}" size="{@size}" maxlength="{@maxLength}" index="{@tabIndex}"' +
                                ' mstrAttach:focus,keyup,blur ' +                              
                              '/>' +
                              '<span class="mstrmojo-TextBox-label-right">{@rightLabel}</span>' +
                          '</div>',
                          
            markupSlots: {
                inputNode: function(){return this.domNode.firstChild.nextSibling;}
            },
            
            preBuildRendering: function() {
                this.markupMethods = mstrmojo.hash.copy({
                                          onvisibleChange: function(){ this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; },
                                          oncssClassChange: function(){this.domNode.className = "mstrmojo-TextBoxWithLabel " + (this.cssClass||'');}
                                     },
                                     mstrmojo.hash.copy(this.markupMethods));
            }
        }
    );
})();
(function(){

	mstrmojo.requiresCls("mstrmojo.css", "mstrmojo._HasBuilder");
	
	mstrmojo.ToolBar = mstrmojo.declare(
		
		mstrmojo.HBox,
		
		[mstrmojo._HasBuilder],
		
		{
			scriptClass: "mstrmojo.ToolBar",
			
			cellCssClass: "mstrmojo-ToolBar-cell",

			markupString: '<table id="{@id}" class="mstrmojo-ToolBar {@cssClass}" style="{@cssText}" cellspacing="0" cellpadding="0"><tr><td class="mstrmojo-ToolBar-outercell">' +
						      '<table class="mstrmojo-ToolBar-innertable" cellspacing="0" cellpadding="0"><tr>{@tableHtml}</tr></table>' +
						  '</td></tr></table>',
									
			markupSlots: {
				containerNode: function(){ return this.domNode.rows[0].cells[0].firstChild.rows[0]; }
			},
			
			markupMethods: {
				onvisibleChange: function(){ this.domNode.style.display = this.visible ? mstrmojo.css.DISPLAY_TABLE : 'none'; }
			},
			
			
			buildChildren: function bldChd(){
				var cfg = this.buildConfig;
				if (!cfg) {
					this.buildConfig = {};
					cfg = this.buildConfig;
				}
				cfg.target = this.target;
				
				return this._super();
			}
		}
	);

})();
(function() {
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.registry", "mstrmojo.tooltip","mstrmojo.HBox");
    var $D = mstrmojo.dom,
        $C = mstrmojo.css,
        VALIGN_TOP = 1,
        VALIGN_MIDDLE = 2,
        VALIGN_BOTTOM = 3,
        getVerticalAlign = function(dom) {
            var va = $C.getStyleValue(dom, 'verticalAlign');
            return {'top': VALIGN_TOP, 'bottom': VALIGN_BOTTOM, 'middle': VALIGN_MIDDLE}[va] || VALIGN_TOP; 
        };
    
    mstrmojo.SliderBox = mstrmojo.declare(
        mstrmojo.Container,
        
        null,
        
        {
            scriptClass: 'mstrmojo.SliderBox',

            markupString: '<div id="{@id}" class="{@cssClass}" style="{@cssText}" tabindex="{@tabIndex}" >' +
                              '<div class="valuePart" style="{@valueCssText}">' +
                                  '<span class="valueLabel">{@valueLabel}</span>' +
                                  '<span class="valueText">{@valueText}</span>' +
                              '</div>' +
                              '<table class="sliderPart" style="{@sliderCssText}">' +
                                  '<tbody><tr>' + 
                                      '<td class="minText">{@min}</td>' +
                                      '<td class="sliderWrapper"></td>' +
                                      '<td class="maxText">{@max}</td>' +
                                  '</tr></tbody>' + 
                              '</table>' +
                          '</div>',

            markupSlots: {
                valuePartNode: function(){ return this.domNode.firstChild; },
                valueLabelNode: function(){ return this.domNode.firstChild.firstChild; },
                valueTextNode: function(){ return this.domNode.firstChild.lastChild; },
                sliderPartNode: function() { return this.domNode.lastChild; },
                minTextNode: function(){ return this.domNode.lastChild.rows[0].cells[0]; },
                maxTextNode: function(){ return this.domNode.lastChild.rows[0].cells[2]; },
                sliderNode: function(){ return this.domNode.lastChild.rows[0].cells[1]; }
            },
            
            markupMethods: {
                onmaxChange: function(){ this.maxTextNode.innerHTML = this.max; },
                onminChange: function(){ this.minTextNode.innerHTML = this.min; },
                onvalueTextChange: function(){ this.valueTextNode.innerHTML = this.valueText; },
                onunsetChange: function() {
                    var sliderNode = this.sliderBar.domNode;
                    if (sliderNode){
                        mstrmojo.css.toggleClass(sliderNode, 'unset', this.unset); 
                    }
                }
            },
            
            tabIndex: -1,
            
            sliderRef: null,
            
            valueLabel: mstrmojo.desc(4104, 'Value:'),
            
            valueText: '',
            
            min: '',
            
            max: '',
            
            interval: 0,
            
            isSequential: false, 

            unset: false,
            
            cssClass: 'mstrmojo-SliderGroup',
            
            postCreate: function postCreate() {
                
                if(!this.sliderRef) {
                    this.sliderRef = {
                        scriptClass: 'mstrmojo.Slider', 
                        isHoriz: true, 
                        ontitleChange: function() {
                            if(this.domNode && this.title) {
                                this.domNode.setAttribute('title', this.title);
                            }
                        },
                        onselectionChange: function() {
                            if(!this.hasRendered) {
                                return ;
                            }
                            var v = this.items[this.selectedIndex] && this.items[this.selectedIndex].n,
                                w = this.parent;
                            
                            if (w.unset){
                                w.unset = false;
                                $C.removeClass(this.domNode, 'unset');
                            }
                            
                            w.set('valueText', v);
                            w.set('value', v);
                            this.typeHelper.updateThumb();
                        }
                    };
                }
                
                this.sliderRef.slot = 'sliderNode'; 
                this.sliderRef.alias = 'sliderBar';
                this.addChildren(this.sliderRef);
            },
            
            preBuildRendering: function(){
                this._super();
                
                var min = this.min, 
                    max = this.max, 
                    v = mstrmojo.num.parseNumeric(this.value), 
                    items = this.items,
                    idx,
                    sliderBar = this.sliderBar;
                
                if (this.isSequential){
                    
                    idx = Math.floor((Math.max(Math.min(v, max), min) - min) / this.interval);
                    if(isNaN(v) || v < min || v > max) {
                        this.unset = true;
                    }
                }else{
                    
                    idx = mstrmojo.array.find(items, 'v', String(v));
                    if (idx == -1){
                        this.unset = true;
                        idx = 0;
                    }
                }
                
                sliderBar.set('items', items);
                sliderBar.select(idx || 0);
            },
            
            postBuildRendering: function(){
                this._super();
                
                if (this.unset){
                    $C.addClass(this.sliderBar.domNode, 'unset');
                }
            },
            
            
            alignSlider: function(baseNode, height) {

                var va = getVerticalAlign(baseNode),
                    ws, wv;

                
                if(!this.valuePartNode) {
                    wv = this.valueCssText || '';
                    ws = this.sliderCssText || ''; 
                    
                    if(va === VALIGN_TOP) {
                        this.valueCssText = 'top:0;' + wv;
                        this.sliderCssText = 'top:0;' + ws;
                    }else if(va === VALIGN_BOTTOM) {
                        this.valueCssText = 'bottom:0;' + wv;
                        this.sliderCssText = 'bottom:0;' + ws;
                    } else {
                        this.valueCssText = 'height: 100%; line-height: ' + height + 'px;' + wv;
                        this.sliderCssText = 'height: 100%;' + ws;
                    }
                
                
                } else {
                    ws = this.sliderPartNode.style;
                    wv = this.valuePartNode.style;
                    
                    
                    if(va) {
                        if(va === VALIGN_TOP) {
                            ws.top = wv.top ='0';
                        } else if(va === VALIGN_BOTTOM) {
                            ws.bottom = wv.bottom = '0';
                        } else {
                            wv.height = ws.height = '100%';
                            wv.lineHeight = inlineHeight + 'px';
                        }
                    }
                }
            }
        }
    );
})();
(function(){

	mstrmojo.requiresCls(
		"mstrmojo.Container",
		"mstrmojo.HBox",
		"mstrmojo._HasBuilder",
		"mstrmojo._CanMeasureChildren");
	
	
	var _IsDocSection = {
        
		postBuildRendering: function postBldRndr() {
			return (this.renderMode != 'scroll') ? this._super() : true;
		},

		childRenderOnAddCheck: function(children) {
			return (this.renderMode != 'scroll') ? this._super(children) : false;
		},

		preserveChildDomOrder: false
	};

	function _refresh(me) {
        if (!me.hasRendered) {
            return;
        }
                            
        var c = me.children || [];
        for (var i = c.length - 1; i >= 0; i--) {
            c[i].refresh && c[i].refresh();
        }
	}
	
	
	mstrmojo.DocSection = mstrmojo.declare(
		
		mstrmojo.Container,
		
		
        [ mstrmojo._HasBuilder, _IsDocSection, mstrmojo._CanMeasureChildren ],
		
		
		{
			scriptClass: "mstrmojo.DocSection",
			
			markupString: '<div id="{@id}" class="mstrmojo-DocSection"></div>',
			
			markupSlots: {
				containerNode: function() { return this.domNode; }
			},
            
			
			width: function width(count) {
				return this._super(1);
			},
			
            refresh: function refresh() {
				_refresh(this);
            }
		}
	);
	
	
	
	mstrmojo.DocSectionHoriz = mstrmojo.declare(
		
		mstrmojo.HBox,
		
		
		[ mstrmojo._HasBuilder, _IsDocSection, mstrmojo._CanMeasureChildren ],
		
		
		{
			scriptClass: "mstrmojo.DocSectionHoriz",
			
			
			height: function height(count) {
				return this._super(1);
			},
			
			refresh: function refresh() {
				_refresh(this);
			}
		}
	);	
	
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo.Container",
                         "mstrmojo.num",
                         "mstrmojo.HBox",
                         "mstrmojo._IsInputControl",
                         "mstrmojo._TouchGestures");

    var $D = mstrmojo.dom,
        $DAE = $D.attachEvent,
        $DDE = $D.detachEvent,
        $C = mstrmojo.css,
        _DTP = mstrmojo.expr.DTP,
        _BTN = 'mstrmojo.Button',
        _N = mstrmojo.num,
        _TR = mstrmojo.validation.TRIGGER,
        HOLD_INTERVAL = 50,
        HOLD_THRESHOLD = 500,
        DECIMAL_NUM = 10;

    function attachWinEvts() {
        var me = this;
        $DAE(window, $D.TOUCHSTART, me._evtHandler, true);
        me.isActive = true;
    }
    
    function detachWinEvts() {
        var me = this;
        $DDE(window, $D.TOUCHSTART, me._evtHandler, true);
        me.isActive = false;
    }

    function decimalFormat(v) {
        return v ? parseFloat(v.toFixed(DECIMAL_NUM)) : v;
    }

    function minusCalc() {
        var v = this.numericValue,
            max = this.max,
            min = this.min,
            itv = this.itv;

            if (!isNaN(v)) {
                if (max !== undefined && v - itv > max) {
                    this.set('numericValue', max);
                } else if (min === undefined || v - itv >= min) {
                    this.set('numericValue', decimalFormat(v - itv));
                } else if (v > min && v - itv < min) {
                    this.set('numericValue', min);
                }
            }
    }

    function plusCalc() {
        var v = this.numericValue,
            max = this.max,
            min = this.min,
            itv = this.itv;

        if (!isNaN(v)) {
            if(min !== undefined && v + itv < min) {
                this.set('numericValue', min);
            } else if (max === undefined || v + itv <= max) {
                this.set('numericValue', decimalFormat(v + itv));
            } else if (v < max && v + itv > max) {
                this.set('numericValue', max);
            }
        }
    }

    function processEvent(isPlus) {
        if (isPlus) {
            plusCalc.call(this);
        } else {
            minusCalc.call(this);
        }
    }

    function startStepperInterval(isPlus) {
        var me = this;
        this._holdTimer = setInterval(function () {
            processEvent.call(me, isPlus);
        }, HOLD_INTERVAL);
    }

    function stopStepperInterval() {
        if (this._holdTimer) {
            clearInterval(this._holdTimer);
            delete this._holdTimer;
        }
    }

    function startStepperTimeout(isPlus) {
        var me = this;
        if (!this._holdTimer && !this._startHoldTimer) {
            this._startHoldTimer = setTimeout(function () {
                delete me._startHoldTimer;
                startStepperInterval.call(me, isPlus);
            }, HOLD_THRESHOLD);
        }
    }

    function stopStepperTimeout() {
        if (this._startHoldTimer) {
            clearTimeout(this._startHoldTimer);
            delete this._startHoldTimer;
        }
        stopStepperInterval.call(this);
    }

    function isTapOnPlus(evt) {
       var v = evt.target;
       return (this.plusNode && this.plusNode == v);
    }

    function isTapOnMinus(evt) {
        var v = evt.target;
        return (this.minusNode && this.minusNode == v);
    }

    function applayChange() {
        var v = this.numericValue;
        if (!isNaN(v) && v >= this.min && v <= this.max && v != this.value) {
            this.set('value', v);
        }
    }
    
    function addTouchedClass(el) {
        $C.addClass(el, 'touched');
    }

    function createDICWidget(dic) {
        var max = dic.max,
            min = dic.min,
            itv = dic.itv;

        return {
            scriptClass: 'mstrmojo.HBox',
            alias: 'hBox',
            cssText: 'margin:auto',

            children: [{
                scriptClass: _BTN,
                alias: 'minus',
                cssClass: 'mstrmojo-StepperDIC-Operator minus',
                bindings: {
                    enabled: function() { return this.parent.parent.numericValue > min;}
                }
            }, {
                scriptClass: 'mstrmojo.ValidationTextBox',
                cssClass: 'mstrmojo-DataInputControl',
                dtp: _DTP.DOUBLE,
                required: true,
                alias: 'textInput',

                constraints: {
                    trigger: _TR.ONKEYUP | _TR.ONBLUR,
                    max: max,
                    min: min
                },

                bindings: {
                    value: 'this.parent.parent.numericValue'
                },

                onblur: function onblur(evt) {
                    var di = this.parent.parent,
                        value = _N.parseNumeric(this.value);

                    if (!di.isActive) {
                        applayChange.call(this.parent.parent);
                    }

                    this._super && this._super(evt);
                },

                onValid: function() {
                    this.parent.parent.set('numericValue', parseFloat(this.value));
                }
            }, {
                scriptClass: _BTN,
                alias: 'plus',
                cssClass: 'mstrmojo-StepperDIC-Operator plus',

                bindings: {
                    enabled: function() { return this.parent.parent.numericValue < max; }
                }
            }]
        };
    }

    
    mstrmojo.android.inputControls.StepperDIC = mstrmojo.declare(
        
        mstrmojo.Container,
        
        [ mstrmojo._IsInputControl, mstrmojo._TouchGestures ],
        
        {
            scriptClass: 'mstrmojo.android.inputControls.StepperDIC',

            cssClass: 'mstrmojo-StepperDIC',

            isActive: false,

            markupString: '<div id="{@id}" class="{@cssClass}" style="{@cssText}"></div>',

            markupSlots: {
                containerNode: function() { return this.domNode; }
            },

            markupMethods: {
                onvisibleChange: function() { this.domNode.style.display = this.visible ? 'block' : 'none'; }
            },

            init: function init(props) {
                this._super && this._super(props);

                this.max = this.dic.max;
                this.min = this.dic.min;
                this.itv = this.dic.itv;

                var _v = parseFloat(this.value);
                this.set('numericValue', isNaN(_v) ? (this.min||0) : _v);

                this.set('children', createDICWidget(this.dic));

                this.plus = this.hBox && this.hBox.plus;
                this.minus = this.hBox && this.hBox.minus;

                var me = this;
                this._evtHandler = this._evtHandler || function(evt) {
                    var t = evt.target;
                    if (!$D.contains(me.domNode, t)) {
                        $D.stopPropogation(evt.view, evt);
                        detachWinEvts.call(me);
                        applayChange.call(me);
                    }
                }
            },

            postBuildRendering: function postBuildRendering () {
                this._super();
                this.plusNode = this.plus && this.plus.domNode;
                this.minusNode = this.minus && this.minus.domNode;
            },

            touchTap: function (touch){
                if (!this.isActive) {
                    attachWinEvts.call(this);
                }
                if (isTapOnPlus.call(this, touch)) {
                    addTouchedClass(this.plusNode);
                    processEvent.call(this, true);
                } else if (isTapOnMinus.call(this, touch)) {
                    addTouchedClass(this.minusNode);
                    processEvent.call(this, false);
                }
            },

            touchBegin: function touchBegin(touch) {
                if (!this.isActive) {
                    attachWinEvts.call(this);
                }
                if (isTapOnPlus.call(this, touch)) {
                    addTouchedClass(this.plusNode);
                    startStepperTimeout.call(this, true);
                } else if (isTapOnMinus.call(this, touch)) {
                    addTouchedClass(this.minusNode);
                    startStepperTimeout.call(this, false);
                }
            },

            touchEnd: function touchEnd(touch) {
                stopStepperTimeout.call(this);
            },

            unrender: function unrender(ignoreDom) {
                if (this.isActive) {
                    detachWinEvts.call(this);
                }
                stopStepperTimeout.call(this);
                this._super(ignoreDom);
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                mstrmojo.css.addClass(this.domNode.firstChild || d, 'tx-active');
            }
        }
    );
}());
 (function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo.func",
                         "mstrmojo.array",
                         "mstrmojo.Button",
                         "mstrmojo.HBox",
                         "mstrmojo.dom",
                         "mstrmojo.Box");

    var $FNC = mstrmojo.func.composite,
        $D = mstrmojo.dom;


    
    mstrmojo.Dialog = mstrmojo.declare(

        mstrmojo.Container,

        null,

        
        {
            scriptClass: "mstrmojo.Dialog",

            
            title: '',

            
            buttons: null,

            
            alignment: 'center',

            
            btnAlignment: 'right',

            
            zIndex: 10,

            
            modal: true,

            markupString: '<div id="{@id}" class="mstrmojo-Dialog {@cssClass}" tabindex="0" mstrAttach:click>' +
                              '<div class="win mstrmojo-Editor" style="{@cssText}">' +
                                  '<div class="mstrmojo-Editor-titlebar"><div class="mstrmojo-Editor-title">{@title}</div></div>' +
                                  '<div class="mstrmojo-Editor-content"></div>' +
                                  '<div class="mstrmojo-Editor-buttons"></div>' +
                              '</div>' +
                              '<div class="mstrmojo-Editor-curtain"></div>' +
                              '<div class="mstrmojo-Editor-tip"></div>' +
                          '</div>',

            markupSlots: {
                editorNode: function () { return this.domNode.firstChild; },
                curtainNode: function () { return this.domNode.childNodes[1]; },
                titleNode: function () { return this.domNode.firstChild.firstChild; },
                containerNode: function () { return this.domNode.firstChild.childNodes[1]; },
                buttonNode: function () { return this.domNode.firstChild.lastChild; },
                tipNode: function () { return this.domNode.lastChild; }
            },

            markupMethods: {
                onzIndexChange: function () {
                    this.editorNode.style.zIndex = this.zIndex;
                    this.curtainNode.style.zIndex = this.zIndex - 1;
                },
                onwidthChange: function () {
                    this.editorNode.style.width = this.width || 'auto';
                },
                onvisibleChange: function (init) {
                    if (init) {
                        return;
                    }

                    var v = this.visible,
                        d = v ? 'block' : 'none';

                    this.editorNode.style.display = d;

                    if (this.modal) {
                        this.curtainNode.style.display = d;
                    }
                },
                onleftChange: function () { this.editorNode.style.left = this.left || ''; },
                ontopChange: function () { this.editorNode.style.top = this.top || ''; },
                ontitleChange: function () { this.titleNode.firstChild.innerHTML = this.title || ''; }
            },

            preBuildRendering: function preBuildRendering() {
                var b;

                
                var buttons = this.buttons;
                if (buttons && !this.btnHbox) {

                    
                    for (b in buttons) {
                        buttons[b].cssClass = 'mstrmojo-Editor-button';
                    }

                    
                    this.addChildren([{
                        scriptClass: 'mstrmojo.HBox',
                        cssText: 'float:' + this.btnAlignment,
                        slot: 'buttonNode',
                        alias: 'btnHbox',
                        children: buttons
                    }, {
                        scriptClass: 'mstrmojo.Label',
                        cssClass: 'mstrmojo-clearMe',
                        slot: 'buttonNode'
                    }]);
                }

                
                if (this.modal) {
                    
                    this.cssClass += ' modal';
                }

                
                return this._super();
            },

            buildRendering: function buildRendering() {
                
                var ph = this.placeholder;
                
                
                if (this._super()) {
                	
                    if (!this.parent && !ph) {
                        
                        document.body.appendChild(this.domNode);
                    }
                    
                    return true;
                }

                return false;
            },

            
            getResizeHandler: function getResizeHandler() {
                var id = this.id;
                return function () {
                    var dialog = mstrmojo.all[id];
                    dialog.resizeDialog();
                    dialog.positionDialog();
                };
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                
                if (this.modal && this.visible) {
                    
                    this.curtainNode.style.display = 'block';
                }

                
                if (!this._resizeHandler) {
                    
                    var fn  = this._resizeHandler = this.getResizeHandler();

                    
                    $D.attachEvent(window, 'resize', fn);
                }

                
                this.resizeDialog();
                this.positionDialog();

                
                this.domNode.focus();

                return true;
            },

            
            resizeDialog: function resizeDialog() {
                
                if (this.modal) {
                    
                    this.resizeCurtain();
                }
            },

            
            resizeCurtain: function resizeCurtain() {
                var w = this,
                	curtainNode = w.curtainNode,
                    body = document.body,
                    docElement = document.documentElement,
                    cs = curtainNode.style,
                    curtainPosition = w.curtainPosition;

                
                cs.width = Math.max(body.clientWidth, docElement.scrollWidth) + 'px';
                
                if (curtainPosition && curtainPosition.h) {
                	cs.height = curtainPosition.h + 'px';
                } else {
                	cs.height = Math.max(body.clientHeight, docElement.scrollHeight) + 'px';
                }
                
                if (curtainPosition && curtainPosition.y) {
                	cs.top = curtainPosition.y + 'px';
                }
                
                w.raiseEvent({name: 'resizeCurtain'});
            },

            
            positionDialog: function positionDialog() {
                
                if (!this.left || !this.top) {
                    var editor = this.editorNode;

                    
                    $D.center(editor);

                    
                    if (this.alignment === 'top') {
                        
                        editor.style.top = '10px';
                    }
                }
            },

            destroy: function (ignoreDom) {
                
                var fn = this._resizeHandler;
                if (fn) {
                    
                    $D.detachEvent(window, 'resize', fn);
                }

                this._super(ignoreDom);
            }
        }
    );

    
    if (window.mstrConfig && !window.mstrConfig.simpleDialog) {

        
        mstrmojo.confirm = function confirm(msg, buttons, title) {
            var id = 'mojoConfirmx9',
                fnDestroy = function () {
                    mstrmojo.all[id].destroy();
                };

            
            mstrmojo.array.forEach(buttons, function (btn) {
                var fn = btn.onclick;
                btn.onclick = fn ? $FNC([ fnDestroy, fn ]) : fnDestroy;
            });

            
            mstrmojo.insert({
                scriptClass: 'mstrmojo.Dialog',
                id: id,
                title: title || mstrmojo.desc(3610),
                width: '475px',
                buttons: buttons,
                children: [{
                    scriptClass: 'mstrmojo.Label',
                    text: msg
                }]
            }).render();
        };

        
        mstrmojo.alert = function alrt(msg, fn, title) {

            var id = 'mojoAlertx9';

            try {
                
                
                mstrmojo.all[id].destroy();
            } catch (e) { }

            mstrmojo.insert({
                scriptClass: 'mstrmojo.Dialog',
                id: id,
                title: title || mstrmojo.desc(3610),     
                width: '475px',
                buttons: [ mstrmojo.Button.newInteractiveButton(mstrmojo.desc(1442), function () {       
                    mstrmojo.all.mojoAlertx9.destroy();
                    if (fn) {
                        fn();
                    }
                }, '#666666')],
                children: [{
                    scriptClass: 'mstrmojo.Label',
                    text: msg
                }]
            }).render();
        };

        
        mstrmojo.toast = function toast(msg, duration) {

            var id = 'mojoToast9',
                dom,
                time = duration || 3000;
            
            try {
                mstrmojo.all[id].destroy();
            } catch (e) { }

            mstrmojo.insert({
                id: id,
                scriptClass: 'mstrmojo.Label',
                cssClass: 'toastCss',
                text: msg
            }).render();

            dom = mstrmojo.all[id].domNode;

            
            document.body.appendChild(dom);
            $D.bottomCenter(dom);

            window.setTimeout(function () {
                mstrmojo.all[id].destroy();
            }, time);
        };
        
        mstrmojo.mask = {};
        
        mstrmojo.mask.show = function () {
        	mstrmojo.mask.win = mstrmojo.insert({
        		scriptClass: 'mstrmojo.Box',
        		cssClass: 'fullscreen-mask'
             });
        	mstrmojo.mask.win.render();
            document.body.appendChild(mstrmojo.mask.win.domNode);
        };

        mstrmojo.mask.hide = function() {
             mstrmojo.mask.win.destroy();
        };
    }

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocPanel",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo._CanGrowOrShrink",
                         "mstrmojo.hash");

    
    function adjustForInfoWindow() {
        
        var containerNode = this.containerNode;
        if (containerNode) {
            
            var fmts = this.getFormats(),
                parentSize = this._parentSize,
                h = Math.max((parseInt(fmts.height, 10) || 0), parentSize.height),
                w = Math.max((parseInt(fmts.width, 10) || 0), parentSize.width),
                containerNodeStyle = containerNode.style;

            
            containerNodeStyle.width = w + 'px';
            containerNodeStyle.height = h + 'px';
        }
    }

    
    var androidPanel = mstrmojo.android.AndroidDocPanel = mstrmojo.declare(
        
        mstrmojo.DocPanel,

        
        [ mstrmojo._CanGrowOrShrink, mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        
        {
            scriptClass: "mstrmojo.AndroidDocPanel",

            
            scrollerSetupDelay: 0,

            postBuildRendering: function postBuildRendering() {
                
                if (this._isInfWin) {
                    
                    adjustForInfoWindow.call(this);
                }

                return this._super();
            },

            
            updatePanelDimensions: function updatePanelDimensions(left, height, width, isInfoWindow) {
                
                this._parentSize = {
                    height: height,
                    width: width
                };

                var px = 'px';

                
                if (isInfoWindow) {
                    
                    this._isInfWin = true;

                    
                    adjustForInfoWindow.call(this);
                }

                
                this.cssText = 'left:' + left + 'px;top:0;height:' + height + px + ';width:' + width + px + ';';

                
                if (this.hasRendered) {
                    
                    var ps = this.domNode.style;

                    
                    ps.left = left + px;
                    ps.height = height + px;
                    ps.width = width + px;

                    this.updateScroller();
                }
            },

            
            update: function update(node) {
                
                this.scrollerConfig = {
                    bounces: false,
                    showScrollbars: false
                };
            },

            
            onchildRenderingChange: function onchildRenderingChange(obj) {
                this._super(obj);

                
                if (this.getFormats().overflow === 'auto') {
                    
                    this.performCanGrowCanShrink([ (obj && obj.src) || obj ], (!!this._isInfWin && !mstrApp.isTablet())); 
                }
            },

            touchTap: function touchTap() {
                
                var ctrl = this.controller;
                if (ctrl && ctrl.viewTap) {
                    
                    ctrl.viewTap();
                }
            },

            getCanGrowShrinkNode: function getCanGrowShrinkNode() {
                return this.containerNode;
            },

            afterCanGrowShrink: function canGrowShrinkPerformed() {
                
                this.updateScroller();
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super();

                
                if (this.getFormats().overflow === 'auto') {
                    var scrollEl = this.containerNode,
                        widgetSize = this._parentSize,
                        iterator = {
                            'Height': {
                                a: 'y',
                                s: 'v'
                            },
                            'Width': {
                                a: 'x',
                                s: 'h'
                            }
                        },
                        offset = {};

                    
                    cfg.scrollEl = scrollEl;

                    mstrmojo.hash.forEach(iterator, function (info, dimension) {
                        
                        var size = widgetSize[dimension.toLowerCase()];

                        
                        var offsetEnd = Math.max(scrollEl['offset' + dimension] - size, 0),
                            enableDimensionScroll = cfg[info.s + 'Scroll'] = (offsetEnd !== 0);

                        
                        if (enableDimensionScroll) {
                            
                            offset[info.a] = {
                                start: 0,
                                end: offsetEnd
                            };
                        }
                    });

                    
                    cfg.offset = offset;

                    
                    cfg.origin = cfg.origin || {
                        x: 0,
                        y: 0
                    };
                }

                return cfg;
            }
        }
    );

    
    var formatHandlers = androidPanel.prototype.formatHandlers,
        nodeName = 'containerNode';

    formatHandlers[nodeName] = formatHandlers[nodeName].concat('D');

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocLayoutViewer",
                         "mstrmojo._Formattable",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.dom");

    
    function checkLinks(checkAll) {
        var links,
            newLinks = this._newLinks,
            allLinks = mstrmojo.hash.copy(newLinks, this._allLinks),
            links = checkAll ? allLinks : newLinks;
        
        this._newLinks = {};
        
        
        
        if ( mstrMobileApp.isOnline() ) {
            return;
        }

        
        var controller = this.controller,
            i,
            lnk,
            linkRequests = [],
            cacheableLinks = [],
            req;

        for (i in links) {
            lnk = links[i];
            req = controller.getLinkRequest(lnk);
            if (req) {
                linkRequests.push(req);
                cacheableLinks.push(lnk);
            }
        }

        
        var count = linkRequests.length;
        if (count) {
            
            var fnSuccess = function (res) {
                for (i = 0; i < count; i++) {
                    lnk = cacheableLinks[i];
                    lnk.src.setLinkEnabled(res[i]);
                }
            };

            if (mstrApp.isHosted()) {
                

            } else {
                this.model.getDataService().checkCachedLinkTargets(linkRequests, {
                    success: fnSuccess,
                    failure: mstrmojo.emptyFn
                });
            }
        }
    }
    
    function applyChildDimensions() {
        var ch = this.children,
        i,
        len;

        
        for (i = 0, len = (ch && ch.length) || 0; i < len; i++) {
            var child = ch[i],
                slot = child.slot;

            
            if (slot) {
                
                this.setSlotDimensions(slot, child.height, child.width);
            }
        }
    }

    
    mstrmojo.MobileDocLayoutViewer = mstrmojo.declare(
        
        mstrmojo.DocLayoutViewer,

        
        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        
        {
            scriptClass: "mstrmojo.MobileDocLayoutViewer",

            layoutConfig: {
                h: {
                    groupBy: '0',
                    fixedHeaderNode: 'auto',
                    layout: '100%',
                    fixedFooterNode: 'auto',
                    incFetchNode: '0'
                },
                w: {
                    layout: '100%'
                }
            },

            formatHandlers: {
                domNode: [ 'background-color' ]
            },

            scrollerConfig: {
                vScroll: false,
                hScroll: false,
                bounces: false,
                showScrollbars: false
            },
            

            usesTouches: true,
            
            init: function init(params) {
                this._super(params);
                this._newLinks = {};
                this._allLinks = {};
                
            },
            
            postBuildRendering: function postBuildRendering() {
            	this._super();

                
                if(this.fixedFooterNode.clientHeight > 0) {
                    applyChildDimensions.call(this);
                }
            },

            preBuildRendering: function preBuildRendering() {
                this._super();

                this._scrollCssText = 'overflow:' + ((!mstrmojo.dom.isWinPhone) ? 'hidden' : 'auto');

                var id = this.id,
                    updateScroller = this.updateScroller;

                
                if (!this.afterScrollSubscr) {
                    this.afterScrollSubscr = this.docLayout.attachEventListener('afterScroll', id, function () {
                        this.updateScroller();
                        checkLinks.call(this);
                    });

                    
                    this.model.attachEventListener('partialUpdate', id, updateScroller);
                }
            },
            
            mapID:null,
            setMapID: function setMapID(id) {
                this.mapID = id;
            },
            
            beforeViewHidden: function beforeViewHidden(isBack) {
                if (!this.mapID) return;
                var c = mstrmojo.all[this.mapID];
                if (c && c.beforeViewHidden) {
                    c.beforeViewHidden(isBack);
                }
                this.mapID = null;
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this.scrollerConfig,
                    layoutNode = this.docLayout.containerNode;

                if (layoutNode) {
                    var docLayout = this.docLayout,
                        xOffset = {
                            start: 0,
                            end: Math.max(docLayout.getWidth() - this.scrollboxWidth, 0)
                        },
                        yOffset = {
                            start: 0,
                            end: Math.max(docLayout.getHeight() - this.scrollboxHeight, 0)
                        },
                        vScroll = (yOffset.start !== yOffset.end),
                        hScroll = (xOffset.start !== xOffset.end),
                        offset;

                    
                    if (vScroll || hScroll) {
                        
                        offset = {
                            x: xOffset,
                            y: yOffset
                        };
                    } else {
                        
                        cfg.origin = {
                            x: 0,
                            y: 0
                        };
                    }

                    
                    mstrmojo.hash.copy({
                        scrollEl: this.scrollboxNode.firstChild,    
                        offset: offset,
                        vScroll: vScroll,
                        hScroll: hScroll,
                        showScrollbars: false
                    }, cfg);

                    
                    if (!cfg.origin) {
                        cfg.origin = this._origin = {
                            x: 0,
                            y: 0
                        };
                    }

                    
                    docLayout.scrollBuffer = parseInt(mstrApp.rootView.getContentDimensions().h, 10);
                }

                return this._super();
            },

            
            initScroller: function initScroller(scroller) {
                this._super(scroller);

                
                scroller.attachEventListener('scrollDone', this.id, function (evt) {
                    
                    this._origin = {
                        x: evt.x,
                        y: evt.y
                    };

                    
                    this.notifyScrollListeners(evt);
                });
            },

            touchBegin: function touchBegin(touch) {
                var p = this.parent;
                
                if (p && p.isAnimating && p.isAnimating()) {

                    
                    touch.stop();

                    
                    return false;
                }
                return this._super(touch);
            },

            
            shouldTouchBubble: function shouldTouchBubble(touch) {
            	if(mstrmojo.dom.contains(this.scrollboxNode, touch.target, true, this.domNode)) {
            		return this._super(touch);
            	}
            	
            	return true;
            },
            
            touchSwipeBegin: function touchSwipeBegin(touch) {
                
                if (this.shouldTouchBubble(touch)) {
                    var parent = this.parent,
                    	parentCanScroll = parent.canScroll && parent.canScroll(touch);

                    
                    if (parentCanScroll) {
                        
                        this._parentScrolling = true;

                        
                        parent.beginScroll(touch);
                    }
                    
                    return parentCanScroll;
                }

                this._super(touch);
            },

            touchSwipeMove: function touchSwipeMode(touch) {
                
                if (this._parentScrolling) {
                    
                    this.parent.scroll(touch);

                    return;
                }

                this._super(touch);
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                
                touch.evt.handled = true;

                
                if (this._parentScrolling) {
                    
                    delete this._parentScrolling;

                    
                    this.parent.endScroll(touch);

                    return;
                }

                this._super(touch);
            },

            touchTap: function touchTap() {
                
                var ctrl = this.controller;
                if (ctrl && ctrl.viewTap) {
                    
                    ctrl.viewTap();
                }
            },

            
            renderChildren: function rnCh() {
                this._super();

                
                this.updateScroller();
            },

            
            unrender: function unrender() {
                
                delete this.scrollerConfig.origin;
                var scroller = this._scroller;
                if (scroller) {
                    delete scroller.origin;
                }
                if (this.subscr) {
                    mstrmojo.publisher.unsubscribe(this.subscr);
                    delete this.subscr;
                }
                if (this.afterScrollSubscr) {
                    mstrmojo.publisher.unsubscribe(this.afterScrollSubscr);
                    delete this.afterScrollSubscr;
                }
                
                this._super();
            },

            
            addLinkInfo: function addLinkInfo(id, linkInfo) {
                this._newLinks[id] = linkInfo;
            },
            
            
            onRender: function onRender() {
                this._super();

                
                
                if (!this.subscr) {
                    var publisher = mstrmojo.publisher;
                    this.subscr = publisher.subscribe(publisher.NO_SRC, publisher.CONNECTIVITY_CHANGED_EVENT, function (isOnline) {
                        
                        
                        if (isOnline) {
                            
                            var links = this._allLinks,
                                i,
                                widget;

                            for (i in links) {
                                widget = links[i].src;
                                if (!widget.linkEnabled) {
                                    widget.setLinkEnabled(true);
                                }
                            }

                        } else {
                            checkLinks.call(this, true);
                        }
                    }, this.id);
                }

                
                if ((mstrApp.useBinaryFormat || mstrApp.isHosted()) && !mstrMobileApp.isOnline() ) {
                    var me = this;
                    window.setTimeout(function () {
                        checkLinks.call(me);
                    }, 100);
                }
            },
            
            setSlotDimensions: function setSlotDimensions(slot, h, w) {
                if (slot === 'layout') {
                    
                    var winHeight = parseInt(this.height, 10),
                        headerHeight = this.fixedHeaderNode.clientHeight,
                        footerHeight = this.fixedFooterNode.clientHeight,
                        height = parseInt(h, 10),
                        actHeight = winHeight - headerHeight - footerHeight;

                    
                    if(headerHeight + footerHeight >= winHeight) {
                        h = 0;
                    } else if( height != actHeight){
                        h = actHeight + 'px';
                    }
                }

                this._super(slot, h, w);
            },
            
            getCaptureDimensions: function getCaptureDimensions() {
            	return this.docLayout.getCaptureDimensions();
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocLayout");

    
    function resizeForSharedHeight(me) {
        var mh = -1,
            c = me.children,
            sec,
            six,
            ssix,
            subsec,
            subsecArr = [],
            resizeSection = function () {
                var ci;
                for (ci in subsecArr) {
                    var subsec = subsecArr[ci];
                    if (subsec._fixedHeight !== mh) {
                        subsec._fixedHeight = mh;
                        if (subsec.domNode) { 
                            subsec.domNode.style.height = mh + 'px';
                        }
                    }
                }
                mh = -1;
                subsecArr = [];
            };

        for (six in c) {
            sec = c[six];
            if (sec.node.data.bh && mh > -1) {
                
                
                resizeSection();
            }
            if (sec.defn.horiz) {
                
                for (ssix in sec.children) {
                    
                    subsec = sec.children[ssix];
                    mh = Math.max(subsec._fixedHeight || 0, mh);
                    
                    subsecArr[subsecArr.length] = subsec;
                }
            }
        }
        resizeSection();
    }

    
    mstrmojo.DocLayoutHoriz = mstrmojo.declare(
        
        mstrmojo.DocLayout,

        
        null,

        
        {
            scriptClass: "mstrmojo.DocLayoutHoriz",

            markupString: '<div id="{@id}">' +
                              '<div class="mstrmojo-DocLayout {@cssClass}" style="{@domNodeCssText}">' +
                              '</div>' +
                          '</div>',

            markupSlots: {
                containerNode: function () { return this.domNode.firstChild; }
            },

            getWidth: function getWidth() {
                
                return this.containerNode.offsetWidth;
            },

            getHeight: function getHeight() {
                
                return this.containerNode.offsetHeight;
            },

            _renderSection: function _renderSection(sec, index) {

                
                if (sec.node.data.bh) {

                    
                    var d = document.createElement('div');
                    d.className = 'mstrmojo-DocLayout-HBox';

                    
                    var t = document.createElement('table');
                    t.className = 'mstrmojo-DocLayout-HBox-HorizContainerTable';

                    
                    this._hRow = t.insertRow(-1);

                    
                    d.appendChild(t);

                    
                    this.containerNode.appendChild(d);
                }

                
                if (sec.defn.horiz) {
                    
                    var slotName = 'hi' + index;

                    
                    sec.slot = slotName;

                    
                    var td = this._hRow.insertCell(-1);

                    
                    td.vAlign = 'top';

                    
                    var slots = {};
                    slots[slotName] = td;
                    this.addSlots(slots);
                }
                this._super(sec, index);
            },
            
            getLayoutMinWidth: function getLayoutMinWidth() {
                var minWidth = 0,              
                    currentMinWidth = 0,       
                    children = this.children,
                    len = children.length,
                    i,
                    k;

                
                for (i = 0; i < len; i++) {

                    var sec = children[i],
                        secNode = sec && sec.node,
                        secNodeData = secNode && secNode.data,
                        begin = secNodeData && (String(secNodeData.bh) === 'true' || String(secNodeData.bv) === 'true');

                    
                    if (begin) {
                        minWidth = Math.max(minWidth, currentMinWidth);
                        currentMinWidth = 0;
                    }

                    if (sec.children) {
                        
                        for (k in sec.children) {
                            currentMinWidth += sec.children[k].width();
                        }
                    } else {
                        
                        
                        currentMinWidth += 10;
                        break;
                    }
                }

                
                return Math.max(minWidth, currentMinWidth);
            },


            
            resizeOrReposition: function resizeOrReposition() {
                if (this._super) {
                    this._super();
                }

                resizeForSharedHeight(this);
            },


            
            renderCtrlsInViewport: function renderCtrlsInViewport() {
                this._super();
                resizeForSharedHeight(this);
            }

        }
    );

}());
(function() {
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.registry", "mstrmojo.tooltip");
    var $D = mstrmojo.dom;
    var $R = mstrmojo.all;

    
    mstrmojo._HasDnD = {
            
            postBuildRendering: function postBuildRendering() {
                if (this._super) {
                    this._super();
                }

                
                var id = this.id;
                this.dnd = new mstrmojo._DnDComponent({
                    target: this
                });
                this.__mouseDownEvt = function (e) {
                    $R[id].dnd.onmousedown(e);
                    return true;
                };
                $D.attachEvent(this.dndNode, 'mousedown', this.__mouseDownEvt);
            },

            unrender: function unrender() {
                
                if (this.__mouseDownEvt && this.dndNode) {
                    $D.detachEvent(this.dndNode, 'mousedown', this.__mouseDownEvt);
                }
                
                
                this.min = 0;
                this.max = (this.items && this.items.length - 1) || 0;

                this.dnd && this.dnd.clearListeners();
                this._super();
            }

    };
    
    mstrmojo._DnDComponent = mstrmojo.declare(
        
        null,
        
        null,
        
        {
                scriptClass: "mstrmojo._DnDComponent",
                
                isDragging: null,

                
                initD: null,
                
                startE: null,
                
                afterDragStart: null,
                duringDrag: null,
                afterDragEnd: null,

                
                target: null,

                
                mousemoveBuffer: 1,

                
                _mousemoveCounter: 0,
                
                init: function init_DnDComp(props) {

                    
                    mstrmojo.hash.copy(props, this);    
                },
                
                onmousedown: function onmousedown(e) {
                    
                    
                    
                    if (e && e.preventDefault) {
                        e.preventDefault();
                    }

                    if (this.dragging) {
                        return true;
                    }



                    var id = this.target.id;
                    if (!this._mousemoveCallback) {
                        this._mousemoveCallback = function(e) {
                            $R[id].dnd.onmousemove(e);
                            return true;
                        };
                    }
                    this._mousemoveCounter = 0;

                    this.startE = mstrmojo.hash.copy(e);

                    $D.attachEvent(document.body, 'mousemove', this._mousemoveCallback);

                    if (!this._cancelCallback) {
                        this._cancelCallback = function(e) {
                            $R[id].dnd.ondragcancel(e);
                            return true;
                        };
                    }

                    $D.attachEvent(document.body, 'mouseup', this._cancelCallback);
                },
                
                ondragcancel: function ondragcancel(e) {
                    
                    $D.detachEvent(document.body, 'mousemove', this._mousemoveCallback);
                    $D.detachEvent(document.body, 'mouseup', this._cancelCallback);

                    if (this.afterDragCancel) {
                    	this.afterDragCancel.apply(this.target, [e]);
                    }
                },
                
                onmousemove: function onmousemove(e) {
                    if (this.dragging) {
                        return;
                    }
                    this._mousemoveCounter++;
                    if (this._mousemoveCounter > this.mousemoveBuffer) {
                        $D.detachEvent(document.body, 'mousemove', this._mousemoveCallback);
                        $D.detachEvent(document.body, 'mouseup', this._cancelCallback);

                        this.initDrag(e);
                    }
                },
                
                initDrag: function initDrag(e) {
                    this.dragging = true;
                    var id = this.target.id;
                    if (!this._dragCallback) {
                        this._dragCallback = function(e) {
                            $R[id].dnd.ondrag(e);
                            return true;
                        };
                    }

                    $D.attachEvent(document.body, 'mousemove', this._dragCallback);

                    if (!this._dragEndCallback) {
                        this._dragEndCallback = function(e) {
                            $R[id].dnd.ondragend(e);
                            return true;
                        };
                    }
                    $D.attachEvent(document.body, 'mouseup', this._dragEndCallback);

                    
                    if (this.afterDragStart) {
                        this.afterDragStart.apply(this.target, [e]);
                    }

                    this._dragCallback(e);
                },
                
                ondrag: function ondrag(e) {
                    
                    if (this.duringDrag) {
                        this.duringDrag.apply(this.target, [e]);
                    }
                },
                
                ondragend: function ondragend(e) {
                    this.dragging = false;
                    $D.detachEvent(document.body, 'mousemove', this._dragCallback);
                    $D.detachEvent(document.body, 'mouseup', this._dragEndCallback);
                    
                    if (this.afterDragEnd) {
                        this.afterDragEnd.apply(this.target, [e]);
                    }
                },

                clearListeners: function clearListeners() {
                    
                    if(this._mousemoveCallback) {
                        $D.detachEvent(document.body, 'mousemove', this._mousemoveCallback);
                        delete this._mousemoveCallback;
                    }

                    if(this._cancelCallback) {
                        $D.detachEvent(document.body, 'mouseup', this._cancelCallback);
                        delete this._cancelCallback;
                    }


                    if(this._dragCallback) {
                        $D.detachEvent(document.body, 'mousemove', this._dragCallback);
                        delete this._dragCallback;
                    }

                    if(this._dragEndCallback) {
                        $D.detachEvent(document.body, 'mouseup', this._dragEndCallback);
                        delete this._dragEndCallback;
                    }
                }
        }
    );

    mstrmojo.requiresCls("mstrmojo.Widget", "mstrmojo._HasDnD", "mstrmojo._ListSelections");
    
    function SingleSlider(sl) {
        this.getUnit = function getUnit() {
            return sl._effLen / (sl.items.length - 1) || 1;
        };

        this.calcMinMax = function (pxMin, pxMax) {
            var p = Math.round((pxMin / sl.unit + pxMax / sl.unit) / 2);
            return {
                min: p,
                max: p
            };
        };

        this.preUpdateThumb = function () {
            sl.start = Math.min(sl.min * sl.unit, sl._effLen) + 'px';
            sl.sdCssText += sl.orCfg.posCssP + ':' + sl.start + ';';
        };

        this.updateThumb = function () {
            sl.containerNode.style[sl.orCfg.posCssP] = sl.start = Math.min(sl.min * sl.unit, sl._effLen) + 'px';
        };
    }

    
    function MultiSlider(sl) {
        this.getUnit = function () {
            return sl._effLen / sl.items.length; 
        };

        this.calcMinMax = function (pxMin, pxMax) {
            return {
                min: Math.floor(pxMin / sl.unit + 0.5),
                max: Math.floor(pxMax / sl.unit - 0.5)
            };
        };

        this.preUpdateThumb = function () {
            sl.start = (sl.min * sl.unit) + 'px';
            sl.length = Math.max(Math.round((sl.max - sl.min + 1) * sl.unit - sl.gap), 0) + 'px';
            sl.sdCssText += sl.orCfg.posCssP + ':' + sl.start + ';' + sl.orCfg.lenCssP + ':' + sl.length + ';';
        };

        this.updateThumb = function () {
            sl.start = sl.min * sl.unit + 'px';
            sl.containerNode.style[sl.orCfg.posCssP] = (sl.min * sl.unit) + 'px';
            sl.length = Math.max(Math.round((sl.max - sl.min + 1) * sl.unit - sl.gap), 1) + 'px';
            sl.containerNode.style[sl.orCfg.lenCssP] = sl.length;
        };
    }
    var _tooltipMarkup = '<span>{@content}</span>';
    
    mstrmojo.Slider = mstrmojo.declare(
            
            mstrmojo.Container,

            
            [mstrmojo._HasDnD, mstrmojo._ListSelections],

            
            {
                scriptClass: "mstrmojo.Slider",

                markupString: '<div class="mstrmojo-Slider {@cssClass} {@clsType} {@clsOrientation}" style="{@cssText}" >' +
                                '<div class="cont">' +
                                	'<div class="bk" style="{@bkCssText}"></div>' +
                                	'<div class="sdc" style="position:absolute;{@sdcCssText}">' +
	                                    '<div class="sd" style="{@sdCssText}">' +
	                                        '<div class="t1"></div>' +
	                                        '<div class="t2"></div>' +
	                                        '<div class="t3"></div>' +
	                                    '</div>' +
                                    '</div>' +
                                '</div>' +
                            '</div>',

                sdCssText: '',

                cssClass: 'sc',

                clsType: 'sc2',

                clsOrientation: 'sc-v',

                
                orCfg: null,

                
                typeHelper: null,
                
                _tooltip_pos: 0,

                useRichTooltip: true,

                init: function init(p) {
                    this._super(p);

                    
                    if (p.isHoriz) {
                        this.orCfg = {
                            posCssP : 'left',
                            marginCssP: 'marginLeft',
                            lenCssP : 'width',
                            lenP : 'clientWidth',
                            opPosCssP: 'top',
                            thickP: 'clientHeight',
                            offsetP: 'x'
                        };

                        this.clsOrientation = ' sc-h';
                        this._tooltip_pos = mstrmojo.tooltip.POS_BOTTOMLEFT;
                    } else {
                        this.orCfg = {
                            posCssP : 'top',
                            marginCssP: 'marginTop',
                            lenCssP: 'height',
                            lenP : 'clientHeight',
                            opPosCssP: 'left',
                            thickP: 'clientWidth',
                            offsetP: 'y'
                        };
                        this._tooltip_pos = mstrmojo.tooltip.POS_TOPRIGHT;
                    }
                    
                    this._exRoom = this.thumbWidth;
                    if (this.multiSelect) {
                        this._exRoom *= 2;
                    }

                    
                    if (p.multiSelect) {
                        this.typeHelper = new MultiSlider(this);
                    } else {
                        this.clsType = 'sc1';

                        this.typeHelper = new SingleSlider(this);
                    }
                },

                markupSlots: {
                    dndNode: function() {return this.domNode.childNodes[0];},    
                    bgNode: function() {return this.domNode.childNodes[0].childNodes[0];},
                    sdcNode: function() {return this.domNode.childNodes[0].childNodes[1];},
                    containerNode: function() {return this.domNode.childNodes[0].childNodes[1].childNodes[0];},
                    frontNode: function() {return this.domNode.childNodes[0].childNodes[1].childNodes[0].childNodes[0];},
                    thumbNode: function() {return this.domNode.childNodes[0].childNodes[1].childNodes[0].childNodes[1];},
                    endNode: function() {return this.domNode.childNodes[0].childNodes[1].childNodes[0].childNodes[2];},
                    tooltipNode: function(){return this.domNode.childNodes[0].childNodes[1];}
                },

                markupMethods: {
                    onvisibleChange: function(){ this.domNode.style.display = this.visible ? 'block' : 'none'; }
                },

                start: '50px',    

                length: '30px',    

                min: 0,            

                max: 0,            

                gap: 1,         

                ghost: null,    

                thumbWidth: 11,

                
                cssBkBW: 1,

                
                preBuildRendering: function preBuildRendering() {


                    
                    var d = this.orCfg.lenCssP,
                        v = this[d],
                        len = parseInt(v);

                    this._effLen = isNaN(len) ? 0 : (len - this._exRoom);

                    if (v) {
                        this.bkCssText = d + ':' + Math.max(parseInt(v, 10) - (2 * this.cssBkBW), 0) + 'px;';
                        this.sdcCssText = d + ':' + this._effLen + ';' + this.orCfg.posCssP + ':' + this._exRoom /2 + 'px;' + this.orCfg.opPosCssP + ':0px;';

                    }

                    
                    var idx = this.selectedIndices;
                    if (!mstrmojo.hash.isEmpty(idx)) {
                        this.min = this.items.length - 1;
                        this.max = 0;


                        
                        for (var i in idx) {
                            if (idx[i]) {
                                this.min = Math.min(this.min, i);
                                this.max = Math.max(this.max, i);
                            }
                        }
                    }
                    this.unit = this.typeHelper.getUnit();
                    this.typeHelper.preUpdateThumb();
                },

                postBuildRendering: function postBuildRendering() {
                    if (this._super) {
                        this._super();
                    }

                    if (this.items.length > 1 && this.dnd) {
                        
                        this.dnd.afterDragStart = this.initDrag;
                        this.dnd.duringDrag = this.ondrag;
                        this.dnd.afterDragEnd = this.ondrop;
                        this.dnd.afterDragCancel = this.cancelDrag;
                    }
                },

                
                _initGhost: function _initGhost() {
                    if (!this.ghost) {
                        var cn = this.containerNode.cloneNode(true);
                        mstrmojo.css.addClass(cn, ['gh']);

                        
                        this.ghost = {
                            containerNode: cn,
                            frontNode: cn.childNodes[0],
                            thumbNode: cn.childNodes[1],
                            endNode: cn.childNodes[2]
                        };

                        this.sdcNode.appendChild(cn);
                    }

                    
                    var gSty = this.ghost.containerNode.style,
                        cnSty = this.containerNode.style,
                        oc = this.orCfg;

                    gSty[oc.posCssP] = cnSty[oc.posCssP];
                    gSty[oc.lenCssP] = cnSty[oc.lenCssP];
                    gSty.display = 'block';

                    return this.ghost;
                },

                initDrag: function initDrag(e, hWin) {
                    hWin = hWin || window;

                    
                    var g = this._initGhost(),
                        oc = this.orCfg;

                    
                    this.dnd.initD = {
                            tP: parseInt(this.start, 10),                        
                            sL: this._effLen,                 
                            contL: g.containerNode[oc.lenP],                     
                            offset: $D.getMousePosition(this.dnd.startE, hWin)[oc.offsetP]     
                        };

                        this.dnd.initD.td = $D.eventTarget(hWin, this.dnd.startE);
                },

                ondrag: function ondrag( e, hWin){
                    hWin = hWin || window;

                    var initD = this.dnd.initD,
                        g = this.ghost,
                        cn = g.containerNode,
                        minPx,
                        maxPx,
                        lenPx,
                        min = this.min,
                        max = this.max,
                        oc = this.orCfg;

                    
                    var diff = $D.getMousePosition(e, hWin)[oc.offsetP] - initD.offset;
                    switch (initD.td) {
                        case this.thumbNode:    
                            minPx = Math.max(Math.min(initD.tP + diff, initD.sL - initD.contL), 0);
                            maxPx = minPx + initD.contL;

                            cn.style[oc.posCssP] = minPx + 'px';

                            var minmax = this.typeHelper.calcMinMax(minPx, maxPx);
                            min = minmax.min;
                            max = minmax.max;
                            break;

                        case this.frontNode:    
                            minPx = Math.max(Math.min(initD.tP + diff, initD.tP + initD.contL), 0);
                            lenPx = Math.max(Math.min(initD.contL - diff, initD.tP + initD.contL), 0);

                            cn.style[oc.posCssP] =  minPx + 'px';
                            cn.style[oc.lenCssP] =  lenPx + 'px';

                            min = Math.min(Math.floor(minPx / this.unit + 0.5), this.max);
                            break;

                        case this.endNode:        
                            lenPx = Math.max(Math.min(initD.contL + diff, initD.sL - initD.tP), 0);
                            maxPx = initD.tP + lenPx;

                            cn.style[oc.lenCssP] =  lenPx + 'px';

                            max = Math.max(Math.floor(maxPx / this.unit - 0.5), this.min);
                            break;

                        default:
                            return;

                    }

                    
                    if (min !== this.min || max !== this.max) {
                        this.min = min;
                        this.max = max;

                        
                        this.typeHelper.updateThumb();
                    }

                    this._updateTooltip();
                },

                ondrop: function ondrop( e){
                    
                    this.typeHelper.updateThumb();

                    
                    if (this.ghost) {
                        this.ghost.containerNode.style.display = "none";
                    }

                    
                    this.hideTooltip();

                    
                    if (this.items && this.items.length){ 
                    var sel = [];
                    for (var i = this.min; i <= this.max; i ++) {
                        sel.push(i);
                    }

                    this.select(sel);
                    }
                    
                    this.dnd.initD = null;
                },

                cancelDrag: function cancelDrag(e, hWin) {
                	if (this.makeSelection) {
                		hWin = hWin || window;
                		var td = $D.eventTarget(hWin, this.dnd.startE);
                		this.makeSelection({
                			selItem: td
                		});
                	}
                },

                
                showTooltip: function showTooltip(e, win) {
                    this._updateTooltip();
                    this._super(e, win);
                },

                hideTooltip: function hideTooltip(e, win) {
                    
                    if (this.dnd && this.dnd.dragging) {
                        return;
                    }
                    this._super(e, win);
                },
                
                _updateTooltip: function _updateTooltip() {

                    var oc = this.orCfg,
	                    tt = {
	                            contentNodeCssClass: 'sc-tooltip',
	                            refNode: this.domNode,
	                            posType: this._tooltip_pos 
	                        },
                    	ref = (this.ghost) ? this.ghost.containerNode : this.containerNode;

                    
                    tt[oc.opPosCssP] = 0; 
                    tt[oc.posCssP] = ref.style[oc.posCssP];

                    if (this.items && this.items.length) { 
	                    var min = this.getItemTooltip(this.items[this.min]);
                    var txt;
                    if (this.min === this.max) {
	                        txt = min;
                    } else {
	                        txt = mstrmojo.desc(146, "From:") + " \'" +
	                            min +
	                            "\' " + mstrmojo.desc(147, "To:") + " \'" +
	                            this.getItemTooltip(this.items[this.max]) + '\'';
	                    }

	                    tt.content = _tooltipMarkup.replace(/\{@content\}/g, txt);
                    } else {
                    	tt.content = '';
                    }
                    
                    this.set('richTooltip', tt);
                },

                
                getItemTooltip: function(item) {
                    return "'" + (item ? item.n : "") + "'";
                },

                unrender: function unrender(ignoreDOM) {
                    this.ghost = null;
                    this.dnd && (this.dnd.dragging = false);
                    this.hideTooltip();
                    this._super(ignoreDOM);
                },

                
                onselectionChange: function onselChg(evt) {
                    
                    if (this.onchange) {
                        this.onchange();
                    }

                	if (this.makeSelection && this.dnd && this.dnd.initD) {
                		this.makeSelection({
                			selItem: this.dnd.initD.td
                		});
                	}
                }
            }
    );
    mstrmojo.Slider.SINGLE_HANDLE_WIDTH = 11;
    mstrmojo.Slider.SCROLLHANDLEWIDTH = 11;

})();


(function(){

    mstrmojo.requiresCls("mstrmojo.dom",
        "mstrmojo.Widget",
                         "mstrmojo.tooltip",
                         "mstrmojo.string",
                         "mstrmojo.array");

    
    var mapIdx = 0,
        $ARR = mstrmojo.array,
        $STR = mstrmojo.string;
    
    
    function configureDisplay() {
        var tn = this.textNode,
            img = this.imgNode;
        
        
        if (this.eg != null) {
            
            img.style.display = 'none';
            
            
            tn.innerHTML = this.eg || '';
            
            
            tn.style.display = 'block';
            
        } else {
            
            tn.style.display = 'none';
            
            
            img.style.display = 'block';
            
            
            if (this.tooltip) {
                img.setAttribute("ttl", this.tooltip);
            }
            
            
            var fmts = this.getFormats();
            this.retrieveGraphSrc(fmts.height, fmts.width);
        }
    }
    
    
    var areaShapeMap = {
        6: 'poly',
        7: 'rect',
        100: 'circle'
    };

    
    function generateImageMap() {
        
        var areaData = this.as,
            len = areaData && areaData.length;

        
        if (!len) {
            
            return;
        }

        var widgetId = this.id,
            mapId = widgetId + '_map' + mapIdx++,
            buf = [],                               
            x = -1,                                 
            i;                                      
        
        
        for (i = 0; i < len; i++) {
            
            var area = areaData[i];
            
            
            area.id = widgetId;                                                 
            area.aid = i;                                                       
            area.tooltip = $STR.multiReplace(area.tooltip || '', {              
                '&#13': '<br />',
                '&#32': ' '
            });

            
            if (!isNaN(area.shape)) {
                
                area.shape = this.getAreaShapeName(area.shape);
            }

            
            if (area.tks || area.tks === '' || area.tty === 1) {
                
                area.extra = ' href="#" ';
            }

            
            buf[++x] = $STR.apply(this.areaMarkup, area);
        }

        
        var mapMarkup = '<map id="' + mapId + '" name="' + mapId + '">' + buf.join('') + '</map>';

        
        if (!this.domNode) {
            
            this.att = 'usemap="#' + mapId + '" ';
            this.map = mapMarkup;
        } else {
            
            
            
            var newMap = document.createElement("div");
            newMap.innerHTML = mapMarkup;

            if (this.mapNode) {
                newMap = newMap.firstChild;
                this.mapNode.innerHTML = newMap.innerHTML; 
            } else {
                this.imgNode.setAttribute("usemap", '#' + mapId);
                this.mapNode = this.domNode.appendChild(newMap.firstChild);            
            } 
        }
    }
    
    
    var graphBase = mstrmojo.GraphBase = mstrmojo.declare(
        
        mstrmojo.Widget,
        
        
        null,
        
        
        {
            scriptClass: "mstrmojo.GraphBase",
            
            cssClassPrefix: "mstrmojo-GraphBase",
            
            markupString: '<div id="{@id}" class="{@cssClassPrefix} {@cssClass}" title="{@tooltip}" style="{@domNodeCssText};">' +
                              '<div class="{@cssClassPrefix}-txt"></div>' +
                              '<img {@att}src="../images/1ptrans.gif" class="{@cssClassPrefix} {@cssImageClass}"/>' +
                              '{@map}' +
                          '</div>',
                          
            
            att: '',
            
            
            map: '',
            
            
            cAreaIdx: -1, 
            
            
            useRichTooltip: true,
            
            markupSlots: {
                imgNode: function(){ return this.domNode.childNodes[1]; },
                mapNode: function() {return this.domNode.childNodes.length > 2 ? this.domNode.childNodes[2] : null;},
                textNode: function() { return this.domNode.firstChild; }
            },
        
            markupMethods: {
                onvisibleChange: function(){ this.domNode.style.display = (this.visible) ? 'block' : 'none'; }
            },
            
            preBuildRendering: function preBuildRendering() {
                
                generateImageMap.call(this);

                return this._super();
            },

            postBuildRendering: function postBuildRendering() {
                
                configureDisplay.call(this);
                
                
                return this._super();
            },
            
            setModel: function setModel(model) {
                this.model = model;
            },
            
            
            updatingTooltipHelper: function updatingTooltipHelper(elem, ep, useGivenCoords) {
                var aid = elem && elem.getAttribute('aid'),
                    ttl = elem && elem.getAttribute('ttl'),
                    borderColor = elem.getAttribute('SC'),
                    ttN = {
                            refNode : this.domNode,
                            posType: mstrmojo.tooltip.POS_BOTTOMLEFT,
                            contentNodeCssClass: 'gp-tooltip'
                        },
                    zoom = (this.model.zf || 1) + 'em';
                
                
                if (aid == this.cAreaIdx) {
                    
                    return;
                }
                
                
                this.cAreaIdx = aid;
                
                
                ttN.content = ttl;
                var cssText = 'font-size:' + zoom + ';';

                
                if (borderColor) { 
                    cssText += 'border-color:#' + borderColor;
                }

                ttN.contentNodeCssText = cssText;
                
                
                var c = elem.getAttribute("coords"),
                    x = 99999,
                    y = 99999;
    
                if (!useGivenCoords) { 
                if (c && c.length > 0) {
                    c = c.split(",");
                    
                    var i = 0;
                    while (i + 1 < c.length) {
                        x = Math.min(x, parseInt(c[i++], 10));
                        y = Math.min(y, parseInt(c[i++], 10));
                    }
                }                    
                }

                if (x === 99999) {
                    x = ep.x;
                }
                if (y === 99999) {
                    y = ep.y;
                }
                
                
                ttN.top = y;
                ttN.left = x;
                
                this.richTooltip = null;
                
                this.set('richTooltip', ttN);
            },
            
            
            refresh: function refresh() {
                
                if (!this.hasRendered) {
                    
                    return;
                }

                
                configureDisplay.call(this);

                
                var f = this.getFormats();
                if (f.height && f.width) {
                    
                    this.refreshMap();
                }
            },

            
            refreshMap: function refreshMap() {
                
                generateImageMap.call(this);
            },

            
            getAreaShapeName: function getAreaShapeName(shapeType) {
                return areaShapeMap[parseInt(shapeType, 10)] || 'default';
            }
        }
    );

    var tooltipCls = graphBase.tooltipCLS = "mstrmojo-mobileGraph-Tooltip-content",
        canvasCls = graphBase.canvasCLS = "mobile-graph-highlight-canvas";

    graphBase.hideTooltips = function () {
        
        $ARR.forEach(document.getElementsByClassName(tooltipCls), function (tooltip) {
            tooltip.style.display = 'none';
        });

        
        $ARR.forEach(document.getElementsByClassName(canvasCls), function (canvas) {
            canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
            canvas.width = canvas.width;
        });
    };

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._FillsBrowser",
                         "mstrmojo._HasLayout",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.Box",
                         "mstrmojo.Label",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $CSS = mstrmojo.css;

    mstrmojo.requiresDescs(2901, 8445);

    
    function updateRootOrientationClass() {
        
        var add = 'rootPortrait',
            remove = 'rootLandscape',
            node = this.domNode;

        
        if (mstrApp.isLandscape()) {
            
            var x = add;
            add = remove;
            remove = x;
        }

        
        $CSS.removeClass(node, remove);
        $CSS.addClass(node, add);
    }

    
    mstrmojo.android.ui.RootView = mstrmojo.declare(
        mstrmojo.Container,

        [ mstrmojo._FillsBrowser, mstrmojo._HasLayout, mstrmojo._TouchGestures ],

        
        {
            scriptClass: 'mstrmojo.android.ui.RootView',

            markupString: '<div id="{@id}" class="mstrmojo-RootView {@cssClass}" style="{@cssText}" >' +
                              '<div class="mstrmojo-RootView-title"></div>' +
                              '<div class="mstrmojo-RootView-content"></div>' +
                          '</div>',

            markupSlots: {
                titleNode: function () { return this.domNode.firstChild; },
                containerNode: function () { return this.domNode.lastChild; }
            },

            markupMethods: {
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod
            },           

            layoutConfig: {
                h: {
                    titleNode: 'auto',
                    containerNode: '100%'
                },
                w: {
                    titleNode: '100%',
                    containerNode: '100%'
                }
            },

            preBuildRendering: function preBuildRendering() {
                
                $CSS.addClass(document.body, 'dpi' + mstrMobileApp.getDeviceDPI());

                
                if (!this.msgBox) {
                    
                    var msgBox = this.msgBox = new mstrmojo.Box({
                        placeholder: 'mainAppMsg',                     
                        cssClass: 'mstrmojo-RootViewMessage',
                        cssText: 'left:-10000px;',
                        children: [{
                            scriptClass: 'mstrmojo.Label',
                            alias: 'lbl',
                            text: mstrmojo.desc(2901, 'Loading...')
                        }]
                    });

                    
                    msgBox.render();
                }

                
                var viewFactory = mstrApp.viewFactory;
                this.addChildren([ viewFactory.newView('ActionBar', {
                    slot: 'titleNode',
                    alias: 'actionBar',
                    controller: mstrmojo.all[this.controllerId]
                }), viewFactory.newView('Switcher', {
                    slot: 'containerNode',
                    alias: 'switcher'
                })]);

                return this._super();
            },

            postBuildRendering: function postBuildRendering() {
                updateRootOrientationClass.call(this);

                
                var titleNode = this.titleNode;
                if(!this._tchHandler) {
                	this._tchHandler = mstrmojo.touchManager.attachEventListener('actionBarMenuStateChange', this.id, function (evt) {
                		if(evt.value) {
                			$CSS.addClass(titleNode, 'top');
                		} else {
                			$CSS.removeClass(titleNode, 'top');
                		}
                	});
                }
                
                return this._super();
            },

            unrender: function unrender(ignoreDom) {
            	
            	if(this._tchHandler) {
            		mstrmojo.touchManager.detachEventListener(this._tchHandler);
            		delete this._tchHandler;
            	}
            	this._super(ignoreDom);
            },
            
            
            setNavigation: function setNavigation(navItems, idx) {
                
                this.actionBar.setNavigation(navItems, idx);
            },
            
            getTitleHeight: function getTitleHeight() {
                return this.titleNode.offsetHeight;
            },


            
            clearNavigation: function clearNavigation() {
                
                this.actionBar.clearNavigation();
            },

            
            restoreNavigation: function restoreNavigation() {
                
                this.actionBar.restoreNavigation();
            },

            selectNavigationItem: function selectNavigationItem(navItem) {
                
                return this.actionBar.selectNavigationItem(navItem);
            },

            hasNavigationItems: function hasNavigationItems() {
            	return this.actionBar.getNavList().items.length > 0;
            },

            
            reset: function reset() {
                this.actionBar.reset();
            },

            
            setContent: function setContent(view, isBack) {
                
                this.reset();

                
                this.switcher.switchView(view, isBack);
            },

            
            contentUpdated: function contentUpdated() {
                
                this.reset();
            },

            
            setTitle: function setTitle(text) {
                this.actionBar.updateTitle(text);
            },

            
            setActionToolbar: function setActionToolbar(id, tbCfg) {
                this.actionBar.updateToolbar(id, tbCfg);
            },

            
            setActionToolbarStatus: function setActionToolbarStatus(isActive) {
                this.actionBar.setActionToolbarStatus(isActive);
            },

            setUpStatus: function setUpStatus(isActive) {
                this.actionBar.setUpStatus(isActive);
            },

            
            updateLastOpened: function updateLastOpened(items) {
                this.actionBar.setLastOpened(items);
            },

            
            monitorWindow: function monitorWindow() {
                
                var dimensions = mstrApp.getScreenDimensions();

                
                
                this._super({
                    currentTarget: {
                        innerWidth: dimensions.w,
                        innerHeight: dimensions.h
                    }
                });

                
                updateRootOrientationClass.call(this);

                
                mstrmojo.all[this.controllerId].set('orientation', (mstrMobileApp.getOrientation() === mstrmojo.android.EnumOrientationTypes.PORTRAIT) ? 1 : 0);

                
                window.setTimeout(function () {
                    mstrMobileApp.setWaitScreenVisibility(false);
                }, 0);
            },

            
            setDimensions: function setDimensions(h, w) {
                this._super(h, w);

                
                var msgBox = this.msgBox;
                msgBox.set('height', this.height);
                msgBox.set('width', this.width);
            },

            
            getBrowserDimensions: function () {
                var dimensions = mstrApp.getScreenDimensions(),
                    px = 'px';

                return {
                    h: dimensions.h + px,
                    w: dimensions.w + px
                };
            },

            
            getContentDimensions: function getContentDimensions() {
                var containerNode = this.containerNode;
                return {
                    h: containerNode.clientHeight,
                    w: containerNode.clientWidth
                };
            },

            
            showMessage: function showMessage(text) {
                mstrMobileApp.showProgress([ text || mstrmojo.desc(8445, 'Loading') ], false );
            },

            
            showHTMLProgress: function showHTMLProgress(text) {
                var loadingCurtain = this.msgBox,
                    loadingCurtainStyle = loadingCurtain.domNode.style,
                    loadingLabel = loadingCurtain.lbl,
                    lblNode = loadingLabel.domNode,
                    lblNodeStyle = lblNode.style;

                
                loadingLabel.set('text', text || mstrmojo.desc(2901, 'Loading...'));

                
                lblNodeStyle.left = Math.round(parseInt(this.width, 10) / 2 - lblNode.offsetWidth / 2) + 'px';
                lblNodeStyle.top = Math.round(parseInt(this.height, 10) / 2 - lblNode.offsetHeight / 2) + 'px';

                
                loadingCurtainStyle.left = 0;
                loadingCurtainStyle.top = 0;

                
                $CSS.addClass(loadingCurtain.domNode, 'active');

                
                loadingCurtainStyle.opacity = 1;
            },

            
            hideMessage: function hideMessage() {
                mstrMobileApp.hideProgress();
            },

            
            hideHTMLProgress: function hideHTMLProgress() {
                var loadingCurtain = this.msgBox.domNode,
                    loadingCurtainStyle = loadingCurtain.style;

                
                loadingCurtainStyle.opacity = 0;

                
                loadingCurtainStyle.left = '-10000px';

                
                $CSS.removeClass(loadingCurtain, 'active');
            },

            enterFullScreen: function enterFullScreen() {
                this.actionBar.enterFullScreen();
            },

            flashFullScreen: function flashFullScreen() {
                this.actionBar.flashFullScreen();
            },

            exitFullScreen: function exitFullScreen(animate) {
                this.actionBar.exitFullScreen(animate);
            },

            cancelFlashFullScreen: function cancelFlashFullScreen() {
                return this.actionBar.cancelFlashFullScreen();
            },
            
            propogateMenuVisibleChange: function propogateMenuVisibleChange(isVisible) {            	
            	this.actionBar.propogateMenuVisibleChange(isVisible);
            }
        }
    );
}());
(function() {
    
    mstrmojo.requiresCls("mstrmojo.Box", "mstrmojo._HasLayout");
    
    
    mstrmojo.Overlay = mstrmojo.declare(
        mstrmojo.Box,
        [mstrmojo._HasLayout],
        {
            markupMethods: {
                onvisibleChange: function(){ this.domNode.style.display = this.visible? 'block' : 'none'; },
                onheightChange: function() { this.domNode.style.height = this.height ? this.height : ''; },
                onwidthChange: function() { this.domNode.style.width = this.width ? this.width: ''; }
            },
            
            layoutConfig: {
                h: {
                    containerNode: '100%'
                },
                w: {
                    containerNode: '100%'
                }
            },
            
            scriptClass: "mstrmojo.Overlay"
        }
    );
    
})();
(function(){
    mstrmojo.requiresCls('mstrmojo.Box', 
            'mstrmojo.ListBase', 
            'mstrmojo._IsList');
    
    var DELIM = ',';
    
    
    
    mstrmojo.TableLayoutList = mstrmojo.declare (

        mstrmojo.ListBase,
        
        [mstrmojo._IsList],
        
        {
            scriptClass: 'mstrmojo.TableLayoutList',
            
            cssClass: 'mstrmojo-TableLayoutList',
            
            styleCssClass: '',
            
            itemIdField: 'v',
            
            allowUnlistedValues: false,
            
            tableLayoutCssStyle: 'auto',
            
            multiSelect: false,
            
            titleItems: null,
            
            
            items: null,
            
            
            itemsPerRow: 0,
            
            
            getLeftEndTitle: function getLeftEndTitle(idx) {
                return '';
            },
            
                        
            getRightEndTitle: function getRightEndTitle(idx) {
                return '';
            },
            
            getTitleRowMarkup: function getTitleRowMarkup() {
                var titleItems = this.titleItems;
                if (titleItems) {
                    var _tr = '<tr><td class="left_text">' + this.getLeftEndTitle(-1) + '</td>',
                        len = titleItems.length,
                        i = 0,
                        t;
                    for (; i < len; i++) {
                        t = titleItems[i];
                        _tr += '<td class="item_title" title="' + t + '">' + t + '</td>';
                    }
                    _tr += '<td class="left_text">' + this.getRightEndTitle(-1) + '</td></tr>';
                    return _tr;
                }
                return '';
            },
            
            _markupPrefix: function() {
                
                
                return '<table class="tableLayoutList" style="table-layout:' + this.tableLayoutCssStyle + '" cellspacing="0" cellpadding="0"><tbody>' + this.getTitleRowMarkup();
            },
            
            _markupSuffix: function() {
                return  '</tbody></table>';
            },
            
            getItemMarkup: function(item, idx) {
                var markup = '<{@tag} class="item {@cls}" idx="{@idx}" title="{@n}" style="{@style}">{@n}</{@tag}>',
                lt = this.getLeftEndTitle(idx),
                rt = this.getRightEndTitle(idx),
                ipr = this.itemsPerRow;

                lt = '<td class="left_text" title="' + lt + '">' + lt + '</id>',
                rt = '<td class="right_text" title="' + rt + '">' + rt + '</id>',
                ipr = this.itemsPerRow;

                if (ipr > 0) {
                    
                    
                    markup = (idx % ipr === 0 ? '<tr>' + lt : '') + '<td>' + markup + '</td>' + ((idx + 1) % ipr === 0 ? rt + '</tr>' : '');
                } else {
                    markup = '<td><div class="item_wrapper" idx="' + idx + '">' + markup + '</div></td>';
                    if (!idx) {
                        markup = '<tr>' + lt + markup;
                    } else if (idx === this.items.length - 1) {
                        markup = markup + rt + '</tr>';
                    }
                }
                return markup;
            },
            
            _getItemNode: function(idx) {
                var itemsTableNode = this.itemsNode,
                    ipr = this.itemsPerRow,
                    rowIdx = (this.titleItems ? 1 : 0) + ((ipr > 0) ? parseInt(idx/ipr, 10) : 0),
                    colIdx = 1 + ((ipr > 0) ? (idx%ipr) : idx);

                
                return itemsTableNode.rows[rowIdx].cells[colIdx].firstChild;
            },            
            
            init: function(props) {
                this._super(props);
                mstrmojo.css.addWidgetCssClass(this, this.styleCssClass);
            },
            
            onchange: function onchange(){
                var newValue, s = [];
                
                
                if (!this.multiSelect){
                    newValue = this.selectedItem.v;
                
                }else{
                    for (var i in this.selectedIndices) {
                        s.push(this.items[i].v);
                    }
                    newValue = s.join(this.delim || DELIM);
                }
                this.set('value', newValue);
            },
            
            postBuildRendering: function postBuildRendering() {
                this._super();
                
                
                var selItems = [];
                if (this.multiSelect){
                    var vs = this.value.split(DELIM);
                    
                    for (var i = 0; i < vs.length; i++){
                        selItems.push({v: vs[i]});
                    }
                }else{
                    selItems.push({v: this.value});
                }
                
                this.setSelectedItems(selItems);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Popup",
                         "mstrmojo._HasBuilder",
                         "mstrmojo._IsAnchorable",
                         "mstrmojo.dom");

    var BASE_TIP_CLS = 'mstrmojo-DocInfoWindow-tip',
        DARK_BORDER_WIDTH = 1,
        $D = mstrmojo.dom;

    function _toggleLockInfoWins(anchor, lock) {
        
        var w = $D.findWidget(anchor) || (anchor && anchor.w);

        
        while (w) {
            if (w.autoCloseLocked !== undefined) {
                w.autoCloseLocked = lock;
            }

            w = w.parent;
        }
    }

    function _getContent(me) {
        var m = me.model;
        return m.getLayoutDataCache(m.getCurrentLayoutKey())[me.psId]
    }

    mstrmojo.DocInfoWindow = mstrmojo.declare(
        
        mstrmojo.Popup,

        
        [ mstrmojo._HasBuilder, mstrmojo._IsAnchorable ],

        
        {
            scriptClass: "mstrmojo.DocInfoWindow",

            markupString: '<div class="mstrmojo-DocInfoWindow-wrapper">' +
                              '<div id="{@id}" class="mstrmojo-DocInfoWindow"></div>' +
                              '<div class="' + BASE_TIP_CLS + ' top"></div>' +
                              '<div class="mstrmojo-DocInfoWindow-curtain" mstrAttach:click></div>' +
                          '</div>',

            markupSlots: {
                infoNode: function () { return this.domNode.firstChild; },
                tipNode: function () { return this.domNode.childNodes[1]; },
                curtainNode: function () { return this.domNode.lastChild; },
                containerNode: function () { return this.domNode.firstChild; }
            },

            boundaryNodeName : "boundary",

            popupNodeName : 'infoNode',

            baseTipClass : BASE_TIP_CLS,

            anchorOffset : 1,

            anchorOrientation : 'h',

            anchor: null,

            boundary: null,

            closeOnClick : true,

            autoCloseLocked: false,

            tipNodeColor: '',

            ontouchstart: function ontouchstart() {
                this.close();
            },

            close: function close(){
                
                if (this.autoCloseLocked)
                    return;

                
                
                
                this.model.raiseEvent({
                    name: 'infoWindowClosed',
                    psKey:this.psKey
                });

                
                var me = this;
                window.setTimeout(function () {
                    if (me.anchor) _toggleLockInfoWins(me.anchor, false);
                }, 0);

                if(this._super){
                    this._super();
                }

                
                this.clearAnchorHilites();

                $D.detachEvent(document, $D.isFF ? 'DOMMouseScroll' : 'mousewheel', this.mw);
                $D.attachEvent(document, 'scroll', me.mw);
            },

            clearAnchorHilites: function clearAnchorHilites() {
                var zn = mstrmojo.dom.findWidget(this.anchor);
                if(zn && zn.clearHilites) {
                    zn.clearHilites(zn.hiliteKey);
                    delete zn.hiliteKey;
                }
            },

            prepareAnchor: function prepareAnchor() {
                if(this.children && this.children[0]) {
                var infoNodeStyle = this.infoNode.style,
                    contentChild = this.children[0],
                    contentChildNode = contentChild.dimNode || contentChild.domNode,
                    ifwWidth = contentChildNode.offsetWidth,
                    ifwHeight = contentChildNode.offsetHeight;

                
                infoNodeStyle.width = (ifwWidth + 2 * DARK_BORDER_WIDTH) + 'px';
                infoNodeStyle.height = (ifwHeight + 2 * DARK_BORDER_WIDTH) + 'px';
                }
            },

            nudge: function nudge() {
                this.positionDialog();
                this.model.raiseEvent({name: 'infoWindowRendered',
                                       id: this.id   
                                      });
            },

            onRender: function onRender() {
                this.open(this.opener);
            },

            
            open: function open(opener, config) {
                
                var ps = mstrmojo.all[this.psId];

                
                if (ps) {
                    var showFirstPanel = ps.defn.sfp,
                        currentPanelIdx = ps.selectedIdx;

                    
                    
                    if (showFirstPanel && currentPanelIdx !== 0) {
                        
                        ps.switchToPanel(0, 0);

                        
                        ps.children[currentPanelIdx].set('selected', false);
                    }
                }

                
                if (this._super) {
                    this._super(opener, config);
                }

                
                if (this.anchor) _toggleLockInfoWins(this.anchor, true);

                
                if(mstrApp.isTablet && mstrApp.isTablet()) {
                    var touchManager = mstrmojo.touchManager,
                        id = this.id,
                        infoWindowNode = this.domNode;
                    this._tchHandler = touchManager.attachEventListener('touchesBegin', id, function (evt) {

                        
                        if(this.autoCloseLocked) {
                            return;
                        }

                        
                        var isTappingOnInfoWindow = mstrmojo.dom.contains(infoWindowNode, evt.touch.target, true);

                        
                        var infoboxes = document.getElementsByClassName('heatmap-infobox'),
                            len = (infoboxes && infoboxes.length) || 0,
                            i,
                            target = evt.touch.target,
                            isTappingOnHeatMapTooltip = false;
                        for(i = 0; i < len; i++) {
                            if(mstrmojo.dom.contains(infoboxes[i], target, true)){
                                isTappingOnHeatMapTooltip = true;
                                break;
                            }
                        }

                        if (!isTappingOnInfoWindow && !mstrApp.hasOpenDialog() && !isTappingOnHeatMapTooltip) { 
                            this.closeOnTablet();
                        }
                    });
                }

                
                var me = this;
                me.mw = me.mw || function(e) {
                	
                    if (me.autoCloses &&
                    		!$D.contains(me.domNode, $D.eventTarget(self, e), true, document.body)) {
                        me.close();
                    }
                };
                $D.attachEvent(document, $D.isFF ? 'DOMMouseScroll' : 'mousewheel', me.mw);
                $D.attachEvent(document, 'scroll', me.mw);
            },


            getChildren: function getChildren() {
                return [_getContent(this)];
            },

            preBuildRendering: function preBuildRendering() {
                var c = _getContent(this),
                    f = c.defn.fmts;

                
                f.left = DARK_BORDER_WIDTH + 'px';
                f.top = DARK_BORDER_WIDTH + 'px';


                if (f.border) { 
                    var tmp = f.border.split(' ');
                    if (tmp.length >= 3) {
                        this.tipNodeColor = tmp[2];
                    }
                }

                if (this._super) this._super();
            },

            postBuildRendering: function postBuildRendering() {
                
                
                this.set('visible', true);

                if (this._super) this._super();

                
                
                if (!this.closeOnClick) {
                    this.curtainNode.style.display = 'none';
                }
            },

            
            closeOnTablet: function closeOnTablet() {
                this.close();
                if (this._tchHandler) {
                    this._tchHandler.clear();
                }
            }
        }
    );

    var factory = mstrmojo.DocInfoWindow;
    factory.PLACEMENT = {
        AUTO: 1,
        FIXED: 2,
        ABOVE: 3,
        BELOW: 4,
        LEFT: 5,
        RIGHT: 6
    };

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo.DocTextfield");


    var $DOM = mstrmojo.dom,
        $CSS = mstrmojo.css,

        DPST_CAPTION_ONLY = 1,
        DPST_ICON_ONLY = 2,
        DPST_ICON_LEFT = 3,
        DPST_ICON_RIGHT = 4,
        DPST_ICON_TOP = 5,
        DPST_CUSTOM = 6,

        FE_GLOSSY = 1,
        dpstCssClass = [ '', 'CaptionOnly', 'IconOnly', 'IconLeft', 'IconRight', 'IconTop', 'Custom' ];
    
    
    var btnCfg = [];
    btnCfg[DPST_CAPTION_ONLY] = btnCfg[DPST_ICON_ONLY] = btnCfg[DPST_CUSTOM] = {
        minsp: 0,
        mincs: 0
    };
    
    btnCfg[DPST_ICON_LEFT] = btnCfg[DPST_ICON_RIGHT] = {
        minsp: 10,
        mincs: 5
    };
    
    btnCfg[DPST_ICON_TOP] = {
        minsp: 4,
        mincs: 5
    };

    
    function centerAlign(e, isH, isV, innerBox, cutoff) {
        var pos = $DOM.position(e),                     
            ppos = $DOM.position(e.parentElement),      
            es = e.style;
        innerBox = innerBox || {};
        innerBox = {'t':innerBox.t||0, 'r':innerBox.r||0, 'b':innerBox.b||0, 'l':innerBox.l||0};    
        innerBox.h = ppos.h-innerBox.t-innerBox.b;      
        innerBox.w = ppos.w-innerBox.l-innerBox.r;      
        if (cutoff) {
            if (pos.h > innerBox.h) es.height = innerBox.h + 'px';
            if (pos.w > innerBox.w) es.width  = innerBox.w + 'px';
            pos = $DOM.position(e);                     
        }
        if (isH) {
            es.top = ((innerBox.h - pos.h)/2 + innerBox.t) + 'px';
        }
        if (isV) {
            es.left = ((innerBox.w - pos.w)/2 + innerBox.l) + 'px';
        }
    }

    
    function appendAndCentralizeImg(e, src, className) {
        var img = document.createElement('img'),
            imgsty = img.style;
        e.appendChild(img);
        $DOM.attachEvent(img, 'load', function () {
            var disp = imgsty.display;
            imgsty.display = 'block'; 
            centerAlign(img, true, true);
            imgsty.display = disp;
        }, true);
        img.className = className;
        img.src = src;
    }   

    
    mstrmojo.DocButton = mstrmojo.declare(
        
        mstrmojo.DocTextfield,

        
        null,

        
        {
            scriptClass: "mstrmojo.DocButton",

            pressed: false,

            markupString: '<div id="{@id}" class="mstrmojo-DocButton {@cssClass}" title="{@tooltip}" style="{@domNodeCssText}">' +
                              '<div class="mstrmojo-DocButton-Container" mstrAttach:click,mousedown>' +
                                  '<div class="mstrmojo-DocButton-IconNode"></div>' +
                                  '<div class="mstrmojo-DocButton-ValueNode" style="{@valueNodeCssText}">{@v}</div>' +
                              '</div>' +
                              '<div class="mstrmojo-DocButton-EffectOverlay"></div>' +
                              '{@buttonNodeMarkup}' +
                          '</div>',

            markupSlots: {
                iconNode: function () { return this.domNode.firstChild.firstChild; },
                valueNode: function () { return this.domNode.firstChild.lastChild; },
                buttonContainerNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onpressedChange: function () {
                    var isPressed = !!this.pressed,
                        defn = this.defn,
                        domNode = this.domNode,
                        fmts = this.fmts;

                    
                    $CSS.toggleClass(domNode, 'pressed', isPressed);

                    
                    this.setBackgroundColor();
                    this.valueNode.style.color = isPressed ? defn.fhlc : (fmts.color || '');
                },
				onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },

            formatHandlers: {
                domNode:  [ 'T', 'z-index', 'D', 'B', 'P', 'background-color' ],
                valueNode: [ 'font', 'fx', 'color', 'white-space', 'overflow' ]
            },
            
            setBackgroundColor: function setBackgroundColor() {

                this.domNode.style.backgroundColor = (!!this.pressed) ? this.defn.bhlc : (this.fmts['background-color'] || '');
            },

            
            getAnchor: function getAnchor() {
                return this.domNode;
            },

            getDPI: function getDPI() {        
                return this.model.dpi;
            }, 
            
            buildRendering: function buildRendering() {
                this._super();

                var defn = this.defn,
                    dm = this.domNode,
                    bc = this.buttonContainerNode,
                    ic = this.iconNode,
                    vl = this.valueNode,
                    dpst = parseInt((defn && defn.dpst) || 1, 10),    
                    px = 'px';

                $CSS.toggleClass(dm, dpstCssClass[dpst], true);

                
                
                dm.onselectstart = dm.ondragstart = function () {
                    return false;
                };

                var fmts = this.getFormats(),
                    innerBorderWidth = parseInt($CSS.getComputedStyle(bc).borderWidth, 10) * 2;     

                
                if (isNaN(innerBorderWidth)) {
                    
                    innerBorderWidth = 0;
                }
                    
                var w = parseFloat(fmts.width) - innerBorderWidth,    
                    h = parseFloat(fmts.height) - innerBorderWidth,   
                    cfg = btnCfg[dpst],
                    minsp = cfg.minsp,             
                    mincs = cfg.mincs,             
                    icsize,                        
                    ics = ic.style,                
                    vls = vl.style;                

                function setIcsize(s) {            
                    ics.height = ics.width = s + px;
                }

                
                var buttonContainerNodeStyle = bc.style;
                buttonContainerNodeStyle.height = h + px;
                buttonContainerNodeStyle.width = w + px;

                switch (dpst) {
                case DPST_ICON_TOP:
                    var dpi = this.getDPI(),
                        outerHeight = h + $CSS.getBorderWidths(fmts['border-width'], dpi).h + $CSS.getPaddings(fmts.padding, dpi).h;
                    icsize = Math.max(0, Math.min(w, h - minsp - mincs, outerHeight * 0.6)); 
                    setIcsize(icsize);
                    centerAlign(ic, false, true);
                    centerAlign(vl, true, false, {'t':icsize+minsp}, true);
                    break;

                case DPST_ICON_LEFT:
                case DPST_ICON_RIGHT:
                    icsize = Math.max(0, Math.min(h, w - minsp - mincs));
                    setIcsize(icsize);
                    centerAlign(ic, true, false);
                    vls[(dpst === DPST_ICON_LEFT) ? 'left' : 'right'] = (icsize + minsp) + px;
                    centerAlign(vl, true, false);
                    break;

                case DPST_CAPTION_ONLY:
                    centerAlign(vl, true, false);
                    break;

                case DPST_ICON_ONLY:
                case DPST_CUSTOM:
                    
                    break;
                }

                if (FE_GLOSSY === parseInt(defn.fe, 10)) {
                    $CSS.addClass(dm, 'gloss');
                }

                
                appendAndCentralizeImg(ic, defn.nmurl, 'normal');
                appendAndCentralizeImg(ic, defn.hlurl || defn.nmurl, 'hilight');

                
                var icMaskNode = document.createElement('div');
                $CSS.addClass(icMaskNode, 'mstrmojo-DocButton-IconMaskNode');
                ic.appendChild(icMaskNode);
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.DocXtabModel",
                         "mstrmojo.array",
                         "mstrmojo.func");
    
    var SELECTOR_ACTION = 2;
    var ROW_AXIS = 1,
    COL_AXIS = 2;

    
    mstrmojo.DocVisModel = mstrmojo.declare(
        mstrmojo.DocXtabModel,
        
        null,        
      
        {            
            scriptClass: "mstrmojo.DocVisModel",
            
            getAction: function getAction(cells) {
                var cell = cells[0],
                    actionType = cell && cell.at;

                var action;
                
                if (actionType) {
                    
                    if (actionType & SELECTOR_ACTION) {
                        
                    	action = { 
                            h: 'onVisSelector',
                            a: this.getSelectAction(cell)
                        };       
                    }
                }
                
                
                if ( ! action ) {
                	action = this.getActionObject(cells);
                }
               
                return action;
            },
            
            getSelectAction: function getSelectAction(actionObj){
				var scObjList = actionObj.scObjList,
	        		scObjListLength = scObjList.length,
	        		action = null;
	        		
	        	if(scObjListLength > 1){
	        		
	        		action = { 
						multiSelect: true,
						type: mstrmojo.EnumRWUnitType.GRID,
						src: actionObj.k,						
						sliceId: 1,
						sid:1,
						anchor: actionObj.anchor,
						selectorObjects: []
					};
					
	        		
	        		var scTks = {};
	        		var strTks = '';
	        		for(var i = 0; i < scObjListLength; i++){
	        			var scObj = scObjList[i];
	        			
	        			
	        			var tksList = scObj.sc.tks.split("\x1E");
	        			for(var j = 0; j < tksList.length; j++){
	        				var target = tksList[j];
	        				if(!scTks[target]){
	        					scTks[target] = true;
	        					if(strTks.length > 0){
	        						
	        						strTks = strTks + '\x1E'+target;
	        					}else{
	        						strTks = target;
	        					}
	        					
	        				}
	        			}
	        				
	        		}
	        		
					for (var i = 0; i < scObjListLength; i++) {
						var scObj = scObjList[i];
						action.selectorObjects.push({ 
							ck: scObj.sc.ck,
							ctlKey: scObj.sc.ckey,
							tks: scObj.sc.tks,
							eid: scObj.eid
						});
					}
				
					if(!action.tks)
						action.tks = strTks;
					
	        	}else if(scObjListLength == 1){
	        		var scObj = scObjList[0];
	        		action = { 
						type: mstrmojo.EnumRWUnitType.GRID,
						src: actionObj.k,						
						sliceId: 1,
						sid:1,
						ck: scObj.sc.ck,
						ctlKey: scObj.sc.ckey,
						tks: scObj.sc.tks,
						eid: scObj.eid,
						anchor: actionObj.anchor
					};
	        	}
	            
	            return action;

			},
			
			getLinkAction: function getLinkAction(actionObj, idx) {
				var node = actionObj.node,
					title = node && node.titleInfo;    		
                
                return this.getLinkActionImpl(node, title, idx);
            },
            
            getPCellParentNode: function getPCellParentNode(pCell, axis){            	
            	return ( axis == ROW_AXIS ) ? pCell._lp : pCell._tp;
            },
            
            getPTitle: function getPTitle(pCell, axis){
            	return pCell.titleInfo;
            }
        }
    );
})();
(function(){
    
    mstrmojo.requiresCls(
            "mstrmojo.css",
            "mstrmojo.array",
            "mstrmojo.dom",
            "mstrmojo._TouchGestures",
            "mstrmojo.SmoothScroll",
            "mstrmojo._HasTouchScroller"
    );
    
    var PAD_STEP = 16; 
    
    
    
    var NODE_STATE_TEXT_MAP = {
        0: "&#9654;", 
        1: "&#9660;",  
        2: "&nbsp;" 
    }; 
    
    var NODE_STATE_CSS_MAP = ["heatmap-tree-state-text collapsed", "heatmap-tree-state-text expanded", "heatmap-tree-state-text leaf"];
    
    var SELECTION_STATUS = {
    	NO: 0,
    	YES: 1,
    	PART: 2
    };
    
    
    
    mstrmojo.VisHeatMapTreeItem = mstrmojo.declare(
        
    	mstrmojo.Container, 
        
        null,
        {
            scriptClass:'mstrmojo.VisHeatMapTreeItem',
            
            
            isRoot: false,
            
            
            showRoot: false,
            
            
            rootText: "",
            
            
            idx: 0,
            
            
            buttonNodeCss: "heatmap-tree-checkbox",
            
            
            buttonNodeWidget: null,
            
            
            
            markupString: '<div id="{@id}" class="heatmap-tree" style="{@cssText}">'
                            + '<div class="heatmap-tree-div" idx="{@idx}">'
                            	+ '<div class="heatmap-tree-state">' 
                            		+ '<div class="heatmap-tree-state space">&nbsp;</div>'
                            		+ '<div class="heatmap-tree-state-text"></div>'
                            	+ '</div>'
                            	+ '<div class="heatmap-tree-text"></div>'
                            	+ '<div class="{@buttonNodeCss}">&nbsp;</div>'
                            + '</div>'
                            + '<div class="heatmap-tree-container"></div>'
                            + '</div>',
            
            
            markupSlots: {
                contentNode: function(){return this.domNode.firstChild;},
                stateNode: function(){return this.domNode.firstChild.firstChild;},
                stateSpaceNode: function(){return this.domNode.firstChild.firstChild.firstChild;},
                stateTextNode: function(){return this.domNode.firstChild.firstChild.lastChild;},
                textNode: function(){return this.domNode.firstChild.childNodes[1];},
                buttonNode: function(){return this.domNode.firstChild.childNodes[2];},
                containerNode: function(){return this.domNode.lastChild;}
            },
            
            markupMethods: {
                ontextChange: function(){ this.textNode.innerHTML = this.text;},
                onstateChange: function(){
                    
                	this.stateTextNode.className = NODE_STATE_CSS_MAP[this.state];
                	
                	
                    if (!this.isRoot) {
                    	this.containerNode.style.display = (this.state === 1) ? 'block' : 'none';
                    	if (this.state != 2) {
                    		this.tree.resized();
                    	}
                    }
                }
            },
            
            
            level: -1,
            
            
            tree: null,
            
            
            itemDisplayField: "n",
            
            
            itemChildrenField: "items",
            
            
            isSelectable: true,
            
            
            itemFunctionField: "itemFunction",
            
            
            itemIncludeFunction: function () {return true;}, 
            
            
            dataProvider: null, 
            
            
            owner: null, 

			fillData: function() {
            	var tree = this.tree || this;
            	if (this.dataProvider) {
            		this.items = this.dataProvider[this.itemChildrenField];
            		
            	}
            	var items = this.items;
            	
            	if (this.items && this.items.length) { 
            		this.childTree = [];
					
            		var childIndex = 0; 
                	for (var i = 0; i < items.length; i++) {
                		var item = items[i];
                		if (this.itemIncludeFunction(item)) {
	                		
	                		
							
	                		var text;
	                		if (tree.owner) {
	                			
                                text = item.label;
	                		} else {
	                			text = item[this.itemDisplayField];
	                		}

                            var d = new Date();
                            var t1 = (new Date()).getTime();
	                		

	                		var iw = {
	                				idx: childIndex,
	                				isRoot: false,
	                				text: text,
	                				itemFunction: item[this.itemFunctionField],
	                				buttonNodeWidget: item["buttonNodeWidget"],
	                				tree: tree,
	                				level: (this.level + 1),
	                				itemDisplayField: this.itemDisplayField,
	                                itemChildrenField: this.itemChildrenField,
	                                parent: this,
	                                parentTree: this,
	                                state: 0,
	                                
	                                isSelectable: this.isSelectable,
	                                itemIncludeFunction: this.itemIncludeFunction,
	                                buttonNodeCss: this.buttonNodeCss,
                                    
                                    fillData: this.fillData,
                                    buildTree: this.buildTree,
                                    setChildStatus : this.setChildStatus,
                                    updateSelection : this.updateSelection
                                    
	                			};

                            
	                		
	                		if (this.dataProvider) { 
	                			iw.dataProvider = item;
	                		} else { 
	                			iw.items = item[this.itemChildrenField];
	                		}
	                		this.childTree[childIndex] = iw;
	                		
	                		childIndex++;
                		}
                	}
            	}
				
            
			},
			

            renderChildrenList: function(){
                    if(!this.childTree)
                            return;
                    var len = this.childTree.length,
                        insertIndex,
                        cachedUnits;
                    if(this.tree){
                            cachedUnits = this.tree.cachedUnits;
                            insertIndex = cachedUnits.indexOf(this.contentNode) + 1;
                            if(insertIndex == 0){
                                    insertIndex = cachedUnits.length;
                            }

                    }
                    if(this.isRoot && this.showScrollbars){
                            insertIndex = 0;
                            cachedUnits = this.cachedUnits;
                    }
                    for(var i = 0; i< len; i++){
                            if(this.childTree[i].domNode){
                                    this.tree.cachedUnits.splice(insertIndex, 0, this.childTree[i].contentNode);
                                    insertIndex ++;
                                    continue;
                            }
                            var div = document.createElement('div');
                            this.containerNode.appendChild(div);
                            this.childTree[i].placeholder = div;
                            var treeItem = new mstrmojo.VisHeatMapTreeItem(this.childTree[i]);
                            if(!treeItem)
                                    alert("new failed!");
                            treeItem.childTree = this.childTree[i].childTree;
                            if(treeItem.childTree){
                                    var child = treeItem.childTree,
                                        clen = child.length;
                                    for(var j = 0; j < clen; j++){
                                            child[j].parent = treeItem;
                                            child[j].parentTree = treeItem;
                                    }
                            }

                            this.childTree[i] = treeItem;

                            this.childTree[i].render();

                            if(!isNaN(insertIndex)){
                                    cachedUnits.splice(insertIndex, 0, this.childTree[i].contentNode);
                                    insertIndex ++;
                            }
                    }
            },


            
            postBuildRendering: function () {
            	if(this._super) {
                	this._super();
                }
            	
                
                this.domNode.style.display = 'none';

            	var tree = this.tree || this;
            	if (this.dataProvider) {
            		this.items = this.dataProvider[this.itemChildrenField];
            		
            	}
            	
            	

				
					
            	if (this.isRoot) {
            		if (!this.showRoot) {
            			this.contentNode.style.display = "none";		
            		} else {
            			this.stateNode.style.display = "none";
            			this.textNode.innerHTML = this.rootText;
            		}
            		this.containerNode.className = "heatmap-tree-container root";
            	} else {
	            	if (this.buttonNodeWidget) {
	            		this.buttonNodeWidget.placeholder = this.buttonNode;
	            		var buttonWidget = mstrmojo.insert(this.buttonNodeWidget);
	            		buttonWidget.render();
	            		this.buttonNode = buttonWidget.domNode;
	            	}
	        		this.textNode.innerHTML = this.text;
	            	var padLeft = (this.level + 1) * PAD_STEP; 
	            	this.stateSpaceNode.style.width = (padLeft >= 0? padLeft: 0) + "px"; 
	            	
	            	this.textNode.style.width = this.domNode.offsetWidth - this.stateNode.offsetWidth - this.buttonNode.offsetWidth - 10 + "px";

            	}
                
                if (!(this.items && this.items.length)) {
                        this.set("state", 2); 
                        this.tree.sampleUnit = this.domNode;
                } else {
                        this.set("state", 0); 
                }
                                       

				
                this.domNode.style.display = 'block';
            },
            buildTree: function() {
                    this.fillData();

                    if(this.childTree)
                            var len = this.childTree.length;
                    for(var i = 0; i < len; i++)
                            this.childTree[i].buildTree();
            },

            
            clickHandler: function (evt) {
                    
                            
                    var target = evt.target;
                    if (this.state !== 2 && mstrmojo.dom.contains(this.stateNode, target, true, this.domNode)) {
                            this.set("state", this.state === 0 ? 1 : 0);
                            if(this.state == 1){
                                    
                                    this.renderChildrenList();
                                    this.updateChildrenSelection();
                            }else{
                                    var deleteIndex = this.tree.cachedUnits.indexOf(this.contentNode);
                                    if(deleteIndex != -1){
                                            deleteIndex ++;
                                            var len = this.childTree.length;
                                            this.tree.cachedUnits.splice(deleteIndex,len);
                                    }
                            }
                            this.tree.resized();
                            this.tree.updateScroller();
                            return;
                    }
                    
                    if (this.itemFunction) {
                            this.itemFunction(evt);
                    }
                    if (!this.isSelectable) {
                            return;
                    }
                    
                    mstrmojo.VisHeatMapAnimation.animate(this.contentNode, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});

                    if (this.selectionStatus === SELECTION_STATUS.YES) { 
                            this.selectionStatus = SELECTION_STATUS.NO;
                    } else { 
                            this.selectionStatus = SELECTION_STATUS.YES;
                    }
                    this.setChildStatus(this.selectionStatus);
                    this.updateSelection(false, true);
            },

            
            setChildStatus: function ( status) {
            	if (this.childTree) {
	            	for (var i = 0; i < this.childTree.length; i++) {
	            		var item = this.childTree[i];
                        if(!item)
                                continue;
	            		item.selectionStatus = status;
	            		item.setChildStatus(status);
	            		item.updateSelection(false, false);
	            	}
            	}
            },

            updateChildrenSelection: function(){
                    if(!this.childTree)
                            return ;
                    var len = this.childTree.length;
                    for(var i = 0; i < len; i++)
                    if(this.childTree[i])
                            this.childTree[i].updateSelection(false,false);
            },
            
            
            updateSelection: function ( checkChild,  callParent) {
            	if (checkChild && this.childTree) {
	            	var allSelected = true;
	            	var noSelected = true;
	            	var partSelected = false;
	            	for (var i = 0; i < this.childTree.length; i++) {
	            		var item = this.childTree[i];
	            		if (allSelected && item.selectionStatus !== SELECTION_STATUS.YES) {
	            			allSelected = false;
	            		}
	            		if (noSelected && item.selectionStatus !== SELECTION_STATUS.NO) {
	            			noSelected = false;
	            		}
	            		if (!allSelected && !noSelected) {
	            			partSelected = true;
	            			break;
	            		}
	            	}
	            	this.selectionStatus = allSelected? SELECTION_STATUS.YES: (noSelected? SELECTION_STATUS.NO: SELECTION_STATUS.PART);
            	}
            	var cssClass = "heatmap-tree-div";
            	switch (this.selectionStatus) {
            		case SELECTION_STATUS.YES:
            			cssClass += " selected";
            			break;
            		case SELECTION_STATUS.PART:
            			cssClass += " partSelected";
            			break;
            		case SELECTION_STATUS.NO:
            		default:
            			break; 
            	}
            	
                this.cssName = cssClass;
                if(this.contentNode)
                        this.contentNode.className = cssClass;
            	if (callParent && this.parentTree) {
            		this.parentTree.updateSelection(true, true);
            	}
            	if (this.isRoot) { 
            		this.notifyAll();
            	}
            },
            
            
            resized: function () {
            	if (this.parent.resized) {
            		this.parent.resized(this.domNode.offsetHeight);
            	}
            },
            
            
            selectionStatus: SELECTION_STATUS.NO         
        });
    
    
    mstrmojo.VisHeatMapTree = mstrmojo.declare(
    		
    		mstrmojo.VisHeatMapTreeItem,
    		[mstrmojo._TouchGestures, mstrmojo._HasTouchScroller, mstrmojo.SmoothScroll],
    		
        	{
        		scriptClass: "mstrmojo.VisHeatMapTree",
        		
        		
                isRoot: true,
                
                
                showRoot: false,
                
                
                rootText: "",
                
                
                heightLimit: 0, 
                
                
                defaultSelectionStatus: SELECTION_STATUS.NO,
                
                
                markupString: '<div id="{@id}" class="heatmap-tree root {@cssClass}" style="{@cssText} mstrAttach:mousedown,mousemove,mouseup,click">' +
					                '<div class="heatmap-tree-div" style="line-height:40px;" idx="{@idx}">' +  
	                            		'<div class="heatmap-tree-state" style="display:none;">'  +
	                            			'<div class="heatmap-tree-state space">&nbsp;</div>' +
	                            			'<div class="heatmap-tree-state-text"></div>' +
	                            		'</div>' +
					            		'<div class="heatmap-tree-text"></div>' + 
					            		'<div class="{@buttonNodeCss}">&nbsp;</div>' +
					            	'</div>' +
					            	'<div style="overflow:hidden; position:relative">' + 
					            			'<div class="heatmap-tree-container"></div>' + 
                					'</div>' +
    					       '</div>',

    			markupSlots: {
                    contentNode: function(){return this.domNode.firstChild;},
                    stateNode: function(){return this.domNode.firstChild.firstChild;},
                    stateSpaceNode: function(){return this.domNode.firstChild.firstChild.firstChild;},
                    stateTextNode: function(){return this.domNode.firstChild.firstChild.lastChild;},
                    textNode: function(){return this.domNode.firstChild.childNodes[1];},
                    buttonNode: function(){return this.domNode.firstChild.childNodes[2];},
                    scrollboxNode: function(){return this.domNode.lastChild;},
                    containerNode: function(){return this.domNode.lastChild.firstChild;}
    			},
    			
    			initialized: false,
    			
    			
    			dirty: false,

                showIndicators: false, 

                showScrollbars: false,

                cachedUnits: [],
    			
    			
    			
    			
    			init: function (config) {
    				this._super(config);
    				this.observer = []; 
    			},
    			
    			register: function (widget) {
    				this.observer.push(widget);
    				this.notifyAll();
    			},
    			
    			notifyAll: function () {
    				var enabled = false;
    				if (this.childTree && this.childTree.length > 0) { 
    					enabled = true;
    				}
    				
    				if (enabled) {
    					mstrmojo.css.removeClass(this.contentNode, "disabled");
    				} else {
    					mstrmojo.css.addClass(this.contentNode, "disabled");
    				}
    				
    				if (this.selectionStatus === SELECTION_STATUS.NO) {
    					enabled = false;
    				}
    				for (var index in this.observer) {
    					this.observer[index].notify(enabled);
    				}
    			},

                buildRendering: function() {
                        if(this.isRoot){
                                this.cachedParent = this.parent;
                                delete this.parent;
                        }
                        if(this._super)
                                this._super();
                },
    			
    			postBuildRendering: function () {


                        var t0 = (new Date()).getTime();
    				

                    if(this.isRoot){
                            this.scrollerConfig = {
                                    bounces : false,
                                    showIndicators: this.showIndicators,
                                    showScrollbars : this.showScrollbars,
                                    useTranslate3d : true,
                                    vScroll: true,
                                    hScroll: false,
                                    offset : {
                                            y: {
                                                    start: 0,
                                                    end: 0 
                                            },
                                            x: {
                                                    start: 0,
                                                    end: 0
                                            }
                                    },
                                    origin: {
                                            x: 0,
                                            y: 0
                                    },
                                    scrollEl : this.containerNode
                            };
                    }

                    

                    

    				this._super();




                    

                    

                    

                    
                    this.buildTree();

                    
                    




                    
                    this.renderChildrenList();
                    

                    
                    
                    if(this.isRoot){
                            this.parent = this.cachedParent;
                            this.parent.containerNode.appendChild(this.domNode);
                    }

    				
    				if (this.heightLimit > 0) {
    					var limit = this.heightLimit - this.contentNode.offsetHeight - 2; 
    					if (limit >= 0) {
    						this.scrollboxNode.style.maxHeight = limit + "px";
    					}
    				}

                    
    				this.selectionStatus = this.defaultSelectionStatus;
            		this.setChildStatus(this.selectionStatus);
                	this.updateSelection(false, true);
            		
                    
                    this.viewNode = this.scrollboxNode;

    				this.notifyAll();
                    this.resized();
                    this.updateScroller();


                    
                    


					
					
    				

    			},

    			touchTap: function (event) {
    				var title = mstrmojo.dom.findAncestorByAttr(event.target, "id", true, this.domNode);
    				if (!title) { 
    					
    						this.clickHandler(event);
    					
    						
    					
    					return;
    				}
    				var item = mstrmojo.all[title.value];
    				if (item && item.clickHandler) {
    					item.clickHandler(event);
    				}
    			},
    			
    			resized: function ( childHeight) {
                    
                    var $P = mstrmojo.dom.position;
                    if(!this.viewRect){
                            this.viewRect = $P(this.scrollboxNode, true);
                    }
    				if (!(this.heightLimit > 0)) { 
    					return;
    				}

                    if(!this._scroller.offset){
                            return;
                    }

    				childHeight = childHeight || this.containerNode.offsetHeight;
    				if (childHeight > this.scrollboxNode.clientHeight) {
    					this._scroller.offset.y.end = childHeight - this.scrollboxNode.clientHeight ;
    				} else {
    					this._scroller.offset.y.end = 0;
    					this._scroller.scrollTo(0, 0, 0);
    				}
    			},

    			
                refresh: function () {
                	if (this.needRefresh) {
	                	this.containerNode.innerHTML = "";
	                	
	                	
	            		
	            		
						
	                	this.postBuildRendering();
	                	this.resized();
                        this.updateScroller();
	                	this.needRefresh = false;
                	}
                }
        	}
    		
    );
   
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.Container",
                         "mstrmojo._HasLayout",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.ui.CalendarMonthView",
                         "mstrmojo.android.ui.CalendarYearList");

    var $H = mstrmojo.hash,
        $A = mstrmojo.array,
        CLEAR_TEXT = mstrmojo.desc(2827, 'Clear'),
        CANCEL_TEXT = mstrmojo.desc(221, 'Cancel');

    
    mstrmojo.android.ui.Calendar = mstrmojo.declare(

        
        mstrmojo.Container,

        
        [mstrmojo._TouchGestures, mstrmojo._HasLayout],

        
        {
            scriptClass: "mstrmojo.android.ui.Calendar",

            config: undefined,

            markupString: '<div id="{@id}" class="mstrmojo-android-Calendar">' +
                              '<div class="mstrmojo-Calendar-Year"></div>' +
                              '<hr class="mstrmojo-Calendar-Sep"/>' +
                              '<div class="mstrmojo-Calendar-Month"></div>' +
                          '</div>',

            markupSlots: {
                yearNode: function () { return this.domNode.firstChild; },
                monthNode: function () { return this.domNode.lastChild; }
            },

            markupMethods: {
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },

            cssDisplay: '',

            
            isMultiSelect: false,

            
            selectedDates: undefined,

            
            min: undefined,

            
            max: undefined,

            init: function init(props) {
                var now = new Date(),
                    yearWidget = this.children[0],
                    monthWidget = this.children[1],
                    min = props.min = props.min || {},
                    max = props.max = props.max || {},
                    selected = props.selectedDates = props.selectedDates || [],
                    firstSelected = selected[0] || {},
                    firstYear,
                    firstMonth;

                
                $A.forEach([firstSelected, min], function (obj) {
                    if (!isNaN(obj.year) && !isNaN(obj.month)) {
                        firstYear = obj.year;
                        firstMonth = obj.month;
                        return false;
                    }
                });

                firstMonth = !isNaN(firstMonth) ? firstMonth : (now.getMonth() + 1);
                firstYear = !isNaN(firstYear) ? firstYear : now.getFullYear();


                
                $H.copy({
                    initialYear: firstYear,
                    initialMonth: firstMonth,
                    multiSelect: !!this.isMultiSelect,
                    selected: selected,
                    range: {
                        start: min,
                        end: max
                    }
                }, monthWidget);

                $H.copy({
                    initialYear: firstYear,
                    start: min.year,
                    end: max.year
                }, yearWidget);

                
                this._super(props);

            },

            postBuildRendering: function postBuildRendering() {
                
                this.monthWidget.markupBuilder = this.markupBuilder;

                
                this._super();

                
                var calList = this.target;

                
                calList.set('items', this.selectedDates);
                calList.selectItems(calList.items);

                
                this.yearWidget.attachEventListener('yearChanged', this.monthWidget.id, function (evt) {
                    this.current.set('y', evt.value);
                });

                
                this.monthWidget.attachEventListener('selectionChanged', this.id, function (evt) {
                    this.syncListItemsWithSelections([].concat(evt.items));
                });

                
                this.target.attachEventListener('selectionChange', this.id, function (evt) {
                    var target = this.target,
                        targetItems = target.items,
                        monthWidget = this.monthWidget,
                        added = $A.get(targetItems, evt.added),
                        removed = $A.get(targetItems, evt.removed);

                    
                    if (added && added.length > 0) {
                        monthWidget.selectItems(added);
                    } else {
                        var toRemove;
                        if ((removed && removed.length > 0) && (targetItems && targetItems.length > 0)) {
                            toRemove = removed;
                        }
                        monthWidget.unselectItems(toRemove);
                    }

                    if (target.parent) {
                        
                        target.parent.btnHbox.children[0].set('text', ((target.getSelectedItems().length > 0) ? CLEAR_TEXT : CANCEL_TEXT));
                    }

                    
                    monthWidget.selected = target.getSelectedItems();
                });
            },

            
            syncListItemsWithSelections: function syncTargetListSelections(newItems) {
                var target = this.target;

                
                target.glow = false;

                
                target.set('items', newItems);
                target.selectItems(newItems);

                if (target.parent) {
                    
                    target.parent.btnHbox.children[0].set('text', ((target.getSelectedItems().length > 0) ? CLEAR_TEXT : CANCEL_TEXT));

                    
                    target.parent.resizeDialog();
                }

                
                target.glow = true;
            },

            
            getSelectedDates: function getSelectedDates(format) {
                var result = [];

                
                $A.forEach(this.target.getSelectedItems(), function (sd) {
                    result.push(sd.n);
                });

                return result;
            },

            children: [{
                scriptClass: "mstrmojo.android.ui.CalendarYearList",
                alias: 'yearWidget',
                slot: 'yearNode'
            }, {
                scriptClass: "mstrmojo.android.ui.CalendarMonthView",
                alias: 'monthWidget',
                slot: 'monthNode'
            }]
        }
    );

}());

(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._HasLayout",
                         "mstrmojo.android.ui.PathView");

    
    mstrmojo.android.large.ui.FolderView = mstrmojo.declare(

        mstrmojo.Container,

        [ mstrmojo._HasLayout ],

        
        {
            scriptClass: "mstrmojo.android.large.ui.FolderView",

            markupString: '<div id="{@id}" class="mstrmojo-TabletFolderView {@cssClass}" style="{@cssText}" >' +
                              '<div class="mstrmojo-TabletFolderView-path"></div>' +
                              '<div class="mstrmojo-TabletFolderView-folder"></div>' +
                          '</div>',

            markupSlots: {
                pathNode: function () { return this.domNode.firstChild; },
                folderNode: function () { return this.domNode.lastChild; }
            },

            markupMethods: {
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod
            },

            layoutConfig: {
                h: {
                    pathNode: 'auto',
                    folderNode: '100%'
                },
                w: {
                    pathNode: '100%',
                    folderNode: '100%'
                }
            },

            children: [{
                scriptClass: 'mstrmojo.android.ui.PathView',
                alias: 'path',
                slot: 'pathNode',
                cssClass: 'mstrmojo-Path'
            }],

            updateFolder: function updateFolder(folderView) {
                
                var existingView = this._folderView;
                if (existingView) {
                    
                    this.removeChildren(existingView);
                    existingView.unrender();
                }

                
                this._folderView = folderView;

                var folderNode = this.folderNode,
                    h = folderNode.clientHeight,
                    w = folderNode.clientWidth;

                
                folderView.width = w + 'px';
                folderView.height = h + 'px';
                folderView.slot = 'folderNode';

                
                this.addChildren([ folderView ]);
            },

            updatePath: function updatePath(path) {
                
                this.path.set('items', path);
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.android.SimpleList",
                         "mstrmojo.css");

    var $CSS = mstrmojo.css,
        clsGlow = 'glow',
        $DOM = mstrmojo.dom,
        $TRANS_DURATION = $DOM.$TRANS_DURATION,
        itemMarkup;

    
    function doGlow(el) {
        var style = el.style;

        
        style[$TRANS_DURATION] = 0;
        $CSS.addClass(el, clsGlow);

        
        window.setTimeout(function () {
            
            style[$TRANS_DURATION] = '300ms';
            $CSS.removeClass(el, clsGlow);
        }, 100);
    }

    
    mstrmojo.ui.MobileCheckList = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        null,

        
        {
            scriptClass: "mstrmojo.ui.MobileCheckList",

            
            multiSelect: true,

            
            hasEvenRows: true,

            
            glow: true,

            
            allowTouchBubble: false,

            listHooks: {
                select: function (el, item, idx) {
                    
                    if (this.glow && !this.skipEvent) {
                        
                        doGlow.call(this, el);
                    }
                },

                unselect: function (el, item, idx) {
                    
                    if (this.glow && this.multiSelect && !this.skipEvent) {
                        
                        doGlow.call(this, el);
                    }
                }
            },

            getItemMarkup: function (item) {
                
                if (!itemMarkup) {
                    
                    itemMarkup = this._super(item).replace('{@n}', '<div><h3>{@n}</h3></div>');
                }

                
                return itemMarkup;
            },

            
            init: function init(props) {
                this._super(props);

                
                var cls = [ 'mobile-checklist' ];

                
                if (this.multiSelect) {
                    
                    cls.push('multi');
                }

                
                mstrmojo.css.addWidgetCssClass(this, cls);
            }


        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList");

    var itemMarkup;

    
    mstrmojo.android.ui.TxDocList = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        null,

        
        {
            scriptClass: "mstrmojo.android.ui.TxtDocList",

            scrollerConfig: {
                bounces: false,
                showScrollbars: false
            },

            highlightOnSelect: true,

            getItemMarkup: function getItemMarkup(item) {
                
                if (!itemMarkup) {
                    
                    itemMarkup = this._super(item).replace('{@n}', '<h3>{@n}</h3><h4>{@desc}</h4><em>{@cnt}</em>');
                }

                
                return itemMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx);

                
                props.desc = item.desc;
                props.cnt = item.c;

                
                return props;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList");

    
    mstrmojo.android.selectors.ListBox = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        null,

        
        {
            scriptClass: "mstrmojo.android.selectors.ListBox",

            init: function init(props) {
                this._super(props);

                
                mstrmojo.css.addWidgetCssClass(this, [ 'selector-listbox' ]);
            },

            postBuildRendering: function postBuildRendering() {
                
                var h = parseInt(this.height, 10);
                if (h) {
                    var itemsContainerNode = this.itemsContainerNode,
                        listHeight = itemsContainerNode.offsetHeight;

                    
                    if (listHeight < h) {
                        
                        var cnt = this.items.length,
                            lineHeight = Math.round(h / this.items.length) + 'px',
                            i = 0;

                        
                        for (i = 0; i < cnt; i++) {
                            
                            itemsContainerNode.childNodes[i].style.lineHeight = lineHeight;
                        }
                    }
                }

                return this._super();
            }

        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList");
    
    var itemMarkup;

    
    mstrmojo.android.large.ui.TxTypeList = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        null,

        
        {
            scriptClass: "mstrmojo.android.large.ui.TxTypeList",
            
            getItemMarkup: function (item) {
                
                if (!itemMarkup) {
                    
                    itemMarkup = '<div class="item {@cls}" idx="{@idx}" style="{@style}"><h3>{@n}</h3><em>{@cnt}</em></div>';
                }
                
                
                return itemMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx);

                
                props.cnt = item.v;

                
                return props;
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList",
                         "mstrmojo.android._HasLingeringListSelections");

    var itemMarkup = [],
        $DOM = mstrmojo.dom,
        $STR = mstrmojo.string;

    
    mstrmojo.android.ui.FolderView = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        [ mstrmojo.android._HasLingeringListSelections ],

        
        {
            scriptClass: "mstrmojo.android.ui.FolderView",

            
            allowTouchBubble: false,

            
            useSelectScroll: true,

            
            highlightOnSelect: true,

            
            hasEvenRows: true,

            
            listHooks: {
                select: function (el) {
                    
                    el.style[$DOM.CSS3_TRANSITION_DURATION] = 0;
                },
                unselect: function (el) {
                    
                    el.style[$DOM.CSS3_TRANSITION_DURATION] = '300ms';
                }
            },

            getItemMarkup: function (item) {
                var desc = item.desc,
                    isc = item.isc,

                    
                    markupType = ((desc) ? 1 : 0) + ((isc) ? 2 : 0);

                
                
                

                
                if (!itemMarkup[markupType]) {

                    
                    var im = '<h3>{@n}</h3>';

                    
                    if (desc) {
                        im += '<h4>{@desc}</h4>';
                    }

                    
                    im += '<div><div><div></div></div></div>';

                    
                    itemMarkup[markupType] = this._super(item).replace('{@n}', im);
                }

                return itemMarkup[markupType];
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx),
                    desc = item.desc || '',
                    cached = this.controller.isItemCached(item),
                    
                    disabled = !(cached || this.controller.isItemAvail(item, true));

                
                props.addCls('ty' + (item.st  || 2048));

                if ( props.n) {
                    
                    props.n = $STR.htmlAngles(props.n);
                }

                
                if (desc) {
                    
                    props.desc = $STR.htmlAngles(desc);

                    
                    props.addCls('desc');
                }

                
                if (cached && item.st !== 2048) {
                    props.addCls('cached');
                } else if (item.isc) {
                    
                    props.addCls('isc');
                }
                
                if (item.unread) {
                	props.addCls('new');
                }

                
                if (disabled) {
                    
                    props.addCls('disabled');
                }

                return props;
            },

            canItemLinger: function canItemLinger(item) {
                return this.controller.canItemLinger(item);
            },

            buildRendering: function buildRendering() {
                var rtn = this._super();

                
                var clearDiv = document.createElement('div');
                clearDiv.className = 'clear-me';

                
                this.itemsContainerNode.appendChild(clearDiv);

                return rtn;
            },

            preselectionChange: function preselectionChange(evt) {
                var added = evt.added,
                    removed = evt.removed;

                
                if (added) {
                    
                    var item = this.items[added[0]];
                    if (!this.controller.isItemAvail(item)) {
                        
                        if (removed && removed.length) {
                            this.select(removed, true);
                        }
                        return false;
                    }
                }

                return true;
            },

            
            touchSelectBegin: function touchSelectBegin(touch) {
                var idx = this.getItemIdxTouch(touch);
                if (idx > -1) {
                    
                    var ctrl = this.controller;
                    if (!ctrl.itemLongPressed || !ctrl.itemLongPressed(this.items[idx])) {
                        
                        this._super(touch);
                    } else {
                        
                        return false;
                    }
                }

                return true;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._HasLayout",
                         "mstrmojo.android.SimpleList",
                         "mstrmojo.OfflineTransactionModel");

    var EnumTxType = mstrmojo.OfflineTransactionModel,
        PENDING = EnumTxType.PENDING,
        FAILED = EnumTxType.FAILED;

    
    mstrmojo.android.ui.TxEditDoc = mstrmojo.declare(

        mstrmojo.Container,

        [ mstrmojo._HasLayout ],

        
        {
            scriptClass: "mstrmojo.android.ui.TxEditDoc",

            markupString: '<div id="{@id}" class="mstrmojo-TxEditDoc {@cssClass}" style="{@cssText}">' +
                              '<div></div>' +
                              '<div></div>' +
                              '<div></div>' +
                          '</div>',

            markupSlots: {
                typeNode: function () { return this.domNode.firstChild; },
                txNode: function () { return this.domNode.childNodes[1]; },
                btmNode: function () { return this.domNode.lastChild; }
            },

            
            model: null,

            
            docDid: null,

            children: [{
                scriptClass: 'mstrmojo.android.SimpleList',
                alias: 'txList',
                slot: 'txNode',
                cssClass: 'txList',
                postselectionChange: function (evt) {
                    var added = evt.added,
                        idx = added && added[0],
                        transactionView = this.parent.parent;

                    
                    if (transactionView) {
                        transactionView.enableButtons(idx !== null);
                    }
                }
            }],

            addChildren: function addChildren(children, idx, silent) {
                
                children = children.concat([mstrApp.viewFactory.newView('TransactionsTypeList', {
                    alias: 'typeList',
                    slot: 'typeNode',
                    cssClass: 'txTypeList',
                    selectionPolicy: 'reselect',
                    postselectionChange: function (evt) {
                        var added = evt.added,
                            idx = added && added[0];

                        
                        if (idx !== null) {
                            var txItems = [],
                                parent = this.parent;

                            
                            mstrmojo.array.forEach(this.parent._tx[idx ? FAILED : PENDING], function (item, idx) {
                                
                                txItems.push({
                                    n: item.n,
                                    v: item.timestamp,
                                    idx: idx
                                });
                            });

                            
                            parent.txList.set('items', txItems);

                            
                            parent.typeSelected(idx);
                        }
                    }
                })]);

                this._super(children, idx, silent);
            },

            
            getType: function getType() {
                return this.typeList.selectedIndex;
            },

            
            setType: function setType(type) {
                
                this.typeList.singleSelect(type);
            },

            
            getSelectedTx: function getSelectedTx() {
                return this.txList.getSelectedItems()[0];
            },

            
            typeSelected: mstrmojo.emptyFn,

            
            generateTypeList: function generateTypeList(defaultSelect) {
                
                var docID = this.docID;
                if (!docID) {
                    
                    return;
                }

                var model = this.model,
                    txs = (model && model.docsTx) || [],
                    documentTxs = txs[docID],
                    pendingItems = [],
                    failedItems = [];

                
                if (documentTxs) {
                    
                    pendingItems = documentTxs[PENDING];
                    failedItems = documentTxs[FAILED];
                }

                
                var tx = this._tx = {};
                tx[PENDING] = pendingItems;
                tx[FAILED] = failedItems;

                
                var typeList = this.typeList,
                    selectedIdx = Math.max(typeList.selectedIndex, 0);

                
                typeList.set('items', [{
                    n: mstrmojo.desc(9250, 'Pending'),
                    v: pendingItems.length
                }, {
                    n: mstrmojo.desc(9251, 'Failed'),
                    v: failedItems.length
                }]);

                
                if (defaultSelect) {
                    
                    selectedIdx = (failedItems.length) ? 1 : 0;
                }

                
                typeList.singleSelect(selectedIdx);
            },

            
            ondocIDChange: function ondocIDChange() {
                this.generateTypeList(true);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList");
    
    var itemMarkup,
    	$D = mstrmojo.dom;
    
    
    function setElementColor(element, duration, color) {
        var elementStyle = element.style;
        elementStyle[$D.CSS3_TRANSITION_DURATION] = duration;        
        elementStyle.backgroundColor = color;
    }

    
    mstrmojo.android.large.ui.NavTabs = mstrmojo.declare(
        mstrmojo.android.SimpleList,

        null,

        
        {
            scriptClass: 'mstrmojo.android.large.ui.NavTabs',
            
            selectionPolicy: 'reselect',
            
            getItemMarkup: function getItemMarkup(item) {
                if (!itemMarkup) {
                    itemMarkup = this._super(item).replace('{@n}', '<div>{@n}</div>');
                }

                return itemMarkup;
            },
            
            listHooks: {
                select: function (el) {
                    
                    setElementColor(el, 0, 'rgba(51,181,229,.6)');

                    
                    window.setTimeout(function () {
                        setElementColor(el, '300ms', 'transparent');
                    }, 200);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.TxEditDoc");

    
    mstrmojo.android.large.ui.TxEditDoc = mstrmojo.declare(

        mstrmojo.android.ui.TxEditDoc,

        null,

        
        {
            scriptClass: "mstrmojo.android.large.ui.TxEditDoc",

            layoutConfig: {
                h: {
                    typeNode: '100%',
                    txNode: '100%'
                },
                w: {
                    typeNode: '42%',
                    txNode: '58%'
                }
            },

            typeSelected: function typeSelected(idx) {
                if(this.hasRendered) {
                    var anchorNode = this.btmNode,
                    anchorStyle = anchorNode.style;
                    
                    
                    anchorStyle.left = (this.typeNode.offsetWidth - anchorNode.offsetWidth + 1) + 'px';
                    anchorStyle.top = this.typeList.getItemOffset(idx) + 'px';
                }
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.ui.MobileCheckList",
                         "mstrmojo.android._IsIncFetchList",
                         "mstrmojo.mstr.WebElements",
                         "mstrmojo.array");

    var $ARR = mstrmojo.array,
        emptyElements = new mstrmojo.mstr.WebElements();

    
    function toggleIncFetch(browseElements) {
        
        this.supportsIncFetch = false;
        delete this.ifDataHelper;

        
        if (browseElements) {
            
            if (browseElements.items.length < browseElements.totalSize) {
                
                this.ifDataHelper = browseElements;

                
                this.supportsIncFetch = true;
            }
        }
    }

    
    function cacheElasticHeight() {
        
        var height = this.height;
        if (!this.elasticHeight && height) {
            
            this.elasticHeight = parseInt(height, 10);
        }
    }

    
    mstrmojo.android.ui.ElementsPicker = mstrmojo.declare(

        mstrmojo.ui.MobileCheckList,

        [ mstrmojo.android._IsIncFetchList ],

        
        {
            scriptClass: 'mstrmojo.android.ui.ElementsPicker',

            
            browseElements: null,

            
            viewAll: true,

            
            glow: true,

            
            onbrowseElementsChange: function onbrowseElementsChange() {
                
                toggleIncFetch.call(this);

                
                this._ignoreSelection = true;

                
                var bElems = this.browseElements;
                if (bElems) {
                    
                    var items = bElems.items = (bElems.items || []),
                        cfg = this._searchConfig;

                    
                    if ((!cfg || cfg.exit) && !this.viewAll) {
                        
                        items = this.getSelectedItems();
                    }

                    
                    this.set('items', items);

                    
                    if (cfg) {
                        
                        this.glow = false;

                        
                        this.selectItems(cfg.selected, true);

                        
                        this.glow = true;
                    }

                    
                    toggleIncFetch.call(this, bElems);
                } else {
                    
                    this.set('items', []);
                }

                
                this.updateScroller();

                
                this._ignoreSelection = false;
            },
            
            syncSelection: function syncSelection() {
                var cfg = this._searchConfig;

	            
	            if (cfg) {
	                this.selectItems(cfg.selected, false);
	            }
            },
            
            enterSearchMode: function enterSearchMode() {
                
                var selectedItems = this.getSelectedItems();
                this._searchConfig = {
                    elements: this.browseElements,              
                    selected: selectedItems,                    
                    clone: [].concat(selectedItems)             
                };

                
                cacheElasticHeight.call(this);

                
                this.set('browseElements', emptyElements);
            },

            
            search: function search(results) {
                
                this.set('browseElements', results);
            },

            
            exitSearchMode: function exitSearchMode(viewAll) {
                
                var cfg = this._searchConfig;

                
                cfg.exit = true;

                
                this.set('browseElements', viewAll ? cfg.elements : {items:cfg.selected});

                
                delete this._searchConfig;
            },

            
            clearSearch: function clearSearch() {
                
                var cfg = this._searchConfig;
                cfg.selected = [].concat(cfg.clone);

                
                this.set('browseElements', emptyElements);
            },

            
            postselectionChange: function postselectionChange(evt) {
                
                var cfg = this._searchConfig;
                if (!cfg || this._ignoreSelection) {
                    
                    return;
                }

                
                var selected = cfg.selected,
                    items = this.items,
                    added = evt.added;

                
                if (this.multiSelect) {
                    
                    $ARR.forEach(added, function (idx) {
                        
                        selected.push(items[idx]);
                    });

                    
                    $ARR.forEach(evt.removed, function (idx) {
                        
                        $ARR.removeItems(selected, 'v', [ items[idx] ]);
                    });

                
                } else if (added) {
                    
                    selected.splice(0);

                    
                    selected.push(items[added[0]]);
                }
            },

            
            onviewAllChange: function onviewAllChange() {
                
                var items = this.getSelectedItems(),
                    browseElements;

                
                if (this.viewAll) {
                    
                    browseElements = this.browseElements;
                    items = browseElements.items;

                } else {
                    
                    cacheElasticHeight.call(this);

                }

                
                this.glow = false;

                
                var selectedItems = this.getSelectedItems();

                
                this.set('items', items);

                
                this.selectItems(selectedItems, true);

                
                this.glow = true;

                
                toggleIncFetch.call(this, browseElements);

                
                this.updateScroller();
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.ui.MobileCheckList",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.android._IsIncFetchList",
                         "mstrmojo.array");

    var BLOCK_SIZE = 50;

    function createIncFetchDataHelper() {
        return {
            next: function (cb) {
                var newEnd = Math.min(this.blockEnd + BLOCK_SIZE, this.totalSize);

                cb.success(null, this.items.slice(this.blockEnd, newEnd));

                this.blockEnd = newEnd;
            },

            init: function (begin, end, items) {
                this.blockBegin = begin;
                this.blockEnd = end;
                this.totalSize = items.length;
                this.items = items;
            }
        };
    }

    mstrmojo.android.inputControls.PullDownDIC = mstrmojo.declare(
        mstrmojo.ui.MobileCheckList,

       [mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton, mstrmojo.android._IsIncFetchList],

        {
            scriptClass: 'mstrmojo.android.inputControls.PullDownDIC',

            multiSelect: false,

            isElastic: true,

            supportsIncFetch: false,

            init: function init(props) {
                this._super(props);

               this._items = this.getItems();

                if (this._items.length > BLOCK_SIZE) {
                    this.ifDataHelper = createIncFetchDataHelper();
                    this.supportsIncFetch = true;
                }
            },

            postselectionChange: function postselectionChange(evt) {
                var idx = evt.added[0];
                if (idx < this.items.length) {
                    this.set('value', this.items[idx].v);
                }
            },

            preBuildRendering: function preBuildRendering() {
                this._super();

                var value = this.value,
                    ust = this.dic.ust || '',
                    items = this._items,
                    idx = mstrmojo.array.find(items, 'v', value);

                
                if (idx === -1) {
                    
                    items = [{
                        n: ust,
                        v: value
                    }].concat(items);
                    idx = 0;
                }

                if (this.supportsIncFetch) {
                    
                    this.ifDataHelper.init(0, BLOCK_SIZE, items);
                    
                    items = items.slice(0, BLOCK_SIZE);
                }

                this.items = items;
                this.set('selectedIndex', idx);
            },

            postBuildRendering: function postBuildRendering() {
                this._super();
                
                this._scroller.scrollTo(0, 0);
            },

            
            renderPreview: function renderPreview() {
                
                var idx = mstrmojo.array.find(this._items, 'v', this.value),
                    label = (idx >= 0) ? this._items[idx].n : (this.dic.ust !== undefined ? this.dic.ust : this.dv);

                this.renderPreviewButton(this.openerNode, this.dicChanged ? label : this.dv);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocButton",
                         "mstrmojo._HasDrillLinks",
                         "mstrmojo.ui.MobileCheckList",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.dom",
                         "mstrmojo.array");

    
    function setPressedState(isPressed) {
        
        this.set('pressed', isPressed);
    }
    
    
    function hexToRgba(hex, alpha) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ?  
            "rgba(" + 
            parseInt(result[1], 16) + "," +
            parseInt(result[2], 16) + "," +
            parseInt(result[3], 16) + "," +
            alpha + ")"
            : '';
    }

    
    function executeLink(link) {
        this.model.executeLink(link, this.target, this);
    }

    
    function showLinkList() {
        var drillLinks = this.drillLinkItems,
            id = this.id;

        
        if (drillLinks.length === 1) {
            
            setPressedState.call(this, false);
            
            
            executeLink.call(this, drillLinks[0].url);
            return;
        }

        
        this._linksOpen = true;

        
        mstrApp.showDialog({
            title: this.defn.n,
            children: [{
                scriptClass: 'mstrmojo.ui.MobileCheckList',
                items: drillLinks,
                multiSelect: false,
                isElastic: true,
                hasEvenRows: true,
                postselectionChange: function (evt) {
                    
                    mstrApp.closeDialog();

                    
                    executeLink.call(mstrmojo.all[id], drillLinks[evt.added[0]].url);
                }
            }],
            onClose: function () {
                var btn = mstrmojo.all[id];

                
                setPressedState.call(btn, false);

                
                delete btn._linksOpen;
            },
            buttons: [ mstrmojo.android.ui.Button.newButton(mstrmojo.desc(221, 'Cancel')) ]
        });
    }
    
    
    var $BTN = mstrmojo.android.ui.DocButton = mstrmojo.declare(
        mstrmojo.DocButton,

        [ mstrmojo._HasDrillLinks ],

        
        {
            scriptClass: "mstrmojo.android.ui.DocButton",

            touchBegin: function touchBegin() {
                
                if (!this.linkEnabled) {
                    
                    return false;
                }

                
                setPressedState.call(this, true);

                return true;
            },

            touchTap: function touchTap() {
                if(this.ifw) {
                    this.model.showInfoWin(this.ifw, (this.getAnchor && this.getAnchor()) || this.domNode, 'v');
                    return;
                }
                
                var dl = this.drillLinkItems,
                	length = (dl && dl.length) || 0;
                
	            if(length > 0) {
	                
	                showLinkList.call(this);
	            }
            },

            touchSelectBegin: function touchSelectBegin() {
                this.touchTap();
            },

            touchEnd: function touchEnd() {
                
                if (!this._linksOpen) {
                    
                    setPressedState.call(this, false);
                }
            },
            
            setBackgroundColor: function setBackgroundColor() {
                var isPressed = !!this.pressed,
                defn = this.defn,
                domNode = this.domNode,
                fmts = this.fmts,
                containerNodeStyle = this.buttonContainerNode.style,
                domNodeStyle = this.domNode.style,
                containerColor = isPressed ? defn.bhlc : (fmts['background-color'] || ''),
                domColor = isPressed ? hexToRgba(defn.bhlc, 0.4) : '';
                
                containerNodeStyle.backgroundColor = containerColor;
                containerNodeStyle.borderColor = containerColor;
                domNodeStyle.borderColor = domColor;
                domNodeStyle.backgroundColor = domColor;
            },

            
            getDPI: function getDPI() {        
                return mstrMobileApp.getDeviceDPI();
            }
        }
    );

    
    $BTN.prototype.markupString = $BTN.prototype.markupString.replace(new RegExp(' mstrAttach:[a-zA-Z,]*'), '');

    
    $BTN.prototype.formatHandlers.domNode = mstrmojo.array.filter([].concat($BTN.prototype.formatHandlers.domNode), function (prop) {
        return (prop !== 'P' && prop !== 'B');
    });
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList",
                         "mstrmojo.ui.MobileCheckList",
                         "mstrmojo.array");

    var itemMarkup = '<div class="mstrmojo-SelectBoxList-item" idx="{@idx}">' +
                         '<h2>{@n}</h2>' +
                         '<h4>{@v}</h4>' +
                     '</div>';

    
    mstrmojo.android.ui.SelectBoxList = mstrmojo.declare(
        mstrmojo.android.SimpleList,

        null,

        
        {
            scriptClass: 'mstrmojo.android.ui.SelectBoxList',

            selectionPolicy: 'reselect',

            getItemMarkup: function () {
                return itemMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                
                var props = this._super(item, idx);

                
                props.v = item.v;

                
                return props;
            },

            
            postselectionChange: function postselectionChange(evt) {
                var added = evt.added;
                if (!added) {
                    return;
                }

                
                var idx = added[0],
                    item = this.items[idx],
                    items = item.items,
                    id = this.id;

                mstrApp.showDialog({
                    title: item.n,
                    children: [{
                        scriptClass: 'mstrmojo.ui.MobileCheckList',
                        items: items,
                        multiSelect: false,
                        isElastic: true,
                        selectedIndex: mstrmojo.array.find(items, 'on', true),
                        postselectionChange: function (evt) {
                            
                            mstrApp.closeDialog();

                            
                            mstrmojo.all[id].selectListChange(idx, items[evt.added[0]]);
                        }
                    }]
                });
            },

            
            selectListChange: mstrmojo.emptyFn
        }
    );

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.ui.MobileCheckList",
                         "mstrmojo.css");

    var $CSS = mstrmojo.css,
        clsSelected = 'selected';
    
    function updateTitleIcon() {
        
        var len = this.getSelectedItems().length,
            totalLen = this.items.length,
            updateStr = 'btnCheckSemi'; 
        
        if( len === 0) { 
            updateStr = 'btnCheckNone';
        } else if (len === totalLen) {
            updateStr = 'btnCheckFull'; 
        }
        
        
        this.parent.updateTitleBarButtonClass(updateStr);
    }
    
    mstrmojo.ui.MobileReviewList = mstrmojo.declare(

            mstrmojo.ui.MobileCheckList,

        null,

        
        {
            scriptClass: "mstrmojo.ui.MobileReviewList",
            
            listHooks: {
                select: function (el, item, idx) {
                    
                    mstrmojo.ui.MobileCheckList.prototype.listHooks.select(el, item, idx);
                    
                    if(this.parent.selectionHidden) {
                        this.selectedIndices = {}; 
                        return true;
                    }
                    
                    
                    updateTitleIcon.call(this);
                    
                },

                unselect: function (el, item, idx) {
                    
                    mstrmojo.ui.MobileCheckList.prototype.listHooks.unselect(el, item, idx);
                    
                    
                    updateTitleIcon.call(this);
                    
                    return this.selectionHidden;
                }
            },
            
            init: function init(props) {
                this._super(props);

                
                if (this.multiSelect) {
                    
                    $CSS.addWidgetCssClass(this, 'hidden');
                }

            },
            
            selectAll: function selectAll() {
                var methodName = 'addClass', 
                    listNode = this.domNode.childNodes[0],
                    count = listNode.childElementCount,
                    i = 0,
                    isSelectAll = true;

                
                if (this.getSelectedItems().length > 0 ) {
                    
                    methodName = ('removeClass');
                    this.selectedIndices = {};
                    isSelectAll = false;
                }


                for(i = 0; i < count; i++ ) {
                    $CSS[methodName](listNode.childNodes[i], clsSelected);
                    if(isSelectAll) {
                        this.selectedIndices[i] = true;
                    }
                }
                
                
                updateTitleIcon.call(this);
            },
        
            touchSelectBegin: function touchSelectBegin(touch) {
                if(this.parent.selectionHidden) {
                    
                    this.parent.setDeleteActions("delete");
                }
            }
        }
    );

}());

(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._HasLayout",
                         "mstrmojo.android.large.ui.FolderView",
                         "mstrmojo.css");

    
    mstrmojo.android.large.ui.BrowserView = mstrmojo.declare(

        mstrmojo.Container,

        [ mstrmojo._HasLayout ],

        
        {
            scriptClass: "mstrmojo.android.large.ui.BrowserView",

            markupString: '<div id="{@id}" class="mstrmojo-BrowserView {@cssClass}" style="{@cssText}" >' +
                              '<div>' +
                                  '<div class="mstrmojo-BrowserView-nav"></div>' +
                                  '<div class="mstrmojo-BrowserView-preview"></div>' +
                              '</div>' +
                          '</div>',

            markupSlots: {
                folderNode: function () { return this.domNode.firstChild.firstChild; },
                previewNode: function () { return this.domNode.firstChild.lastChild; }
            },

            markupMethods: {
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod
            },

            layoutConfig: {
                h: {
                    folderNode: '100%',
                    previewNode: '100%'
                },
                w: {
                    folderNode: '33%',
                    previewNode: '67%'
                }
            },

            children: [{
                scriptClass: 'mstrmojo.android.large.ui.FolderView',
                alias: 'folder',
                slot: 'folderNode'
            }],

            
            onorientationChange: function onorientationChange() {
                var isPortrait = !!this.orientation,
                    widthCfg = this.layoutConfig.w;

                
                widthCfg.folderNode = isPortrait ? '100%' : '33%';
                widthCfg.previewNode = isPortrait ? '0px' : '67%';

                
                if (this.hasRendered) {
                    
                    this.doLayout();
                }
            },

            updateFolder: function updateFolder(folderView, path) {
                var folder = this.folder;
                if (!folder) {
                	var displayMsg = this.displayMsg;
                	if (displayMsg && displayMsg.parent) {
                		this.removeChildren(displayMsg);
                	}
                	
                	folder = this._chachedFolder;
                	this.addChildren([ folder ]);
                }
                
                	
                
                if (folderView) {
                    
                    folder.updateFolder(folderView);

                    
                    folderView.controller.afterViewVisible();
                }

                
                folder.updatePath(path);

                
                folder.doLayout();
            },
            
            updateProperties: function updateProperties(view) {
                
                view.slot = 'previewNode';
                view.ignoreLayout = true;

                this.addChildren([ view ]);
            },            
            
            updateDisplayMessage: function updateDisplayMessage(view) {
            	
            	var folder = this.folder;
            	if (folder && folder.parent) {   
            		this._chachedFolder = folder;  
            		this.removeChildren(folder);
            	}
            	
                view.alias = 'displayMsg';
                view.slot = 'folderNode';
                view.height = '100%';
            	
                this.addChildren([ view ]);            	
            }
        }
    );
}());
(function() {
    mstrmojo.requiresCls("mstrmojo.TableLayoutList");

    
    mstrmojo._IsTableLayoutListDIC = mstrmojo.provide(

        "mstrmojo._IsTableLayoutListDIC",
        
        {
            _mixinName: 'mstrmojo._IsTableLayoutListDIC',

            icnCss: 'dicContainer',
            
            tableLayoutCssStyle: 'fixed',
            
            
            setDirtyFlag: function(c, d) {
                if (c.className !== 'flag-container') {
                    var f = document.createElement('div'), w = this.itemsNode
                            && this.itemsNode.clientWidth - 8;
                    f.className = 'flag-container';
                    f.style.left = (w > 0 ? w : 0) + 'px';
                    f.innerHTML = '<div class="dirty-cell"/>';
                    d.insertBefore(f, c);
                }
            }
        });
}());

(function () {
    mstrmojo.requiresCls("mstrmojo.graph._MobileGraphAreaHelper",
                         "mstrmojo.GraphBase",
                         "mstrmojo.dom");

    
    var ANIMATION_DURATION = 0,
        INITIAL_TIME = 0,
        
        InsUndefined = 0,
        InsSaveState = 1,
        InsRestoreState = 2,
        InsClip = 11,
        InsScale = 12,
        InsRotate = 13,
        InsNewPath = 101,
        InsClosePath = 102,
        InsMoveTo = 111,
        InsLineTo = 112,
        InsBezierCurveTo = 113,
        InsAddRect = 121,
        InsAddArc = 122,
        InsAddNeedle = 131,
        InsAddGaugeMarker = 132,
        InsAddString = 201,
        InsSetLineDash = 301,
        InsSetLineWidth = 302,
        InsSetLineJoin = 303,
        InsSetFontSize = 311,
        InsSetRGBAFillColor = 321,
        InsSetRGBAStrokeColor = 322,
        InsFillPath = 401,
        InsStrokePath = 402,
        InsFillSimple = 501,
        InsFillPattern = 502,
        InsFillGradient = 503,
        InsFillEdgeType = 511,
        InsFillDonutOrSphere= 512,
        InsFillRadientGradient = 513,
        InsFillDonut2Rect= 514,
        InsFillBorderMetallic = 515,
        InsMakeDarker = 521,
        InsRestoreColor = 522,
        InsApplyLineFormat = 601,
        InsAddFormatedText = 701,
        InsApplyBeveledFrameToRectangle = 801;
    var GradientReserved = 0,
        GradientCircular = 9,
        GradientRectangular = 10,
        GradientLinear = 14;
    var FillBevelNone = 0,
        FillBevelSmoothEdge = 1,
        FillBevelChiselEdge = 2,
        FillBevelDonut = 3,
        FillBevelSphere = 4;
    var RGPieSlice = 0,
        RGRing = 1,
        RG_BORDERRING = 2;
    var BSS_METALLIC_OUTER_RING = 2,
        BSS_METALLIC_MIDDLE_RING = 3;
    var FillSimple = 0,
        FillWash = 3,
        FillPicture = 4,
        FillUserPicture = 6,
        FillBrush = 13,
        FillAdvancedWash = 14,
        FillPattern = 101;
    var LineJoinMiter = 0,
        LineJoinBevel = 1,
        LineJoinRound = 2;
    var PI = 3.14159265;
    var startPoint,endPoint;
    var MS_Rectangle = 0,
        MS_XShape = 1,
        MS_PlusSymbolthin = 2,
        MS_PlusSymbolthick = 3,
        MS_Circle = 4,
        MS_Diamond = 5,
        MS_Triangle = 6,
        MS_Square = 7,
        MS_Star = 8,
        MS_Area = 9;
    var gLocalMarkerSize = 100;
    var gMarkerShapes = [
        [-100, -100, 100, -100, 100, 100, -100, 100],
        [-80, -100, 0, -20, 80, -100, 100, -80, 20, 0, 100, 80, 80, 100, 0, 20, -80, 100, -100, 80, -20, 0, -100, -80],
        [-33, -100, 33, -100, 33, -33, 100, -33, 100, 33, 33, 33, 33, 100, -33, 100, -33, 33, -100, 33, -100, -33, -33, -33],
        [-50, -100, 50, -100, 50, -50, 100, -50, 100, 50, 50, 50, 50, 100, -50, 100, -50, 50, -100, 50, -100, -50, -50, -50],
        [],
        [0, -100, 100, 0, 0, 100, -100, 0],
        [0, -100, 100, 100, -100, 100],
        [-100, -100, 100, -100, 100, 100, -100, 100],
        [0, -100, 23, -31, 95, -31, 36, 12, 59, 81, 0, 38, -59, 81, -36, 12, -95, -31, -23, -31],
        [0, -60, 100, -100, 100, 100, -100, 100, -100, -100, 0, -60, 0, 100]
    ];

    function drawWithContext(context, progress, unit, formatList){
        var insList = unit.InstructionList,
            insCount = insList.length,
            ins, j, x, y, h, w, format, color, formatIndex,
            gradient, startColor, endColor,
            rect, finalGradient, bevel, isCircularShape, darker;

        for (j = 0; j < insCount; j++)
        {
            
            ins = insList[j];

            
            if (typeof(ins) === 'undefined') {
                
                continue;
            }

            
            switch (ins.Ins) {
                case InsUndefined:
                    
                    break;
                case InsSaveState:
                    context.save();
                    break;
                case InsRestoreState:
                    context.restore();
                    break;
                case InsClip:
                    context.clip();
                    break;
                case InsScale:
                    context.scale(ins.X, ins.Y);
                    break;
                case InsRotate:
                    if (ins.Radian !== 0) {
                        context.translate(ins.Anchor.X, ins.Anchor.Y);
                        context.rotate(ins.Radian);
                        context.translate(-ins.Anchor.X, -ins.Anchor.Y);
                    }
                    break;
                case InsNewPath:
                    context.beginPath();
                    break;
                case InsClosePath:
                    context.closePath();
                    break;
                case InsMoveTo:
                    if (unit.IsAnimated === 0) {
                        context.moveTo(ins.X, ins.Y);
                    } else {
                        if (ins.CA[0] == 0) {
                            x = ins.X[0] * (1 - progress) + ins.X[1] * progress;
                            y = ins.Y[0] * (1 - progress) + ins.Y[1] * progress;
                            context.moveTo(x, y);
                        } else {
                            var r1 = Math.sqrt((ins.X[0]-ins.BPX[0])*(ins.X[0]-ins.BPX[0]) + (ins.Y[0]-ins.BPY[0])*(ins.Y[0]-ins.BPY[0]));
                            var r2 = Math.sqrt((ins.X[1]-ins.BPX[0])*(ins.X[1]-ins.BPX[0]) + (ins.Y[1]-ins.BPY[0])*(ins.Y[1]-ins.BPY[0]));
                            var d = Math.sqrt((ins.X[0]-ins.X[1])*(ins.X[0]-ins.X[1]) + (ins.Y[0]-ins.Y[1])*(ins.Y[0]-ins.Y[1]));
                            var de = Math.acos((r1*r1+r2*r2-d*d)/(2*r1*r2));

                            
                            var lDest = (ins.X[0]-ins.BPX[0]) * Math.cos(de) - (ins.Y[0]-ins.BPY[0]) * Math.sin(de) + ins.BPX[0] - ins.X[1];
                            if (lDest < -0.01 || lDest > 0.01)
                                de = 2*PI - de;

                            x = (ins.X[0]-ins.BPX[0]) * Math.cos(progress*de) - (ins.Y[0]-ins.BPY[0]) * Math.sin(progress*de) + ins.BPX[0];
                            y = (ins.Y[0]-ins.BPY[0]) * Math.cos(progress*de) + (ins.X[0]-ins.BPX[0]) * Math.sin(progress*de) + ins.BPY[0];
                            context.moveTo(x, y);
                        }
                    }
                    break;
                case InsLineTo:
                    if (unit.IsAnimated === 0) {
                        context.lineTo(ins.X, ins.Y);
                    } else {
                        if (ins.CA[0] == 0) {
                            x = ins.X[0] * (1 - progress) + ins.X[1] * progress;
                            y = ins.Y[0] * (1 - progress) + ins.Y[1] * progress;
                            context.lineTo(x, y);
                        } else {
                            var r1 = Math.sqrt((ins.X[0]-ins.BPX[0])*(ins.X[0]-ins.BPX[0]) + (ins.Y[0]-ins.BPY[0])*(ins.Y[0]-ins.BPY[0]));
                            var r2 = Math.sqrt((ins.X[1]-ins.BPX[0])*(ins.X[1]-ins.BPX[0]) + (ins.Y[1]-ins.BPY[0])*(ins.Y[1]-ins.BPY[0]));
                            var d = Math.sqrt((ins.X[0]-ins.X[1])*(ins.X[0]-ins.X[1]) + (ins.Y[0]-ins.Y[1])*(ins.Y[0]-ins.Y[1]));
                            var de = Math.acos((r1*r1+r2*r2-d*d)/(2*r1*r2));
                            
                            
                            var lDest = (ins.X[0]-ins.BPX[0]) * Math.cos(de) - (ins.Y[0]-ins.BPY[0]) * Math.sin(de) + ins.BPX[0] - ins.X[1];
                            if (lDest < -0.02 || lDest > 0.02)
                                de = 2*PI - de;
                                
                            x = (ins.X[0]-ins.BPX[0]) * Math.cos(progress*de) - (ins.Y[0]-ins.BPY[0]) * Math.sin(progress*de) + ins.BPX[0];
                            y = (ins.Y[0]-ins.BPY[0]) * Math.cos(progress*de) + (ins.X[0]-ins.BPX[0]) * Math.sin(progress*de) + ins.BPY[0];
                            context.lineTo(x, y);
                        }
                    }
                    break;
                case InsBezierCurveTo:
                    if (unit.IsAnimated === 0) {
                        context.bezierCurveTo(ins.CP1X, ins.CP1Y, ins.CP2X, ins.CP2Y, ins.X, ins.Y);
                    } else {
                        cp1x = ins.CP1X[0] * (1 - progress) + ins.CP1X[1] * progress;
                        cp1y = ins.CP1Y[0] * (1 - progress) + ins.CP1Y[1] * progress;
                        cp2x = ins.CP2X[0] * (1 - progress) + ins.CP2X[1] * progress;
                        cp2y = ins.CP2Y[0] * (1 - progress) + ins.CP2Y[1] * progress;
                        x = ins.X[0] * (1 - progress) + ins.X[1] * progress;
                        y = ins.Y[0] * (1 - progress) + ins.Y[1] * progress;
                        context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                    }
                    break;
                case InsAddRect:
                    if (unit.IsAnimated === 0) {
                        context.rect(ins.X, ins.Y, ins.W, ins.H);
                    } else {
                        x = ins.X[0] * (1 - progress) + ins.X[1] * progress;
                        y = ins.Y[0] * (1 - progress) + ins.Y[1] * progress;
                        w = ins.W[0] * (1 - progress) + ins.W[1] * progress;
                        h = ins.H[0] * (1 - progress) + ins.H[1] * progress;
                        context.rect(x, y, w, h);
                    }
                    break;
                case InsAddArc:
                    if (unit.IsAnimated === 0) {
                        if (ins.EndAngle == 6.283) 
                         ins.EndAngle = 2*PI;
                        context.arc(ins.X, ins.Y, ins.Radius, ins.StartAngle, ins.EndAngle, ins.AntiClockwise);
                    } else {
                        if (ins.EndAngle[0] == 6.283) 
                         ins.EndAngle[0] = 2*PI;
                        if (ins.EndAngle[1] == 6.283) 
                         ins.EndAngle[1] = 2*PI;

                        context.arc(ins.X[0] * (1 - progress) + ins.X[1] * progress,
                                    ins.Y[0] * (1 - progress) + ins.Y[1] * progress,
                                    ins.Radius[0] * (1 - progress) + ins.Radius[1] * progress,
                                    ins.StartAngle[0] * (1 - progress) + ins.StartAngle[1] * progress,
                                    ins.EndAngle[0] * (1 - progress) + ins.EndAngle[1] * progress,
                                    ins.AntiClockwise[0]);
                    }
                    break;
                case InsAddGaugeMarker:
                    if (unit.IsAnimated == 1)
                    {
                        var angle = ins.Angle[0] * (1 - progress) + ins.Angle[1] * progress;
                        var lSize = ins.NeedleSize[0];
                        var bPX = ins.BPX[0];
                        var bPY = ins.BPY[0];
                        var markerSize = ins.MarkSize[0];
                        var markerShape = ins.MarkShape[0];

                        var lMarkerPostion = {X:lSize*Math.cos(angle)+bPX, Y:lSize*Math.sin(angle)*-1+bPY};
                        var lPolygon = hGetClockwisePolygon(markerShape, lMarkerPostion, markerSize);
                        hDrawPolygon(context, lPolygon, false, false);
                        
                    }
                    break;
                case InsAddString:
                case InsSetLineDash:
                    
                    break;

                case InsSetLineWidth:
                    context.lineWidth = ins.LineWidth;
                    break;

                case InsSetLineJoin:
                    switch(ins.Type)
                    {
                    case LineJoinMiter:
                        context.lineJoin = 'miter';
                        break;
                    case LineJoinBevel:
                        context.lineJoin = 'bevel';
                        break;
                    case LineJoinRound:
                        context.lineJoin = 'round';
                        break;
                    }
                    break;
                case InsSetFontSize:
                case InsSetRGBAFillColor:
                case InsSetRGBAStrokeColor:
                    
                    break;

                case InsFillPath:
                    context.fill();
                    break;

                case InsStrokePath:
                    context.stroke();
                    break;

                case InsFillSimple:
                    formatIndex = ins.Format;
                    format = formatList[formatIndex];
                    if(ins.HEP == 1)
                      color = ins.FC;
                    else
                        color = format.SimpleColor;
                    context.fillStyle = "RGBA(" + Math.round(color.R * ins.DarkerFactor) + ", " + Math.round(color.G * ins.DarkerFactor) + ", " + Math.round(color.B * ins.DarkerFactor) + ", " + format.Alpha / 255.0 + ");";
                    context.fill();
                    break;

                case InsFillPattern:
                    break;
                case InsFillGradient:
                    if (unit.IsAnimated === 0) {
                        rect = ins.BoundingRect;
                        darker = ins.DarkerFactor;
                    }
                    else {
                        rect = ins.BoundingRect[0];
                        darker = ins.DarkerFactor[0];
                        var rect2 = ins.BoundingRect[1];
                        rect.X = rect.X * (1-progress) + rect2.X * progress;
                        rect.Y = rect.Y * (1-progress) + rect2.Y * progress;
                        rect.Width = rect.Width * (1-progress) + rect2.Width * progress;
                        rect.Height = rect.Height * (1-progress) + rect2.Height * progress;
                    }
                    if (rect.Width < 1 || rect.Height < 1)
                        continue;

                    rect.Width = Math.floor(rect.Width);
                    rect.Height = Math.floor(rect.Height);

                    var format = formatList[ins.Format];
                    
                    
                    if (format.Bevel.FillBevelType != FillBevelSphere || progress < 1)
                    {
                        fillGradient(context, format, rect, darker);
                    }
                    else
                    {
                        
                        addCompensativeLayer(context, format);
                        
                        
                        
                        fillGradient(context, format, rect, darker);
                        
                    }

                    break;
                case InsFillEdgeType:
                    
                    format = formatList[ins.Format];
                    bevel = format.Bevel;

                    lPolygon = hRemoveZeroEdgeInPolygon(ins.Polygon);

                    var lInitialPolygonSize = lPolygon.length;
                    var lInitialPolygon = [];
                    for (var i = 0; i < lInitialPolygonSize; i++)
                        lInitialPolygon.push(lPolygon[i]);

                    while(true)
                    {
                        lInitialPolygonSize = lInitialPolygon.length;
                        if (lInitialPolygonSize < 3)
                            break;

                        var lFirstPolygon = [];
                        var lSecondPolygon = [];
                        var lDivided = false;
                        if(lInitialPolygonSize > 3)
                        {
                            var lIntersectionPoint = { X:0, Y:0 };

                            for(var i = 0; ((i < (lInitialPolygonSize - 2)) && (!lDivided)); ++i)
                            {
                                for(var k = i + 2; k < (lInitialPolygonSize - 1); ++k)
                                {
                                    var rt = hLineInterSection(lInitialPolygon[i], lInitialPolygon[i+1], lInitialPolygon[k], lInitialPolygon[k+1], lIntersectionPoint, false);
                                    lIntersectionPoint = rt.interSection;
                                    if(rt.val == 1)
                                    {
                                        lDivided = true;
                                        
                                        for(m = 0; m <= i; ++m)
                                        {
                                            if (!hIsFPointsEqual(lInitialPolygon[m], lIntersectionPoint))
                                                lFirstPolygon.push(lInitialPolygon[m]);
                                        }
                                        lFirstPolygon.push(lIntersectionPoint);
                                        for(m = k + 1; m < lInitialPolygonSize; ++m)
                                        {
                                            if (!hIsFPointsEqual(lInitialPolygon[m], lIntersectionPoint))
                                                lFirstPolygon.push(lInitialPolygon[m]);
                                        }
                                        
                                        lSecondPolygon.push(lIntersectionPoint);
                                        for(m = k; m > i; --m)
                                        {
                                            if (!hIsFPointsEqual(lInitialPolygon[m], lIntersectionPoint))
                                                lSecondPolygon.push(lInitialPolygon[m]);
                                        }
                                        break;
                                    }
                                }

                                
                                if((i != 0) && (!lDivided))
                                {
                                    var rt = hLineInterSection(lInitialPolygon[i], lInitialPolygon[i+1], lInitialPolygon[0], lInitialPolygon[lInitialPolygonSize-1], lIntersectionPoint, false);
                                    lIntersectionPoint = rt.interSection;
                                    if(rt.val == 1)
                                    {
                                        for(m = 0; m <= i; ++m)
                                            lFirstPolygon.push(lInitialPolygon[m]);
                                        lFirstPolygon.push(lIntersectionPoint);
                                        
                                        lSecondPolygon.push(lIntersectionPoint);
                                        for(m = lInitialPolygonSize - 1; m > i; --m)
                                            lSecondPolygon.push(lInitialPolygon[m]);
                                        lDivided = true;
                                    }
                                }
                            }
                        }

                        if(!lDivided)
                            lFirstPolygon = lInitialPolygon;

                        
                        var lDepth = 0.0;
                        var lRt = hGetAreaDepth(lFirstPolygon, lDepth);
                        lDepth = lRt.depth;
                        if (!lRt.mark)
                            break;
                        lDepth *= bevel.Depth * 0.01;
                        
                        var lNormalStart = [];
                        var lNormalEnd = [];
                        var lFirstPolygonSize = lFirstPolygon.length;
                        for(var i = 0; i < lFirstPolygonSize; ++i)
                        {
                            var lPointStart;
                            var lPointEnd;
                            var lRt = hGetAngularBisectorIntersectionPoint(lFirstPolygon[(i+lFirstPolygonSize-1) % lFirstPolygonSize], lFirstPolygon[i],
                                        lFirstPolygon[(i+1) % lFirstPolygonSize], lDepth);
                            lPointStart = lRt.start;
                            lPointEnd = lRt.end;

                            lNormalStart.push(lPointStart);
                            lNormalEnd.push(lPointEnd);
                        }

                        
                        
                        for(var i = 0; i < lFirstPolygonSize; ++i)
                        {
                            var lVectorNormalLine = {X:lNormalEnd[i].X - lNormalStart[i].X, Y:lNormalEnd[i].Y - lNormalStart[i].Y};
                            var lLengthNormalLine = Math.sqrt(hLengthSquared(lVectorNormalLine));
                            var lVectorUnitNormalLine = {X:lVectorNormalLine.X / lLengthNormalLine, Y:lVectorNormalLine.Y / lLengthNormalLine};
                            
                            var lAngleReflectedLight = degreeToRadian((540 - bevel.LightAngle) % 360);
                            var lVectorUnitLight = {X:Math.cos(lAngleReflectedLight), Y:Math.sin(lAngleReflectedLight)};
                            var lTemp = hInnerProduct(lVectorUnitNormalLine, lVectorUnitLight);

                            var lColorRGB = 0.0;
                            var lTransparency = 0.0;
                            
                            var lFactor = 0.1;
                            var lTransparencyFactor = 0.2;
                            if(lTemp < -0.01)
                            {
                                lColorRGB = (1.0 + lTemp) * lFactor;
                                lTransparency = (1.0 + Math.abs(lTemp)) * lTransparencyFactor * bevel.Intensity * 0.01;
                            }
                            else
                            {
                                lColorRGB = (1.0 - lFactor) + lTemp * lFactor;
                                lTransparency = ((1.0 - lTransparencyFactor) + lTemp * lTransparencyFactor) * bevel.Intensity * 0.01;
                            }
                            var lNext = i + 1;
                            if(lNext == lFirstPolygonSize)
                                lNext -= lFirstPolygonSize;

                            context.beginPath();
                            context.moveTo(lFirstPolygon[i].X, lFirstPolygon[i].Y);
                            context.lineTo(lFirstPolygon[lNext].X, lFirstPolygon[lNext].Y);
                            context.lineTo(lNormalStart[lNext].X, lNormalStart[lNext].Y);
                            context.lineTo(lNormalStart[i].X, lNormalStart[i].Y);
                            context.closePath();

                            var R = Math.round(lColorRGB*255);
                            if (isNaN(R))  
                                continue;

                            if(bevel.FillBevelType == FillBevelSmoothEdge)
                            {
                                context.save();
                                context.clip();
                                var lLinearGrad = context.createLinearGradient(lNormalEnd[i].X, lNormalEnd[i].Y, lNormalStart[i].X, lNormalStart[i].Y);


                                lLinearGrad.addColorStop(0, 'rgba(' + R + ',' + R +',' + R +',' + lTransparency + ')');
                                lLinearGrad.addColorStop(1, 'rgba(' + R + ',' + R +',' + R +',' + 0 + ')');

                                 context.fillStyle = lLinearGrad;
                                 context.fill();
                                 context.restore();
                            }
                            else
                            {
                                context.fillStyle = "RGBA(" + R + ", " + R + ", " + R + ", " + lTransparency + ");";
                                context.fill();
                            }


                        }
                        if(lDivided)
                        {
                            lInitialPolygon = lSecondPolygon;
                        }
                        else
                            break;
                    }

                    
                    if (lPolygon.length != 0)
                    {
                        context.beginPath();
                        context.moveTo(lPolygon[0].X, lPolygon[0].Y);
                        for (var i = 1; i < lPolygon.length; ++i)
                        {
                            context.lineTo(lPolygon[i].X, lPolygon[i].Y);
                        }
                        context.closePath();
                    }
                    break;
                case InsFillDonutOrSphere:
                    format = formatList[ins.Format];
                    bevel = format.Bevel;
                    if (unit.IsAnimated === 0) {
                        rect = ins.BoundingRect;
                        isCircularShape = ins.IsCircularShape;
                    }
                    else {
                        var rect1 = ins.BoundingRect[0];
                        var rect2 = ins.BoundingRect[1];
                        rect = {X : 0, Y : 0, Width:0, Height:0};
                        rect.X = rect1.X * (1-progress) + rect2.X * progress;
                        rect.Y = rect1.Y * (1-progress) + rect2.Y * progress;
                        rect.Width = rect1.Width * (1-progress) + rect2.Width * progress;
                        rect.Height = rect1.Height * (1-progress) + rect2.Height * progress;

                    }

                    if (bevel.FillBevelType === FillBevelDonut)
                    {
                        var factor = 0.2;
                        var lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                        var lStop = 1.0 - bevel.Depth * 0.01;

                        finalGradient = context.createLinearGradient(rect.X, rect.Y, rect.X + rect.Width, rect.Y);

                        startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                        endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                        finalGradient.addColorStop(0, startColor);
                        finalGradient.addColorStop(lStop * factor, startColor);
                        finalGradient.addColorStop(lStop, endColor);
                        finalGradient.addColorStop(1, startColor);
                    }
                    else
                    {
                        startColor = format.SimpleColor;
                        var lCenterPoint = {x: rect.X + rect.Width / 2, y : rect.Y + rect.Height / 2};

                        startPoint = {x : 0, y : 0};
                        endPoint = {x : 0, y : 0};
                        hRatioInRectangle(rect, bevel.LightAngle, lCenterPoint); 

                        var lFillAlpha = format.Alpha / 255.0;
                        var lNewAlpha = lFillAlpha;
                        if (format.FillType != FillSimple)
                        {
                            lFillAlpha *= 0.8;
                            lNewAlpha *= 0.5;
                            startColor = {R : 128, G : 128, B : 128};
                        }

                        var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                        lLinearGrad.addColorStop(0, 'rgba(255,255,255,' + lFillAlpha + ')');
                        lLinearGrad.addColorStop(0.05 + bevel.Intensity * 0.001, 'rgba(255,255,255,' + 9 * lFillAlpha / (10 - lFillAlpha) + ')');
                        lLinearGrad.addColorStop(0.5, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',' + lNewAlpha + ')');
                        lLinearGrad.addColorStop(0.85 + (1.0 - bevel.Intensity * 0.01) * 0.05, 'rgba(0,0,0,' + 9 * lFillAlpha / (10 - lFillAlpha) + ')');
                        lLinearGrad.addColorStop(1, 'rgba(0,0,0,' + lFillAlpha + ')');

                        context.fillStyle = lLinearGrad;
                        context.fill();

                        if (format.FillType != FillSimple)
                            continue;

                        var lRadius = Math.max(rect.Width, rect.Height) * 0.5 * (2.0 - bevel.Intensity * 0.01);
                        lRadius *= isCircularShape ? 0.75 : 2;

                        
                        finalGradient = context.createRadialGradient(lCenterPoint.x, lCenterPoint.y, 0, lCenterPoint.x, lCenterPoint.y, lRadius);

                        finalGradient.addColorStop(0, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',' + lFillAlpha + ')');
                        finalGradient.addColorStop(0.5, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',' + lFillAlpha / 2 + ')');
                        finalGradient.addColorStop(0.8, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',' + lFillAlpha / 10 + ')');
                        finalGradient.addColorStop(1, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',0)');
                    }
                    context.fillStyle = finalGradient;
                    context.fill();

                    break;
                case InsFillBorderMetallic:
                    format = formatList[ins.Format];
                    bevel = format.Bevel;

                    var CX = ins.CX;
                    var CY = ins.CY;
                    var mRadius = ins.Radius;
                    var lRadius;
                    var lAlpha;

                    switch(ins.BorderUse)
                    {
                        case BSS_METALLIC_OUTER_RING:
                            lAlpha = 0.4;
                            startPoint = {x : CX + mRadius * Math.cos(PI * 1.25), y : CY + mRadius * Math.sin(PI * 1.25)};
                            endPoint = {x : CX + mRadius * Math.cos(PI * 0.25), y : CY + mRadius * Math.sin(PI * 0.25)};

                            context.save();
                            context.clip();
                            var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                            lLinearGrad.addColorStop(0, 'rgba(0,0,0,' + lAlpha + ')');
                            lLinearGrad.addColorStop(1, 'rgba(255,255,255,' + lAlpha + ')');

                            context.fillStyle = lLinearGrad;
                            context.fill();
                            context.restore();

                            lAlpha = 0.4;
                            lRadius = mRadius * 0.3;
                            color = format.SimpleColor;
                            startPoint = {x : CX + lRadius * Math.cos(PI * 0.75), y : CY + lRadius * Math.sin(PI * 0.75)};
                            endPoint = {x : CX + lRadius * Math.cos(PI * 1.75), y : CY + lRadius * Math.sin(PI * 1.75)};

                            context.save();
                            context.clip();
                            var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                            lLinearGrad.addColorStop(0, 'rgba(' + color.R + ',' + color.G +',' + color.B +',' + 0.0 + ')');
                            lLinearGrad.addColorStop(0.2, 'rgba(' + color.R + ',' + color.G +',' + color.B +',' + 1.0 + ')');
                            lLinearGrad.addColorStop(0.8, 'rgba(' + color.R + ',' + color.G +',' + color.B +',' + 1.0 + ')');
                            lLinearGrad.addColorStop(1, 'rgba(' + color.R + ',' + color.G +',' + color.B +',' + 0.0 + ')');

                            context.fillStyle = lLinearGrad;
                            context.fill();
                            context.restore();
                            break;
                        case BSS_METALLIC_MIDDLE_RING:
                            lAlpha = 0.6;
                            lRadius = mRadius* 0.2;
                            var lStop = 0.3;
                            startPoint = {x : CX + lRadius * Math.cos(PI * 1.25), y : CY + lRadius * Math.sin(PI * 1.25)};
                            endPoint = {x : CX + mRadius * Math.cos(PI * 0.25), y : CY + mRadius * Math.sin(PI * 0.25)};

                            context.save();
                            context.clip();
                            var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                            lLinearGrad.addColorStop(0, 'rgba(255,255,255,' + lAlpha + ')');
                            lLinearGrad.addColorStop(lStop, 'rgba(0,0,0,' + lAlpha + ')');
                            lLinearGrad.addColorStop(1, 'rgba(255,255,255,' + lAlpha + ')');

                            context.fillStyle = lLinearGrad;
                            context.fill();
                            context.restore();
                            break;
                        default:
                            lAlpha = 0.4;
                            lRadius = mRadius- ins.Thickness;
                            startPoint = {x : CX + lRadius * Math.cos(PI * 1.25), y : CY + lRadius * Math.sin(PI * 1.25)};
                            endPoint = {x : CX + lRadius * Math.cos(PI * 0.25), y : CY + lRadius * Math.sin(PI * 0.25)};

                            context.save();
                            context.clip();
                            var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                            lLinearGrad.addColorStop(0, 'rgba(0,0,0,' + lAlpha + ')');
                            lLinearGrad.addColorStop(1, 'rgba(255,255,255,' + lAlpha + ')');

                            context.fillStyle = lLinearGrad;
                            context.fill();
                            context.restore();
                            break;
                    }
                    break;
                case InsFillRadientGradient:
                    format = formatList[ins.Format];
                    bevel = format.Bevel;

                    var lAlpha;
                    var lStop;
                    var CX;
                    var CY;
                    var innerRadius;
                    var outerRadius;
                    var lUsage;
                    var lExtraPara;
                    var lExtraDepth;
                    var lExtraIntensity;

                    if (unit.IsAnimated === 0) {
                        CX = ins.CX;
                        CY = ins.CY;
                        innerRadius = ins.InnerRadius;
                        outerRadius = ins.OuterRadius;
                        lUsage = ins.RGUsage;
                        lExtraPara = ins.HEP;
                        if (lExtraPara == 1)
                        {
                            lExtraDepth = ins.ExtraDepth;
                            lExtraIntensity = ins.ExtraIntensity;
                        }
                    } else {
                        CX = ins.CX[0] * (1 - progress) + ins.CX[1] * progress;
                        CY = ins.CY[0] * (1 - progress) + ins.CY[1] * progress;
                        innerRadius = ins.InnerRadius[0];
                        outerRadius = ins.OuterRadius[0];
                        lUsage = ins.RGUsage[0];
                        lExtraPara = ins.HEP[0];
                        if (lExtraPara == 1)
                        {
                            lExtraDepth = ins.ExtraDepth[0];
                            lExtraIntensity = ins.ExtraIntensity[0];
                        }
                    }

                    switch(lUsage)
                    {
                        case RGPieSlice:
                            lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                            lStop = 1.0 - bevel.Depth * 0.01;
                            finalGradient = context.createRadialGradient(CX, CY, innerRadius, CX, CY, outerRadius);
                            startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                            endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                            finalGradient.addColorStop(0, startColor);
                            finalGradient.addColorStop(lStop, endColor);
                            finalGradient.addColorStop(1, startColor);

                            context.fillStyle = finalGradient;
                            context.fill();
                            break;
                        case RGRing:
                            lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                            finalGradient = context.createRadialGradient(CX, CY, innerRadius, CX, CY, outerRadius);
                            startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                            endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                            finalGradient.addColorStop(0, startColor);
                            finalGradient.addColorStop(1, endColor);

                            context.fillStyle = finalGradient;
                            context.fill();
                            break;
                        case RG_BORDERRING:
                            if (lExtraPara == 0)
                            {
                                lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                                lStop = bevel.Depth * 0.01;
                            }
                            else
                            {
                                lAlpha = lExtraIntensity * 0.01 * format.Alpha / 255.0;
                                lStop = lExtraDepth * 0.01;
                            }
                            finalGradient = context.createRadialGradient(CX, CY, innerRadius, CX, CY, outerRadius);
                            startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                            endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                            finalGradient.addColorStop(0, startColor);
                            finalGradient.addColorStop(lStop, endColor);
                            finalGradient.addColorStop(1, startColor);

                            context.fillStyle = finalGradient;
                            context.fill();
                            break;
                    }
                    break;
                case InsFillDonut2Rect:
                    format = formatList[ins.Format];
                    bevel = format.Bevel;
                    lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                    lStop = 1.0 - bevel.Depth * 0.01;

                    startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                    endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                    finalGradient = context.createLinearGradient(ins.StartPoint.X, ins.StartPoint.Y, ins.EndPoint.X, ins.EndPoint.Y);
                    finalGradient.addColorStop(0, startColor);
                    finalGradient.addColorStop(lStop, endColor);
                    finalGradient.addColorStop(1, startColor);

                    context.save();
                    context.clip();
                    context.fillStyle = finalGradient;
                    context.fill();
                    context.restore();
                    break;
                case InsMakeDarker:
                case InsRestoreColor:
                    
                    break;

                case InsApplyLineFormat:
                    formatIndex = ins.Format;
                    format = formatList[formatIndex];
                    color = format.Color;
                    context.strokeStyle = "RGBA(" + color.R + ", " + color.G + ", " + color.B + ", " + format.Alpha / 255.0 + ");";
                    context.stroke();
                    break;
                case InsAddFormatedText:
                    formatIndex = ins.Format;
                    format = formatList[formatIndex];
                    color = format.Color;
                    
                    context.font = format.Size + "px " + format.Name;
                    if (format.Style & 0x02)    
                    {
                        context.font = "italic " + context.font;
                    }
                    if (format.Style & 0x01)    
                    {
                        context.font = "bold " + context.font;
                    }
                    context.fillStyle = "RGBA(" + color.R + ", " + color.G + ", " + color.B + ", " + format.Alpha / 255.0 + ");";
                    context.fillText(ins.Text, ins.StartPoint.X, ins.StartPoint.Y);
                    if (format.Style & 0x0C) 
                    {
                        context.beginPath();
                        var textSize = context.measureText(ins.Text);
                        if(format.Style & 0x04) 
                        {
                            context.moveTo(Math.round(ins.StartPoint.X), Math.round(ins.StartPoint.Y));
                            context.lineTo(Math.round(ins.StartPoint.X + textSize.width), Math.round(ins.StartPoint.Y));
                        }
                        if(format.Style & 0x08) 
                        {
                            context.moveTo(Math.round(ins.StartPoint.X), Math.round(ins.StartPoint.Y - format.Size * 0.5));
                            context.lineTo(Math.round(ins.StartPoint.X + textSize.width), Math.round(ins.StartPoint.Y - format.Size * 0.5));
                        }
                        context.strokeStyle = "RGBA(" + color.R + ", " + color.G + ", " + color.B + ", " + format.Alpha / 255.0 + ");";
                        context.lineWidth = Math.round(Math.max(1, format.Size * 3 / 40));
                        context.stroke();
                    }
                    break;

                case InsApplyBeveledFrameToRectangle: 

                    var lRect;
                    if (unit.IsAnimated === 0) {
                        lRect = ins.Rect;
                    }
                    else {
                        lRect = ins.Rect[0];
                        var rect2 = ins.Rect[1];
                        lRect.X = lRect.X * (1-progress) + rect2.X * progress;
                        lRect.Y = lRect.Y * (1-progress) + rect2.Y * progress;
                        lRect.Width = lRect.Width * (1-progress) + rect2.Width * progress;
                        lRect.Height = lRect.Height * (1-progress) + rect2.Height * progress;
                    }

                    var lRotationAngle = ins.RotationAngle;
                    var llBevelDepth = ins.BevelDepth;
                    var lrLTColor = ins.LTColor;
                    var lLTAlpha = ins.LTAlpha;
                    var lrRBColor = ins.RBColor;
                    var lRBAlpha = ins.RBAlpha;
                    var lDeviceAnchor ={X:lRect.X + lRect.Width / 2, Y:lRect.Y + lRect.Height / 2};
                    var lInnerRect = {X:0, Y:0, Width:0, Height:0};
                    lInnerRect.X =  lRect.X;
                    lInnerRect.Y = lRect.Y;
                    lInnerRect.Width = lRect.Width;
                    lInnerRect.Height = lRect.Height;
                    hImplode(lInnerRect, llBevelDepth, llBevelDepth);

                    var lOutterPolygon = [];

                    lOutterPolygon.push(hRotateAndClone({X:lRect.X, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    lOutterPolygon.push(hRotateAndClone({X:lRect.X + lRect.Width, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    lOutterPolygon.push(hRotateAndClone({X:lRect.X + lRect.Width, Y:lRect.Y + lRect.Height}, lDeviceAnchor, lRotationAngle));
                    lOutterPolygon.push(hRotateAndClone({X:lRect.X, Y:lRect.Y + lRect.Height},lDeviceAnchor, lRotationAngle));

                    var lInnterPolygon = [];
                    lInnterPolygon.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lInnterPolygon.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lInnterPolygon.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));
                    lInnterPolygon.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));

                    
                    var lLeftTop = [];
                    lLeftTop.push(hRotateAndClone({X:lRect.X, Y:lRect.Y + lRect.Height}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lRect.X + lRect.Width, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lRect.X, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    hDrawPolygon(context, lLeftTop, false, false);
                    context.fillStyle = "RGBA(" + lrLTColor.R + ", " + lrLTColor.G + ", " + lrLTColor.B + ", " + lLTAlpha / 255.0 + ");";
                    context.fill();

                    
                    var lRightBottom = [];
                    lRightBottom.push(hRotateAndClone({X:lRect.X, Y:lRect.Y + lRect.Height}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lRect.X + lRect.Width, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lRect.X + lRect.Width,Y:lRect.Y + lRect.Height}, lDeviceAnchor, lRotationAngle));
                    hDrawPolygon(context, lRightBottom, false, false);
                    context.fillStyle = "RGBA(" + lrRBColor.R + ", " + lrRBColor.G + ", " + lrRBColor.B + ", " + lRBAlpha / 255.0 + ");";
                    context.fill();

                    context.strokeStyle = "RGBA(230, 230, 230, " + lLTAlpha*0.5 / 255.0 + ");";
                    context.lineWidth = 1;
                    hDrawPolygon(context, lOutterPolygon, true, true);
                    context.stroke();
                    hDrawPolygon(context, lInnterPolygon, true, true);
                    context.stroke();
                    break;
            }
        }
    }

    function hGetRadialAlpha(rr, cc)
    {
        return 1 - ( Math.sqrt((cc - 256) * (cc -  256) + (rr -  256) * (rr -  256)) / (1.5 * 256) );
    }

    function hMoveTo(context, iX, iY, iIsLinePath, iIsLineWidthOdd)
    {
        var lOffset = (iIsLinePath && iIsLineWidthOdd) ? 0.5 : 0.0;
        context.moveTo(iX + lOffset, iY + lOffset);
    }

    function hLineTo(context, iX, iY, iIsLinePath, iIsLineWidthOdd)
    {
        var lOffset = (iIsLinePath && iIsLineWidthOdd) ? 0.5 : 0.0;
        context.lineTo(iX + lOffset, iY + lOffset);
    }

    function hDrawPolyLine(context, irPoints, iIsLinePath, iIsLineWidthOdd)
    {
        var lNumberOfPoints = irPoints.length;
        if(lNumberOfPoints<=0)
            return;
        context.beginPath();
        hMoveTo(context, irPoints[0].X, irPoints[0].Y, iIsLinePath, iIsLineWidthOdd);
        var lPreviousIndex = 0;
        for(i = 1; i < lNumberOfPoints; ++i)
        {
            
            
            
            
                hLineTo(context, irPoints[i].X, irPoints[i].Y, iIsLinePath, iIsLineWidthOdd);
                lPreviousIndex = i;
            
        }
    }

    function hGetMarkerShape(iMarkerShape)
    {
        var opPoints = gMarkerShapes[iMarkerShape];
        var opPointNumber = opPoints.length/2;

        return {number:opPointNumber, points:opPoints};
    }


    function hGetClockwisePolygon(iMarkerShape, mpos, iMarkerSize)
    {
        var mPolygon = [];

        if (iMarkerShape == MS_Circle)
        {
            mPolygon.push({X:mpos.X - iMarkerSize, Y:mpos.Y - iMarkerSize});
            mPolygon.push({X:mpos.X + iMarkerSize, Y:mpos.Y - iMarkerSize});
            mPolygon.push({X:mpos.X + iMarkerSize, Y:mpos.Y + iMarkerSize});
            mPolygon.push({X:mpos.X - iMarkerSize, Y:mpos.Y + iMarkerSize});
            return mPolygon;
        }

        var lPointNumber;
        var lPoints;

        var rt = hGetMarkerShape(iMarkerShape);
        lPointNumber = rt.number;
        lPoints = rt.points;

        for (var i = 0; i < lPointNumber; i++)
        {
            var lx = (lPoints[2 * i]) * iMarkerSize / gLocalMarkerSize + mpos.X;
            var ly = (lPoints[2 * i + 1]) * iMarkerSize / gLocalMarkerSize + mpos.Y;
            mPolygon.push({X:lx, Y:ly});
        }

        return mPolygon;
    }

    function hDrawPolygon(context, irPoints, iIsLinePath, iIsLineWidthOdd)
    {
        var lNumberOfPoints = irPoints.length;
        if(lNumberOfPoints < 3)
            return;

        context.beginPath();
        if (iIsLinePath && iIsLineWidthOdd)
        {
            var lAdjustedPoints = [];
            for(var i = 0; i < lNumberOfPoints; ++i)
            {
                lAdjustedPoints.push(irPoints[i]);
            }

            var lPreviousIndex = lNumberOfPoints - 1;
            for(var i = 0; i < lNumberOfPoints; ++i)
            {
                lNextIndex = (i + 1 == lNumberOfPoints) ? 0 : i + 1;
                if (irPoints[i].X == irPoints[lPreviousIndex].X || irPoints[i].X == irPoints[lNextIndex].X)
                {
                    lAdjustedPoints[i].X += 0.5;
                }
                if (irPoints[i].Y == irPoints[lPreviousIndex].Y || irPoints[i].Y == irPoints[lNextIndex].Y)
                {
                    lAdjustedPoints[i].Y += 0.5;
                }
                lPreviousIndex = i;
            }
            hDrawPolyLine(context, lAdjustedPoints, false, iIsLineWidthOdd);
        }
        else
        {
            hDrawPolyLine(context, irPoints, false, iIsLineWidthOdd);
        }
        context.closePath();
    }

    function hRotate(point, irAnchor, iRadian)
    {
        var lXDist = point.X - irAnchor.X;
        var lYDist = point.Y - irAnchor.Y;

        point.X = irAnchor.X + Math.cos(iRadian) * lXDist - Math.sin(iRadian) * lYDist;
        point.Y = irAnchor.Y + Math.sin(iRadian) * lXDist + Math.cos(iRadian) * lYDist;
        return point;
    }

    function hRotateAndClone(point, irAnchor, iRadian)
    {
        return hRotate(point, irAnchor, iRadian);
    }

    function hImplode(rect, iXOffset, iYOffset)
    {
        if (iXOffset * 2 > rect.Width)
        {
            iXOffset = rect.Width / 2;
        }
        if (iYOffset * 2 > rect.Height)
        {
            iYOffset = rect.Height / 2;
        }

        return hExplode(rect, -iXOffset, -iYOffset);
    }

    function hExplode(rect, iXOffset, iYOffset)
    {
        rect.X -= iXOffset;
        rect.Y -= iYOffset;
        rect.Width += (iXOffset*2);
        rect.Height += (iYOffset*2);
        return rect;
    }

    function hGetTriangleAreaDouble(vectorA, vectorB, vectorC)
    {
        return hCrossProduct(vectorA,vectorB) + hCrossProduct(vectorB, vectorC) + hCrossProduct(vectorC, vectorA);
    }

    function hDistance(vectorA, vectorB)
    {
        return Math.sqrt((vectorA.X - vectorB.X) * (vectorA.X - vectorB.X)
            + (vectorA.Y - vectorB.Y) * (vectorA.Y - vectorB.Y));
    }

    
    function hGetNewPolygon(polygon, iCurrent, oPolygon)
    {
        var rtPolygon = oPolygon;

        var lSize = polygon.length;
        var i = iCurrent;
        var lPointA = polygon[(i + lSize - 1) % lSize];
        var lPointC = polygon[(i + 1) % lSize];
        
        var lIndexAB = 0;
        var lIntersectionAB = {X:0, Y:0};
        var lVectorAB = {X: polygon[iCurrent].X - polygon[(iCurrent + lSize - 1) % lSize].X,
            Y:polygon[iCurrent].Y - polygon[(iCurrent + lSize - 1) % lSize].Y};

        for(var k = (i+2) % lSize; k != i; k = (k + 1) % lSize)
        {
            var j = k - 1;
            if(j < 0)
                j += lSize;
            var lVectorBJ = {X:polygon[j].X - polygon[i].X, Y:polygon[j].Y - polygon[i].Y};
            var lVectorBK = {X:polygon[k].X - polygon[i].X, Y:polygon[k].Y - polygon[i].Y};
            if(hCrossProduct(lVectorAB, lVectorBJ) < 0.01 && hCrossProduct(lVectorAB, lVectorBK) > 0.01)
            {
                
                var rt = hLineInterSection(lPointA, polygon[i], polygon[j], polygon[k], lIntersectionAB, false);
                lIntersectionAB = rt.interSection;
                lIndexAB = k;
                break;
            }
        }

        
        var lIndexCB = 0;
        var lIntersectionCB = {X:0, Y:0};
        var lVectorCB = { X:polygon[iCurrent].X - polygon[(iCurrent + 1) % lSize].X, Y:polygon[iCurrent].Y - polygon[(iCurrent+1) % lSize].Y };
        for(var k = (i + lSize - 2) % lSize; k != i; k = (k - 1 + lSize) % lSize)
        {
            var j = k + 1;
            if(j >= lSize)
                j -= lSize;
            var lVectorBJ = {X:polygon[j].X - polygon[i].X, Y:polygon[j].Y - polygon[i].Y};
            var lVectorBK = {X:polygon[k].X - polygon[i].X, Y:polygon[k].Y - polygon[i].Y};
            if(hCrossProduct(lVectorCB, lVectorBJ) > -0.01 && hCrossProduct(lVectorCB, lVectorBK) < -0.01)
            {
                
                var rt = hLineInterSection(lPointC, polygon[i], polygon[j], polygon[k], lIntersectionCB, false);
                lIntersectionCB = rt.interSection;
                lIndexCB = k;
                break;
            }
        }
        rtPolygon.push(polygon[i]);
        rtPolygon.push(lIntersectionAB);
        for(m = lIndexAB; ; m = (m + 1) % lSize)
        {
            rtPolygon.push(polygon[m]);
            if (m == lIndexCB)
                break;
        }
        rtPolygon.push(lIntersectionCB);

        return rtPolygon;
    }

    
    function hGetNewAreaDepth(polygon, orMaxDepth)
    {
        var lSize = polygon.length;
        if(lSize == 3)
        {
            var lRt = hGetAreaDepth(polygon, orMaxDepth);
            return lRt;
        }
        else
        {
            
            
            
            var lPointA = polygon[lSize - 1];
            var lVectorBC = {X:polygon[1].X - polygon[0].X, Y:polygon[1].Y - polygon[0].Y};
            var lVectorCB = {X:-lVectorBC.X, Y:-lVectorBC.Y};
            var lVectorBA = {X:lPointA.X - polygon[0].X, Y:lPointA.Y - polygon[0].Y};
            var lVectorAB = {X:-lVectorBA.X, Y:-lVectorBA.Y};

            var lIsValid = false;
            var lDepth = 1e10; 
            
            for(var i = 2; i < lSize; ++i)
            {
                var j = i - 1;
                var lVectorJI = {X:polygon[i].X - polygon[j].X, Y:polygon[i].Y - polygon[j].Y};
                if (hCrossProduct(lVectorCB, lVectorJI) < -0.01)
                {
                    
                    var lPoint = {X:0, Y:0};
                    
                    var rt = hLineInterSection(polygon[0], polygon[1], polygon[j], polygon[i], lPoint, false);
                    lPoint = rt.interSection;
                    if(rt.val > 0)
                    {
                        var lVectorBIntersection = {X:lPoint.X - polygon[0].X, Y:lPoint.Y - polygon[0].Y};
                        
                        if(hInnerProduct(lVectorBC, lVectorBIntersection) > 0.01)
                        {
                            
                            var lTempPoint = {X:lPoint.X + lVectorJI.X, Y:lPoint.Y + lVectorJI.Y};
                            var lBisectorPoint = {X:0, Y:0};
                            var lTemp;

                            var lRt = hGetBisectorPointAndDepth(lPointA, polygon[0], lPoint, lTempPoint, lBisectorPoint, lTemp);
                            lBisectorPoint = lRt.point;
                            lTemp = lRt.val;
                            if (lRt.mark)
                            {
                                lIsValid = true;
                                if((lTemp < lDepth) && hPointInRange(lBisectorPoint, polygon[j-1], polygon[j], polygon[i], polygon[(i+1)%lSize]))
                                {
                                    lDepth = lTemp;
                                }
                            }
                        }
                    }
                }
                else if(hCrossProduct(lVectorAB, lVectorJI) < -0.01)
                {
                    
                    var lPoint = {X:0, Y:0};
                    
                    var rt = hLineInterSection(polygon[0], lPointA, polygon[j], polygon[i], lPoint, false);
                    lPoint = rt.interSection;
                    if(rt.val > 0)
                    {
                        var lVectorBIntersection = {X:lPoint.X - polygon[0].X, Y:lPoint.Y - polygon[0].Y};
                        
                        if(hInnerProduct(lVectorBA, lVectorBIntersection) > 0.01)
                        {
                            
                            var lTempPoint = {X:lPoint.x - lVectorJI.x, Y:lPoint.y - lVectorJI.y};
                            var lBisectorPoint = {X:0, Y:0};
                            var lTemp;

                            var lRt = hGetBisectorPointAndDepth(lTempPoint, lPoint, polygon[0], polygon[1], lBisectorPoint, lTemp);
                            lBisectorPoint = lRt.point;
                            lTemp = lRt.val;
                            if (lRt.mark)
                            {
                                lIsValid = true;
                                if((lTemp < lDepth) && hPointInRange(lBisectorPoint, polygon[j-1], polygon[j], polygon[i], polygon[(i+1)%lSize]))
                                {
                                    lDepth = lTemp;
                                } 
                            }
                        } 
                    } 
                } 
            } 
            return {mark:lIsValid, depth:lDepth};
        } 
    }

    function hLengthSquared(vectorA)
    {
        return vectorA.X * vectorA.X + vectorA.Y * vectorA.Y;
    }

    function hGetAngularBisectorIntersectionPoint(vectorA, vectorB, vectorC, depth)
    {
        var lVectorBA = {X:vectorA.X - vectorB.X, Y:vectorA.Y - vectorB.Y};
        var lVectorBC = {X:vectorC.X - vectorB.X, Y:vectorC.Y - vectorB.Y};
        var lLengthBA = Math.sqrt(hLengthSquared(lVectorBA));
        var lLengthBC = Math.sqrt(hLengthSquared(lVectorBC));
        var lVectorUnitBA = {X: lVectorBA.X / lLengthBA, Y:lVectorBA.Y / lLengthBA};
        var lVectorUnitBC = {X:lVectorBC.X / lLengthBC, Y:lVectorBC.Y / lLengthBC};
        var lLength = 0.0;
        if(Math.abs(lVectorUnitBA.X - lVectorUnitBC.X) < 0.01)
        {
            lLength = depth * (lVectorUnitBC.X + lVectorUnitBA.X) / (lVectorUnitBA.Y - lVectorUnitBC.Y);
        }
        else
        {
            lLength = depth * (lVectorUnitBC.Y + lVectorUnitBA.Y) / (lVectorUnitBC.X - lVectorUnitBA.X);
        }
        var oPointEnd = { X:0, Y:0 };
        var oPointStart = { X:0, Y:0 };
        oPointEnd.X = vectorB.X + lLength * lVectorUnitBC.X;
        oPointEnd.Y = vectorB.Y + lLength * lVectorUnitBC.Y;
        oPointStart.X = oPointEnd.X + depth * (-lVectorUnitBC.Y);
        oPointStart.Y = oPointEnd.Y + depth * lVectorUnitBC.X;

        return {start:oPointStart, end:oPointEnd};
    }

    function hIncludedAngle(vectorA, vectorB)
    {
        var lTemp = hInnerProduct(vectorA, vectorB) / (Math.sqrt(hLengthSquared(vectorA) * hLengthSquared(vectorB)));
        lTemp = (lTemp > 1.0) ? 1.0 : lTemp;
        lTemp = (lTemp < -1.0) ? -1.0 : lTemp;
        return Math.acos(lTemp);
    }

    function hPointInRange(irPoint, vectorA, vectorB, vectorC, vectorD)
    {
        
        var lVectorBA = {X:vectorA.X - vectorB.X, Y:vectorA.Y - vectorB.Y};
        var lVectorBC = {X:vectorC.X - vectorB.X, Y:vectorC.Y - vectorB.Y};
        var lAngleABC = radianToDegree(hIncludedAngle(lVectorBA, lVectorBC));
        if(hCrossProduct(lVectorBC, lVectorBA) < -0.01)
            lAngleABC = 360 - lAngleABC;
        var lVectorBPoint = {X:irPoint.X - vectorB.X, Y:irPoint.Y - vectorB.Y};
        var lAnglePointBC = radianToDegree(hIncludedAngle(lVectorBPoint,lVectorBC));
        if(hCrossProduct(lVectorBC, lVectorBPoint) < -0.01)
            lAnglePointBC = 360 - lAnglePointBC;
        if(2 * lAnglePointBC > lAngleABC)
            return false;

        
        var lVectorCB = {X:-lVectorBC.X, Y:-lVectorBC.Y};
        var lVectorCD = {X:vectorD.X - vectorC.X, Y:vectorD.Y - vectorC.Y};
        var lAngleBCD = radianToDegree(hIncludedAngle(lVectorCB, lVectorCD));
        if(hCrossProduct(lVectorCD, lVectorCB) < -0.01)
            lAngleBCD = 360 - lAngleBCD;
        var lVectorCPoint = {X:irPoint.X - vectorC.X, Y:irPoint.Y - vectorC.Y};
        var lAngleBCPoint = radianToDegree(hIncludedAngle(lVectorCB, lVectorCPoint));
        if(hCrossProduct(lVectorCPoint, lVectorCB) < -0.01)
            lAngleBCPoint = 360 - lAngleBCPoint;
        if(2 * lAngleBCPoint > lAngleBCD)
            return false;
        
        return true;
    }

    function hLength(vectorA)
    {
        return Math.sqrt(hLengthSquared(vectorA));
    }

    function hGetBisectorPointAndDepth(vectorA, vectorB, vectorC, vectorD, orBisectorPoint, orDistance)
    {
        var val;
        var mark;

        var lVectorAB = {X:vectorB.X - vectorA.X, Y:vectorB.Y - vectorA.Y};
        var lVectorCD = {X:vectorD.X - vectorC.X, Y:vectorD.Y - vectorC.Y};
        var lVectorBC = {X:vectorC.X - vectorB.X, Y:vectorC.Y - vectorB.Y};
        var lLengthBC = Math.sqrt(hLengthSquared(lVectorBC));
        var lABCrossCD =  hCrossProduct(lVectorAB, lVectorCD);
        if (lABCrossCD > 0.01 || lABCrossCD < -0.01)
        {
            
            
            var lE = {X:0, Y:0};
            var rt = hLineInterSection(vectorA, vectorB, vectorC, vectorD, lE, false);
            lE = rt.interSection;
            var lLengthBE = hDistance(vectorB, lE);
            var lLengthCE = hDistance(vectorC, lE);
            if (lABCrossCD < -0.01)
            {
                
                var lP = lLengthBC + lLengthBE + lLengthCE;
                orBisectorPoint.X = (lLengthCE * vectorB.X + lLengthBE * vectorC.X + lLengthBC * lE.X) / lP;
                orBisectorPoint.Y = (lLengthCE * vectorB.Y + lLengthBE * vectorC.Y + lLengthBC * lE.Y) / lP;
                val = hGetTriangleAreaDouble(vectorB, vectorC, lE) / lP;
                mark = true;
            }
            else 
            {
                
                var lP = lLengthBE + lLengthCE - lLengthBC;
                if(lP < 0.01)
                {
                    var lDepth = 0.0;
                    if(Math.abs(hCrossProduct(lVectorAB, lVectorBC)) < 0.01)
                    {
                        var lVectorCBUnit = {X:-lVectorBC.X / lLengthBC, Y:-lVectorBC.Y / lLengthBC};
                        var lLengthCD = Math.sqrt(hLengthSquared(lVectorCD));
                        var lVectorCDUnit = {X:lVectorCD.X / lLengthCD, Y:lVectorCD.Y / lLengthCD};
                        lDepth = (lVectorCBUnit.Y - lVectorCDUnit.Y) * lLengthBC / (lVectorCBUnit.X + lVectorCDUnit.X);
                        orBisectorPoint.X = vectorB.X + lDepth * lVectorCBUnit.Y;
                        orBisectorPoint.Y = vectorB.Y + lDepth * (-lVectorCBUnit.X);
                    }
                    else
                    {
                        var lVectorBCUnit = {X:lVectorBC.X / lLengthBC, Y:lVectorBC.Y / lLengthBC};
                        var lLengthAB = hLength(lVectorAB);
                        var lVectorBAUnit = {X:-lVectorAB.X / lLengthAB, Y:-lVectorAB.Y / lLengthAB};
                        lDepth = (lVectorBAUnit.Y - lVectorBCUnit.Y) * lLengthBC / (lVectorBAUnit.X + lVectorBCUnit.X);
                        orBisectorPoint.X = vectorC.X + lDepth * (-lVectorBCUnit.Y);
                        orBisectorPoint.Y = vectorC.Y + lDepth * lVectorBCUnit.X;
                    }
                    val = lDepth;
                    mark = true;
                    return {val:val, mark:mark, point:orBisectorPoint};
                }
                orBisectorPoint.X = (lLengthCE * vectorB.X + lLengthBE * vectorC.X - lLengthBC * lE.X) / lP;
                orBisectorPoint.Y = (lLengthCE * vectorB.Y + lLengthBE * vectorC.Y - lLengthBC * lE.Y) / lP;
                val = hGetTriangleAreaDouble(vectorB, lE, vectorC) / lP;
                mark = true;
            }
        }
        else
        {
            

            
            if(Math.abs(hCrossProduct(lVectorAB, lVectorBC)) < 0.01)
            {
                mark = false;
                return {val:val, mark:mark, point:orBisectorPoint};
            }
            var lLengthAB = Math.sqrt(hLengthSquared(lVectorAB));
            var lUnitVectorBA = {X:-lVectorAB.X / lLengthAB, Y:-lVectorAB.Y / lLengthAB };
            orBisectorPoint.X = (vectorB.X + vectorC.X + lLengthBC * lUnitVectorBA.X) / 2;
            orBisectorPoint.Y = (vectorB.Y + vectorC.Y + lLengthBC * lUnitVectorBA.Y) / 2;
            val = hCrossProduct(lVectorBC, lUnitVectorBA) / 2;
            mark = true;
        }

        return {val:val, mark:mark, point:orBisectorPoint};
    }


    function hGetAreaDepth(polygon, orMaxDepth)
    {
        var val = false;

        var lPolygonSize = polygon.length;
        if(lPolygonSize == 3)
        {
            
            var lLengthA = hDistance(polygon[0], polygon[1]);
            var lLengthB = hDistance(polygon[1], polygon[2]);
            var lLengthC = hDistance(polygon[2], polygon[0]);
            var lP = lLengthA + lLengthB + lLengthC;
            orMaxDepth = hGetTriangleAreaDouble(polygon[0], polygon[1], polygon[2]) / lP;
            val = true;
        }
        else
        {
            var lIsValid = false;
            var lDepth = 1e10; 
            for(var i = 0; i < lPolygonSize; ++i)
            {
                var lPointB = polygon[i];
                
                var lPointA = polygon[(i + lPolygonSize - 1) % lPolygonSize];
                var lPointC = polygon[(i + 1) % lPolygonSize];
                var lPointD = polygon[(i + 2) % lPolygonSize];


                var lVectorBA = {X:lPointA.X - lPointB.X, Y:lPointA.Y - lPointB.Y};
                var lVectorBC = {X:lPointC.X - lPointB.X, Y:lPointC.Y - lPointB.Y};
                var lVectorCB = {X:-lVectorBC.X, Y:-lVectorBC.Y};
                var lVectorCD = {X: lPointD.X - lPointC.X, Y:lPointD.Y - lPointC.Y};
                var lBACrossBC = hCrossProduct(lVectorBA, lVectorBC);
                if(lBACrossBC < 0.01) 
                {
                    if(hCrossProduct(lVectorCB, lVectorCD) < 0.01)
                    {
                        var lTempPoint = {X:0, Y:0};
                        var lTemp = 0.0;

                        var lRt = hGetBisectorPointAndDepth(lPointA, lPointB, lPointC, lPointD, lTempPoint, lTemp);
                        lTempPoint = lRt.point;
                        lTemp = lRt.val;
                        if (lRt.mark)
                        {
                            lIsValid = true;
                            lDepth = (lDepth > lTemp) ? lTemp : lDepth;
                        }
                    }
                    
                }
                else if(lBACrossBC > 0.01)
                {
                    var lPolygon = [];
                    lPolygon = hGetNewPolygon(polygon, i, lPolygon);

                    var lRt = hGetNewAreaDepth(lPolygon, lTemp);
                    var lTemp = lRt.depth;
                    if (lRt.mark)
                    {
                        lIsValid = true;
                        lDepth = (lDepth > lTemp) ? lTemp : lDepth;
                    }
                }
                
            }
            orMaxDepth = lDepth;
            val = lIsValid;
        }

        return {mark:val, depth:orMaxDepth};
    }

    function hIsFPointsEqual(vectorA, vectorB)
    {
        return (Math.abs(vectorA.X - vectorB.X) < 0.01 && Math.abs(vectorA.Y - vectorB.Y) < 0.01);
    }

    function hRemoveZeroEdgeInPolygon(polygon)
    {
        var lPolygon = [];
        lPolygon.push(polygon[0]);

        pcount = polygon.length;
        for(var i = 1; i < pcount; i++)
        {
            if (polygon[i-1].X == polygon[i].X && polygon[i-1].Y == polygon[i].Y)
                continue;
            lPolygon.push(polygon[i]);
        }

        var lFinalPolygon = new Array();
        pcount = lPolygon.length;
        for(var i = 0; i < pcount; i++)
        {
            if (i === pcount - 1)
            {
                if (lPolygon[i].X == lPolygon[0].X && lPolygon[i].Y == lPolygon[0].Y)
                    continue;
            }
            lFinalPolygon.push(lPolygon[i]);
        }

        return lFinalPolygon;
    }

    function hIsOnSegment(vectorA, vectorB, vectorC, bExclude)
    {
        var lTolerance = 0.01;
        if (bExclude === false)
            lTolerance = -0.01;

        if (Math.abs(vectorB.X - vectorC.X) < 0.01)
        {
            if (vectorA.Y - vectorB.Y > lTolerance && vectorC.Y - vectorA.Y > lTolerance)
                return true;
            if (vectorA.Y - vectorC.Y > lTolerance && vectorB.Y - vectorA.Y > lTolerance)
                return true;
        }
        else
        {
            if (vectorA.X - vectorB.X > lTolerance && vectorC.X - vectorA.X > lTolerance)
                return true;
            if (vectorA.X - vectorC.X > lTolerance && vectorB.X - vectorA.X > lTolerance)
                return true;
        }

        return false;
    }


    function hLineInterSection(vectorA, vectorB, vectorC, vectorD, vectorSection, bExclude)
    {
        var vectorAB = {X : vectorB.X - vectorA.X, Y : vectorB.Y - vectorA.Y};
        var vectorCD = {X : vectorD.X - vectorC.X, Y : vectorD.Y - vectorC.Y};

        if (Math.abs(hCrossProduct(vectorAB, vectorCD)) < 0.01)
        {
            var vectorAC = {X : vectorC.X - vectorA.X, Y : vectorC.Y - vectorA.Y};
            if (Math.abs(hCrossProduct(vectorAB, vectorAC)) < 0.01)
               return { val:-1, interSection:vectorSection };
            else
               return { val:0, interSection:vectorSection };
        }
        else
        {
            var vectorCA = {X : vectorA.X - vectorC.X, Y : vectorA.Y - vectorC.Y};
            var lS = hCrossProduct(vectorCD, vectorCA)/hCrossProduct(vectorAB, vectorCD);
            vectorSection.X = vectorA.X + lS*vectorAB.X;
            vectorSection.Y = vectorA.Y + lS*vectorAB.Y;
            if (hIsOnSegment(vectorSection, vectorA, vectorB, bExclude)
                    && hIsOnSegment(vectorSection, vectorC, vectorD, bExclude))
                return { val:1, interSection:vectorSection };
            else
                return { val:2, interSection:vectorSection };
        }
    }

    function hRatioInRectangle(rect, angle, anchor)
    {
        var lAngle = angle;
        while (lAngle < 0)
        {
            lAngle += 360;
        }
        while (lAngle >= 360)
        {
            lAngle -= 360;
        }

        var lEdgeRight = rect.X + rect.Width - anchor.x;
        var lEdgeUp = anchor.y - rect.Y;
        var lEdgeLeft = anchor.x - rect.X;
        var lEdgeDown = rect.Y + rect.Height - anchor.y;
        var lRadianAngle = degreeToRadian(lAngle);

        
        var lUnitVectorAngle = {x : Math.cos(lRadianAngle), y : -Math.sin(lRadianAngle)};

        
        
        
        
        
        
        
        var lLengthOF;
        var lNegLengthOE;
        if (lAngle >= 0 && lAngle < 90)
        {
            var lVectorOB = {x : lEdgeRight, y : -lEdgeUp};
            var lVectorOD = {x : -lEdgeLeft, y : lEdgeDown};
            lLengthOF = innerProduct(lVectorOB, lUnitVectorAngle);
            lNegLengthOE = innerProduct(lVectorOD, lUnitVectorAngle);
        }
        else if (lAngle >= 90 && lAngle < 180)
        {
            var lVectorOA = {x : -lEdgeLeft, y : -lEdgeUp};
            var lVectorOC = {x : lEdgeRight, y : lEdgeDown};
            lLengthOF = innerProduct(lVectorOA, lUnitVectorAngle);
            lNegLengthOE = innerProduct(lVectorOC, lUnitVectorAngle);
        }
        else if (lAngle >= 180 && lAngle < 270)
        {
            var lVectorOB = {x : lEdgeRight, y : -lEdgeUp};
            var lVectorOD = {x : -lEdgeLeft, y : lEdgeDown};
            lLengthOF = innerProduct(lVectorOD, lUnitVectorAngle);
            lNegLengthOE = innerProduct(lVectorOB, lUnitVectorAngle);
        }
        else 
        {
            var lVectorOA = {x : -lEdgeLeft, y : -lEdgeUp};
            var lVectorOC = {x : lEdgeRight, y : lEdgeDown};
            lLengthOF = innerProduct(lVectorOC, lUnitVectorAngle);
            lNegLengthOE = innerProduct(lVectorOA, lUnitVectorAngle);
        }

        endPoint.x = anchor.x + lLengthOF * lUnitVectorAngle.x;
        endPoint.y = anchor.y + lLengthOF * lUnitVectorAngle.y;
        startPoint.x = anchor.x + lNegLengthOE * lUnitVectorAngle.x;
        startPoint.y = anchor.y + lNegLengthOE * lUnitVectorAngle.y;
        var lAnchorPercent = -lNegLengthOE / (lLengthOF - lNegLengthOE);
        if (lAnchorPercent < 0)
        {
            lAnchorPercent = 0;
        }
        else if (lAnchorPercent > 1)
        {
            lAnchorPercent = 1;
        }
        return lAnchorPercent;
    }

    function degreeToRadian(degree)
    {
        return degree * PI / 180;
    }

    function radianToDegree(radian)
    {
        return radian * 180 / PI;
    }

    function innerProduct(vector1, vector2)
    {
        return (vector1.x * vector2.x + vector1.y * vector2.y);
    }

    function hInnerProduct(vector1, vector2)
    {
        return (vector1.X * vector2.X + vector1.Y * vector2.Y);
    }

    function hCrossProduct(vector1, vector2)
    {
        return (vector1.X * vector2.Y - vector1.Y * vector2.X);
    }

    function fillGradient(context, format, rect, darkerFactor)
    {
        var gradient = format.Gradient;

        var startColor = "RGBA(" + Math.round(darkerFactor * gradient.StartGraphColor.R) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.G) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.B) + ", " + format.Alpha / 255.0 + ");";
        var endColor = "RGBA(" + Math.round(darkerFactor * gradient.EndGraphColor.R) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.G) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.B) + ", " + gradient.EndAlpha / 255.0 + ");";
        var finalGradient;

        switch (gradient.GradientType)
        {
        case GradientLinear:
            {
                var lHOffset = gradient.HorizontalOffset;
                if ((gradient.Angle > 90 && gradient.Angle < 180) || gradient.Angle > 270)
                {
                    
                    lHOffset = 100 - lHOffset;
                }

                var lAnchorPoint = {x : rect.X + rect.Width * lHOffset / 100,
                        y : rect.Y + rect.Height * gradient.VerticalOffset / 100};
                startPoint = {x : 0, y : 0};
                endPoint = {x : 0, y : 0};
                var lAnchorPercent = hRatioInRectangle(rect, gradient.Angle, lAnchorPoint);

                finalGradient = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                finalGradient.addColorStop(0, endColor);
                finalGradient.addColorStop(lAnchorPercent, startColor);
                finalGradient.addColorStop(1, endColor);

                context.fillStyle = finalGradient;
                context.fill();
            }
            break;

        case GradientCircular:
            {
                var lAnchorPoint = {x : rect.X + rect.Width * gradient.HorizontalOffset / 100,
                        y : rect.Y + rect.Height * gradient.VerticalOffset / 100};
                var lScale = rect.Width * 1.0 / rect.Height;
                lAnchorPoint.y *= lScale;

                finalGradient = context.createRadialGradient(lAnchorPoint.x, lAnchorPoint.y, 0, lAnchorPoint.x, lAnchorPoint.y, rect.Width * 2);
                finalGradient.addColorStop(0, startColor);
                finalGradient.addColorStop(0.5, endColor);
                finalGradient.addColorStop(1, endColor);
                context.fillStyle = finalGradient;

                context.save();
                context.scale(1.0, 1 / lScale);
                context.fill();
                context.restore();
            }
            break;

        case GradientRectangular:
            {
                var lAnchorPoint = {x : rect.X + rect.Width * gradient.HorizontalOffset / 100,
                        y : rect.Y + rect.Height * gradient.VerticalOffset / 100};
                var lAngle = gradient.Angle % 90;
                var lRectAngle = radianToDegree(Math.atan(rect.Height / rect.Width));
                var lTempAngle = 2 * lAngle - lRectAngle * lAngle / 45 + 90 + lRectAngle;

                startPoint = {x : 0, y : 0};
                endPoint = {x : 0, y : 0};
                var lAnchorPercent = hRatioInRectangle(rect, lTempAngle, lAnchorPoint);

                var lGradient = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                startColor = "RGBA(" + Math.round(darkerFactor * gradient.StartGraphColor.R) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.G) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.B) + ", " + format.Alpha / (255.0 * 2 - format.Alpha) + ");";
                endColor = "RGBA(" + Math.round(darkerFactor * gradient.EndGraphColor.R) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.G) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.B) + ", " + gradient.EndAlpha / (255.0 * 2 - gradient.EndAlpha) + ");";
                lGradient.addColorStop(0, endColor);
                lGradient.addColorStop(lAnchorPercent, startColor);
                lGradient.addColorStop(1, endColor);
                context.fillStyle = lGradient;
                context.fill();

                lTempAngle = lRectAngle * lAngle / 45 + 90 - lRectAngle;
                lAnchorPercent = hRatioInRectangle(rect, lTempAngle, lAnchorPoint);

                finalGradient = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                startColor = "RGBA(" + Math.round(darkerFactor * gradient.StartGraphColor.R) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.G) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.B) + ", " + format.Alpha / (255.0 * 2) + ");";
                endColor = "RGBA(" + Math.round(darkerFactor * gradient.EndGraphColor.R) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.G) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.B) + ", " + gradient.EndAlpha / (255.0 * 2) + ");";
                finalGradient.addColorStop(0, endColor);
                finalGradient.addColorStop(lAnchorPercent, startColor);
                finalGradient.addColorStop(1, endColor);
                context.fillStyle = finalGradient;
                context.fill();
            }
            break;
        }
    }

    function addCompensativeLayer(context, format)
    {
        
        
        
        var lFillAlpha = format.Alpha / 255.0;
        context.fillStyle = 'rgba(255,255,255,' + format.Alpha / 255.0 + ')';
        context.fill();
    }


    
    function clearCanvas(context) {
        
        var canvas = context.canvas;

        
        context.clearRect(0, 0, canvas.width, canvas.height);
    }

    function draw(widget) {
        INITIAL_TIME = (new Date()).getTime();
        drawEx(widget);
    }

    function drawEx(widget) {
        var data = widget.graphData,
            unitList = data.UnitList,
            unitCount = unitList.length,
            formatList = data.FormatList,
            cn = widget.graphNode,
            hcn = widget.highlightNode,
            hcontext = hcn.getContext('2d'),
            scn = widget.selectionNode,
            scontext = scn.getContext('2d'),
            context = cn.getContext('2d');

        
        clearCanvas(context);
        clearCanvas(hcontext);
        clearCanvas(scontext);

        
        var t = Math.min(((new Date()).getTime() - INITIAL_TIME) / ANIMATION_DURATION, 1),
            x = (1 - t),
            i;

        
        var progress = 0.3 * t * x * x + 2.7 * x * t * t + t * t * t;

        var isAnimated = 0;
        for (i = 0; i < unitCount; i++) {
            drawWithContext(context, progress, unitList[i], formatList);
            if (unitList[i].IsAnimated !== 0)
            {
                isAnimated = 1;
            }
        }

        
        if (t < 1.0 && isAnimated === 1) {
            
            setTimeout(function() {
                drawEx(widget);
            }, 20);
        }
    }

    
    mstrmojo.graph._CanvasGraph = mstrmojo.provide(
        "mstrmojo.graph._CanvasGraph",

        
        {
            markupString: '<div class="{@cssClassPrefix} {@cssClass}" title="{@tooltip}" style="{@domNodeCssText};">' +
                              '<div class="{@cssClassPrefix}-txt"></div>' +
                              '<canvas id="{@id}" height="{@height}" width="{@width}">' +
                                  '{@unsupportedError}' +
                              '</canvas>' +
                              '{@map}' +
                              '<canvas id="{@id}-highlight" class="mobile-graph-selection-canvas" height="{@height}" width="{@width}" style="position:absolute;top:0;left:0">' +
                              '</canvas>' +
                              '<canvas id="{@id}-highlight" class="' + mstrmojo.GraphBase.canvasCLS + '" height="{@height}" width="{@width}" style="position:relative;top:0;left:0">' +
                              '</canvas>' +
                          '</div>',

            unsupportedError: "This text is displayed if your browser does not support HTML5 Canvas element.",

            markupSlots: {
                graphNode: function () { return this.domNode.childNodes[1]; },
                imgNode: function () { return this.domNode.childNodes[1]; },        
                mapNode: function () { return null; },                              
                textNode: function () { return this.domNode.firstChild; },
                selectionNode: function () { return this.domNode.lastChild.previousSibling;},
                highlightNode: function () { return this.domNode.lastChild; }
            },

            
            graphData: null,

            retrieveGraphSrc: function retrieveGraphSrc(h, w) {
                var graphNode = this.graphNode,
                    highlightNode = this.highlightNode,
                    selectionNode = this.selectionNode,
                    graphData = this.graphData,
                    data = (graphData && graphData.data);

                if(data && data.eg) {
                    var tn = this.textNode,
                        img = this.imgNode;

                    
                    img.style.display = 'none';
                    highlightNode.style.display = 'none';
                    selectionNode.style.display = 'none';

                    
                    tn.innerHTML = data.eg || '';

                    
                    tn.style.display = 'block';
                    
                    tn.className = 'mstrmojo-message';
                } else {
                    
                    var height = graphData.GH ||  parseInt(h, 10),
                        width = graphData.GW || parseInt(w, 10);

                    graphNode.setAttribute('height', height);
                    graphNode.setAttribute('width', width);

                    highlightNode.style.display = 'block';
                    highlightNode.setAttribute('height', height);
                    highlightNode.setAttribute('width', width);

                    highlightNode.style.top = -height + 'px';

                    selectionNode.style.display = 'block';
                    selectionNode.setAttribute('height', height);
                    selectionNode.setAttribute('width', width);

                    
                    this.displayTooltips([], 0, 0);
                    
                    
                    draw(this);

                    if (graphData.Selected) {
                        this.highlightAreaInInit(selectionNode, graphData.Selected);
                    }
                }
            },
            
            unrender: function unrender(ignoreDom) {

                
                this._super(false);
                
            },
          
            invalidate: function invalidate() {
                
                var graphNode = this.graphNode;
                if(graphNode) { 
                    clearCanvas(graphNode.getContext('2d'));
                }
            },
            
            getCaptureDimensions: function getCaptureDimensions() {
            	var graphNode = this.graphNode,
            	    position = mstrmojo.dom.position(this.domNode, true);
            	
            	position.w = graphNode.width;
            	position.h = graphNode.height;
            	
            	return position;
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.GraphBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.graph._MobileGraphAreaHelper");

    
    mstrmojo.MobileGraph = mstrmojo.declare(

        mstrmojo.GraphBase,

        [ mstrmojo._TouchGestures, mstrmojo.graph._MobileGraphAreaHelper ],

        
        {
            scriptClass: "mstrmojo.MobileGraph",

            
            areaMarkup: '<area shape="{@shape}" coords="{@coords}" ttl="{@tooltip}" aid="{@aid}" {@extra}/>',

            cssImageClass: "mstrmojo-ReportGraph",

            setDimensions: function setDimensions(h, w) {
            	if(this.height === h && this.width === w) {
            		return; 
            	}
                
            	this.height = h;
                this.width = w;

                
                if (this.hasRendered) {
                    
                    this.controller.refresh(this);
                }
            },

            preBuildRendering: function preBuildRendering() {
                
                var graphData = this.graphData.gd.g;
                this.as = graphData && graphData.as;

                
                return this._super ? this._super() : true;
            },

            refresh: function refresh() {
                
                this.graphData = this.model.data;

                
                this._super();
            },

            
            retrieveGraphSrc: function retrieveGraphSrc(h, w) {
                var src = "data:image/png;base64," + this.graphData.ib.eb,
                    imgNode = this.imgNode;

                if (imgNode.src !== src) {
                    imgNode.src = src;
                }
            },

            
            getFormats: function getFormats() {
                return {
                    height: this.height,
                    width: this.width,
                    top: 0,
                    left: 0
                };
            },

            touchTap: function touchTap() {
                
                this.displayTooltips([], 0, 0);

                
                var ctrl = this.controller;
                if (ctrl && ctrl.viewTap) {
                    
                    ctrl.viewTap();
                }
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                this.syncTooltips(touch.pageX, touch.pageY);
            },

            touchSelectMove: function touchSelectMove(touch) {
                this.syncTooltips(touch.pageX, touch.pageY);
            },

            setModel: function setModel(model) {
                this._super(model);

                this.setGraphData(model.data);
            },
            
            
            syncTooltips: function syncTooltips(x, y) {
                
                var me = this,
                    pos = mstrmojo.dom.position(me.domNode, true);

                
                x -= pos.x;
                y -= pos.y;

                me.model.getDataService().handleUserSingleTap(-1, "", x, y, false, {
                    success: function (res) {
                        me.displayTooltips(res.Areas, pos.x, pos.y);
                    }
                }); 
            },
            
            setGraphData: function setGraphData(graphData) {
                
                this.graphData = graphData;

                
                this.controller.getPageByTree(false);
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.GraphBase",
                         "mstrmojo._Formattable",
                         "mstrmojo._HasWaitIcon",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo.tooltip");

    var $D = mstrmojo.dom;

    
    function adjustGraphHeight(w) {
        var f = w.getFormats();
        if (!f.width && 'gp' in f) {
            f = f.gp;
        }
        w.resizeForDisplayState(parseInt(f.height, 10), parseInt(f.width, 10), false);
    }

    function _getEventPos(e) {
        




        
        var domNodePosition = $D.position(this.domNode),        
            mousePosition = $D.getMousePosition(e);             
        return {
            x: parseInt(mousePosition.x - domNodePosition.x, 10),
            y: parseInt(mousePosition.y - domNodePosition.y, 10)
        };
    }
    
    
    function getOverlappedItems(e, win) {
    	var t = $D.eventTarget(win, e),
			p = t && t.parentNode,
			c = p && p.children,
			as = [],
			coords = t.getAttribute("coords");
		if (c && !!coords) {
			for (var i = 0; i < c.length; ++i) {
				if (c[i] && c[i].getAttribute && c[i].getAttribute("coords") == coords) {
					as.push(c[i]);
				}
			}
		}
		return as;
    }

    
    mstrmojo.DocXtabGraph = mstrmojo.declare(
        
        mstrmojo.GraphBase,

        
        [ mstrmojo._Formattable, mstrmojo._HasWaitIcon, mstrmojo._IsSelectorTarget ],

        
        {
            scriptClass: "mstrmojo.DocXtabGraph",

            cssClassPrefix: "mstrmojo-DocXtabGraph",

            areaMarkup: '<area shape="{@shape}" coords="{@coords}" ttl="{@tooltip}" aid="{@aid}" onclick="mstrmojo.all[\'{@id}\'].onClickArea(this, event);" onmousemove="mstrmojo.all[\'{@id}\']._updateTooltip(event, self);" {@extra}/>',

            _att: '',

            markupSlots: {
                imgNode: function () { return this.domNode.childNodes[1]; },
                mapNode: function () { return this.domNode.childNodes.length > 2 ? this.domNode.childNodes[2] : null; },
                textNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                domNode: [ 'RW', 'B', 'background-color', 'fx' ]
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? 'block' : 'none'; }
            },

            onClickArea: function onClickArea(elem, e) {
                e = e || window.event;

                var ep = _getEventPos.apply(this, [e]),                               
                    defn = this.defn,
                    domNodePosition = $D.position(this.domNode),        
                    area = this.as[elem.getAttribute('aid')],
                    key = this.k,
                    x = ep.x,
                    y = ep.y,
                    anchor = {                                            
                       getBoundingClientRect: function () {
                        var left = domNodePosition.x + x,
                            top = domNodePosition.y + y;

                        return {
                            left: left,
                            top: top,
                            right: left + 1,
                            bottom: top + 1
                        };
                       }, 
                       
                       w: this 
                	};
                
                this.showInfoWin(area.tks, anchor);

                
                this.model.slice({
                    type: parseInt(defn.t, 10) || mstrmojo.EnumRWUnitType.GRAPH,
                    src: key,
                    ck: defn.ck,
                    gk: key,
                    tks: area.tks,
                    cks: area.cks,
                    sid: this.node.data.sid,
                    x: x,
                    y: y,
                    anchor: anchor,
                    tty: area.tty
                });
            },
            
            showInfoWin: function showInfoWin(tks, anchor) {
            	var m = this.model,
            		ifws = tks && m.getTargetInfoWin(tks);
            	if (ifws && ifws.length) {
            		for (var i = 0;i < ifws.length; i++) {
            			m.showInfoWin(ifws[i], anchor, 'h');
            		}
            	}
            },

            showTooltip: function showTooltip(e, win) {
                this._updateTooltip(e, win);
                var items = getOverlappedItems(e, win);
                if (items && items.length > 1) {
                	
                	mstrmojo.DocXtabGraph.multiTooltip.open(this, e, win, items);
                } else {
                	this._super(e, win);
                }
            },

            
            _updateTooltip: function _updateTooltip(evt, win) {
                this.updatingTooltipHelper($D.eventTarget(win, evt), _getEventPos.apply(this, [evt]));
            },

            hideTooltip: function hideTooltip(e, win) {
                var elem = $D.eventTarget(win, e);
                if (elem.getAttribute('aid') === this.cAreaIdx) {
                    
                    this.cAreaIdx = -1;

                    
                    var items = getOverlappedItems(e, win);
                    if (items && items.length > 1) {
                    	
                    	mstrmojo.DocXtabGraph.multiTooltip.close(this, e, win, items);
                    } else {
                    	this._super(e, win);
                    }
                }
            },

            
            update: function update(node) {
                this.node.data = node.data;
                
                this.as = node.data.as;

                
                var sep = '\u001E',
                    m = this.model,
                    cgbm = m.getCGBMap && m.getCGBMap(),
                    as = this.as || [],
                    i,
                    j;

                for (i = 0; i < as.length; i++) {
                    var a = as[i],
                        cgb = a && a.tgbs;

                    if (cgb) {
                        var cgbs = cgb.split(sep);
                        var keys = {};
                        for (j = 0; j < cgbs.length; j++) {
                            var k = cgbm && cgbm[cgbs[j]];
                            if (k) {    
                                keys[k] = true;
                            } else {    
                                keys[cgbs[j]] = true;
                            }
                        }
                        a.tks = mstrmojo.hash.keyarray(keys).join(sep);
                    }
                }

                
                this.eg = node.data.eg;
            },

            
            retrieveGraphSrc: function retrieveGraphSrc(h, w) {
                
                var src = mstrConfig.taskURL + '?taskId=getRWGraphImage&taskEnv=xhr&__ts__=' + (new Date().getTime()) + '&messageID=' + this.model.mid + '&nodeKey=' + this.k + '&sliceID=' + parseInt(this.node.data.sid, 10) + '&imgType=4' + '&width=' + parseInt(w, 10) + '&height=' + parseInt(h, 10) + '&sessionState=' + mstrApp.sessionState,
                    imgNode = this.imgNode;

                
                if (imgNode.src !== src) {
                    
                    imgNode.src = src;
                }
            },

            resize: function () {
                adjustGraphHeight(this);
            },

            
            resizeForDisplayState: function resizeForDisplayState(h, w, doDom) {
                var f = this.getFormats(),
                    imgNode = this.imgNode;

                
                if (doDom) {
                    var dns = this.domNode.style;

                    
                    dns.top = f.top;
                    dns.left = f.left;
                    dns.height = f.height;
                    dns.width = f.width;
                }

                
                if (imgNode) {
                    imgNode.style.height = h + 'px';
                }

                
                if (!this.eg) {
                    
                    this.retrieveGraphSrc(h, w);
                    if (h) {
                        this.refreshMap();
                    }
                }
            }
        }
    );

    
    
    function getTargetWidth(a) {
    	if (a && a.getAttribute) {
    		var c = a.getAttribute("coords");
    		c = c && c.split(",");
    		if (c && c.length >= 3) {
    			return c[2] - c[0];
    		}
    	}
    	return 0;
    }
    
    
    function getMultiPosition(targetWid) {
    	var p = [],
    		docw = document.body.offsetWidth,
    		doch = document.body.offsetHeight,
    		maxw = 0,
    		maxh = 0,
    		x = ttpList[0] && ttpList[0].domNode ? ttpList[0].domNode.offsetLeft : 0,
    		y = ttpList[0] && ttpList[0].domNode ? ttpList[0].domNode.offsetTop : 0,
    		line = Math.ceil(ttpList.length / 2),
    		margin = 5,
    		originalX = function(x, tpWid) {
				if (x + targetWid + tpWid + margin > docw) {
		    		
		    		return docw - targetWid - tpWid - margin;
		    	} else if (ttpList.length > 1 && x - tpWid - margin < 0) {
		    		
		    		return tpWid + margin;
		    	}
				return x;
			},
			originalY = function(y, tpHeight, line) {
				
				y += tpHeight;
		    	
				var toph = line == 1 ? tpHeight : (line * tpHeight + (line - 1) * margin) / 2;
		    	if (toph > y) {
		    		
		    		return 0;
		    	} else if (toph + y > doch) {
		    		
		    		return doch - toph * 2;
		    	} else {
		    		return y - toph;
		    	}
			};
		
    	for (var i = 0; i < ttpList.length; ++i) {
    		maxw = Math.max(maxw, ttpList[i].containerNode.offsetWidth);
    		maxh = Math.max(maxh, ttpList[i].containerNode.offsetHeight);
    	}
    	x = originalX(x, maxw);
    	y = originalY(y, maxh, line);
    	for (var i = 0; i < ttpList.length; ++i) {
    		if (i % 2 == 0) {
        		p.push({l: x + targetWid + margin, t: y});
    		} else {
    			p.push({l: x - ttpList[i].containerNode.offsetWidth - margin, t: y});
    			y += maxh + margin;
    		}
    	}
    	return p;
    }

    var ttpList = [];
    mstrmojo.DocXtabGraph.multiTooltip = {
    		_posMultiTp: function(multiPos) {
        		for (var i = 0; i < ttpList.length; ++i) {
        			ttpList[i].domNode.style.left = multiPos[i].l + 'px';
        			ttpList[i].domNode.style.top = multiPos[i].t + 'px';
        		}
    		},
    		
            open: function(opener, e, win, as, config) {                
                if (!config) {
                    config = {};
                }
                config.e = e;
                config.win = win;
                var tw = 0;
                if (as && as.length) {
                	tw = getTargetWidth(as[0]);
                }

                for (var i = 0; i < as.length; ++i) {
                	var tp = ttpList[i];
                	if (!tp || !mstrmojo.all[tp.id]) {
                		tp = new mstrmojo.Tooltip();
                		var count = 0,
                			me = this;
                		
                		tp.optimizePos = function() {
                        	count++;
                        	if (count >= ttpList.length) {
                        		count = 0;
                        		me._posMultiTp(getMultiPosition(tw));
                        	}	
                		}; 
                		ttpList.push(tp);
                	}
                	opener.richTooltip.content = as[i] && as[i].getAttribute('ttl');
                	tp.open(opener, config);
                }
            },
            
            close: function() {
            	for (var j = ttpList.length - 1; j >= 0; --j) {
            		ttpList[j].close();
            	}
            	ttpList = [];
            }
    };

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.Slider",
                         "mstrmojo.MetricQualification",
                         "mstrmojo.expr",
                         "mstrmojo.ValidationTextBox",
                         "mstrmojo.array",
                         "mstrmojo.hash");

    mstrmojo.requiresDescs(8153, 8154, 8155, 8156, 8157, 8158, 8159, 8160, 8161, 8162, 8163, 8164, 8165, 8166, 8167, 8168, 8169, 8170, 7839, 587, 2204, 2202, 2203, 7576, 7575, 7622);

    var $D = mstrmojo.dom,
        $HASH = mstrmojo.hash,
        $M = mstrmojo.MCSUtil,
        $DESC = mstrmojo.desc,
        $C = mstrmojo.css,
        $NM = mstrmojo.num,
        $MATH = Math,
        $MATH_MAX = $MATH.max,
        $MATH_MIN = $MATH.min,
        $MATH_FLOOR = $MATH.floor,
        $MATH_ROUND = $MATH.round;

    
    function positionSliderElements(slider, ui, handle1, handle2) {
        var px = 'px',
            effectiveLength = slider._length,                   
            handleSize = slider.handleSize,
            orCfg = slider.orCfg,
            position = orCfg.posCssP,
            length = orCfg.lenCssP;

        
        handle1 = $MATH_MAX(handle1, -1);
        handle2 = $MATH_MIN(handle2, effectiveLength);

        
        var min = $MATH_MIN(handle1, handle2),
            max = $MATH_MAX(handle1, handle2),
            thumbLength = max - min,
            upperLength = $MATH_MAX(parseInt(slider[length], 10) - (2 * slider.cssBkBW) - (max + handleSize), 0);   

        
        if (slider.hasRendered) {

            
            ui.handle1Node.style[position] = handle1 + px;
            ui.handle2Node.style[position] = handle2 + px;

            var lowerStyle = ui.lowerRange.style,
                thumbStyle = ui.thumbNode.style,
                upperStyle = ui.upperRange.style;

            
            lowerStyle[position] = 0;
            thumbStyle[position] = (min + handleSize) + px;
            upperStyle[position] = (max + handleSize) + px;

            
            lowerStyle[length] = $MATH_MAX(min, 0) + px;
            thumbStyle[length] = thumbLength + px;
            upperStyle[length] = upperLength + px;

        } else {
            
            px += ';';
            position += ':';
            length += ':';

            
            slider.handle1CssText = position + handle1 + px;
            slider.handel2CssText = position + handle2 + px;

            
            slider.lowerRangeCssText = length + $MATH_MAX(min, 0) + px;
            slider.thumbCssText = position + (min + handleSize) + px + length + thumbLength + px;
            slider.upperRangeCssText =  position + (max + handleSize) + px + length + upperLength + px;
        }

        
        return {
            handle1: handle1,
            handle2: handle2
        };
    }

    
    function MetricSlider(sl) {
        
        this.getUnit = function () {
            return sl._length / $MATH_MAX((sl.items.length - 1), 1);
        };

        this.calcMinMax = function (pxMin, pxMax) {
            var unit = sl.unit;
            return {
                min: $MATH_FLOOR(pxMin / unit + 0.5),
                max: $MATH_FLOOR(pxMax / unit + 0.5)
            };
        };

        this.calcPxIdx = function (px) {
            return $MATH_FLOOR(px / sl.unit + 0.5);
        };

        
        this.getStep = function () {
            var rng = sl.high - sl.low,
                cat = parseInt(sl.numFmts.cat, 10),
                adjust = (cat === 4) ? 2 : (cat === 5) ? 4 : 0;

            rng = (rng === 0) ? 1 : rng;
            if (rng > 1) {
                return (rng > (sl._length - 2)) ? Number(Number(rng / (sl._length - 2)).toFixed(sl.numFmts.dp + adjust)) : 1;
            }

            return rng / (sl._length - 2);
        };

        
        this.getIdx = function (vl) {
            return $MATH_MIN($MATH_MAX($MATH_ROUND((vl - sl.low) / sl.step), 0), sl.items.length - 1);
        };

        
        this.initialMetricSlider = function initialMetricSlider() {
            var notNull = function (v) {
                    return v !== undefined && v !== null;
                },
                validateData = function (sl) {
                    return (notNull(sl.da) && notNull(sl.da.low) && notNull(sl.da.high) &&
                            notNull(sl.da.cnt) && notNull(sl.f) && notNull(sl.ft) && notNull(sl.qua));
                },
                displayInvalid = function (sl) {
                    var gen = true,
                        rp = true;

                    
                    if (sl.ft == $M._GENERIC) {
                        gen = sl.f != $M.FN.ISNULL && sl.f != $M.FN.ISNOTNULL && sl.f != $M.FN.NOTIN && sl.f != $M.FN.IN;
                    } else if(sl.ft == $M._PERCENT || sl.ft == $M._RANK) {
                        rp = sl.f != $M.MRPFN.INASCENDING && sl.f != $M.MRPFN.INDESCENDING && sl.f != $M.MRPFN.NOTINDESCENDING && sl.f != $M.MRPFN.NOTINASCENDING;
                    }

                    return !gen || !rp;
                },
                adjust = 0;

            sl.include = sl.parent.include;
            sl.clsType = 'scm ';

            sl.staticStatus = !(notNull(sl.da) && notNull(sl.da.low) && notNull(sl.da.high)&& notNull(sl.da.cnt)&& notNull(sl.qua));
            if (sl.staticStatus) { 
               sl.da.low = 1;
               sl.da.high = 7;
               sl.ft = $M._GENERIC;
               sl.f = $M.FN.BETWEEN;
               sl.qua = $M.Q._G;
               sl.cs = [{n: '', v: 1}, {n: '', v: 7}];
               sl.numFmts = {cat: 9, dp: 0, fm: ''};
            }

            
            switch (sl.qua) {
            case 0:
                var cat = sl.numFmts.cat;
                adjust = cat == 4 ? 2 : cat == 5 ? 4 : 0;
                sl.low = Number(Number(sl.da.low ).toFixed(sl.numFmts.dp + adjust));
                sl.high = Number(Number(sl.da.high).toFixed(sl.numFmts.dp + adjust));
                break;
            case 1:
            case 2:
                sl.low = 1;
                sl.high = sl.da.cnt;
                break;
            case 3:
            case 4:
                sl.low = 0;
                sl.high  = 100;
                break;
            }

            var ept = !sl.staticStatus && !sl.da.nov && sl.dt != 30;
            sl.set('lowText', ept? $M.formatNumber(sl.qua, sl.low, sl.numFmts) : "");
            sl.set('highText', ept? $M.formatNumber(sl.qua, sl.high, sl.numFmts) : "");

            
            sl.step = (sl.qua == 1 || sl.qua == 2)? 1 : this.getStep();

            sl.low -= sl.step;
            sl.high += sl.step;

            
            sl.cs1Vl = sl.low;
            sl.cs2Vl = sl.high;

            
            var l = sl.low,
                h = sl.high,
                itms = [],
                len = 0;

            if ( notNull(l) && notNull(h) && sl.dt != 30) {
                for (var i = 0, j = l; j <= h; i ++, j += sl.step) {
                    itms[i] = {n : $M.formatNumber(sl.qua, j, sl.numFmts), v: Number(Number(j).toFixed(sl.numFmts.dp + adjust))};
                }
                len = itms.length;
                if (len > 0 && itms[len -1].v != h){  itms[len-1] = {n: $M.formatNumber(sl.qua, h, sl.numFmts), v: h}; }
            }

            len = itms.length;
            if(len >= 2 ) {
                itms[0].n = itms[len -1].n = $DESC(7622);
            }

            sl.items = itms;

            
            var $O = $M.OP,
            cs = sl.cs,
            c1 = (cs && cs.length > 0)? $NM.parseNumeric(String(cs[0].v).replace('%', '')) : l,
            c2 = (cs && cs.length >1)? $NM.parseNumeric(String(cs[1].v).replace('%', '')) : h;

            if(c1 < sl.low) { sl.frtUst = true;}
            if(c2 > sl.high) {sl.ndUst = true;}

            sl.opId = (sl.f != null && sl.ft != null)? $M.getOpIdxByfunc(sl.f, sl.ft) : $O._BETWEEN;

            switch (sl.opId){
            case  $O._EQUALS :
            case $O._NOT_EQUALS:
                sl.cs1Vl = sl.cs2Vl = c1;
                break;
            case $O._LESS_EQUAL:
            case $O._GREATER:
                sl.cs1Vl = l;
                sl.cs2Vl = c1;
                break;
            case $O._GREATER_EQUAL:
            case $O._LESS:
                sl.cs1Vl = c1;
                sl.cs2Vl = h;
                break;
            case $O._IN:
            case $O._NOT_IN:
            case $O._IS_NULL:
            case $O._IS_NOT_NULL:
                break;
            default:
                sl.cs1Vl = c1;
                sl.cs2Vl = c2;
                break;
            }

            sl.cs1Idx = this.getIdx(sl.cs1Vl);
            sl.cs2Idx = this.getIdx(sl.cs2Vl);

            if (sl.dt != 30) {
               
               
               sl.cs1Nm = notNull(sl.cs1Vl) ? $M.formatNumber(sl.qua, sl.cs1Vl, sl.numFmts) : sl.items[sl.cs1Idx].n;
               sl.cs2Nm = notNull(sl.cs2Vl) ? $M.formatNumber(sl.qua, sl.cs2Vl, sl.numFmts) : sl.items[sl.cs2Idx].n;
            }

            sl.unit = this.getUnit();

            sl.set('unSet', (sl.dt == 30 || !validateData(sl) || displayInvalid(sl) || (!sl.cs || sl.cs.length == 0)) && !sl.staticStatus);
        };

        
        this.updateOpCs = function () {
            
            var i = (sl.cs1Vl > sl.cs2Vl)? sl.cs2Vl : sl.cs1Vl,
                a = (sl.cs1Vl > sl.cs2Vl)? sl.cs1Vl : sl.cs2Vl,
                l = sl.low,
                h = sl.high,
                il = sl.include,
                $O = $M.OP,
                isPercent = (sl.qua == $M.Q._PT || sl.qua == $M.Q._PB),
                unset,
                cs = [];

            if ((i >= l && a <= h) || i < l || a > h) { sl.opId = (il)? $O._BETWEEN : $O._NOT_BETWEEN;}
            if (i == a) { sl.opId = (il)? $O._EQUALS : $O._NOT_EQUALS;}
            if (i == l && a < h ) { sl.opId = (il)? $O._LESS_EQUAL : $O._GREATER;}
            if (i > l && a == h) {sl.opId = (il)? $O._GREATER_EQUAL : $O._LESS;}

            unset = l == i && a == h;
            if(!unset){
                
                switch (sl.opId){
                case $O._BETWEEN:
                case $O._NOT_BETWEEN:
                    cs.push({dtp:5, v: $NM.toLocaleString(i) + (isPercent? '%' : '')});

                case $O._EQUALS:
                case $O._NOT_EQUALS:
                    cs.push({dtp:5, v: $NM.toLocaleString(a) + (isPercent? '%' : '')});
                    break;
                 default:
                     if (i > l) { cs.push({dtp:5, v: $NM.toLocaleString(i) + (isPercent? '%' : '')});}
                     if (a < h) { cs.push({dtp:5, v: $NM.toLocaleString(a) + (isPercent? '%' : '')});}
                }
            }
            sl.cs = cs;

            
            sl.parent.node.data.cs = cs;
            sl.set('unSet', unset);
        };

        
        this.updateThumb = function () {
            var cs1Idx = sl.cs1Idx,
                cs2Idx = sl.cs2Idx;

            
            if (cs1Idx !== undefined && cs2Idx !== undefined) {
                var unit = sl.unit,
                    gap = sl.gap;

                
                $HASH.copy(positionSliderElements(sl, sl, $MATH_ROUND(cs1Idx * unit - gap), $MATH_ROUND(cs2Idx * unit - gap)), sl);
            }
        };

        this.joinConst = function () {
            var cs = sl.cs;
            if (cs) {
                var constValues = [],
                    i;

                for (i in cs){
                    constValues.push(cs[i].v);
                }

                return constValues.join(',');
            }
        };
    }

    var tooltipMarkup = '<span {@ttpCssText}>{@content}</span>';

    
    function initGhost() {
        
        if (this.staticStatus) {
            
            return null;
        }

        
        var ghost = this.ghost;
        if (!ghost) {
            
            var cn = this.containerNode.cloneNode(true),
                cnc = cn.childNodes;

            
            $C.addClass(cn, [ 'gh' ]);

            
            ghost = this.ghost = {
                containerNode: cn,
                lowerRange: cnc[0],
                handle1Node: cnc[1],
                thumbNode: cnc[2],
                handle2Node: cnc[3],
                upperRange: cnc[4]
            };

            
            this.sdcNode.appendChild(cn);
        }

        var orCfg = this.orCfg,
            position = orCfg.posCssP,
            length = orCfg.lenCssP,
            id = this.id;

        
        mstrmojo.array.forEach([ 'lowerRange', 'containerNode', 'thumbNode', 'upperRange' ], function (nodeName, idx) {
            
            var slider = mstrmojo.all[id],
                widgetNodeStyle = slider[nodeName].style,
                ghostNodeStyle = ghost[nodeName].style;

            
            if (idx) {
                
                ghostNodeStyle[position] = widgetNodeStyle[position];
            }

            
            ghostNodeStyle[length] = widgetNodeStyle[length];
        });

        
        ghost.containerNode.style.display = 'block';

        return ghost;
    }

    
    mstrmojo.MetricSlider = mstrmojo.declare(
        
        mstrmojo.Slider,

        
        [ mstrmojo._HasPopup ],

        
        {
            scriptClass: "mstrmojo.MetricSlider",

            markupString: '<div>' +
                            '<div class="mstrmojo-Slider-summary"></div>'+
                            '<div class="mstrmojo-Slider {@cssClass} {@clsType} {@clsOrientation}" style="{@cssText}" >' +
                                '<div class="cont" style="position:absolute;">' +
                                    '<div class="bk" style="margin-top: 2px;{@bkCssText}"></div>' +
                                    '<div class="sdc" style="position:absolute;{@sdcCssText}">' +
                                        '<div class="sd" style="{@sdCssText}">' +
                                            '<div class="bk" style="{@lowerRangeCssText}"></div>' +
                                            '<div class="t1" style="{@handle1CssText}" mstrAttach:mouseover,mouseout,click></div>' +
                                            '<div class="t2 bk" style="{@thumbCssText}"></div>' +
                                            '<div class="t3" style="{@handel2CssText}" mstrAttach:mouseover,mouseout,click></div>' +
                                            '<div class="bk" style="{@upperRangeCssText}"></div>' +
                                        '</div>' +
                                    '</div>' +
                                    '<div class="mstrmojo-Label" style="margin-top:5px;float:left;"></div>' +
                                    '<div class="mstrmojo-Label" style="margin-top:5px;float:right;"></div>' +
                                '</div>' +
                            '</div>'+
                        '</div>',

            markupSlots: {
                summaryNode: function() {return this.domNode.childNodes[0];},
                dndNode: function() {return this.domNode.childNodes[1].childNodes[0];},
                bgNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[0];},
                sdcNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1];},
                containerNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0];},
                lowerRange: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[0];},
                handle1Node: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[1];},
                thumbNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[2];},
                handle2Node: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[3];},
                upperRange: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[4];},
                tooltipNode: function(){return this.domNode.childNodes[1].childNodes[0].childNodes[1];},
                lowNode: function(){return this.domNode.childNodes[1].childNodes[0].childNodes[2];},
                highNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[3];},
                editValueNode: function(){return this.domNode;}
            },

            markupMethods: {
                onlowTextChange: function (){ this.lowNode.innerHTML = this.lowText || ''; },
                onhighTextChange: function (){ this.highNode.innerHTML = this.highText || ''; },
                onfontChange: function () { this.lowNode.style.font = this.highNode.style.font = String(this.font); },
                onunSetChange: function () { $C.toggleClass(this.domNode.childNodes[1], 'invalid', this.unSet); }
            },

            init: function init(p) {
                this._super(p);

                this.handleSize = mstrmojo.MetricSlider.METRICSLIDERTHUMBWIDTH;

                this.clsType = 'scm';
                this.typeHelper = new MetricSlider(this);
                this.useRichTooltip = false;
            },

            

            unSet : false, 

            preBuildRendering: function preBuildRendering() {
                
                var orCfg = this.orCfg,
                    isHoriz = this.isHoriz;

                orCfg.cPosCssP = (isHoriz) ? 'right' : 'bottom';
                orCfg.cLenCssP = (isHoriz) ? 'height' : 'width';

                var dimension = orCfg.lenCssP,
                    rawLength = this[dimension],
                    length = parseInt(rawLength, 10),
                    handleSize = this.handleSize;

                var effectiveLength = this._length = (isNaN(length)) ? 0 : (length - handleSize);
                if (effectiveLength <= 0) {
                    effectiveLength = this._length = mstrmojo.MetricSlider.METRICSLIDERDEFAULTWIDTH - handleSize;   
                }

                if (rawLength) {
                    this.bkCssText = dimension + ':' + $MATH_MAX(length - (2 * this.cssBkBW), 0) + 'px;';
                    this.sdcCssText =  orCfg.posCssP + ':0px;' + dimension + ':' + effectiveLength + 'px;' + orCfg.opPosCssP + ':0px;';
                }

                this.typeHelper.initialMetricSlider();
                this.typeHelper.updateThumb();
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                if (!this.staticStatus && !this.da.nov) {
                    var ln = this.lowNode,
                        fos = parseInt(ln.style.fontSize, 10);

                    ln.style.fontSize = this.highNode.style.fontSize = $MATH_ROUND((isNaN(fos) ? 8 : fos) * this.parent.model.zf) + 'pt';

                    this.updateSummary();
                }
            },

            onmouseover: function onmouseover(evt) {
                this.showTooltip(evt.e, self);
            },

            onmouseout: function onmouseout(evt) {
                this.hideTooltip(evt.e, self);
            },

            summaryLabels: {
                db : $DESC(8153, "Between ## and ###"),
                dnb: $DESC(8154,"Not between ## and ###"),
                din: $DESC(587,"In"),
                dnin: $DESC(2204,"Not in"),
                dnull: $DESC(2202,"Is Null"),
                dnnull: $DESC(2203,"Is not Null"),

                req: $DESC(8155,"Rank ="),
                rneq: $DESC(8156,"Rank <>").replace("<>", String.fromCharCode(0x2260)),
                rexb: $DESC(8157,"Rank exclude bottom"),
                rext: $DESC(8158,"Rank exclude top"),
                rb: $DESC(8159,"Rank bottom"),
                rt: $DESC(8160,"Rank top"),
                rbt: $DESC(8161,"Rank between ## and ###"),
                rnbt: $DESC(8162,"Rank not between ## and ###"),
                rin: $DESC(8163,"Rank in"),
                rnin: $DESC(8164,"Rank not in"),

                peq: $DESC(8165,"Percent ="),
                pneq: $DESC(8166,"Percent <>").replace("<>", String.fromCharCode(0x2260)),
                pexb: $DESC(8167,"Exclude bottom"),
                pext: $DESC(8168,"Exclude top"),
                pb: $DESC(7576,"Bottom"),
                pt: $DESC(7575,"Top"),
                pbt: $DESC(8153,"Between ## and ###"),
                pnbt: $DESC(8154,"Not between ## and ###"),
                pin: $DESC(8169,"Percent in"),
                pnin: $DESC(8170,"Percent not in")
            },

            updateSummary: function updateSummary() {
                

                if (this.summaryNode && !this.staticStatus) {
                    var f  = this.f,  
                        ft = this.ft, 
                        fte = $M,
                        fe = $M.FN,
                        fmrpe = $M.MRPFN,
                        txt = "",
                        fl = (this.cs1Vl < this.cs2Vl)? this.cs1Nm : this.cs2Nm,
                        fr = (this.cs1Vl > this.cs2Vl)? this.cs1Nm : this.cs2Nm,
                        th = this.typeHelper,
                        s = this.summaryLabels,
                        specialCase = (ft == fte._GENERIC && (f == fe.ISNULL || f == fe.ISNOTNULL || f == fe.NOTIN || f == fe.IN)) ||
                                        ((ft == fte._PERCENT || ft == fte._RANK) && (f == fmrpe.INASCENDING || f == fmrpe.INDESCENDING || f == fmrpe.NOTINDESCENDING || f == fmrpe.NOTINASCENDING));

                    
                    if(!this.unSet || specialCase){
                        switch(ft){
                            case  fte._GENERIC:
                                switch(f){
                                case fe.EQUALS:
                                    txt = "= " + fl;
                                    break;
                                case fe.NOTEQUALS:
                                    txt = String.fromCharCode(0x2260) + " " + fl;
                                    break;
                                case fe.GREATERTHAN:
                                    txt = "> " + fr;
                                    break;
                                case fe.GREATERTHANEQUALS:
                                    txt = String.fromCharCode(0x2265) + " " + fl;
                                    break;
                                case fe.LESSTHAN:
                                    txt = "< " + fl;
                                    break;
                                case fe.LESSTHANEQUALS:
                                    txt = String.fromCharCode(0x2264) + " " + fr;
                                    break;
                                case fe.BETWEEN:
                                    txt = s.db.replace("##",fl).replace("###",fr);
                                    break;
                                case fe.NOTBETWEEN:
                                    txt = s.dnb.replace("##",fl).replace("###",fr);
                                    break;
                                case fe.ISNULL:
                                    txt = s.dnull;
                                    break;
                                case fe.ISNOTNULL:
                                    txt = s.dnnull;
                                    break;
                                case fe.IN:
                                    txt = s.din + " " + th.joinConst();
                                    break;
                                case fe.NOTIN:
                                    txt = s.dnin + " " +th.joinConst();
                                    break;
                                }
                                break;
                            case fte._PERCENT:
                            case fte._RANK:

                                var pr = "r";
                                if(ft == fte._PERCENT) pr = "p";

                                switch(f){
                                case fmrpe.EQUALSDESCENDING:
                                case fmrpe.EQUALSASCENDING:
                                    txt = s[pr + "eq"] + " " + fl;
                                    break;
                                case fmrpe.NOTEQUALSDESCENDING:
                                case fmrpe.NOTEQUALSASCENDING:
                                    txt = s[pr + "neq"] + " " + fl;
                                    break;
                                case fmrpe.GREATERTHANEQUALSASCENDING:
                                    txt = s[pr + "exb"] + " " + fl;
                                    break;
                                case fmrpe.GREATERTHANASCENDING:
                                    txt = s[pr + "exb"] + " " + fr;
                                    break;
                                case fmrpe.GREATERTHANEQUALSDESCENDING:
                                    txt = s[pr + "ext"] + " " + fl;
                                    break;
                                case fmrpe.GREATERTHANDESCENDING:
                                    txt = s[pr + "ext"] + " " + fr;
                                    break;
                                case fmrpe.LESSTHANASCENDING:
                                    txt = s[pr + "b"] + " " + fl;
                                    break;
                                case fmrpe.LESSTHANEQUALSASCENDING:
                                    txt = s[pr + "b"] + " " + fr;
                                    break;
                                case fmrpe.LESSTHANDESCENDING:
                                    txt = s[pr + "t"] + " " + fl;
                                    break;
                                case fmrpe.LESSTHANEQUALSDESCENDING:
                                    txt = s[pr + "t"] + " " + fr;
                                    break;
                                case fmrpe.BETWEENDESCENDING:
                                case fmrpe.BETWEENASCENDING:
                                    txt = s[pr + "bt"].replace("##",fl).replace("###",fr);
                                    break;
                                case fmrpe.NOTBETWEENASCENDING:
                                case fmrpe.NOTBETWEENDESCENDING:
                                    txt = s[pr + "nbt"].replace("##",fl).replace("###",fr);
                                    break;
                                case fmrpe.INASCENDING:
                                case fmrpe.INDESCENDING:
                                    txt = s[pr + "in"] + " " + th.joinConst();
                                    break;
                                case fmrpe.NOTINDESCENDING:
                                case fmrpe.NOTINASCENDING:
                                    txt = "";
                                    txt = s[pr + "nin"] + " " + th.joinConst();
                                    break;
                                }
                                break;
                        }
                    }

                    var summaryNode = this.summaryNode,
                        margin = (txt !== '') ? '' : 0;     

                    
                    summaryNode.innerHTML = txt;
                    summaryNode.style.margin = margin;

                    if (this.hasRendered && this.height == null){
                        this.parent.updateHeight();
                     }

                }
            },

            getClientHeight: function getClientHeight(){
                return this.dndNode.clientHeight + this.summaryNode.clientHeight + 15;
            },

            
            initDrag: function initDrag(e, hWin) {
                if (!this.staticStatus && !this.da.nov) {
                    hWin = hWin || window;

                    
                    var td = $D.eventTarget(hWin, this.dnd.startE);
                    if (td === this.handle1Node || td === this.handle2Node) {

                        var ghost = initGhost.call(this),
                            oc = this.orCfg,
                            dnd = this.dnd;

                        dnd.initD = {
                            handle1: parseFloat(this.handle1, 10),
                            handle2: parseFloat(this.handle2, 10),
                            length: this._length,
                            contL: ghost.containerNode[oc.lenP],
                            offset: $D.getMousePosition(this.dnd.startE, hWin)[oc.offsetP]
                        };

                        dnd.initD.td = td;

                        $C.removeClass(this.domNode.childNodes[1], ['invalid']);
                    }
                }
            },

            ondrag: function ondrag(e, hWin){
                if (!this.staticStatus) {
                    hWin = hWin || window;

                    var initD = this.dnd.initD;
                    if (initD) {
                        var ghost = this.ghost,
                            cs1Px = initD.handle1,
                            cs2Px = initD.handle2,
                            cs1Idx = this.cs1Idx,
                            cs2Idx = this.cs2Idx,
                            unit = this.unit,
                            gap = this.gap,
                            length = initD.length;

                        
                        var diff = $D.getMousePosition(e, hWin)[this.orCfg.offsetP] - initD.offset;
                        switch (initD.td) {
                            case this.handle1Node:
                                cs1Px = $MATH_MAX($MATH_MIN($MATH_MAX(initD.handle1 + diff, 0), length) - gap, -1);
                                cs1Idx = $MATH_MAX($MATH_FLOOR(cs1Px / unit + 0.5), 0);
                                break;

                            case this.handle2Node:
                                cs2Px = $MATH_MAX($MATH_MIN($MATH_MAX(initD.handle2 + diff, 0), length) - gap, -1);
                                cs2Idx = $MATH_MAX($MATH.ceil(cs2Px / unit + 0.5), 0);  
                                break;

                            default:
                                return;
                        }

                        
                        positionSliderElements(this, ghost, cs1Px, cs2Px);

                        var items = this.items,
                            itemCount = (items && items.length) || 0;

                        if (itemCount && cs1Idx >= 0 && cs1Idx < itemCount && cs2Idx >= 0 && cs2Idx < itemCount) {
                            var _changed = false;
                            if (cs1Idx !== this.cs1Idx) {
                                this.cs1Idx = cs1Idx;
                                var itm = this.items[cs1Idx];
                                this.cs1Vl = itm.v;
                                this.cs1Nm = itm.n;
                                _changed = true;
                            }
                            if (cs2Idx !== this.cs2Idx) {
                                this.cs2Idx = cs2Idx;
                                var itm = this.items[cs2Idx];
                                this.cs2Vl = itm.v;
                                this.cs2Nm = itm.n;
                                _changed = true;
                            }

                            if (_changed) {
                                
                                this.typeHelper.updateThumb();
                                this._updateTooltip(initD.td);
                            }
                        }
                    }
                }
            },

            ondrop: function ondrop( e){
                if (!this.staticStatus && !this.da.nov) {
                    this.typeHelper.updateThumb();

                    var ghost = this.ghost;
                    if (ghost) {
                        ghost.containerNode.style.display = "none";
                    }

                    this.hideTooltip(e, self);

                    if (this.items && this.items.length){
                        this[($D.eventTarget(self, e) === this.ghost.handle1Node)? 'frtUst' : 'ndUst'] = false;
                        this.selectRange();
                    }

                    this.dnd.initD = null;
                }
            },

            
            selectRange : function slctrng(onlyInclude, changeQual, updateUnset) {
                var T = this.typeHelper,
                    c1 = this.cs1Vl,
                    c2 = this.cs2Vl,
                    q = this.qua,
                    nf = this.numFmts;

                this.cs1Idx = T.getIdx(c1);
                this.cs2Idx = T.getIdx(c2);

                var isEdge = function(idx, itms) {
                        var its = itms || [];
                        return idx == 0 || idx == its.length -1;
                    },
                    unsetStr = $DESC(7622);

                this.cs1Nm = isEdge(this.cs1Idx, this.items) && !this.frtUst ? unsetStr : $M.formatNumber(q, c1, nf);
                this.cs2Nm = isEdge(this.cs2Idx, this.items) && !this.ndUst ? unsetStr : $M.formatNumber(q, c2, nf);

                T.updateOpCs();

                
                this.onlyInclude = !!onlyInclude;
                this.changeQual = !!changeQual;
                this.unSet = !!updateUnset || this.unSet;

                this.updateSummary();
                this.onselectionChange();
             },

             onincludeChange : function incChange(){
                 if (!this.staticStatus) {
                     this.selectRange(true);
                 }
             },

            
            showTooltip: function showTooltip(e, win) {
                 var tgt = $D.eventTarget(win, e);
                 this._updateTooltip(tgt);
                 mstrmojo.tooltip.open(this, e, win);
            },

            
            _updateTooltip: function _updateTooltip(tgt) {
                var oc = this.orCfg,
                    ps = oc.posCssP,
                    txt,
                    tt = {
                        contentNodeCssClass: 'scm-tooltip',
                        refNode: this.domNode.childNodes[1],
                        posType: this._tooltip_pos
                    };

                tt[oc.opPosCssP] = - parseInt(this.font)/2;
                tt[ps] = tgt.style[ps];

                if (this.unSet) {
                    txt = $DESC(7622);
                } else {
                    txt = String((tgt === this.handle1Node) ? this.cs1Nm: this.cs2Nm);
                }

                tt.content = tooltipMarkup.replace(/\{@content\}/g, txt);

                this.set('richTooltip', tt);
            },

            
            onclick: function onclick(evt) {
                if (!this.staticStatus && !this.da.nov) {
                    var tgt = $D.eventTarget(evt.hWin || window, evt.e);
                    
                    this.dnd.initD = {
                    		makeMetricSilderSelectionByClick: true,
                    		td: ((tgt===this.handle1Node) ? this.handle1Node : ((tgt=== this.handle2Node) ? this.handle2Node : null))
                    };
                    
                    this.openEditValue({
                        isfrt: (tgt === this.handle1Node),
                        tgt: tgt
                    });

                    if (this._onThumb) {
                        
                        this._onThumb(evt);
                    }
                }
            },
            
            onselectionChange: function onselChg(evt) {
            	this._super(evt);
            	
            	
        		if (this.dnd.initD && this.dnd.initD.makeMetricSilderSelectionByClick){
        			this.dnd.initD = null;
        		}
            },

            onquaChange: function onqChg(evt){
                var oldf = mstrmojo.MCSUtil.getFuncInfo(this.opId, evt.valueWas),
                    newf = mstrmojo.MCSUtil.getFuncInfo(this.opId, evt.value),
                    u;

                if (oldf.ft != newf.ft) {
                    if (!this.staticStatus) {
                        this.items = [];
                        this.cs = [];
                        this.f = this.ft = null;
                        this.refresh();
                        u = true;
                    }
                } else {
                    this.f = mstrmojo.MCSUtil.getFuncInfo(this.opId, evt.value).f;
                    u = false;
                }

                this.selectRange(false, true, u);
            },

            updateData: function udtDt(da, props){
                this.da = da;

                
                
                this.updateExpr(props);

            },

            updateExpr: function udtEp(props) {
                if (props) {
                    this.cs = props.cs;
                    this.f = props.f;
                    this.ft = props.ft;
                    this.qua = props.qua;
                }
                this.refresh();
            },

            editValueRef:{
                cssClass: "edvl",
                slot: "editValueNode",
                scriptClass: "mstrmojo.Popup",
                locksHover: true,
                onOpen: function() {
                    if (this.tgt) {
                        this.set("left", $MATH_MIN($MATH_MAX(parseInt(this.tgt.style.left, 10), 0), parseInt(this.opener.width, 10) - 90) + 'px');
                        this.set("top", this.tgt.style.top);
                    }
                    var op = this.opener,
                    cld = this.children[0];
                    if (op) {
                        var v = this.isfrt ? op.cs1Vl : op.cs2Vl;
                        if (this.isfrt){
                            if ((op.cs1Vl <= op.low || op.cs1Vl >= op.high) && !op.frtUst){
                                v = '';
                            }
                        } else {
                            if((op.cs2Vl <= op.low || op.cs2Vl >= op.high) && !op.ndUst){
                                v = '';
                            }
                        }
                        cld.edt.set('value', $NM.toLocaleString(v));
                    }
                },
                children:[{
                  scriptClass : "mstrmojo.Table",
                  rows:1,
                  cols: 2,
                  layout: [{
                      cells: [{
                          cssText: "width: 40px; padding: 3px;"
                      }, {
                          cssText: "width: 16px;padding: 3px;"
                      }]
                  }],
                  children : [{
                        slot: "0,0",
                        scriptClass : "mstrmojo.ValidationTextBox",
                        alias: "edt",
                        cssText: "color:black",
                        dtp: mstrmojo.expr.DTP.NUMERIC,
                        constraints: {
                            trigger: mstrmojo.validation.TRIGGER.ALL
                        },
                        onValid: function() {
                            if (this.parent.apply) {
                                this.parent.apply.set("enabled", String(this.value).length != 0);
                            }
                        },
                        onInvalid: function() {
                            if (this.parent.apply) {
                                this.parent.apply.set("enabled", false);
                            }
                        },
                        onkeyup: function(evt) {
                            if (this.parent.apply.enabled) {
                                var hWin = evt.hWin,
                                    e = evt.e || hWin.event;
                                if (e.keyCode === 13){
                                    this.parent.apply.onclick();
                                }
                            }
                        }
                    }, {
                        slot: "0,1",
                        scriptClass : "mstrmojo.Button",
                        cssClass : 'icn apply',
                        alias: "apply",
                        onclick : function() {
                            var p = this.parent.parent,
                                op = p.opener,
                                v = this.parent.edt.value;

                            if (p && op && String(v).length > 0) {
                                op[p.isfrt ? 'cs1Nm' : 'cs2Nm'] = v;
                                v = $NM.parseNumeric(v);
                                op[p.isfrt ? 'cs1Vl' : 'cs2Vl'] = v;
                            }

                            op[p.isfrt? 'frtUst' : 'ndUst'] = true;
                            op.selectRange();

                            op.typeHelper.updateThumb();
                            p.close();
                        }
                    }]
                }]
            },

            openEditValue: function( config) {
                this.openPopup("editValueRef", config);
            }
        }
    );

    mstrmojo.MetricSlider.METRICSLIDERTHUMBWIDTH = 14;
    mstrmojo.MetricSlider.METRICSLIDERDEFAULTWIDTH = 95;

}());
(function(){

    mstrmojo.requiresCls("mstrmojo.MobileDocLayoutViewer");
    
    var $CFC = mstrmojo.DynamicClassFactory.newComponent;
    
    
    
    mstrmojo.maps.MobileMapInfoWindowLayoutViewer = mstrmojo.declare(
        mstrmojo.MobileDocLayoutViewer, 
        null, 
        {
            scriptClass: 'mstrmojo.maps.MobileMapInfoWindowLayoutViewer',
            
            preBuildRendering: function preBuildRendering() {
                
                this.setDimensions(this.height, this.width);
                
                this.set('visible', true);       
            
                return this._super ? this._super() : true;
            }
        }
    );
    
    
     
    mstrmojo.maps.MapInfoWindowLayoutViewer = mstrmojo.declare(
        
        mstrmojo.MobileDocLayoutViewer,
        
        
        null,
        
        
        {
            scriptClass: "mstrmojo.maps.MapInfoWindowLayoutViewer",
            
            preBuildRendering: function preBuildRendering() {            
                
                this.set('visible', true);
                
                return this._super ? this._super() : true;
            }        
        }
    );
    
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo.fx",
                         "mstrmojo.Dialog",
                         "mstrmojo._IsPopup",
                         "mstrmojo._HasPopup",
                         "mstrmojo._IsMovable");

    var $D = mstrmojo.dom;

    
    mstrmojo.Editor = mstrmojo.declare(

        mstrmojo.Dialog,

        [ mstrmojo._IsPopup, mstrmojo._HasPopup, mstrmojo._IsMovable ],

        
        {
            scriptClass: "mstrmojo.Editor",

            
            title: '',

            
            help: '',

            
            autoClose: false,

            
            showTitle: true,

            
            openEffect: null,

            
            closeEffect: null,

            markupString: '<div id="{@id}" class="mstrmojo-Editor-wrapper">' +
                            '<div class="mstrmojo-Editor {@cssClass}" style="z-index:{@zIndex};{@cssText}" mstrAttach:mousedown>{@titlebarHTML}' +
                                '<div class="mstrmojo-Editor-content"></div>' +
                                '<div class="mstrmojo-Editor-buttons"></div>' +
                            '</div>' +
                            '<div class="mstrmojo-Editor-curtain"></div>' +
                          '</div>',

            titleMarkupString: '<div style="position:absolute;width:100%;"><table cellspacing="0" cellpadding="0" class="mstrmojo-Editor-titlebar"><tr>' +
                          '<td class="mstrmojo-Editor-titleCell"><div class="mstrmojo-Editor-title"></div></td>' +
                          '<td><a href="#" target="_new" class="mstrmojo-Editor-help"><img class="mstrmojo-Editor-help" src="../images/1ptrans.gif" title="' + mstrmojo.desc(1143, "help") + '"></img></a></td>' +
                          '<td><div class="mstrmojo-Editor-close" title="' + mstrmojo.desc(2102, "Close") + '"></div></td>' +
                     '</tr></table></div><div class="mstrmojo-Editor-titleSpacer"></div>',

            markupSlots: {
                editorNode: function () { return this.domNode.firstChild; },
                titlebarNode: function () { return this.showTitle ? this.domNode.firstChild.firstChild.firstChild : null; },
                titleNode: function () { return this.showTitle ? this.domNode.firstChild.firstChild.firstChild.rows[0].cells[0].firstChild : null; },
                helpNode: function () { return this.showTitle ? this.domNode.firstChild.firstChild.firstChild.rows[0].cells[1].firstChild : null; },
                closeNode: function () { return this.showTitle ? this.domNode.firstChild.firstChild.firstChild.rows[0].cells[2].firstChild : null; },
                containerNode: function () { return this.domNode.firstChild.childNodes[2]; },
                buttonNode: function () { return this.domNode.firstChild.childNodes[3]; },
                curtainNode: function () {return this.domNode.lastChild; }
            },

            markupMethods: {
                ontitleChange: function () {
                    if (this.showTitle) {
                        this.titleNode.innerHTML = this.title;
                    }
                },

                onzIndexChange: function () {
                    var zIndex = this.zIndex;
                    this.editorNode.style.zIndex = zIndex;
                    this.curtainNode.style.zIndex = zIndex - 1;
                },

                onvisibleChange: function (init) {
                    if (init) {
                        return;
                    }

                    var v = this.visible,
                        fx = 'closeEffect',
                        d = 'none';

                    if (v) {
                        fx = 'openEffect';
                        d = 'block';
                    }

                    if (this[fx]) {
                        this.playEffect(fx);

                    } else {
                        this.editorNode.style.display = d;
                        if (this.modal) {
                            this.curtainNode.style.display = d;
                        }
                    }
                },

                onhelpChange: function () {
                    if (this.showTitle) {
                        if (this.help === null) {
                            this.helpNode.style.display = 'none';
                        }

                        this.helpNode.href = (mstrApp.helpUrl || '../help/')  + 'WebUser/WebHelp/Lang_' + (mstrApp.helpLocaleId ? mstrApp.helpLocaleId : mstrApp.localeId) +
                            '/'+(mstrApp.userHelpPage || 'MicroStrategy_Web_Help.htm')+'#' + (this.help || '');
                    }
                },

                onleftChange: function () { this.editorNode.style.left = this.left || ''; },
                ontopChange: function () { this.editorNode.style.top = this.top || ''; }
            },

            
            preBuildRendering: function preBuildRendering() {
                if (!this.slot && !this.placeholder) {
                    this.placeholder = document.body.appendChild(document.createElement('div'));
                    this._curtain_to_body = true;
                }

                this.titlebarHTML = (this.showTitle) ? this.titleMarkupString : '<div></div><div></div>';

                return this._super();
            },

            getMovingHandle: function getMovingHandle() {
                return this.titlebarNode;
            },

            getMovingTarget: function getMovingTarget() {
                return this.editorNode;
            },

            
            onPreClose: function() {
                return true;
            },
            
            premousedown: function premousedown(evt) {
                var target = $D.eventTarget(evt.hWin, evt.e);
                if (target === this.closeNode) {
                 
                    if (this.onPreClose()) {
                        this.close();
                    }
                }
            },

            
            _set_visible: function _set_visible(n, v) {
                
                var bChanged = (this[n] !== v);
                if (bChanged) {
                    
                    this[n] = v;

                    var closeHandler = this._close_handler;

                    
                    if (v) {
                        if (this._curtain_to_body) {
                            this.resizeDialog();
                            this.positionDialog();
                        }

                        
                        if (this.autoClose) {
                            var me = this;

                            closeHandler = this._close_handler = closeHandler || function (evt) {
                                var t = $D.eventTarget(self, evt); 
                                if (t && t.parentNode && !$D.contains(me.editorNode, t, true, document.body)) {
                                    me.close();
                                }
                            };

                            $D.attachEvent(document.body, 'mousedown', closeHandler);
                        }
                    } else {
                        var curtainHandler = this._curtain_handler;

                        
                        if (curtainHandler) {
                            
                            $D.detachEvent(window, 'resize', curtainHandler);
                        }

                        
                        if (closeHandler) {
                            
                            $D.detachEvent(document.body, 'mousedown', closeHandler);
                        }
                    }
                }

                return bChanged;
            }
        }
    );

    mstrmojo.Editor.openEffect_fadeIn = {
        scriptClass: 'mstrmojo.fx.AnimateProp',
        slot: 'curtainNode',
        props: {
            backgroundColor: {
                start: 255,
                stop: 0,

                
                fn: function (v) {
                    v = Math.round(v);
                    return ['rgb(', v, ',', v, ',', v, ')'].join('');
                }
            }
        },

        preStart: function () {
            var target = this.target,
                widget = this.widget;

            widget.editorNode.style.display = 'block';

            if (!widget.modal) {
                return false;
            }

            target.style.display = 'block';
            mstrmojo.css.setOpacity(target, 60);

            return true;
        }
    };

    mstrmojo.Editor.closeEffect_fadeOut = {
        scriptClass: 'mstrmojo.fx.FadeOut',
        slot: 'curtainNode',
        start: 0.6,
        stop: 0,
        preStart: function () {
            var widget = this.widget;
            widget.editorNode.style.display = 'none';

            return !!widget.modal;
        }
    };
}());
(function(){
    mstrmojo.requiresCls("mstrmojo.Dialog",
                         "mstrmojo._IsAnchorable",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller");
    
    var $D = mstrmojo.dom;
    
    function fnCloseDialog(){
        mstrApp.closeDialog();
    }
    
    
    mstrmojo.Magnifier = mstrmojo.declare(
        
        mstrmojo.Dialog,
        
        [mstrmojo._IsAnchorable, mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],
        
        {
            scriptClass: "mstrmojo.Magnifier",
            
            cssClass: 'mstrmojo-magnifier anchor',

            markupString: '<div id="{@id}" class="mstrmojo-Dialog {@cssClass}">' +
                            '<div class="win mstrmojo-Editor" style="{@cssText}">' +
                                '<div class="mstrmojo-InfoViewer-Title"><div class="mstrmojo-Editor-title">{@title}</div></div>' +
                                '<div class="mstrmojo-InfoViewer-Content"></div>' + 
                                '<div class="mstrmojo-InfoViewer-Buttons"></div>' + 
                            '</div>' +
                            '<div class="mstrmojo-Editor-curtain"></div>' + 
                            '<div class="mstrmojo-Editor-tip"></div>' +
                         '</div>',
            
            anchorOrientation : 'h',
            
            anchorOffset: 0,
            
            baseTipClass: '',

            
            screenDim: null,
            
            width: 'auto',
            
            
            close: function close() {
                if (this.onClose) {
                    this.onClose();
                }
                
                $D.detachEvent(window, 'resize', fnCloseDialog);
                               
                this.destroy();
            },
            
            touchBegin: function touchBegin(touch) {
                
                this.helper.glowOnTap(touch.target);
            },
            
            touchTap: function touchTap(touch) {
                var target = touch.target;
                
                if (target === this.curtainNode) {
                    
                    mstrApp.closeDialog();
                }else {
                    
                    this.helper.handleTouchTap(target);
                }
            },
            
            touchSwipeEnd: function touchSwipeEnd(touch){
                this.helper.handleTouchSwipe(touch);
                this._super(touch);
            },
            
            preBuildRendering: function preBldRdr(){
                this._super();
                
                var dim = this.screenDim = mstrApp.getScreenDimensions(),
                    w = dim.w,
                    h = dim.h;
                
                if (mstrApp.isTablet()){
                    this.width = 'auto';
                }else{
                    
                    
                    this.width = (w > h ? (w * 0.4) : (w * 0.6)) + 'px';
                }
            },
            
            
            postBuildRendering: function(){
            	this._super();
                
                
                $D.attachEvent(window, 'resize', fnCloseDialog);                
            },
            
            
            updateContent: function () {
                var helper = this.helper;
                
                helper.createTitle(this.titleNode);
                
                helper.createContent(this.containerNode);
            },
            
            
            resizeAndPosition: function(anchorPos){
                var contentHeight = this.helper.getContentHeight(),
                    titleHeight = this.helper.titleHeight,
                    dim = this.screenDim,
                    totalHeight  = dim.h - 30, pos;

                
                this.height = Math.min(contentHeight, totalHeight - titleHeight);
                this.containerNode.style.height = this.height + 'px';
                
                this.updateScroller();
                
                if (anchorPos){
                    this.moveTo(anchorPos);
                }else{
                    pos = $D.position(this.editorNode);

                    
                    if (!(pos.x > 0 && pos.x + pos.w < dim.w && pos.y > 0 && pos.y + pos.h < dim.h)){
                        this.positionDialog();
                    }
                }
                
                window.setTimeout(function() {
                    mstrMobileApp.forceRepaint();
                }, 0);
            },
            
            
            moveTo: function(anchorPosition) {
                this.anchorPosition = anchorPosition;
                this.positionDialog();
            },
            
            
            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    idx = this.helper.currentTabIndex,
                    scrollEl = this.containerNode.children[idx];

                cfg.bounces = false;

                if (scrollEl){
                    
                    cfg.scrollEl = scrollEl;
    
                    
                    cfg.origin = cfg.origin || {
                        x: 0,
                        y: 0
                    };
    
                    
                    cfg.noVScroll = cfg.noHScroll = true;
                    
                    
                    var offsetEnd = Math.max(this.helper.getContentHeight() - this.height, 0);
    
                    
                    var enableScroll = cfg.vScroll = (offsetEnd !== 0);
                    if (enableScroll) {
                        
                        cfg.offset = {
                            y: {
                                start: 0,
                                end: offsetEnd
                            }
                        };
                    }
                }

                return cfg;
            }
        });
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Dialog",
                         "mstrmojo.array",
                         "mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo._IsAnchorable"
    					);
    
    var $DOM = mstrmojo.dom,
        $ARR = mstrmojo.array;
    
    
    
    
    
    
    mstrmojo.VisHeatMapPopupPanel = mstrmojo.declare(
    	mstrmojo.Container,
    	
		null,
    	
	{
		scriptClass: "mstrmojo.VisHeatMapPopupPanel",

		title: "",


		markupString: '<div id="{@id}" class="heatmap-popup-panel" style="{@cssText}">' +
					       '</div>',

			markupSlots: {
				containerNode: function () { return this.domNode;}
			},
			
			initialized: false,
			
			naviAction: null 
    	}
    );
    
	mstrmojo.VisHeatMapAnimation = (function () { 
		var animationSet = []; 
		return {
				animate: function (node, propName, orgStyle, targetStyle, duration, callback) { 
					var thisObj;
					var emptyPos = animationSet.length;
					for (var i = 0, len = animationSet.length; i < len; i++) {
						if (!animationSet[i]) { 
							emptyPos = i;
							continue;
						}
						if (animationSet[i].node === node && animationSet[i].propName === propName) {
							
							(animationSet[i].finalize(false)); 
							thisObj = animationSet[i];
							break;
						}
					}
					if (!thisObj) { 
						thisObj = {};
						thisObj.node = node;
						thisObj.index = emptyPos;
						thisObj.propName = propName;
						animationSet[emptyPos] = thisObj;
					}
					var startTime = (new Date()).getTime();
					var duration = duration || 500; 
					var interval = 20; 
					
					var timer = null;
					thisObj.finalize = function ( removeNode) {
						
						clearInterval(timer);
						timer = null;
						
						
						if (targetStyle.r !== undefined) { 
							targetStyle.a = targetStyle.a || 1;
							
							
							node.style[propName] = "";
						} else if (targetStyle.px !== undefined) { 
							node.style[propName] = targetStyle.px + "px";
						}
						
						
						if (removeNode) {
							delete animationSet[this.index];
						}
						
						
						if (callback) {
							callback();
						}
					};
					
					function setStyle () {
						
						var curStyle = {};
						var curTime = (new Date()).getTime();
						var timeDiff = curTime - startTime;
						if (timeDiff >= duration) {
							
							thisObj.finalize(true); 
							return;
						}
						
						for (var prop in orgStyle) {
							curStyle[prop] = (targetStyle[prop] - orgStyle[prop]) * timeDiff / duration + orgStyle[prop]; 
							if (prop !== "a") {
								curStyle[prop] = Math.round(curStyle[prop]);
							}
						};
						
						if (curStyle.r) { 
							curStyle.a = curStyle.a || 1;
							node.style[propName] = "rgba(" + curStyle.r + "," + curStyle.g + "," + curStyle.b + "," + curStyle.a + ")";
						} else if (curStyle.px) { 
							node.style[propName] = curStyle.px + "px";
						}
					}
					timer = setInterval(setStyle, interval);
				}
			};
	})();
    
    
    
    mstrmojo.VisHeatMapPopup = mstrmojo.declare(

    	mstrmojo.Container,

    	
		null,
        
        
        {
            scriptClass: "mstrmojo.VisHeatMapPopup",
            
            
            fadeOnClose: false,
            
            
            autoClose: true,
            
            
            markupString:'<div style="display: -webkit-box; -webkit-box-align: start; -webkit-box-pack: center;position:absolute; left:0px; top:0px; z-index:100000; width: 100%; height:100%;"  id={@id} mstrAttach:mouseup,touchend>' + 
	            			'<div id={@id} style=" position:relative; left: 0px; top: 0px; width:{@width}; background-color:#F5F5F5;z-index:100001;border:2px solid rgba(0, 0, 0, 0.1);-webkit-box-shadow:rgba(0, 0, 0, 0.45) 2px 2px 8px;">' +
	        						'<div  class="heatmap-popup-panel-title" style="display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: center;position:relative; -webkit-box-sizing: border-box; margin-bottom:6px; padding-right: 25%; height:65px; width:100%; line-height:65px;vertical-align:bottom;color:#33b5e5;">' +
	        							
	        						'</div>' +
	        						'<div style="height: 2px;width:100%;background-color:#33b5e5">' +
	        						'</div>' +
	        						'<div style="width:100%; height:auto; position:relative;overflow:hidden; display: -webkit-box; -webkit-box-orient: horizontal">' +
	        						'</div>' +
	    					'</div>' +
	    					'<div style="position:absolute;z-index:100000;top:0px;left:0px;width:100%;height:100%;background: rgba(0, 0, 0, 0.5);">' +
	    					'</div>' +
    					'</div>',

			markupSlots: {
				contentNode: function () {return this.domNode.firstChild;},
				titleNode: function () {return this.domNode.firstChild.firstChild;},
				
				containerNode: function () {return this.domNode.firstChild.lastChild;},
				curtainNode: function () {return this.domNode.lastChild;}
			},
         
			baseTipClass: "heatmap-editor-tip",
			
			
			anchorOffset: 42,
			
			
			hasCloseButton: true,

            goBack: function () {
                    
                    return this.close();
            },
			
			
            
			close: function () {
                    this.domNode.style.webkitTransform = 'translate(-100000px,0px)';
                    this.destroy();
                    
                    return true;
			},

            destroy: function() {
                    this.onClose();
                    if(this._super){
                            this._super();
                    }
            },

			postBuildRendering: function () {
				this._super();

				
				
				
				for (var i = 0, len = this.panels.length; i < len; i++) {
					
					if (i !== 0) {
						
						var div = document.createElement("div");
						div.style.cssText = "position:relative;width:1px;color:grey;height:35px;text-align:center;background-color:grey;"; 
						
						this.titleNode.appendChild(div);
					}
					var div = document.createElement("div");
					div.style.cssText = "-webkit-box-flex:1; line-height:65px;text-align:center; display: -webkit-box; -webkit-box-align: center; -webkit-box-pack: center; height:100%;";
                    if(i==0)
                            div.style.cssText += 'margin-left:16px;';
                    else
                            div.style.cssText += 'margin-right:16px;';
					div.setAttribute("panel", i);
					div.innerText = this.panels[i].title;
					this.titleNode.appendChild(div);
				}
				
				var that = this;
				document.body.appendChild(this.domNode);
				
				this.panelStack = 0;
				this.navigateTo(0);
                this.contentNode.style.marginTop = parseInt((document.body.offsetHeight - this.contentMaxHeight - this.titleNode.offsetHeight) / 2) + 'px';
			},			
			
			
			onmouseup: function (event) {
				if (event.e.target === this.curtainNode) {
					this.close();
					return;
				}
				var title = mstrmojo.dom.findAncestorByAttr(event.e.target, "panel", true, this.domNode);
				if (!title) {
					return;
				}

				
				
				
				title.node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
				var callback = function () {
					mstrmojo.VisHeatMapAnimation.animate(title.node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
				};
				var that = this;
				setTimeout(function () {
    		   		setTimeout(function () {
    		   			that.navigateTo(title.value);
    		   			callback();
    		   		}, 0);
    		   },0); 
				
			},
			
			ontouchend: function (event) {
				this.onmouseup(event);
			},

            highlightTitle: function (titleIndex) {
                    titleIndex =  2*parseInt(titleIndex);
                    if(isNaN(titleIndex))
                            return;
                    var titles = this.titleNode.childNodes,
                        len = titles.length;
                    for( var i = 0; i < len; i+=2){
                        if(i != titleIndex){
                               titles[i].style.borderBottom = '';
                        }else{
                                titles[i].style.borderBottom = 'solid 6px #33b5e5';
                        }
                    }
            },
			
            
            panelStack: 0, 
            
			
			navigateTo: function (panelIndex) {
                this.highlightTitle(panelIndex);

				var newPanel = this.panels[panelIndex];
				var curPanel = this.panelStack;
			    var oldPanel = this.panels[curPanel];
                
                if(panelIndex != curPanel){
                        if(oldPanel.hasRendered){
                                oldPanel.domNode.style.display = 'none';
                        }
                }
				if (!newPanel.hasRendered) {
					this.panels[panelIndex] = new mstrmojo.VisHeatMapPopupPanel(this.panels[panelIndex]);
					var newPanel = this.panels[panelIndex];
					this.addChildren(newPanel);
					this.renderChildren();
					
					
				}
                newPanel.domNode.style.display = 'block';
				if (newPanel.naviAction) {
					newPanel.naviAction(); 
				}

				
				
				if (curPanel === panelIndex) {
					
					
					
					delete newPanel.domNode.style["webkitTransform"];
				} else {
					
					var oldWidth = oldPanel.domNode.offsetWidth + "px";
					var newWidth = newPanel.domNode.offsetWidth + "px";

					
					
					var maxWidth = Math.max(parseInt(oldWidth), parseInt(newWidth));
					
					delete newPanel.domNode.style["webkitTransition"];
					var newStyle = "";
					var oldStyle = "";
					if (curPanel < panelIndex) { 
						newStyle = "translate(-" + maxWidth + "px,0px)";
						
						oldStyle = "translate(-" + maxWidth + "px,0px)";
					} else { 
						newStyle = "translate(" + maxWidth + "px,0px)";
						
						oldStyle = "translate(" + maxWidth + "px,0px)";
					}
					
					
					
					
                    
					this.panelStack = panelIndex;

					
				}
				
				
				
				
				
				
				
			},
			
            animation: function (newPanel, oldPanel, oldStyle) {
            	
            	
				oldPanel.domNode.style["webkitTransform"] = oldStyle;
            	
				newPanel.domNode.style["webkitTransform"] = oldStyle;
				
            },
			
			
			
			dummy: true
        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Dialog",
                         "mstrmojo.array",
                         "mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo._IsAnchorable");

    var $DOM = mstrmojo.dom,
        $ARR = mstrmojo.array;

    
    mstrmojo.android.Popup = mstrmojo.declare(

        mstrmojo.Dialog,

        [mstrmojo._IsAnchorable],

        
        {
            scriptClass: "mstrmojo.android.Popup",

            
            fadeOnClose: false,

            
            autoClose: true,

            
            init: function init(props) {
                
                this._super(props);

                
                if (this.anchor) {
                    mstrmojo.css.addWidgetCssClass(this, 'anchor');
                }
            },

            addChildren: function addChildren(children, idx, silent) {
                this._super(children, idx, silent);

                
                $ARR.forEach(this.children, function (child) {
                    
                    if (child.isElastic) {
                        
                        this._elasticChild = child;

                        
                        return false;
                    }
                }, this);
            },

            resizeDialog: function resizeDialog() {
                
                var editorNode = this.editorNode,
                    app = mstrApp,
                    dimensions = app.getScreenDimensions(),
                    mh = Math.round(dimensions.h * 0.9),
                    w = dimensions.w,
                    contentHeight;

                
                w = w * 0.85;

                
                if (app.isTablet()) {
                    var popDimensions = this.popDimensions || {},
                        tabletDimensions = mstrApp.getScreenDimensions();

                    
                    mh = popDimensions.h || Math.min(Math.round(tabletDimensions.h * 0.6), mh);
                    w = popDimensions.w ||  Math.min(Math.round(tabletDimensions.w * (mstrApp.isLandscape() ? 0.43 : 0.65)), w);
                }

                
                w += 'px';

                
                var elasticChild = this._elasticChild;
                if (elasticChild) {
                    
                    var elasticHeight = elasticChild.elasticHeight;
                    if (elasticHeight) {
                        
                        contentHeight = elasticHeight;

                    
                    } else if (elasticChild.getItemsContainerHeight) {
                        
                        contentHeight = elasticChild.getItemsContainerHeight();
                    }
                }

                
                if (contentHeight === undefined) {
                    
                    contentHeight = this.getAvailableContentSpace();

                    
                    
                    mh = Math.max( mh, contentHeight + (this.titleNode.offsetHeight + this.buttonNode.offsetHeight) );
                    
                } else {
                    
                    contentHeight = Math.min(contentHeight, mh - (this.titleNode.offsetHeight + this.buttonNode.offsetHeight));
                }

                
                if (editorNode) {
                    
                    editorNode.style.maxHeight = mh + 'px';

                    
                    this.set('width', w);
                } else {
                    
                    this.width = w;
                    this.cssText = (this.cssText || '') + 'max-height:' + mh + 'px;';
                }

                
                this.raiseEvent({
                    name: 'popupResized',
                    maxheight: mh,
                    height: contentHeight,
                    width: parseInt(w, 10)
                });

                
                if (elasticChild) {
                    
                    var h = elasticChild.height;
                    if (h !== undefined && h !== 'auto') {
                        
                        elasticChild.set('height', 'auto');
                    }

                    
                    elasticChild.set('height', contentHeight + 'px');

                    
                    
                    if (elasticChild.updateScroller) {
                        
                        elasticChild.updateScroller();
                    }
                }

                this._super();
            },

            getAvailableContentSpace: function getAvailableContentSpace() {
            	
            	
                return Math.max(this.containerNode.offsetHeight, this.editorNode.clientHeight - this.titleNode.offsetHeight - this.buttonNode.offsetHeight);
            },

            close: function close() {
                
                if (this.onClose) {
                    
                    this.onClose();
                }

                
                if (this.fadeOnClose) {
                    
                    var domNode = this.domNode;
                    if (domNode) {
                        var id = this.id;

                        if (!$DOM.isWinPhone) {

                            $DOM.attachOneTimeEvent(domNode, $DOM.CSS3_TRANSITION_END, function () {
                                mstrmojo.all[id].destroy();
                            });

                            
                            domNode.style.opacity = 0;

                        } else {

                            (new mstrmojo.fx.FadeOut({
                                onEnd: function () {
                                    mstrmojo.all[id].destroy();
                                },
                                target: domNode,
                                duration: 400
                            })).play();

                        }
                    }
                } else {
                    this.destroy();
                }
            },

            onclick: function onclick(evt) {
                
                if (this.autoClose && evt.e.target === this.curtainNode) {
                    
                    this.close();
                }
            },

            ontouchend: function ontouchend(evt) {
                
                this.onclick(evt);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.SliderBox",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.ui.MobileSlider",
                         "mstrmojo.num");

    var INPUT_VALUES_MANUAL = 1,
        $NUM = mstrmojo.num;

    mstrmojo.android.inputControls.SliderDIC = mstrmojo.declare(
        mstrmojo.SliderBox,

        [ mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: "mstrmojo.android.inputControls.SliderDIC",

            popupStyle: 1,

            init: function init(props) {
                
                
                var sbMin, sbMax, sbItv, sb;

                this._super(props);
                this.items = this.getItems();

                this.cssClass = this.showByDefault ? 'mstrmojo-SliderGroup' : 'mstrmojo-PopupSlider';

                if (this.dic.ipt !== INPUT_VALUES_MANUAL) {
                    this.isSequential = true;
                    sbMax = this.max = this.dic.max;
                    sbMin = this.min = this.dic.min;
                    sbItv = this.interval = this.dic.itv;
                } else {
                    sbMin = 1;
                    sbMax = this.items.length;
                    sbItv = 1;
                }

                sb = this.sliderBar;
                if (sb) {
                    sb.min = sbMin;
                    sb.max = sbMax;
                    sb.interval = sbItv;
                }
            },

            preBuildRendering: function preBuildRendering() {
                
                var dic = this.dic,
                    ldw = (dic.ldw != null) ? dic.ldw / 100 : 0.4,
                    os;

                this.valueText = this.dv;
                this._super();

                
                if (this.showByDefault) {
                    
                    
                    os = this.openerStyle;
                    
                    this.valueCssText = 'left:-' + os.iw * ldw + 'px;width:' + os.iw * ldw + 'px';
                    this.cssText = 'width:' + os.iw * (1 - ldw) + 'px';

                    this.alignSlider(this.openerNode, os.ih);
                }
            },

            onpopupResized: function onpopupResized() {
                var sb = this.sliderBar;
                if (sb) {
                    sb.refresh();
                }
            },

            
            sliderRef: {
                scriptClass: "mstrmojo.ui.MobileSlider",
                onslidingValueChange: function () {
                    if (this.hasRendered) {
                        this.selectedIdx = parseInt((this.slidingValue - this.min) / this.interval, 10) || 0;
                        this.parent.selectedIdxChanged(this.selectedIdx);
                    }
                },
                
                selectedIdx: 0,
                
                select: function (v) {
                    this.selectedIdx = v || 0;
                    this.slidingValue = this.value = this.min + v * this.interval;
                }
            },

            
            selectedIdxChanged: function selectedIdxChanged(v) {
                var item = this.items[v],
                    sv = item && item.n;
                
                this.set('value', $NUM.toLocaleString(sv));
                this.set('valueText', $NUM.toLocaleString(sv));
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo.ToolBar",
                         "mstrmojo.boxmodel",
                         "mstrmojo.array",
                         "mstrmojo.EnumRWUnitType",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var MOVE_FMTS = ['background-color',
                  'border',
                  'border-color',
                  'border-left',
                  'border-style',
                  'border-top',
                  'border-width',
                  'filter',
                  'top',
                  'left',
                  'z-index',
                  'fx',
                  'normWidth',
                  'normHeight',
                  'normZIndex',
                  'normTop',
                  'normLeft',
                  'tbborder',
                  'lrborder',
                  'ttl'],
        COPY_FMTS = ['width', 'height'],
        P_FMTS = 'p_fmts';

    var $PX = 'px';

    
    var ETS = {
        
        getContentHeight: function (h, f) {
            var th = f.ttl && f.ttl.height;
            if (h && th && !this.floatingToolbar) {
                
                return Math.max(parseInt(h, 10) - parseInt(th, 10), 0) + $PX;
            }

            return '';
        },

        getPortletMinHeight: function (f) {
            return f.ttl.height;
        },

        adjustTitleCss: function (ptlt) {
            return;
        }
    };

    
    var FTS = {
        getContentHeight: function (h, f) {
            return h;
        },
        getPortletMinHeight: function () {
            return 0;
        },
        adjustTitleCss: function (ptlt) {



            ptlt.titlebarNodeClass += ' floating';
            return;
        }
    };

    
    function passDirtyKey(method, key) {
        var parent = this.parent,
            methodName = method + 'DirtyKey';

        if (parent[methodName]) {
            parent[methodName](key);
        }
    }


    function updateTitle() {
        
        var title = this.title;

        
        if (this.count) {
            
            title += ' ' + this.count;
        }

        
        this.toolbarTitleTextNode.innerHTML = title;
    }

    function retrieveFilterPanel() {
        
        var parent = this.parent,
            parentDefn = parent && parent.defn;

        
        if (parentDefn && parseInt(parentDefn.t, 10) === mstrmojo.EnumRWUnitType.PANEL) {
            
            var panelStack = parent.parent,
                panelStackDefn = panelStack.defn;

            
            if (panelStackDefn && panelStackDefn.ifp) {
                
                return panelStack;
            }
        }

        return null;
    }

    var $HASH = mstrmojo.hash,
        ITEM_SPA = 2;

    mstrmojo.DocPortlet = mstrmojo.declare(
        
        mstrmojo.Container,

        
        [mstrmojo._Formattable],

        
        {
            scriptClass: 'mstrmojo.DocPortlet',
            
            floatingTitle: false,
            
            floatingTitleHeight: 30,
            
            buttonWidth: 17,

            markupString:
                '<div class="mstrmojo-portlet {@borderCss}" style="{@portletNodeCssText}">' +
                    '<div class="mstrmojo-portlet-slot-shadow" style="{@shadowNodeCssText}"></div>' +
                    '<div class="mstrmojo-portlet-container" style="{@portletContainerNodeCssText}">' +
                        '<div class="mstrmojo-portlet-titlebar {@titlebarNodeClass}" style="{@titlebarNodeCssText}">' +
                            '<table style="height:100%;width:100%" class="mstrmojo-portlet-titlebar-table" cellspacing="0" cellpadding="0">' +
                            '<tr>' +
                                '<td class="mstrmojo-portlet-slot-toolbar-left {@leftToolbarNodeClass}" style="{@leftToolbarNodeCssText}"></td>' +
                                    '<td class="mstrmojo-portlet-title" style="{@titleNodeCssText}"><div style="overflow: hidden;">{@title} {@count}</div></td>' +
                                '<td class="mstrmojo-portlet-slot-toolbar {@toolbarNodeClass}" style="{@rightToolbarNodeCssText}"></td>' +
                                '</tr>' +
                            '</table>' +
                        '</div>' +
                        '<div class="mstrmojo-portlet-buttonbar {@buttonbarNodeClass}" style="{@buttonbarNodeCssText}"></div>' +
                        '<div class="mstrmojo-portlet-slot-content" style="{@contentNodeCssText}"></div>' + 
                    '</div>' +
                '</div>',

            rightToolbarNodeCssText: '',
            leftToolbarNodeCssText: '',
            titleNodeCssText: '',
            titlebarNodeClass: '',
            titlebarNodeCssText: '',
            contentNodeCssText: '',
            borderCss: 'no-border',
            buttonbarNodeClass: '',
            buttonbarNodeCssText: '',
            markupSlots: {
                containerNode: function () {return this.domNode.lastChild; }, 
                portletNode: function () {return this.domNode; },
                portletContainerNode: function () {return this.domNode.lastChild; },
                dimNode: function () {return this.domNode.lastChild; }, 
                shadowNode: function () { return this.domNode.firstChild; },
                titleNode: function () {return this.domNode.lastChild.childNodes[0]; },
                buttonbarNode: function() {return this.domNode.lastChild.childNodes[1];},
                toolbarNode: function () { return this.domNode.lastChild.firstChild.childNodes[0].rows[0].cells[2]; }, 
                toolbarTitleTextNode: function () { return this.domNode.lastChild.firstChild.childNodes[0].rows[0].cells[1].firstChild; },
                leftToolbarNode: function () { return this.domNode.lastChild.firstChild.childNodes[0].rows[0].cells[0]; },
                contentNode: function () { return this.domNode.lastChild.lastChild; }
            },

            markupMethods: {
                ontitleChange: function(){
                    updateTitle.call(this);
                },
                oncountChange: function () {
                    updateTitle.call(this);
                },
                onfcChange: function () {
                    if (this.fc && this.content) {
                        this.updateContentHeight();
                    }
                }
            },

            formatHandlers: {
                
                portletContainerNode: [ 'RW', 'B'], 
                shadowNode: [ 'RW', 'B', 'fx', 'background-color' ], 
                titlebarNode: {
                        src: 'ttl',
                        props: ['F', 'B', 'background-color', 'height', 'fx', 'text-align', 'vertical-align']
                    },
                titleNode : {
                    src: 'ttl',
                    props: ['vertical-align', 'P', 'text-decoration']
                },
                buttonbarNode: {
                     src: 'ttl',
                     props: ['background-color']
                }
            },

            
            fc: false, 

            
            content: null,
            
            rightToolbar: null,
            
            leftToolbar: null,
            
            floatingToolbar: false,
            
            _ts: ETS,
            
            getCacheKey: function getCacheKey(w){
                return this._super(w) + '-portlet';
            },
            
            getFormats: function getFormats() {
                var c = this.content,
                f = c && c.getFormats();

                return f && f[P_FMTS];
            },

            updateContentHeight: function updateContentHeight(bHide) {
                var pf = this.getFormats(),
                    cnt = this.content,
                    node = cnt.dimNode  || cnt.domNode,
                    h = ((pf.ttl && parseInt(pf.ttl.height, 10)) || 0);

                if (node){
                    if (!bHide) {
                        h += ((this.fc || this.isInFilterPanel()) ? node.offsetHeight : (pf.height ? parseInt(pf.height, 10) : 0));
                    }

                    this.containerNode.style.height = h + $PX;
                    this.shadowNode.style.height = h + $PX;
                }
            },


            
            init: function init(props) {
                
                this._super(props);

                var content = this.content;

                
                
                if (content && content.getFormats() && !this.getFormats()) {
                    
                    this._createFormats();
                }
            },

            
            preBuildRendering: function preBuildRendering() {
                
                var ts = this._ts = (this.floatingTitle) ? FTS : ETS;

                
                this._super();

                
                ts.adjustTitleCss(this);

                var displayNone = "display:none;";

                if (this.isInFilterPanel()) {
                    var f = $HASH.clone(this.formatHandlers);
                    f.portletContainerNode = ['z-index', 'height', 'B', 'backgroud-color'];
                    f.shadowNode = ['z-index', 'height', 'B', 'fx', 'background-color'];
                    this.formatHandlers = f;
                }

                if (!this.leftToolbar){
                    this.leftToolbarNodeCssText += displayNone;
                }

                if (!this.toolbar){
                    this.toolbarNodeCssText += displayNone;
                }

                
                var borderWidths = mstrmojo._Formattable.getBorderWidths(this);
                if (borderWidths.l || borderWidths.t || borderWidths.r) {
                    
                    this.borderCss = 'has-border';
                }
             },

            
            postBuildRendering: function postBuildRendering() {
                    
                    var dom = mstrmojo.dom,
                        css = mstrmojo.css,
                        d = this.contentNode,
                        t = this.titleNode,
                        me = this;

                if (this.titleNode) {
                    if (this.floatingTitle) {
                        
                        document.body.appendChild(this.titleNode);


                    if (!this._onhover){
                        
                        this._onhovertt = function() {
                            
                            css.addClass(me.titleNode, ['visible']);
                            me._onflt = true;
                            return true;
                        };
                        
                        this._onhoverofftt = function() {
                            css.removeClass(me.titleNode, ['visible']);
                            me._onflt = false;
                            return true;
                        };
                        
                        this._onhover = function () {
                            var t = me.titleNode;
                            
                            css.addClass(t, ['visible']);
                            
                            var p = dom.position(me.contentNode, true);
                            t.style.top = (p.y - t.clientHeight + 2) + $PX; 
                            t.style.left = p.x + $PX;
                            return true;
                        };
                        
                        this._onhoveroff = function () {
                            css.removeClass(me.titleNode, ['visible']);
                            return true;
                        };
                    }
                    dom.attachEvent(d, 'mouseover', this._onhover);
                    dom.attachEvent(d, 'mouseout', this._onhoveroff);
                    
                    dom.attachEvent(t, 'mouseover', this._onhovertt);
                    dom.attachEvent(t, 'mouseout', this._onhoverofftt);
                }

                    
                    if (this.attachContextMenuEvent) {
                        
                        this._oncontextmenu = function ( e,  hWin) {
                            var btn = me.rightToolbar && me.rightToolbar.btnMenu;

                            if (btn) {
                                btn.cmPos = dom.getMousePosition(e, hWin);
                                btn.openPopupMenu();
                                btn.cmPos = null;

                                dom.preventDefault(hWin, e);
                            }
                        };
                        dom.attachEvent(t, 'contextmenu', this._oncontextmenu);
                    }
                }

                if (this._super) {
                    this._super();
                }

                
                var pf = this.getFormats();
                this.set('fc', pf && !pf.height);

                if (this.isInFilterPanel() && !this.isHorizFP()) {
                    var portletContainerNodeStyle = this.portletContainerNode.style,
                        shadowNodeStyle = this.shadowNode.style,
                        parent = this.parent;
                    portletContainerNodeStyle.width = shadowNodeStyle.width = '99%';
                    portletContainerNodeStyle.top = shadowNodeStyle.top = parent.topStart + $PX;
                    portletContainerNodeStyle.left = shadowNodeStyle.left = ITEM_SPA + $PX;
                }
                
                else if (this.isInFilterPanel() && this.isHorizFP()) {
                    ITEM_SPA = 8;

                    this.portletContainerNode.style.left = this.shadowNode.style.left = parseInt(pf.left) + ITEM_SPA * this.orgPos + $PX;
                }
                
                else if (this.defn.ifp){
                	this.adjustFPHeight2Fit();
                }
            },
            adjustFPHeight2Fit: function(){
            	var dom = mstrmojo.dom,
            		ttl = dom.position(this.titleNode),
        			btn_h = dom.position(this.contentNode).y - ttl.y - ttl.h;
            	this.content.domNode.style.height = parseInt(this.defn.fmts.height) - btn_h + 'px';
            },
            
            unrender: function unrender(ignoreDom) {

                if (this.floatingTitle && this.titleNode) {
                    var d = this.domNode,
                        t = this.titleNode,
                    dom = mstrmojo.dom;

                    if (d && this._onhover){
                        dom.detachEvent(d, 'mouseover', this._onhover);
                    }
                    if (d && this._onhoveroff) {
                        dom.detachEvent(d, 'mouseout', this._onhoveroff);
                    }
                    
                    if (t && this._onhovertt) {
                        dom.detachEvent(t, 'mouseover', this._onhovertt);
                    }
                    if (t && this._onhoverofftt) {
                        dom.detachEvent(t, 'mouseout', this._onhoverofftt);
                    }
                    if (t && this._oncontextmenu) {
                        dom.detachEvent(t, 'contextmenu', this._oncontextmenu);
                    }

                    if(t) {
                        document.body.removeChild(t);
                    }
                }
                if (this._super) {
                    this._super(ignoreDom);
                }
            },

            updateStyle: function (h, w) {
                var snStyle = this.shadowNode.style,
                    cnStyle = this.containerNode.style;
                snStyle.height = cnStyle.height = h;
                snStyle.width = cnStyle.width = w;
            },

            
            _createFormats: function _createFormats() {
                var c_f = this.content && this.content.getFormats(),
                    f;
                
                f = c_f.p_fmts = {};
                var i, p;
                
                for (i in MOVE_FMTS) {
                    p = MOVE_FMTS[i];
                    if (p in c_f) {
                        f[p] = c_f[p];
                        delete c_f[p];
                    }
                }
                
                for (i in COPY_FMTS) {
                    p = COPY_FMTS[i];
                    if (p in c_f) {
                        f[p] = c_f[p];
                    }
                }
                

                
                c_f.height = this._ts.getContentHeight(c_f.height, f);

                
                
                if (mstrmojo.dom.isIE&&f.fx && f.fx.ds && !f['background-color']){
                    f['background-color'] = '#ffffff';
                }
            },

            
            refresh: function refresh() {
                if (!this.hasRendered) {
                    return;
                }

                
                var c = this.children,
                    i;
                for (i = c.length - 1; i >= 0; i--) {
                    c[i].refresh();
                }
                
                
                
            },

            isInFilterPanel: function isInFilterPanel() {
                return (retrieveFilterPanel.call(this) !== null);
            },

            isHorizFP: function(){
                if(this.isInFilterPanel()){
                    var fp = this.getFilterPanel();
                    return fp && fp.defn && fp.defn.fds == 2;
                }else{
                    return false;
                }
            },

            getFilterPanel: function getFilterPanel() {
                return retrieveFilterPanel.call(this);
            },

            getContainerHeight: function getContainerHeight() {
                return this.containerNode.clientHeight;
            },

            relocate: function relocate(top, width) {
                if (this.isInFilterPanel() && !this.isHorizFP()) {
                    this.portletContainerNode.style.top = this.shadowNode.style.top = top + $PX;
                }
            },

            
            setInfoWindowDimensions: function setInfoWindowDimensions(d) {
                var domNodeStyle = this.domNode.style,
                    shadowStyle = this.shadowNode.style,
                    containerStyle = this.portletContainerNode.style,
                    borderWidths = mstrmojo._Formattable.getBorderWidths(this);

                
                d.h -= borderWidths.h;
                d.w -= borderWidths.w;

                
                shadowStyle.height = containerStyle.height = domNodeStyle.height = d.h + $PX;
                shadowStyle.width = containerStyle.width = domNodeStyle.width = d.w + $PX;

                
                d.h -= this.titleNode.offsetHeight;

                
                this.toolbarNode.style.display = 'none';
            },

            
            addDirtyKey: function addDirtyKey(key) {
                passDirtyKey.call(this, 'add', key);
            },

            
            removeDirtyKey: function removeDirtyKey(key) {
                passDirtyKey.call(this, 'remove', key);
            },

            
            setDirtyChildren: function setDirtyChildren() {
                
                var contentChild = this.content;
                if (contentChild && contentChild.setDirtyChildren) {
                    
                    contentChild.setDirtyChildren.apply(contentChild, arguments);
                }
            }
        }
    );

    
    var ST_RESTORE = 0,
        ST_MIN = 1,
        ST_MAX = 2;

    
    function updateWindowState(v, oh, ow, evt) {

        
        var w = this.content,
            key = w.k,
            px = mstrmojo.boxmodel.px2Inches,
            m = w.model.docModel || w.model,
            f = this.getFormats(),
            callback = {},
            me = this,
            fnUpdateDS = function () {
                var defn = me.content && me.content.defn;
                if (defn) {
                    defn.set('ds', v);      
                }
            },
            propValues = {                  
                ZIndex: f['z-index'],
                WindowState: v
            },
            props = {};

        props[key] = propValues;

        
        if (oh !== undefined && ow !== undefined) {
            
            $HASH.copy({
                OldHeight: px(m, oh),
                OldWidth: px(m, ow),

                
                Height: px(m, parseInt(f.height, 10)),      
                Width: px(m, parseInt(f.width, 10))         
            }, propValues);

            
            callback.success = function (res) {
                
                var data = res && res.data;
                if (data) {
                    
                    w.model.loadPartialData(data, key);
                }

                
                fnUpdateDS();

                
                var p = me.parent;
                if ('adjustSectionSize' in p) {
                    
                    p.adjustSectionSize();
                }
            };

            
            m.saveRWProps(key, props, 1, this.loadDataOnResize, callback, true);

        } else {
            
            fnUpdateDS();
            if (!(evt && evt.all)) {
                m.saveRWProps(key, props, 1, this.loadDataOnResize, callback, true);
            }
        }

        return props;
    }

    
    function onWindowStateChange() {
        
        

        
        
        var content = this.content;
        if (!content) {
            
            
            return;
        }

        var fnUpdateBtnState = function (children) {
                
                mstrmojo.array.forEach(children, function (child) {
                    
                    if ('ds' in child) {
                        
                        child.set('visible', (child.ds !== content.defn.ds));
                    }
                });
            },
            toolbar;

        
        if (this.isInFilterPanel()) {

            
            var isRestore = (parseInt(this.defn.ds, 10) === ST_RESTORE);
            content.set('visible', isRestore);
            this.updateContentHeight(!isRestore);

            
            toolbar = this.leftToolbar;
            fnUpdateBtnState(toolbar && toolbar.children);

            
            var p = this.parent;
            if (p.refreshFP) {
                p.refreshFP();
            }

        } else {
            
            var c_f = content.getFormats(),                     
                p_f = this.getFormats(),                        
                ps = this.portletContainerNode.style,
                ss = this.shadowNode.style,
                cs = this.contentNode.firstChild.style;

            
            cs.height = c_f.height;
            cs.width = c_f.width;

            
            ss.height = ps.height = p_f.height;
            ss.width = ps.width = p_f.width;
            ss.top = ps.top = p_f.top;
            ss.left = ps.left = p_f.left;

            
            if ('z-index' in p_f) {
                
                ss.zIndex = ps.zIndex = p_f['z-index'];
            }

            
            toolbar = this.rightToolbar;
            fnUpdateBtnState(toolbar && toolbar.children);

            
            if (content.resize) {
                
                content.resize();
            }
        }
    }

    mstrmojo.DocResizablePortlet = mstrmojo.declare(
            
            mstrmojo.DocPortlet,

            
            null,

            
            {
                scriptClass : 'mstrmojo.DocResizablePortlet',

                
                loadDataOnResize: false,

                
            _createFormats: function _createFormats() {
                    
                    this._super();

                    var f = this.getFormats();

                    
                var ds = parseInt(this.defn.ds, 10);    

                    
                    
                    if (ds === ST_RESTORE) {
                        
                        f.normHeight = f.height;
                        f.normWidth = f.width;
                        if (f['z-index'] !== null && f['z-index'] !== undefined) {
                            f.normZIndex = f['z-index'];
                        }
                    }

                    
                    if (ds !== ST_MAX) {
                        f.normTop = f.top;
                        f.normLeft = f.left;
                    }
                },

                
            onmaximize: function onmaximize() {

                    var p = this.parent,
                        c = this.content,
                        c_f = c && c.getFormats(),
                        f = this.getFormats(),
                        oh = f.height,
                        ow = f.width,
                        bw = mstrmojo._Formattable.getBorderWidths(this);

                    this.clearCache();
                    c.clearCache();

                    
                f.height = (parseInt(p.height(), 10) - bw.h) + $PX;
                    
                    c_f.height = this._ts.getContentHeight(f.height, f);
                    
                f.width = c_f.width = (p.width() - bw.w) + $PX;
                    f.top = f.left = 0;
                    f['z-index'] = p.getMaxZIndex() + 1;

                    
                updateWindowState.call(this, ST_MAX, oh, ow);
                },
                
            onminimize: function onminimize() {

                    var c = this.content,
                    node = c.dimNode  || c.domNode,
                        c_f = c && c.getFormats(),
                        f = this.getFormats(),
                    oh = f.height || node.offsetHeight,
                        ow = f.width;

                    this.clearCache();
                    c.clearCache();

                    
                    f.width = c_f.width = f.normWidth;
                    
                    f.top = f.normTop;
                    
                    f.left = f.normLeft;
                    
                    if (f.normZIndex !== null && f.normZIndex !== undefined) {
                        f['z-index'] = f.normZIndex;
                    }

                    
                    c_f.height = 0;
                    
                    f.height = this._ts.getPortletMinHeight(f);

                    
                updateWindowState.call(this, ST_MIN, oh, ow);
                },
                
            onrestore: function onrestore() {

                    var c = this.content,
                        c_f = c && c.getFormats(),
                        f = this.getFormats(),
                        oh = f.height,
                        ow = f.width;

                    this.clearCache();
                    c.clearCache();

                    
                    f.height = f.normHeight;
                    
                    c_f.height = this._ts.getContentHeight(f.height, f);
                    
                    f.width = c_f.width = f.normWidth;
                    
                    f.top = f.normTop;
                    
                    f.left = f.normLeft;
                    
                    if (f.normZIndex !== null && f.normZIndex !== undefined) {
                        f['z-index'] = f.normZIndex;
                    }

                    
                updateWindowState.call(this, ST_RESTORE, oh, ow);
                },
                
            oncollapse: function oncollapse(evt) {
                return updateWindowState.call(this, ST_MIN, undefined, undefined, evt);
            },
            
            onexpand: function onexpand(evt) {
                
                return updateWindowState.call(this, ST_RESTORE, undefined, undefined, evt);
            },

                
                postBuildRendering: function postBuildRendering() {
                    
                    if (!this._sub_dsChange) {
                    this._sub_dsChange = this.defn.attachEventListener('dsChange', this.id, onWindowStateChange);
                    }

                    this._super();

                    
                    
                    if (this.isInFilterPanel()) {
                    
                    var isRestore = (parseInt(this.defn.ds, 10) === ST_RESTORE);
                	this.updateContentHeight(!isRestore);
                    }
                }
            }
        );
}());
(function() {

    mstrmojo.requiresCls("mstrmojo.ServerProxy",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.Box",
                         "mstrmojo.TextBoxWithLabel",
                         "mstrmojo.Label",
                         "mstrmojo.hash",
                         "mstrmojo.mstr.EnumWebAPIErrorCodes");

    mstrmojo.requiresDescs(11,17,18,26,7904,5088,9935,10672);

    var $mobileLogin = 'mobileLogin',
        $chgPassword = 'changePassword',
        $BTN = mstrmojo.android.ui.Button.newButton,
        $DESC = mstrmojo.desc,
        $H = mstrmojo.hash,
        $ERRS = mstrmojo.mstr.EnumWebAPIErrorCodes,
        sessions = {},
        localeInfoMap = {},
        EnumDeviceType = { ANDROID_PHONE: 3,
                            ANDROID_TAB: 4 },
        EnumPasswordDlgType = {
            OLD_PASSWORD: 0,
            NEW_PASSWORD: 1,
            CONFIRM_NEW_PASSWORD: 2
        },
        
        
        postLoginFlag = {};

    
    function getProjectSettings(request) {
        var me = this,
            projectId = request.pid,
            realPid = request.params.projectID,
            requestId = request.id,
            sessionState = sessions[projectId],
            realPid = request.params.projectID,
            params = {
                taskId: 'getProjectSettings'
            };

        if ( sessionState ) {
            params.sessionState = sessionState;
        } else {
            
            params.projectID = realPid;
        }
        mstrApp.serverRequest(
            params,
            { 
                success: function (response) {
                    postLoginFlag[projectId] = true;
                    me.transport.serverRequest(me.id, requestId, request);
                },
                failure: function (response) {
                    var callback = request.callback;

                    if (callback.failure !== undefined) {
                        callback.failure(response);
                    }

                    callback.complete(requestId);
                }
            },
            { 
                
                
                skipLogin : true,
                
                doNotHold : true
            });
    }

    function setLocaleInfo(params) {
    	var locStr = String(mstrMobileApp.getLocaleInfo());

    	if(locStr) {
    		var locArr = locStr.split(',');

    		for(var i = 0; i < locArr.length; i++) {
    			var locInfo = locArr[i].split(':');
    			params[locInfo[0]] = locInfo[1];
    		}
    	}
    	return params;
    }

    function notifyUserNewPasswordRequired(params,cb) {
        var dialog,
            items = [],
            dialogConfig = {
                id: "new_pwd_reqd",
                title: $DESC(5088),
                cssClass: 'mstrmojo-CredentialsDialog',
                loginInfo: params.loginInfo
            },
            loginInfo = params.loginInfo,
            fnOK = function(p,callback) {
                return function() {
                    callback(p);
                };
            }(params,cb);

        
        items.push( {
            scriptClass: "mstrmojo.Label",
            cssClass: "mstrmojo-PasswordDialog-Label",
            text: "You must supply a new password."
        });

        dialogConfig.children = items;

        
        dialogConfig.buttons = [
            $BTN($DESC(221, 'Cancel'), function() {
                
                
                dialog.manualClose = true;
                mstrApp.cancelPending();
            }  ),
            $BTN($DESC(1442, 'OK'), fnOK, { enabled: true } )
        ];

        dialog = mstrApp.showDialog(dialogConfig);
    }

    function doPasswordDialog(params,cb) {
        var dialog,
        	btnOk,
            items = [],
            dialogConfig = {
                id: "password_prompt" + mstrmojo.now(),
                title: params.title,
                cssClass: 'mstrmojo-CredentialsDialog',
                loginInfo: params.loginInfo
            },
            loginInfo = params.loginInfo,
            fnOK = function(p,callback) {
                return function() {
                    var ch = dialog.children,
                        pe = ch[0].children[0];

                    switch( p.dlgType ) {
                        case EnumPasswordDlgType.OLD_PASSWORD:
                            loginInfo.pwd = pe.value;
                            break;
                        case EnumPasswordDlgType.NEW_PASSWORD:
                            loginInfo.npwd = pe.value;
                            break;
                    }
                    callback(p);
                };
            }(params,cb);

        btnOk = mstrmojo.getInstance( $BTN($DESC(1442, 'OK'), fnOK, { enabled: params.enableOK } ) );

            
        items.push({
            scriptClass: 'mstrmojo.Box',
            cssDisplay: 'table',
            children: [ {
            				scriptClass: "mstrmojo.TextBoxWithLabel",
            				label: $DESC(18) + ":",
            				value: "",
            				type: "password",
            				cssDisplay: 'table-row',
            				onvalueChange: function() {
            					if ( params.dlgType == EnumPasswordDlgType.CONFIRM_NEW_PASSWORD ) {
            						btnOk.set("enabled", this.value == loginInfo.npwd );
                               }
                           }
                       }
                   ]
        });

        dialogConfig.children = items;

        
        dialogConfig.buttons = [
            $BTN($DESC(221, 'Cancel'), function() {
                mstrApp.cancelPending();
            }  ),
            btnOk
        ];

        dialog = mstrApp.showDialog(dialogConfig);
    }


    

    function handleExpiredPassword(request) {

        var cfg = this._mobileCfg,
            projectId = request.pid,
            project = cfg.getProject(projectId),
		    params = {
                cfg: cfg,
                projectId: projectId,
                project: project,
                transport: this.transport,
                loginInfo: cfg.getLoginInfo(projectId)
             },
             me = this;

        
        mstrApp.hideMessage();

        
        
        params.loginInfo.uid = request.params.userid;

        
        notifyUserNewPasswordRequired( params, function(params) {

            
            doPasswordDialog( $H.copy({ title: "Enter your old password",
                                        dlgType: EnumPasswordDlgType.OLD_PASSWORD,
                                        enableOK: true }, params ), function(params) {

                
                doPasswordDialog( $H.copy({ title: "Enter your new password",
                                            dlgType: EnumPasswordDlgType.NEW_PASSWORD,
                                            enableOK: true }, params ), function(params) {

                    
                    doPasswordDialog( $H.copy( { title: "Confirm your new password",
                                                dlgType: EnumPasswordDlgType.CONFIRM_NEW_PASSWORD,
                                                enableOK: (params.loginInfo.npwd == "") }, params ), function(params) {

                        
                        var fnSuccess = function(p) {
                            return function(res) {
                                var liInfo = p.loginInfo,
                                	npwd = liInfo.npwd,
                                	nuid = liInfo.uid;

                                
                                if ( project.udc ) {
                                    var server = cfg.getServerByProjectId(projectId);
                                    server.pdc.ps = npwd;
                                    server.pdc.lo = nuid;
                                } else {
                                    project.pc.ps = npwd;
                                    project.pc.lo = nuid;
                                }
                                cfg.saveConfiguration();

                                
                                request.params.password = npwd;

                                login.call(me,request);
                            };
                        }(params),

                        
                        fnFailure = function(res) {
                            var callback = request.callback;

                            
                            if (callback.failure !== undefined) {
                                callback.failure(res);
                            }

                            
                            
                            callback.complete(request.id);
                        };

                        
                        me.request( {
                            success: fnSuccess,
                            failure: fnFailure
                        }, {
                            taskId: $chgPassword,
                            server: params.project.sn,
                            userid: params.loginInfo.uid,
                            oldPassword: params.loginInfo.pwd,
                            newPassword: params.loginInfo.npwd
                        },
                        false, {
                            projectId: projectId,
                            mobileConfig: cfg,
                            
                            doNotHold : true
                        });
                    });

                });

            });

        });
    }

    
    function promptForCredentials(loginInfo, isServer, callback) {

        var dialog,
            btnOk,
            getInstance = mstrmojo.getInstance,
            fnNewInput = function (descId, valueNode, type, props) {
                
                return getInstance($H.copy(props, {
                    scriptClass: 'mstrmojo.TextBoxWithLabel',
                    cssDisplay: 'table-row',
                    label: $DESC(descId) + ":",
                    value: loginInfo[valueNode],
                    type: type || 'text',
                    onEnter: function () {
                        
                        if (btnOk.enabled) {
                            
                            btnOk.onclick({
                                e: {
                                    stopPropagation: mstrmojo.emptyFn
                                }
                            });
                        }
                    }
                }));
            },
            userId = fnNewInput(17, 'uid', null, {
                onRender: function () {
                    
                    this.focus();
                },
                onvalueChange: function() {
                    
                    btnOk.set('enabled', !!this.value.length);
                }
            }),
            userPwd = fnNewInput(18, 'pwd', 'password');

        btnOk = getInstance($BTN($DESC(9935, 'Log In'), function () {
            
            var name = loginInfo.uid = userId.value;
            loginInfo.pwd = userPwd.value;

            
            if (name.length) {
                
                window.setTimeout(function() {
                    callback();
                }, 100);                             
            }
        }, {
            enabled: false
        }));

        
        dialog = mstrApp.showDialog({
            id: 'user_creds_prompt',
            title: (isServer ? $DESC(7904) : $DESC(11) ) + ' ' + $DESC(26),
            cssClass: 'mstrmojo-CredentialsDialog',
            loginInfo: loginInfo,
            children: [{
                scriptClass: 'mstrmojo.Box',
                cssDisplay: 'table',
                children: [ userId, userPwd ]
            }],
            buttons: [ $BTN($DESC(221, 'Cancel'), function() {
                
                
                dialog.manualClose = true;
                mstrApp.cancelPending();
            }), btnOk ]
        });
    }

    

    function needServerCreds( loginInfo ) {
    	return ( ( loginInfo.wsam > 1 ) && !loginInfo.wsuid );
    }

    function needProjectCreds( loginInfo ) {
    	return ( !loginInfo.uid && loginInfo.am != 2  );
    }

    function getCredentials( li, callback ) {
        var loginInfo = li,
            needUpdateCfg = false;

        
        var promptForServerCreds = function(cb) {
            var serverCreds = { uid: loginInfo.wsuid, pwd: loginInfo.wspwd },
                callback = function() {
                    loginInfo.wsuid = serverCreds.uid;
                    loginInfo.wspwd = serverCreds.pwd;

                    
                    loginInfo.updateCfgAfterLogin |= 0x01;

                    cb();
                };

            promptForCredentials.call(this, serverCreds, true, callback );
        };

        
        var promptForProjectCreds = function(cb) {
            var projCreds = { uid: loginInfo.uid, pwd: loginInfo.pwd },
                callback = function() {
                    loginInfo.uid = projCreds.uid;
                    loginInfo.pwd = projCreds.pwd;

                    
                    loginInfo.updateCfgAfterLogin |= 0x02;

                    cb();
                };
            promptForCredentials.call(this, projCreds, false, callback);
        };

        
        if ( needServerCreds(loginInfo) && needProjectCreds( loginInfo )  ) {
            
            var ths = this;
            promptForServerCreds.call(this, function() {
                promptForProjectCreds.call(ths,callback);
            } );

        
        } else if ( needServerCreds( loginInfo ) ) {

            promptForServerCreds.call(this,callback);

        
        } else if ( needProjectCreds( loginInfo ) ) {

            promptForProjectCreds.call(this, callback);

        } else {

            
            callback();
        }
    }

    
    function canUseCache(request) {
        var cfg = this._mobileCfg,
            pid = request.pid,
            project = cfg.getProject(pid),
            realPid = project.realPid,
            loginInfo = cfg.getLoginInfo(pid);

        
        if ( mstrApp.useBinaryFormat && realPid && loginInfo.uid) {
            request.params.projectID = realPid;
            return true;
        }
        return false;
    }

    
    function postLogin(request) {
        var me = this,
            cfg = me._mobileCfg,
            projectId = request.pid,
            realPid = request.params.projectID,
            transport = me.transport,
            id = me.id,
            callback = {
                success: function(res){
                    
                    var l = localeInfoMap[projectId] = mstrmojo.hash.obj2array(res);
                    mstrmojo.hash.copy(l, mstrmojo.locales);

                    if ( mstrApp.useBinaryFormat ) {
                        
                        getProjectSettings.call(me, request);
                    } else {
                        postLoginFlag[projectId] = true;
                        
                        transport.serverRequest(id, request.id, request);
                    }
                },
                failure: function(response){
                    var cb = request.callback;

                    if (cb.failure !== undefined) {
                        cb.failure(response);
                    }

                    cb.complete(request.id);
                }
            },
            params = {
                taskId: 'getLocaleInfo'
            },
            config = {
                projectId: projectId,
                mobileConfig: cfg,
                
                
                skipLogin : true,
                
                doNotHold : true
            };
        if ( realPid) {
            params.projectID = realPid;
        }

        
        me.request(callback, params, false, config);
    }
    
    function login(request) {
        var me = this,
            cfg = me._mobileCfg,
            projectId = request.pid,
            project = cfg.getProject(projectId),
            transport = me.transport,
            id = me.id,
            loginInfo = cfg.getLoginInfo(projectId),
            repromptForCreds = false,
            repromptTimer,
            doLogin = function( f ){
                project.posLoginFlag = false;
                var loginCallback = {
                        success: function(res) {

                        	
                        	clearInterval(repromptTimer);

                            
                            
                            
                            
                            

                        	
                        	
                        	project.es = res.hasEmailScreenPriv;

                            
                            if ( loginInfo.updateCfgAfterLogin ) {
                                cfg.updateLoginInfo(projectId,loginInfo);
                            }

                            
                            cfg.setRealPid(project, res.projectID);
                            
                            var sessionState = sessions[projectId] = res.sessionState;
                            mstrMobileApp.putSession(projectId, sessionState);

                            
                            request.params.sessionState = sessionState;

                            
                            if ( res.isCompatible === false ) {
                                mstrApp.handleCompatibilityError(request);
                            }

                            postLogin.call(me, request);

                        },
                        failure: function( res ) {
                            var callback = request.callback,
                            	canUseCacheFlag = canUseCache.call(me, request),
                            	isHttpAuthFail = (res.status==401),
                            	isAuthFail = ( res.code == $ERRS.AUTHEN_E_LOGIN_FAIL ) || (res.status==401),
                            	errorCallback = mstrmojo.emptyFn,
                            	li = cfg.getLoginInfo(projectId),
                            	needToReprompt = isHttpAuthFail ||  isAuthFail || ( needServerCreds(li) || needProjectCreds( li ) );

	                        
	                        if ((callback.failure !== undefined) && !isHttpAuthFail) {
	                            
	                            res.noErrorMessage = canUseCacheFlag || needToReprompt || res.requireDeviceCertificate;

	                            
	                            res.handledError = needToReprompt || res.requireDeviceCertificate;

	                            callback.failure(res);
	                        }


	                        
	                        
	                        

	                        if ( !needToReprompt ) {
		                        callback.complete(request.id);
	                        }

	                        
	                        
	                        
	                        if ( canUseCacheFlag && !mstrMobileApp.isOnline()) {
	                            postLogin.call(me, request);
	                        } else {
	                            res.method = "login";

	                            
	                            if ( needToReprompt ) {

                                    if ( isAuthFail ) {
                                        cfg.clearLoginInfoForProject(projectId);
                                    }

	                            	
		                            if ( isHttpAuthFail ) {
		                            	var	server = cfg.getServerByProjectId(projectId),
		                            		creds;

		                            	
		                            	if ( server.udc ) {
		                            		
		                                    creds = cfg.getDefaultServerCreds();
		                            	} else {
		                            		
		                            		creds = server.wsc;
		                            	}
		                            	
	                                    delete creds.lo;
	                                    delete creds.ps;

	                                    
	                                    
		                                cfg.saveConfiguration();

		                                
	                                    res.message = $DESC( 10672, "The username or password you entered is incorrect." );
		                            }

	                            	
	                            	res.handledError = false;

	                            	
	                            	errorCallback = function() {
			                            repromptForCreds = true;
		                            };
	                            }

	                            
	                            mstrApp.onerror(res, errorCallback );
	                        }
	                	}
                    },
                    devTypes = EnumDeviceType,
                    loginParams = setLocaleInfo({
                        taskId: $mobileLogin,
                        server: project.sn,
                        project: project.pn,
                        userid: loginInfo.uid,
                        password: loginInfo.pwd,
                        
                        wsSize: 10,
                        
                        authMode: loginInfo.am,

                        
                        wsuid: loginInfo.wsuid,
                        wspwd: loginInfo.wspwd,
                        wsam: loginInfo.wsam,

                        
                        clientVersion: mstrMobileApp.getAppVersion(),
                        clientType: mstrMobileApp.isTablet() ? devTypes.ANDROID_TAB : devTypes.ANDROID_PHONE

                    }),
                    loginConfig = {
                        projectId: projectId,
                        mobileConfig: cfg,
                        
                        doNotHold : true
                    };
                me.request(loginCallback, loginParams, false, loginConfig); 
            },
            foo = doLogin;

        getCredentials.call( this, loginInfo, doLogin );

        repromptTimer = setInterval( function () {

            if ( repromptForCreds ) {
            	
            	repromptForCreds = false;

            	
            	loginInfo = cfg.getLoginInfo(projectId);

            	
            	getCredentials.call( me, loginInfo, doLogin );
            }

        }, 500 );

    }

    
    mstrmojo.MobileServerProxy = mstrmojo.declare(
        mstrmojo.ServerProxy,

        null,

        
        {
            scriptClass: "mstrmojo.MobileServerProxy",

            getSessions: function() {
                return sessions;
            },

            
            request: function request(callback, params, override, config) {
                
                this._projectId = config.projectId;

                
                this._mobileCfg = config.mobileConfig;

                this._super(callback, params, override, config);
            },

            
            createRequest: function createRequest(requestId, callback, params, config) {
                var request;
                try {
                    
                    request = this._super(requestId, callback, params, config);

                    
                    var projectId = this._projectId;
                    request.pid = projectId;
                    if ( ! config.noTaskURL ) {
                    request.taskURL = this._mobileCfg.getTaskUrlByProject(projectId);
                    }
                    request.isLogin = (params.taskId === $mobileLogin);
                    request.isPwdChange = (params.taskId == $chgPassword);
                } catch(ex) {
                    
                    this.deleteRequest(requestId);
                    throw ex;
                }

                
                return request;
            },

            
            userInteractionRequired: function userInteractionRequired(request) {
                var result = false;

                
                if ( request.pid && !sessions[request.pid]) {

                    var loginInfo = request.config.mobileConfig.getLoginInfo(request.pid),
                        needServerCreds = ( ( loginInfo.wsam > 1 ) && !loginInfo.wsuid ),
                        needProjectCreds = ( !loginInfo.uid && loginInfo.am != 2  );

                    
                    return needServerCreds || needProjectCreds;
                }

                return result;
            },

            
            submitRequest: function submitRequest(request) {
                
                if (request.isLogin || request.isPwdChange  ) {
                    
                    this._super(request);

                    
                    return;
                }

                
                var state = sessions[request.pid],
                    localeInfo = localeInfoMap[request.pid];

                
                if (state) {
                    
                    request.params.sessionState = state;

                    if (localeInfo){
                        mstrmojo.hash.copy(localeInfo, mstrmojo.locales);
                    }

                      
                    this._super(request);

                } else {
                    if ( request.config.skipLogin ) {
                        this._super(request);
                        return;
                    }
                    if ( mstrMobileApp.isOnline() ) {
                        
                        
                        login.call(this, request);
                    } else {
                        
                        
                        if ( canUseCache.call(this, request)) {
                            
                            
                            if ( ! postLoginFlag[request.pid] ) {
                                postLogin.call(this, request);
                            } else {
                                this._super(request);
                            }
                        } else {
                            
                            login.call(this, request);
                        }
                    }
                }
            },

            
            response: function response(requestId, status, res) {
                var request = this.getRequest(requestId);

                
                if (!request) {
                    
                    return;
                }

                
                if (!status && mstrMobileApp.isOnline()) {
                    switch (parseInt(res.code,10)) {
                        case $ERRS.AUTHEN_E_LOGIN_FAIL_EXPIRED_PWD:
                        case $ERRS.AUTHEN_E_LOGIN_FAILED_NEW_PASSWORD_REQD:
                            handleExpiredPassword.call(this,request);
                            return;
                            break;

                        case $ERRS.MSI_INBOX_MSG_NOT_FOUND:
                            
                            break;

                        case $ERRS.E_MSI_USERMGR_USER_NOTFOUND:
                            if (!request.isLogin) {
                                
                                delete request.params.sessionState;

                                
                                login.call(this, request);

                                
                                return;
                            }
                            break;
                    }
                }

                
                this._super(requestId, status, res);
            },

            getSession: function getSession(projectId) {
                return sessions[projectId];
            },

            closeSession: function closeSession(projectId) {
                
            },

            closeAllSessions: function closeAllSessions() {
                
                sessions = {};
            },

            getLocaleInfo: function getLocaleInfo(projectId) {
                return localeInfoMap[projectId];
            },

            hasEmailScreenPrivilege : function hasEmailScreenPrivilege(projectId) {
            	return false;
            }
        });

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.TextInput",
                         "mstrmojo.ValidationTextBox",
                         "mstrmojo.hash");

    
    mstrmojo.android.ui.ValidationTextInput = mstrmojo.declare(

        mstrmojo.android.ui.TextInput,

        null,

        
        {
            scriptClass: "mstrmojo.android.ui.ValidationTextInput",

            
            valProps: null,

            
            getTextCfg: function getTextCfg() {
                return mstrmojo.hash.copy(this.valProps, {
                    scriptClass: 'mstrmojo.ValidationTextBox',
                    onEnter: function () {
                        
                        var parent = this.parent,
                            fnEnter = parent.onEnter;

                        
                        if (fnEnter) {
                            
                            if (this.isValid()) {
                                
                                fnEnter.call(parent, this.value);
                            }
                        }
                    },
                    onvalidationStatusChange: function () {
                        
                        var status = this.validationStatus,
                            code = status && status.code,
                            errorLabel = this.parent.lblErr,
                            msg = code ? status.msg : '';

                        
                        errorLabel.set('text', msg);
                        errorLabel.set('visible', !!msg);
                    }
                });
            },

            
            validate: function validate() {
                return this.txt.validate();
            },

            
            isValid: function isValid() {
                return this.txt.isValid();
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo.android.ui.Label",
                         "mstrmojo.android.ui.Menu",
                         "mstrmojo.android.ui.SearchBox",
                         "mstrmojo.android.ui.Image",
                         "mstrmojo.mstr.WebElements",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    mstrmojo.requiresDescs(10, 9462, 9463);

    var $DOM = mstrmojo.dom,
        $CSS = mstrmojo.css,
        $TRANSITION_END = $DOM.CSS3_TRANSITION_END;

    var menuItems = [{
        n: mstrmojo.desc(9462, 'View All'),
        idx: 1,
        v: true
    }, {
        n: mstrmojo.desc(9463, 'View Selected'),
        idx: 0,
        v: false
    }];

    
    function canSearchClose() {
        
        if (this.searchRequired) {
            
            if (!this.target.getSelectedItems().length) {
                
                return false;
            }

            
            
        }

        return true;
    }

    
    function toggleSearch() {
        var switchLbl = this.lbl,
            switchLblNode = switchLbl.domNode,
            switchLblNodeStyle = switchLblNode.style,
            searchNodeStyle = this.searchNode.style,
            txt = this.search.box,
            txtNode = txt.inputNode,
            txtNodeStyle = txtNode.style,
            target = this.target,
            viz = 'visible';

        
        var isSearch = this._isSearch = !!switchLbl.visible;

        
        if (isSearch) {
            
            target.enterSearchMode();

            
            var textStyle = $CSS.getComputedStyle(txt.inputNode),
                width = this.domNode.offsetWidth - (2 * parseInt(textStyle.marginRight, 10)) - parseInt(textStyle.paddingLeft, 10) - parseInt(textStyle.paddingRight, 10) - this.search.slot0.offsetWidth,
                browseElements = this.browseElements;

            
            $DOM.attachOneTimeEvent(switchLblNode, $TRANSITION_END, function () {
                
                switchLbl.set(viz, false);

                
                searchNodeStyle.width = '100%';

                
                txt.set('hint', (browseElements && browseElements.source.n) || mstrmojo.desc(10, 'Search'));

                
                txt.set(viz, true);

                window.setTimeout(function () {
                    
                    txtNodeStyle.width = width + 'px';
                }, 0);
            });

            
            switchLblNodeStyle.opacity = 0;

        } else {
            
            if (!canSearchClose.call(this)) {
                return;
            }

            
            target.exitSearchMode(!this.searchRequired);

            
            $DOM.attachOneTimeEvent(txtNode, $TRANSITION_END, function () {
                
                txt.set(viz, false);

                
                txt.set('value', '');

                
                searchNodeStyle.width = '';

                
                switchLbl.set(viz, true);

                
                window.setTimeout(function () {
                    switchLblNodeStyle.opacity = 1;
                }, 0);
            });

            
            txt.inputNode.style.width = 0;
        }
    }


    
    mstrmojo.android.ui.ElementsSearchBar = mstrmojo.declare(
        mstrmojo.Container,

        null,

        
        {
            scriptClass: 'mstrmojo.android.ui.ElementsSearchBar',

            markupString: '<div id="{@id}" class="mstrmojo-ElementSearchBar {@cssClass}" style="{@cssText}" >' +
                              '<div>' +
                                  '<div class="mstrmojo-ElementSearchBar-switch"></div>' +
                                  '<div class="mstrmojo-ElementSearchBar-search"></div>' +
                              '</div>' +
                          '</div>',

            markupSlots: {
                switchNode: function () { return this.domNode.firstChild.firstChild; },
                searchNode: function () { return this.domNode.firstChild.lastChild; }
            },

            markupMethods: {
                oncanSearchChange: function () { this.search.btn.set('visible', !!this.canSearch); }
            },

            
            target: null,

            
            browseElements: null,

            
            searchRequired: false,

            children: [{
                scriptClass: 'mstrmojo.android.ui.Menu',
                slot: 'switchNode',
                alias: 'menu',
                visible: false,
                items: [ menuItems[1] ],
                postselectionChange: function (evt) {
                    var added = evt.added,
                        item = added && this.items[added[0]];

                    
                    if (item) {
                        
                        var parent = this.parent;
                        parent.lbl.set('text', item.n);

                        
                        this.set('visible', false);
                        this.set('items', [ menuItems[item.idx] ]);

                        
                        parent.target.set('viewAll', item.v);
                    }
                }
            }, {
                scriptClass: 'mstrmojo.HBox',
                alias: 'search',
                slot: 'searchNode',
                children: [{
                    scriptClass: 'mstrmojo.android.ui.Image',
                    alias: 'btn',
                    touchTap: function () {
                        
                        toggleSearch.call(this.parent.parent);
                    }
                }, {
                    scriptClass: 'mstrmojo.android.ui.SearchBox',
                    alias: 'box',
                    hint: mstrmojo.desc(10, 'Search'),
                    cssDisplay: 'block',
                    cssText: 'width:0;',
                    visible: false,

                    searchFunc: function (searchPattern) {
                        
                        if (searchPattern) {
                            
                            var searchBar = this.parent.parent,
                                elements = searchBar.browseElements,
                                searchElements = (elements && elements.duplicate()) || new mstrmojo.mstr.WebElements(),
                                cfg = searchElements.browseConfig || {},
                                id = this.id;

                            
                            cfg.searchPattern = searchPattern;
                            cfg.blockBegin = 1;
                            cfg.searchForms = this.searchForms;
                        	
                            if (searchBar.searchTarget) {
                            	cfg.searchTarget = searchBar.searchTarget;
                            	delete searchBar.searchTarget;
                            }

                            
                            searchElements.browseConfig = cfg;

                            
                            searchElements.getItems(0, {
                                success: function () {
                                    
                                    mstrmojo.all[id].set('searchResult', searchElements);
                                }
                            });

                        } else {
                            
                            this.clearSearch();

                        }
                    },

                    clearFunc: function () {
                        
                        this.parent.parent.target.clearSearch();
                    },

                    onsearchResultChange: function () {
                        
                        this.parent.parent.target.search(this.searchResult);
                    }
                }]
            }],
            
            
            init: function init(props) {
                this._super(props);
                var lbl = {
                        scriptClass: 'mstrmojo.android.ui.Label',
                        slot: 'switchNode',
                        alias: 'lbl'
                    };
                if ( props.searchRequired) {
                    lbl.text = props.title;
                    lbl.cssClass = 'mstrmojo-no-Image';
                } else {
                    lbl.text = mstrmojo.desc(9462, 'View All');
                    lbl.touchTap = function () {
                        var menu = this.parent.menu,
                            show = !menu.visible;

                        
                        if (show) {
                            
                            menu.set('width', this.domNode.offsetWidth + 'px');
                        }

                        
                        menu.set('visible', show);
                    };
                }
                this.addChildren(lbl);
            },
            
            onRender: function onRender() {
                var initialSearch = this.initSearchValue,
                    id = this.id;

                
                if (initialSearch || this.searchRequired) {
                    
                    delete this.initSearchValue;

                    
                    window.setTimeout(function () {
                        
                        var bar = mstrmojo.all[id];
                        
                        toggleSearch.call(bar);

                        
                        var box = bar.search.box;
                        box.set('value', initialSearch || '');

                        
                        if (initialSearch) {
                            
                            box.onEnter();
                        }
                    }, 0);
                }

                return this._super();
            },

            goBack: function goBack() {
                
                if (this._isSearch) {
                    
                    if (canSearchClose.call(this)) {
                        
                        toggleSearch.call(this);

                        
                        return true;
                    }
                }

                
                return false;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.TextArea",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $DOM = mstrmojo.dom,
        $C = mstrmojo.css,
        BASEFORM_URL = 5,
        BASEFORM_EMAIL = 6,
        INTEGER = 1,
        FLOAT = 7, 
        BIGDECIMAL = 30; 

    function reApplyWebkitTransform(dom) {
        if (dom.style) {
            var trans = mstrmojo.css.getStyleValue(dom, $DOM.CSS3_TRANSFORM);
            if (trans !== 'none') {
                dom.style[$DOM.CSS3_TRANSFORM] =  trans;
            }
        }
    }

    function convert3dTransform(dom) {
        var i,
            len = dom.childNodes.length;
        for (i = 0; i < len; i++) {
            var c = dom.childNodes[i];
            convert3dTransform(c);
            reApplyWebkitTransform(c);
        }
    }

    mstrmojo.android.inputControls.TextAreaDIC = mstrmojo.declare(

        mstrmojo.TextArea,

        [mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton],

        {
            scriptClass: "mstrmojo.android.inputControls.TextAreaDIC",

            cssDisplay: 'block',

            init: function init(props) {
                this._super(props);

                this.maxLength = this.dic.ml;

                if (!this.showByDefault) {
                    this.cssClass = 'mstrmojo-TextAreaDIC-Popup';
                    this.rows = 7;
                }
            },

            focus: function focus() {
                $DOM.setCaret(this.domNode, (this.value != null && String(this.value).length) || 0);
            },

            onfocus: function onfocus() {
                
                window.setTimeout(function () {
                    mstrMobileApp.forceRepaint();
                }, 0);
            },

            onvalueChange: function onvalueChange() {
                if (!this.showByDefault) {
                    this._super();
                }
            },

            onblur: function onblur() {
                if (this.showByDefault) {
                    this.applyChanges();
                }
            },

            applyChanges: function applyChanges() {
                
                
                
                this.domNode.blur();
                var dt = parseInt(this.dic.dt, 10);
                if ((dt >= INTEGER && dt <= FLOAT) || dt === BIGDECIMAL) {
                    this.value = parseFloat(this.value);
                }
                this._super();
            },

            cancelChanges: function cancelChanges() {
                this.domNode.blur();
                this._super();
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                if (this.showByDefault) {
                    
                    
                    this.domNode.style.width = '100%';
                    this.domNode.style.height = '100%';

                    
                    
                    
                    
                    
                    
                    if (!mstrApp.isTablet()) {
                        
                        
                        
                        $DOM.attachEvent(this.domNode, 'click', function () {
                            convert3dTransform(document.body);
                        }, false);
                    }

                    
                    
                    
                    
                    
                    var me = this;
                    $DOM.attachEvent(this.domNode, 'blur', function () {
                        var d = me.domNode;
                        while (d != null) {
                            if (d.scrollTop > 0) {
                                d.scrollTop = 0;
                                break;
                            }
                            d = d.parentNode;
                        }
                    }, false);
                }
            },

            renderPreview: function renderPreview() {
                var dic = this.dic,
                    v = this.value,
                    dv = (this.dv == null) ? '' : String(this.dv),
                    prefix = '',
                    reg4URL = /(.*href=['"])(.*)(['"].*>)(.*)(<.*)/i;

                if (!dv || !dic.sp) { 
                    this.dv = dic.siwc ? '&nbsp;' : (dv || '&nbsp;');
                } else {
                    
                    v = (v.length > dic.pl) ? (v.substring(0, dic.pl) + '&hellip;') : v;

                    
                    switch (this.ts) {
                    case BASEFORM_EMAIL:
                        prefix = 'mailto:';
                        
                    case BASEFORM_URL:
                        if (!dv) {
                            dv = '<a href="mailto:"></a>';
                        }
                        dv = dv.replace(reg4URL, '$1' + prefix + this.value.replace(/\$/g, '$$$$') + '$3' + v.replace(/\$/g, '$$$$') + '$5');
                        break;
                   default:
                        dv = (dv.length > dic.pl) ? (dv.substring(0, dic.pl) + '&hellip;') : dv;
                    }
                    this.dv = dv;
                }

                this.renderPreviewButton(this.openerNode, this.dv);

                $C.toggleClass(this.openerNode.firstChild, 'filled', !this.dicChanged && this.value != null && String(this.value).length > 0);

            }
        }
    );
}());
(function() {
    mstrmojo.requiresCls("mstrmojo.ValidationTextBox", "mstrmojo._IsInputControl", "mstrmojo.dom", "mstrmojo.num");
    
    var _VAL = mstrmojo.validation,
        SC = _VAL.STATUSCODE,
        _VALIDATOR = _VAL.VALIDATOR,
        _DTP = mstrmojo.expr.DTP,
        NO_VALIDATION = 0,
        PHONE_NO = 1,
        EMAIL_ADDRESS = 2,
        ZIP_CODE = 3,
        SOCIAL_SECURITY_NO = 4,
        REG_EXP = 5;
    
    
    mstrmojo.TextFieldDIC = mstrmojo.declare(
            
        mstrmojo.ValidationTextBox,
        
        [mstrmojo._IsInputControl],
        
        {
            scriptClass: 'mstrmojo.TextFieldDIC',
            
            cssClass: 'mstrmojo-TextFieldDIC',
            
            dtp: _DTP.VARCHAR,
            
            validationDelay: 0, 
            
            getInputNode: function(){
                return this.inputNode;
            },
            
            focus: function() {
                this.validate();
                mstrmojo.dom.setCaret(this.domNode, (this.value && this.value.length || 0));
            },
            
            init: function(props) {
                if (this._super){
                    this._super(props);
                }
                
                this.constraints = mstrmojo.hash.copy()
                
                var di = props.dic, 
                    c = this.constraints = {trigger: mstrmojo.validation.TRIGGER.ONKEYUP}, 
                    dt = di.dt;
                
                if(di.ml) {
                    this.maxLength = di.ml;
                }
                
                
                if(di.psw) {
                    this.type = 'password';
                    
                    this.value = this.lv = '';
                    this.owner.applyPasswordMask && this.owner.applyPasswordMask();
                }
                
                
                if (_VAL.isNumeric(dt) || _VAL.isInt(dt) || _VAL.isString(dt)){
                    this.dtp = dt;
                }
                
                switch (di.vm){
                case PHONE_NO: 
                        c.validator = _VALIDATOR.VALIDATE_PHONENO;
                        break;
                case EMAIL_ADDRESS: 
                        c.validator = _VALIDATOR.VALIDATE_EMAIL;
                        break;
                case ZIP_CODE:
                        c.validator = _VALIDATOR.VALIDATE_ZIPCODE;
                        break;
                case SOCIAL_SECURITY_NO: 
                        c.validator = _VALIDATOR.VALIDATE_SSN;
                        break;
                case REG_EXP: 
                        c.regExp = new RegExp('^'+di.rgx+'$');
                        break;
                }
                
                c.min = di.emin ? di.min : null;
                c.max = di.emax ? di.max : null;
                
                c.maxLen = (di.ml !== undefined) ? di.ml : null;
                c.minLen = (di.mnl !== undefined) ? di.mnl : null;
                
                if (di.req || di.emin){
                    this.required = true;
                }
            },
            
            
            onInvalid: function(){
                if(this.popup) {
                    this.popup.set('hasInvalidData', true);
                }
            },
            
            onValid: function(){
                if(this.popup) {
                    this.popup.set('hasInvalidData', false);
                }
            },
            
            
            applyChanges: function(){
                this.validate();
                
                if(this.isValid()){
                    this._super();
                }else{
                    this.handleInvalid();
                    return false;
                }
                
                return true;
            },
            
            handleInvalid: function(){
                if (mstrmojo.all.mojoConfirmx9){
                    
                    return;
                }
                
                var me = this;
                mstrmojo.confirm(this.validationStatus.msg + '<br>(' + mstrmojo.desc(9199) + ')',  
                                
                                [{
                                    scriptClass: 'mstrmojo.Button',
                                    text: mstrmojo.desc(1442), 
                                    onclick: function(){
                                        me.focus();
                                    }
                                },{
                                    scriptClass: 'mstrmojo.Button',
                                    text: mstrmojo.desc(221), 
                                    onclick: function(){
                                        me.popup.onCancel();
                                    }
                                }], mstrmojo.desc(7548)); 
            },
            
            cancelChanges: function(){
                this.inputNode.blur();
                this.value = this.lv;
                this.clearValidation();
            }
        });
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.ViewSlider",
                         "mstrmojo._HasBuilder",
                         "mstrmojo._IsRwDocument",
                         "mstrmojo.android.ui.LayoutSelector",
                         "mstrmojo.Label",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.func",
                         "mstrmojo.android.EnumOrientationTypes");

    mstrmojo.requiresDescs(4174);

    var $ARR = mstrmojo.array,
        $AFE = $ARR.forEach,
        $HASH = mstrmojo.hash,
        EnumOrientationTypes = mstrmojo.android.EnumOrientationTypes,
        OR_PORTRAIT = EnumOrientationTypes.PORTRAIT,
        OR_LANDSCAPE = EnumOrientationTypes.LANDSCAPE;

    
    function isInfoWindowLayout(l) {
        return (l.defn.iw !== undefined && l.defn.iw);
    }

    
    function getLoadingPlaceholder(view) {
        return new mstrmojo.Label({
            cssClass: 'pre-loader',
            n: view.n,
            k: view.k,
            isPreloader: true
        });
    }

    
    function updateLayoutSelector(currentLayout, noItems) {
        
        var layoutSelector = this.layoutSelector,
            supportedLayouts = this.getSupportedLayouts();

        
        if (!noItems) {
            
            layoutSelector.set('items', supportedLayouts);
        }

        
        layoutSelector.setCurrentTab($ARR.find(supportedLayouts, 'k', currentLayout.k));

        
        layoutSelector.set('visible', !!noItems);

        
        if (noItems) {
            
            layoutSelector.initiateFade();
        }
    }

    
    function findNextLayout(index, direction) {
        var allLayouts = this._layouts,
            orientation = mstrMobileApp.getOrientation(),
            wrapIdx = allLayouts.length - 1 - index,        
            hasWrapped = false,
            layout;

        
        var layouts = allLayouts.slice(index + 1);

        
        if (index) {
            
            layouts = layouts.concat(allLayouts.slice(0, index));
        }

        
        if (!direction) {
            
            layouts.reverse();

            
            wrapIdx = index;
        }

        
        $AFE(layouts, function (l, idx) {

            
            
            hasWrapped = (idx >= wrapIdx);

            
            if (((l.defn.or & orientation) > 0) && !isInfoWindowLayout(l)) {
                
                layout = l;

                
                return false;
            }
        });

        
        if (!layout) {
            
            return null;
        }

        
        return {
            wrap: hasWrapped,
            layout: layout
        };
    }


    function hasDifferentViewsOrientation() {
        
        
        var views = this.model.defn.views,
            len = (views && views.length) || 0,
            i;

        if (len) {
            var orientation = views[0].orientation;
            for (i = 1; i < len; i++) {
                if (orientation !== views[i].orientation) {
                    
                    return true;
                }
            }
        }

        return false;
    }

    
    function checkLayoutOrientation(key) {
        
        var layouts = this._layouts,
            orientationInfo = this._orientationInfo;

        
        if (!orientationInfo) {
            
            orientationInfo = this._orientationInfo = {};
            var portraitInfo = orientationInfo[OR_PORTRAIT] = {
                lyts: []
            };
            var landscapeInfo = orientationInfo[OR_LANDSCAPE] = {
                lyts: []
            };

            
            $ARR.forEach(layouts, function (layout) {
                
                var or = layout.defn.or,
                    info = orientationInfo[or];

                
                if (!isInfoWindowLayout(layout) && info !== undefined) {
                    
                    info.lyts.push(layout.k);
                }
            });

            
            if (portraitInfo.lyts.length || landscapeInfo.lyts.length) {
                
                orientationInfo.specific = true;
            }
        }

        var selectedLayout = layouts[$ARR.find(layouts, 'k', key)], 
            selectedOrientation = selectedLayout.defn.or,           
            selectedOrInfo = orientationInfo[selectedOrientation],  
            deviceOrientation = mstrMobileApp.getOrientation(),     
            rtn = {
                isSupported: true,                                  
                currentLayout: selectedLayout,
                specific: !!orientationInfo.specific
            };

        
        if (isInfoWindowLayout(selectedLayout) || ((selectedOrientation & deviceOrientation) === 0)) {
            
            rtn.isSupported = false;

            
            var deviceOrInfo = orientationInfo[deviceOrientation];

            
            if (selectedOrInfo === undefined || deviceOrInfo === undefined) {
                return rtn;
            }

            
            var targetLayoutKey = deviceOrInfo.lyts[$ARR.indexOf(selectedOrInfo.lyts, key)];
            if (targetLayoutKey) {
                
                rtn.newLayout = layouts[$ARR.find(layouts, 'k', targetLayoutKey)];

            } else {
                
                var lastLayout = deviceOrInfo.last;
                if (lastLayout) {
                    
                    rtn.newLayout = lastLayout;

                } else {
                    
                    $ARR.forEach(layouts, function (layout) {
                        
                        if (!isInfoWindowLayout(layout) && (layout.defn.or & deviceOrientation) > 0) {
                            
                            rtn.newLayout = layout;

                            
                            return false;
                        }
                    });
                }
            }

            
            selectedOrInfo.last = selectedLayout;

            
            if (!rtn.newLayout) {
                
                rtn.isStale = true;
            }
        } else {
            
            
            rtn.needNewLayout = hasDifferentViewsOrientation.call(this);
        }

        return rtn;
    }

    
    function getScrollLayoutInfo(touch) {
        
        var nextLayoutInfo = findNextLayout.call(this, $ARR.find(this._layouts, 'k', this.model.getCurrentLayoutKey()), (touch.delta.x < 0));

        
        return (nextLayoutInfo && !nextLayoutInfo.wrap) ? nextLayoutInfo : null;
    }

    
    function getImageWatermark() {
        var model = this.model,
            watermark = model && model.wm;

        
        if (watermark && watermark.tp === 3 && watermark.imgSrc) {
            return watermark;
        }

        
        return null;
    }

    
    function insertWatermark(wm) {
        
        var img = document.createElement('img'),
            style = img.style;

        
        this.watermarkNode = img;

        
        style.position = "absolute";
        style.top = 0;
        style.left = 0;
        
        style.visibility = 'hidden';

        
        var me = this;
        img.onload = function () {
            var iw = img.width,
                ih = img.height;
            
            if (wm.imgScale <= 0) { 
                var dn = me.domNode;

                if(dn) { 
                    img.width = dn.clientWidth;
                    img.height = dn.clientHeight;
                }

            } else { 
                var r = wm.imgScale / 100;
                
                img.width = iw * r;
                img.height = ih * r;

            }

            
            img.style.visibility = 'visible';
        };

        
        this.domNode.insertBefore(img, this.domNode.firstChild);
        var ds = this.model.getDataService();
        
        var imgSrcUrl = wm && wm.imgSrc;
        img.src = (imgSrcUrl && ds && ds.getDocImage && ds.getDocImage(imgSrcUrl)) || imgSrcUrl;
    }
    
    mstrmojo.android.ui.DocumentView = mstrmojo.declare(
        mstrmojo.android.ui.ViewSlider,

        [ mstrmojo._HasBuilder, mstrmojo._IsRwDocument ],

        
        {
            scriptClass: "mstrmojo.android.ui.DocumentView",

            postBuildRendering: function postBuildRendering() {
                var rtn = this._super(),
                    watermark = getImageWatermark.call(this);

                
                if (watermark) {
                    
                    insertWatermark.call(this, watermark);
                }

                return rtn;
            },

            buildChildren: function buildChildren(noAddChildren) {
                
                
                this._layouts = this._super(true);
            },

            beforeViewHidden: function beforeViewHidden(isBack) {
                
                this._stale = true;
                var lyt = this.getCurrentLayout();
                if (lyt && lyt.beforeViewHidden) {
                    lyt.beforeViewHidden(isBack);
                }
            },

            getViewController: function getViewController(view) {
                
                return null;
            },

            unrender: function unrender(ignoreDom) {
                
                delete this._stale;

                this._super(ignoreDom);
            },

            reloadLayout: function reloadLayout() {

            	var view = this.getCurrentView(),
            		id = this.id,
                    params = {
                        layoutKey: view.k,
                        reload: true,
                        executionOrientation: mstrMobileApp.getOrientation()
                    };

                this.getNewLayout(params, this._layouts, true, {
                    success: function (newLayout) {
	                    
            			var doc = mstrmojo.all[id];
            			doc.replaceView(newLayout, view,true);
	                    doc.resetSliderNodes();
	                }
                });
            },

            rootOrientationChange: function rootOrientationChange() {
                
                if (this._stale) {
                    
                    return;
                }

                
                var watermark = getImageWatermark.call(this);
                if (watermark && watermark.imgScale <= 0) {
                    
                    var watermarkNode = this.watermarkNode;
                    watermarkNode.width = parseInt(this.width, 10);
                    watermarkNode.height = parseInt(this.height, 10);
                }

                
                var view = this.getCurrentView();
                if (view.isPreloader) {
                    
                    return;
                }

                
                var layoutsCollection = this._layouts,
                    viewKey = view.k,
                    layoutInfo = checkLayoutOrientation.call(this, viewKey),
                    layout = layoutInfo.newLayout;

                
                if (layoutInfo.isStale) {
                    
                    return;
                }

                
                if (layoutInfo.specific) {
                    
                    updateLayoutSelector.call(this, view);
                }

                var needNewDocumentView = !!layoutInfo.needNewLayout,                                               
                    needNewOrientationLayout = !needNewDocumentView && (!layoutInfo.isSupported && layout),         
                    needNewFitLayout = !needNewOrientationLayout && (this.model.zt && !view.isFullScreenWidget);    

                
                if (needNewDocumentView || needNewOrientationLayout || needNewFitLayout) {
                    
                    mstrApp.closeAllDialogs();

                    var id = this.id,
                    	me = this,
                    	params = {
                            layoutKey: viewKey,
                            reload: true,
                            executionOrientation: mstrMobileApp.getOrientation()
                        },
                        fnSuccess = function (newLayout) {
                            
                            mstrmojo.all[id].replaceView(newLayout, me.getCurrentView());  
                            
                            me.resetSliderNodes();
                        };

                    
                    if (needNewOrientationLayout) {
                    
                        view = this.replaceView(getLoadingPlaceholder(layout), view, true);

                        
                        params.layoutKey = layout.k;

                        
                        delete params.reload;

                        
                        fnSuccess = mstrmojo.func.composite([ function (newLayout) {
                            
                            updateLayoutSelector.call(mstrmojo.all[id], newLayout);
                        }, fnSuccess ]);
                    }

                    
                    this.getNewLayout(params, layoutsCollection, true, {
                        success: fnSuccess
                    });
                }

                
                this.controller.generateActionToolbar();
            },

            onRender: function onRender() {
                
                if (!this.layoutSelector) {
                    
                    this.addChildren([{
                        scriptClass: 'mstrmojo.android.ui.LayoutSelector',
                        slot: 'overlayNode',
                        alias: 'layoutSelector',
                        visible: false,
                        tabSelected: function (item) {
                            this.parent.showLayout(item);
                        }
                    }]);
                }

                
                var lyt = this.getCurrentLayout();

                
                var layoutInfo = checkLayoutOrientation.call(this, this.model.getCurrentLayoutKey()),
                    currentLayout = layoutInfo.currentLayout,
                    me = this,
                    fnShow = function (lyt) {
                        
                        if (lyt && !lyt.domNode) {
                            
                            me.switchView(lyt);
                        } else {
                            
                            me.stackViews(lyt.slot);
                        }

                        return lyt;
                    };

                if (layoutInfo.needNewLayout && this.controller.isBack) {

                    fnShow(currentLayout);
                    var params = {
                        layoutKey: currentLayout.k,
                        reload: true,
                        executionOrientation: mstrMobileApp.getOrientation()
                    };

                    this.getNewLayout(params, this._layouts, true, {
                        success: function (newLayout) {
                            me.replaceView(newLayout, currentLayout);
                        }
                    });

                } else if (layoutInfo.isSupported) {  
                    
                    fnShow(currentLayout);

                    
                    updateLayoutSelector.call(this, currentLayout);

                } else {
                    
                    var layout = layoutInfo.newLayout;
                    if (layout) {
                        
                        currentLayout.defn.loaded = false;

                        
                        layout = fnShow(this.selectLayout(getLoadingPlaceholder(layout), false));

                        
                        this.getNewLayout({ layoutKey: layout.k }, this._layouts, true, {
                            success: function (newLayout) {
                                
                                updateLayoutSelector.call(me, newLayout);

                                
                                me.replaceView(newLayout, layout);

                            }
                        });

                    } else {
                        
                        this._ignoreOrientation = true;

                        
                        fnShow(currentLayout);
                    }
                }

            },

            
            showLayout: function showLayout(layout) {
                
                var key = layout.k,
                    doc = this;

                if (key !== this.model.getCurrentLayoutKey()) {
                    var params = {
                        layoutKey: key
                    };

                    if (hasDifferentViewsOrientation.call(this)) {
                        params.executionOrientation = mstrMobileApp.getOrientation();
                        params.reload = true;
                    }

                    
                    this.getNewLayout(params, this._layouts, true, {
                        success: function (newLayout) {
                            
                            doc.switchView(newLayout);
                        }
                    });

                    
                    return true;
                }

                
                return false;
            },

            afterSwitch: function afterSwitch(layout) {
                this._super(layout);

                
                this.selectLayout(layout, (layout.k !== this.model.getCurrentLayoutKey()));
            },

            
            selectLayout: function selectLayout(layout, updateServer, callback) {
                var _layout = this._super(layout, updateServer, callback);

                
                this.controller.getPageByTree(true);

                
                if (!layout.defn || !layout.defn.iw) {
                    
                    updateLayoutSelector.call(this, _layout, true);
                }

                return _layout;
            },

            replaceLayout: function replaceLayout(oldLayout, newLayoutNode) {
                
                var layouts = this._layouts || [],
                    idx = $ARR.find(layouts, 'k', oldLayout.k);

                
                if (idx >= 0) {
                    oldLayout.unrender();
                    oldLayout.destroy();
                }

                
                var c = this.builder.build([ newLayoutNode ], this.model)[0];

                
                
                if (idx >= 0) {
                    layouts[idx] = c;
                } else {
                    layouts.push(c);
                }

                
                this._layouts = layouts;

                
                return c;
            },

            onLayoutRebuilt: function onLayoutRebuilt(layout) {
                
                this.replaceView(layout, this.getCurrentView());
            },

            
            canScroll: function canScroll(touch) {
                return !!getScrollLayoutInfo.call(this, touch);
            },

            
            beginScroll: function beginScroll(touch, view) {
                
                if (this.isAnimating()) {
                    
                    return false;
                }

                
                delete this._scrollInfo;

                
                if (!view) {
                    
                    var layouts = this._layouts,
                        nextLayoutInfo = getScrollLayoutInfo.call(this, touch),
                        id = this.id;

                    
                    if (!nextLayoutInfo) {
                        
                        return;
                    }

                    
                    view = nextLayoutInfo.layout;

                    var orientation = mstrMobileApp.getOrientation(),
                    	docLayout = view.docLayout,
                    	
                    	
                        needNewLayout = hasDifferentViewsOrientation.call(this) || (this.model.zt && docLayout && orientation !== docLayout.defn.lastOrientation);

                    
                    if (!view.defn.loaded || needNewLayout) {
                        
                        view = getLoadingPlaceholder(view);
                        var params = {
                            layoutKey: view.k
                        };

                        if (needNewLayout) {
                            params.executionOrientation = orientation;
                            params.reload = true;
                        }

                        
                        this.getNewLayout(params, layouts, false, {
                            success: function (newLayout) {

                                
                                var me = mstrmojo.all[id],
                                    scrollInfo = me._scrollInfo;

                                if (scrollInfo) {
                                    
                                    scrollInfo.view = newLayout;
                                }

                                
                                me.replaceView(newLayout, view);
                            }
                        });
                    }
                }

                
                if (view) {
                    
                    this._super(touch, view);
                }
            },

            scrollStarted: function scrollStarted() {
                var layoutSelector = this.layoutSelector;

                
                layoutSelector.set('visible', true);

                
                layoutSelector.enterScroll();
            },

            scrollProgress: function scrollProgress(info, delta) {
                
                this.layoutSelector.scroll(delta);
            },

            scrollStopped: function scrollStopped(info, isComplete) {
                
                var layoutSelector = this.layoutSelector,
                    idx = layoutSelector.selectedIndex;

                
                if (isComplete) {
                    
                    idx += (info.isForward ? 1 : -1);
                }

                
                layoutSelector.exitScroll(idx);
            },

            
            scrollCanceled: function scrollCanceled(info) {
                this._super(info);

                
                var layout = info.oldView;

                this.model.getDataService().setCurrentDocLayout(layout.k);
                this.selectLayout(layout, false);

                
                this.layoutSelector.initiateFade();
            },

            
            scrollComplete: function scrollComplete(info) {
                this._super(info);

                
                var layout = info.newView;
                this.selectLayout(layout, (layout.k !== this.model.getCurrentLayoutKey()));

                
                this.controller.generateActionToolbar();
            },

            
            renderInfoWindow: function renderInfoWindow(infoWindow) {
                
                
                infoWindow.autoCloses = infoWindow.locksHover = false;

                
                if (mstrApp.isTablet()) {
                    
                    this._super(infoWindow);
                    return;
                }

                var controller = this.controller,
                    rootCtrl = controller.rootCtrl,
                    oldTitle = rootCtrl.getTitle(),
                    fnUpdateTitle = function (title) {
                        rootCtrl.updateContent(null, title);
                    },
                    shouldReleaseOrientation = false;

                
                this.fullScreenInfoWindow = true;

                
                controller.generateActionToolbar();

                
                var id = this.id;
                mstrApp.showDialog({
                    cssClass: 'FSInfoWindow',

                    children: infoWindow,

                    
                    resizeDialog: function resizeDialog() {
                        var rootView = mstrApp.rootView,
                            availableSpace = rootView.getContentDimensions(),
                            ens = this.editorNode && this.editorNode.style,
                            infoWindow = this.children[0],
                            iwn = infoWindow && infoWindow.infoNode;

                        
                        if (ens) {
                            
                            ens.top = (parseInt(rootView.getBrowserDimensions().h, 10) - availableSpace.h + 3) + 'px';
                            ens.left = '5px';
                        }


                        
                        if (iwn) {
                            var iwns = iwn.style;

                            iwns.height = availableSpace.h + 'px';
                            iwns.width = availableSpace.w + 'px';

                            
                            mstrmojo.all[infoWindow.psId].setInfoWindowDimensions(availableSpace);
                        }
                    },

                    onClose: function onClose() {
                        fnUpdateTitle(oldTitle);

                        
                        delete mstrmojo.all[id].fullScreenInfoWindow;

                        
                        controller.generateActionToolbar();
                        
                        if (shouldReleaseOrientation) {
                            
                            mstrMobileApp.releaseOrientation();
                        }

                        
                        var infoWindow = this.children[0];
                        if (infoWindow && infoWindow.clearAnchorHilites) {
                            infoWindow.clearAnchorHilites();
                        }
                    },

                    
                    positionDialog: mstrmojo.emptyFn
                });

                
                var panelStack = infoWindow.children[0];
                fnUpdateTitle(panelStack.getTitle());

                
                if (mstrMobileApp.getLockedOrientation() === 0) {
                    
                    mstrMobileApp.lockOrientation(mstrMobileApp.getOrientation());

                    
                    shouldReleaseOrientation = true;
                }

                
                panelStack.attachEventListener('titleChange', this.id, function (evt) {
                    
                    fnUpdateTitle(evt.value);
                });
            },

            
            updateInfoWindowPS: function updateInfoWindowPS(psID, psKey) {
                if (!mstrApp.isTablet()) {
                    
                    mstrmojo.all[psID].setInfoWindowDimensions(mstrApp.getContentDimensions());
                }
            },

            
            destroy: function destroy(ignoreDom) {
                
                $AFE(this._layouts, function (lyt) {
                    
                    lyt.destroy(ignoreDom);
                });

                
                this.builder.destroy();

                
                this._super(ignoreDom);
            },

            getLayouts: function () {
                return this._layouts;
            },

            
            getSelectedLayoutWidget: function getSelectedLayout() {
                return this.getCurrentView();
            },

            
            getNewLayout: function getNewLayout(params, layouts, isSelected, callback) {
                
                var controller = this.controller,
                    desired;

                if (controller && controller.getDesiredElements) {
                    desired = controller.getDesiredElements();
                    if (desired) {
                        params.desiredElements = desired;
                    }
                }

                
                callback.success = mstrmojo.func.composite([ callback.success, function () {
                    
                    controller.generateActionToolbar();
                }]);

                
                $HASH.forEach(this.ifwMap, function (infoWindow) {
                    
                    if (infoWindow.visible) {
                        
                        infoWindow.close();
                    }
                });

                
                return this._super(params, layouts, isSelected, callback);
            },

            
            
            
            
            unloadLayouts: function unloadLayouts(keys, gbFlag) {

                var layouts = this._layouts,
                    curKey = this.model.getCurrentLayoutKey(),
                    i,
                    cnt = (layouts && layouts.length) || 0,
                    lyt,
                    gbys,
                    defn,
                    iKey;

                for (i = 0; i < cnt; i++) {
                    lyt = layouts[i];
                    defn = lyt.defn;
                    if (lyt.k !== curKey && defn && defn.loaded) {
                        if (gbFlag) {
                            gbys = (lyt.gb && lyt.gb.groupbys);
                            if (gbys && gbys.length) {
                                defn.loaded = false;
                            }
                        } else if (keys) {
                            for (iKey = 0; iKey < keys.length; iKey++) {
                                if (lyt.k === keys[iKey]) {
                                    defn.loaded = false;
                                    break;
                                }
                            }
                        } else {
                            defn.loaded = false;
                        }
                    }
                }
            },

            
            getSupportedLayouts: function getSupportedLayouts() {
                
                var layouts = [],
                    orientation = mstrMobileApp.getOrientation();

                
                $AFE(this._layouts, function (l) {
                    
                    if (((l.defn.or & orientation) > 0) && (!isInfoWindowLayout(l))) {
                        
                        layouts.push(l);
                    }
                });

                return layouts;
            },

            
            getCurrentLayout: function getCurrentLayout() {
                var layouts = this._layouts;
                return layouts[$ARR.find(layouts, 'k', this.model.getCurrentLayoutKey())];
            },

            getCaptureDimensions: function getCaptureDimensions() {
                var layout = this.getCurrentLayout();
                return layout.getCaptureDimensions && layout.getCaptureDimensions();
            },

            closeInfoWindowsOnTablet: function closeInfoWindowsOnTablet() {
                if (mstrApp.isTablet()) {
                    
                    $HASH.forEach(this.ifwMap, function (infoWindow) {
                        
                        if (infoWindow.visible) {
                            
                            infoWindow.closeOnTablet();
                        }
                    });
                }
            }
        }
    );
}());
(function () { 

    var ROW_AXIS = 1;
    var COL_AXIS = 2;   
    
    var CP_ROW_HEADERS = 4;
    var CP_VALUES = 8;  
    
    
    function _moreData(gd, isDoc) {
        var rw = gd.rw;
        
        
        if (!rw) {
            return false;
        }
        
        return isDoc ? (rw.row.bb + rw.row.bc < rw.row.tc) : (rw.wsr + rw.wmr < rw.tr);
    }    
    
    
    mstrmojo._XtabSeamlessIncrementalFetch = mstrmojo.provide(
            
        "mstrmojo._XtabSeamlessIncrementalFetch",   
        
        {
            
            _mixinName: 'mstrmojo._XtabSeamlessIncrementalFetch',
            
            
            useSeamlessIncFetch: true,
            
            preBuildRendering: function preBuildRendering() {
                var rtn = true;
                if (this._super) {
                    rtn = this._super();
                }
                
                if (this.useSeamlessIncFetch) {
                    
                    this.currentPageNum = 0;
                    this.currentPageNum = this.loadingPageNum = 0;
                    this.endFetching = !_moreData(this.gridData, this.isDocXtab);
                }
            },                
            
            
            aggregateCP: function aggregateCP(cp, rc, zone) {
                
                var scp = (rc === CP_ROW_HEADERS) ? this.rhsCP : this.valuesCP;
                
                
                if (scp.scriptClass !== "mstrmojo.XtabVACP") { 
                    scp = mstrmojo.hash.clone(scp);
                    var tcp = new mstrmojo.XtabVACP();
                    tcp.cps = [scp, cp];
                    mstrmojo.hash.copy(tcp, (rc === CP_ROW_HEADERS) ? this.rhsCP : this.valuesCP);
                } else {
                    
                    scp.cps.push(cp);
                }
                
                
                if (zone) {
                    zone.cp.initContent();
                }
            },
            
            onScrolledToLastRow: function onScrolledToLastRow() {
                if (this.useSeamlessIncFetch) {
                    var cp = this.currentPageNum,
                        lp = this.loadingPageNum;
                    
                    
                    if (lp <= cp && !this.endFetching) { 
                        this.loadingPageNum = cp + 1;
                        this.download(1 + cp);            
                    }
                }
            },
            
            
            download: function download(blockNum) {
                
                var rw = this.gridData.rw,
                    rwRow = rw.row,
                    rwCol = rw.col,
                    maxRows = rwRow.bc;
                
                
                this._isDownloading = this.rhsCP.isDownloading = this.valuesCP.isDownloading = true; 
                
                
                if (maxRows) {
                    var memo = {
                            blockNum: blockNum
                        };
                    
                    
                    this.controller.onDownloadGridData(this, this.model.getDownloadAction(blockNum * maxRows + 1, maxRows, rwCol.bb, rwCol.bc, this.id, memo));
                }
            },            
            
            
            dataDownloaded: function dataDownloaded(node, memo) {
                
                if (this._isDecelerating) {
                    
                    this._cachedDownload = {
                        node: node,
                        memo: memo
                    };
                    
                    
                    return;
                }
                
                
                var cachedDownload = this._cachedDownload;
                if (cachedDownload) {
                    
                    if (node) {
                        
                        alert('Missed download');
                    }
        
                    
                    node = cachedDownload.node;
                    memo = cachedDownload.memo;
                    
                    
                    delete this._cachedDownload;
                }
                
                var gd = node.data, 
                    z = this.zones;
                
                
                this._firstRowHeight = this._firstRowHeight || this.contentNode.rows[0].offsetHeight;
                
                var rhsCP = this.initCP(gd, this.interactiveCellsArray, CP_ROW_HEADERS, gd.ghs.rhs, gd.gts.row, ROW_AXIS),
                    valuesCP = this.initCP(gd, this.interactiveCellsArray, CP_VALUES, gd.gvs);
                
                this.aggregateCP(rhsCP, CP_ROW_HEADERS, z._BL);
                this.aggregateCP(valuesCP, CP_VALUES, z._BR);
        
                
                var start = rhsCP.startIndexInContainer,
                    end = start + rhsCP.rc - 1;
                
                var appGrid = function (zone) {
                    if (zone) {
                        
                        zone.start = start;
                        zone.end = end;
                        
                        
                        zone.renderGrid(true);                                                
                    }
                };
                
                
                var id = this.id;
                window.setTimeout(function () {
                    var w = mstrmojo.all[id];
                    
                    appGrid(z._BL);
                    appGrid(z._BR);
                    
                    
                    if (!_moreData(gd, w.isDocXtab)) {
                        
                        w.endFetching = true;                    
                    }
        
                    
                    w.setOffsets();
                    w.currentPageNum++;
        
                    
                    w._isDownloading = false;
                }, 0);
            }   
        }
    );
}());
(function () {

    mstrmojo.requiresCls(
        "mstrmojo.dom",
        "mstrmojo.array",
        "mstrmojo.hash",
        "mstrmojo.StickySections",
        "mstrmojo.VisTextTooltip"
    );

    var $D = mstrmojo.dom,
        $H = mstrmojo.hash,
        $A = mstrmojo.array,
        $THEMES = [ 'white', 'black', 'transparent', 'gray'],
        $SELECTED_ROW = "ig-selected-row";

    
    function isIGFullscreen() {
        return (this.isFullScreenWidget || !this.isDocXtab);
    }


    
    function cleanUpMXVP() {
        var gd = this.gridData,
            chs = gd.ghs.chs;

        
        if (chs.items && chs.items.length) {
            var mx = gd.ghs.chs.items[0].items,
                vp = gd.vp,
                cols = vp.cols,
                cg = cols.cg,
                cws = cols.cws,
                cgc = cg.cgc,
                i, j,
                hasMx = false,
                remove = [];

            for (i = 0; i < cgc; i++) {
                var col = cg[i],
                    mxCount = -1;

                $H.forEach(col, function (v, k) {
                    if (/[mMiIxX]([0-9])+$/.test(k)) {
                        for (j = 0; j < mx.length; j++) {
                            if (mx[j].mix == v) {
                                col[k] = j;
                                mxCount++;
                                break;
                            }
                        }
                        if (mx[col[k]] === undefined || j === mx.length) {
                            delete col[k];
                            return;
                        }
                        hasMx = true;
                    }
                });

                if (hasMx) {
                    var lastEmpty = [];
                    for (j = 0; j < col.cl; j++) {
                        if (col['mix' + j] === undefined) {
                            lastEmpty.push(j);
                        } else if (lastEmpty.length > 0) {
                            col['mix' + lastEmpty.splice(0, 1)] = col['mix' + j];
                            delete col['mix' + j];
                        }
                    }
                    col.cl = ++mxCount;

                    
                    if (col.cl === 0) {
                        remove.push(i);
                    }
                } else if (!col.attForms) {
                    
                    remove.push(i);
                }

                hasMx = false;
            }

            for (i = remove.length - 1; i >= 0; i--) {
                
                delete cg[remove[i]];

                
                for (j = remove[i]; j < cgc; j++) {
                    cg[j] = cg[j + 1];
                }

                
                delete cg[j-1];

                
                cws.splice(remove[i], 1);
                cg.cgc--;
            }
        }
    }


    
    function setupDefaultProps() {
        var DAF_DELIMITER = ":",
            gd = this.gridData,
            gts = gd.gts,
            chs = gd.ghs.chs,
            row = gts.row,
            firstTitle = row[0],
            hasMetrics = gts.col && gts.col.length > 0,
            vp = {
                
                bn: "0",

                
                gr: "0",

                
                ar: "1",

                
                ct: "1",

                
                daf: firstTitle.id + DAF_DELIMITER + firstTitle.fid,

                
                cols: {
                    
                    cws: [ { w: "100"} ],
                    cg: { cgc: 1 }
                }
            },
            gdAxis = ['row'],
            gdES = [gts.row],
            idx,
            len;

        
        if(hasMetrics) {
            
            gdAxis = ['row', 'col'];
            gdES = [gts.row, chs.items[0].items];

            
            vp.cols = {
                cws: [ { w: "50" }, { w: "50" } ],
                cg: { cgc: 2 }
            }
        }
        cg = vp.cols.cg;

        
        for(idx = 0, len = cg.cgc; idx < len; idx++) {
            var axis = gdAxis[idx],
                i;

            
            cg[idx] = {
                
                tg: true,

                
                cl: gdES[idx].length,

                
                cc: 0,

                
                sh: true
            };

            
            if (axis === 'col') {
                for (i = 0; i < gdES[idx].length; i++) {
                    cg[idx]['mix' + i] = gdES[idx][i].mix;
                }
            } else {
                cg[idx].attForms = [];
                for (i = 0; i < gdES[idx].length; i++) {
                    cg[idx].attForms[i] = {idx: i, n: ''};
                }
            }
        }

        
        this.gridData.vp = vp;
    }

    
    function findStackedCells(tr, trs) {
        var c, i, iLen, cn,
            
            findTR = function (direction, row, collection) {
                var j, jLen, r = row[direction + 'Sibling'], cell;
                if (r) {
                    for (j = 0, jLen = r.cells.length; j < jLen; j++) {
                        cell = r.cells[j];
                        if ((direction === 'next' && /stack-bottom/.test(cell.className)) || (direction === 'previous' && /stack-top/.test(cell.className))) {
                            collection.push(r);
                            return;
                        }
                    }

                    collection.push(r);
                    findTR(direction, r, collection);
                }
            };

        
        trs.push(tr);
        for (i = 0, iLen = tr.cells.length; i < iLen; i++) {
            c = tr.cells[i];
            cn = c.className;
            
            if (/stack/.test(cn)) {
                
                if (/stack-top/.test(cn)) {
                    findTR('next', tr, trs);
                    break;
                
                } else if (/stack-bottom/.test(cn)) {
                    findTR('previous', tr, trs);
                    break;
                
                } else if (/stack-middle/.test(cn)) {
                    findTR('next', tr, trs);
                    findTR('previous', tr, trs);
                    break;
                }
            }
        }

        return trs;
    }

    function addSelection(rows) {
        $A.forEach(rows, function (row) {
            
            mstrmojo.css.addClass(row, $SELECTED_ROW);
        });
    }

    function removeSelection() {
        
        var rows = $H.copy(document.getElementsByClassName($SELECTED_ROW));

        $A.forEach(rows, function (row) {
            mstrmojo.css.removeClass(row, $SELECTED_ROW);
        });
    }



    
    function handleAction(target) {
        
        var td = $D.findAncestorByAttr(target, 'ei', true, this.domNode),
            node = td && td.node,
            cell = this.getCellForNode(node);

        
        if (node && node.className.indexOf('iggroup') > 0) {
            return true;
        }

        
        if (this.isInteractiveGrid() && this.igToggle(cell)) {
            
            return true;
            
        }

        
        
        
        if (!cell) {
        	return true;
        }

        
        if ($D.contains(this._BR, target)) {
            
            removeSelection();

            var row = $D.findAncestorByName(target, 'tr', true);
            
            if ($D.contains(this._BR, row)) {
                
                addSelection(findStackedCells(row, []));
            }
        }

        return false;
    }

    
    mstrmojo._IsInteractiveGrid = mstrmojo.provide(
        "mstrmojo._IsInteractiveGrid",
        
        {
            _mixinName: 'mstrmojo._IsInteractiveGrid',

            
            cssClass: 'mstrmojo-InteractiveGrid',

            
            enableMagnifier: false,

            
            scrollerConfig: {
                scrollPast: false
            },

            
            isInteractiveGrid: function () {
                return (this.gridData.vp && this.gridData.vp.cols) ? true : false; 
            },

            preBuildRendering: function preBuildRendering() {
                
                if (this.gridData.eg) {
                    return this._super();
                }

                
                if (!this.isInteractiveGrid()) {
                    setupDefaultProps.call(this);
                }

                
                cleanUpMXVP.call(this);

                var me = this,
                    parent = this.parent,
                    setProp = function (propName) {
                        me[propName] = me[propName] || ((parent && parent[propName]) ? parent[propName] : 480);
                    };

                
                setProp('height');
                setProp('width');

                
                var theme = isNaN(this.gridData.vp.ct) ? 1 : parseInt(this.gridData.vp.ct, 10);

                
                this.cssClass = "mstrmojo-InteractiveGrid " + $THEMES[theme];

                
                this.scrollboxNodeOverflow = 'overflow:hidden;';

                var returnVal = (this._super ? this._super() : true);

                this.cssDefault = (this.cssDefault === "") ? "r-cssDefault" : "";

                return returnVal;
            },

            
            getKey: function getKey() {
                return this.gridData.k;
            },

            
            renderChildren: function renderChildren() {
                
                this.prepareCWSCalculation();

                
                if (this._super) {
                    this._super();
                }

                
                this.createStickySections();

                
                var BR = this.zones._BR,
                    hilitedCells = BR.hiliteCellsMap,
                    rows = {}, trs = [];
                
                $H.forEach(hilitedCells, function(cell, key){
                    $A.forEach(cell.pos, function(ro) {
                        BR.clearHilites(key);
                        rows[ro.row] = ro.row;
                    });
                });
                
                if(!$H.isEmpty(rows)) {
                    
                    $H.forEach(rows, function(v){
                        trs.push(BR.domNode.firstChild.rows[v]);
                    });
                    
                    addSelection(findStackedCells(trs[0], []));
                }
            },

            
            useDomToCalculateOffsets: function useDomToCalculateOffsets() {
                var cp = this.zones._BR.cp;
                if (cp && (cp.groupEnabled || cp.stackLevels > 1)) {
                    return true;
                } else {
                    return (this._super || this._super()) || false;
                }
            },

            
            prepareCWSCalculation: function prepareCWSCalculation() {
                var fmts = this.getFormats && this.getFormats(),
                    
                    width = (!isIGFullscreen.call(this)) ? parseInt(fmts.width, 10) : parseInt(this.width, 10);

                
                this.zones._BR.cp.gridWidth = width;
                this.zones._TR.cp.gridWidth = width;
            },

            
            createStickySections: function createStickySections() {
                var gd = this.gridData,
                    fmts = this.getFormats && this.getFormats();

                
                if (this.isInteractiveGrid() && (gd.vp.gr === '1' && gd.gts.cws.length > 1)) {
                    
                    mstrmojo.requiresCls("mstrmojo.StickySections");

                    
                    var node = this._TR,
                        slotName = 'stickySections';

                    
                    this.addSlots({ stickySections: node });

                    
                    if (!this.ss) {
                        var cell = this.zones._BR.cp.getResolvedGroupHeader(0, 0),
                            cssClass = "iggroup xtab-td",
                            DPICONVERSION = {
                                    320: -52
                                },
                            marginBottom = DPICONVERSION[mstrMobileApp.getDeviceDPI()] || -33,
                            
                            
                            width = (!isIGFullscreen.call(this)) ? (parseInt(fmts.width, 10) + 'px') : '100%',
                            cssText = "width: " + width + ";z-index: 2; position: relative;margin-bottom:" + marginBottom + "px;";

                        
                        this.ss = new mstrmojo.StickySections({
                            currentSectionTitle: cell.n || cell.v,
                            cssClass: cssClass,
                            slot: slotName,
                            cssText: cssText
                        });

                        this.addChildren(this.ss);
                    }
                }
            },

            
            performAction: function performAction(touch) {
                
                return handleAction.call(this, touch && touch.target) || (this._super && this._super(touch));
            },

            
            igToggle: function igToggle(cell) {
                
                if (!this.isInteractiveGrid() || !cell) {
                    return false;
                }

                var e = cell && cell._e,
                    otp = (cell && cell.otp) || (e && e.otp);

                if (otp) {
                    var i,
                        j,
                        cols = this.gridData.vp.cols,
                        cg = cols.cg,
                        mix = cell.mix,
                        OBJECT_TYPE_METRIC = 4,
                        OBJECT_TYPE_ATTR = 12,

                        
                        adjCol = function (currentCol, colPos) {
                            var _return = false;

                            
                            if (currentCol.tg && currentCol.cl > 1) {
                                var cc = currentCol.cc,
                                    cur = currentCol.cc,
                                    start = 0,
                                    end = currentCol.cl,
                                    diff = currentCol.cc = (++cur >= (end + start)) ? start : cur,
                                    colgroup = [this._TR.getElementsByTagName('COLGROUP')[0], this._BR.getElementsByTagName('COLGROUP')[0]];

                                
                                $A.forEach(colgroup, function (c) {
                                    var wPx = c.childNodes[colPos + cc].style.width;

                                    c.childNodes[colPos + cc].style.width = '0';
                                    c.childNodes[colPos + diff].style.width = wPx;
                                });

                                _return = true;
                            }

                            return _return;
                        },
                        currentCol,
                        attFm,
                        count = 0,
                        returnVal = false;

                    if (cell && cell.otp === OBJECT_TYPE_ATTR) {
                        for (i = 0; i < cg.cgc; i++) {
                            currentCol = cg[i];
                            attFm = currentCol.attForms;

                            
                            if (attFm) {
                                for (j = 0; j < currentCol.cl; j++) {
                                    if (attFm[j] && (attFm[j].idx === (cell.ci || cell.ui))) {
                                        
                                        returnVal = adjCol.call(this, currentCol, count);
                                    }
                                }
                            }

                            
                            count += currentCol.tg ? currentCol.cl : 1;
                        }

                    
                    } else if (e && e.otp === OBJECT_TYPE_METRIC) {
                        for (i = 0; i < cg.cgc; i++) {
                            currentCol = cg[i];

                            
                            if (currentCol['mix' + currentCol.cc] === mix) {
                                
                                returnVal = adjCol.call(this, currentCol, count);
                            }

                            
                            count += currentCol.tg ? currentCol.cl : 1;
                        }
                    }

                    return returnVal;
                }

                
                return false;
            },

            
            getHACP: function getHACP() {
                
                var hacp = (this.isInteractiveGrid()) ? new mstrmojo.InteractiveGridHACP() : this._super();

                
                hacp.onDemandIF = !!(this.onDemandIF && this.gridData.rw);

                return hacp;
            },

            
            onheightChange: function onheightChange() {
                if (isIGFullscreen.call(this) && this.scrollboxNode) {
                    
                    this.scrollboxNode.style.height = (parseInt(this.height, 10) - this._TR.clientHeight) + 'px';
                }

                
                if (this._super) {
                    this._super();
                }
            },

            
            onwidthChange: function onwidthChange() {
                if (isIGFullscreen.call(this)) {
                    
                    var w = this.width;

                    
                    if (this.hasRendered) {
                        
                        this.unrender();

                        
                        this.width = w;

                        
                        this.render();
                    }

                } else if (this._super) {
                    this._super();
                }
            },

            
            defaultAction: function defaultAction(td, tCell) {
                var _returnVal = false;

                if (this._super) {
                    _returnVal = this._super(td, tCell);
                }

                
                this.model.sti = null;

                return _returnVal;
            },

            
            onclick: function onclick(evt) {
                
                if (!mstrApp.isTouchApp()) {
                    var e = evt.e;

                    
                    return handleAction.call(this, $D.findAncestorByName(e.target, 'td', true)) || (this._super && this._super(evt));
                }
            },



            touchSelectBegin: function touchSelectBegin(touch) {
                var tch = touch;

                var touchTd = mstrmojo.dom.findAncestorByName(touch.target, 'td', true, this.domNode);
                var hasImg = this.hasImgTag(touchTd);
                var touchArea = mstrmojo.dom.findAncestorByAttr(touch.target, 'trType', true, this.domNode);
                if (touchTd && touchArea && !hasImg) {
                	var textWidth = this.getTextWidth(touchTd, touchTd.className);
                    if (textWidth > touchTd.offsetWidth - 30) {
                    	
                   	 
                    	if (!this.visTextTooltip) {
                    		var ph = document.createElement('div');
                    		this.domNode.appendChild(ph);
                        	this.visTextTooltip = new mstrmojo.VisTextTooltip({placeholder: ph, targetDiv: touchTd, boundary: this.domNode, touchAreaType: touchArea.value});
                            this.visTextTooltip.render();
                            this.visTextTooltip.updateContent(touchTd, touchArea.value, touchTd.innerText);
                        } else {
                        	this.visTextTooltip.targetDiv = touchTd;
                        	this.visTextTooltip.touchAreaType = touchArea.value;
                        	this.visTextTooltip.updateContent(touchTd, touchArea.value, touchTd.innerText);
                        }
                    }
                }

            },

            touchSelectEnd: function touchSelectEnd(touch) {
            	var tch = touch;

            	if (this.visTextTooltip && this.visTextTooltip.domNode) {
            		this.visTextTooltip.toggle(false);
            	}

            },

            
            
            hasImgTag: function hIT(touchTd) {
            	var child = touchTd && touchTd.childNodes.length>0 && touchTd.childNodes[0];
            	if (child && child.nodeName.toLowerCase() === 'div') {
            		var grandChild = child.childNodes.length>0 && child.childNodes[0];
            		if (grandChild && grandChild.nodeName.toLowerCase() === 'div') {
            			var img = grandChild.childNodes.length>1 && grandChild.childNodes[1];
            			if (img && img.nodeName.toLowerCase() === 'img') {
            				return true;
            			}
            		}
            	}

            	return false;

            },

            getTextWidth : function gtw(dom, className, fontName, fontSize, fontSizeUnit, bold) {
            	var childNodes = dom.childNodes;
            	var table = null,
            		selfTextDom = null;
            	if (childNodes.length>0 && childNodes[0].nodeName.toLowerCase() === '#text') {
            		table = document.createElement('table');
            		selfTextDom = document.createElement('td');
            		table.appendChild(selfTextDom);
            	} else if (childNodes.length>0 && childNodes[0].nodeName.toLowerCase() === 'span') {
            		selfTextDom = document.createElement('span');
    				selfTextDom.style = "z-index:-10;visibility:hidden;-webkit-text-size-adjust: none;";
            	} else {
            		return -1;
            	}

				if(selfTextDom.className !== className || "")
					selfTextDom.className = className || "";
				if(selfTextDom.style.fontFamily !== fontName || "")
					selfTextDom.style.fontFamily = fontName || "" ;

				var fsUnit = fontSizeUnit || "pt"

				if(fontSize){
					selfTextDom.style.fontSize = fontSize + fsUnit;
				}else{
					selfTextDom.style.fontSize = '';
				}

				if(bold){
					if(selfTextDom.style.fontWeight !== 'bold')
						selfTextDom.style.fontWeight = 'bold';
				}else{
					if(selfTextDom.style.fontWeight!=='')
						selfTextDom.style.fontWeight = '';
				}

				selfTextDom.innerHTML = dom.innerText;

				var ret = -1;
				if (table) {
					this.domNode.appendChild(table);
					ret = selfTextDom.offsetWidth - 30; 
					this.domNode.removeChild(table);
				} else {
					this.domNode.appendChild(selfTextDom);
					
					ret = selfTextDom.offsetWidth;
					this.domNode.removeChild(selfTextDom);
				}


				return ret;
			},

            
            unrender: function unrender(ignoreDom) {
            	
            	if (this.visTextTooltip && this.visTextTooltip.destroy) {
               		this.visTextTooltip.destroy();
               		delete this.visTextTooltip;
               	}

                var stickySection = this.ss;

                
                if (stickySection) {
                    
                    this.removeChildren(stickySection, true);

                    
                    stickySection.destroy();
                    delete this.ss;
                }

                
                this._super(ignoreDom);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._HasScrollbox",
                         "mstrmojo.XtabZone",
                         "mstrmojo._ShowsStatus",
                         "mstrmojo.boxmodel",
                         "mstrmojo.dom");


    var ROW_AXIS = 1;
    var COL_AXIS = 2;
    var LOCK_OFF = 0;
    var LOCK_ROW = 1;
    var LOCK_COL = 2;
    var LOCK_BOTH = 3;

    
    var CP_TITLE = 1;
    var CP_COL_HEADERS = 2;
    var CP_ROW_HEADERS = 4;
    var CP_VALUES = 8;

    var $D = mstrmojo.dom,
        UNSET;

    function onDemandCPAgg(cpList) {
        var vCP = null;
        if (cpList && cpList.length > 1) {
            
            vCP = new mstrmojo.XtabVACP();
            vCP.cps = cpList;
        }
        return vCP;
    }

    function repaint(node) {
        var img = document.createElement('img');
        node.appendChild(img);
        node.removeChild(img);
    }

    function convertEmtoPx(dom, v) {
        if ($D.isIE) {
            return mstrmojo.boxmodel.convert2px(dom, v);
        }
        return v;
    }

    
    function addOnDemandCPs(rw) {
        if (!rw || this._onDemandCP) {
            return;
        }

        
        var blockCount = rw.bc,
            totalRows = rw.tc,
            rowsRemaining = totalRows - blockCount,
            numCPs = Math.ceil(rowsRemaining / blockCount),
            rhsCPList = [],
            valuesCPList = [],
            i;

        
        for (i = 0; i < numCPs; ++i) {
            
            var rc = Math.min(rowsRemaining, blockCount);

            
            
            rhsCPList.push(this.createOnDemandCP(i + 1, rc, CP_ROW_HEADERS));
            valuesCPList.push(this.createOnDemandCP(i + 1, rc, CP_VALUES));

            
            rowsRemaining -= blockCount;
        }

        this._onDemandCP = {rhs: rhsCPList, vls: valuesCPList};
        return this._onDemandCP;
    }


    
    
    mstrmojo.XtabBase = mstrmojo.declare(
        
        mstrmojo.Container,

        
        [ mstrmojo._HasScrollbox, mstrmojo._ShowsStatus ],

        
        {
            scriptClass: "mstrmojo.XtabBase",

            
            dataRenderMode: "vscroll",

            
            handleClicks: function handleClicks() {
                return true;
            },

            markupString: '<div id="{@id}" class="mstrmojo-Xtab {@cssClass}" title="{@tooltip}" style="{@domNodeCssText}">' +
                            '<div style="display: none;{@msgNodeCssText}"><div>&nbsp;</div></div>' +    
                            '<div class="mstrmojo-Xtab-overlay"></div>' +
                            '<div class="mstrmojo-Xtab-content {@cssDefault}" title="{@tooltip}" style="{@viewportCssText}" mstrAttach:click,selectstart>' +
                                '<table cellspacing="0" cellpadding="0">' +
                                    '<tr trType="title">' +
                                        '<td style="vertical-align:top;padding:0px"></td>' +    
                                        '<td class="xtab-tr" style="vertical-align:top;padding:0px;"></td>' +
                                    '</tr><tr trType="content">' +
                                        '<td class="xtab-bl" style="vertical-align:top;padding:0px;"></td>' +
                                        '<td class="xtab-br" style="vertical-align:top;padding:0px">' +
                                            '<div class="mstrmojo-progress" style="display:none">' +
                                                '<div class="mstrmojo-progress-barbg">' +
                                                    '<div class="mstrmojo-progress-bar"></div>' +
                                                '</div>' +
                                                '<div class="mstrmojo-progress-text"></div>' +
                                                '</div>' +
                                            
                                            
                                            
                                            '<div id="{@id}_scrollbox" style="position:relative;{@scrollboxNodeCssText};{@scrollboxNodeOverflow}"></div>' +
                                        '</td>' +
                                    '</tr>' +
                                '</table>' +
                            '</div>' +
                        '</div>',

            markupSlots: {
                overlayNode: function () { return this.domNode; },
                msgNode: function () { return this.domNode.firstChild; },
                maskNode: function () { return this.domNode.childNodes[1]; },
                viewport: function () { return this.domNode.lastChild; },
                contentNode: function () { return this.domNode.lastChild.firstChild; },
                scrollboxNode: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].lastChild; },

                
                _TL: function () { return this.domNode.lastChild.firstChild.rows[0].cells[0]; },                                                    
                _TR: function () { return this.domNode.lastChild.firstChild.rows[0].cells[1]; },                                     
                _BL: function () { return this.domNode.lastChild.firstChild.rows[1].cells[0]; },                                 
                _BR: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].lastChild; },                          

                
                _T_ROW: function () { return this.domNode.lastChild.firstChild.rows[0]; },                              
                _B_ROW: function () { return this.domNode.lastChild.firstChild.rows[1]; },                              
                _BR_CELL: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1]; },                

                
                
                _STATUS: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].firstChild;  },
                _STATUS_TXT: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].firstChild.lastChild; },
                _STATUS_BAR: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].firstChild.firstChild.firstChild; }
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? 'block' : 'none'; }
            },

            
            zones: null,

            
            lockHeadersCase: LOCK_BOTH,

            
            interactiveCellsArray: null,

            
            titlesCP: null,

            
            chsCP: null,

            
            rhsCP: null,

            
            valuesCP: null,

            
            onDemandIF: true,

            
            numRowFixed: false,

            
            heightLimit: 0,

            
            height: 0,

            
            widthLimit: 0,

            
            width: 0,

            useTouchScrolling: false,

            
            scrollInterval: 0,

            
            selections: null,

            
            dataBlocks: null,

            
            getCellUnitIndex: function getCellUnitIndex(cell) {
                return (cell.o !== undefined) ? cell.o : cell._ei;
            },

            
            getCellTitleId: function getCellTitleId(cell) {
                var rtn = '';

                if (cell.axis && cell.ui !== undefined) {
                    rtn = cell.axis + 'A' + (cell.ui + 1);

                } else if (cell.mix !== undefined) {
                    rtn = '0A' + cell.mix;
                }

                return rtn;
            },

            
            update: function update(node) {
                if (this._super) {
                    this._super(node);
                }

                this.set('gridData', node.data[0] || node.data); 

                var defn = this.defn || node.defn;
                this.sid = this.gridData.sid;
                this.treeType = (defn && defn.tt) || 1;
                this.interactiveCellsArray = [];
            },

            
            initCP: function initCP(gd, interactiveCellsArray, tp, base, lkpBase, ax, cp) {
                var props = {
                    gridData: gd,
                    type: tp,
                    interactiveCellsArray: interactiveCellsArray
                };

                props.base = base || props.base;
                props.lookupBase = lkpBase || props.lookupBase;
                props.axis = ax || props.axis;

                if (!cp) {
                    if (tp === CP_TITLE) {
                        cp = new mstrmojo.XtabTitlesCP(props);
                    } else {
                        cp = new mstrmojo.XtabCP(props);
                    }
                } else {
                    mstrmojo.hash.copy(props, cp);
                }
                return cp;
            },


            preBuildRendering: function preBuildRendering() {
                var gd = this.gridData;

                
                this.lockHeadersCase = parseInt(gd.lhv, 10);
                this.selections = {};

                this.cssDefault = (this.lockHeadersCase === LOCK_OFF || !this.k) ? "" : "r-cssDefault" + (this.k ? "_" + this.k : "");

                
                
                
                
                this.numRowFixed = !!(!this.height && gd.rw && gd.rw.row && (gd.rw.row.bc < gd.rw.row.tc));
                this.rw = gd.rw;
                this._onDemandCP = null;

                
                if (this.width) {
                    this.widthLimit = parseInt(this.width, 10);
                }
                if (this.height) {
                    this.heightLimit = parseInt(this.height, 10);
                }

                
                return (this._super) ? this._super() : true;
            },

            
            renderEmptyGrid: function renderEmptyGrid() {
                var gd = this.gridData,
                    msgNode = this.msgNode,
                    viewport = this.viewport;

                
                msgNode.firstChild.innerHTML = gd.eg;
                msgNode.style.display = "block";
                msgNode.style.overflow = "hidden";
                msgNode.className = 'mstrmojo-message';
                viewport.style.display = "none";

                return (this._super) ? this._super() : true;
            },

            
            postBuildRendering: function postBldRndr() {
                
                var gd = this.gridData,
                    bInitZones = !!this._BR && gd,
                    msgNode = this.msgNode,
                    viewport = this.viewport,
                    rtn;

                if (gd.eg === undefined) {
                    
                    if (msgNode.style.display === "block") {
                        msgNode.style.display = "none";
                        viewport.style.display = "block";
                    }
                } else {
                    return this.renderEmptyGrid();
                }

                
                if (!this.interactiveCellsArray) {
                    this.interactiveCellsArray = [];
                }

                if (bInitZones) {
                    this._setupZones(gd);
                    this._setupCPs(gd);
                    
                    
                    var zs = this.zones,
                        n;

                    for (n in zs) {
                        var z = zs[n];
                        if (z.parent !== this) {
                            this.addChildren(this.zones[n]);
                        }
                    }

                    
                    if (this.scrollboxNode) {
                        
                        
                        var h = this.heightLimit;
                        this.scrollboxHeightFixed = !isNaN(h) && (h > 0);
                        if (this.scrollboxHeightFixed) {
                            this.scrollboxHeight = h; 
                        }
                        this.scrollboxLeft = this.scrollboxTop = 0; 

                        
                        if (this.lockHeadersCase) {
                            this.connectScrollbox(this);
                        }
                    }
                }

                this.renderChildren();
                rtn = this._super();

                
                if (this.numRowFixed) {
                    
                    if (!this.height) {
                        
                        this.heightLimit = this.zones._BR.getPageHeight(0) + (this._TR ? this._TR.offsetHeight : 0);

                        
                        this.height = this.heightLimit + 'px';

                    } else {
                        
                        this.heightLimit = parseInt(this.height, 10);
                    }
                }

                
                
                
                if ((this.lockHeadersCase && bInitZones && this.scrollboxNode) || this.numRowFixed) {
                    
                    
                    
                    this.resizeScrollBox($D.isIE);
                }

                
                this.onGridWidthChanged(true);

                
                
                if ($D.isIE7 && !this.scrollboxHeightFixed && this.scrollboxNode && this.scrollboxNode.scrollWidth > this.scrollboxNode.offsetWidth) {
                    this.scrollboxNode.style.height = this.scrollboxNode.offsetHeight + 17 + 'px';
                }

                return rtn;
            },

            onclick: function onclick(e, hWin) {

				
				if (!this.interactiveCellsArray.length) {
					this.isSelectingText = false;
					return;
				}

                e = e.e || e;

                
                var $D = mstrmojo.dom,
                    target = $D.eventTarget(hWin, e),
                    clickedCell = target && $D.findAncestorByName(target, 'td', true, this.viewport);

                if (target.nodeName.toLowerCase() === 'a' && clickedCell.getAttribute('ei')) {
                    try {
                        var att = this.interactiveCellsArray[parseInt(clickedCell.getAttribute('ei'), 10)];
                        var DssXmlBaseFormHTMLTag = 7;
                        if (att && att.ts === DssXmlBaseFormHTMLTag) { 
                            target.href = mstrmojo.addCSRFTokenToURL(target.href);
                        }
                    } catch (er) {
                        
                    }
                }

                
                if (clickedCell) {
                    
                    var a = $D.findAncestorByName(target, 'span', true, clickedCell);

                    if (a && !$D.shiftKey(hWin, e) && !$D.ctrlKey(hWin, e)) {
                        
                        
                        this.defaultAction(clickedCell);

                    } else {
                        this.doSelection(e, hWin, clickedCell);
                        if (!this.isSelectingText) {
                            $D.clearBrowserHighlights();
                        }
                    }
                }

                if (this.isSelectingText) {
                    this.isSelectingText = false;
                }
            },

            ontouchend: function ontouchend(e, hWin) {
                this.onclick(e, hWin);
            },

            onselectstart: function onselectstart() {
            	this.isSelectingText = true;
                return false;
            },

            
            onscroll: function onscroll() {
                this._alignHeaders();
            },

            
            resizeScrollBox: function resizeScrollBox(bForceRepaint) {

                
                var sb = this.scrollboxNode,
                    ss = sb && sb.style,
                    br = this._B_ROW,
                    brc = this._BR_CELL;
                if (!ss || !br || !brc) {
                    return;
                }

                
                
                
                var width = this.widthLimit,
                    
                    height = this.heightLimit;
                
                if (!width || !height) {
                    
                    if (!width) {
                        ss.width = 'auto';
                    }
                    if (!height) {
                        ss.height = 'auto';
                        this.scrollboxHeightFixed = false;
                    }
                }

                if (height) {
                    
                    var top = (this.zones._TR && this.zones._TR.cp.rc) ? br.offsetTop : 0,
                        newHeight = height - top;
                    if (newHeight > 0) {
                        ss.height = newHeight + 'px';
                        this.scrollboxHeight = newHeight;
                        this.scrollboxHeightFixed = true;

                        
                        
                        
                        if ((this.lockHeadersCase !== LOCK_OFF) && this.numRowFixed) {
                            this.viewport.style.height = this.overlayNode.style.height = (newHeight + top) + 'px';
                        }
                    }
                }

                if (!this.useTouchScrolling) {
                    
                    
                    

                    
                    
                    
                    var left = (this.zones._BL && this.zones._BL.cp.rc) ? brc.offsetLeft : 0;

                    
                    
                    var adjustSum = 0;
                    if (this.lockHeadersCase !== LOCK_OFF) {
                        
                        var vp = this.viewport,
                            cs = mstrmojo.css.getComputedStyle(vp),
                            metrics = ['paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth'];
                        if (cs) {
                            mstrmojo.array.forEach(metrics, function (v) {
                                adjustSum += parseFloat(convertEmtoPx(vp, cs[v]));
                            });
                        }
                        
                        if (this.width) {
                            this.viewport.style.width = (parseFloat(this.width) - (adjustSum || 0)) + 'px';
                        }
                    }

                    
                    var newWidth = (this.widthLimit && (this.widthLimit - left)) || (mstrmojo.dom.isIE7 ? brc.scrollWidth + 1 : (brc.scrollWidth + (sb.offsetWidth - sb.clientWidth))); 
                    if (newWidth && (newWidth > 0)) {
                        newWidth -= adjustSum;
                        ss.width = newWidth + 'px';
                    }

                    
                    this._alignHeaders(bForceRepaint);
                }

                
                var finalHeight = ss.height,
                    finalWidth = ss.width;
                if (finalHeight || finalWidth) {
                    
                    var container = mstrmojo.findAncestor(this, 'fixedSizeCanGrowShrink', null, mstrmojo.DocSection);
                    if (container) {
                        
                        container.fixedSizeCanGrowShrink(this, finalHeight, finalWidth);
                    }
                }

            },

            _resizeScrollBoxWidth: function _resizeScrollBoxWidth() {
                
                var sb = this.scrollboxNode,
                    ss = sb && sb.style,
                    br = this._B_ROW,
                    brc = this._BR_CELL;
                if (this.useTouchScrolling || !ss || !br || !brc) {
                    return;
                }

                
                
                
                var width = this.widthLimit;
                
                if (!width) {
                    ss.width = 'auto';
                }

                var fnUpdatetWidth = function() {
                    
                    var newWidth = (mstrmojo.dom.isIE7 ? brc.scrollWidth + 1: (brc.scrollWidth + (sb.offsetWidth - sb.clientWidth))); 
                    
                    
                    if ((newWidth && (newWidth > 0)) && (!width || (width && (newWidth < width))) && (sb.firstChild.firstChild.offsetWidth >= sb.clientWidth)) {
                        ss.width = newWidth + 'px';
                    }
                };

                
                if (mstrmojo.dom.isIE7) {
                    window.setTimeout(function(){fnUpdatetWidth();}, 1);
                } else {
                    fnUpdatetWidth();
                }

            },

            
            onGridWidthChanged: function onGridWidthChange(noScrollBoxChange) {

                
                if (this.lockHeadersCase === LOCK_OFF && !noScrollBoxChange) {
                    this._resizeScrollBoxWidth();
                }

                
                var container = mstrmojo.findAncestor(this, 'fixedSizeCanGrowShrink', null, mstrmojo.DocSection),
                    widthLimit = this.widthLimit;

                
                
                if (!widthLimit) {
                    this.width = UNSET;

                    
                    if (container) {
                        
                        container.performCanGrowCanShrink([ this ], true);
                    }
                } else if (container) {
                    
                    container.fixedSizeCanGrowShrink(this, null, widthLimit);
                }
            },

            
            getGridDimension: function getGridDimension(dimension) {
                var DIM_HEIGHT = 1, 
                    dim = dimension === DIM_HEIGHT ? 'Height' : 'Width',
                    dimLC = dim.toLowerCase(),
                    limit = this[dimLC + 'Limit'];

                if (!limit && (this[dimLC] === UNSET || this[dimLC] === 0)) {
                    limit = this.viewport['offset' + dim];
                    this[dimLC] = limit + 'px';
                    return limit;
                }

                return limit || parseInt(this[dimLC], 10);
            },

            
            _alignHeaders: function syncHeaders(bForceRepaint) {
                
                
                if (this.lockHeadersCase === LOCK_OFF || this.useTouchScrolling) {
                    return;
                }

                
                var left = this.scrollboxLeft,
                    top = this.scrollboxTop,
                    zs = this.zones,
                    trz = zs._TR,
                    blz = zs._BL;

                
                function set(zone, prop, v) {
                    var el = zone && zone.domNode,
                        s = el && el.style;
                    if (!s) {
                        return;
                    }
                    s[prop] = -v + "px";
                }

                
                if (trz && trz.rc) {
                    set(trz, 'left', left);
                }
                
                if (blz && blz.rc) {
                    set(blz, 'top', top);
                }

                
                
                
                if (bForceRepaint) {
                    repaint(this._BL);
                }
            },

            
            defaultAction: function defaultAction(td, tCell) {
                
                var cell = tCell || this.getCellForNode(td),
                    
                    
                    isReselectingTD = td && td.className.indexOf('sc_') > 0,
                    action = this.model.getAction(this.getActionCells(cell), td, isReselectingTD),
                    handler = action && action.h;

                
                this._currentSelectedTD = td;

                
                if (handler && this.controller[handler]) {
                    
                    this.controller[handler](this, action.a);
                    return true;
                }

                
                return false;
            },

            createZone: function createZone(cfg) {
                return new mstrmojo.XtabZone(cfg || {});
            },

            
            _setupZones: function _setupZones(gd) {
                
                
                var oldsz = this.zones;

                
                this.zones = {};

                
                var zs = this.zones,
                    l = this.lockHeadersCase,
                    zIndex = 'z-index:';

                var me = this;
                
                function newz(rm, style, slot, oldsz) {
                    var zone = (oldsz && oldsz[slot]) || me.createZone({
                        renderMode: rm,
                        cssText: style,
                        slot: slot
                    });

                    zs[slot] = zone;
                    
                    zone.rh = gd.rh;
                }

                
                

                
                newz(this.dataRenderMode, zIndex + '1;', "_BR", oldsz);
                if (l & LOCK_ROW) {
                    newz(this.dataRenderMode, zIndex + '3;', "_BL", oldsz);
                }
                if (l & LOCK_COL) {
                    newz(null, zIndex + '3;', "_TR", oldsz);
                }
                if (l === LOCK_BOTH) {
                    newz(null, zIndex + '4;', "_TL", oldsz);
                }

                
                if (l === LOCK_OFF) {
                    this.zones._BR.autoFitWindow = !!gd.afw;
                    this.zones._BR.tableCssClass = "r-cssDefault" + (this.k ? "_" + this.k : '');
                }

                
                if (mstrmojo.dom.isIE7) {
                    if (l & LOCK_ROW || l & LOCK_COL || l === LOCK_BOTH) {
                        this._T_ROW.style.display = 'block';
                    } else if (l === LOCK_OFF) {
                        this._T_ROW.style.display = 'none';
                    }
                }

                var bz = zs._BL || zs._BR;
                if (bz) { 
                    bz.numColumnCanMerge = gd.gts.cws.length - 1;
                }
            },

            getHACP: function getHACP() {
                return (this._super && this._super()) || new mstrmojo.XtabHACP();
            },

            
            _setupCPs: function _setupCPs(gd) {
                
                var titlesCP = this.titlesCP = this.getTitleCP(gd),
                    chsCP = this.chsCP = this.getColumnHeadersCP(gd),
                    rhsCP = this.rhsCP = this.getRowHeadersCP(gd),
                    valuesCP = this.valuesCP = this.getValuesCP(gd);

                
                titlesCP.forceAutoRowHeight = chsCP.forceAutoRowHeight = gd.rh;

                
                
                var zs = this.zones;

                switch (this.lockHeadersCase) {
                case LOCK_OFF:
                    
                    var vacp = new mstrmojo.XtabVACP();

                    
                    var hacpTop = this.getHACP();
                    hacpTop.cps = [titlesCP, chsCP];
                    vacp.cps = [hacpTop];

                    var hacpBottom = this.getHACP();
                    hacpBottom.cps = [rhsCP, valuesCP];
                    vacp.cps.push(hacpBottom);

                    
                    zs._BR.cp = vacp;
                    break;

                case LOCK_ROW:
                    
                    var acpLeft = new mstrmojo.XtabVACP();
                    var acpRight = new mstrmojo.XtabVACP();

                    
                    acpLeft.cps = [titlesCP, rhsCP];

                    
                    acpRight.cps = [chsCP, valuesCP];

                    
                    zs._BL.cp = acpLeft;
                    zs._BR.cp = acpRight;
                    break;

                case LOCK_COL:
                    
                    var acpTop = this.getHACP();
                    var acpBottom = this.getHACP();

                    
                    acpTop.cps = [titlesCP, chsCP];

                    
                    acpBottom.cps = [rhsCP, valuesCP];

                    
                    zs._TR.cp = acpTop;
                    zs._BR.cp = acpBottom;
                    break;

                case LOCK_BOTH:
                    zs._TL.cp = titlesCP;
                    zs._TR.cp = chsCP;

                    zs._BL.cp = rhsCP;
                    zs._BR.cp = valuesCP;
                    break;

                }
            },

            ongridDataChange: function ongridDataChange() {
                
                var m = this.model;
                if (m) {
                    
                    m.set('data', this.gridData);

                    if (!this.dataBlocks) {
                        this.dataBlocks = [];
                    }
                    this.dataBlocks[0] = this.gridData;
                }
            },

            gridPagesRendered: mstrmojo.emptyFn,

            
            getTitleCP: function getTitleCP(gd) {
                return this.initCP(gd, this.interactiveCellsArray, CP_TITLE);
            },

            
            getColumnHeadersCP: function getColumnHeadersCP(gd) {
                return this.initCP(gd, this.interactiveCellsArray, CP_COL_HEADERS, gd.ghs.chs, gd.gts.col, COL_AXIS);
            },

            
            getRowHeadersCP: function getRowHeadersCP(gd) {
                var rhsCP = this.initCP(gd, this.interactiveCellsArray, CP_ROW_HEADERS, gd.ghs.rhs, gd.gts.row, ROW_AXIS);

                
                if (this.onDemandIF && this.rw) {
                    if (!this._onDemandCP) {
                        addOnDemandCPs.call(this, this.rw && this.rw.row); 
                    }
                    this.rhsCPList = [rhsCP].concat(this._onDemandCP.rhs);
                    return onDemandCPAgg(this.rhsCPList) || rhsCP;
                }

                return rhsCP;
            },

            
            getValuesCP: function getValuesCP(gd) {
                var valuesCP = this.initCP(gd, this.interactiveCellsArray, CP_VALUES, gd.gvs);

                
                if (this.onDemandIF && this.rw) {
                    
                    if (!this._onDemandCP) {
                        addOnDemandCPs.call(this, this.rw && this.rw.row);
                    }
                    this.valuesCPList = [valuesCP].concat(this._onDemandCP.vls);

                    return onDemandCPAgg(this.valuesCPList) || valuesCP;
                }

                return valuesCP;
            },

            
            createOnDemandCP: function createOnDemandCP(blockNum, rc, zone) {
                var cp =  new mstrmojo.XtabOnDemandCP();
                cp.dataSource = this;
                cp.blockNum = blockNum;
                cp.rc = rc;
                return cp;
            },

            
            dataDownloaded: function dataDownloaded(node, memo) {
                
                var idx = memo.blockNum,
                    rhsCP = this.rhsCPList[idx],
                    valuesCP = this.valuesCPList[idx],
                    gd = node.data;

                gd._bidx = idx;
                this.dataBlocks[idx] = gd;

                if (!rhsCP || !valuesCP) {
                    return;
                }

                
                this.initCP(gd, this.interactiveCellsArray, CP_ROW_HEADERS, gd.ghs.rhs, gd.gts.row, ROW_AXIS, rhsCP);
                this.initCP(gd, this.interactiveCellsArray, CP_VALUES, gd.gvs, null, null, valuesCP);

                
                rhsCP.initContent();
                valuesCP.initContent();

                
                this.numRowsDownloaded += parseInt(rhsCP.rc, 10);
                this.updateStatus(mstrmojo.desc(8301, "Retrieving Data ..."), this.numRowsDownloaded * 100 / this.numRowsToDownload);

                var zs = this.zones,
                    bl = zs && zs._BL,
                    br = zs && zs._BR;

                
                if (bl) {
                    bl.dataDownloaded();
                }
                if (br) {
                    br.dataDownloaded();
                }
            },

            
            
            showDownloadStatus: function shwRndrSts(numRowsToDownload) {
                
                if (!numRowsToDownload) {
                    return;
                }

                
                if (this.showingStatus) {
                    this.numRowsToDownload += numRowsToDownload;
                } else {
                    
                    this.numRowsToDownload = numRowsToDownload;

                    
                    this.numRowsDownloaded = 0;
                }

                if (this.showStatus) {
                    this.showStatus(true, mstrmojo.desc(8301, "Retrieving Data ..."), this.numRowsDownloaded * 100 / this.numRowsToDownload);
                }
            },

            closeDownloadStatus: function closeSts() {
                this.numRowsToDownload = 0;
                if (this.showStatus) {
                    this.showStatus(false);
                }
            },

            
            download: function download(blockNum) {
                
                var rw = this.gridData.rw,
                    rwRow = rw.row,
                    rwCol = rw.col,
                    maxRows = rwRow.bc;

                
                this.rhsCPList[blockNum].isDownloading = this.valuesCPList[blockNum].isDownloading = true;

                
                if (maxRows) {
                    
                    this.controller.onDownloadGridData(this, this.model.getDownloadAction(blockNum * maxRows + 1, maxRows, rwCol.bb, rwCol.bc, this.id, {
                        blockNum: blockNum
                    }));
                }
            },

            unrender: function unrender(ignoreDom) {
                
                this.width = this.widthLimit = this.height = this.heightLimit = 0;

                
                
                this.disconnectScrollbox(this);
                this._super(ignoreDom);
            },

            
            getCellForNode: function getCellForNode(td) {
                var idx = td && td.getAttribute('ei');
                if (isNaN(idx)) {
                    return null;
                }
                var t = this.interactiveCellsArray[parseInt(idx, 10)];
                return t;
            },

            
            getActionCells: function getActionCells(cell) {
                var cells = [],
                    selections = this.selections;

                var titleId = cell.axis + 'A' + (cell.ui + 1),
                    selTitle = selections[titleId],
                    i;

                if (selTitle && selTitle[cell.o]) {
                    for (i in selTitle) {
                        var sc = this.getCellForNode(selTitle[i][0]); 
                        cells.push(sc);
                    }
                } else {
                    cells.push(cell);
                }
                return cells;
            },

            setModel: function setModel(model) {
                this.model = model;
                if (model.data) {
                    this.set('gridData', model.data);
                }
            },

            destroy: function destroy() {
                var model = this.model;
                if (model && model.destroy) {
                    model.destroy();
                }
                this._super();
            }

        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Button",
                         "mstrmojo.XtabZone",
                         "mstrmojo.DICFactory",
                         "mstrmojo.DynamicClassFactory");

    
    var MARKROW = 102,

        ROW_HEADER_MERGED = 1,

        TX_MARK = 2, 

        $C = mstrmojo.css,
        $D = mstrmojo.dom,
        $H = mstrmojo.hash,
        $CFC = mstrmojo.DynamicClassFactory.newComponent,
        CP_TITLE = 1,
        CP_COL_HEADERS = 2,
        CP_ROW_HEADERS = 4,
        COL_AXIS = 2,
        TX_ELEM_ATT_FORM = 1,
        TX_ELEM_METRIC = 2,
        MARK_ROW = 1, 
        CHANGE_DATA = 2, 
        MR_MANIPULATION_UNSET = 1,
        MR_MANIPULATION_SELECT = 2,
        DATA_DRIVEN_CONTROL = 2,
        XTAB = 1,
        getGroupIdx = function (cell) {
            if (cell) {
                return cell.tui >= 0 ? ('h_' + cell.tui + '_' + cell.fi + '_' + cell.axis) : ('m_' + cell.mix);
            }
            return '';
        };



















    
    function applyChange(c, k, vo) {
        var t = this.nm[k],
            v = vo.v,
            dv = vo.dv;

        c.rv = v;
        c.v = dv;
        c.mdf = 1;
        
        
        if (c._src) {
            c._src.rv = v;
            c._src.v = dv;
            c._src.mdf = 1;
        }

        
        var dicWidget = this.dicGroupMap[getGroupIdx(c)].widgetsMap[c._ei];

        
        if (!dicWidget.showByDefault) {
            if (dicWidget.hasPreview) {
                dicWidget.renderPreview();
            } else {
                
                if ($D.isIE7 && mstrmojo.string.isEmpty(v)) {
                    v = ' ';
                }
                t[t.innerText !== undefined ? 'innerText' : 'textContent'] = v;
            }
        }
        return t;
    }

    
    function onTotalRow(cp, o, rs) {
        if (rs[o] === 0) {
            return true;
        }

        if (cp && rs[o] === undefined) {
            try {
                var cells = cp.getRowCells(o),
                    c = cells && cells[0];
                if (c && c.o === o) {
                    if (c.sst) {
                        rs[o] = 0;
                    }
                    return !!c.stt;
                }

                if (c && c.o) {
                    return onTotalRow(cp, o + o - c.o, rs);
                }

                return false;
            } catch (ex) {
                return false;
            }
        } else {
            return false;
        }
    }

    
    function updateSelectedRows(marked, rs) {
        mstrmojo.array.forEach(marked, function (m) {
            rs[m.o] = 1;
        });
    }

    
    function clearMergedHeaderMarks(gd) {
        if (gd.mgh && (gd.mgh & ROW_HEADER_MERGED)) {
            this.mghMarks = {};
        }
    }
    
    
    function clearSelectedRowsForBlock(selections, block) {
          var begin = block.bb - 1, 
              end = Math.min(begin + block.bc, block.tc),
              row;
          $H.forEach(selections, function(v, idx) {
              row = Number(idx);
              if (row !== NaN && row >= begin && row < end) {
                  delete selections[idx];
              }
          });
    }

    
    function markDirtyRows(c, rowIdx) {
        var rs = this.editing ? 1 : (c.rs || 1),
            i;

        for (i = 0; i < rs; i++) {
            this.dirtyRows[rowIdx + i] = 1;
        }
    }

    
    function isDataDrivenDIC(di) {
    	return di && parseInt(di.ipt, 10) === DATA_DRIVEN_CONTROL; 
    }

    
    
    function getRowIndex(cell) {
        var _BR = this.zones._BR,
            _BL = this.zones._BL;
        
        
        if(!_BL) {
            return _BR.getRowIdxByCell(cell);
        } else {
            
            if(_BR.posMap && _BR.posMap[cell._ei]) {
                return _BR.getRowIdxByCell(cell);
            
            } else {
                return _BL.getRowIdxByCell(cell);
            }
        }
    }    
    
    mstrmojo._IsEditableGridCP = {

        _mixinName: "mstrmojo._IsEditableGridCP",

        
        initContent: function initContent(startIndexInContainer) {
            this._super(startIndexInContainer);

            
            
            
            
            
            var gd = this.gridData,
                vp = gd && gd.vp,
                i,
                j,
                fm,
                size,
                cg,
                cl,
                cws,
                rt;
            if (((this.type === CP_TITLE) || (this.type === CP_ROW_HEADERS)) && vp && vp.cols && !vp._adjusted) {
                cg = vp.cols.cg;
                cws = vp.cols.cws;
                
                if (cg && cg.cgc > 0) {
                    for (i = cg.cgc; i > 0; i--) {

                        cg[i] = $H.copy(cg[i - 1], {});
                        cl = cg[i];
                        var fms = cl.attForms;
                        if (fms) {
                            for (j = 0, size = fms.length; j < size; j++) {
                                fm = fms[j];
                                
                                fm.idx += 1;
                            }
                        }
                    }
                    
                    cg[0] = {tg: false, cc: 0, cl: 1, attForms: [{n: '', idx: 0}]};
                    
                    cg.cgc += 1;
                }
                
                if (cws) {
                    cws.splice(0, 0, {w: '60px', xc: true});
                }
                
                if (vp.dafIdx !== undefined) {
                    vp.dafIdx += 1;
                }

                rt = gd.gts.row;
                for (i = 0, size = rt.length; i < size; i++) {
                    rt[i].ci = i + 1; 
                }

                
                vp._adjusted = true;
            }

            
            this.colWidths = [{w: ''}].concat(this.colWidths);
            this.unmergedCells = [];
        },

        getUnmergedCells: function getUnmergedCells() {
            return null;
        },

        
        getRowCells: function getRowCells(ri) {
            var cells = this._super(ri),
                cell = cells[0], 
                o = (cell && cell.o) || 0,
                isTtl = (this.tp === CP_TITLE),
                ics = this.interactiveCellsArray,
                fc = {
                    css: '',
                    v: ''
                },
                umc = [],
                ncs = [],
                i,
                len;

            if (!isTtl) {
                var rows = this.base.items,
                    lb = this.lookupBase,
                    cssBase = this.gridData.css,
                    pi = cell && cell.pi, 
                    r = pi && pi.ri, 
                    c = pi && pi.ci, 
                    otr = cell.stt > 0;
                while (pi && r > -1 && c > -1) { 
                    cell = cell._p || rows[r].items[c];
                    
                    var _c = $H.copy(cell, {});
                    
                    _c._src = cell;
                    if (!_c.css) {
                        _c.css = cssBase[_c.cni].n;
                    }

                    var unit = lb[cell.tui],
                        e = unit && unit.es[cell.idx];
                    if (e) {
                        _c.v = cell.v || e.n; 
                        
                        _c._e = e;
                    }
                    _c.rs = 1;
                    if (otr) {
                        _c.at &= ~32;
                    }
                    if (o > -1) {
                        _c.o = o;
                    }
                    if (!_c.axis && this.axis) {
                        _c.axis = this.axis;
                    }
                    _c._ei = ics.push(_c) - 1;
                    umc.splice(0, 0, _c);

                    
                    pi = cell && cell.pi;
                    r = pi && pi.ri;
                    c = pi && pi.ci;
                }

                for (i = 0, len = cells.length; i < len; i++) {
                    var nc = cells[i];
                    if (nc.rs > 1) {
                        var tc = $H.copy(nc, {});
                        tc.rs = 1;
                        nc = tc;
                    }
                    ncs.push(nc);
                }

            } else {
                ncs = cells;
                if (ri > 0) {
                    return cells;
                }
            }

            if (ncs[0]) {
                fc = $H.copy(ncs[0], {});
                fc.rv = fc.v = '';
                if (this.tp === CP_TITLE) {
                    fc.n = fc.v = '';
                    fc.markAll = true;

                } else {
                    fc.n = '';
                }
                fc._ei = ics.push(fc) - 1;
                fc.at = 32;
                fc.cs = 1;
                fc.mark = true; 
                fc.mix = 'x';
                
                
                fc.css = (umc[0] && umc[0].css) || fc.css;
                delete fc.ui;
                delete fc.tui;
                delete fc.fs;
                delete fc.mdf;
            }

            return [fc].concat(umc.concat(ncs));
        }
    };    

    
    mstrmojo._IsEditableXtab =
        {
            _mixinName: "mstrmojo._IsEditableXtab",

            
            update: function update(node) {
                var marks,
                    gd = node.data;

                if (this._super) {
                    this._super(node);
                }

                this.kc = {};
                this.rs = {};
                this.rsDelta = {};

                clearMergedHeaderMarks.call(this, gd);

                
                if (gd.eg !== undefined) {
                    return;
                }

                
                marks = node.data.marked;
                if (marks) {
                    updateSelectedRows(marks, this.rs);
                }

                if (!gd.rw) {
                    var rc = gd.gvs.items.length;
                    gd.rw = {
                        row: {
                            bb: 1,
                            bc: rc,
                            tc: rc
                        },
                        col: {
                            bb: -1,
                            bc: -1,
                            tc: 0
                        }
                    };
                }
            },

            
            initCP: function initCP(gd, interactiveCellsArray, tp, base, lkpBase, ax, cp) {
                var props = {
                    gridData: gd,
                    type: tp,
                    interactiveCellsArray: interactiveCellsArray
                };

                props.base = base || props.base;
                props.lookupBase = lkpBase || props.lookupBase;
                props.axis = ax || props.axis;
                props.dataSource = this;

                if (!cp) {
                    
                    if (this.tca === TX_MARK && this.editing) {
                        if (tp === CP_TITLE) {
                            mstrmojo.EditableXtabTitlesCP = $CFC(mstrmojo.XtabTitlesCP, [mstrmojo._IsEditableGridCP], {scriptClass: "mstrmojo.EditableXtabTitlesCP", tp: CP_TITLE});
                            cp = new mstrmojo.EditableXtabTitlesCP(props);
                        } else if (tp === CP_ROW_HEADERS) {
                            mstrmojo.EditableXtabCP = $CFC(mstrmojo.XtabCP, [mstrmojo._IsEditableGridCP], {scriptClass: "mstrmojo.EditableXtabCP"});
                            cp = new mstrmojo.EditableXtabCP(props);
                        } else {
                            cp = new mstrmojo.XtabCP(props);
                        }
                    } else {
                        if (tp === CP_TITLE) {
                            cp = new mstrmojo.XtabTitlesCP(props);
                        } else {
                            cp = new mstrmojo.XtabCP(props);
                        }
                    }
                } else {
                    $H.copy(props, cp);
                }

                return cp;
            },

            
            createOnDemandCP: function createOnDemandCP(blockNum, rc, zone) {
                var cp;

                
                if (this.tca === TX_MARK && this.editing && zone === CP_ROW_HEADERS) {
                    mstrmojo.EditableXtabOnDemandCP = $CFC(mstrmojo.XtabOnDemandCP, [mstrmojo._IsEditableGridCP], {scriptClass: "mstrmojo.EditableXtabOnDemandCP"});
                    cp = new mstrmojo.EditableXtabOnDemandCP();
                } else {
                    cp =  new mstrmojo.XtabOnDemandCP();
                }

                cp.dataSource = this;
                cp.blockNum = blockNum;
                cp.rc = rc;
                return cp;
            },

            preBuildRendering: function preBuildRendering() {
                var txi = this.defn.txi;

                if (this._super) {
                    this._super();
                }

                this.txar = txi.txar;
                
                this.sci = txi.sci;
                this.tca = txi.tca;

                
                if (this.tca !== TX_MARK) {
                    this.editing = false;
                } else {
                    if (mstrApp.isMobile) {
                    
                        this.editing = this.alwaysEditing = true;
                    }
                }
                
                this.nm = {};
                this.ko = {};

                this.dirtyRows = {}; 
                this.requiredCellsMap = {}; 

                this.dicGroupMap = {};
                this.lastIndex = 0;
                this.lastHeaderIndex = 0;
                this.columnNames = {};
            },

            postBuildRendering: function postBuildRendering() {
                if (this._super) {
                    this._super();
                }

                
                if (this.tca === TX_MARK && this.gridData.eg === undefined) {
                    var t = Math.max(-16, -this.domNode.offsetTop), 
                        me = this;

                    if (!this.alwaysEditing) {
                        var dn = mstrmojo.Button.newIconButton(mstrmojo.desc(8324, 'Mark rows'), 'mstrmojo-EditButton', function () {
                                if (!me.recalculating) {
                                    me.editing = !me.editing;
                                    me.refresh();
                                }
                            }),
                            btn = new mstrmojo.Button(mstrmojo.hash.copy({
                                cssText: 'top:' + t + 'px;'
                            }, dn));

                        btn.render();
                        this.domNode.appendChild(btn.domNode);


                        if (this.editing) {
                            this.domNode.style.zIndex = 1000;
                            
                            $C.addClass(btn.domNode, 'close');
                        } else {
                            $C.removeClass(btn.domNode, 'close');
                        }
                    }
                }
            },

            dataDownloadErr: function dataDownloadErr() {
                if (this.txar && this.recalculating) {
                    var z = this.zones;
                    if (z._BL) {
                        z._BL.isDownloading = false;
                    }
                    z._BR.isDownloading = false;

                    this.rhsCP.initContent();
                    this.valuesCP.initContent();

                    
                    $C.removeClass(this.maskNode, 'wait');
                    this.recalculating = false;
                }
            },

            
            dataDownloaded: function dataDownloaded(node, memo) {
                var gd = node.data;
                if (this.txar) {
                    var idx = memo.blockNum, zn = this.zones, ica;

                    if (this.recalculating) {
                        memo.recalculating = true;
                        this.interactiveCellsArray = [];
                        this.requiredCellsMap = {};
                        this.dirtyRows = {};
                        this.lastIndex = 0;
                        this.lastHeaderIndex = 0;
                        this.kc = {};
                        this.nm = {};
                        this.updatedCellsMap = {};
                        this.recalculating = false;
                        this.destroyDICs();
                    } else {
                        memo.recalculating = false;
                    }

                    
                    if (idx === 0) {
                        this.gridData = gd;
                    }

                    
                    
                    if (gd.eg) {
                        this.refresh();
                        return;
                    }

                    ica = this.interactiveCellsArray;
                    this.initCP(gd, ica, CP_TITLE, null, null, null, this.titlesCP);
                    this.initCP(gd, ica, CP_COL_HEADERS, gd.ghs.chs, gd.gts.col, COL_AXIS, this.chsCP);
                    this.titlesCP.initContent();
                    this.chsCP.initContent();

                    
                    
                    
                    if (ica && ica.length === 0) {
                        if (zn._TR) {
                            zn._TR.refresh();
                        }
                        if (zn._TL) {
                            zn._TL.refresh();
                        }
                    }
                }

                if (this._super) {
                    this._super(node, memo);
                }

                
                clearMergedHeaderMarks.call(this, gd);

                
                clearSelectedRowsForBlock(this.rs, gd.rw.row); 
                
                if (gd.marked) {
                    updateSelectedRows(gd.marked, this.rs);
                    this.rsDelta = {};
                }
            },

            closeDownloadStatus: function closeDownloadStatus() {
                if (this._super) {
                    this._super();
                }
                mstrmojo.css.removeClass(this._STATUS, 'recalculate');
            },


            
            kc: null,

            
            ko: null,

            
            nm: null,

            
            rs: null,

            
            dicGroupMap: null,

            
            lastIndex: 0,

            
            lastHeaderIndex: 0,

            
            columnNames: null,

            
            getDataInputInfo: function getDataInputInfo(cell, widx) {
                var k = cell._ei, o,
                    defn = this.node.defn,
                    data = this.gridData;

                if (cell.mark) {
                    o = cell.o;
                    if (cell.stt) {
                        this.rs[o] = 0; 
                        return;
                    }
                    this.ko[o] = k;
                    cell.rv = cell.v = this.rs[o] || -1;
                    this.kc[k] = {rowop: true};
                    return {
                        key: k,
                        t: MARKROW,
                        vls: [{
                            'v': -1
                        }, {
                            'v': 1
                        }],
                        wm: 1,
                        w: 22,
                        hm: 1,
                        h: 16,
                        dm: 1
                    };
                }

                var titleInfo = this.model.getCellTitleInfo(cell, this.dataBlocks[cell._gd]),
                    title = titleInfo && titleInfo.title,
                    es = title && title.es,
                    mti = (cell.mti !== undefined) ? cell.mti : cell.mix,
                    isMtx = (cell.mix !== undefined),
                    dic = defn.txi.dic,
                    di;

                di = !isMtx ? dic.att && title && dic.att[title.id] && dic.att[title.id][title.fs[cell.fi].id] : dic.mtx && dic.mtx[es[mti].oid];

                if (!di) {
                    return null;
                }

                
                if (this.columnNames[widx] === undefined) {
                	this.columnNames[widx] = !isMtx ? title.n : es[mti].n;
                }

                
                if (isDataDrivenDIC(di)) {
                	di.vls = (data.dcv && data.dcv[di.k]) || [];
                }

                
                if (k >= 0 && !this.kc[k]) {
                    var isMv = !cell.axis,
                        t = {
                            isMv: isMv
                        };

                    if (isMv) {
                        var pi = cell.pi,
                            tp = pi && pi.top;
                        t.co = (tp && tp.ci) || 0;
                        t.metric_id = es[mti].oid;
                        cell.o = t.o = (cell._lp && cell._lp.o) || 0;
                        t.tp = TX_ELEM_METRIC;
                    } else {
                        t.ax = cell.axis;
                        t.atid = title.id;
                        t.form_id = title.fs[cell.fi].id;
                        t.o = cell.o;
                        t.tp = TX_ELEM_ATT_FORM;
                        t.fi = cell.fi;
                        t.ui = cell.ui;
                        t.tui = cell.tui;
                        t.rs = cell.rs;
                    }

                    t.dt = di.dt;
                    if (isDataDrivenDIC(di)) {
                    	t.vls = di.vls;
                    	t.k = di.k;
                    }

                    this.kc[k] = t;
                }

                di.key = k;

                if (di.dm) {
                    di.dm = parseInt(di.dm, 10);
                }

                return di;

            },

            isEditableHeader: function isEditableHeader(cell) {
                var defn = this.node.defn,
                    dic = defn.txi.dic;

                if (cell.sst || !dic) {
                    return false;
                }

                if (cell.id !== undefined && dic.att) { 
                    return !!(dic.att[cell.id] && (cell.fix ? dic.att[cell.id][cell.fid] : dic.att[cell.id]));
                }

                if (cell.tui !== undefined && cell.mix !== undefined && dic.mtx) { 
                    return !!(dic.mtx[cell._e.oid]);
                }

                return false;
            },

            
            dataChanged: function dataChanged(k, r, v, d) {
                if (!this.recalculating) {
                    if (d) {
                        this.nm[k] = d;
                    }

                    if (this._super) {
                        this._super(k, r, v, d);
                    }
                }
            },

            
            updateValue: function updateValue(k, vo) {
                if (this._super) {
                    this._super(k, vo);
                }

                var c = this.interactiveCellsArray[k],
                    v = vo.v,
                    t,
                    rowIdx = getRowIndex.call(this, c);

                this.lmr = null; 

                
                
                
                





                t = applyChange.call(this, c, k, vo);
                if (c.r !== v) {
                    if (!c.mark) {
                        
                        c.mdf = 1;

                        
                        mstrmojo.css.removeClass(t, 'required');

                        markDirtyRows.apply(this, [c, rowIdx]);

                        
                        this.flagDirtyUnit(t);
                    }
                } else {
                    this.clearDirtyUnit(t);
                }

                
                if (this.tca === TX_MARK) {
                    
                    if (c.mark) { 
                        var ordinal = c.markAll ? -1 : c.o,
                            rsDelta = this.rsDelta;

                        this.rs[ordinal] = v;

                        
                        
                        this.lmr = {r: ordinal, v: v}; 

                        if (c.markAll) {
                            
                            rsDelta = this.rsDelta = {};
                            rsDelta[ordinal] = v;
                            this.mghMarks = {};
                        } else if (rsDelta[ordinal] && rsDelta[ordinal] !== v) {
                            
                            
                            delete rsDelta[ordinal];
                        } else if (rsDelta[-1] !== v) {
                            
                            rsDelta[ordinal] = v;
                        }
                    } else { 
                        if (this.rs[c.o] !== 0) {
                            this.rs[c.o] = 1;
                        }

                        
                        if (!this.editing && this.mghMarks && (c.mix === undefined)) {
                            
                            
                            if(!this.mghMarks[c.o] || this.mghMarks[c.o].rs < c.rs) {
                                
                                this.mghMarks[c.o] = {o: c.o, rs: c.rs, k: k};
                            }
                            
                            
                            var sro,
                                sco,
                                me = this;
                            $H.forEach(this.rsDelta, function (mv, ro) {
                                sro = parseInt(ro, 10);
                                sco = parseInt(c.o, 10);
                                if (sro >= sco && sro <= (sco + c.rs)) {
                                    delete me.rsDelta[ro];
                                }
                            });
                        } else {
                            
                            this.rsDelta[c.o] = 1;
                        }

                        
                        
                        if (!this.editing && c.rs > 1) {
                            var o = c.o + 1;
                            while (o - c.o < c.rs) {
                                if (!onTotalRow(this.rhsCP, o, this.rs)) {
                                    this.rs[o] = 1;
                                }
                                o += 1;
                            }
                        }
                        
                        if (this.editing) {
                            var w = this.dicGroupMap.m_x.widgetsMap[this.ko[c.o]];
                            if (w) {
                                w.set('checked', true);
                            }
                        }
                    }
                }

                
                
                if (this.txar && !c.mark) {
                    return true;
                }

                return false;
            },

            autoRefresh: function autoRefresh() {
                
                var z = this.zones;
                if (z._BL) {
                    z._BL.invalidAllPages();
                }
                z._BR.invalidAllPages();
                
                this.rhsCP.invalid();
                this.valuesCP.invalid();

                
                $C.addClass(this._STATUS, 'recalculate');

                
                z._BR.onscroll(true); 
                this.recalculating = true;
            },

            
            getKeyContext: function getKeyContext(key) {
                return this.kc[key];
            },

            
            getUpdateObject: function getUpdateObject() {
                var cs = [], j, udvs, udv, lmr = this.lmr, v, ddicObj = {};

                if (lmr) { 
                    
                    this.lmr = null;
                    return {
                        manipulation: MARK_ROW,
                        actionType: (lmr.v === -1) ? MR_MANIPULATION_UNSET : MR_MANIPULATION_SELECT,
                        rowOrdinal: lmr.r, 
                        nodeKey: this.k,
                        sliceId: this.sid
                    };
                }

                
                udvs = this.getUpdatedValues();

                
                for (j = 0; j < (udvs && udvs.length); j++) {
                    if (!udvs[j].rowop) {
                        udv = udvs[j];
                        break;
                    }
                }

                if (udv) {
                    
                    v = mstrmojo.string.encodeXMLAttribute(String(udv.v));

                    if (udv.k !== undefined && udv.vls) {
                        ddicObj = {
                            controlKey: udv.k,
                            elementId: udv.vls[mstrmojo.array.find(udv.vls, 'v', udv.v)].eid
                        };
                    }

                    if (!!udv.isMv) {
                        cs.push($H.copy(ddicObj, {
                            rowOrdinal: udv.o,
                            colOrdinal: udv.co,
                            newValue: v,
                            dataType: udv.dt
                        }));
                    } else {
                        cs.push($H.copy(ddicObj, {
                            rowOrdinal: udv.o,
                            attId: udv.atid,
                            formId: udv.form_id,
                            unitIndex: udv.tui || udv.ui, 
                            newValue: v,
                            dataType: udv.dt
                        }));
                    }
                }

                return {
                    manipulation: CHANGE_DATA,
                    nodeKey: this.k,
                    sliceId: this.sid,
                    cells: cs,
                    
                    autoRefresh: this.txar
                };
            },

            
            getUpdates: function getUpdates() {
                var w = this, j, udv,
                    udvs = w.getUpdatedValues(),
                    srs = this.rsDelta,
                    eg = [], gd = [], udt = false, k = '';


                eg.push('<gr rw_tree_type="' + w.treeType + '" rw_node_key="' + w.k + '" slice_id="' + w.sid + '">');
                for (j in udvs) {
                    if (udvs.hasOwnProperty(j)) {
                        udv = udvs[j];
                        if (!udv.rowop) {
                            
                            var v = mstrmojo.string.encodeXMLAttribute(String(udv.v));

                            
                            if (udv.k && udv.vls) {
                                var m = mstrmojo.array.find(udv.vls, 'v', udv.v);
                                k = 'rw_control_key="' + udv.k + '" element_id="' + udv.vls[m].eid + '" ';
                            }

                            if (!!udv.isMv) {
                                gd.push('<cli cordinal="' + udv.co + '" metric_id="' + udv.metric_id + '"><updt types="' + udv.tp + '" rordinal="' + udv.o + '" ' + k + 'value="' + v + '" dt="' + udv.dt + '"/></cli>');
                            } else {
                                
                                
                                
                                gd.push('<cli ax="' + udv.ax + '" attribute_id="' + udv.atid + '" form_id="' + udv.form_id + '"><updt types="' + udv.tp + '" ordinal="' + udv.o + '" ' + k + 'value="' + v + '" dt="' + udv.dt + '"' + (this.mghMarks ? ' flags="1"' : '') + '/></cli>');
                            }
                            udt = true;
                        }
                    }
                }

                
                if (!$H.isEmpty(this.mghMarks)) {
                    var me = this;
                    $H.forEach(this.mghMarks, function (v, ro) {
                        k = me.getKeyContext(v.k);
                        gd.push('<mark rordinal="' + ro + '" types="4" flags="1" attribute_id="' + k.atid + '" form_id="' + k.form_id + '"/>');
                    });
                }

                
                if (srs && !$H.isEmpty(srs)) {
                    udt = true;
                    $H.forEach(srs, function (v, o) {
                        if (v === 1) {
                            gd.push('<mark rordinal="' + o + '" types="4"/>');
                        } else {
                            gd.push('<mark rordinal="' + o + '" types="5"/>');
                        }
                    });
                }

                eg.push(gd.join(''));
                eg.push('</gr>');

                
                if (!udt) {
                    eg = [];
                }
                return eg.join('');
            },

            
            flagDirtyUnit: function flgDtUnt(t) {
                if (t && this.sci) {
                    if (this._super) {
                        this._super(t);
                        return;
                    }

                    var v = document.createElement('div'),
                        df,
                        tf = false,
                        trans3d = $C.getStyleValue(this.domNode, $D.CSS3_TRANSFORM),
                        isTDRelative;
                    v.className = "flag-container";
                    v.innerHTML = '<div class="dirty-cell"/>';
                    if (t.insertBefore) {
                        t.insertBefore(v, t.firstChild);
                        isTDRelative = (v.offsetParent === t);
                    }
                    tf = mstrmojo.string.isEmpty(trans3d) || trans3d === "none";
                    
                    df = v.firstChild;
                    df.style.top = ((!tf || isTDRelative) ? (-v.offsetTop) : (t.offsetTop - v.offsetTop)) + 'px';
                    df.style.left = (t.clientWidth + ((!tf || isTDRelative) ? (-v.offsetLeft) : (t.offsetLeft - v.offsetLeft)) - 8) + 'px';
                }
            },

            
            clearDirtyUnit: function clrDtUnt(t) {
                if (this._super) {
                    this._super(t);
                    return;
                }

                var c = t.firstChild;
                if (t) {
                    if (c && c.className && c.className === 'flag-container') {
                        t.removeChild(c);
                    }
                }
            },

            onvisibleChange: function onvisChg() {
                if (this.visible === true) {
                    var me = this;

                    
                    setTimeout(function () {
                        me.configureActions();
                    }, 10);
                }
            },

            
            configureActions: function cfgAct() {
                if (this.visible === false) {
                    return;
                }

                var zone = '_BR',
                    grid = this.zones[zone],
                    rowLocked = !!this.zones['_BL'],
                    posMap = grid.posMap,
                    thPosMap = grid.thPosMap,
                    ics = this.interactiveCellsArray,
                    dicGroupMap = this.dicGroupMap,
                    dirtyNodes = [],
                    ei,
                    len,
                    i,
                    k,
                    cell,
                    pos,
                    node,
                    widx,
                    rowIdx,
                    currentRow,
                    config,
                    dicGroup,
                    me = this,
                    flagDirtyNodes = function (dns) {
                        var jLen = dns.length,
                            j;
                        for (j = 0; j < jLen; j++) {
                            me.flagDirtyUnit(dns[j]);
                        }
                    };

                for (ei = this.lastIndex, len = ics.length; ics[ei] && ei < len; ei++) {
                    cell = ics[ei];
                    pos = posMap && posMap[ei];
                    
                    
                    if(!pos && rowLocked) {
                        zone = (zone === '_BR') ? '_BL' : '_BR'; 
                        grid = this.zones[zone]; 
                        posMap = grid && grid.posMap; 
                        thPosMap = grid && grid.thPosMap; 
                        pos = posMap && posMap[ei];
                    }

                    if (pos && ((cell.at & 32) > 0)) {
                        node = grid.getNodeByPosition(pos);
                        
                        
                        cell.at = 32;

                        if (cell.rv == null) {
                            cell.rv = isNaN(cell.mix) ? cell._e.n : cell.v;
                        }

                        widx = getGroupIdx(cell);
                        config = this.getDataInputInfo(cell, widx);
                        dicGroup = this.dicGroupMap[widx];

                        if (config) {
                            if (!dicGroup) {
                                dicGroup = dicGroupMap[widx] = mstrmojo.DICFactory.createDICGroup({
                                    gk: widx,
                                    dic: config,
                                    owner: this,
                                    openerType: XTAB
                                });
                            }

                            
                            
                            var dicProps = {
                                    value: (cell.rv === undefined) ? (cell.v || cell.n) : (typeof cell.rv === 'string' ? mstrmojo.string.decodeHtmlString(cell.rv) : cell.rv),
                                    dv: cell.v || cell.n,
                                    ts: cell.ts,
                                    markAll: cell.markAll,
                                    openerNode: node,
                                    k: cell._ei,
                                    ownerCell: cell,
                                    popupTitle: this.columnNames[widx]
                                },
                                stackedRh = grid.cp.stackedRh;

                            
                            if (stackedRh && cell.singleStack && (mstrmojo.DICConfig.showDICByDefault(config, 1) || mstrmojo.DICConfig.hasDICPreview(config, 1))) {
                                var tdHeight = node.offsetHeight;

                                
                                node.className += ' igDIC';
                                node.style.cssText = 'height:' + tdHeight + 'px;';

                                mstrmojo.hash.copy({
                                    inlineExtraCssText: 'position:absolute;' + 'top:' +  parseInt(stackedRh / 2 - tdHeight / 2 + 1, 10) + 'px;'

                                }, dicProps);
                            }

                            dicGroup.addDIC(cell._ei, dicProps);

                            rowIdx = pos.page * grid.rowsPerPage + pos.row;

                            if (config.req) {
                                
                                for (k = 0; k < (this.editing ? 1 : (cell.rs || 1)); k++) {
                                    currentRow = this.requiredCellsMap[rowIdx + k];
                                    if (!currentRow) {
                                        this.requiredCellsMap[rowIdx + k] = currentRow = [];
                                    }
                                    currentRow.push(cell);
                                }
                            }

                            
                            if (cell.mdf) {
                                dirtyNodes.push(node);

                                markDirtyRows.apply(this, [cell, rowIdx]);
                            }
                        }
                    }
                }
                this.lastIndex = ei;

                
                for (widx in dicGroupMap) {
                    dicGroupMap[widx].render();
                }

                
                
                
                setTimeout(function () {
                    flagDirtyNodes(dirtyNodes);
                }, 25);

                
                for (i = this.lastHeaderIndex, len = thPosMap.length; i < len; i++) {
                    pos = thPosMap[i];
                    node = grid.getNodeByPosition(pos);
                    cell = pos.obj;

                    if (this.isEditableHeader(cell)) {
                        node.innerHTML = '<div class="editable-column">' + node.innerHTML + '</div>';
                    }
                }
                this.lastHeaderIndex = i;

                this.registerTxWidget();

                if (this._super) {
                    this._super();
                }
            },

            showPopupDIC: function showPopupDIC(target) {
                var tn = target && $D.findAncestorByAttr(target, 'ei', true, this.viewport);

                if (tn) {
                    var td = tn.node,
                        cell = this.getCellForNode(td),
                        group = this.dicGroupMap[getGroupIdx(cell)];

                    if (group) {
                        group.showPopupDIC(cell._ei);
                        return true;
                    }
                }

                return false;
            },

            
            onclick: function onclick(e) {
                var target = mstrmojo.dom.eventTarget(window, e.e);

                if (!this.showPopupDIC(target) && this._super) {
                    this._super(e);
                }
            },

            unrender: function unrender() {
                if (this._super) {
                    this._super();
                }
                this.destroyDICs();
            },

            destroyDICs: function destroyDICs() {
                var dicGroupMap = this.dicGroupMap;
                this.dicGroupMap = {};

                
                setTimeout(function () {
                    var i;
                    for (i in dicGroupMap) {
                        dicGroupMap[i].destroy();
                    }
                }, 10);
            },

            
            checkRequiredObjects: function checkRequiredObjects() {
                if (this.hasRendered && !(this.isInteractiveGrid && this.isInteractiveGrid()) && !this.gridData.eg) {
                    var grid = this.zones._BR,
                        posMap = grid.posMap,
                        row,
                        me = this,
                        rowSelections = this.rs,
                        validFlag = true,
                        
                        
                        
                        processRow = function (r, hilite) {
                            var valid = true,
                                cells = me.requiredCellsMap[r],
                                len = (cells && cells.length) || 0,
                                i;

                            for (i = 0; i < len; i++) {
                                
                                if (!cells[i].mdf) {
                                    
                                    $C.toggleClass(grid.getNodeByPosition(posMap[cells[i]._ei]), 'required', hilite);
                                    
                                    valid = !hilite;
                                }
                            }

                            return valid;
                        };

                    
                    if (this.tca === TX_MARK) {
                        
                        for (row in rowSelections) {
                            validFlag = processRow(parseInt(row, 10) + 1, rowSelections[row] > 0) && validFlag;
                        }
                    } else {
                        
                        for (row in this.dirtyRows) {
                            validFlag = processRow(row, true) && validFlag;
                        }
                    }

                    return validFlag;
                }
                return true;
            },

            
            editNext: function editNext(k) {
                
                if (this.recalculating) {
                    return false;
                }

                var ics = this.interactiveCellsArray,
                    len = ics.length,
                    i = k + 1,
                    nextCell,
                    dicWidget;

                do {
                    
                    if (i >= len) {
                        i %= len;
                    }

                    
                    if (i === k) {
                        return false;
                    }

                    nextCell = ics[i];
                    var group = this.dicGroupMap[getGroupIdx(nextCell)];

                    
                    if (group) {
                        
                        if (mstrmojo.DICConfig.isKeyNavigable(group.dic)) {

                            
                            if (!group.showByDefault) {
                                group.showPopupDIC(i);
                            } else {
                                dicWidget = group.widgetsMap[i];

                                
                                dicWidget.focus();
                            }

                            return true;
                        }
                    }
                    i++;
                } while (true);
                
            }
        };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.ResultSetView");

    
    mstrmojo.android.large.ui.ResultSetView = mstrmojo.declare(

        mstrmojo.android.ui.ResultSetView,

        null,

        {
            scriptClass: "mstrmojo.android.large.ui.ResultSetView",

            getMaskNode: function getMaskNode() {
                
                var view = this.children[0];
                if (view) {
                    
                    return (view.getMaskNode) ? view.getMaskNode() : view.domNode.cloneNode(true);
                }

                return null;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DateTimePicker",
                         "mstrmojo.ui.MobileStepper",
                         "mstrmojo._TouchGestures");
    
    var dateTimeScriptClass = 'mstrmojo.ui.MobileStepper';
        
    
    mstrmojo.ui.MobileDateTimePicker = mstrmojo.declare(
        
        mstrmojo.DateTimePicker,
            
        
        [mstrmojo._TouchGestures],
            
        {

            scriptClass: "mstrmojo.ui.MobileDateTimePicker",
            
            stepperClass: 'mstrmojo.ui.MobileStepper',
            
            
            onclick: function(evt) {
                this.touchTap(evt.e);
            },
            
            
            touchTap: function(touch) {
                if (touch.target === this.meridiemNode) {
                    
                    this.set('meridiem', !this.meridiem);
                    this.updateTime();
                }
            },
            
            touchBegin: function(touch){
                if (touch.target == this.meridiemNode){
                    mstrmojo.css.addClass(touch.target, 'glow');
                }
            },
            
            touchEnd: function(touch){
                if (touch.target == this.meridiemNode){
                    mstrmojo.css.removeClass(touch.target, 'glow');
                }
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo._CanSupportOfflineTransactions",
                         "mstrmojo._CanMakeServerProxyRequests",
                         "mstrmojo.MobileConfiguration",
                         "mstrmojo.OfflineTransactionModel",
                         "mstrmojo.dom",
                         "mstrmojo.hash",
                         "mstrmojo.android.EnumOrientationTypes");

    mstrmojo.requiresDescs(6828, 9419);

    var $DOM = mstrmojo.dom,
        $HASH = mstrmojo.hash;

    
    var dialogs = [],

    
        lisStacks = {},
        menus = {},
        cachedMicroTablet;

     
    function handleError(res, app, callback) {
        
        if (!res || res.handledError) {
            
            return;
        }

        var msg = [],
            map = {
                title: '',
                message: mstrmojo.desc(6828) + " ",
                sourceURL: 'Source URL: ',
                fileName: 'File: ',
                lineNumber: 'Line: ',
                line: 'Line: '
            };

        
        $HASH.forEach(map, function (v, n) {
            if (res[n] !== undefined) {
                msg.push(v + res[n]);

                if (n === 'title') {
                    msg.push('');
                }
            }
        });

        
        if (res.getResponseHeader) {
            
            msg.push('XHR: ' + res.getResponseHeader('X-MSTR-TaskFailureMsg'));
        }

        
        msg = msg.join('\n');

        
        if (app) {
            
            app.hideMessage();
        }

        
        if (msg.length) {
            
            mstrmojo.alert(msg, callback);

            
            res.handledError = true;

            
            mstrmojo.dbg(res.stack || msg);
        }
    }

    function onWindowError(errMsg, fName, lineNum) {

        

        
        if ( errMsg instanceof String ) {
            handleError({
                message: errMsg,
                fileName: fName,
                lineNumber: lineNum
            });
        }
    }



    
    var $APP = mstrmojo.android.AndroidApp = mstrmojo.declare(
        mstrmojo.Obj,

        [ mstrmojo._CanMakeServerProxyRequests, mstrmojo._CanSupportOfflineTransactions ],

        
        {
            scriptClass: "mstrmojo.android.AndroidApp",

            
            serverProxy: null,

            
            isMobile: true,

            
            handledCompatibilityError: false,

            init: function init(props) {
                this._super(props);

                var fn = window.onerror;
                window.onerror = fn ? mstrmojo.func.composite([ onWindowError, fn ]) : onWindowError;

                
                this.handleError = handleError;
            },

            
            start: function start() {
                
                this.started = true;

                
                var app = mstrMobileApp;
                app.setTaskServletName(mstrConfig.taskURL);

                var cfg = this.getConfiguration(),
                    diagnosticMode = cfg.getDiagnosticMode();

                
                app.setDiagnosticMode(diagnosticMode);

                
                this.diagnosticMode = diagnosticMode;
                this.useBinaryFormat = cfg.getBinaryMode();

                
                mstrmojo.DPIManager.setDPI();

                
                mstrApp.oflnTxModel = new mstrmojo.OfflineTransactionModel();

                
                var view = this.rootView = this.viewFactory.newView('Root', {
                    id: 'rootView',
                    placeholder: this.placeholder
                });

                
                var controller = this.rootController = this.controllerFactory.newController('Root', {
                    id: "rootController",
                    rootView: view
                });

                
                view.controllerId = controller.id;

                
                view.render();

                
                controller.start();


                
                window.setTimeout(function () {
                    mstrMobileApp.getTitleBarHeight(mstrApp.rootView.getTitleHeight());
                }, 0);

            },

            restart: function restart() {
                var rootController = this.rootController;
                if (rootController) {
                    rootController.restart();
                } else {
                    this.start();
                }
            },

            
            onMobileDevice: function onMobileDevice() {
                return mstrConfig.onMobileDevice;
            },

            
            isTouchApp: function isTouchApp() {
                
                return ($DOM.isIPad || $DOM.isAndroid || mstrApp.onMobileDevice()) && !$DOM.isWinPhone;
            },

            
            isLandscape: function isLandscape() {
                return (mstrMobileApp.getOrientation() === mstrmojo.android.EnumOrientationTypes.LANDSCAPE);
            },

            
            getConfiguration: function getConfiguration() {
                if (!this._cfg) {
                    this._cfg = new mstrmojo.MobileConfiguration();
                }

                return this._cfg;
            },

            
            isTablet: function isTablet() {
                return mstrMobileApp.isTablet();
            },

            isMicroTablet: function isMicroTablet() {
                
                if (cachedMicroTablet === undefined) {
                    
                    cachedMicroTablet = false;

                    
                    if (this.isTablet()) {
                        
                        var dimensions = this.getScreenDimensions(),
                            limit = 700; 

                        cachedMicroTablet = (dimensions.h < limit || dimensions.w < limit);
                    }
                }

                return cachedMicroTablet;
            },

            
            goBack: function goBack() {
                
                if (this.cancelPending(true)) {
                    return true;
                }

                
                var menuClosed = false;
                $HASH.forEach(menus, function (v, id) {
                    
                    var menu = mstrmojo.all[id];
                    if (menu) {
                        
                        menu.set('visible', false);

                        
                        menuClosed = true;
                    }
                });

                
                menus = {};

                
                if (menuClosed) {
                    
                    return true;
                }

                
                var len = dialogs.length;
                if (len) {
                    
                    var openDialog = dialogs[len - 1];
                    if (openDialog.goBack) {
                        
                        if (openDialog.goBack()) {
                            
                            return true;
                        }
                    }

                    
                    if (this.closeDialog()) {
                        return true;
                    }
                }

                
                
                return (this.rootController && this.rootController.goBack()) || mstrMobileApp.goBack();
            },

            
            doSearch: function doSearch() {








            },

            
            menuShown: function menuShown() {









            },

            
            registerListener: function (name, target, fn) {
                var s = lisStacks[name] || [];

                s.push({
                    t: target,
                    f: fn
                });

                lisStacks[name] = s;
            },
            
            unregisterListener: function (name, target) {
                var s = lisStacks[name],
                    l = s && s.pop();
                if (!l || l.t !== target) {
                    window.alert("Unregister Search listener out of order.");
                    if (s && l) {
                        s.push(l);
                    }
                }
            },

            getListener: function (name, target) {
                var s = lisStacks[name],
                    l = s && ((s.length) ? s[s.length - 1] : null);

                return ((l && l.t === target) ? l : null);
            },

            
            cancelPending: function cancelPending(dontCloseDialogs) {
                
                this.hideMessage();

                
                var serverProxy = this.serverProxy;
                if (serverProxy) {
                    
                    if (serverProxy.cancelRequests()) {
                        
                        return true;
                    }
                }

                return dontCloseDialogs ? false : this.closeDialog(); 
            },

            
            onerror: function onerror(res, callback) {
                handleError(res, this, callback);
            },

            
            showMessage: function showMessage(text) {
                if (this.rootView) {
                    this.rootView.showMessage(text);
                }
            },

            showHTMLProgress: function showHTMLProgress(text) {
                if (this.rootView) {
                    this.rootView.showHTMLProgress(text);
                }
            },

            
            hideMessage: function hideMessage() {
                if (this.rootView) {
                    this.rootView.hideMessage();
                }
            },

            hideHTMLProgress: function hideHTMLProgress() {
                if (this.rootView) {
                    this.rootView.hideHTMLProgress();
                }
            },

            showToastNotification: function showToastNotification(msg, duration) {
                mstrMobileApp.toast(msg, duration);
            },

            displayHelp: function displayHelp() {
                
                var err = mstrMobileApp.displayHelp();

                
                if (err) {
                    
                    mstrApp.onerror({
                        message: err
                    });
                }
            },

            isDialogUp: function isDialogUp() {
                return (dialogs.length > 0);
            },

            
            showDialog: function showDialog(dialogConfig, viewName) {
                
                mstrMobileApp.showPopupDialog();


                
                dialogConfig.scriptClass = dialogConfig.scriptClass || 'mstrmojo.android.Dialog';

                var cfg = mstrmojo.func.wrapMethods(dialogConfig, {
                    
                    onClose: function () {
                        
                        mstrMobileApp.closePopupDialog();
                        dialogs.pop();
                    }
                });

                
                var d = viewName ? this.viewFactory.newView(viewName, cfg) : mstrmojo.insert(cfg);

                
                dialogs.push(d);

                
                d.render();

                
                window.setTimeout(function () {
                    
                    mstrMobileApp.forceRepaint();
                }, 0);
                return d;
            },

            
            showPopup: function showPopup(popupConfig, anchor) {
                
                popupConfig.scriptClass = popupConfig.scriptClass || 'mstrmojo.android.Popup';

                
                if (anchor) {
                    
                    popupConfig.anchor = anchor;
                }

                
                return this.showDialog(popupConfig);
            },

            
            closeDialog: function closeDialog() {
                if (dialogs.length) {
                    dialogs[dialogs.length - 1].close();
                    return true;
                }
                return false;
            },

            
            closeAllDialogs: function closeAllDialogs() {
                
                var cDialogs = dialogs.slice(0),
                    dialog = cDialogs.pop();

                
                while (dialog) {
                    
                    dialog.close();

                    
                    dialog = cDialogs.pop();
                }

                
                dialogs = [];
            },

            
            setMenuStatus: function setMenuStatus(menuId, isOpen) {
                
                if (isOpen) {
                    
                    menus[menuId] = true;
                } else {
                    
                    delete menus[menuId];
                }
            },

            setCurrentProjectId: function setCurrentProjectId(id) {
                this._currentProjId = id;
            },

            getCurrentProjectId: function getCurrentProjectId() {
                return this._currentProjId;
            },

            getSessionState: function getSessionState(projectId) {
                return this.serverProxy.getSession(projectId || this._currentProjId);
            },

            getContentDimensions: function getContentDimensions(supportsFullScreen) {
                return this.rootView.getContentDimensions(supportsFullScreen);
            },

            getContentPosition: function getContentPosition() {
                var contentDimensions = this.getContentDimensions();
                return {
                    x: 0,
                    y: this.rootView.getTitleHeight(),
                    w: contentDimensions.w,
                    h: contentDimensions.h
                };
            },

            getScreenDimensions: function getScreenDimensions() {
                
                
                var deviceDimensions = String(mstrMobileApp.getScreenDimensions()).split('|');
                return {
                    h: parseInt(deviceDimensions[0], 10),
                    w: parseInt(deviceDimensions[1], 10)
                };
            },

            getResSetStore: function getResSetStore() {
                return mstrMobileApp.getResSetStore(this.getCurrentProjectId());
            },

            getResSetStoreMgr: function getResSetStoreMgr() {
                return mstrMobileApp.getResSetStoreMgr();
            },

            removeProjectCaches: function removeProjectCaches(pid) {
                
                
                if (this.getConfiguration().getCacheEnabled()) {
                    this.getResSetStoreMgr().removeProjectCaches(pid);
                }

            },

            getLocaleInfo: function getLocaleInfo(projectId) {
                projectId = projectId || this._currentProjId;
                return this.serverProxy.getLocaleInfo(projectId);
            },

            onConnectivityChanged: function onConnectivityChanged(onlineFlag) {
                var publisher = mstrmojo.publisher;
                publisher.publish(publisher.NO_SRC, publisher.CONNECTIVITY_CHANGED_EVENT, onlineFlag);

                
                if (onlineFlag) {
                    this.submitOfflineTransaction();
                }

                
                this.rootController.generateActionToolbar();
            },

            
            
            onReconcileEnd: function onReconcileEnd() {
                var publisher = mstrmojo.publisher;
                publisher.publish(publisher.NO_SRC, publisher.RECONCILE_END_EVENT, null);

                
                if (mstrMobileApp.isOnline()) {
                    this.submitOfflineTransaction();
                }
            },

            handleCompatibilityError: function handleCompatibilityError() {
                if (!this.handledCompatibilityError) {
                    this.handledCompatibilityError = true;

                    
                    if (!this.isHosted()) {

                        mstrmojo.toast(mstrmojo.desc(9419, "The version of this app is incompatible with one or more of the MicroStrategy Mobile Server(s). Please update the app to a more recent version."));

                    }
                }
            },

            hasOpenDialog: function hasOpenDialog() {
            	return dialogs.length > 0;
            },

            isHosted: function isHosted() {
                return mstrMobileApp.isProxy;
            }
        }
    );

    
    $APP.$PF = function (direction, className, methodName) {
        mstrMobileApp[(direction ? 'enter' : 'exit') + 'JavaScriptMethod'](new Date().getTime(), methodName || arguments.callee.caller.name, className);
    };

    window.$MAPF = $APP.$PF;
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.CheckBoxDIC",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var MIN_HEIGHT_MDPI = 24,
        MIN_HEIGHT_HDPI = 36,
        MIN_HEIGHT_XHDPI = 48,
        MIN_HEIGHT = {160: MIN_HEIGHT_MDPI,
                      213: MIN_HEIGHT_MDPI,
                      240: MIN_HEIGHT_HDPI,
                      320: MIN_HEIGHT_XHDPI},
        SCROLLER_OFFSET_X = {160: 48,
                             213: 48,
                             240: 73,
                             320: 98},
        SWITCH_DURATION = 300,
        $C = mstrmojo.css,
        $D = mstrmojo.dom;

    function toggleBtn(isOn) {
        this.btnNode.innerHTML = isOn ? this.onText : this.offText;
        $C.toggleClass(this.btnNode, 'on', isOn);
        $C.toggleClass(this.btnNode, 'off', !isOn);
    }

    function clearAnimationTimeout() {
        if (this._animHandle) {
            window.clearTimeout(this._animHandle);
            delete this._animHandle;
        }
    }

    
    function applyTransform(duration, value) {
        this._scroller.origin.x = value;

        if (!duration) return;

        var style = this.scrollNode.style,
            me = this;

        this._isAnimating = true;
        style[$D.CSS3_TRANSITION_DURATION] = duration + 'ms';
        style[$D.CSS3_TRANSFORM] = $D.createTranslateString(-value);

        this._animHandle = window.setTimeout(function() {
            if (me._isAnimating) { me._isAnimating = false; }
            clearAnimationTimeout.call(me);
        }, duration * 3);
    }
    
    mstrmojo.android.inputControls.CheckBoxDIC = mstrmojo.declare(

        mstrmojo.CheckBoxDIC,

        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller, mstrmojo.android._HasPreviewButton ],

        
        {
            scriptClass: 'mstrmojo.android.inputControls.CheckBoxDIC',
            cssText: 'cursor:pointer;',
            cssDisplay: 'inline-block',

            onText: 'ON',
            offText: 'OFF',

            isSwitchStyle: false,

            
            markupString: '<div id="{@id}" class="mstrmojo-Label mstrmojo-CheckBoxDIC {@cssClass}" style="{@cssText}" mstrAttach:click,keydown>' +
                    '<div class="checkBox-android-wrapper">' +
                        '<div class="checkBox-android-scrollable">' +
                            '<div class="checkBox-androidMobile-button off"></div>' +
                            '<div class="checkBox-label-text"></div>' +
                        '</div>' +
                    '</div>' +
                '</div>',

            markupSlots: {
                scrollNode: function () { return this.domNode.firstChild.firstChild; },
                textNode: function () { return this.domNode.firstChild.firstChild.lastChild; },
                btnNode: function () { return this.domNode.firstChild.firstChild.firstChild; }
            },

            
            markupMethods: mstrmojo.hash.copy({
                ontextChange: function () { this.textNode.innerHTML = (this.text != null) ? this.text : ''; }
            }, mstrmojo.hash.copy(mstrmojo.CheckBoxDIC.prototype.markupMethods)),

            init: function init(props) {
                this._super && this._super(props);
                if (this.dic.stl == 0) {
                    this.isSwitchStyle = true;
                    var dpi = mstrMobileApp.getDeviceDPI();

                    this.maxOffsetX = SCROLLER_OFFSET_X[dpi];
                    this.scrollerConfig = {
                        showScrollbars: false,
                        showIndicators: false,
                        vScroll: false,
                        hScroll: true,
                        bounces: false,
                        useTranslate3d: false,
                        offset: { x: {end: this.maxOffsetX, start: 0},
                                 scrollPast: false
                        }
                    };
                    this.minHeight = MIN_HEIGHT[dpi] || MIN_HEIGHT_MDPI;
                }
            },

            updateScrollerConfig: function updateScrollerConfig() {
                if (!this.isSwitchStyle) return;
                var cfg = this._super(),
                    originX = this.checked ? 0 : (this.maxOffsetX || 0);
                mstrmojo.hash.copy({
                    scrollEl: this.scrollNode,
                    origin: {
                        x: originX,
                        y: 0
                    }
                }, cfg);
                return cfg;
            },

            updateScroller: function updateScroller(noScrollToOrigin, duration) {
                if (!this.isSwitchStyle) return;
                this._super(noScrollToOrigin, duration);
            },

            initScroller: function initScroller(scroller) {
                if (!this.isSwitchStyle) return;
                this._super(scroller);

                var me = this;
                
                scroller.attachEventListener('scrollMoved', this.id, function (evt) {
                    this._translateX = evt.x; 
                    toggleBtn.call(me, (evt.x < me.maxOffsetX / 2));
                });
            },

            oncheckedChange: function oncheckedChange(e) {
                if (this.isSwitchStyle) {
                    if (this.checked && this._scroller.origin.x !== 0) {
                        applyTransform.call(this, SWITCH_DURATION, 0);
                    } else if (!this.checked && this._scroller.origin.x !== this.maxOffsetX) {
                        applyTransform.call(this, SWITCH_DURATION, this.maxOffsetX);
                    }
                    toggleBtn.call(this, this.checked);
                }
                this._super && this._super(e);
            },

            preBuildRendering: function preBuildRendering() {
                this.cssClass = this.isSwitchStyle ? 'Android-tristate-mobile' : 'Android-tristate';
                
                var alignment;

                
                switch (this.owner.getFormats()['text-align']) {
                case 'center':
                    
                    alignment = '50%';
                    break;

                case 'right':
                    
                    alignment = '100%';
                    break;
                }

                
                if (alignment) {
                    
                    this.cssText += 'background-position:' + alignment + ' 50%;';
                }

                return this._super();
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                if (this.isSwitchStyle) {
                    toggleBtn.call(this, this.checked);
                    
                    
                    this.domNode.style.height = (this.openerStyle.ih > this.minHeight ? this.openerStyle.ih : this.minHeight) + 'px';
                 }
            },

            touchTap: function touchTap(touch) {
                this.onclick();
            },

            touchBegin: function touchBegin(touch) {
                if (!this.isSwitchStyle) return;
                if (this._isAnimating) {
                    touch.stop();
                    return false;
                }
                return this._super(touch);
            },

            touchSwipeEnd: function(touch) {
                if (!this.isSwitchStyle) return;
                
                touch.evt.handle = true;
                var posX = this._translateX,
                    isOn = (posX < this.maxOffsetX / 2),
                    value = isOn ? posX : (this.maxOffsetX - posX),
                    duration = value * SWITCH_DURATION / this.maxOffsetX;
                applyTransform.call(this, duration, isOn ? 0 : this.maxOffsetX);
                this.set('checked', isOn);
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                if (this.isSwitchStyle) {
                    mstrmojo.css.addClass(this.domNode.firstChild || d, 'tx-active');
                } else {
                    this._super(c, d);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._HasLayout",
                         "mstrmojo.android.ui._CanBeFullScreen",
                         "mstrmojo.android.ui.ActionToolbar",
                         "mstrmojo.android.ui.TitleLabel",
                         "mstrmojo.android.ui.Image",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.css");

    var $HASH = mstrmojo.hash,
        $ARR = mstrmojo.array,
        $CSS = mstrmojo.css;

    
    var $AB = mstrmojo.android.ui.ActionBar = mstrmojo.declare(
        mstrmojo.Container,

        [ mstrmojo._HasLayout, mstrmojo.android.ui._CanBeFullScreen ],

        
        {
            scriptClass: 'mstrmojo.android.ui.ActionBar',

            markupString: '<div id="{@id}" class="mstrmojo-ActionBar {@cssClass}" style="{@cssText}" >' +
                              '<div>' +
                                  '<div class="mstrmojo-ActionBar-logo"></div>' +
                                  '<div>' +
                                  	'<div class="mstrmojo-ActionBar-contents"></div>' +
                                  '</div>' + 	
                                  '<div class="mstrmojo-ActionBar-toolbar"></div>' +
                              '</div>' +
                          '</div>',

            markupSlots: {
                logoNode: function () { return this.domNode.firstChild.firstChild; },
                containerNodeWrapper: function () { return this.domNode.firstChild.childNodes[1]; },
                containerNode: function () { return this.domNode.firstChild.childNodes[1].firstChild; },
                toolbarNode: function () { return this.domNode.firstChild.lastChild; }
            },

            markupMethods: {
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod
            },

            layoutConfig: {
                h: {
                    logoNode: '56px',
                    containerNodeWrapper: '56px',
                    containerNode: '56px',
                    toolbarNode: '56px'
                },
                w: {
                    logoNode: '66px',
                    containerNodeWrapper: '100%',
                    containerNode: '100%',
                    toolbarNode: 'auto'
                }
            },

            children: [{
                scriptClass: 'mstrmojo.android.ui.Image',
                slot: 'logoNode',
                alias: 'logo',
                onactiveChange: function () {
                    
                    $CSS.toggleClass(this.domNode, 'active', this.active);
                },
                touchTap: function () {
                    
                    mstrApp.closeAllDialogs();

                    
                    if (this.active) {
                        var domNode = this.domNode,
                            cls = 'selected';

                        $CSS.addClass(domNode, cls);

                        
                        this.parent.controller.goUp();

                        window.setTimeout(function () {
                            $CSS.removeClass(domNode, cls);
                        }, 500);
                    }
                }
            }, {
                scriptClass: 'mstrmojo.android.ui.TitleLabel',
                slot: 'containerNode',
                alias: 'title',
                onlistSelectionMade: function (evt) {
                    
                    this.parent.controller.jumpTo(evt.item);
                }
            }, {
                scriptClass: 'mstrmojo.android.ui.ActionToolbar',
                slot: 'toolbarNode',
                alias: 'toolbar'
            }],

            
            reset: function reset() {
                
                this.title.reset();
                this.toolbar.reset();
            },

            setUpStatus: function setUpStatus(isActive) {
                this.logo.set('active', isActive);
            },

            
            setNavigation: mstrmojo.emptyFn,

            
            clearNavigation: mstrmojo.emptyFn,

            
            restoreNavigation: mstrmojo.emptyFn,

            
            selectNavigationItem: function selectNavigationItem(item) {
                var list = this.getNavList(),
                    res = false;
                $ARR.forEach(list && list.items, function (btn, idx) {
                    if (item.act === btn.act) {
                        list.singleSelect(idx);
                        res = true;
                        return false;
                    }
                });
                return res;
            },

            
            getNavList: mstrmojo.emptyFn,

            
            setLastOpened: function setLastOpened(items) {
                this.title.setListItems(items);
            },

            
            updateTitle: function updateTitle(text) {
                
                this.title.setText(text);
            },

            
            updateToolbar: function updateToolbar(id, tbCfg) {
                
                this.toolbar.setActions(id, tbCfg);

                
                this.title.checkTextFit();
            },

            
            setActionToolbarStatus: function setActionToolbarStatus(isActive) {
                this.toolbar.set('active', isActive);
            },

            onEnterFullScreen: function onEnterFullScreen() {
                this.reset();
            }
        }
    );

    
    $AB.adjustLayoutConfig = function (dpi, isTablet) {
        
        var $DPI_MANAGER = mstrmojo.DPIManager;

        
        $HASH.forEach($AB.prototype.layoutConfig.h, function (value, slot) {
            
            $DPI_MANAGER.registerClass($AB, 'h', slot, dpi);
        });

        
        var widthDpi = $HASH.copy(dpi);

        
        if (isTablet) {
            
            $HASH.forEach(widthDpi, function (value, key) {
                widthDpi[key] = Math.ceil(value * 1.333);
            });
        }

        
        $DPI_MANAGER.registerClass($AB, 'w', 'logoNode', widthDpi);
    };
}());


(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo.android.ui.ActionToolbar");

    mstrmojo.requiresDescs(1, 1143, 7831);

    var MENUS = mstrmojo.android.EnumMenuOptions,
        $HASH = mstrmojo.hash,
        $AFE = mstrmojo.array.forEach,
        GOTO_SETTINGS = MENUS.SETTINGS,
        GOTO_HELP = MENUS.HELP,
        GOTO_LEARN = MENUS.LEARN,
        DEFAULT_ALL = -1;

    
    var linkDrillParams = {
        currentViewMedia : 0,
        documentID : 'objectID',
        elementsPromptAnswers : 0,
        link : 0,
        linkAnswers : 0,
        objectID : 0,
        objectsPromptAnswers : 0,
        promptsAnswerXML : 0,
        reportID : 0,
        reportViewMode : 0,
        valuePromptAnswers : 0,
        visMode : 0,
        desiredElements : 0,
        desiredUnits : 0,           
        projectID : 0,              
        Project : 'projectID',      
        groupByElements : 0,        
        pageByElements : 0,         
        layoutIndex : 0,
        originMessageID: "originMessageID",
        promptAnswerMode: 0,
        selectorMode: "selectorMode"
    };

    
    mstrmojo.android.controllers.ViewController = mstrmojo.declare(
        mstrmojo.Obj,

        null,

        
        {
            scriptClass: "mstrmojo.android.controllers.ViewController",

            
            supportsFullScreen: false,

            
            start: function start(params) {
                
                this.set('orientation', mstrApp.isLandscape() ? 0 : 1);

                
                this.pid = mstrApp.getCurrentProjectId();
            },

            
            detach: function detach() {
                var me = this,
                    nextController = me.nextController,
                    prevController = me.prevController;

                
                if (prevController) {
                    
                    delete prevController.nextController;
                }

                
                if (nextController) {
                    
                    nextController.destroy();
                }

                
                this.nextController = this.prevController = null;

                
                var view = this.view;
                if (view) {
                    
                    view.destroy();
                }
            },

            
            destroy: function destroy() {
                
                this.detach();

                
                this._super();
            },

            
            canDetach: function canDetach(controller) {
                
                return controller.hsc || !this.hsc;
            },

            
            getUpStatus: function getUpStatus() {
                return !this.hsc;
            },

            
            spawn: function spawn(controller, startParams) {
                
                var nextController = this.nextController;
                if (nextController) {
                    
                    if (!nextController.canDetach(controller)) {
                        
                        nextController.spawn(controller, startParams);
                        return;
                    }

                    
                    nextController.destroy();
                }

                
                this.nextController = controller;
                controller.prevController = this;

                
                controller.rootCtrl = this.rootCtrl || this;

                
                controller.start(startParams || {});
            },

            
            spawnFailed: function spawnFailed(details) {
                
                this.makeCurrent();

                
                mstrApp.onerror(details);
            },

            
            viewFailed: function viewFailed(details) {
                
                if (details) {
                    mstrmojo.dbg('details: ' + JSON.stringify(details));
                }

                
                mstrApp.hideMessage();

                
                if (this.view) {
                    
                    if (this.rootCtrl.getCurrent() !== this) {
                        
                        this.makeCurrent(true);
                    }

                } else {
                    
                    var previousController = this.prevController;
                    if (previousController) {
                        
                        previousController.spawnFailed(details);
                    }
                }

                
                mstrApp.onerror(details);
            },

            
            makeCurrent: function makeCurrent(isBack) {
                
                var nextController = this.nextController,
                	
                    needRefresh = true;
                if (nextController) {
                	needRefresh = ! nextController.doNotRefresh;
                    
                    nextController.destroy();
                }

                
                if (!this.supportsFullScreen) {
                    
                    this.rootCtrl.exitFullScreen();
                }

                
                var projectId = this.pid;
                if (projectId) {
                    
                    mstrApp.setCurrentProjectId(projectId);
                }

                
                if (isBack) {
                    
                    if (mstrApp.useBinaryFormat && mstrApp.getCurrentProjectId()) {
                        
                        
                        var ctrlType = this.ctrlType;
                        if (ctrlType) {
                            var model = this.model,
                                emptyFn = mstrmojo.emptyFn,
                                successFn = emptyFn,
                                me = this;

                            
                        	
                            if (this.checkCache && needRefresh) {
                                successFn = function () {
                                    
                                    setTimeout(function () {
                                        me.checkCache(null, null, null, 1);
                                    }, 100);
                                };
                            }

                            var params = {
                                    taskId: 'setCurrentView',
                                    st: ctrlType,
                                    did: this.did || '',
                                    mid: (model && model.dataService && model.dataService.msgId) || ''
                                },
                                curLayoutKey = model && model.currlaykey;

                            
                            if (curLayoutKey) {
                                params.layoutKey = curLayoutKey;
                            }

                            
                            mstrApp.serverRequest(params, {
                                success: successFn,
                                failure: emptyFn
                            }, {
                                silent: true
                            });
                        }
                    }
                }
            },

            
            makeHome: function makeHome() {
                this.makeCurrent(true);
            },

            
            jumpTo: function jumpTo(item) {
                
                var nextController = this.nextController;
                if (nextController) {
                    
                    nextController.jumpTo(item);
                    return;
                }

                
                this.spawn(mstrApp.controllerFactory.newController(this.getViewKey(item.st), item), item);
            },

            
            getPath: function getPath() {
                
                var nextController = this.nextController;
                if (nextController) {
                    
                    return nextController.getPath();
                }

                
                return [];
            },

            
            updateItemProperties: function updateItemProperties(defaultMsg, item, ctrlId, isAvail) {
                
                var nextController = this.nextController;
                if (nextController) {
                    
                    nextController.updateItemProperties(defaultMsg, item, ctrlId, isAvail);
                }
            },

            
            onorientationChange: function onorientationChange() {
                var orientation = this.orientation,
                    view = this.view;

                
                if (view && view.hasRendered && view.rootOrientationChange) {
                    
                    view.rootOrientationChange({
                        isLandscape: !orientation
                    });
                }

                
                var nextController = this.nextController;
                if (nextController) {
                    
                    nextController.set('orientation', orientation);
                }
            },

            
            getCurrent: function getCurrent() {
                var nextController = this.nextController;
                if (nextController) {
                    return nextController.getCurrent();
                }

                return this;
            },

            
            goBack: function goBack() {
                
                var nextController = this.nextController;
                if (nextController) {
                    
                    if (!nextController.goBack()) {
                        
                        if (!this.rootCtrl) {
                            
                            return false;
                        }

                        
                        this.makeCurrent(true);
                    }

                    return true;
                }

                return false;
            },

            
            goUp: function goUp() {
                
                var nextController = this.nextController;
                if (nextController) {
                    return nextController.goUp();
                }

                return false;
            },

            
            getController: function getController(propName, propValue, isForward) {
                
                var ctrl = this[(isForward ? 'next' : 'prev') + 'Controller'];
                if (ctrl) {
                    
                    if (ctrl[propName] === propValue) {
                        
                        return ctrl;
                    }

                    
                    return ctrl.getController(propName, propValue, isForward);
                }

                
                return null;
            },

            
            newView: function newView(viewKey, params) {
                return mstrApp.viewFactory.newView(viewKey, mstrmojo.hash.copy(params, {
                    controller: this
                }));
            },

            
            getViewKey: function getViewKey(subtype) {
                return {
                    1: 'Projects',
                    2: 'Home',
                    3: 'Subscriptions',
                    4: 'Settings',
                    5: 'Projects',
                    6: 'Help',
                    8: 'Subscriptions',
                    768: 'Xtab',
                    769: 'Graph',
                    774: 'Xtab',
                    2048: 'Folder',
                    14081: 'Document'
                }[subtype];
            },

            
            getDefaultMenus: function getDefaultMenus() {
                return DEFAULT_ALL;
            },

            
            generateActionToolbar: function generateActionToolbar() {
                
                var rootCtrl = this.rootCtrl || this,
                    currentCtrl = rootCtrl.getCurrent();

                
                rootCtrl.setActionToolbar(currentCtrl.id, currentCtrl.updateActionToolbar(mstrmojo.android.ui.ActionToolbar.newToolbarConfig()));
            },

            
            updateActionToolbar: function updateActionToolbar(tbCfg) {
                var menus = this.getDefaultMenus(),
                    config = mstrApp.getConfiguration();

                
                if (config.isMenuAllowed(GOTO_LEARN, menus)) {
                    tbCfg.addMenuItem(GOTO_LEARN, mstrmojo.desc(9849, 'Learn More'), GOTO_LEARN, true, 6);
                }

                
                if (config.isMenuAllowed(GOTO_SETTINGS, menus)) {
                    tbCfg.addMenuItem(GOTO_SETTINGS, mstrmojo.desc(7831, 'Settings'), GOTO_SETTINGS, true, 6);
                }

                
                if (config.isMenuAllowed(GOTO_HELP, menus)) {
                    tbCfg.addMenuItem(GOTO_HELP, mstrmojo.desc(1143, 'Help'), GOTO_HELP, false, 9);
                }

                
                if (!mstrApp.isTablet()) {
                    
                    tbCfg.maxBtnCount = (mstrApp.isLandscape()) ? Math.round(mstrMobileApp.getDeviceDPI() / 105) + 1 : 2;
                }

                return tbCfg;
            },

            
            handleMenuItem: function handleMenuItem(group, cmdId) {
                switch (group) {
                case GOTO_SETTINGS:
                    
                    this.spawn(mstrApp.controllerFactory.newController('Settings'));
                    break;

                case GOTO_LEARN:
                    mstrMobileApp.displayLearnMore();
                    break;

                case GOTO_HELP:
                    
                    mstrApp.displayHelp();
                    break;
                }

                return false;
            },

            
            beforeViewVisible: mstrmojo.emptyFn,

            
            afterViewVisible: function afterViewVisible() {
                
                
                var me = this;
                window.setTimeout(function () {
                    me.generateActionToolbar();
                }, 100);
            },

            
            beforeViewHidden: mstrmojo.emptyFn,

            
            afterViewHidden: mstrmojo.emptyFn,

            
            handleSpecialLink: function handleSpecialLink(uri) {
                var eventId = uri.queryKey.evt,
                    forceRepaint;

                
                if (eventId === '3999') {
                    this.spawn(mstrApp.controllerFactory.newController('Settings', {}), {});

                } else if (eventId === '3124') { 
                    mstrApp.goBack();

                    
                    forceRepaint = true;

                } else if (eventId === '3994') { 
                    mstrApp.displayHelp();

                } else if (eventId === '3997') { 
                    mstrApp.rootController.jumpTo({
                        act: 8
                    });

                } else if (eventId === "3995") { 
                    
                    mstrApp.rootController.goHome();

                    
                    forceRepaint = true;

                } else if (eventId === "3996") { 
                    
                    mstrApp.rootController.jumpTo({
                        act: 5
                    });

                    
                    forceRepaint = true;
                }

                
                if (forceRepaint) {
                    window.setTimeout(function () {
                        mstrMobileApp.forceRepaint();
                    }, 0);
                }
            },

            
            getDepth: function getDepth() {
            	var prev = this.prevController;
            	return (prev && (prev.getDepth() + 1)) || 1;
            },

            onLink: function onLink(view, action) {
                var params = this.buildLinkParams(action);
                params.action = 'linkToObject';

                
                var isHTMLDoc = false,
                    subtype = 768;

                
                switch (parseInt(action.evt, 10)) {
                    case 4001:
                        
                        if (parseInt(action.reportViewMode, 10) === 2) {
                            
                            subtype = 769;
                        }

                        
                        params.styleName = 'AndroidMessageResultStyle';
                        break;

                    case 32001:
                        
                        isHTMLDoc = true;
                        break;

                    case 2048001:
                        
                        subtype = 14081;
                        break;
                }

                
                params.st = subtype;

                
                this.spawn(mstrApp.controllerFactory.newController(isHTMLDoc ? 'HTMLDoc' : this.getViewKey(subtype), {
                    st : subtype
                }), params);

            },

            
            buildLinkParams: function buildLinkParams(action) {
                var params =  {};

                
                $HASH.forEach(action, function (v, p) {
                    var pV = linkDrillParams[p];

                    
                    if (p === "Project") {
                        
                        var mobileCfg = mstrApp.getConfiguration(),
                            sn = action.Server,
                            port = action.port || action.Port,
                            project;

                        
                        
                        if (sn === undefined) {
                            var server = mobileCfg.getServerByProjectId(mstrApp.getCurrentProjectId());
                            if (server !== undefined) {
                                $AFE(server.pl, function (p) {
                                    if (v === p.pn) {
                                        if ((port === undefined) || (!!port && parseInt(port, 10) === p.sp)) {
                                            project = p;
                                            return false;
                                        }
                                    }
                                });
                            }
                        } else {
                            project = mobileCfg.getProjectByServerAndProjectName(sn, port, v);
                        }

                        
                        if (project !== undefined) {
                            
                            params[pV] = project.pid;
                        }

                        
                    } else if (pV !== undefined) {
                        
                        
                        
                        params[pV || p] = v;
                    }
                });

                
                if (mstrApp.useBinaryFormat) {
                    
                    params.srcMsgId = action.srcMsgId;
                }


                var linkInfo = action.linkInfo;  

                if (linkInfo && linkInfo.so > 0) {
                    params.selectorMode = linkInfo.so;
                    params.originMessageID = action.srcMsgId;
                    if (!action.linkAnswers) {
                        params.promptAnswerMode = '0'; 
                    }
                }

                return params;
            },

            
            exitFullScreen: mstrmojo.emptyFn
        }
    );
}());
(function() {
	mstrmojo.requiresCls(
			"mstrmojo.prompt.WebConstantPrompt", 
			"mstrmojo.prompt.WebGeoConstantPrompt", 
			"mstrmojo.prompt.WebElementsPrompt",
			"mstrmojo.prompt.WebUnsupportedPrompt",
			"mstrmojo.XMLBuilder");
	mstrmojo.prompt.WebPrompts = mstrmojo.declare(
			
			mstrmojo.Obj,
			
			null, 
			
			{
				scriptClass: 'mstrmojo.prompt.WebPrompts',
				
				lcl: 1033,
				
				
				
				host: null,
				
				mergeGeoPrompts: true,
				
	            init: function init(props){
	                var rsl = props.rsl;
	                delete props.rsl;
	                this._super(props);
	                this.populate(rsl);
	            },            
	            
				
				
				get: function(index) {
					var ps = this.prompts;
					if (ps && index < ps.length) {
						return ps[index];
					} else {
						alert('index is out of boundary.');
					}
				},
				
				size: function size(){
					var ps = this.prompts;
					return ps && ps.length || 0;
				},

				
				isEmpty: function isEmpty(){
					return !this.prompts || !!this.prompts.length;
				},


				
				validate: function validate(){
					var ps = this.prompts;
					for (var i = 0; i < ps.length; i ++) {
						ps[i].validate(); 
					}
					return true;
				},

				
				populate: function populate(rsl) {
					var prompts = rsl && rsl.prompts,
						$T = mstrmojo.prompt.PromptTypes,
						mgp = this.mergeGeoPrompts,
						geo;
					this.lcl = rsl && rsl.lcl || this.lcl;
					this.prompts = [];
					
					
					if ( prompts) {
    					for (var i = 0; i < prompts.length; i ++){
    						var p = prompts[i];
    						switch(p.ptp){
    							case $T.CONSTANT_PROMPT:
    								
    								var pm = new mstrmojo.prompt.WebConstantPrompt();
    								
    								pm.populate(p);
    								
    								if (mgp && pm.prs && pm.prs.DisplayStyle == 'GeoLocation'){
    									if (!geo){
    										geo = new mstrmojo.prompt.WebGeoConstantPrompt();
    										geo.title = "Current Location";
    										geo.add(pm);
    										pm = geo;
    									} else {
    										
    										geo.add(pm);
    										continue;
    									}
    								}
    								break;
    							case $T.ELEMENTS_PROMPT:
    								var pm = new mstrmojo.prompt.WebElementsPrompt();
    								
    								pm.populate(p);
    								break;
    							default:
    								var pm = new mstrmojo.prompt.WebUnsupportedPrompt();
    								
    								pm.populate(p);
    								
    						}
    						
    						this.prompts.push(pm);
    					}
					}
				},
                
				populateAnswers: function populateAnswers(answers) {
				    var prompts = this.prompts,
				        i;
				    for ( i = 0; i < answers.length; i ++ ) {
				        prompts[i].populateAnswer(answers[i]);
				    }
				},
				
                buildAnswerObject: function buildAnswerObject() {
                    var ob = [];
                    for (var i = 0; i < this.size(); i ++) {
                        var p = this.prompts[i];
                        ob.push(p.buildAnswerObject());
                    }
                    return ob;
                },
				


                prepareAnswer: function(callbacks){
                	var ps = this.prompts,
	            		prep = function(ps, i, callbacks) {
                			var len = ps.length; 
                			ps[i].prepareAnswer({
                				success: function() {
                    				if (i < len - 1) {
                    					prep(ps, i + 1, callbacks);
                    				} else {
                    					if (callbacks && callbacks.success) {
                    						callbacks.success();
                    					}
                    				}
                				},
                    			failure: function(){
                    				if (callbacks && callbacks.failure) {
                    					callbacks.failure();
                    				}
                    			}
                			});
	            		};
                	if (ps && ps.length > 0){
                		prep(this.prompts, 0, callbacks);
                	}
                	
                },
				
				getAnswerXML: function getAnswerXML(){
					var buf = new mstrmojo.XMLBuilder();
					this.buildShortAnswerXML(buf);
					return buf.toString();
				},
				
				buildShortAnswerXML: function buildShortAnswerXML(builder) {
					builder = builder || new mstrmojo.XMLBuilder();
					builder.addChild('rsl');
					builder.addAttribute('lcl', this.lcl);
					for (var i = 0; i < this.size(); i ++) {
						var p = this.prompts[i];
						p.buildShortPa(builder);
					}
					builder.closeElement();
				},
				
				hasSupported: function hasSupported() {
                    for (var i = 0; i < this.size(); i ++) {
                        var p = this.prompts[i];
                        if (p.supported() ) {
                            return true;
                        }
                    }
                    return false;
				}
			}
	);
	
	mstrmojo.prompt.PromptTypes = {
			CONSTANT_PROMPT : 1,
			CONSTANT_GEO_PROMPT: 1.5,
			ELEMENTS_PROMPT : 2,
			OBJECT_PROMPT : 4
	};
	mstrmojo.Enum = {};
	mstrmojo.Enum.Validation = {};
	mstrmojo.Enum.Validation.STATUSCODE = {
		'VALID' :0,
		'INVALID_DATATYPE' :1,
		'EXCEEDS_MIN_VALUE' :2,
		'EXCEEDS_MAX_VALUE' :3,
		'EXCEEDS_MIN_LENGTH' :4,
		'EXCEEDS_MAX_LENGTH' :5,
		'EXCEEDS_MIN_COUNT' :6,
		'EXCEEDS_MAX_COUNT' :7,
		'INVALID_ANSWERS' :8,
		'NO_INPUT' :9,
		'NO_PERSONAL_ANSWER_NAME' :10,
		'INCOMPLETE_CONDITION' :11,
		'TRUNCATED' :12,
		'INCOMPLETE_CONDITION_ON_AUTO_NODE' :13, 
		'INVALID_PERSONAL_ANSWER_NAME' :14,
		'DUPLICATED' :15,
		'INVALID' :999
	
	};
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.prompt.WebPrompts");

    var CLASS_NAME = 'mstrmojo._ResultSetXt',
        STATUS_MISSING = 0,
        STATUS_COMPLETE = 1,
        STATUS_ERROR = 2,
        STATUS_PROMPT = 3,
        STATUS_POLL = 4;

    var URL_LINK_PARAMS = ["promptsAnswerXML", "elementsPromptAnswers", "valuePromptAnswers", "objectsPromptAnswers"];

    function fromLink(params) {
        if (params.linkAnswers) {
            return true;
        }
        var len = URL_LINK_PARAMS.length,
            i;

        for (i = 0; i < len; i++) {
            if (params[URL_LINK_PARAMS[i]]) {
                return true;
            }
        }
        return false;
    }

    function resolveStatus(res) {
        
        if ((!res) || (res.status === undefined) || (isNaN(res.status))) {
            return STATUS_MISSING;
        }

        switch (parseInt(res.status, 10)) {
        case 0:  
        case 1:  
            return STATUS_COMPLETE;

        case 2:  
            return STATUS_PROMPT;

        case 3:  
            return STATUS_ERROR;

        default: 
            return STATUS_POLL;
        }
    }

    function pollForResult(request, isInitialRequest, callback) {
        
        var fnSuccess = callback.success;
        delete callback.success;

        var app = mstrApp,
        	isRefresh = !!request.useRefreshProgress,
        	pst = isRefresh ? [mstrmojo.desc(10078, 'Refreshing data. Please wait.')] : [],
            fnPollStatus;

        delete request.useRefreshProgress;

        
        callback.success = function (res, req ) {
            
            

            switch (resolveStatus(res)) {
            case STATUS_COMPLETE:
            case STATUS_PROMPT:
            case STATUS_MISSING:
                fnSuccess(res, req);
                break;

            case STATUS_ERROR:
                callback.failure(res);
                break;

            case STATUS_POLL:
                
                
                
                var hInterval;

                
                callback.success = function (res, req) {

                    
                    var pollStatus = resolveStatus(res);

                    switch (pollStatus) {
                    case STATUS_COMPLETE:
                    case STATUS_PROMPT:
                        
                        fnSuccess(res, req);
                        break;

                    case STATUS_MISSING:
                        
                    case STATUS_POLL:
                        fnPollStatus();  
                        break;

                    default:
                        
                        res.message = "Error checking the status of running report/document.";
                        callback.failure(res);
                        break;
                    }
                };

                
                fnPollStatus = function() { app.serverRequest({
                        taskId: 'pollStatus',
                        msgID: res.id
                    }, callback, {
                        src: CLASS_NAME + '::pollForResult'
                    });
                };

                fnPollStatus();
                break;
            }
        };

        
        
        app.serverRequest(request, callback, {
            src: CLASS_NAME + '::pollForResult',
            showProgress: isInitialRequest,
            hideProgress: !isInitialRequest,
            hideWait: !isInitialRequest,
            useRefreshProgress: isRefresh,
            progressStateText: pst
        });
    }

    function execAndPoll(request, callback, isInitialRequest, resParams) {
        var me = this;
        pollForResult.call(this, request, isInitialRequest, {  
            success: function (res) {
                me.msgId = res.id;
                if (res.visName) {
                    me.visName = res.visName;
                }
                var rc = resolveStatus(res);
                if (rc === STATUS_PROMPT) {
                    if (callback.prompts) {
                        me.loadPrompts({
                            success: callback.prompts,
                            failure: callback.failure
                        });
                    } else {
                        callback.failure({
                            message: "Wrong status. Received Prompts while expected Result."
                        });
                    }
                } else {
                    
                    if (callback.execSuccess) {
                        
                        callback.execSuccess(res);
                    }

                    if (resParams && resParams.statusOnly) {
                        callback.success(res);
                    } else {
                        
                        if (me.visName && me.visName !== "") {
                            if (!resParams) {
                                resParams = {};
                            }
                            resParams.colsPerPage = -1;
                            resParams.rowsPerPage = -1;
                        }
                        me.getResults(resParams, {
                            success: callback.success,
                            failure: callback.failure,
                            complete: callback.complete || mstrmojo.emptyFn,
                            canceled: callback.canceled || mstrmojo.emptyFn
                        });
                    }
                }
            },

            failure: callback.failure,
            complete: callback.complete || mstrmojo.emptyFn,
            canceled: callback.canceled || mstrmojo.emptyFn
        });
    }

    
    function getPromptModel(prompts, answers) {
        
        var factory = mstrApp.modelFactory;
        if (factory) {
            return factory.newPromptsModel(prompts, answers);
        }

        return mstrApp.viewFactory.newPrompts(prompts, answers);
    }

    
    mstrmojo._ResultSetXt = mstrmojo.provide(
        'mstrmojo._ResultSetXt',

        
        {
            _mixinName: 'mstrmojo._ResultSetXt',

            
            msgId: null,

            
            execute: function execute(request, callback, resParams) {
                if (request.link) {
                    request.linkAnswers = request.link.toXml();
                    delete request.link;
                }

                var me = this,
                    cb = mstrmojo.func.addMethods(callback, {
                        prompts: function (res) {
                            me.prompts = res;
                            callback.prompts(res);
                        },
                        
                        
                        success: function (res) {
                            if (res.prompt) {
                                me.prompts = res.prompt;
                            }
                            callback.success(res);
                        }
                    });

                
                
                
                if (!me.prompts && fromLink(request)) {
                    cb.success = function (res, req) {

                        delete req.config.hideWait;
                        delete req.config.hideProgress;

                        me.loadPrompts({
                            success: function (prm) {
                                if (prm.prompts) {
                                    me.prompts = prm;
                                    me.answers = getPromptModel(prm).buildAnswerObject();
                                }
                                callback.success(res, req );
                            },
                            failure: callback.failure,
                            complete: callback.complete || mstrmojo.emptyFn
                        }, {
                            includeClosed: true
                        });
                    };
                } else if (request.promptsAnswerXML) {
                    
                    cb.success = function (res, req) {
                        me.prompts = null;
                        me.answers = null;
                        me.loadPrompts({
                            success: function (prm) {
                                if (prm.prompts) {
                                    me.prompts = prm;
                                    me.answers =  getPromptModel(prm).buildAnswerObject();
                                }
                                callback.success(res,req);
                            },
                            failure: mstrmojo.emptyFn
                        });
                    };
                }
                execAndPoll.call(this, request, cb, true, resParams);
            },

            
            answerPrompts: function answerPrompts(prompts, callback, request) {
                if (mstrApp.useBinaryFormat) {
                    request.objectType = 55;
                }
                request.taskId = 'answerPrompts';
                request.msgID = request.msgId || this.msgId;
                request.promptAnswerXML = prompts.getAnswerXML();

                var me = this;
                execAndPoll.call(this, request, {
                    success: function (res) {
                        
                        me.answers = prompts.buildAnswerObject();
                        callback.success(res);
                    },
                    prompts: callback.prompts,
                    failure: callback.failure
                }, true);
            },

            
            getResults: function getResults(request, callback) {
                request.messageID = request.msgId || this.msgId;
                pollForResult.apply(this, [ request, false, callback ]);
            },


            
            loadPrompts: function loadPrompts(callback, request) {
                request.taskId = 'getPrompts';
                request.msgID = request.msgID || this.msgId;
                pollForResult.apply(this, [ request, false, callback ]);
            },

            linkToObject: function linkToObject(params, callback) {
                
                this.execute(params, callback);
            },

            getPrompts: function getPrompts() {
                
                var prompts = this.prompts;
                if (prompts) {
                    
                    return getPromptModel(this.prompts, this.answers);
                }

                
                return undefined;
            },

            checkCache: function checkCache(request, callback, config) {
            	var cfg = mstrmojo.hash.copy(config, {
                    src: CLASS_NAME + '::checkCache',
                    override: false,
                    silent: true
                });
                request.taskId = 'checkCache';
                mstrApp.serverRequest(request, callback, cfg);
            },

            checkCachedLinkTargets: function checkCachedLinkTargets(items, callback) {
                var request = {
                    taskId: 'checkCachedLinkTargets',
                    items: items
                };
                mstrApp.serverRequest(request, callback, {
                    src: CLASS_NAME + '::checkCachedLinkTargets',
                    override: false,
                    silent: true
                });
            },
            
            
            urlLinkParams: function urlLinkParams() {
                return URL_LINK_PARAMS;
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ViewController",
                         "mstrmojo.android.controllers._HasFolderView",
                         "mstrmojo.android.EnumMenuOptions");

    mstrmojo.requiresDescs(773, 1089, 9931);
    
    var $DESC = mstrmojo.desc;

    
    var REFRESH = mstrmojo.android.EnumMenuOptions.REFRESH;

    
    function loadSubscriptions(refresh) {
        var me = this,
            callback = function (res) {
                var view = me.view,
                    rootCtrl = me.rootCtrl,
                    title;

                
                view.set('items', res.items);

	            
	            if (rootCtrl.getCurrent() == me) {
	                
	                if (!me.hsc) {
	                    
	                    title = $DESC(1089, 'Subscriptions');
	                }
	
	                
	                rootCtrl.updateFolder(view, title);
	
	                
	                me.updatePropertiesMsg();
	            }
            };





        mstrApp.modelFactory.newDataService('Subscriptions').getSubscriptions({
            success: callback,
            failure: function (details) {
                
                if (mstrApp.isHosted()) {
                    
                    callback({
                        items: [{
                            n: 'Subscriptions Unavailable'
                        }]
                    });
                } else {
                    
                    me.viewFailed(details);
                }
            }
        }, refresh);
    }

    
    mstrmojo.android.controllers.SubscriptionsController = mstrmojo.declare(

        mstrmojo.android.controllers.ViewController,

        [ mstrmojo.android.controllers._HasFolderView ],

        
        {
            scriptClass: "mstrmojo.android.controllers.SubscriptionsController",

            init: function init(params) {
                this._super(params);

                
                var publisher = mstrmojo.publisher;
                publisher.subscribe(publisher.NO_SRC, publisher.RECONCILE_END_EVENT, function () {
                    loadSubscriptions.call(this, true);
                }, this.id);
            },

            start: function start(params) {
                this._super(params);

                
                this.csp = params.csp;

                
                this.initFolderView();

                
                loadSubscriptions.call(this, false);
            },

            openItem: function openItem(item) {
                
                var subtype = item.st;
                if (subtype) {
                	
                	this.spawnedItem = item;
                    
                    this.spawn(mstrApp.controllerFactory.newController(this.getViewKey(subtype), item), item);
                } else {
                    
                    this.view.clearSelect();
                }
            },
            
            spawnFailed: function spawnFailed(details) {
            	
            	delete this.spawnedItem;
            	this._super(details);
            },

            itemLongPressed: function itemLongPressed(item) {
                
                if (item.st) {
                    
                    return this._super(item);
                }

                
                return false;
            },

            getDefaultMessage: function getDefaultMessage() {
                return $DESC(9931, 'Select a subscription to view its content.');
            },

            makeCurrent: function makeCurrent(isBack) {
            	var spawnedItem = this.spawnedItem;
            	
            	if ( isBack && spawnedItem ) {
            		delete spawnedItem.unread;
            		delete this.spawnedItem;
            		
            	}
                this._super(isBack);

                
                var rootCtrl = this.rootCtrl;
                
                rootCtrl.updateFolder(this.view, this.txt, isBack);

                
                rootCtrl.restoreNavigation();

                
                this.updatePropertiesMsg();
            },

            goUp: function goUp() {
                
                if (!this._super()) {
                    
                    this.rootCtrl.goBack();
                }

                
                return true;
            },

            updateActionToolbar: function updateActionToolbar(tbCfg) {
                
                tbCfg.addMenuItem(REFRESH, $DESC(773, 'Refresh'), REFRESH, true, 5);

                return this._super(tbCfg);
            },

            handleMenuItem: function handleMenuItem(group, command) {
                
                if (group === REFRESH) {
                    
                    mstrMobileApp.restartReconciler();
                    return;
                }

                this._super(group, command);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ViewController",
                         "mstrmojo.android.ui.ActionToolbar",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo.android.ui.PropertiesView",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.string");

    mstrmojo.requiresDescs(1142, 8623, 8429, 8430, 8624, 8625, 9099, 11191);

    var $HASH = mstrmojo.hash,
        $AFE = mstrmojo.array.forEach,
        $DOM = mstrmojo.dom,
        TYPE_REPORT = 768,
        MENUS = mstrmojo.android.EnumMenuOptions,
        MNU_FULLSCREEN = MENUS.FULL_SCREEN,
        MNU_SHARE = MENUS.SHARE,
        MNU_ANNOTATION = MENUS.ANNOTATION,
        MNU_ABOUT = MENUS.ABOUT_RESULTSET,
        OBJECT_TYPE_REPORT = 3,             
        BOTTOM_ACTION_TOOLBAR_HEIGHT_160_DPI = 50;

    
    function restoreProjectId() {
        
        var oldPrjId = this._oldPID;
        if (oldPrjId) {
            
            mstrApp.setCurrentProjectId(oldPrjId);
        }
    }

    
    function reExecuteRS(params, callback, resParams, isRefresh ) {
        var model = this.model,
            prompts = model.prompts;

        if (prompts) {
            params.promptsAnswerXML = prompts.getAnswerXML();
        }

        
        params.useRefreshProgress = isRefresh;

        mstrApp.closeAllDialogs(); 

        model.execute(params, callback, resParams);
    }

    
    function refreshRS( callback ) {
        var model = this.model,
            prompts = model.prompts,
            params = {
                fresh: false,
                useRefreshProgress: mstrApp.isTablet()
            };

        if (prompts) {
            params.promptsAnswerXML = prompts.getAnswerXML();
        }

        
        mstrApp.closeAllDialogs();

        this.refresh( params, callback );
    }

    
    function updateLastOpenedList() {
        var startParams = this._startParams,
            action = startParams.action,
            newItem;

        
        if (!action || (action !== 'drillGrid' && action !== 'drill2Grid')) {
            
            newItem = startParams;
        }

        
        this.rootCtrl.updateLastOpened(newItem);
    }

    
    function initView(response, params) {
        
        params = params || {};

        
        var view = this.view = this.createView(response, $HASH.copy(params)),
            title = response.n || params.ttl || '',
            me = this;

        
        view.slot = 'containerNode';

        
        var frame = this.frame = this.newView('ResultSet', {
            controller: this
        });

        
        frame.addChildren([ view ]);

        
        this.rootCtrl.updateContent(frame, title);

        
        this.ttl = this._startParams.n = title;

        
        this.desc = response.dsc;

        
        updateLastOpenedList.call(this);

        
        window.setTimeout(function () {
            
            me.checkCache(response, params);
        }, 100);
    }

    
    function getViewCaptureConfig() {
    	
        
    	if (this.isFullScreen) {
    		this.cancelFlashFullScreen();
        }

    	var position = this.frame.getPosition(),
        	windowDim = $DOM.windowDim();

        position.ww = windowDim.w;
        position.wh = windowDim.h;

        return JSON.stringify(position);
    }

    
    mstrmojo.android.controllers.ResultSetController = mstrmojo.declare(

        mstrmojo.android.controllers.ViewController,

        null,

        
        {
            scriptClass: "mstrmojo.android.controllers.ResultSetController",

            supportsFullScreen: true,

            start: function start(params) {
                this._super(params);

                
                this._startParams = $HASH.copy(params);

                var me = this,
                    newProjectId = params.projectID,
                    prevController = me.prevController,
                    fnViewFailed = function (e) {
                        
                        restoreProjectId.call(me);

                        
                        me.viewFailed(e);
                    },
                    fnLogMethod = function (isEntry) {
                        
                        $MAPF(isEntry, 'ResultSetController', 'start');
                    },
                    fnDocRequestComplete = function () {
                        
                        if (prevController && prevController.docRequestComplete) {
                            
                            prevController.docRequestComplete();
                        }
                    };

                
                var subtype = this.ctrlType = params.st;

                
                fnLogMethod(true);

                
                if (newProjectId) {
                    
                    this._oldPID = mstrApp.getCurrentProjectId();

                    
                    mstrApp.setCurrentProjectId(newProjectId);

                    
                    this.pid = newProjectId;

                }

                try {
                    
                    var action = params.action || 'execute';
                    delete params.action;

                    
                    var model = this.model = this.initModel();

                    
                    if (subtype) {
                        
                        model.st = subtype;
                        model.n = params.n;
                    }

                    
                    this.did = this.did || params.documentID || params.reportID || params.objectID;

                    
                    model[action](params, {
                        success: function (response) {
                            try {
                                
                                initView.call(me, response, params);

                            } catch (e) {
                                
                                fnViewFailed(e);
                            }
                        },

                        prompts: function () {
                            
                            me.openPrompts(params);
                        },

                        failure: function (details) {
                            
                            fnViewFailed(details);
                        },

                        complete: function () {
                            
                            fnLogMethod(false);

                            
                            fnDocRequestComplete();
                        },

                        canceled: function () {
                            
                            fnViewFailed();
                        }
                    });

                } catch (e) {
                    
                    fnViewFailed(e);

                    
                    fnDocRequestComplete();
                }
            },

            
            initModel: mstrmojo.emptyFn,

            
            canDelegateToolBar: function canDelegateToolBar() {
                return true;
            },

            
            createView: mstrmojo.emptyFn,

            getDefaultMenus: function getDefaultMenus() {
                
                return 0;
            },

            onorientationChange: function onorientationChange() {
                
                var frame = this.frame;
                if (frame && frame.hasRendered) {
                    
                    frame.rootOrientationChange({
                        isLandscape: !this.orientation
                    });
                }

                this._super();
            },

            
            refresh: function refresh(params, callback) {
                
                var view = this.view;
                
                this.model.refresh(params, mstrmojo.func.wrapMethods({
                    success: function (res) {
                        
                        if (res) {
                            
                            view.refresh();
                        }
                    }
                }, callback));
            },

            reExecute: function reExecute(view) {
                
                if (mstrApp.useBinaryFormat) {
                    mstrMobileApp.removeLiveCache(mstrApp.getCurrentProjectId(), this.model.ci.cid);

                    
                    var me = this;
                    reExecuteRS.call(this, {}, {
                        success: function (res) {
                            me.setData(res);
                        }
                    }, {
                        refresh: true
                    }, false );
                } else {
                    view.model.raiseEvent({
                        name: 'refresh'
                    });
                }
            },

            reprompt: function reprompt() {
                
                this.repromptFlag = true;

                
                this.openPrompts();
            },

            openPrompts: function openPrompts(params) {
                var me = this,
                    prompts = this.model.prompts,
                    size = prompts.size(),
                    supportedPrompts = [],
                    hasUnanswerdUnsupportedPrompts = false,
                    i;

                
                for (i = 0; i < size; i++) {
                    
                    var prompt = prompts.get(i);
                    if (prompt.supported()) {
                        
                        supportedPrompts.push(prompt);

                    } else {
                        
                        if (!prompt.hasAnswer) {
                            
                            if (prompt.req) {
                                
                                this.viewFailed({
                                    message: mstrmojo.desc(8623, 'Report cannot be executed because it contains unanswered, required prompts.')
                                });
                                return;

                            }

                            
                            hasUnanswerdUnsupportedPrompts = true;
                        }
                    }
                }

                var fnAnswerPrompts = function () {
                    
                    if (hasUnanswerdUnsupportedPrompts) {
                        
                        mstrmojo.alert(mstrmojo.desc(8624, 'Warning: Report contains unasnwered, unsupported prompts.'), function () {
                            me.answerPrompts();
                        });

                    } else {
                        
                        me.answerPrompts();
                    }
                };

                
                if (supportedPrompts.length > 0) {
                    
                    var frame = this.frame;
                    this.spawn(mstrApp.controllerFactory.newController('Prompts'), {
                        maskNode: frame && frame.getMaskNode(),
                        prompts: prompts,
                        supportedPrompts: supportedPrompts,
                        
                        n: (params && (params.n || params.ttl)) || this.ttl,
                        callback: function () {
                            fnAnswerPrompts();
                        }
                    });

                } else {
                    
                    fnAnswerPrompts();

                }
            },

            answerPrompts: function answerPrompts() {
                
                var me = this;
                this.model.answerPrompts({
                    success: function (response) {
                        
                        var nextController = me.nextController;
                        if (nextController) {
                            
                            nextController.destroy();
                        }

                        
                        if (me.repromptFlag) {
                            
                            me.afterReprompt(response);

                            
                            delete me.repromptFlag;

                            
                            me.rootCtrl.updateContent(me.frame, response.n);

                            
                            updateLastOpenedList.call(me);

                            
                            me.checkCache(response);

                        } else {
                            
                            initView.call(me, response);

                        }
                    },

                    prompts: function () {
                        
                        me.viewFailed({
                            message: mstrmojo.desc(8625, 'Prompts in prompts are not supported.')
                        });
                    },

                    failure: function (details) {
                        mstrApp.onerror(details);
                    }
                });
            },

            
            afterReprompt: function afterReprompt(response) {
                this.getPageByTree(true);
            },
            
            hasPageBy: mstrmojo.emptyFn,

            
            getPageByTree: function getPageByTree(override) {
                
                var hasData = !!this.pageByData;
                if ((!override && hasData) || !this.hasPageBy()) {
                    
                    return;
                }

                var ctrl = this,
                    view = this.view,
                    model = (view.isVis && view.isVis()) ? view.xtabModel : this.model;

                
                if (model.getPageByTree) {
                    
                    if (hasData) {
                        
                        this.set('pageByData', null);
                    }

                    
                    model.getPageByTree({
                        success: function (data) {
                            ctrl.set('pageByData', data);
                        },
                        failure: function (res) {
                            mstrApp.onerror(res);
                        }
                    });
                }
            },

            destroy: function destroy() {
                
                this.model.destroy();

                
                var frame = this.frame;
                if (frame) {
                    
                    frame.destroy();
                }

                this._super();
            },

            
            checkCache: function checkCache(res, params, callback, option, config) {
                
                
                
                

                var me = this,
                    dataService = this.model.getDataService(),
                    ifc = res && res.ifc;

                
                callback = callback || mstrmojo.emptyFn;

                
                if (!mstrApp.useBinaryFormat || !ifc) {
                    callback();
                    return;
                }
                

                
                params = params || {
                    did: this.did,
                    n: this.n,
                    st: this.st,
                    t: this.t,
                    sub_id: this.sub_id
                    
                };

                
                
                
                var fnDisableMenu = function (menuInactive) {
                    var isActive = (menuInactive !== true);
                    me.rootCtrl.setActionToolbarStatus(isActive);
                    me.frame.setActionToolbarStatus(isActive);
                };

                
                var showMessage = true,                     
                    refreshMethod = 1, 
                    reExecuteCallback = {
                        success: function (newData) {
                            if (showMessage && option !== 2) {
                                mstrmojo.toast(mstrmojo.desc(8617, 'Your view has been updated with the latest version of the document.'), 3000);
                            }
                            
                    	    if ( refreshMethod === 1) {
                                me.setData(newData, true);
                    	    }
                            me.getPageByTree(true);
                            
                            me.generateActionToolbar();
                            
                            callback();
                            fnDisableMenu();
                        },

                        prompts: function () {
                            mstrmojo.alert(
                                mstrmojo.desc(8619, 'New prompts were added to the document.'),
                                function () {
                                    fnDisableMenu();
                                    me.reprompt();
                                }
                            );
                        },

                        
                        failure: function () {
                            fnDisableMenu();
                        },

                        
                        canceled: fnDisableMenu
                    };

                fnDisableMenu(true);

                
                
                if (option === 1 && res.ci.cid === "00000000000000000000000000000000") {
                    showMessage = false;
                }

                dataService.checkCache($HASH.copy(res.ci || {}), {
                    success: function (cache) {
                    	
                        if (cache.needUpdate ) {
                        	if ( cache.refresh && option === 2) { 
                        		refreshMethod = 2;
                        		refreshRS.call(me, reExecuteCallback);
                        	} else {
                                reExecuteRS.call(me, params, reExecuteCallback, {}, mstrApp.isTablet() );
                        	}
                        } else {
                            callback();
                            fnDisableMenu();
                        }
                    },

                    failure: function () {
                        
                        
                        if (!mstrApp.onMobileDevice()) {
                        	if ( option === 2) { 
                        		refreshMethod = 2;
                        		refreshRS.call(me, reExecuteCallback);
                        	} else {
                                reExecuteRS.call(me, params, reExecuteCallback, {}, mstrApp.isTablet() );
                        	}
                        } else {
                            fnDisableMenu();
                        }
                    },

                    
                    canceled: fnDisableMenu
                }, config);
            },

            goBack: function goBack() {
                
                var rtn = this._super();
                if (!rtn) {
                    
                    restoreProjectId.call(this);
                }

                return rtn;
            },

            makeCurrent: function makeCurrent(isBack) {
                
                var frame = this.frame;
                if (frame) {
                    
                    this._super(isBack);

                    
                    this.rootCtrl.updateContent(frame, this._startParams.n, isBack);

                    
                    updateLastOpenedList.call(this);

                } else {
                    
                    this.doNotRefresh = true;
                    this.prevController.makeCurrent(isBack);
                }
            },

            onExecuteNewObject: function onExecuteNewObject(params) {
                
                var subtype = (params.objType === OBJECT_TYPE_REPORT) ? 768 : 14081;

                
                this.spawn(mstrApp.controllerFactory.newController(this.getViewKey(subtype), {
                    st : subtype
                }), params);
            },

            onDrill: function onDrill(params) {
                
                this.spawn(mstrApp.controllerFactory.newController(this.getViewKey(TYPE_REPORT)), $HASH.copy(params, {
                    action: (this.ctrlType === TYPE_REPORT) ? 'drillGrid' : 'drill2Grid',
                    st: TYPE_REPORT
                }));
            },

            goUp: function goUp() {
                
                if (!this._super()) {
                    
                    var folderController = this.getController('ctrlType', 2048);
                    if (folderController) {
                        
                        folderController.makeCurrent(true);
                    } else {
                        
                        this.rootCtrl.goHome();
                    }
                }

                
                return true;
            },

            
            updateActionToolbar: function updateActionToolbar(tbCfg) {
            	if (mstrApp.getConfiguration().isMenuAllowed(MNU_SHARE, MNU_SHARE)) {
            		
            		if (mstrMobileApp['getSDKVersion']() >= 11) {
            			tbCfg.addToolbarBtn(MNU_ANNOTATION, mstrmojo.desc(11191, 'Annotation'), MNU_ANNOTATION, false, 24);
                	}
            		
                    
                	tbCfg.addToolbarBtn(MNU_SHARE, mstrmojo.desc(9099, 'Share'), MNU_SHARE, false, 22);
                }

                
                tbCfg.addMenuItem(MNU_ABOUT, mstrmojo.desc(1142, 'About'), MNU_ABOUT, false, 23);

                
                tbCfg = this._super(tbCfg);

                
                if (this.frame && this.frame.delegateToolbar(tbCfg)) {
                    
                    tbCfg = mstrmojo.android.ui.ActionToolbar.newToolbarConfig();
                }

                
                return tbCfg;
            },

            handleMenuItem: function handleMenuItem(group, cmdId) {
                switch (group) {
                case MNU_ABOUT:
                    this.rootCtrl.updateItemProperties('', {
                        ttl: this.ttl,
                        st: this.st,
                        
                        did: this.did || this.getDepth(),
                        pid: this.pid,
                        desc: this.desc,
                        propsPopup: true
                    }, this.id, false);
                    return;

                case MNU_SHARE:
                    this.share('', false);

                    return;

                case MNU_FULLSCREEN:
                    
                    this[((cmdId === 11) ? 'enter' : 'exit') + 'FullScreen']();
                    return;

                case MNU_ANNOTATION:
                	this.startAnnotate();
                	return;
                }

                return this._super(group, cmdId);
            },

            beforeViewHidden: function beforeViewHidden(isBack) {
                this._super(isBack);

                
                var view = this.view;
                if (view && view.beforeViewHidden) {
                    
                    view.beforeViewHidden(isBack);
                }

                
                if (this.isFullScreen) {
                    
                    this.exitFullScreen(true, isBack);
                }

            },

            afterViewVisible: function afterViewVisible(isBackOperation) {

                this._super(isBackOperation);








                
                if (this.isFullScreen || !!this.model.fs || !!this.model.data.fs) {
                    
                    this.enterFullScreen();
                }
                
                else if (mstrMobileApp['getSDKVersion']() >= 16)
                {
                    window.setTimeout(function () {
                        mstrMobileApp.clearWebViewCache(false);
                    }, 100);
                }

                
                mstrMobileApp.hideProgress();

                
                if (!isBackOperation) {
                    
                    var id = this.id;
                    window.setTimeout(function () {
                        
                        var ctrl = mstrmojo.all[id];
                        if (ctrl && ctrl.rootCtrl.getCurrent() === ctrl) {
                            
                            ctrl.takeScreenShot();
                        }
                    }, 300);
                }
            },

            takeScreenShot: function takeScreenShot() {
                

                var view = this.view,
                    position = (view.getCaptureDimensions && view.getCaptureDimensions()) || $DOM.position(view.domNode),
                    windowDim = $DOM.windowDim(),
                    
                    id = this.did || this.getDepth(),
                    projId = mstrApp.getCurrentProjectId();

                
                $AFE(mstrmojo.android.ui.PropertiesView.getPreviewSizes(), function (preview) {
                    
                    mstrMobileApp.takeScreenShot(JSON.stringify({
                        pid: projId,
                        dssId: id,
                        x: position.x,
                        y: position.y,
                        w: Math.max(position.w, preview.w),
                        h: Math.max(position.h, preview.h),
                        pw: preview.w,
                        ph: preview.h,
                        ww: windowDim.w,
                        wh: windowDim.h
                    }));
                });
            },

            
            addFullScreenButton: function addFullScreenButton(tbCfg) {
                
                var lbl = mstrmojo.desc(8430, 'Enter Fullscreen'),
                    icon = 11;

                
                if (this.isFullScreen) {
                    
                    lbl = mstrmojo.desc(8429, 'Exit Fullscreen');
                    icon = 10;
                }

                
                tbCfg.addToolbarBtn(MNU_FULLSCREEN, lbl, icon, false, icon);
            },

            
            enterFullScreen: function enterFullScreen() {
                
                this.frame.enterFullScreen();

                
                this.rootCtrl.enterFullScreen();

                
                this.isFullScreen = true;

                
                this.generateActionToolbar();

                
                mstrmojo.touchManager.raiseEvent({
                    name: 'fullScreenStateChange'
                });
            },

            
            exitFullScreen: function exitFullScreen(noAnimation, isBack) {
                
                this.isFullScreen = false;

                
                this.frame.exitFullScreen(!noAnimation);

                
                this.rootCtrl.exitFullScreen(!noAnimation, isBack);

                
                this.generateActionToolbar();

                
                mstrmojo.touchManager.raiseEvent({
                    name: 'fullScreenStateChange'
                });
            },

            
            viewTap: function viewTap() {
                
                if (this.isFullScreen) {
                    
                    this.frame.flashFullScreen();

                    
                    this.rootCtrl.flashFullScreen();
                }
            },

            
            cancelFlashFullScreen: function cancelFlashFullScreen() {
                this.frame.cancelFlashFullScreen();

                this.rootCtrl.cancelFlashFullScreen();
            },

            
            getMagnifierConfig: function getMagnifierConfig() {
                var curtainPosition = this.frame.getPosition();
                return {curtainPosition: curtainPosition};
            },

            
            share: function share(subject, useDefault) {
            	var viewCaptureConfig = getViewCaptureConfig.call(this),
            		ttl = this.ttl;

            	window.setTimeout(function () {
            		mstrMobileApp.takeScreenShotAndSend(viewCaptureConfig, JSON.stringify({
            			attachmentName: mstrmojo.string.decodeHtmlString(ttl),
            			subject: subject,
            			useDefault: useDefault
                    }));
                }, 100);
            },

            
            getBottomToolBarHeight: function getBottomToolBarHeight() {

                return (!mstrApp.isTablet() && !this.isFullScreen && !mstrApp.isLandscape()) ?
                                (Math.round(BOTTOM_ACTION_TOOLBAR_HEIGHT_160_DPI * mstrMobileApp.getDeviceDPI() / 160)) :
                                0;
            },

            
            startAnnotate: function startAnnotate() {
            	if (!!this.ignoreAnnotationMenuItem) {
            		return;
            	}
            	
            	
            	this.ignoreAnnotationMenuItem = true;
            	
            	mstrMobileApp.showProgress([mstrmojo.desc(8445, 'Loading')], false );
            	
            	var viewCaptureConfig = getViewCaptureConfig.call(this),
            		me = this;
            	window.setTimeout(function () {
            		mstrMobileApp.startAnnotate(viewCaptureConfig, mstrmojo.string.decodeHtmlString(me.ttl),
            				'javascript:mstrmojo.all.' + me.id + '.onAnnotationFinished()');
            	}, 100);
            },
            
            
            onAnnotationFinished: function onAnnotationFinished() {
            	
            	this.ignoreAnnotationMenuItem = false;
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ViewController",
                         "mstrmojo.android.SimpleList",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.string",
                         "mstrmojo.num");

    mstrmojo.requiresDescs(11, 16, 17, 18, 37, 187, 295, 629, 702, 784, 844, 845, 874, 1088, 1142, 1563, 1900, 1905, 2411, 2461, 2822, 3157, 4253, 5191, 6560, 7227, 7559, 7561, 7778, 7779, 7831, 7840, 8027, 8360, 8361, 8362, 8363, 8364, 8365, 8366, 8367, 8368, 8369, 8370, 8371, 8372, 8373, 8374, 8375, 8376, 8377, 8378, 8379, 8390, 8441, 8447, 8455, 8456, 8457, 8458, 8459, 8489, 8633, 8634, 8635, 8760, 9446, 9447, 9448, 9449, 9450, 9451, 9452, 9456, 9457, 9458, 9459, 9460, 9464, 9465, 9466, 9467, 9468, 9469, 9470, 9471, 9481, 9790, 9791, 9792, 9793, 9794, 9795, 9796, 9797, 9807);

    var $ARR = mstrmojo.array,
        $HASH = mstrmojo.hash,
        $BTN = mstrmojo.android.ui.Button.newButton,
        $DESC = mstrmojo.desc,
        MENUS = mstrmojo.android.EnumMenuOptions,
        MENU_DELETE = MENUS.DELETE,
        MENU_ADD_SERVER = MENUS.ADD_SERVER,
        MENU_ADD_PROJECT = MENUS.ADD_PROJECT,
        MENU_ABOUT = MENUS.ABOUT,
        legalText;

    
    var STYLE_HEADER = 1,
        STYLE_BUTTON = 2,
        STYLE_VIEW_BUTTON = 3,
        STYLE_TEXT = 4,
        STYLE_LIST = 5,
        STYLE_CHECK = 6,
        STYLE_IMAGE = 7,
        STYLE_TEXT_AREA = 8,
        STYLE_NUMBER = 9,
        STYLE_TIME = 10;

    
    var TYPE_HOME = 1,
        TYPE_SERVERS = 2,
        TYPE_EDIT_SERVER = 3,
        TYPE_SERVER_CREDS = 4,
        TYPE_EDIT_PROJECT = 5,
        TYPE_PROJECT_CREDS = 6,
        TYPE_GENERAL = 7,
        TYPE_ABOUT = 8,

        TYPE_LEGAL = 10,
        TYPE_CERT = 12,
        TYPE_CERT_AUTH = 12,
        TYPE_TRUSTED_CERTS = 13;

    
    var DELETE_TXT = {};
    DELETE_TXT[TYPE_EDIT_SERVER] = 5191; 
    DELETE_TXT[TYPE_EDIT_PROJECT] = 11;  

    
    var ADD_TXT = {};
    ADD_TXT[TYPE_SERVERS] = 5191;          
    ADD_TXT[TYPE_EDIT_SERVER] = 11;        

    
    var MEMORY_LIMIT_LIST = [{
            v: 25,
            n: '25MB'
        }, {
            v: 50,
            n: '50MB'
        }, {
            v: 100,
            n: '100MB'
        }, {
            v: 250,
            n: '250MB'
        }, {
            v: 500,
            n: '500MB'
        }, {
            v: 1024,
            n: '1GB'
        }, {
            v: 2048,
            n: '2GB'
        }, {
            v: 3072,
            n: '3GB'
        }, {
            v: 4096,
            n: '4GB'
        }];

    function getHourString(v) {
        return $DESC(9797, 'Every ## hours').replace('##', v);
    }

    var UPDATE_INTERVAL = [{
            v: 1,
            n: $DESC(9796, 'Every hour')
        }, {
            v: 2,
            n: getHourString(2)
        }, {
            v: 4,
            n: getHourString(4)
        }, {
            v: 10,
            n: getHourString(10)
        }, {
            v: 24,
            n: getHourString(24)
        }];

    
    var MODIFIED_ITEMS = {};

    
    function getNewServerNode() {
        return {
            nm: '',
            po: 80,
            pt: 'MicroStrategyMobile',
            ty: 1,
            rt: 0,
            udc: true,
            wsc: {
                am: 1,
                lo: '',
                ps: ''
            },
            pdc: {
                am: 1,
                lo: '',
                ps: ''
            },
            pl: [],
            isNew: true
        };
    }

    
    function getNewProjectNode() {
        return {
            pc: {
                am: 0,
                lo: '',
                ps: ''
            },
            pn: '',
            sn: '',
            sp: 0,
            udc: false,
            isNew: true
        };
    }

    
    function updateView(viewInfo, items) {

        
        if (items) {
            
            viewInfo.items = items;
        } else {
            
            items = viewInfo.items;
        }

        var view = this.view.getList(viewInfo.cfg.isHome),
            rootCtrl = this.rootCtrl;

        
        view.restoreListState(viewInfo.idx, viewInfo.origin);

        
        view.items = items;

        
        view.refresh();

        
        if (mstrApp.isTablet() && viewInfo.cfg.isHome) {
            
            if (!viewInfo.idx) {
                
                view.singleSelect(0);
            }
        }

        
        rootCtrl.updateContent(null, (mstrApp.isTablet()) ? $DESC(7831, 'Settings') : viewInfo.title);

        
        rootCtrl.contentUpdated('Settings');

        
        this.generateActionToolbar();
    }

    
    function generateView(fnView, item) {
        
        var viewInfo = fnView.call(this, item);

        
        this.view.getList(viewInfo.cfg.isHome).resetListState();

        
        viewInfo.cfg.fnRedraw = fnView;

        
        this._viewInfos.push(viewInfo);

        
        updateView.call(this, viewInfo);
    }

    
    function getLastViewInfo() {
        var views = this._viewInfos;
        return views[views.length - 1];
    }

    
    function getCurrentConfig() {
        var viewInfo = getLastViewInfo.call(this);
        return viewInfo && viewInfo.cfg;
    }

    
    function cacheViewState(idx) {
        
        var lastViewInfo = getLastViewInfo.call(this);
        lastViewInfo.idx = idx;
        lastViewInfo.origin = this.view.getList(lastViewInfo.cfg.isHome).getScrollPos();
    }

    
    function showCurrentView() {
        
        var current = getLastViewInfo.call(this),
            cfg = current.cfg;

        
        updateView.call(this, current, cfg.fnRedraw.call(this, cfg.item).items);

        
        this.view.getList(cfg.isHome).restoreListState(current.idx, current.origin);
    }

    
    function confirmDelete(itemName, fnOk) {
        
        mstrmojo.confirm($DESC(8390, 'Are you sure you want to delete #?').replace('#', itemName), [ $BTN($DESC(1442, 'OK'), fnOk), $BTN($DESC(221, 'Cancel')) ]);
    }

    
    function deleteItem(item) {
        
        var me = this;
        confirmDelete(item.nm, function () {

            
            var mobileConfig = me.mobileConfigObj,
                cfg = getCurrentConfig.call(me),
                servers = mobileConfig.getWebServersList(),
                collection = (cfg.type === TYPE_SERVERS) ? servers : servers[cfg.idx].pl;

            
            collection.splice(item.idx, 1);

            
            me.view.getList(cfg.isHome).set('items', cfg.fnRedraw.call(me, cfg.item).items);

            me.mobileConfigObj.reconcileHomescreen();

            
            me.mobileConfigObj.saveConfiguration();

            
            me.connectivityChanged = true;
        });
    }

    
    function showPopup(item) {
        var controller = this,
            dialog;

        
        dialog = mstrApp.showDialog({
            title: item.nm,
            cssClass: 'mstrmojo-SimpleOptions',
            children: [{
                scriptClass: 'mstrmojo.android.SimpleList',
                isElastic: true,
                items: [{
                    n: $DESC(1088, 'Edit'),
                    v: 1
                }, {
                    n: $DESC(629, 'Delete'),
                    v: 2
                }],
                postselectionChange: function (evt) {
                    
                    dialog.close();

                    
                    if (this.items[evt.added[0]].v === 1) {
                        
                        item.fn();

                    } else {
                        
                        deleteItem.call(controller, item);
                    }
                }
            }]
        });
    }

    
    function convertListToItems(list) {
        
        var rtn = [],
            x = -1;

        
        $ARR.forEach(list, function (n, idx) {
            
            if (n) {
                
                rtn[++x] = {
                    n: n,
                    v: idx
                };
            }
        });

        return rtn;
    }

    
    function editItem(item, value, node) {
        var cfg = getCurrentConfig.call(this),
            type = cfg.type,
            path = item.pt.split('.'),
            prop = path.pop(),
            mobileConfig = this.mobileConfigObj,
            servers = mobileConfig.getWebServersList();

        switch (type) {
        case TYPE_EDIT_SERVER:
            
            node = servers[cfg.idx];

            
            if (!node) {
                
                node = getNewServerNode();

                
                servers.push(node);

                
                this.connectivityChanged = true;
            }
            break;

        case TYPE_EDIT_PROJECT:
            
            var serverNode = servers[cfg.parent.idx],
                projects = serverNode.pl || [];

            
            node = projects[cfg.idx];

            
            if (!node) {
                
                node = getNewProjectNode();

                
                
                this.mobileConfigObj.setPid(node);

                
                projects.push(node);

                
                this.connectivityChanged = true;
            }
            break;

        case TYPE_GENERAL:
            
            node = mobileConfig.getGeneralSettings();

            
            if (prop === 'am' || prop === 'lo' || prop === 'ps') {
                
                node = mobileConfig.getDefaultServerCreds();
            } else if (prop === 'ebs' || prop === 'tod' || prop === 'ui' || prop === 'wo' || prop === 'co') {
                
                node = mobileConfig.getBackgroundSyncSettings();
            }
            break;

        case TYPE_CERT:
        case TYPE_CERT_AUTH:
        case TYPE_TRUSTED_CERTS:
            break;

        default:
            throw new Error('AndroidSettingsController::editItem -- Unhandled edit action.');
        }

        
        if (path.length) {
            
            node = $HASH.walk(path.join('.'), node);
        }

        
        var oldValue = node[prop];
        if (oldValue !== value) {
            
            node[prop] = value;

            
            item.v = value;

            
            var mods = MODIFIED_ITEMS[type] || {};

            
            mods[item.pt.replace('.', '@')] = item;

            
            MODIFIED_ITEMS[type] = mods;

            
            $ARR.forEach(item.dependents, function (dependentItem) {
                
                $ARR.forEach([ 'Hidden', 'Disabled' ], function (prop) {
                    
                    var fnDependent = dependentItem['fn' + prop];
                    if (fnDependent) {
                        
                        dependentItem[prop.toLowerCase()] = fnDependent(value);
                    }
                });
            });

            
            if (prop === "lo" || prop === "ps") {
                
                node.um = true;
            }
        }
    }

    
    function newImage(props) {
        return $HASH.copy(props, {
            nm: '',
            style: STYLE_IMAGE
        });
    }

    
    function newHeader(text, props) {
        return $HASH.copy(props, {
            nm: text,
            style: STYLE_HEADER
        });
    }

    
    function newItem(title, value, style, props) {
        return $HASH.copy(props, {
            nm: title,
            v: value,
            style: style
        });
    }

    
    function newBtnItem(title, value, fnClick, props) {
        var controller = this;

        return newItem(title, value, STYLE_BUTTON, $HASH.copy({
            fn: function () {
                
                fnClick.call(controller);
            }

        }, props));
    }

    
    function newViewItem(title, value, fnView, props) {
        var controller = this;

        return newItem(title, value, STYLE_VIEW_BUTTON, $HASH.copy({
            fn: function () {
                
                cacheViewState.call(controller, this._renderIdx);

                
                generateView.call(controller, fnView, this);
            }
        }, props));
    }

    
    function newEditItem(title, style, node, path, props) {
        var controller = this;

        return newItem(title, $HASH.walk(path, node), style, $HASH.copy({
            pt: path,
            fn: function (value) {
                editItem.call(controller, this, value, node);
            }
        }, props));
    }

    
    function newListItem(title, node, path, items, props) {
        return newEditItem.call(this, title, STYLE_LIST, node, path, $HASH.copy({
            items: items
        }, props));
    }

    
    function newCheckItem(title, description, node, path, on, off, props) {
        return newEditItem.call(this, title, STYLE_CHECK, node, path, $HASH.copy({
            desc: description,
            on: on,
            off: off
        }, props));
    }

    
    function ellipsizeHeaderText(text, ellipsize) {
        return ellipsize ? mstrmojo.string.ellipsize(text, 20) : text;
    }

    
    function addTabletHeader(items, title, ellipsize) {
        
        if (mstrApp.isTablet()) {
            
            var headerTitle = [];
            $ARR.forEach(this._viewInfos, function (info, idx) {
                
                if (idx && info.title !== title) {
                    
                    headerTitle.push('<div hidx="' + idx + '">' + ellipsizeHeaderText(info.title, (idx > 1 && ellipsize)) + '</div>');
                }
            });

            
            headerTitle.push('<em>' + ellipsizeHeaderText(title, ellipsize) + '</em>');

            
            items = [ newHeader(headerTitle.join(''), {
                cls: 'tablet-header'
            }) ].concat(items);
        }

        
        return items;
    }

    
    function validateServerChanges(cfg, mods) {
        var servers = this.mobileConfigObj.getWebServersList(),
            server = servers[cfg.idx],
            serverCreds = server.wsc,                           
            serverAuth = serverCreds.am,                        
            projects = server.pl,
            isNewServer = server.isNew;

        
        if (isNewServer && !mods.nm) {
            
            servers.splice(cfg.idx, 1);

            
            return false;
        }

        
        delete server.isNew;

        
        if (mods.nm || mods.po || mods.pt || mods.ty) {
            
            $ARR.forEach(projects, function (project) {
                mstrApp.removeProjectCaches(project);
            });
        } else {
            
            if (mods['wsc@lo'] && (mods['wsc@am'] || (serverAuth === 2 || serverAuth === 3))) {        
                var projectDefaultAuth = server.pdc.am;

                
                $ARR.forEach(projects, function (project) {
                    
                    var projectAuth = (project.udc) ? projectDefaultAuth : project.pc.am;

                    
                    if (projectAuth === 2 || projectAuth === 64) {
                        
                        mstrApp.removeProjectCaches(project);
                    }
                });
            }
        }

        
        server.udc = (!serverAuth);

        
        if (!serverAuth) {
            
            serverCreds.lo = '';
            serverCreds.ps = '';
        }

        
        this.mobileConfigObj.setWebServerList(servers);

        
        return (isNewServer || !!mods.nm);
    }

    
    function validateProjectChanges(cfg, mods) {
        var servers = this.mobileConfigObj.getWebServersList(),
            projects = servers[cfg.parent.idx].pl,
            project = projects[cfg.idx],
            projectCreds = project.pc,                             
            projectAuth = projectCreds.am,                         
            isNewProject = project.isNew;

        
        if (isNewProject && (!mods.pn || !mods.sn)) {
            
            projects.splice(cfg.idx, 1);

            
            return false;
        }

        
        delete project.isNew;

        
        if (!isNewProject && (mods.pn || mods.sn || mods['pc@am'] || (projectAuth > 0 && mods.lo))) {
            
            mstrApp.removeProjectCaches(project.pid);

            
            
            this.mobileConfigObj.setPid(project);

            
            this.connectivityChanged = true;
        }

        
        project.udc = (!projectAuth);

        
        if (!projectAuth) {
            
            projectCreds.lo = '';
            projectCreds.ps = '';
        }

        
        return (isNewProject || !!mods.pn || !!mods.sn);
    }

    
    function validateGeneralSettingsChanges(cfg, mods) {
        var mobileConfig = this.mobileConfigObj,
            creds = mobileConfig.getDefaultServerCreds(),
            isAnonymousMode = (creds.am === 1);

        
        if (mods.am || (mods.lo && !isAnonymousMode)) {
            
            $ARR.forEach(mobileConfig.getWebServersList(), function (server) {
                
                if (server.udc) {
                    
                    var defaultProjAuth = server.pdc.am;

                    
                    $ARR.forEach(server.pl, function (project) {
                        
                        var projAuthMode = (project.udc) ? defaultProjAuth : project.pc.am;

                        
                        if (projAuthMode === 2 || projAuthMode === 64) {
                            mstrApp.removeProjectCaches(project.pid);
                        }
                    });
                }
            });
        }

        
        if (isAnonymousMode) {
            
            creds.lo = '';
            creds.ps = '';
        }

        
        return false;
    }

    
    function newAuthenticationItems(type, node) {

        var path = '',
            fnDisabled = mstrmojo.emptyFn,
            items;

        
        if (type === TYPE_EDIT_SERVER || type === TYPE_SERVER_CREDS) {
            
            items = convertListToItems([ $DESC(8441, 'Default'), $DESC(7778, 'Anonymous'), $DESC(7227, 'Basic'), $DESC(7779, 'Windows'),  $DESC(8027, 'Trusted') ]);

            
            if (type === TYPE_EDIT_SERVER) {
                
                path = 'wsc';
            }

            
            fnDisabled = function (v) {
                return (v < 2 || v === 64);
            };

            
            
            if ((type !== TYPE_SERVER_CREDS) && node.udc) {
                node[path].am = 0;
            }

        } else {
            
            items = [{
                n: $DESC(8441, 'Default'),
                v: 0
            }, {
                n: $DESC(3157, 'Standard'),
                v: 1
            }, {
                n: $DESC(7779, 'Windows'),
                v: 2
            }, {
                n: 'LDAP',
                v: 16
            }, {
                n: $DESC(1563, 'Database'),
                v: 32
            }, {
                n: mstrmojo.desc(8027, 'Trusted'),
                v: 64
            }];

            
            path = (type === TYPE_PROJECT_CREDS) ? 'pdc' : 'pc';

            
            fnDisabled = function (v) {
                
                return (!v || parseInt(v, 10) === 2 || parseInt(v, 10) === 64);
            };

            
            
            if ((type !== TYPE_PROJECT_CREDS) && node.udc) {
                node[path].am = 0;
            }
        }

        
        if (type === TYPE_SERVER_CREDS || type === TYPE_PROJECT_CREDS) {
            
            items.shift();
        }

        
        path = (path && path + '.') || '';

        
        var cfgLogin = {
                disabled: fnDisabled($HASH.walk(path + 'am', node)),
                fnDisabled: fnDisabled
            },
            userName = newEditItem.call(this, $DESC(17, 'User Name'), STYLE_TEXT, node, path + 'lo', cfgLogin),
            
            pwd = newEditItem.call(this, $DESC(18, 'Password'), STYLE_TEXT, node,  path + 'ps', $HASH.copy(cfgLogin, {
                pwd: true
            })),
            rtn = [];

        
        rtn.push(newListItem.call(this, $DESC(2822, 'Authentication'), node, path + 'am', items, {
            dependents: [ userName, pwd ]
        }));

        
        rtn.push(userName);
        rtn.push(pwd);

        return rtn;
    }

    
    function getEditProjectView(item) {
        var idx = item.idx,
            settingsCfg = getCurrentConfig.call(this),
            server = this.mobileConfigObj.getWebServersList()[settingsCfg.idx] || getNewServerNode(),
            project = server.pl[idx] || getNewProjectNode(),
            items = [];

        
        items.push(newEditItem.call(this, $DESC(11, 'Project'), STYLE_TEXT, project, 'pn', {
            showHint: true
        }));
        items.push(newEditItem.call(this, $DESC(5191, 'Server'), STYLE_TEXT, project, 'sn', {
            showHint: true
        }));

        
        items = items.concat(newAuthenticationItems.call(this, TYPE_EDIT_PROJECT, project));

        
        return {
            title: item.nm,
            items: addTabletHeader.call(this, items, item.nm, true),
            cfg: {
                type: TYPE_EDIT_PROJECT,
                item: item,
                idx: idx,
                parent: settingsCfg,
                fnVal: validateProjectChanges
            }
        };
    }

    
    function getEditServerView(item) {
        var controller = this,
            serverIndex = item.idx,
            server = this.mobileConfigObj.getWebServersList()[serverIndex] || getNewServerNode(),
            projects = server.pl || [],
            items = [];

        
        server.pl = projects;

        
        items.push(newEditItem.call(this, $DESC(7559, 'Name'), STYLE_TEXT, server, 'nm', {
            showHint: true
        }));

        items.push(newEditItem.call(this, $DESC(16, 'Port'), STYLE_NUMBER, server, 'po', {
            limits: {
                min: 0,
                max: 65535
            }
        }));
        items.push(newEditItem.call(this, $DESC(8489, 'Path'), STYLE_TEXT, server, 'pt'));
        items.push(newListItem.call(this, $DESC(8362, 'Web server type'), server, 'ty', convertListToItems([ 'J2EE', 'ASP.Net' ])));
        items.push(newCheckItem.call(this, $DESC(8363, 'Secure HTTP'), $DESC(9449, 'Use HTTPS to access the mobile server'), server, 'rt', 1, 0));

        
        items = items.concat(newAuthenticationItems.call(this, TYPE_EDIT_SERVER, server));

        
        items.push(newHeader($DESC(8364, 'Default Project Credentials')));
        items = items.concat(newAuthenticationItems.call(this, TYPE_PROJECT_CREDS, server));

        
        items.push(newHeader($DESC(37, 'Projects')));

        
        $ARR.forEach(projects, function (project, idx) {
            items.push(newViewItem.call(controller, project.pn, project.sn, getEditProjectView, {
                idx: idx,
                fnPress: showPopup
            }));
        });

        
        return {
            title: item.nm,
            items: addTabletHeader.call(this, items, item.nm, true),
            cfg: {
                type: TYPE_EDIT_SERVER,
                item: item,
                idx: serverIndex,
                parent: getCurrentConfig.call(this),
                fnVal: validateServerChanges
            }
        };
    }

    
    function getLegalView() {
        var items = [],
            title = $DESC(8365, 'Legal');

        if (!legalText) {
            legalText = "<p>" + $DESC(8633) + "</p>" + "<p>" + $DESC(8634) + "</p>" + "<p>" + $DESC(8635) + "</p>";
        }
        items.push(newItem(legalText, "", STYLE_TEXT_AREA, {
            noclick: true
        }));

        
        return {
            title: title,
            items: addTabletHeader.call(this, items, title),
            cfg: {
                type: TYPE_LEGAL
            }
        };
    }

    
    function getAboutView() {
        var items = [],
            title = mstrApp.isTablet() ? $DESC(1142, 'About') : $DESC(9457, 'About #').replace('#', 'MicroStrategy');

        items.push(newImage.call(this, {
            noclick: true,
            cls: 'mstr-logo'
        }));

        items.push(newItem.call(this, 'MicroStrategy Mobile 9.4.0', $DESC(8366, 'Build Number #').replace('#', mstrMobileApp.getAppVersion()), STYLE_BUTTON, {
            cls: 'build-info',
            noclick: true
        }));

        items.push(newHeader($DESC(9456, 'More Information'), {
            cls: 'more-info'
        }));
        items.push(newViewItem.call(this, $DESC(8365, 'Legal'), $DESC(9460, 'Copyright disclosure'), getLegalView));
        items.push(newBtnItem.call(this, $DESC(9458, 'Get in touch'), $DESC(9459, 'Send us an email with your feedback, suggestions and appreciation!'), function () {
            var bodyMsg = [ $DESC(9465, 'I was looking through the MicroStrategy Mobile Android App. Please contact me with details on how I can:') ];
            bodyMsg.push($DESC(9466, ' - Find out how I can use MicroStrategy Apps to drive my business.'));
            bodyMsg.push($DESC(9467, ' - Have apps, based on my workflow, specifications and design, in two weeks.'));
            bodyMsg.push($DESC(9468, ' - How I can partner with MicroStrategy for all my Mobile solutions.'));
            bodyMsg.push($DESC(9469, ' - Attend a free, hands-on, class to teach developers how to build and maintain Mobile Business Apps.'));
            bodyMsg.push('');
            bodyMsg.push($DESC(9470, 'Thank you.'));

            
            mstrMobileApp.sendEmail('info@microstrategy.com', $DESC(9464, 'Request information about MicroStrategy Mobile'), bodyMsg.join('\r\n'), '');
        }));

        
        return {
            title: title,
            items: addTabletHeader.call(this, items, title),
            cfg: {
                type: TYPE_ABOUT
            }
        };
    }

    
    function getBackgroundSyncingItems() {
        var settings = this.mobileConfigObj.getBackgroundSyncSettings(),
            fnDisabled = function (v) {
                return (!v || v === false);
            },
            depProps = {
                disabled: fnDisabled($HASH.walk('ebs', settings)),
                fnDisabled: fnDisabled
            },
            timeOfDay = newEditItem.call(this, $DESC(9807, 'Time of day'), STYLE_TIME, settings, 'tod'),
            updateInterval = newListItem.call(this, $DESC(9792, 'Update interval'), settings, 'ui', UPDATE_INTERVAL, $HASH.copy(depProps, {
                dependents: [timeOfDay]
            })),
            wifi = newCheckItem.call(this, $DESC(9793, 'Only over Wi-Fi'), null, settings, 'wo', true, false, depProps),
            charge = newCheckItem.call(this, $DESC(9794, 'Only if charging'), null, settings, 'co', true, false, depProps),
            enable = newCheckItem.call(this, $DESC(9795, 'Enable background syncing'), null, settings, 'ebs', true, false, {
                dependents: [updateInterval, timeOfDay, wifi, charge, timeOfDay]
            }),
            items = [];

        
        items.push(enable);
        items.push(updateInterval);
        items.push(timeOfDay);
        items.push(wifi);
        items.push(charge);

        
        timeOfDay.disabled = updateInterval.disabled || (updateInterval.v !== 24);
        timeOfDay.fnDisabled = function () {
            return (enable.v !== true) || (updateInterval.v !== 24);
        };

        return items;
    }

    function deleteCertificate(item) {
        var controller = this;
        confirmDelete(item.nm, function () {
            
            mstrApp.showMessage('Deleting...');


            window.setTimeout(function () {
                var cfg = getCurrentConfig.call(controller);

                
                mstrMobileApp.deleteCertificate();

                
                item.hidden = !mstrMobileApp.hasCertificate();

                
                $ARR.forEach(item.dependents, function (d) {
                    d.hidden = !item.hidden;
                });

                
                controller.view.getList(cfg.isHome).set('items', cfg.fnRedraw.call(controller, cfg.item).items);

                
                mstrApp.hideMessage();
            }, 100);
        });
    }

    function showPopupDeleteCertificate(item) {
        var controller = this,
            dialog;

        dialog = mstrApp.showDialog({
            title: item.nm,
            cssClass: 'mstrmojo-SimpleOptions',
            children: [{
                scriptClass: 'mstrmojo.android.SimpleList',
                isElastic: true,
                items: [{
                    n: $DESC(1900, 'View'),
                    v: 1
                }, {
                    n: $DESC(629, 'Delete'),
                    v: 2
                }],
                postselectionChange: function (evt) {
                    dialog.close();
                    if (this.items[evt.added[0]].v === 1) {
                        item.fn();
                    } else if (this.items[evt.added[0]].v === 2) {
                        deleteCertificate.call(controller, item);
                    }
                }
            }]
        });
    }

    
    function getCertificateDetailsView(item) {
        var detailsStr = mstrMobileApp.getCertificateDetails(),
            details = eval('(' + detailsStr + ')'),
            items = [],
            result = "",
            i;

        if (details.prs) {
            for (i = 0; i < details.prs.pr.length; ++i) {
                var pr = details.prs.pr[i];
                var name;

                if (pr.n === "edat") {
                    name = $DESC(8457, 'Expiration');
                } else if (pr.n === "issr_n") {
                    name = $DESC(8458, 'Issuer');
                } else {
                    name = pr.n;
                }
                result += name + ": " + pr.v + "<br/>";
            }
            items.push(newItem.call(this, result, "", STYLE_TEXT_AREA, {
                disabled: true
            }));
            return {
                title: item.nm,
                items: addTabletHeader.call(this, items, item.nm),
                cfg: {
                    type: TYPE_CERT,
                    item: item
                }
            };
        }

        throw details.message || 'No certificate details available';
    }

    
    function getTrustedCertificatesView(item) {
        var result = mstrMobileApp.getTrustedCertificates(),
            jsonResult = eval('(' + result + ')'),
            items = [],
            i;

        if (jsonResult && jsonResult.certs) {
            for (i = 0; i < jsonResult.certs.length; ++i) {
                var cert = jsonResult.certs[i].dsc;

                items.push(newItem(cert, "", STYLE_TEXT_AREA, {
                    disabled: true
                }));
            }
        }
        return {
            title: item.nm,
            items: addTabletHeader.call(this, items, item.nm),
            cfg: {
                type: TYPE_TRUSTED_CERTS,
                item: item
            }
        };
    }

    
    function getCertificateAuthenticationFieldsView(item) {
        var result = mstrMobileApp.getCertificateAuthenticationFields(),
            jsonResult = eval('(' + result + ')'),
            items = [],
            controller = this,
            i = 0;

        if (jsonResult.login_info) {
            var settings = {},
                loginInfoField = jsonResult.login_info.field;

            for (i = 0; i < loginInfoField.length; ++i) {
                var field = loginInfoField[i],
                    cfgAuth = {};

                settings[field.n] = "";
                if (!!field.pass) {
                    cfgAuth = $HASH.copy(cfgAuth, {
                        pwd: true
                    });
                }

                items.push(newEditItem.call(this, field.dn, ((field.tp === "numeric") ? STYLE_NUMBER : STYLE_TEXT), settings, field.n, cfgAuth));
            }
            
            items.push(newItem.call(this, "Submit", "", STYLE_BUTTON, {
                fn: function () {

                    
                    mstrApp.showMessage();

                    
                    window.setTimeout(function () {
                        
                        var responseStr = mstrMobileApp.getNewCertificate(JSON.stringify(settings));

                        
                        mstrApp.hideMessage();

                        
                        var response = eval('(' + responseStr + ')'),
                            message = response.message;
                        if (message) {
                            
                            window.alert(response.message);

                        } else {
                            
                            window.alert("Certificate obtained");

                            
                            if (item && item.nm === "Get Certificate") {
                                
                                item.hidden = mstrMobileApp.hasCertificate();

                                
                                $ARR.forEach(item.dependents, function (d) {
                                    d.hidden = !d.hidden;
                                });
                            }

                            
                            
                            
                            mstrApp.goBack();
                        }

                    }, 100);
                }
            }));

            var title = jsonResult.login_info.msg;

            return {
                title: title,
                items: addTabletHeader.call(this, items, title),
                cfg: {
                    type: TYPE_CERT_AUTH,
                    item: item
                }
            };
        }

        throw new Error(jsonResult.message);
    }

    
    function getGeneralSettingsView(item) {
        var mobileConfig = this.mobileConfigObj,
            generalSettings = mobileConfig.getGeneralSettings(),
            items = [];

        items.push(newEditItem.call(this, $DESC(8367, 'Network Timeout (seconds)'), STYLE_NUMBER, generalSettings, 'nt', {
            limits: {
                min: 0,
                max: 9999
            }
        }));

        items.push(newEditItem.call(this, $DESC(7840, 'Maximum Columns in Grid'), STYLE_NUMBER, generalSettings, 'mgc', {
            limits: {
                min: 0,
                max: 9999
            }
        }));

        
        if (generalSettings.usd) {
            var diagnosticMode = newCheckItem.call(this, $DESC(8760, 'Diagnostic Mode'), $DESC(9450, 'Store a log file in the device'), {
                b: mobileConfig.getDiagnosticMode()
            }, 'b', true, false);

            
            diagnosticMode.fn = function (value) {
                
                mobileConfig.setDiagnosticMode(value);

                
                this.v = value;
            };
            items.push(diagnosticMode);
        }

        
        var monitor = newCheckItem.call(this, $DESC(9471, 'Monitor Network Status'), $DESC(9790, 'Notify the user when connection quality is below optimal'), generalSettings, 'mns', true, false);

        
        var fn = function (value) {
            mstrMobileApp.setNetworkMonitoringEnabled(value);
        };

        monitor.fn = mstrmojo.func.composite([fn, monitor.fn]);

        
        if (generalSettings.mns === undefined) {
            
            monitor.v = true;
        }
        items.push(monitor);

        items.push(newHeader($DESC(8361, 'Mobile Server Default')));
        items = items.concat(newAuthenticationItems.call(this, TYPE_SERVER_CREDS, this.mobileConfigObj.getDefaultServerCreds()));

        
        
        if (generalSettings.usc) {
            items.push(newHeader($DESC(8368, 'Caching')));
            items.push(newListItem.call(this, $DESC(8369, 'Memory limit'), generalSettings, 'ml', MEMORY_LIMIT_LIST));
            items.push(newCheckItem.call(this, $DESC(8370, 'Folder caching'), $DESC(9451, 'Store folders information for offline analysis'), generalSettings, 'fc', true, false));
            items.push(newCheckItem.call(this, $DESC(8371, 'Clear cache when closed'), $DESC(9452, 'Delete reports and documents information after exiting the app'), generalSettings, 'cc', 2, 1));
        }

        items.push(newHeader($DESC(8459, 'Certificates')));

        
        if (generalSettings.ucs !== undefined && generalSettings.ucs !== '' && generalSettings.ucs) {
            var hasCert = mstrMobileApp.hasCertificate(),
                certItem,
                getCertItem;

            certItem = newViewItem.call(this, 'Device Certificate', '', getCertificateDetailsView, {
                fnPress: showPopupDeleteCertificate,
                hidden: !hasCert
            });
            getCertItem = newViewItem.call(this, 'Get Certificate', "", getCertificateAuthenticationFieldsView, {
                hidden: hasCert,
                dependents: [certItem]
            });
            certItem.dependents = [getCertItem];
            items.push(certItem);
            items.push(getCertItem);
        }
        items.push(newViewItem.call(this, $DESC(8447, 'Trusted Certificates'), "", getTrustedCertificatesView, {
            hidden: false
        }));

        
        if (mstrMobileApp.isDPCEnabled()) {
            items.push(newHeader($DESC(9481, 'Device Passcode')));
            items.push(newItem.call(this, $DESC(1905, 'Reset'), '', STYLE_BUTTON, {
                fn: function () {
                    mstrMobileApp.resetDPC();
                }
            }));
        }

        
        items.push(newHeader($DESC(9791, 'Background Syncing')));
        items = items.concat(getBackgroundSyncingItems.call(this));

        
        return {
            title: item.nm,
            items: addTabletHeader.call(this, items, item.nm),
            cfg: {
                type: TYPE_GENERAL,
                fnVal: validateGeneralSettingsChanges,
                item: item
            }
        };
    }

    
    function getMobileServersView(item) {
        var config = this.mobileConfigObj,
            servers = config.getWebServersList(),
            items = [];

        
        $ARR.forEach(servers, function (server, idx) {
            
            items.push(newViewItem.call(this, server.nm, '', getEditServerView, {
                idx: idx,
                fnPress: showPopup
            }));
        }, this);

        
        return {
            title: item.nm,
            items: addTabletHeader.call(this, items, item.nm),
            cfg: {
                type: TYPE_SERVERS,
                item: item
            }
        };

    }

    
    function getHomeSettingsView() {
        
        var items = [ newViewItem.call(this, $DESC(6560, 'General Settings'), '', getGeneralSettingsView), newViewItem.call(this, $DESC(8375, 'Mobile Servers'), '', getMobileServersView) ];

        
        if (mstrApp.isTablet()) {
            
            items.push(newViewItem.call(this, $DESC(1142, 'About'), '', getAboutView));
        }

        
        return {
            title: $DESC(7831, 'Settings'),
            items: items,
            cfg: {
                type: TYPE_HOME,
                isHome: true
            }
        };
    }

    
    function saveChanges(cfg, doSave) {
        var type = cfg.type,
            modifications = MODIFIED_ITEMS[cfg.type];

        
        if (modifications) {
            
            var fnValidate = cfg.fnVal;
            if (fnValidate) {
                
                fnValidate.call(this, cfg, modifications);
            }

            
            if (doSave) {
                
                this.mobileConfigObj.saveConfiguration();
            }

            
            delete MODIFIED_ITEMS[type];
        }
    }

    
    var $CTRL = mstrmojo.android.controllers.SettingsController = mstrmojo.declare(

        mstrmojo.android.controllers.ViewController,

        null,

        
        {
            scriptClass: "mstrmojo.android.controllers.SettingsController",

            
            connectivityChanged: false,

            init: function (props) {
                this._super(props);

                
                this.mobileConfigObj = this.mobileConfigObj || mstrApp.getConfiguration();
            },

            start: function (params) {
                var viewFn = params.viewFn;

                this._super(params);

                
                mstrApp.cancelPending();

                
                this._viewInfos = [];

                
                var view = this.view = this.newView('Settings');

                
                this.rootCtrl.updateContent(view, $DESC(7831, 'Settings'));

                
                generateView.call(this, (viewFn && eval('(' + viewFn + ')')) || getHomeSettingsView);
            },

            
            getDefaultMenus: function getDefaultMenus() {
                
                return MENUS.HELP;
            },

            updateActionToolbar: function updateActionToolbar(tbCfg) {
                
                var cfg = getCurrentConfig.call(this),
                    cfgType = cfg && cfg.type,
                    deleteDescId = DELETE_TXT[cfgType],
                    addDescId = ADD_TXT[cfgType];

                
                if (addDescId) {
                    
                    var menuId = MENU_ADD_SERVER,
                        iconId = 19;

                    
                    if (cfgType === TYPE_EDIT_SERVER) {
                        
                        menuId = MENU_ADD_PROJECT;
                        iconId = 20;
                    }

                    
                    tbCfg.addToolbarBtn(menuId, $DESC(9446, 'Add #').replace('#', $DESC(addDescId, 'Item')), menuId, true, iconId);
                }

                
                if (deleteDescId) {
                    
                    tbCfg.addMenuItem(MENU_DELETE, $DESC(8379, 'Delete #').replace('#', $DESC(deleteDescId, 'Item')), MENU_DELETE, true, 16);
                }

                
                if (!mstrApp.isTablet() && cfgType !== TYPE_ABOUT && cfgType !== TYPE_LEGAL) {
                    
                    tbCfg.addMenuItem(MENU_ABOUT, $DESC(1142, 'About'), MENU_ABOUT, true, 21);
                }

                
                return this._super(tbCfg);
            },

            handleMenuItem: function handleMenuItem(group, cmdId) {
                var cfg = getCurrentConfig.call(this),
                    type = cfg.type,
                    servers = this.mobileConfigObj.getWebServersList(),
                    isServer = (type === TYPE_EDIT_SERVER);

                switch (group) {
                case MENU_ABOUT:
                    
                    cacheViewState.call(this, -1);

                    
                    generateView.call(this, getAboutView);
                    break;

                case MENU_ADD_SERVER:
                case MENU_ADD_PROJECT:
                    
                    cacheViewState.call(this, -1);

                    
                    if (group === MENU_ADD_SERVER) {
                        
                        generateView.call(this, getEditServerView, {
                            nm: $DESC(9447, 'New Server'),
                            idx: servers.length
                        });

                    } else {
                        
                        var server = servers[cfg.item.idx];
                        generateView.call(this, getEditProjectView, {
                            nm: $DESC(9448, 'New Project'),
                            idx: (server && server.pl.length) || 0
                        });

                    }
                    break;

                case MENU_DELETE:
                    var collection;

                    
                    if (isServer) {
                        
                        collection = servers;

                    
                    } else if (type === TYPE_EDIT_PROJECT) {
                        
                        var idx = cfg.parent.idx;
                        collection = servers[idx] && servers[idx].pl;
                    }

                    
                    if (collection) {
                        var me = this,
                            item = collection[cfg.idx];

                        var okFn = function () {
                            
                            collection.splice(cfg.idx, 1);

                            
                            me.mobileConfigObj.reconcileHomescreen();

                            
                            me.mobileConfigObj.saveConfiguration();

                            
                            me.view.getList(cfg.isHome).set('items', cfg.parent.fnRedraw.call(me, cfg.parent.item).items);

                            
                            me.goBack();

                            me.connectivityChanged = true;
                        };

                        
                        if (item) {
                            confirmDelete(item.nm || item.pn, okFn);
                        } else {
                            okFn();
                        }
                    } else {
                        
                        this.goBack();
                    }
                    return false;
                }

                
                return this._super(group, cmdId);
            },

            goBack: function goBack() {
                
                if (this._super()) {
                    
                    return true;
                }

                var currentConfig = getCurrentConfig.call(this);
                
                saveChanges.call(this, currentConfig, true);

                
                var viewInfos = this._viewInfos;
                viewInfos.pop();

                
                
                
                if(currentConfig.type === TYPE_EDIT_SERVER && mstrApp.deviceType === 3 && this.mobileConfigObj.getWebServersList().length === 0){
                	viewInfos.pop();
                }

                
                var current = getLastViewInfo.call(this);
                if (!current || (mstrApp.isTablet() && viewInfos.length === 1)) {
                    
                    if (this.connectivityChanged) {
                        
                        this.rootCtrl.restart();
                        return true;
                    }

                    
                    return false;
                }

                
                showCurrentView.call(this);

                
                return true;
            },

            goUp: function goUp() {
                
                if (!this._super()) {
                    
                    $ARR.forEach(this._viewInfos, function (view) {
                        
                        saveChanges.call(this, view.cfg);
                    }, this);

                    
                    this.mobileConfigObj.saveConfiguration();

                    
                    this.rootCtrl[(this.connectivityChanged) ? 'restart' : 'goHome']();
                }

                
                return true;
            },

            
            jumpTo: function jumpTo(idx, showView) {
                var viewInfos = this._viewInfos,
                    targetIdx = idx + 1;

                
                $ARR.forEach(viewInfos, function (view, vIdx) {
                    if (vIdx > targetIdx) {
                        
                        saveChanges.call(this, view.cfg);
                    }
                }, this);

                
                viewInfos.splice(targetIdx);

                
                if (showView) {
                    
                    showCurrentView.call(this);
                }
            }
        }
    );

    
    $CTRL.STYLES = {
        HEADER: STYLE_HEADER,
        BUTTON: STYLE_BUTTON,
        VIEW_BUTTON: STYLE_VIEW_BUTTON,
        TEXT: STYLE_TEXT,
        LIST: STYLE_LIST,
        CHECK: STYLE_CHECK,
        IMAGE: STYLE_IMAGE,
        TEXT_AREA: STYLE_TEXT_AREA,
        NUMBER: STYLE_NUMBER,
        TIME: STYLE_TIME
    };

}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ViewController",
                         "mstrmojo.date",
                         "mstrmojo.locales",
                         "mstrmojo.hash");

    mstrmojo.requiresDescs(8391, 8392);

    
    function getCachedTime(item) {
        
        var subtype = item.st;
        if (subtype === 2048 || subtype === 'Project') {
            
            return undefined;
        }

        var ct = mstrMobileApp.getCachedTime(item.sub_id || item.did, (item.sub_id) ? -1 : subtype, item.projectID || item.pid || ''),
            dtString;

        
        if (ct > 0) {
            var $date = mstrmojo.date,
                $l = mstrmojo.locales.datetime,
                dateInfo = $date.getDateJson(new Date(parseInt(ct, 10)));

            dtString = $date.formatDateInfo(dateInfo, $l.DATEOUTPUTFORMAT) + ' ' + $date.formatTimeInfo(dateInfo, $l.TIMEOUTPUTFORMAT);
        }

        return mstrmojo.desc(8391, 'Cached On:') + ' ' + (dtString || mstrmojo.desc(8392, 'Not available'));
    }

    
    function updateView(params) {
        
        var item = params.item;
        if (item) {
            
            params = mstrmojo.hash.copy(params, {
                desc: item.desc || '',
                ttl: item.n || item.ttl || '',
                cached: getCachedTime(item),
                did: item.did,
                st: item.st
            });
        }

        
        this.view.updateView(params);
    }

    
    mstrmojo.android.controllers.PropertiesController = mstrmojo.declare(

        mstrmojo.android.controllers.ViewController,

        null,

        
        {
            scriptClass: "mstrmojo.android.controllers.PropertiesController",
            
            doNotRefresh: true,

            start: function start(params) {
                this._super(params);
                
                
                var view = this.view = mstrApp.viewFactory.newView('Properties', {
                    controller: this
                });

                
                this.rootCtrl.updateProperties(view, 'Properties');

                
                updateView.call(this, params);
            },

            
            updateItemProperties: function updateItemProperties(defaultMsg, item, ctrlId, isAvail) {
                
                updateView.call(this, {
                    defaultMsg: defaultMsg,
                    item: item,
                    ctrlId: ctrlId,
                    avail: isAvail
                });
            },

            
            extractView: function extractView() {
                
                var view = this.view;
                view.parent.removeChildren(view);
                view.unrender();

                
                return view;
            },
            
            afterViewVisible: function afterViewVisible() {
                this.view.afterViewVisible();
                
                this._super();
            },            

            
            restoreView: function restoreView(view) {
                
                view.unrender();

                
                this.rootCtrl.updateProperties(view);
            },

            makeCurrent: function makeCurrent(isBack) {
                this._super(isBack);

                
                this.rootCtrl.updateProperties(this.view, 'Properties');
            },

            goUp: function goUp() {
                
                if (!this._super()) {
                    
                    this.rootCtrl.goBack();
                }

                
                return true;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ViewController",
                         "mstrmojo.hash",
                         "mstrmojo.array");

    mstrmojo.requiresDescs(8394);

    var EnumHSButtonType = {
        FOLDER: 1,
        RESULTSET: 2,
        REPORTS: 3,
        SETTINGS: 4,
        SHAREDLIBRARY: 5,
        SUBSCRIPTIONS: 8,
        HELP: 6
    };

    var HS_DEFAULT = 1,
        HS_CUSTOM = 2,
        HS_RESULTSET = 3,
        HS_FOLDER = 4;

    var $HASH = mstrmojo.hash,
        $ARR = mstrmojo.array;

    
    function setUpStatus() {
        this.rootView.setUpStatus(this.getCurrent().getUpStatus());
    }

    function dispatchController(deviceCfg, params) {

        var screenType = deviceCfg && deviceCfg.getHomeScreenType();

        
        if (!deviceCfg || (screenType < HS_DEFAULT || screenType > HS_FOLDER)) {
            
            mstrmojo.err({
                name: 'StartupError',
                message: deviceCfg ? 'illegal default homescreen type, hsc=' + screenType : 'no device configuration found.'
            });

            return false;
        }

        
        if (screenType > HS_CUSTOM) {

            
            var homeScreen = deviceCfg.getHomeScreen(),
                projectId = homeScreen.pid,
                subtype = homeScreen.st;

            
            params.did = homeScreen.did;

            
            var systemFolder = homeScreen.systemFolder;
            if (systemFolder) {
                
                params.systemFolder = systemFolder;
            }

            
            if (screenType === HS_FOLDER) {
                
                var oi = homeScreen.oi;

                
                projectId = params.pid = oi.pid;
                subtype = oi.st;

                
                params.did = oi.did;
                params.csp = !!homeScreen.csp;

            } else {
                
                params.projectID = projectId;

                
                $HASH.copyProps([ "promptsAnswerXML", "elementsPromptAnswers", "valuePromptAnswers", "objectsPromptAnswers", "reportViewMode" ],
                                 homeScreen,
                                 params);

                
                if (parseInt(params.reportViewMode, 10) === 2) {
                    
                    subtype = 769;
                }
            }

            
            mstrApp.setCurrentProjectId(projectId);

            
            params.st = subtype;
        }

        
        this.initHomeScreen(screenType, params);
    }

    
    var $CTRL = mstrmojo.android.controllers.RootController = mstrmojo.declare(

        mstrmojo.android.controllers.ViewController,

        null,

        
        {
            scriptClass: "mstrmojo.android.controllers.RootController",

            start: function start() {
                var deviceCfg = mstrApp.getConfiguration(),
                    params = {
                        hsc: true               
                    };

                
                this._lastOpened = $ARR.filter(this._lastOpened, function (rs) {
                    
                    return !!deviceCfg.getProject(rs.projectID || rs.pid);
                });

                dispatchController.call(this, deviceCfg, params);
            },

            

            direct: function direct(externalCfg) {
                
                var deviceCfg = new mstrmojo.MobileConfiguration({
                    _cfg: externalCfg
                });

                
                mstrApp.closeAllDialogs();

                
                dispatchController.call(this, deviceCfg, {});
            },

            
            restart: function restart() {
                
                mstrApp.closeAllDialogs();

                
                var nextController = this.nextController;
                if (nextController) {
                    
                    nextController.destroy();
                }

                
                this.start();
            },

            
            initHomeScreen: function initHomeScreen(screenType, params) {
                
                this.spawn(mstrApp.controllerFactory.newController(this.getViewKey(params.st), params), params);
            },

            initNav: function initNav() {
                var deviceCfg = mstrApp.getConfiguration(),
                    nav = [{
                        n: mstrmojo.desc(1873, 'Home'),
                        act: -1,
                        fromNav: true
                    }];

                if (deviceCfg.isSubscriptionEnabled()) {
                    nav.push({
                        n: mstrmojo.desc(1089, 'Subscriptions'),
                        act: 8,
                        fromNav: true
                    });
                }

                
                this.rootView.setNavigation(nav, 0);
            },

            
            updateLastOpened: function updateLastOpened(request) {
                
                var last = this._lastOpened,
                    projId = mstrApp.getCurrentProjectId(),
                    requestId;

                
                if (request) {
                    
                    requestId = request.did || request.documentID || request.reportID || request.objectID;

                    
                    mstrmojo.array.forEach(last, function (item, idx) {
                        
                        if (item.xId === requestId && item.projectID === projId) {
                            
                            last.splice(idx, 1);

                            
                            return false;
                        }
                    });
                }

                
                this.rootView.updateLastOpened(last);

                
                if (request) {
                    
                    last = this._lastOpened = [ $HASH.copy(request, {
                        projectID: projId,                  
                        xId: requestId                      
                    }) ].concat(last);

                    
                    if (last.length > 5) {
                        
                        last.pop();
                    }
                }
            },

            
            updateProperties: mstrmojo.emptyFn,

            
            updateFolder: function updateFolder(folderView, title, isBack) {
                setUpStatus.call(this);
            },

            
            updatePrompts: function updatePrompts(promptView, title) {
                
                this.updateContent(promptView, title);
            },

            
            updateTransactions: mstrmojo.emptyFn,

            
            closeTransactions: mstrmojo.emptyFn,

            
            updateContent: function updateContent(contentView, title, isBack) {
                var rootView = this.rootView;

                
                if (title !== undefined) {
                    
                    this._lastTitle = title;

                    
                    rootView.setTitle(title);
                    rootView.clearNavigation();
                }

                
                if (contentView) {
                    
                    rootView.setContent(contentView, isBack);
                }

                
                setUpStatus.call(this);
            },

            
            contentUpdated: function contentUpdated(subtype) {
                
                this.rootView.contentUpdated(subtype);
            },

            
            restoreNavigation: function restoreNavigation() {
                this.rootView.restoreNavigation();
            },
            
                        
            updateDisplayMessage: mstrmojo.emptyFn,

            
            setActionToolbarStatus: function setActionToolbarStatus(isActive) {
                this.rootView.setActionToolbarStatus(isActive);
            },

            
            getTitle: function getTitle() {
                return this._lastTitle || '';
            },

            
            jumpTo: function jumpTo(item) {
                
                var action = item.act;
                if (action) {

                    
                    if (!item.fromNav) {
                        
                        if (!this.rootView.hasNavigationItems()) {
                            this.initNav();
                        } else {
                            
                            this.restoreNavigation();
                        }

                        
                        this.rootView.selectNavigationItem(item);
                    }

                    
                    if (action === -1) {
                        
                        this.restart();

                    } else if (action === EnumHSButtonType.SHAREDLIBRARY) {
                        
                        
                        this.spawn(mstrApp.controllerFactory.newController('Projects', {
                            hsc: true
                        }));


                    } else if (action === EnumHSButtonType.SUBSCRIPTIONS) {
                        
                        this.spawn(mstrApp.controllerFactory.newController('Subscriptions', {
                            hsc: true
                        }));
                    }

                    return;
                }

                
                this._super(item);
            },

            
            goHome: function goHome() {
                
                mstrApp.closeAllDialogs();

                
                var nextController = this.nextController;
                if (nextController) {
                    
                    nextController.makeHome();
                }
            },

            
            makeCurrent: mstrmojo.emptyFn,

            
            setActionToolbar: function setActionToolbar(id, tbCfg) {
                this.rootView.setActionToolbar(id, tbCfg);
            },

            enterFullScreen: function enterFullScreen() {
                this.rootView.enterFullScreen();
            },

            flashFullScreen: function flashFullScreen() {
                this.rootView.flashFullScreen();
            },

            exitFullScreen: function exitFullScreen(animate, isBack) {
                this.rootView.exitFullScreen(animate);
            },

            cancelFlashFullScreen: function cancelFlashFullScreen() {
                return this.rootView.cancelFlashFullScreen();
            },

            onorientationChange: function onorientationChange(evt) {
                this._super(evt);

                
                this.rootView.reset();

                
                this.raiseEvent({
                    name: 'rootOrientationChange',
                    isLandscape: !!this.orientation
                });
            }
        }
    );

    
    $CTRL.EnumHSType = {
        DEFAULT: HS_DEFAULT,
        CUSTOM: HS_CUSTOM,
        RESULTSET: HS_RESULTSET,
        FOLDER: HS_FOLDER
    };
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ViewController",
                         "mstrmojo.android.EnumMenuOptions");

    
    mstrmojo.android.controllers.PromptsController = mstrmojo.declare(

        mstrmojo.android.controllers.ViewController,

        null,

        
        {
            scriptClass: "mstrmojo.android.controllers.PromptsController",
            
            
            doNotRefresh: true,

            start: function start(params) {
                this._super(params);

                
                this.callback = params.callback;

                
                var prompts = this.prompts = params.prompts,
                    view = this.view = this.newView('Prompts', {
                        maskNode: params.maskNode,
                        prompts: prompts,
                        supportedPrompts: params.supportedPrompts
                    });

                
                var name = prompts.host.n || params.n;

                
                this.rootCtrl.updatePrompts(view, name);
            },

            getDefaultMenus: function getDefaultMenus() {
                
                return 0;
            },

            goUp: function goUp() {
                
                if (!this._super()) {
                    
                    this.rootCtrl.goBack();
                }

                
                return true;
            },

            answerPrompts: function answerPrompts() {
                var id = this.id;
                this.prompts.prepareAnswer({
                    success: function () {
                        try {
                            var ctrl = mstrmojo.all[id];
                            ctrl.prompts.validate();
                            ctrl.callback();
                        } catch (e) {
                            mstrApp.onerror(e);
                            return false; 
                        }

                        return true;
                    }
                });
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ViewController",
                         "mstrmojo.android.controllers._SupportsQueuedTransactions",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo.hash",
                         "mstrmojo.array");

    mstrmojo.requiresDescs(8394);

    var EnumMenus = mstrmojo.android.EnumMenuOptions,
        popDimensions = {
            160: {
                h: 700,
                w: 550
            },
            213: {
                h: 700,
                w: 550
            },
            240: {
                h: 1000,
                w: 750
            },
            320: {
                h: 1400,
                w: 1000
            }
        };

    
    mstrmojo.android.large.controllers.BrowserController = mstrmojo.declare(

        mstrmojo.android.controllers.ViewController,

        [ mstrmojo.android.controllers._SupportsQueuedTransactions ],

        
        {
            scriptClass: "mstrmojo.android.large.controllers.BrowserController",

            getDefaultMenus: function getDefaultMenus() {
                return EnumMenus.SETTINGS + EnumMenus.HELP + EnumMenus.LEARN;
            },

            start: function start(params) {
                this._super(params);

                
                var view = this.view = this.newView('Browser'),
                    screenType = params.screenType;

                
                view.set('orientation', this.orientation);

                
                this.rootCtrl.updateContent(view);
                
                
                var propsController = this._propsController = mstrApp.controllerFactory.newController('Properties', {
                    rootCtrl: this.rootCtrl,
                    orientation: this.orientation
                });

                
                propsController.start({});

                if(screenType ) {
                	var EnumHSType = mstrmojo.android.controllers.RootController.EnumHSType;

                	switch (params.screenType) {
                	case EnumHSType.FOLDER:
                		
                		this.spawn(mstrApp.controllerFactory.newController(this.getViewKey(params.st), params), params);
                		break;

                	case EnumHSType.CUSTOM:
                		
                		this.spawn(mstrApp.controllerFactory.newController('HomeScreen', params));
                		break;

                	default:
                		
                		var projectCtrl = mstrApp.controllerFactory.newController('Projects', {
                			hsc: true
                		});

	                    
	                    
	            		this.spawn(projectCtrl);
                	}
                }
            },
            
            updateDisplayMessage: function updateDisplayMessage(view){
            	
            	this.view.updateDisplayMessage(view);
            },

            canDetach: function canDetach() {
                
                return false;
            },

            makeCurrent: function makeCurrent(isBack) {
                
                var nextController = this.nextController;
                if (nextController) {
                    
                    nextController.makeCurrent(isBack);
                }
            },

            onorientationChange: function onorientationChange() {
                
                var dialog = this._propsDialog;
                if (dialog) {
                    
                    dialog.close();
                }

                
                var orientation = this.orientation;

                
                mstrmojo.array.forEach([ this._propsController, this.view ], function (dependent) {
                    
                    if (dependent) {
                        
                        dependent.set('orientation', orientation);
                    }
                });

                this._super();
            },

            goBack: function goBack() {
                
                var nextController = this._propsController.nextController || this.nextController;
                return (nextController && nextController.goBack()) || false;
            },

            updateItemProperties: function updateItemProperties(defaultMsg, item, ctrlId, isAvail) {
                
                var propsCtrl = this._propsController;
                if (item && (item.propsPopup || this.orientation)) {
                    
                    var view = propsCtrl.extractView(),
                        dialog;

                    delete view.slot;

                    
                    view.onOpenItem = function () {
                        
                        dialog.close();
                    };

                    
                    dialog = this._propsDialog = mstrApp.showDialog({
                        cssClass: 'mstrmojo-TabletPropertiesView-portrait',
                        autoClose: true,
                        src: this,
                        popDimensions: popDimensions[mstrMobileApp.getDeviceDPI()],
                        children: [ view ],
                        onClose: function () {
                            
                            delete this.src._propsDialog;

                            
                            dialog.removeChildren(view);

                            
                            view.onOpenItem = mstrmojo.emptyFn;

                            
                            propsCtrl.restoreView(view);
                        }
                    });
                }

                
                propsCtrl.updateItemProperties(defaultMsg, item, ctrlId, isAvail);
            },

            updateFolder: function updateFolder(folderView, title, isBack) {
                var view = this.view,
                    rootCtrl = this.rootCtrl;

                
                if (!view.domNode) {
                    
                	
                    rootCtrl.updateContent(view, undefined, isBack);

                    
                    rootCtrl.restoreNavigation();

                    
                    folderView.controller.syncItemProperties();
                }

                
                view.updateFolder(folderView, this.rootCtrl.getPath());
            },

            
            updateProperties: function updateProperties(view) {
                this.view.updateProperties(view);
            },

            
            syncPath: function syncPath() {
                
                this.view.updateFolder(null, this.rootCtrl.getPath());
            },

            updateActionToolbar: function updateActionToolbar(tbCfg) {
                
                this.getTxnToolbarButton(tbCfg);

                
                return this._super(tbCfg);
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ViewController",
                         "mstrmojo.android.controllers._SupportsQueuedTransactions",
                         "mstrmojo.android.controllers._HasFolderView",
                         "mstrmojo.hash");

    mstrmojo.requiresDescs(8385);

    
    function openProject(project, controller, isHomeScreen) {
        
        mstrApp.setCurrentProjectId(project.did);

        
        var params = mstrmojo.hash.copy(project),
            props = {};

        
        if (isHomeScreen) {
            
            props.hsc = true;
        }

        
        var rtf = project.rtf;
        if (rtf) {
            
            params.did = params.folderID = rtf.did;

        } else {
            
            params.systemFolder = 7;
        }

        
        params.st = 2048;

        
        controller.spawn(mstrApp.controllerFactory.newController('Folder', props), params);
    }
    
    function displayNoProjectsView(projectsList) {
		if (projectsList.length < 1) {
			var noPrjView = this._noPrjView;
			if (!noPrjView) {
				noPrjView = this._noPrjView = new mstrmojo.android.ui.NoProjectsView({
					controller: this
				});
			}
			
			
			this.rootCtrl.updateDisplayMessage(noPrjView);
		}    	
    }

    
    var $PROJ = mstrmojo.android.controllers.ProjectsController = mstrmojo.declare(

        mstrmojo.android.controllers.ViewController,

        [ mstrmojo.android.controllers._SupportsQueuedTransactions, mstrmojo.android.controllers._HasFolderView ],

        
        {
            scriptClass: "mstrmojo.android.controllers.ProjectsController",
            
            

            start: function start(params) {
            	this._super(params);

            	
            	var projectsList = mstrApp.getConfiguration().getProjectList(),
            		rootCtrl = this.rootCtrl,
            		view = this.initFolderView();

        		
        		view.set('items', projectsList); 

        		
        		rootCtrl.updateFolder(view);                	

        		
        		this.updatePropertiesMsg();   
        		
        		displayNoProjectsView.call(this, projectsList);
            },

            openFolder: function openFolder(folder) {
                openProject(folder, this);
            },

            getDefaultMessage: function getDefaultMessage() {
                return mstrmojo.desc(8385, 'Select a project to view contents');
            },

            makeCurrent: function makeCurrent(isBack) {
                this._super(isBack);

                
                this.view.clearSelect();

                
                var rootCtrl = this.rootCtrl;
                
                rootCtrl.updateFolder(this.view);

                
                rootCtrl.restoreNavigation();

                
                this.updatePropertiesMsg();                	
            
        		displayNoProjectsView.call(this, mstrApp.getConfiguration().getProjectList());
            },

            goUp: function goUp() {
                
                if (!this._super()) {
                    
                    this.rootCtrl.goBack();
                }

                
                return true;
            },
            
            destroy: function destroy() {
            	var noPrjView = this._noPrjView;
            	if (noPrjView) {
            		noPrjView.destroy();
            	}
            	
            	this._super();
            },

            updateActionToolbar: function updateActionToolbar(tbCfg) {
                
                this.getTxnToolbarButton(tbCfg);

                
                return this._super(tbCfg);
            }
        }
    );

    
    $PROJ.spawnFolderController = openProject;

}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ViewController");

    
    var CLASS_NAME = 'mstrmojo.android.controllers.HomeScreenController';


    
    mstrmojo.android.controllers.HomeScreenController = mstrmojo.declare(

        mstrmojo.android.controllers.ViewController,

        null,

        
        {
            scriptClass: "mstrmojo.android.controllers.HomeScreenController",

            openItem: function openItem(button) {
                $MAPF(true, CLASS_NAME);
                try {
                	
                	var item = mstrmojo.hash.copy(button);
                	
                    
                    var getVK = this.getViewKey,
                        viewKey = item.act  ? getVK(item.act) : getVK(item.st);

                    
                    if (viewKey === 'Help') {
                        mstrApp.displayHelp();
                        return;
                    }

                    
                    if (viewKey === '') {
                        
                        viewKey = item.type;
                    }

                    
                    delete item.type;
                    
                    
                    if (viewKey === getVK(5)) {
                        var deviceConfig = mstrApp.getConfiguration(),
                            projectCount = deviceConfig.getProjectCount();

                        
                        if (projectCount === 1) {
                            
                            
                            viewKey = getVK(2048);

                            
                            item.systemFolder = 7;

                            
                            item.pid = mstrmojo.hash.any(deviceConfig.getProjectHash(), true);
                        }
                    }
                    
                    
                    mstrApp.setCurrentProjectId(item.pid);
                    delete item.pid;

                    
                    this.spawn(mstrApp.controllerFactory.newController(viewKey, item), item);

                } catch (ex) {

                    
                    throw ex;
                } finally {
                    $MAPF(false, CLASS_NAME);
                }
            }

        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ViewController",
                         "mstrmojo.func",
                         "mstrmojo.hash");

    mstrmojo.requiresDescs(9478, 9479, 9753);

    var $HASH = mstrmojo.hash,
        TX_QUEUE_LEVEL_DOC = 1,
        TX_QUEUE_LEVEL_ALL = 2,
        guiTitle;

    
    mstrmojo.android.controllers.TransactionNotificationController = mstrmojo.declare(
        mstrmojo.android.controllers.ViewController,

        null,

        
        {
            scriptClass: 'mstrmojo.android.controllers.TransactionNotificationController',

            widgetMap: null,

            boardOpen: null,

            init: function init(props) {
                this._super(props);

                var widgetMap = this.widgetMap = {},
                    boardModel = this.boardModel = this.model.getBoardModel();

                
                if (!this._txListener) {
                    this._txListener = boardModel.attachEventListener('recordChanged', this.id, function (e) {
                        $HASH.forEach(widgetMap, function (v, k) {
                            if (!e.data || !e.data[k]) {
                                v.set('txData', null);
                                delete widgetMap[k];
                            }
                        });

                        
                        if (this.isNotificationBoardOpen()) {
                            
                            this.pendingUpdate = true;
                        } else {
                            
                            this.generateActionToolbar();
                        }
                    });
                }
            },

            start: function start(params) {
                this._super(params);

                
                var view = this.view = mstrApp.viewFactory.newView('Transactions', {
                    model: this.boardModel,
                    context: params.context,
                    controller: this
                });

                
                guiTitle = mstrmojo.desc(9753, 'Transactions');
                this.rootCtrl.updateTransactions(view, guiTitle);
            },

            destroy: function destroy(ignoreDOM) {
                
                var listener = this._txListener;
                if (listener) {
                    
                    listener.clear();
                }

                this._super(ignoreDOM);
            },

            
            hasTransactionQueue: function hasTransactionQueue(did) {
                
                var txs = this.model.hasOfflineTransactions();

                
                if (txs && did) {
                    
                    txs = this.boardModel.getOfflineRecords(did);
                }

                return txs;
            },

            
            hasPendingTransactions: function hasPendingTransactions(did) {
                var docTx = this.boardModel.getOfflineRecords(did);
                return (docTx && docTx.pending && docTx.pending.length);
            },

            
            showNotificationBoard: function showNotificationBoard(srcController, did, docTitle) {
                
                var startParams = {},
                    boardOpen = TX_QUEUE_LEVEL_ALL;

                
                if (did) {
                    
                    startParams = {
                        context: {
                            id: did,
                            n: docTitle || srcController.ttl
                        }
                    };

                    
                    boardOpen = TX_QUEUE_LEVEL_DOC;
                }

                
                this.boardOpen = boardOpen;

                
                this.contextController = srcController;

                
                srcController.spawn(this, startParams);
            },

            
            isNotificationBoardOpen: function isNotificationBoardOpen() {
                return !!this.boardOpen;
            },

            
            isAllTransactionLevel: function isAllTransactionLevel() {
                return (this.boardOpen === TX_QUEUE_LEVEL_ALL);
            },

            
            editTransactionRecord: function editTransactionRecord(did, isPending, timeStamp, callback) {
                var bm = this.boardModel,
                    id = this.id;

                this.model.editTransactionRecord(did, isPending, timeStamp, mstrmojo.func.wrapMethods(callback, {
                    success: function (response) {
                        
                        mstrmojo.all[id].startDocument(response, did, bm.docsTx[did] && bm.docsTx[did].p.pid);
                    }
                }));
            },

            
            deleteTransactionRecord: function deleteTransactionRecord(did, isPending, timeStamp, callback) {
                
                callback = callback || {};

                
                var fnSuccess = callback.success || mstrmojo.emptyFn,
                    me = this;

                
                callback.success = function (data) {
                    var noTxRecords = !me.boardModel.getOfflineRecords();

                    
                    fnSuccess(data);

                    var boardOpen = me.boardOpen;

                    
                    
                    if (boardOpen === TX_QUEUE_LEVEL_ALL && noTxRecords) {
                        me.goBack();
                    }

                    
                    if ((boardOpen === TX_QUEUE_LEVEL_DOC && noTxRecords) || me.model.emptyTransactionQueue) {
                        mstrmojo.toast(me.model.emptyTransactionQueue ? mstrmojo.desc(9478, 'There are no more pending transactions') : mstrmojo.desc(9479, 'There are no more pending transactions for the current document'));
                        me.goUp();
                    }
                };

                this.model.deleteTransactionRecord(did, isPending, timeStamp, callback);
            },

            
            startDocument: function startDocument(res, did, pid) {
                
                res.ifc = false;

                
                this.rootCtrl.closeTransactions(true); 

                
                var contextController = this.contextController;
                if (contextController) {
                    
                    if (contextController instanceof mstrmojo.android.controllers.ResultSetController) {
                        
                        if (contextController.did === did) {
                            
                            contextController.hasTxChanges = true;

                            
                            contextController.model.transactionUpdate(res);

                            
                            
                            contextController.setData(res);
                            contextController.getPageByTree(true);

                            
                            contextController.makeCurrent();
                            return;
                        }
                    }

                    
                    var ctParams = {
                        action: 'open',
                        data: res,
                        documentID: did,
                        hasTxChanges: true,
                        st: 14081               
                    };

                    
                    if (pid !== mstrApp.getCurrentProjectId()) {
                        
                        ctParams.projectID = pid;
                    }

                    
                    contextController.spawn(mstrApp.controllerFactory.newController('Document', {
                        st: 14081
                    }), ctParams);
                }
            },

            detach: function detach() {
                this._super();

                
                this.boardOpen = null;

                
                if (this.pendingUpdate) {
                    
                    this.rootCtrl.getCurrent().generateActionToolbar();
                    delete this.pendingUpdate;
                }
            },

            
            addWidgetListener: function addWidgetListener(did, w) {
                this.widgetMap[did] = w;
            },

            
            goBack: function goBack() {
                
                if (this._super()) {
                    
                    return true;
                }

                
                if (this.boardOpen !== TX_QUEUE_LEVEL_ALL || !this.view.goBack()) {
                    
                    this.rootCtrl.closeTransactions();
                }

                
                return true;
            },

            goUp: function goUp() {
                
                if (!this._super()) {
                    
                    this.rootCtrl.closeTransactions();
                }

                
                return true;
            },

            makeCurrent: function makeCurrent(isBack) {
                this._super(isBack);

                
                this.rootCtrl.updateTransactions(this.view, guiTitle, isBack);
            },

            
            setOfflineRecords: function setOfflineRecords(did) {
                

                
                this.model.refresh();
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ViewController",
                         "mstrmojo.android.controllers._SupportsQueuedTransactions",
                         "mstrmojo.android.controllers._HasFolderView",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo.publisher",
                         "mstrmojo.array");

    mstrmojo.requiresDescs(773, 8386, 8388);

    var $ARR = mstrmojo.array,
        $DESC = mstrmojo.desc,
        $MENUS = mstrmojo.android.EnumMenuOptions,
        $REFRESH = $MENUS.REFRESH;

    
    function getLastRequest() {
        var requests = this._requests;
        return requests[requests.length - 1];
    }

    
    function loadFolder(params, isRefresh, callback) {
        var controller = this,
            view = this.view;

        
        params.csp = this.csp;

        
        callback = callback || {};

        
        this.dataService.getData(params, {
            success: function (res) {
                
                view.set('items', res.items);

                
                if (isRefresh) {
                    
                    getLastRequest.call(controller).res = res;

                } else {
                    
                    controller._requests.push({
                        p: params,
                        res: res
                    });
                }

                
                var fnSuccess = callback.success;
                if (fnSuccess) {
                    
                    fnSuccess.call(controller, res);
                }
            },
            failure: function (details) {
                controller.viewFailed(details);
            },
            canceled: function () {
                
                var fnCancel = callback.canceled;
                if (fnCancel) {
                    
                    fnCancel.call(controller);
                }
            }
        }, isRefresh);
    }

    
    function cacheViewState(idx) {
        
        var lastRequest = getLastRequest.call(this);
        lastRequest.orientation = mstrApp.isLandscape();
        lastRequest.idx = idx;
        lastRequest.origin = this.view.getScrollPos();
        lastRequest.hasState = true;
    }

    
    function clearPhoneViewSelections() {
        
        var view = this.view;
        if (view && !mstrApp.isTablet()) {
            
            view.clearSelect();
        }
    }

    
    function spawnItem(item) {
        
        var itemSubType = item.st,
            params = {
                ttl: item.n,
                st: itemSubType,
                did: item.did,
                ab: item.ab,
                rtf: item.rtf
            };

        
        this.spawn(mstrApp.controllerFactory.newController(this.getViewKey(itemSubType), params), params);
    }

    
    function restoreStateFromRequest(request) {
        
        if (!request.hasState) {
            
            return;
        }

        
        var view = this.view,
            isDirty = (mstrApp.isTablet() && request.orientation !== mstrApp.isLandscape()),
            idx = request.idx,
            origin = {
                x: 0,
                y: 0
            };

        
        if (!isDirty) {
            
            origin = request.origin;
        }

        
        view.restoreListState(idx, origin);

        
        view.items = request.res.items;

        
        view.refresh();

        
        if (isDirty) {
            
            view.scrollToItem(idx);
        }
    }

    
    function jumpBack(idx) {
        
        var requests = this._requests;

        
        if (idx !== undefined) {
            
            if (requests.length <= idx + 1) {
                
                return false;
            }

            
            requests.splice(idx + 1);
        } else {
            
            requests.pop();
        }

        
        var current = getLastRequest.call(this);
        if (!current) {
            
            return false;
        }

        
        restoreStateFromRequest.call(this, current);

        var rootCtrl = this.rootCtrl,
            currentResponse = current.res;

        
        rootCtrl.updateFolder(null, currentResponse.n);

        
        rootCtrl.contentUpdated(2048);

        
        this.updatePropertiesMsg();

        return true;
    }

    
    mstrmojo.android.controllers.FolderController = mstrmojo.declare(

        mstrmojo.android.controllers.ViewController,

        [ mstrmojo.android.controllers._SupportsQueuedTransactions, mstrmojo.android.controllers._HasFolderView ],

        
        {
            scriptClass: "mstrmojo.android.controllers.FolderController",

            start: function start(params) {
                this._super(params);

                
                this.ctrlType = 2048;

                
                this.dataService = mstrApp.modelFactory.newDataService('Folder');

                
                this._requests = [];

                
                var view = this.initFolderView();

                
                loadFolder.call(this, params, false, {
                    success: function (res) {
                        
                        if (params.systemFolder === 7) {
                            
                            res.n = params.n || params.txt;
                        }

                        
                        var rootCtrl = this.rootCtrl;
                        rootCtrl.updateFolder(this.view, res.n);

                        
                        
						if (this.hsc && !mstrApp.isTablet()) {
							
							rootCtrl.updateContent(null, res.n);
						}

                        
                        this.updatePropertiesMsg();
                    },
                    canceled: function () {
                        
                    	this.prevController && this.prevController.makeCurrent();
                    }
                });
            },

            openFolder: function openFolder(folder) {
                
                cacheViewState.call(this, folder._renderIdx);

                
                this.view.resetListState();

                
                loadFolder.call(this, folder, false, {
                    success: function (res) {
                        var rootCtrl = this.rootCtrl;

                        
                        rootCtrl.updateFolder(null, res.n);

                        
                        rootCtrl.contentUpdated(2048);

                        
                        this.updatePropertiesMsg();
                    },
                    canceled: clearPhoneViewSelections
                });
            },

            openItem: function openItem(item) {
                
                cacheViewState.call(this, item._renderIdx);

                
                spawnItem.call(this, item);
            },

            itemLongPressed: function itemLongPressed(item) {
                
                cacheViewState.call(this, item._renderIdx);

                return this._super(item);
            },

            getDefaultMenus: function getDefaultMenus() {
                
                return $MENUS.SETTINGS + $MENUS.HELP + $MENUS.LEARN;
            },

            getDefaultMessage: function getDefaultMessage() {
                var items = this.view.items;
                return (items && items.length) ? $DESC(8386, 'Select a report, document or folder to view its content') : $DESC(8388, 'No items in folder');
            },

            makeCurrent: function makeCurrent(isBack) {
                this._super(isBack);

                
                var current = getLastRequest.call(this);
                if (current) {
                	var	title = (this.hsc && mstrApp.isTablet()) ? undefined : current.res.n;
                	
                    
                	
                	this.rootCtrl.updateFolder(this.view, title, isBack);

                    
                    restoreStateFromRequest.call(this, current);
                }
            },

            makeHome: function makeHome() {
                this._super();

                
                jumpBack.call(this, 0);
            },

            goBack: function goBack() {
                
                if (this._super()) {
                    
                    return true;
                }

                
                return jumpBack.call(this);
            },

            goUp: function goUp() {
                
                if (!this._super()) {
                    
                    if (this._requests.length > 1) {
                        
                        jumpBack.call(this, 0);
                    } else {
                        
                        this.rootCtrl.goBack();
                    }
                }

                
                return true;
            },

            getUpStatus: function getUpStatus() {
                
                if (!this._super()) {
                    
                    var requests = this._requests;
                    return !!(requests && requests.length > 1);
                }

                
                return true;
            },

            updateActionToolbar: function updateActionToolbar(tbCfg) {
                
                this.getTxnToolbarButton(tbCfg);

                
                if (mstrMobileApp.isOnline()) {
                    
                    tbCfg.addMenuItem($REFRESH, $DESC(773, 'Refresh'), $REFRESH, true, 5);
                }

                
                return this._super(tbCfg);
            },

            handleMenuItem: function handleMenuItem(group, cmdId) {
                
                if (group === $REFRESH) {
                    
                    loadFolder.call(this, getLastRequest.call(this).p, true, {
                        success: function () {
                            
                            this.view._scroller.scrollTo(0, 0);
                        }
                    });

                    return false;
                }

                
                return this._super(group, cmdId);
            },

            getPath: function getPath() {
                var path = [],
                    id = this.id;

                
                $ARR.forEach(this._requests, function (item, idx) {
                	
                    
                    var response = item.res;
                    path.push({
                        n: response.n,
                        fn: function () {
                            
                            jumpBack.call(mstrmojo.all[id], idx);
                        }
                    });
                });

                return path;
            },

            goHome: function goHome() {
                
                jumpBack.call(this, 0);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.ActionBar",
                         "mstrmojo.android.large.ui.NavTabs");

    
    function toggleNavTabs(visible) {
        var prop = 'visible';

        this.tabs.set(prop, visible);
        this.title.set(prop, !visible);
    }

    
    mstrmojo.android.large.ui.ActionBar = mstrmojo.declare(
        mstrmojo.android.ui.ActionBar,

        null,

        
        {
            scriptClass: 'mstrmojo.android.medium.ui.ActionBar',

            addChildren: function addChildren(children, idx, silent) {
                
                children.push({
                    scriptClass: 'mstrmojo.android.large.ui.NavTabs',
                    slot: 'containerNode',
                    alias: 'tabs',
                    cssClass: 'mstrmojo-ActionBar-Nav',
                    visible: false
                });

                this._super(children, idx, silent);

                
                this.tabs.attachEventListener('selectionChange', this.id, function (evt) {
                    
                    var added = evt.added;
                    if (!added) {
                        
                        return;
                    }

                    
                    this.controller.jumpTo(evt.src.items[added[0]]);
                });
            },

            updateTitle: function updateTitle(title) {
                
                toggleNavTabs.call(this, false);

                this._super(title);
            },

            setNavigation: function setNavigation(items, selectedIdx) {
                
                toggleNavTabs.call(this, true);

                
                var tabs = this.tabs,
                    idxs = {};

                
                idxs[selectedIdx] = true;

                
                tabs.items = items;

                
                tabs.selectedIndex = selectedIdx;
                tabs.selectedIndices = idxs;

                
                tabs.refresh();
            },

            restoreNavigation: function restoreNavigation() {
                
                toggleNavTabs.call(this, true);
            },

            getNavList: function getNavList() {
                return this.tabs;
            }
        }
    );

    
    mstrmojo.android.ui.ActionBar.adjustLayoutConfig({
        160: 56,
        213: 75,
        240: 84,
        320: 112
    }, true);

}());
(function() {
    mstrmojo.requiresCls("mstrmojo.android.inputControls.CheckBoxDIC");
    
    mstrmojo.android.inputControls.MarkRowDIC = mstrmojo.declare(
            
            mstrmojo.android.inputControls.CheckBoxDIC,
            
            null,
            
            {
                scriptClass: 'mstrmojo.android.inputControls.MarkRowDIC',
                
                isSwitchStyle: false,

                oncheckedChange: function() {
                    if(this.markAll) {
                        var wm = this.group && this.group.widgetsMap, i;
                        for (i in wm){
                            if(wm.hasOwnProperty(i)) {
                                if  (wm[i].checked !== this.checked) {
                                    wm[i].set('checked', this.checked);
                                }
                            }
                        }
                    } else {
                        this._super();
                    }
                },
                
                postBuildRendering: function(){
                    this._super();
                    
                    
                    this.domNode.style.height = '30px';
                }
            }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ui.MobileDateTimePicker",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.date",
                         "mstrmojo.expr",
                         "mstrmojo.locales");

    mstrmojo.requiresDescs(2052, 2170, 7656);

    var $D = mstrmojo.date,
        $DESC = mstrmojo.desc,
        CALENDAR = 5,
        TIMEPICKER = 6,
        DTP = mstrmojo.expr.DTP;

    mstrmojo.android.inputControls.DateTimePickerDIC = mstrmojo.declare(
        mstrmojo.ui.MobileDateTimePicker,

        [ mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: "mstrmojo.android.inputControls.DateTimePickerDIC",

            cssText: '',

            valueField: 'dtValue',

            
            popupTitle: '',

            init: function init(props) {
                var dic = props.dic;

                if (dic.min !== undefined) {
                    props.min = $D.parseDateAndOrTime(dic.min);
                }
                if (dic.max !== undefined) {
                    props.max = $D.parseDateAndOrTime(dic.max);
                }

                props[this.valueField] = $D.parseDateAndOrTime(props.value);

                
                if (dic.t === CALENDAR) {
                    props.dtp = dic.ict ? DTP.TIMESTAMP : DTP.DATE;
                    props.popupTitle = dic.ict ? $DESC(7656, 'Date and Time') : $DESC(2052, 'Date');
                } else if (dic.t === TIMEPICKER) {
                    props.dtp = DTP.TIME;
                    props.minuteInterval = props.dic.itv;
                    props.popupTitle = $DESC(2170, 'Time');
                }

                this._super(props);
            },

            
            getCurValue: function getCurValue(forDisplay) {
                var oldDateTime = this[this.valueField] || {},
                    date = this.getDate() || oldDateTime.date || {year: 1970, month: 1, day: 1},
                    time = this.getTime() || oldDateTime.time || {hour: 0, min: 0, sec: 0},
                    config = this.dic,
                    dt = parseInt(config.dt, 10),
                    LD = mstrmojo.locales.datetime,
                    timeFormat = LD.TIMEOUTPUTFORMAT,
                    dateFormat = LD.DATEOUTPUTFORMAT,
                    displayDate = $D.formatDateInfo(date, dateFormat),
                    displayTime = $D.formatTimeInfo(time, timeFormat);

                if (forDisplay) {
                    if (config.t === CALENDAR) {
                        return config.ict ? (displayDate + ' ' + displayTime) : displayDate;
                    }

                    return displayTime;
                }

                if (dt === DTP.TIMESTAMP) {
                    return displayDate + ' ' + displayTime;
                }

                if (dt === DTP.TIME) {
                    return displayTime;
                }

                return displayDate;
            },

            
            
            renderPreview: function renderPreview() {
                
                this.renderPreviewButton(this.openerNode, this.getCurValue(true));
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList",
                         "mstrmojo._HasLayout",
                         "mstrmojo._SupportsEllipsisText",
                         "mstrmojo.date",
                         "mstrmojo.string",
                         "mstrmojo.num",
                         "mstrmojo.hash",
                         "mstrmojo.expr",
                         "mstrmojo.StringBuffer",
                         "mstrmojo.android.ui.ElementsSearchBar",
                         "mstrmojo.GeoLocation",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.android.ui.TextInput",
                         "mstrmojo.ui.MobileSlider",
                         "mstrmojo.MobileCalendar",
                         "mstrmojo.android.ui.Calendar",
                         "mstrmojo.android.ui.ElementsPicker",
                         "mstrmojo.android._HasLingeringListSelections",
                         "mstrmojo.locales.datetime",
                         "mstrmojo.prompt.WebPrompt",
                         "mstrmojo.ui.MobileDateTimePicker",
                         "mstrmojo.ui.MobileReviewList",
                         "mstrmojo.array",
                         "mstrmojo.BarcodeReader",
                         "mstrmojo.string");

    mstrmojo.requiresDescs(189, 221, 1442, 6149, 8382, 8383, 8384, 8397, 8761);

    var $D = mstrmojo.date,
        $DESC = mstrmojo.desc,
        $STYLES = mstrmojo.prompt.WebPrompt.STYLES,
        $TYPES = mstrmojo.prompt.WebPrompt.TYPES,
        $NUM = mstrmojo.num,
        $BTN = mstrmojo.android.ui.Button.newButton,
        $HASH = mstrmojo.hash,
        $ARR = mstrmojo.array,
        $TRANS_DURATION = mstrmojo.dom.CSS3_TRANSITION_DURATION,
        $EXPR = mstrmojo.expr,
        anchorOffset = {
            160: 10,
            213: 10,
            240: 15,
            320: 20
        };

    var requiredText = '<em>*</em>',
        iconItemCls = 'item-icon',
        choiceMainCls = 'main-btn',
        choiceItemCls = 'item-btn',
        displayStyleBarCode = 'Barcode',
        displayStyleGeo = 'GeoLocation';

    
    var itemMarkupCache = {};

    
    var stepperDown = ' onclick="mstrmojo.all.{@wid}.clickStepper({@idx}, false);"',
        stepperUp = stepperDown.replace('false', 'true');

    
    function setAnswer(item, idx, vals) {
        try {
            
            item.setAnswerValue.apply(item, vals);
        } catch (e) {
            mstrmojo.alert(e.message || e);
            return false;
        }

        
        this.updateItem(idx);
        return true;
    }

    function consolidateAnswers(original, toAdd) {
        var hashArray = [],
            tempArray = [];
        
        $ARR.forEach(original, function (item) {
            hashArray[item.v] = item;
            tempArray.push(item);
        });

        $ARR.forEach(toAdd, function (item) {
            if (hashArray[item.v]) {
                return;
            }

            tempArray.push(item);
        });

        return tempArray;
    }

    function getExistingItems(items, actualReviewItems) {
        var existingItems = [],
            len = actualReviewItems.length,
            i = 0,
            j = 0,
            lastMatchPosition = 0,
            itemsLength = items.length;

        for (i = 0; i < itemsLength; i++) {
            for (j = lastMatchPosition; j < len; j++) {
                if (items[i].v === actualReviewItems[j].dssid) {
                    existingItems.push(actualReviewItems[j]);
                    lastMatchPosition = j + 1;
                    break;
                }
            }
        }
        return existingItems;
    }

    function showReviewList(picker, items, actualReviewItems, displayKeypadView, list, idx, item, isMultiSelect) {
        var callback = this,
            dialogConfig = {
                
                title: $DESC(9755, 'Prompt Values')
            },
            dialogChildren = [],
            fnOk,
            fnCancel,
            dialog,
            reviewList,
            fnShowDialog = function () {
                
                dialogConfig.children = dialogChildren;

                fnOk = function () {
                    
                    if (dialog.deleteAction) {
                        
                        var index,
                            loopVariant = 0,
                            x;
                        
                        var newItems = [].concat(items);
                        
                        for (x in reviewList.selectedIndices) {
                            index = parseInt(x, 10) - loopVariant++;
                            actualReviewItems.splice(index, 1);
                            newItems.splice(index, 1);
                        }

                        reviewList.set('items', newItems);
                        items = newItems;

                        
                        reviewList.set('height', 'auto');
                        dialog.resizeDialog();

                        dialog.setDeleteActions("done");

                        
                        return false;
                    }

                    
                    setAnswer.call(list, item, idx, [consolidateAnswers.call(this, item.answer.items || [], reviewList.items)]);
                    dialog.close();
                };

                fnCancel = function () {
                    
                    dialog.close();

                    
                    mstrmojo.BarcodeReader.readBarcodes({   
                        'attributeID': picker.browseElements.source.did,
                        'searchForms': item.prs.LookupForm,
                        'multiSelect': isMultiSelect
                    }, callback, null, getExistingItems(reviewList.items, actualReviewItems), displayKeypadView);
                };

                
                var dBtn = $BTN($DESC(8473, 'Done'), fnOk);
                dBtn.alias = 'deleteBtn';

                dialogConfig.buttons = [$BTN($DESC(221, 'Cancel'), fnCancel), dBtn];

                
                dialog = mstrApp.showDialog(dialogConfig);

                dialog.setDeleteActions = function (actionStr) {
                    if (actionStr === "delete") {
                        this.selectionHidden = false;
                        this.deleteAction = true;
                        this.titleNode.lastChild.style.display = 'block';
                        this.btnHbox.deleteBtn.set('text', $DESC(629, 'Delete'));
                        mstrmojo.css.removeClass(reviewList.domNode, 'hidden'); 
                    } else {
                        this.selectionHidden = true;
                        this.deleteAction = false;
                        this.titleNode.lastChild.style.display = 'none';
                        this.btnHbox.deleteBtn.set('text', $DESC(8473, 'Done'));
                    }
                };

                
                dialog.updateTitleBarButtonClass = function (clsName) {
                    dialog.titleNode.lastChild.className = 'mstrmojo-Editor-titlebar-button ' + clsName;
                };

                
                dialog.createTitleBarButton('mstrmojo-Editor-titlebar-button btnCheckSemi', function () {
                    reviewList.selectAll();
                });

                dialog.setDeleteActions("done");

                
                return dialog;
            };

        
        reviewList = new mstrmojo.ui.MobileReviewList({
            controller: this.controller,
            isElastic: true,
            multiSelect: true,
            itemIdField: 'v'
        });

        dialogConfig.useMenu = false;

        
        dialogChildren.push(reviewList);

        
        reviewList.set('items', items);

        
        fnShowDialog();
    }

    
    function wasBtnClicked() {
        return (this._clkTarget.className === iconItemCls);
    }

    
    function isIconStyle(item, style, displayStyle) {
        var prs = item.prs;
        return (item.getStyle() === style || (prs && prs.DisplayStyle === displayStyle));
    }

    
    function getIconClass(item) {
        if (isIconStyle(item, $STYLES.BARCODE, displayStyleBarCode) || isIconStyle(item, $STYLES.GEO, displayStyleGeo)) {
            return (wasBtnClicked.call(this)) ? choiceItemCls : choiceMainCls;
        }

        return '';
    }

    function getAnswerCount(item) {
        if (parseInt(item.promptType, 10) === $TYPES.ELEMENTS_PROMPT && item.answer) {
            return ' (' + item.getAnswersCount() + ')';
        }

        return '';
    }

    
    function ellipsizeItem(node, idx) {
        
        var item = this.items[idx];
        if (item.isTtl) {
            
            return;
        }

        var childNodes = node.firstChild.childNodes,
            promptName = childNodes[0],
            promptAnswer = childNodes[1],
            isRequired = !!item.req,
            answerCnt = getAnswerCount(item),
            ellipsisText = this.ellipsisText,
            innerHTML;

        
        if (isRequired) {
            
            promptName.innerHTML = requiredText + promptName.innerHTML.replace(requiredText, '');
        }

        
        var h3 = this.ellipsize('h3', promptName, false);

        
        if (isRequired) {
            
            innerHTML = promptName.innerHTML.replace(requiredText, '');

            
            promptName.innerHTML = h3 ? innerHTML.replace(innerHTML.slice(-1), requiredText + ellipsisText) : innerHTML + requiredText;
        }

        
        var h4 = this.ellipsize('h4', promptAnswer, true);

        
        if (h4 && answerCnt) {
            
            promptAnswer.innerHTML = mstrmojo.string.trim(promptAnswer.innerHTML.slice(0, -(answerCnt.length + 3))) + ellipsisText + answerCnt;
        }
    }

    
    function getDialogCssClass(cls) {
        
        var css = [ 'prompts-dialog' ];

        
        if (mstrApp.isTablet() && mstrApp.isLandscape()) {
            
            css.push('prompts-landscape');
        }

        
        if (cls) {
            
            css.push(cls);
        }

        return css.join(' ');
    }

    
    function getDefaultDialogConfig(props) {
        var id = this.id;
        return $HASH.copy(props, {
            cssClass: getDialogCssClass(),
            onClose: function () {
                var list = mstrmojo.all[id];

                
                list.parent.closePrompt();

                
                list.clearSelect();
            }
        });
    }

    
    function showDialog(config, children, idx, fnOk, hideCancel, viewName) {
        
        config.children = children;
        var btns = [];

        
        if (!hideCancel) {
            
            btns.push($BTN($DESC(221, 'Cancel')));
        }

        
        if (fnOk) {

            
            btns.push($BTN($DESC(1442, 'OK'), fnOk));
        }

        
        config.buttons = btns;

        
        
        if (mstrApp.isTablet()) {
            
            config.anchor = this._getItemNode(idx);
            config.anchorOrientation = 'h';
            config.autoClose = true;
            config.anchorOffset = anchorOffset[mstrMobileApp.getDeviceDPI()];
        }

        
        this.parent.openPrompt(function () {
            mstrApp.showDialog(config, viewName);
        });
    }

    
    function selectBarCodePrompt(item, idx) {
        var id = this.id;

        
        mstrmojo.BarcodeReader.readBarcodes(null, {
            success: function (val) {
                
                if (item.promptType === $TYPES.CONSTANT_PROMPT && item.dataType === mstrmojo.mstr.EnumDataType.DataTypeBigDecimal) {
                    
                    var li = mstrApp.getLocaleInfo();
                    val = val.substr(0, 1) + ((li && li.number.DECIMALSEPARATOR) || '.') + val.substr(1);
                }

                
                if (!setAnswer.call(mstrmojo.all[id], item, idx, [ val ])) {
                    return false;
                }
            },

            failure: function (ex) {
                item.setError(ex);

                
                mstrmojo.all[id].updateItem(idx);
            }
        });
    }

    
    function selectTextPrompt(item, idx) {
        var id = this.id,
            txtId = 'plTxtInputxz';

        showDialog.call(this, getDefaultDialogConfig.call(this, {
            title: item.title
        }), [{
            scriptClass: 'mstrmojo.android.ui.TextInput',
            id: txtId,
            alias: 'textInput',
            textValue: item.getDisplayValue(false, false) || '',
            onEnter: function (value) {
                
                if (!setAnswer.call(mstrmojo.all[id], item, idx, [ value ])) {
                    return; 
                }

                
                mstrApp.closeDialog();
            }
        }], idx, function () {
            if (!setAnswer.call(mstrmojo.all[id], item, idx, [ mstrmojo.all[txtId].getValue() ])) {
                return false; 
            }
        });
    }

    
    function selectElementPrompt(item, idx) {
        var id = this.id,
            answerItems = item.answer.items || [],                 
            availableAnswers = item.getAvailable(),                
            isBarCode = isIconStyle(item, $STYLES.BARCODE, displayStyleBarCode),
            isBtn = wasBtnClicked.call(this),
            prs = item.prs,
            isMultiSelect = (item.max === "" || parseInt(item.max, 10) > 1) && prs.DisplayStyle !== 'Option button',        
            sr = prs.SearchRequired,
            searchRequired = sr && sr !== "0";

        
        availableAnswers.concat = true;

        
        var fnSetPickerAndShowDialog = function () {
            var list = mstrmojo.all[id];

            
            if (isBarCode && isBtn) {
                
                mstrmojo.BarcodeReader.readBarcodes({
                    'attributeID': availableAnswers.source.did,
                    'searchForms': item.prs.LookupForm,
                    'multiSelect': isMultiSelect
                }, {
                    success: function (val) {
                        var res = JSON.parse(val),
                            items =  availableAnswers.convertElems(res.items);

                        if (res.review) {
                            
                            var picker = new mstrmojo.android.ui.ElementsPicker({
                                isElastic: true,
                                itemIdField: 'v',
                                multiSelect: true             
                            });

                            
                            picker.set('browseElements', availableAnswers);

                            
                            picker.addSelectedItems(items);

                            
                            showReviewList.call(this, picker, items, res.items, res.displayKeypadView, list, idx, item, isMultiSelect);
                        } else {
                            
                            setAnswer.call(list, item, idx, [consolidateAnswers.call(this, answerItems, availableAnswers.convertElems(JSON.parse(val).items))]);
                        }

                    }
                });

            } else {
                
                var picker = new mstrmojo.android.ui.ElementsPicker({
                    isElastic: true,
                    itemIdField: 'v',
                    multiSelect: isMultiSelect             
                });

                
                picker.set('browseElements', availableAnswers);


                
                picker.addSelectedItems(answerItems);

                
                var searchBar = new mstrmojo.android.ui.ElementsSearchBar({
                    slot: 'titleNode',
                    target: picker,
                    browseElements: availableAnswers,
                    searchForms: isBarCode  ? item.prs.LookupForm : undefined,
                    searchRequired: searchRequired,     
                    canSearch: item.canSearch(),        
                    title: item.title                   
                });

                var fnDisplayPicker = function () {
                    var fnOk;

                    if (isMultiSelect) {
                        fnOk = function () {
                        	picker.syncSelection();
                            return setAnswer.call(list, item, idx, [ picker.getSelectedItems() ]);
                        };
                    } else {
                        
                        
                    	
                    	
                    	
                        var mySuper = picker.singleSelect;
                        picker.singleSelect = function (index, suppressEv) {
                            mySuper.call(this, index, suppressEv);
                            if (index != -1 && ! suppressEv) {
                                setAnswer.call(list, item, idx, [ picker.getSelectedItems() ]);
                                this.parent.close();
                                return true;
                            }
                        };
                    }

                    
                    showDialog.call(list, getDefaultDialogConfig.call(list, {
                        title: $DESC(6149, 'Select Elements'),
                        cssClass: getDialogCssClass('edtElementPicker'),
                        goBack: function () {
                            
                            return searchBar.goBack();
                        }
                    }), [ searchBar, picker ], idx, fnOk, false);
                };

                
                if (isIconStyle(item, $STYLES.GEO, displayStyleGeo) && isBtn) {
                    
                    item.getGeoTargetValue({
                        success: function (result) {
                        	var searchTarget = item.searchTarget,
                        	    searchBox = searchBar.search.box;
                            
                            searchBar.initSearchValue =  result;
                            searchBar.canSearch = true;
                        	
                            if ( searchTarget ) {
                                searchBar.initSearchValue = 'in "' + result + '"';
                            	searchBar.searchTarget = searchTarget;
                            	searchBox.searchValue = result;
                            }  
                            
                            fnDisplayPicker();
                        }
                    });

                } else {
                    
                    fnDisplayPicker();
                }
            }
        };

        
        if (availableAnswers.browseConfig) {
            
            availableAnswers.getItems(1, {
                success: fnSetPickerAndShowDialog
            });
        } else {
            fnSetPickerAndShowDialog();
        }
    }

    
    function selectSliderPrompt(item, idx) {
        var config = getDefaultDialogConfig.call(this, {
                title: item.title,
                cssClass: getDialogCssClass('edtSlider')
            }),
            v = item.getDisplayValue(true, false), 
            valueField = new mstrmojo.Label({
                text: v,
                cssClass: 'value'
            }),
            labelField = new mstrmojo.Label({
                text: item.mn,
                cssClass: 'title'
            }),
            id = this.id;

        
        var slider = new mstrmojo.ui.MobileSlider({
            value: $NUM.parseNumeric(v),
            max: item.max,
            min: item.min,
            interval: item.interval,
            onvalueChange: function () {
                
                valueField.set('text', $NUM.toLocaleString(this.value));
            },
            onslidingValueChange: function () {
                
                valueField.set('text', $NUM.toLocaleString(this.slidingValue));
            },
            onRender: function () {
                this.parent.attachEventListener('resizeCurtain', this.id, this.resize);
            }
        });

        
        showDialog.call(this, config, [ valueField, labelField, slider ], idx, function () {
            if (!setAnswer.call(mstrmojo.all[id], item, idx, [ String(slider.value) ])) {
                return false;
            }
        });
    }

    
    function selectDateTimePrompt(item, idx, dtp) {
        
        var config = getDefaultDialogConfig.call(this, {
                title: item.title
            }),
            dateUtil = mstrmojo.date,
            formats = mstrmojo.locales.datetime,
            answer = item.answer,
            min = item.min,
            max = item.max,
            timePicker = new mstrmojo.ui.MobileDateTimePicker({
                value: dateUtil.parseDateAndOrTime(answer || ''),    
                min: dateUtil.parseDateAndOrTime(min || ''),         
                max: dateUtil.parseDateAndOrTime(max || ''),         
                minuteInterval: item.interval,                       
                
                
                hideSwitchers: dtp == $EXPR.DTP.DATE,                
                dtp: dtp || $EXPR.DTP.TIMESTAMP                      
            }),
            id = this.id;

        
        showDialog.call(this, config, [ timePicker ], idx, function () {
            var v = timePicker.getDateTime(),
                dateInfo = v && v.date,
                timeInfo = v && v.time,
                date = (dateInfo && dateUtil.formatDateInfo(dateInfo, formats.DATEOUTPUTFORMAT)) || '',
                time = (timeInfo && dateUtil.formatTimeInfo(timeInfo, formats.TIMEOUTPUTFORMAT)) || '',
                answer = [date + ' ' + time];

            
            if (item.promptType === $TYPES.ELEMENTS_PROMPT) {
                answer = [answer];
            }

            if (!setAnswer.call(mstrmojo.all[id], item, idx, answer)) {
                return false;
            }
        });
    }

    
    function selectCalenderPrompt(item, idx) {
        
        var calendar =  {
                alias: 'calendar'
            },
            max = item.max,
            id = this.id,
            fnOk,
            calendarWidget,
            isSingleSelectPrompt = false,
            promptsFiltersNode = this.parent.domNode,
            
            config = $HASH.copy(getDefaultDialogConfig.call(this, {
                cssClass: getDialogCssClass()
            }), {
                targetListHeight: promptsFiltersNode.clientHeight, 
                targetListWidth: promptsFiltersNode.clientWidth
            });

        switch (item.promptType) {
        case $TYPES.CONSTANT_PROMPT:
            
            isSingleSelectPrompt = true;
            break;

        case $TYPES.ELEMENTS_PROMPT:
            
            if (1 === parseInt(max, 10)) {
                isSingleSelectPrompt = true;
                break;
            }

            
            config.title = $DESC(8383, 'Select Dates');

            
            calendar.min = $D.parseDate(item.prs.LocalizedMinDate || '');
            calendar.max = $D.parseDate(item.prs.LocalizedMaxDate || '');

            
            calendar.selectedDates = item.getAnswerAsDateArray();

            calendar.isMultiSelect = true;

            
            fnOk = function () {
                try {
                    
                    item.setAnswerValue(calendarWidget.getSelectedDates());
                } catch (e) {
                    mstrmojo.alert(e.message || e);
                    return false;
                }

                
                item.syncDateAnswer({
                    success: function () {
                        
                        mstrApp.closeDialog();

                        var list = mstrmojo.all[id];
                        list.updateItem(idx);

                        
                        setAnswer.call(list, item, idx, [calendarWidget.getSelectedDates()]);
                    },

                    failure: function (msg) {
                        
                        window.setTimeout(function () {
                            mstrmojo.alert(msg);
                        }, 0);
                    }
                });

                
                return false;
            };
            break;

        default:
            throw new Error($DESC(8397, 'Error: Unknown prompt type.'));
        }

        if (isSingleSelectPrompt) {
            selectDateTimePrompt.call(this, item, idx, $EXPR.DTP.DATE);
        } else {
            
            calendarWidget = new mstrmojo.android.ui.Calendar(calendar);

            
            showDialog.call(this, config, [ calendarWidget ], idx, fnOk, false, 'CalendarDialog');
        }
    }

    
    function selectGeoPrompt(item, idx) {
        var id = this.id;

        
        
        mstrmojo.confirm($DESC(8384, '"MicroStrategy" Would Like to use Your Current Location.'), [ $BTN($DESC(221, 'Cancel')), $BTN($DESC(1442, 'OK'), function () {
            mstrmojo.GeoLocation.getCurrentLocation({
                success: function (la, lo, al) {
                    setAnswer.call(mstrmojo.all[id], item, idx, [ la, lo ]);
                },

                failure: function (ex) {
                    item.setError(ex);

                    
                    mstrmojo.all[id].updateItem(idx);
                }
            });
        })]);
    }

    
    function selectSwitchPrompt(item, idx) {
        
        item.toggleSwitch();

        
        this.updateItem(idx);
    }

    
    var promptFnMap = {};
    promptFnMap[$STYLES.BARCODE] = selectBarCodePrompt;
    promptFnMap[$STYLES.TEXT] = selectTextPrompt;
    promptFnMap[$STYLES.LIST] = selectElementPrompt;
    promptFnMap[$STYLES.SLIDER] = selectSliderPrompt;
    promptFnMap[$STYLES.CALENDAR] = selectCalenderPrompt;
    promptFnMap[$STYLES.TIME] = selectDateTimePrompt;
    promptFnMap[$STYLES.GEO] = selectGeoPrompt;
    promptFnMap[$STYLES.SWITCH] = selectSwitchPrompt;

    
    mstrmojo.android.ui.PromptsList = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        [ mstrmojo._SupportsEllipsisText, mstrmojo.android._HasLingeringListSelections ],

        
        {
            scriptClass: "mstrmojo.android.ui.PromptsList",

            listHooks: {
                select: function (el, item, idx) {
                    var cls = getIconClass.call(this, item);
                    if (cls) {
                        mstrmojo.css.addClass(el, cls);
                    }

                    
                    el.style[$TRANS_DURATION] = 0;

                    
                    this.setClearHandler(200);
                },
                unselect: function (el, item, idx) {
                    var cls = getIconClass.call(this, item);
                    if (cls) {
                        mstrmojo.css.removeClass(el, cls);
                    }

                    
                    el.style[$TRANS_DURATION] = '300ms';
                }
            },

            getItemMarkup: function (item) {
                
                if (item.isTtl) {
                    
                    return '<div class="item {@cls}" idx="{@idx}">{@ttl}</div>';
                }

                
                var style = item.getStyle(),
                    showIcon = isIconStyle(item, $STYLES.GEO, displayStyleGeo) || isIconStyle(item, $STYLES.BARCODE, displayStyleBarCode),
                    cacheKey = style + String(item.req) + (showIcon ? 'ic' : ''),
                    markup = itemMarkupCache[cacheKey];

                
                if (!markup) {
                    
                    var sb = new mstrmojo.StringBuffer();

                    sb.append('<div class="item {@cls}" idx="{@idx}"><div><h3>{@ttl}' + requiredText + '</h3><h4>{@val}</h4>');

                    
                    if (style === $STYLES.STEPPER) {
                        
                        sb.append('<div class="step"><div' + stepperDown + '></div><div>{@v}</div><div' + stepperUp + '></div></div>');

                    } else if (showIcon || style === $STYLES.SWITCH) {
                        
                        sb.append('<div class="' + iconItemCls + '"><div></div></div>');

                    }

                    
                    markup = itemMarkupCache[cacheKey] = sb.toString() + '</div></div>';
                }

                
                return markup;
            },

            getItemProps: function getItemProps(item, idx) {
                
                var props = this._super(item, idx);

                
                props.ttl = item.title;

                
                if (item.isTtl) {
                    
                    props.addCls('ttl');
                    return props;
                }

                
                var style = item.getStyle(),
                    isStepperOrSwitch = (style === $STYLES.STEPPER || style === $STYLES.SWITCH),
                    displayValue = item.getDisplayValue(isStepperOrSwitch, isStepperOrSwitch);          

                
                if (isIconStyle(item, $STYLES.BARCODE, displayStyleBarCode)) {
                    
                    props.addCls('bar');

                } else if (isIconStyle(item, $STYLES.GEO, displayStyleGeo)) {
                    
                    props.addCls('geo');

                }

                
                props.wid = this.id;
                props.val = displayValue || '';                 

                
                props.addCls('st' + style);

                
                if (item.req) {
                    
                    props.addCls('req');
                }

                
                switch (style) {
                case $STYLES.STEPPER:
                    
                    if (!item.canStepUp()) {
                        props.addCls('max');
                    }

                    
                    if (!item.canStepDown()) {
                        props.addCls('min');
                    }

                    
                    props.v = displayValue;

                    
                    props.val = item.mn || '';
                    break;

                case $STYLES.SWITCH:
                    
                    props.val = item.mn || '';

                    
                    if (displayValue) {
                        
                        props.addCls('on');
                    }
                    break;

                case $STYLES.GEO:
                    if (!item.displayLoc) {
                        item.getDisplayLocation(this, displayValue);
                    }
                    break;
                }

                
                if (props.val) {
                    
                    props.addCls('has-ans');
                }

                
                return props;
            },

            updateItem: function updateItem(idx) {
                
                ellipsizeItem.call(this, this._super(idx), idx);
            },

            
            allowTouchBubble: false,

            
            onRender: function onRender() {
                if (this._super) {
                    this._super();
                }

                var items = this.itemsContainerNode.childNodes,
                    cnt = items.length,
                    i;

                
                for (i = 0; i < cnt; i++) {
                    
                    ellipsizeItem.call(this, items[i], i);
                }
            },

            
            clickStepper: function clickStepper(idx, isUp) {
                
                this.items[idx]['step' + (isUp ? 'Up' : 'Down')]();

                
                this.updateItem(idx);
            },

            
            postselectionChange: function postselectionChange(evt) {
                
                var added = evt.added;
                if (!added) {
                    
                    return;
                }

                
                var idx = added[0],
                    item = this.items[idx],
                    style = item.getStyle();

                
                if (style === $STYLES.BARCODE && !wasBtnClicked.call(this)) {
                    
                    style = $STYLES.TEXT;
                }

                
                var fnPrompt = promptFnMap[style];
                if (fnPrompt) {
                    
                    fnPrompt.call(this, item, idx);
                }
            },

            rootOrientationChange: function rootOrientationChange() {
                
                this.refresh();
            },

            
            touchSelectBegin: function touchSelectBegin(touch) {
                
                var idx = this.getItemIdxTouch(touch);
                if (idx > -1) {
                    
                    var item = this.items[idx],
                        style = item.getStyle(),
                        msg = [];

                    
                    var description = item.mn || '';
                    if (description) {
                        
                        msg.push(description);
                    }

                    
                    if (!(style === $STYLES.SWITCH) && !(style === $STYLES.STEPPER)) {
                        
                        var answer = item.getDisplayValue(false, false);
                        if (answer) {
                            msg.push(answer);
                        }
                    }

                    
                    if (item.req) {
                        
                        msg.push($DESC(475, 'This prompt is required and must be answered.'));
                    }

                    
                    if (msg.length) {
                        
                        mstrmojo.alert(msg.join('<br /><br />'), null, $DESC(189, 'Details'));
                    }

                    
                    return false;
                }

                
                return true;
            },

            touchTap: function touchTap(evt) {
                
                var item = this.items[this.getItemIdxTouch(evt)];
                if (item && item.isTtl) {
                    
                    return;
                }

                
                this._clkTarget = evt.target;

                this._super(evt);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.TextFieldDIC",
                         "mstrmojo.android._HasPreviewButton");

    mstrmojo.android.inputControls.TextFieldDIC = mstrmojo.declare(

        mstrmojo.TextFieldDIC,

        [ mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: 'mstrmojo.android.inputControls.TextFieldDIC',

            cssClass: 'mstrmojo-TextFieldDIC',

            cssDisplay: 'block',

            
            onfontChange: mstrmojo.emptyFn,

            
            applyChanges: function applyChanges() {
                
                
                
                this.domNode.blur();
                return this._super();
            },

            
            handleInvalid: function handleInvalid() {
                
                mstrmojo.alert(this.validationStatus.msg);
            },

            cancelChanges: function cancelChanges() {
                this.domNode.blur();
                this._super();
            },

            
            focus: function focus() {
                this.validate();
            },

            onfocus: function onfocus() {
                
                if (this.value != undefined && this.maxLength != undefined && String(this.value).length > this.maxLength) {
                    this.set('value', '');
                }
                
                window.setTimeout(function () {
                    mstrMobileApp.forceRepaint();
                }, 0);
            },

            renderPreview: function renderPreview() {
                var openerNode = this.openerNode,
                    group = this.group || this,
                    showFullPreview = (group.openerType === 2) || !!this.dic.dm || this.dicChanged;   

                var displayValue = this.type === "password" ? '********' : this.dv;
                this.renderPreviewButton(openerNode, showFullPreview ? displayValue : openerNode.innerHTML);
            }
        }
    );
}());
(function() {

	var prevWidth,
		prevHeight;

	mstrmojo.requiresCls("mstrmojo.Container", "mstrmojo.DocPortlet");

	var FMTS = {'top':'top',
	            'left':'left',
	            'z-index':'zIndex',
	            'width':'width',
	            'height':'height'};

    
    mstrmojo.Vis = mstrmojo.declare(

        
        mstrmojo.Container,

        
        [mstrmojo._HasLayout],

        
        {
            
            scriptClass: 'mstrmojo.Vis',

            offsetTop:0,

            offsetLeft:0,

            isAndroid: window.navigator.userAgent.indexOf('Android') != -1,

            updated: false,

            reRenderOnDimensionChg: true,

            getFormats: function() {
                
                return this.fmts;
            },

            isVis: function() {
            	return true;
            },

            setModel: function setModel(model) {

            	this.set('model', model);

            	
                if (model.data) {
                    this.set('model', model.data);
                }
            	this.xtabModel = model;

                    
            	if (typeof (this.controller.getPageByTree) != 'undefined') {

                    this.controller.getPageByTree(false);
                }
            },

            destroy: function destroy() {
            	this._super();

            	var xtab = this.xtabModel;
            	if (xtab && xtab.destroy) {
            		xtab.destroy();
            		
            		delete this.xtabModel;
            	}

            },

            setDimensions: function setDimensions(h, w) {
            	var dimensionChanged = this._super(h, w);
            	if (dimensionChanged && this.hasRendered && this.reRenderOnDimensionChg ) {
            		this.reRender();
            	}
            	return dimensionChanged;
            },

            reRender: function reRender() {
            	this.unrender();
            	this.render();
            },

            getWidth: function getWidth() {
            	return parseInt(this.width, 10); 
            },

            getHeight: function getHeight() {
            	return parseInt(this.height, 10); 
            },























            buildRendering: function bldRn() {

            	if (!this.updated) {
            		this.update();
            	}

                
                if (this.parent instanceof mstrmojo.DocPortlet) { 
                    delete this.left;
                    delete this.top;
                    this.height = this.fmts && this.fmts.height;
                }

            	
            	this._super();
            },

            postBuildRendering: function postBR(){
            	prevWidth = this.width;
            	prevHeight = this.height;

            	this.adjustWidgetOffsets();

            	
            	this._super();
            },

            adjustWidgetOffsets: function adjustWidgetOffsets() {
            	var dn = this.domNode,
            	offset = {
            			top: 0,
            			left: 0
            	};

            	if (typeof(mstr) != 'undefined') {
            		offset.top = mstr.utils.BoxModel.getElementSumOffsetTop(dn);
            		offset.left = mstr.utils.BoxModel.getElementSumOffsetLeft(dn);
            	} else if (typeof(mstrmojo) != 'undefined') {
            		offset = mstrmojo.boxmodel.offset(dn);
            	}

            	this.offsetTop = offset.top;
            	this.offsetLeft = offset.left;
            },

        	
			initFromVisProps: function initFromVisProps(vp) {},

            update: function update(node) {
                node = node || this.node;
                if (node) { 
                	if (node.data) {
                	    this.set('model', node.data);
						
						
						if(this.xtabModel && this.xtabModel.set){
							this.xtabModel.set('data',node.data);
						}
                		this.model = node.data;
                		if (this.model.layoutModel) this.layoutModel = this.model.layoutModel;
                		if (this.model.layoutNode) this.layoutNode = this.model.layoutNode;

                        
                        mstrmojo.hash.copy(node.data.extProps, this);
                	}

            	 	this.fmts = node.defn.fmts || node.defn.units[this.model.k].fmts;

                    var fmts = this.fmts;
                    if(fmts){
                        for(var k in FMTS){
                            v = FMTS[k];
                            if(k in fmts){
                                this[v] = fmts[k];
                            }
                        }
                    }
                }

                if (this.model) {
                    this.initFromVisProps(this.model.vp);
                }
                this.updated = true;
            },

            getModel: function getModel(k) {
            	if (k) {
            		var m = mstrmojo.Vis.getVisGrid(this.layoutModel, this.layoutNode, k);
            		if (m) {
            			return m.data;
            		} else {
            			alert(mstrmojo.desc(8427,"Incorrect visualization properties encountered.  Data may be inconsistent.  Please reset your properties."));
            		}
            	} else {
            		return this.model;
            	}
            },

            getDataParser: function getDataParser(key) {
            	return new mstrmojo.Vis.DataParser(this.getModel(key));
            },

            
            renderErrorMessage: function renderErrorMessage(msg) {
            	this.domNode.innerHTML = "<div class=\"mstrmojo-message\">" + msg + "</div>";
            },

            getMessageID: function getMessageID() {
                return this.model.mid && this.model.mid || this.xtabModel && this.xtabModel.docModel && this.xtabModel.docModel.mid;
            },

            
            hasNoninfowindowTarget: function hasNoninfowindowTarget(actionObj) {
            	var xtabModel = this.xtabModel,
		    		docModel = (xtabModel && xtabModel.docModel);

            	var result = false;
				if (docModel) {
					var layouts = docModel.defn && docModel.defn.layouts,
						layout = null;
					var i;
					
					if (layouts) {
						for(i in layouts) {
							if (layouts[i].loaded) {
								layout = layouts[i];
								break;
							}
						}
					}

					var units = layout && layout.units;
					this.selectorTargets = {};
					if (units && actionObj.scObjList) {
						for(var i = 0; i < actionObj.scObjList.length; i++){
		        			var scObj = actionObj.scObjList[i];
		        			

		        			var tksList = scObj.sc.tks.split("\x1E");
		        			for(var j = 0; j < tksList.length; j++){
		        				var unit = units[tksList[j]];
		        				if (unit) {
		        					this.selectorTargets[tksList[j]] = unit;
		        					if (!this.isChildOfIfw(units, unit)) {
		        						result = true;
		        					}
		        				}
		        			}
		        		}
					}
				}

				return result;
            },

            isChildOfIfw: function isChildOfIfw(units, unit){
            	while(unit){
            		if(unit.ifw){
            			return true;
            		}
                	unit = units[unit.pnk];
            	}
            	return false;
            },

            performAction: function performAction(actionObj){
            	var action = this.xtabModel.getAction(actionObj),
            		handler = action && action.h;
            	if(handler && this.controller[handler]){
            		this.controller[handler](this, action.a);
            		return true;
            	}
            	return false;
			}
        }
    );

    
    mstrmojo.Vis.getVisGrid = function(m , n , k ) {
    	var origN = n;
    	var chldn = m.getChildren(n, false);
    	for (var i=0; i < chldn.length; i++) {
    		var c = chldn[i];
    		if (c.k == k) {
    			return c;
    		} else {
    			var g = mstrmojo.Vis.getVisGrid(m, c, k);
    			if (g) {
    				n = origN; 
    				return g;
    			}
    		}
    	}
    };

    mstrmojo.Vis.DataParser = function (m ) {
    	var ns = mstrmojo.Vis;

            	return {
            		getRowTitles: function() {
	            		return new ns.Titles(m, true);
	            	},

            		getColTitles: function() {
	            		return new ns.Titles(m, false);
	            	},

	            	findMetricValue: function(rvIdx , c ) {
	            		var rhs = m.ghs.rhs.items;
	            		for (var e in rhs) {
	            			var row = rhs[e].items;
	            			var found = true;
	            			for (var i in rvIdx) {
	            				if (rvIdx[i] != row[i].idx) {found = false; break;}
	            			}
	            			if (found) {
	            				return new mstrmojo.Vis.MetricValue(m.gvs.items[e].items[c]);
	            			}
	            		}
	            	},

	            	getTotalRows: function getTotalRows() {
	            		return m.eg ? 0 : m.ghs.rhs.items.length;
	            	},

            getTotalColHeaderRows : function getTotalColHeaderRows(){
                return (!m.ghs.chs.items ? 0: m.ghs.chs.items.length);
            },

        	getTotalCols: function getTotalCols() {
        		return this.getColHeaders(0).size();
        	},

        	getRowHeaders: function getRowHeaders(pos ) {
        		return new ns.Headers(m, pos, true);
        	},

        	getColHeaders: function getColHeaders(pos ) {
        		return new ns.Headers(m, pos, false);
        	},

        	getMetricValue: function getMetricValue(row, col) {
                return new ns.MetricValue(m, m.gvs.items[row].items[col]);
            },

            getColumnHeaderCount : function getColumnHeaderCount(){
                return m.gvs.items[0].items.length;
            },

            getCSSString : function getCSSString()
            {
                return m.cssString;
            }


    	};
    };

    mstrmojo.Vis.Titles = function (m, isRow) {
    	var t = (isRow) ? m.gts.row : m.gts.col;
    	return {
    		size: function size() {return t.length;},
            getTitle: function getTitle(pos) {return new mstrmojo.Vis.Title(t[pos]);},
            getCSS : function getCSS(pos) {return m.css[t[pos].cni].n;}
    	};
    };

    mstrmojo.Vis.Headers = function (m , i , isRow ) {
    	var t = (isRow) ? m.gts.row : m.gts.col;
    	var hs = (isRow) ? m.ghs.rhs : m.ghs.chs;
    	var h = hs.items && hs.items[i].items;

    	return {
    		size: function size() {return (!h ? 0: h.length);},
    		getHeader: function getHeader(pos) {
                return h && h[pos] && new mstrmojo.Vis.Header(h[pos], isRow ? t[pos] : t[i]);
            },
            getCSS : function getCSS(pos) {
                return h && m.css[h[pos].cni].n;
            },
            getHeaderCell : function(pos)
            {
                return h && h[pos];
            }

    	};
    };

    mstrmojo.Vis.Title = function (t ) {
    	return {
    		
    		getActionType: function() {return t.at;},
    		
    		getDrillPath: function() {return t.dp;},
    		getHeaderValues: function getHeaderValues() {return t.es;},
    		getHeaderName: function getHeaderValue(pos) {return t.es[pos].n;},
    		getHeaderId: function getHeaderValue(pos) {return t.es[pos].id;},
    		getForms: function getForms() {return t.fs;},
    		getFormId: function() {return t.fid;},
    		getFormType: function() {return t.ftp;},
    		getUnitId: function() {return t.id;},
    		
    		getLinkMap: function() {return t.lm;},
    		getName: function() {return t.n;},
            getUnitDssType: function() {return t.otp;},
            getSelectorControl : function() {return t.sc;}
    	};
    };

    mstrmojo.Vis.Header = function (h , t ) {
    	return {
    		getName: function getName() {
                return (h.idx === -1) ? "" :t.es[h.idx].n;
            },
            getElementId : function getElementId(){
                return (h.idx === -1) ? "" : t.es[h.idx].id;
            },
            getObjectId: function getId() {
                return (h.idx === -1) ? "" : t.es[h.idx].oid;
            },
            getElementIndex : function getElementIndex(){
                return h.idx;
            },
            getActionType : function getActionType(){
                return h.at;
            },
            isTotal : function isTotal(){
               return h.otr === 1;
            }
        };
    };

    mstrmojo.Vis.MetricValue = function (m, jsonObj) {
    	var v = jsonObj;
    	return {
            getValue: function getValue() {return v.v;},
            getThresholdType : function getThresholdType() { return v.ty;},
            getRawValue : function getRawValue() { return v.rv;},
            getCSS : function getCSS() { return m.css[v.cni].n;},
            getThresholdValue : function getThresholdValue(defaultValue)
            {
                if (v.ti == undefined) {
                    return defaultValue;
                }

                return m.th[v.ti].n;
            },
			getFillColor : function getFillColor(defaultValue)
            {
                if (v.ci == undefined) {
                    return defaultValue;
                }

                return m.fc[v.ci].n;
            }
    	};
    };
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.android.Popup",
                         "mstrmojo.array",
                         "mstrmojo.android.TextArea",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo.hash");

    mstrmojo.requiresDescs(1442);

    var $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom,
        $ARR = mstrmojo.array,
        $HASH = mstrmojo.hash;

    
    var $DIALOG = mstrmojo.android.Dialog = mstrmojo.declare(

        mstrmojo.android.Popup,

        [ mstrmojo._TouchGestures ],

        
        {
            scriptClass: "mstrmojo.android.Dialog",

            autoClose: false,

            
            btnVisible: true,

            init: function init(props) {
                this._super(props);

                var css = [ 'dialog' ];

                if (this.title) {
                    css.push('has-ttl');
                }

                
                if (props.anchor) {
                    
                    this.curtainPosition = mstrApp.getContentPosition();
                }

                $CSS.addWidgetCssClass(this, css);
            },

            
            preBuildRendering: function preBuildRendering() {
                
                var buttons = this.buttons;
                if (buttons && !this.btnHbox) {

                    
                    var ths = this,
                        id = this.id,
                        fn = function () {
                            
                            if (!ths.manualClose) {
                                
                                window.setTimeout(function () { 
                                    var dialog = mstrmojo.all[id];
                                    if (dialog) {
                                        dialog.close();
                                    }
                                }, 50);
                            }
                        };

                    
                    $ARR.forEach(buttons, function (btn) {
                        
                        btn.origFn = btn.onclick;

                        
                        btn.onclick = function (event) {
                            
                            if (this.origFn) {
                                
                                if (this.origFn() === false) {
                                    
                                    return;
                                }
                            }

                            
                            fn();

                            
                            event.e.stopPropagation();
                            event.e.cancelBubble = true;
                        };
                    });
                }

                this._super();
            },

            postBuildRendering: function postBuildRendering() {
                
                if (this.onTitleClick) {
                    
                    var id = this.id;
                    $DOM.attachEvent(this.titleNode, 'click', function (evt) {
                        mstrmojo.all[id].onTitleClick(evt);
                    });
                }

                return this._super();
            },

            
            getResizeHandler: function getResizeHandler() {
                var id = this.id,
                    fn = function () {
                        var dialog = mstrmojo.all[id];
                        if (dialog.dialogRefresh) {
                            dialog.dialogRefresh();
                        } else {
                            dialog.resizeDialog();
                            dialog.positionDialog();
                        }
                    };

                return fn;
            },

            resizeDialog: function resizeDialog() {
                this._super();

                
                var buttonCnt = this.buttons && this.buttons.length;
                if (buttonCnt) {
                    
                    var buttonNode = this.buttonNode,
                        btnVisible = this.btnVisible;

                    
                    if (!btnVisible) {
                        
                        this.set('btnVisible', true);
                    }

                    
                    var btns = this.btnHbox.children,
                        $CS = $CSS.getComputedStyle,
                        slotStyle = $CS(buttonNode),
                        btnStyle = $CS(btns[0].domNode);

                    
                    var availWidth = buttonNode.clientWidth - parseInt(slotStyle.paddingLeft, 10) - parseInt(slotStyle.paddingRight, 10),
                        btnOffset = parseInt(btnStyle.paddingLeft, 10) + parseInt(btnStyle.paddingRight, 10) + parseInt(btnStyle.borderLeftWidth, 10) + parseInt(btnStyle.borderRightWidth, 10),
                        btnSpace = availWidth - (buttonCnt * btnOffset);

                    
                    var buttonWidth = Math.floor(btnSpace / buttonCnt);

                    
                    $ARR.forEach(btns, function (btn) {
                        
                        btn.set('width', buttonWidth + 'px');
                    });

                    
                    this.set('btnVisible', btnVisible);
                }
            },

            
            resizeCurtain: function resizeCurtain() {
                var curtainNode = this.curtainNode,
                    body = document.body,
                    cs = curtainNode.style,
                    curtainPosition = this.curtainPosition;

                
                cs.width = body.scrollWidth + 'px';
                
                if (curtainPosition && curtainPosition.h) {
                	cs.height = curtainPosition.h + 'px';
                } else {
                	
                	
                	cs.height = body.scrollHeight + 'px';
                }
                
                if (curtainPosition && curtainPosition.y) {
                	cs.top = curtainPosition.y + 'px';
                }
                
                this.raiseEvent({name: 'resizeCurtain'});
            },
            
            setButtonVisibility: function setButtonVisibility(isVisible) {
                this.buttonNode.style.display = isVisible ? 'block' : 'none';
            },

            createTitleBarButton: function createTitleBarButton(className, fn, title) {
                var bl = document.createElement('div');
                bl.className = className;
                bl.setAttribute('title', title || '');
                
                bl[(mstrApp.isTouchApp()) ? 'ontouchend' : 'onclick'] = fn;

                this.titleNode.appendChild(bl);
            }
        }
    );

    
    var markupMethods = $HASH.copy($DIALOG.prototype.markupMethods);
    markupMethods.onbtnVisibleChange = function () {
        this.buttonNode.style.display = (this.btnVisible) ? 'block' : 'none';
    };
    $DIALOG.prototype.markupMethods = markupMethods;

    
    if (window.mstrConfig && !window.mstrConfig.simpleDialog) {

        var fnGetLabelChild = function (msg) {
            return [{
                scriptClass: 'mstrmojo.android.TextArea',
                text: msg,
                cssClass : 'mstrmojo-androidAlert',
                isElastic: true
            }];
        };

        
        mstrmojo.alert = function alrt(msg, fn, title) {
            mstrApp.showDialog({

                title: title || "MicroStrategy Mobile",
                buttons: [ mstrmojo.android.ui.Button.newButton(mstrmojo.desc(1442, 'OK'), function () {
                    if (fn) {
                        fn();
                    }
                })],
                children: fnGetLabelChild(msg)
            });

        };

        
        mstrmojo.confirm = function confirm(msg, buttons, title) {
            
            mstrApp.showDialog({
                title: title || 'MicroStrategy Mobile',
                buttons: buttons,
                children: fnGetLabelChild(msg)
            });
        };

        
        mstrmojo.toast = function toast(msg, duration) {
            mstrApp.showToastNotification(msg, duration || 3500);
        };

        
        mstrmojo.mask = {
            show: function show(msg) {
                mstrMobileApp.showProgress([ msg || ''], false );
            },

            hide: function hide() {
                mstrMobileApp.hideProgress();
            }
        };
    }
}());
(function() {
    
    mstrmojo.requiresCls("mstrmojo.Magnifier",
    					 "mstrmojo.hash");
    
    var SELECTED_CELL_CSS = 'xtab-selected-cell';

    
    mstrmojo._HasMagnifier = {
            
        scriptClass: 'mstrmojo._HasMagnifier',
        
        magnifiedNode: null,
        
        magnifier: null,

        
        magnifierHelper: null,
        
        onmagnifiedNodeChange: function(evt){
            var oldNd = evt.valueWas,
                newNd = evt.value;
            
            if (oldNd){
                mstrmojo.css.removeClass(oldNd, SELECTED_CELL_CSS);
            }
            if (newNd){
                mstrmojo.css.addClass(newNd, SELECTED_CELL_CSS);
            }
        },
        
        displayMagnifier: function dspMgnf(touch, config) {
            var helper = this.magnifierHelper,
                touchObj = helper.resolveTouchEvent(touch), 
                info, anchor, anchorPos;
            
            
            if (touchObj){
                anchor = touchObj.cell;
                anchorPos = touchObj.pos;
                
                
                if (anchor != this.magnifiedNode){
                    
                    info = helper.resolveInfoToDisplay(touchObj);
                
                    
                    if (info){
                        this.set('magnifiedNode', anchor);
                        
                        
                        if (!this.magnifier){
                            var me = this;
                            this.magnifier = mstrApp.showPopup(
                            	mstrmojo.hash.copy({
	                                scriptClass: 'mstrmojo.Magnifier',
	                                onClose: function(){
	                                    me.magnifier = null;
	                                    me.set('magnifiedNode', null);
	                                },
	                                helper: helper
                            	}, config), anchor
                            );
                        }
                        
                        
                        this.magnifier.updateContent();
                        this.magnifier.resizeAndPosition(anchorPos);
                    }else {
                        
                        if (this.magnifier){
                            this.magnifier.close();
                        }
                    }
                }else {
                    
                    if (this.magnifier){
                        this.magnifier.moveTo(anchorPos);
                    }
                }
            }
        }
    };
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.string",
                         "mstrmojo._HasPopup",
                         "mstrmojo.ListBase",
                         "mstrmojo.Editor",
                         "mstrmojo.SuggestionList");

    
    function stepSelect(isForward) {
        var list = this.list,
            idx = list.selectedIndex,
            len = list.items.length,
            clearTarget = (isForward) ? len - 1 : 0;

        if (idx === clearTarget) {
            list.clearSelect();
            return;
        }

        if (idx === null || idx < 0) {
            idx = (isForward) ? 0 : len - 1;
        } else {
            idx += (isForward) ? 1 : -1;
        }

        list.singleSelect(idx);
    }

    
    mstrmojo._HasSuggestion = mstrmojo.provide(
        "mstrmojo._HasSuggestion",

        mstrmojo.hash.copy(mstrmojo._HasPopup, {
            blockBegin: 1,

            blockCount: -1,

            
            suggestCount: 15,

            autoSelect: true,

            
            itemField: 'n',

            
            candidates: null,

            
            suggestionShown: false,

            
            suggestionItems: null,

            
            _last_hit: null,

            
            _request_pattern: null,

            
            browseItemVisible: false,

            
            folderLinksContextId: 25,

            
            browsableTypes: '1,8',


            
            REQUEST_THRESHOLD: 20,

            noCache: false,

            
            getCandidatesThroughTaskCall: mstrmojo.emptyFn,

            
            onSuggestionItemSelect: function onSuggestionItemSelect(item) {
                this.hideSuggestion();
            },

            
            getSearchPattern: function getSearchPattern() {
                return '';
            },

            
            getSuggestionPos: function getSuggestionPos() {
                return {
                    left: '100px',
                    top: '100px'
                };
            },

            
            getSuggestionTarget: function getSuggestionTarget() {
                return this;
            },

            
            
            showSuggestion: function showSuggestion(pattern) {
                var its = this.getSuggestion(pattern);

                
                if (!this.noCache && its !== -1) {
                    this.updateSuggestion(its);
                }
            },

            
            hideSuggestion: function hideSuggestion() {
                this.suggestionShown = false;
                if (this.suggestionPopup.visible) {
                    this.suggestionPopup.close();
                }
            },

            
            getSelected: function getSelected() {
                return (this.suggestionShown) ? this._lastOpened.getSelected() : null;
            },

            
            nextHighlight: function nextHighlight() {
                if (this.suggestionShown) {
                    this._lastOpened.nextHighlight();
                }
            },

            
            preHighlight: function preHighlight() {
                if (this.suggestionShown) {
                    this._lastOpened.preHighlight();
                }
            },


            
            getSuggestion: function getSuggestion(t) {
                var c = this.candidates,
                    its = c && c.items,
                    ic = c && c.isComplete,
                    lh = this._last_hit;

                if (!this.noCache && (c || lh)) {
                    var fcs = this.filterCandidates(its, t, this.REQUEST_THRESHOLD),
                        len = fcs.length,
                        sc = this.suggestCount,
                        hit = false;

                    
                    if (!ic && len < sc) {
                        var p = lh && lh.pattern;
                        if (lh && p && (t.indexOf(p) > -1)) {
                            hit = true;
                            var lhc = this.filterCandidates(lh.items, t, this.REQUEST_THRESHOLD),
                                llen = lhc && lhc.length,
                                A = mstrmojo.array,
                                ifd = this.itemField,
                                i;

                            for (i = 0; i < llen; i++) {
                                if (A.find(fcs, ifd, lhc[i][ifd]) === -1) {
                                    fcs.push(lhc[i]);
                                }
                            }

                            len = fcs.length;
                        }
                    }


                    
                    
                    if (!ic && ((t.length > 2 && len < this.REQUEST_THRESHOLD) || (len < sc))) {
                        this.requestCandidates(t);
                        
                        return -1;
                    }

                    return (len < sc) ? fcs : fcs.slice(0, sc);
                }



                
                this.requestCandidates(t);
                return -1;  
            },

            requestCandidates: function requestCandidates(t) {
                this._request_pattern = t;

                var me = this,
                    targetWas = this.getSuggestionTarget(),
                    callbacks = {
                        success: function (res) {
                            if (!res) {
                                return;
                            }

                            var target = me.getSuggestionTarget();
                            if (!target || (targetWas !== target)) { 
                                return;
                            }

                            var newPattern = target.getSearchPattern(),
                                its = res.items;

                            me._last_hit = {
                                items: its,
                                pattern: t
                            };
                            me.sz = res.sz;

                            
                            
                            if (!me.noCache && its) {
                                var c = me.candidates && me.candidates.items|| [],
                                    _its = [].concat(its); 
                                for (var i = 0, len = its.length; i < len; i ++) {
                                    var it = _its[i];

                                    if (mstrmojo.array.indexOf(c, it) > -1) {
                                        mstrmojo.array.removeItem(its, it);
                                    }
                                }
                                
                                if (me.candidates) {
                                    me.candidates.items = c.concat(its);
                                }
                            }

                            if (newPattern && newPattern.indexOf(t) > -1) {
                                var fcs = me.filterCandidates(its, newPattern);
                                me.updateSuggestion(fcs);
                            }
                        },

                        failure: function (res) {
                            mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
                        }
                    };

                this.getCandidatesThroughTaskCall({
                    pattern: t,
                    blockBegin: this.blockBegin,
                    blockCount: this.blockCount,
                    isSuggest: true
                }, callbacks);
            },


            filterCandidates: function filterCandidates(its, t, max) {
                max = max || this.suggestCount;
                t = mstrmojo.string.regEscape(t);

                var itf = this.itemField,
                    fcs = mstrmojo.array.filter(its, function (it) {
                        return (new RegExp('\\s' + t + '|^' + t, 'i')).test(it[itf]);
                    }, {
                        max: max
                    });

                return fcs;
            },
            
            getHighlightedText: function getHighlightedText(pattern, n) {
                if (!this.highlightPattern || mstrmojo.string.isEmpty(pattern)) {
                    return n;
                }

                try {
                    if (!this.nameWildcards || mstr.$A.find([2, 32], parseInt(this.nameWildcards, 10)) > -1) { 
                        n = n.replace(new RegExp('(^|\\s)('+ pattern + ')', 'gi'), '$1<b>' + '$2' + '</b>');
                    } else {
                        var words = pattern.split(' '),
                            i,
                            len;

                        for (i = 0, len = words.length; i < len; i++) {
                            if (words[i] !== '') { 
                                n = n.replace(new RegExp('(' + words[i] + ')', 'gi'), '<b>' + '$1' + '</b>');
                            }
                        }
                    }
                } catch (e) {} 

                return n;
            },

            updateSuggestion: function updateSuggestion(items) {
                var len = items && items.length,
                    canBrowseItems = this.browseItemVisible;

                if (len || canBrowseItems) {
                    if (canBrowseItems) {
                        items = items || [];
                        items.push({
                            n: 'Browse...',
                            t: -99,
                            cssClass: ((len) ? 'br' : 'bro')
                        });
                    }

                    
                    this.set('suggestionItems', items);

                    
                    if (this.suggestionShown) {
                        
                        var popup = this._lastOpened;
                        if (popup && popup.nudge) {
                            popup.nudge();
                        }

                    } else {
                        this.openPopup('suggestionPopup', this.getSuggestionPos());
                        this.suggestionShown = true;
                    }

                } else {
                    this.hideSuggestion();

                }
            },

            ob: {
                scriptClass: "mstrmojo.Editor",
                title: mstrmojo.desc(5298, "Select an Object"),
                help: "Select_Objects_dialog_box_.htm",
                onClose: function () {
                    var o = this.opener;
                    if (o && o.onBrowserClose) {
                        o.onBrowserClose();
                    }
                },
                onOpen: function () {
                    var o = this.opener;
                    if (o && o.onBrowserOpen) {
                        o.onBrowserOpen();
                    }
                },
                children: [{
                    scriptClass : "mstrmojo.ObjectBrowser",
                    alias: "browser",
                    cssText: "width:200px;",
                    fishEyeVisible: false,
                    closeable: false,
                    closeOnSelect: false
                }]
            },

            onBrowserClose: function onBrowserClose() {
                this.browserShown = false;
            },

            handleSuggestionItemSelect: function handleSuggestionItemSelect(it) {
                
                if (this.browseItemVisible && it.t === -99) {
                    
                    this.hideSuggestion();

                    
                    mstrmojo.requiresCls("mstrmojo.ObjectBrowser");

                    
                    var zIndex = this.zIndex;
                    this.openPopup('ob', {
                        zIndex: (zIndex && (zIndex + 10)) || 110
                    });

                    
                    this.ob.browser.browse({
                        folderLinksContextId : this.folderLinksContextId,
                        onSelectCB: [this, 'onSuggestionItemSelect'],
                        browsableTypes: this.browsableTypes
                    });

                    this.browserShown = true;

                } else {
                    this.onSuggestionItemSelect(it);
                }
            },

            
            highlightPattern: true,

            suggestionPopup: {
                scriptClass: 'mstrmojo.Editor',
                cssClass: 'mstrmojo-ObjectInputBox-suggest',
                showTitle: false,
                modal: false,
                autoClose: true,
                nextHighlight: function () {
                    stepSelect.call(this, true);
                },

                preHighlight: function () {
                    stepSelect.call(this, false);
                },

                getSelected: function getSelected() {
                    var list = this.list;
                    return list.items[list.selectedIndex];
                },

                onOpen: function onOpen() {
                    var o = this.opener;
                    if (o && o.autoSelect) {
                        this.list.singleSelect(0);
                    }
                },

                onClose: function onClose() {
                    this.list.clearSelect();
                    if (this.opener) {
                        this.opener.suggestionShown = false;
                    }
                }
            },

            
            suggestionListClass: 'mstrmojo.SuggestionList',

            postApplyProperties: function postApplyProperties() {
                this.suggestionPopup.children = [{
                    scriptClass: this.suggestionListClass,
                    alias: 'list',
                    cssClass: 'mstrmojo-suggest-list'
                }];
            }
        })
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocXtabGraph",
                         "mstrmojo.TouchScroller",
                         "mstrmojo.graph._MobileGraphAreaHelper",
                         "mstrmojo._TouchGestures");

    var $DOM = mstrmojo.dom;

    
    function updateTooltip(graph, x, y) {
        var dpos = mstrmojo.dom.position(graph.domNode, false),
            left = 0,
            top = 0,
            node = graph.node;

        if (dpos) {
            left = dpos.x;
            top = dpos.y;
        }

        graph.model.getDataService().handleUserSingleTap(node.data.sid, node.k, x - left, y - top, false, {
            success: function (res) {
                graph.displayTooltips(res.Areas, left, top);
            }
        });

    }

    

    
    function getGbKey(model) {
        var gbkey = '',
            gba = [],
            currKey,
            layouts,
            currlayout,
            l,
            index,
            gb;

        if (!model) {
            return gbkey;
        }

        currKey = model.currlaykey;
        gbkey = currKey + '_';
        layouts = model.data && model.data.layouts;
        for (index = 0; index < (layouts.length || 0); index++) {
            l = layouts[index];
            if (l.k === currKey) {
                currlayout = l;
                break;
            }
        }

        if (currlayout) {
            if (currlayout.gbys) {
                gba = currlayout.gbys.groupbys;
                for (index = 0; index < (gba.length || 0); index++) {
                    gb = gba[index];
                    gbkey = gbkey + gb.k + ':' + gb.lvl;
                    if (gb.unit) {
                        gbkey = gbkey + ':' + gb.unit.idx;
                    }
                    gbkey = gbkey + '_';
                }
            }
        }
        return gbkey;
    }

    function applySelectionChange(touch) {
        
        this.displayTooltips([], 0, 0);

        var me = this,
            dataService = this.model.getDataService(),
            pos = mstrmojo.dom.position(this.domNode, true),
            x = touch.pageX - pos.x,
            y = touch.pageY - pos.y,
            anchor = {                                            
                    getBoundingClientRect: function () {
                     var left = touch.pageX,
                         top = touch.pageY;

                     return {
                         left: left,
                         top: top,
                         right: left + 1,
                         bottom: top + 1
                     };
                    }
                 },
            callback = {
                success: function (res) {
                    var areas = res.Areas,
                        defn = me.defn,
                        k = me.k,
                        tks = res.tks;
                    
                    if (areas && areas.length > 0) {
                        if (areas[0].Selectable === 1) {
                            
                            me.highlightArea(me.selectionNode, areas);

                        } else if(areas[0].Selectable === -1) { 
                            
                            me.highlightedAreas = [];
                            
                            
                            me.clearHighlightArea(me.selectionNode);
                        }
                        
                        if(tks) {
                        	me.showInfoWin(tks, anchor);
                        }
                    } else {
                        
                        me.highlightedAreas = [];
                        
                        
                        me.clearHighlightArea(me.selectionNode);
                    }
                    
                    window.setTimeout(function () { 
                        mstrMobileApp.forceRepaint();

                        
                        me.model.slice({
                        	type: parseInt(defn.t, 10) || mstrmojo.EnumRWUnitType.GRAPH,
                        	src: k,
                        	ck: defn.ck,
                        	gk: k,
                        	sid: me.node.data.sid,
                        	x: x, 
                        	y: y,  
                        	tks:tks,
                        	anchor: anchor
                        });
                    
                    }, 0);
                }
            };

        dataService.handleUserSingleTap(me.node.data.sid, me.k, x, y, true, callback);

    }

    
    function setImageNodeSrc(src) {
        var imgNode = this.imgNode;

        
        if (imgNode.src !== src) {
            
            imgNode.src = src;

            
            $DOM.translate(imgNode, 0, 0, 0);
        }
    }

    
    mstrmojo.MobileDocXtabGraph = mstrmojo.declare(
        mstrmojo.DocXtabGraph,

        [ mstrmojo._TouchGestures, mstrmojo.graph._MobileGraphAreaHelper ],

        
        {
            scriptClass: "mstrmojo.MobileDocXtabGraph",

            
            areaMarkup: '<area shape="{@shape}" coords="{@coords}" ttl="{@tooltip}" aid="{@aid}" {@extra}/>',

            retrieveGraphSrc: function retrieveGraphSrc(h, w) {
                var  id = this.id,
                    model = this.model;
                

                
                if (parseInt(h, 10) > 0 && parseInt(w, 10) > 0) {
                    model.getDataService().getRWGraphImage({
                        w: w,
                        h: h,
                        k: this.k,
                        sid: this.node.data.sid,
                        gbk: getGbKey(model)
                    }, model.newCallback({
                        success: function (res) {
                            
                            setImageNodeSrc.call(mstrmojo.all[id], res);
                        }
                    }));
                }
            },

            invalidate: function invalidate() {
                
                setImageNodeSrc.call(this, '');
            },

            
            showTooltip: function showTooltip() {
                
                
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                
                this.restoreDefaultTouches(false);

                
                updateTooltip(this, touch.pageX, touch.pageY);
            },

            touchSelectMove: function touchSelectMove(touch) {
                
                this.restoreDefaultTouches(false);

                
                updateTooltip(this, touch.pageX, touch.pageY);
            },

            touchTap: function touchTap(touch) {
                
                this.restoreDefaultTouches(false);

                applySelectionChange.call(this, touch);
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.MobileGraph", 
                         "mstrmojo.graph._CanvasGraph");
    
    
    mstrmojo.graph.MobileXtabCanvasGraph = mstrmojo.declare(
        mstrmojo.MobileGraph,
        
        [ mstrmojo.graph._CanvasGraph ],
        
        
        {
            scriptClass: "mstrmojo.graph.MobileXtabCanvasGraph"
        }
    );
    
}());



        
(function() {
    mstrmojo.requiresCls("mstrmojo.TableLayoutList",
                         "mstrmojo._IsTableLayoutListDIC",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.css");

    
    mstrmojo.android.inputControls.RadioListDIC = mstrmojo.declare(
        
        mstrmojo.TableLayoutList,
        
        [ mstrmojo._IsTableLayoutListDIC, mstrmojo._IsInputControl ],
        
        {
            scriptClass: 'mstrmojo.android.inputControls.RadioListDIC',

            styleCssClass: 'radio',

            init: function (props) {
                this._super(props);
                this.items = this.getItems();
                this.itemsPerRow = this.dic.ipr || 0;
            },

            ontouchend: function (evt) {
                this.onclick(evt);
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                mstrmojo.css.addClass(this.itemsNode || d, 'tx-active');
            }
        }
    );
}());
(function(){
    mstrmojo.requiresCls("mstrmojo._IsInputControl",
                         "mstrmojo.TableLayoutList",
                         "mstrmojo._IsTableLayoutListDIC",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $D = mstrmojo.dom,
        $C = mstrmojo.css,
        STYLES_LIST = {
            0: 'default',
            1: 'stars_dots'
        };

    mstrmojo.RatingDIC = mstrmojo.declare(
        
        mstrmojo.TableLayoutList,
        
        [mstrmojo._IsTableLayoutListDIC, mstrmojo._IsInputControl],
        
        {
            scriptClass: 'mstrmojo.RatingDIC',

            styleCssClass: 'rate',

            markupString: '<div id="{@id}" class="mstrmojo-ListBase {@cssClass}" style="{@cssText}" mstrAttach:click,mouseover,mouseout>' +
                              '<div class="{@icnCss}" style="{@icnCssText}">{@itemsHtml}</div>' +
                          '</div>',

            lastIdx: null,

            init: function (props) {
                this._super(props);
                this.items = this.getItems();
                this.starCount = this.items && this.items.length;
                $C.addWidgetCssClass(this, STYLES_LIST[this.dic.stl || 0]);
            },

            setRating: function (idx) {
                var i = 0,
                    starCount = this.starCount,
                    leCss = 'less_equal';
                if (this.lastIdx == undefined || this.lastIdx != idx){
                    for (; i < starCount; i++) {
                        if (i <= idx) {
                            $C.addClass(this._getItemNode(i), leCss);
                        } else {
                            $C.removeClass(this._getItemNode(i), leCss);
                        }
                    }
                    this.lastIdx = idx;
                }
            },

            onvalueChange: function() {
                this._super && this._super();
                var idx = mstrmojo.array.find(this.items, 'v', this.value);
                this.setRating(idx);
            },

            onmouseover: function(evt) {
                this._super && this._super(evt);
                var target = evt.target || $D.eventTarget(evt.hWin, evt.e),
                    idx = target && target.getAttribute('idx');
                if (idx != undefined) {
                    this.setRating(idx);
                }
            },

            onmouseout: function(evt) {
                this._super && this._super(evt);
                var idx = mstrmojo.array.find(this.items, 'v', this.value);
                this.setRating(idx);
            },

            postBuildRendering: function() {
                this._super();

                if (!mstrmojo.isDescendant(this.owner, this) && this.showByDefault) {
                    this.set('height', (this.openerStyle.ih || 0) + 'px');
                    this.set('width', (this.openerStyle.iw || 0) + 'px')
                }

                var idx = mstrmojo.array.find(this.items, 'v', this.value);
                if (idx > -1) {
                    this.setRating(idx);
                }
            }
        }
   )
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.TableLayoutList",
        "mstrmojo._IsTableLayoutListDIC",
        "mstrmojo._IsInputControl");

    function getTitleItems(items) {
        var arr = [];
        mstrmojo.array.forEach(items, function (v) {
            arr.push(v.n);
        });
        return arr;
    }

    mstrmojo.LikertScaleDIC = mstrmojo.declare(
        
        mstrmojo.TableLayoutList,

        
        [mstrmojo._IsTableLayoutListDIC, mstrmojo._IsInputControl],

        
        {
            scriptClass: 'mstrmojo.LikertScaleDIC',

            styleCssClass: 'scale',

            init: function (props) {
                this._super(props);
                this.items = this.getItems();
                this.titleItems = getTitleItems(this.items);
            },

            getDisplayValue: function getDisplayValue() {
                return (this.selectedIndex >= 0) ? this.items[this.selectedIndex].n : this.dv;
            },

            getLeftEndTitle: function getLeftEndTitle(idx) {
                return idx >= 0  ? (this.dic.mint || '') : '';
            },

            getRightEndTitle: function (idx) {
                return idx >= 0 ? (this.dic.maxt || '') : '';
            },

            postBuildRendering: function() {
                this._super();
                if (!mstrmojo.isDescendant(this.owner, this) && this.showByDefault) {
                    this.set('height', (this.openerStyle.ih || 0) + 'px');
                    this.set('width', (this.openerStyle.iw || 0) + 'px')
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.SelectBoxList",
                         "mstrmojo.array");

    
    mstrmojo.android.controllers._HasSelectBoxDialog = mstrmojo.provide(

        "mstrmojo.android.controllers._HasSelectBoxDialog",

        
        {
            _mixinName: 'mstrmojo.android.controllers._HasSelectBoxDialog',

            showSelectBoxDialog: function showSelectBoxDialog(items, fnSelect, dialogConfig) {

                
                var dialogChild = dialogConfig.children = [{
                    scriptClass: 'mstrmojo.android.ui.SelectBoxList',
                    isElastic: true,
                    items: items,
                    selectListChange: function (idx, item) {
                        
                        if (!fnSelect.call(this, idx, item)) {
                            
                            mstrApp.closeDialog();
                        }
                    }
                }][0];

                
                if (items.length === 1) {
                    var item = items[0];
                    items = item.items;

                    
                    dialogConfig.title = item.n;

                    
                    dialogChild.scriptClass = 'mstrmojo.ui.MobileCheckList';
                    dialogChild.items = items;
                    dialogChild.multiSelect = false;
                    dialogChild.selectedIndex = mstrmojo.array.find(items, 'on', true);

                    
                    dialogChild.postselectionChange = function (evt) {
                        this.selectListChange(0, items[evt.added[0]]);
                    };
                }

                
                mstrApp.showDialog(dialogConfig);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.ViewSwitcher",
                         "mstrmojo.android.ui.TxDocList",
                         "mstrmojo.android.large.ui.TxEditDoc",
                         "mstrmojo.OfflineTransactionModel",
                         "mstrmojo.hash",
                         "mstrmojo.css");

    mstrmojo.requiresDescs(9249, 9753);

    var $HASH = mstrmojo.hash,
        $CSS = mstrmojo.css;

    var EnumTxType = mstrmojo.OfflineTransactionModel,
        PENDING = EnumTxType.PENDING,
        FAILED = EnumTxType.FAILED;

    var defaultTitle = mstrmojo.desc(9753, 'Transactions');

    
    function editDoc(item) {
        
        var editDocView = this._editDocView;
        if (!editDocView) {
            
            editDocView = this._editDocView = mstrApp.viewFactory.newView('TransactionsEditDoc', {
                model: this.model
            });
        } else {
            
            editDocView.set('docID', null);
        }

        
        this.switchView(editDocView);

        
        this.disposables.push(editDocView);

        
        editDocView.set('docID', item.v);

        
        var title = item.n;

        
        if (this.controller.isAllTransactionLevel()) {
            
            title = '<em>' + defaultTitle + '</em>' + title;
        }

        
        this.setTitle(title);
    }
    
    
    function showDocList() {
        
        this.enableButtons(false);

        var model = this.model,
            txs = (model && model.docsTx) || {},
            items = [],
            id = this.id;

        
        if ($HASH.isEmpty(txs)) {
            
            showEmptyList.call(this);
            return ;
        }
            
        
        $HASH.forEach(txs, function (v, k) {
            var pe = v[PENDING] || [],
                fe = v[FAILED] || [];

            
            items.push({
                n: v.name,
                v: k,
                c: pe.length + fe.length,
                desc: v.p.pn
            });
        });

        
        this.dirty = false;

        var docList = this._docList;
        if (!docList) {
            docList = this._docList = new mstrmojo.android.ui.TxDocList({
                cssClass: 'docList',
                items: items,
                postselectionChange: function (evt) {
                    var added = evt.added;
                    if (added) {
                        editDoc.call(mstrmojo.all[id], this.items[added[0]]);
                    }
                }
            });

            
            this.disposables.push(docList);

        } else {
            docList.set('items', items);
        }

        
        this.switchView(docList);

        
        this.setTitle(defaultTitle);

        
        var editDocView = this._editDocView;
        if (editDocView) {
            
            editDocView.set('docID', null);
        }
    }

        
    function showEmptyList() {
        
        var lbl = this._docList = new mstrmojo.Label({
            cssClass: 'txtEmpty',
            text: mstrmojo.desc(9249, 'No pending or failed transactions')
        });

        
        this.disposables.push(lbl);

        
        this.switchView(lbl);
        
        
        this.enableButtons(false);
    }
    
    
    mstrmojo.android.ui.TransactionView = mstrmojo.declare(
        mstrmojo.android.ui.ViewSwitcher,

        null,

        
        {
            scriptClass: 'mstrmojo.android.ui.TransactionView',

            
            context: null,

            
            model: null,

            
            controller: null,

            
            dirty: true,

            init: function init(props) {
                this._super(props);

                
                $CSS.addWidgetCssClass(this, 'mstrmojo-TxView');

            },

            onRender: function onRender() {
                
                var fnStart = function () {
                    
                    var model = this.model,
                        txs = (model && model.docsTx) || {},
                        context = this.context; 
                    
                    
                    if ($HASH.isEmpty(txs)) {
                        showEmptyList.call(this);
                        return ;
                    }
                    
                    if (context) {
                        
                        editDoc.call(this, {
                            v: context.id,
                            n: context.n
                        });
                    } else {
                        
                        showDocList.call(this);
                    }
                };

                
                if (!this._txListener) {
                    var txListener = this._txListener = this.model.attachEventListener('recordChanged', this.id, function () {
                        
                        this.dirty = true;

                        
                        fnStart.call(this);
                    });

                    
                    this.disposables.push(txListener);
                }

                
                fnStart.call(this);
            },

            
            deleteRecord: function deleteRecord() {
                var editDocView = this._editDocView,
                    isPending = (editDocView.getType() === 0),
                    tx = editDocView.getSelectedTx(),
                    id = this.id;

                
                this.controller.deleteTransactionRecord(editDocView.docID, isPending, tx.v, {
                    success: function (r) {
                        
                        var view = mstrmojo.all[id];
                        view.dirty = true;

                        
                        editDocView.generateTypeList();

                        
                        editDocView.setType((isPending || !r.length) ? 0 : 1);
                    }
                });

            },

            
            editRecord: function editRecord() {
                var editDocView = this._editDocView,
                    tx = editDocView.getSelectedTx();

                
                this.controller.editTransactionRecord(editDocView.docID, (editDocView.getType() === 0), tx.v);
            },

            
            enableButtons: mstrmojo.emptyFn,

            
            setTitle: mstrmojo.emptyFn,

            
            goBack: function goBack() {
                
                if (!this.controller.isAllTransactionLevel()) {
                    
                    return false;
                }

                
                var currentView = this.getCurrentView();
                if (!currentView || currentView === this._docList) {
                    
                    return false;
                }

                
                showDocList.call(this);

                
                return true;
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.TransactionView");

    
    mstrmojo.android.large.ui.TransactionView = mstrmojo.declare(
        mstrmojo.android.ui.TransactionView,

        null,

        
        {
            scriptClass: 'mstrmojo.android.large.ui.TransactionView',

            enableButtons: function enableButtons(enabled) {
                this.parent.set('btnVisible', enabled);
            },
            
            setTitle: function setTitle(title) {
                this.parent.set('title', title);
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.array",
                         "mstrmojo.hash",
                         "mstrmojo.desc",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.android.controllers._HasSelectBoxDialog");


    mstrmojo.requiresDescs(221, 1442, 5136, 2941);

    var $HASH = mstrmojo.hash,
        $ARR = mstrmojo.array,
        $DESC = mstrmojo.desc,
        $BTN = mstrmojo.android.ui.Button.newButton;

    
    function displayPageByDialog(title, isDoc) {
        var pageByData = $HASH.clone(this.pageByData),       
            pageElements = pageByData.es,
            dialogCfg = {
                title: title,
                dialogRefresh: function () {
                    
                    this.refresh();
                }
            },
            ctrl = this,
            pageCnt = 0,
            depth,
            pageBys,
            selections,
            selectedIndices,
            fnClearPageBy,
            fnPageHeader,
            fnGetPages,
            fnIterateSelections,
            fnSubmit;

        
        fnClearPageBy = function (node) {
            
            var idx = selectedIndices.shift(),
                item = node.ph.h[idx];

            
            delete item.cet;

            
            if (item.ph) {
                
                fnClearPageBy(item);
            }
        };

        
        fnPageHeader = function (node) {
            
            var page = node.ph;

            
            if (!page) {
                
                return;
            }

            var items = [],
                selectedPageHeader;

            
            $ARR.forEach(page.h, function (v, idx) {
                var ix = v.ix,
                    cet = v.cet || 0;

                var el = pageElements[ix];
                items[idx] = {
                    n: el.en,
                    v: ix,          
                    on: cet
                };

                
                if (cet) {
                    
                    selections[depth] = items[idx];

                    
                    selectedIndices[depth] = idx;

                    
                    selectedPageHeader = v.ph;
                }
            });

            
            var selected = selections[depth];

            
            pageBys.push({
                n: page.n,
                items: items,
                v: selected.n
            });

            
            depth++;

            
            fnPageHeader($HASH.copy(selected, {
                ph: selectedPageHeader
            }));
        };

        
        fnGetPages = function () {
            
            depth = 0;
            pageBys = [];
            selections = [];
            selectedIndices = [];

            
            fnPageHeader(pageByData);

            
            pageCnt = pageBys.length;
        };

        
        fnIterateSelections = function (fnModifier) {
            var pageHeader = pageByData.ph;
            $ARR.forEach(selections, function (v) {
                
                var headers = pageHeader.h,
                    index = $ARR.find(headers, 'ix', v.v),
                    selectedHeader;

                if (index < 0) {
                    index = (isDoc && headers.length > 1)  ? 1 : 0;
                }

                selectedHeader = headers[index];

                
                fnModifier(selectedHeader, pageHeader);

                
                pageHeader = selectedHeader.ph;
            });
        };

        
        fnSubmit = function () {
            
            var pageByKeys = [];

            
            fnIterateSelections(function (selectedHeader, pageHeader) {
                
                pageByKeys.push({
                    id: pageHeader.id || 'm',               
                    tp: pageHeader.tp,
                    v: pageElements[selectedHeader.ix].ei
                });
            });

            
            ctrl.pageByData = pageByData;

            
            ctrl.onPageBy(pageByKeys);
        };

        
        fnGetPages();

        
        if (pageCnt > 1) {
            
            dialogCfg.buttons = [ $BTN($DESC(221, 'Cancel')), $BTN($DESC(1442, 'OK'), function () {
                fnSubmit();
            }) ];
        }

        
        this.showSelectBoxDialog(pageBys, function (idx, item) {
            
            fnClearPageBy(pageByData);

            
            selections[idx] = item;

            
            fnIterateSelections(function (selectedHeader) {
                
                selectedHeader.cet = 1;
            });

            
            fnGetPages();

            
            if (pageCnt > 1) {
                
                this.set('items', pageBys);

            } else {
                
                fnSubmit();

            }

            
            return (pageCnt > 1);

        }, dialogCfg);

    }

    
    mstrmojo.android.controllers._HasPageBy = mstrmojo.provide(

        'mstrmojo.android.controllers._HasPageBy',

        

        $HASH.copy(mstrmojo.android.controllers._HasSelectBoxDialog, {

            _mixinName: 'mstrmojo.android.controllers._HasPageBy',

            
            showGroupByDialog: function showGroupByDialog() {
                displayPageByDialog.call(this, mstrmojo.desc(2941, 'Grouping'), true);
            },

            
            showPageByDialog: function showPageByDialog() {
                displayPageByDialog.call(this, mstrmojo.desc(5136, 'Page By'), false);
            }
        })
    );

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.LikertScaleDIC",
                         "mstrmojo.css");

    
    mstrmojo.android.inputControls.LikertScaleDIC = mstrmojo.declare(
        
        mstrmojo.LikertScaleDIC,
        
        null,
        
        {
            scriptClass: 'mstrmojo.android.inputControls.LikertScaleDIC',

            lowestLabel: null,

            hightestLabel: null,

            

            markupString: '<div id="{@id}" class="mstrmojo-ListBase {@cssClass}" style="{@cssText}" mstrAttach:click>' +
                              '<div class="{@icnCss}" style="{@icnCssText}">' +
                                    '{@itemsHtml}' +
                                    '<div class="label {@lowestClass}">{@lowestLabel}</div>' +
                                    '<div class="label {@hightestClass}">{@hightestLabel}</div>' +
                              '</div>' +
                          '</div>',

            init: function init(props) {
                this._super(props);

                var len = this.titleItems && this.titleItems.length,
                    showMint = this.dic.mint && len,
                    showMaxt = this.dic.maxt && len;
                this.lowestLabel = showMint ? (this.titleItems[0] + ': ' + this.dic.mint) : '';
                this.lowestClass = showMint ? '' : 'hidden';
                this.hightestLabel = showMaxt ? (this.titleItems[len - 1] + ': ' + this.dic.maxt) : '';
                this.hightestClass = showMaxt ? '' : 'hidden';
            },

            
            getLeftEndTitle: function (idx) { return ''; },

            
            getRightEndTitle: function (idx) { return ''; },
            
            ontouchend: function (evt) {
                this.onclick(evt);
            },

            setDirtyFlag: function (c, d) {
                mstrmojo.css.addClass(this.itemsNode || d, 'tx-active');
            }
        }
    )
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.RatingDIC",
                         "mstrmojo._TouchGestures");

    var $D = mstrmojo.dom;

    
    mstrmojo.android.inputControls.RatingDIC = mstrmojo.declare(
        
        mstrmojo.RatingDIC,
        
        [ mstrmojo._TouchGestures ],

        
        {
            scriptClass: 'mstrmojo.android.inputControls.RatingDIC',

            touchTap: function touchTap(touch) {
                
                touch.e = touch.e || touch.evt;
                this.onclick(touch);
            },

            touchSwipeMove: function touchSwipeMove(touch) {
                var target = document.elementFromPoint(touch.pageX, touch.pageY),
                    idx;
                if ( $D.contains(this.domNode, target) ) {
                    idx = target && target.getAttribute('idx');
                    if ( idx != undefined ) {
                        this.setRating(idx);
                        this.ratingSelectedValue = this.items[idx].v;
                    }
                }
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                    if (this.ratingSelectedValue != undefined && this.ratingSelectedValue != this.value) {
                        this.set('value', this.ratingSelectedValue);
                    }
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                mstrmojo.css.addClass(this.itemsNode || d, 'tx-active');
            }
        }

    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.MobileDocXtabGraph",
                         "mstrmojo.graph._CanvasGraph");

    
    mstrmojo.graph.MobileDocXtabCanvasGraph = mstrmojo.declare(
        mstrmojo.MobileDocXtabGraph,

        [ mstrmojo.graph._CanvasGraph ],

        
        {

            scriptClass: "mstrmojo.graph.MobileDocXtabCanvasGraph",
            update: function update(node) {
                delete this.graphData;

                this._super(node);
            },

            setModel: function setModel(model) {
                
                this.graphData = model.data;
            },

            retrieveGraphSrc: function retrieveGraphSrc(h, w) {
                if (!this.graphData) {
                    var id = this.id,
                        parentMethod = this._super,
                        md = this.model;

                    if (parseInt(h, 10) > 0 && parseInt(w, 10) > 0) {

                        this.model.getDataService().getRWGraphImage({
                            w: w,
                            h: h,
                            k: this.k,
                            sid: this.node.data.sid
                        }, md.newCallback({
                            success: function (res) {
                                var graph = mstrmojo.all[id];

                                if(!graph) { 
                                	return;
                                }
                                
                                graph.setModel({
                                    data: res
                                });

                                
                                parentMethod.call(graph, h, w);
                                
                                var parent = graph.parent;  
                                if(parent && parent.updateScroller) {
                                	parent.updateScroller();
                                }
                                
                            }
                        }));
                    }
                } else {
                    this._super(h, w);
                }
            }
        }
    );

}());




(function () {
    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._IsList",
                         "mstrmojo._HasSuggestion",
                         "mstrmojo.Enum_Keys",
                         "mstrmojo.hash",
                         "mstrmojo.dom");

    var $DOM = mstrmojo.dom,
        $KEYS = mstrmojo.Enum_Keys,
        KEY_DELAY = 200,
        markup;

    var STATES = {
        DEFAULT: 1,
        ADDING: 2,
        EMPTY: 3,
        FULL: 4
    };

    var deleteCssCls = 'mstrmojo-SimpleObjectInputBox-del';

    
    function testInputText() {
        var inputBox = this.inputBox,
            text = inputBox.value;

        
        if (text !== this._lastPattern) {
            
            this.showSuggestion(text);
        }

        
        this._lastPattern = text;

        
        delete this._timerHandle;
    }

    
    function clearInputTextTimer() {
        
        var timerHandle = this._timerHandle;
        if (timerHandle) {
            
            window.clearTimeout(timerHandle);

            
            delete this._timerHandle;
        }
    }

    
    function setDefaultState() {
    	var mx = this.maxObjectCount,
			itsLen = (this.items && this.items.length) || 0,
			isFull = (mx != null && itsLen >= mx);
	
        this.set('state', !itsLen ? STATES.EMPTY : (isFull? STATES.FULL : STATES.DEFAULT) );
    }

    
    mstrmojo.SimpleObjectInputBox = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._IsList, mstrmojo._HasSuggestion ],

        
        {
            scriptClass: 'mstrmojo.SimpleObjectInputBox',

            markupString: '<div id="{@id}" class="mstrmojo-ListBase mstrmojo-SimpleObjectInputBox {@cssClass}" style="{@cssText}" mstrAttach:click>' +
                              '<div class="mstrmojo-SimpleObjectInputBox-container {@icnCss}" style="{@icnCssText}">{@itemsHtml}' +
                                  '<input type="text" mstrAttach:keydown,keyup,blur style="display: none;" />' +
                              '</div>' +
                              '<div class="mstrmojo-SimpleObjectInputBox-empty"><div>{@emptyText}</div></div>' +
                           '</div>',

            markupSlots: {
                itemsContainerNode: function () { return this.domNode.firstChild; },
                scrollboxNode: function () { return this.domNode; },
                emptyTextNode: function () { return this.domNode.childNodes[1]; },
                inputBox: function () { return this.domNode.firstChild.lastChild; }
            },

            markupMethods: {
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod,
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod,
                onmaxItemWidthChange: function onmaxItemWidthChange() {
                    
                    var w = this.maxItemWidth;
                    if (!isNaN(w)) {
                        
                        w += 'px';
                    }

                    
                    this.emptyTextNode.style.maxWidth = w;
                }
            },

            
            itemField: 'n',

            
            emptyText: '',

            state: 0,

            
            maxItemWidth: 'none',

            
            useKeyDelay: false,

            
            maxObjectCount: null,
            
            getItemMarkup: function (item) {
                
                if (!markup) {
                    var itemField = this.itemField;
                    markup = this._super(item).replace('>{@n}<', ' title="{@' + itemField + '}"><div class="elem">{@' + itemField + '}<div class="' + deleteCssCls + '"></div></div><');
                }

                
                return markup;
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx),
                    itemField = this.itemField;

                
                props[itemField] = item[itemField];

                
                var maxWidth = this.maxItemWidth;
                if (!isNaN(maxWidth)) {
                    maxWidth = (maxWidth - 24) + 'px';
                }
                
                props.addStyle('max-width:' + maxWidth);

                return props;
            },

            getSuggestionPos: function getSuggestionPos() {
                var inputPosition = this._inputPos;

                return {
                    target: this.inputBox,
                    left: inputPosition.x,
                    top: inputPosition.y + inputPosition.h,
                    zIndex: 100
                };
            },

            getSearchPattern: function getSearchPattern() {
                return this.inputBox.value;
            },

            onSuggestionItemSelect: function onSuggestionItemSelect(item) {
                
                clearInputTextTimer.call(this);

                
                this.set('items', this.items.concat(item));

                this._super();

                
                var id = this.id;
                window.setTimeout(function () {
                	var obj = mstrmojo.all[id];
                	if (obj.state != STATES.FULL) {
                		obj.set('state', STATES.ADDING);
                	}
                }, 0);
            },

            onstateChange: function onstateChange(evt) {
                var state = evt.value;

                
                this.emptyTextNode.style.display = (state === STATES.EMPTY) ? 'block' : 'none';

                var inputBox = this.inputBox,
                    inputStyle = inputBox.style,
                    itemsContainer = this.itemsContainerNode;

                
                if (state === STATES.ADDING) {

                    
                    inputStyle.display = '';

                    
                    inputBox.focus();

                    
                    this._inputPos = $DOM.position(inputBox, true);

                } else {
                    
                    clearInputTextTimer.call(this);

                    
                    inputStyle.display = 'none';
                    inputBox.value = '';

                    
                    this._lastPattern = '';
                }
            },

            postBuildRendering: function postBuildRendering() {
                
                setDefaultState.call(this);
                return this._super();
            },

            preitemsChange: function preitemsChange() {
                
                setDefaultState.call(this);
            },

            onclick: function onclick(evt) {
                
                var target = $DOM.eventTarget(evt.hWin, evt.e);
                if (target && target.className === deleteCssCls) {
                    var item = $DOM.findAncestorByAttr(target, 'idx', true, this.domNode),
                        idx = item && parseInt(item.value, 10);

                    
                    if (idx !== null && !isNaN(idx)) {
                        
                        var items = this.items.concat();

                        
                        items.splice(idx, 1);

                        
                        this.set('items', items);
                    }

                    
                    return;
                }

                if (this.state != STATES.FULL) {
                	
                	this.set('state', STATES.ADDING);
                }
            },

            onblur: function onblur() {
                
                clearInputTextTimer.call(this);

                if (!this.suggestionShown) {
                    
                    setDefaultState.call(this);
                }
            },

            prekeydown: function prekeydown(evt) {
                
                var e = evt.e;
                switch (parseInt(e.keyCode || e.charCode, 10)) {
                case $KEYS.DOWN_ARROW:
                    this.nextHighlight();
                    break;

                case $KEYS.UP_ARROW:
                    this.preHighlight();
                    break;

                case $KEYS.TAB:
                case $KEYS.ENTER:
                    
                    $DOM.preventDefault(evt.hWin, e);

                    
                    var item = this.getSelected();
                    if (item) {
                        
                        this.handleSuggestionItemSelect(item);

                    } else {
                        
                        this.hideSuggestion();

                        setDefaultState.call(this);

                    }
                    break;

                case $KEYS.ESCAPE:
                    
                    clearInputTextTimer.call(this);

                    
                    this.hideSuggestion();

                    setDefaultState.call(this);
                    break;
                    
                case $KEYS.BACKSPACE:
                	
                	if (!this.getSearchPattern()) {
                		
                		$DOM.preventDefault(evt.hWin, e);

                		var items = this.items && this.items.concat();
                		if (items && items.length) {
                			
                			items.splice(items.length - 1, 1);
                			
                			
                			this.set('items', items);
                			
                			
                			var id = this.id;
                			window.setTimeout(function () {
                           		mstrmojo.all[id].set('state', STATES.ADDING);
                            }, 0);
                		}
                	}
                    
                    break;

                }
            },

            prekeyup: function prekeyup() {
                
                if (this.useKeyDelay) {
                    var id = this.id;

                    
                    if (!this._timerHandle) {
                        
                        this._timerHandle = window.setTimeout(function () {
                            testInputText.call(mstrmojo.all[id]);
                        }, KEY_DELAY);
                    }
                } else {
                    
                    testInputText.call(this);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.XtabBase",
                         "mstrmojo.XtabZone",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasXtabTouchScroll",
                         "mstrmojo._XtabSelections",
                         "mstrmojo.dom",
                         "mstrmojo.hash",
                         "mstrmojo.css",
                         "mstrmojo._HasMagnifier",
                         "mstrmojo.XtabMagnifierHelper");

    var $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom;

    
    var LOCK_OFF = 0;
    var LOCK_ROW = 1;
    var LOCK_COL = 2;
    var LOCK_BOTH = 3;











    
    function flagUnit(cellNode, isDirty) {
        $CSS.toggleClass(cellNode.firstChild, 'tx-active', isDirty);
    }

    
    function bringMagnifierToFront(magnifier) {
        if (magnifier) {
            magnifier.domNode.style.pointerEvents = 'auto';
        }
    }

    
    function checkLinks() {
        
        
        if (mstrMobileApp.isOnline()) {
            return;
        }

        
        var controller = this.controller,
            z,
            zone,
            nodes,
            node,
            cell,
            action,
            i,
            lnk,
            linkRequests = [],
            linkNodes = [],
            req;

        
        if ( ! controller.getLinkRequest) {
        	return;
        }
        for (z in this.zones) {
            if (z === '_BL' || z === '_BR') {
                zone = this.zones[z];
                nodes = zone.getNodesByPositions(zone.posMap);
                for (i = 0; i < nodes.length; i++) {
                    node = nodes[i];
                    cell = this.getCellForNode(node);
                    if (cell && cell.at && (cell.at & 4)) {
                        action = this.model.getAction(this.getActionCells(cell), null);

                        
                        if (action) {
                            lnk = action.a;
                            req = controller.getLinkRequest(lnk);
                            if (req) {
                                linkRequests.push(req);
                                linkNodes.push(node);
                            }
                        }
                    }
                }
            }
        }

        
        var count = linkRequests.length;
        if (count) {
            
            var fnSuccess = function (res) {
                var i,
                    node;
                for (i = 0; i < count; i++) {
                    node = linkNodes[i];
                    if (!res[i]) {
                    	node.setAttribute("hl_d", true);
                    	$CSS.addClass(node, "hl_d");
                    }
                }
            };

            if (mstrApp.isHosted()) {
                

            } else {
                this.model.getDataService().checkCachedLinkTargets(linkRequests, {
                    success: fnSuccess,
                    failure: mstrmojo.emptyFn
                });
            }
        }
    }

    
    function onConnectivityChange() {
        if (mstrMobileApp.isOnline()) {
            var z, zone,
                nodes,
                node,
                i;
            for (z in this.zones) {
                if (z === '_BL' || z === '_BR') {
                    zone = this.zones[z];
                    nodes = zone.getNodesByPositions(zone.posMap);
                    for (i = 0; i < nodes.length; i++) {
                        node = nodes[i];
                    	node.removeAttribute("hl_d");
                    	$CSS.removeClass(node, "hl_d");
                    }
                }
            }
        } else {
            checkLinks.call(this);
        }
    }

    
    mstrmojo.MobileXtab = mstrmojo.declare(
        
        mstrmojo.XtabBase,

        [ mstrmojo._TouchGestures, mstrmojo._HasXtabTouchScroll, mstrmojo._XtabSelections, mstrmojo._HasMagnifier ],

        
        {
            scriptClass: "mstrmojo.MobileXtab",

            
            frameRate: 30,

            
            enableMagnifier: true,

            useSeamlessIncFetch: false,
            
            
            allowToggleSelections: true,

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? 'block' : 'none'; },
                onheightChange: function () { this.domNode.style.height = this.height || ''; },
                onwidthChange: function () { this.domNode.style.width = this.width || ''; }
            },

            init: function init(props) {
                this._super(props);
                this.magnifierHelper = new mstrmojo.XtabMagnifierHelper({xtab: this});
                this.disposables.push(this.magnifierHelper);
            },

            gridPagesRendered: function gridPagesRendered() {
                this._super();
                
                checkLinks.call(this);
            },


            onRender: function onRender() {
                this._super();
                
                var interactiveCells = this.interactiveCellsArray;
                if (interactiveCells && interactiveCells.length > 0 && this.controller.getLinkRequest) {
                    
                    if (!this.subscr) {
                        var publisher = mstrmojo.publisher;
                        this.subscr = publisher.subscribe(publisher.NO_SRC, publisher.CONNECTIVITY_CHANGED_EVENT, onConnectivityChange, this.id);
                    }

                    
                    if ((mstrApp.useBinaryFormat || mstrApp.isHosted()) && !mstrMobileApp.isOnline()) {
                        var me = this;
                        window.setTimeout(function () {
                        	try{
                        	    checkLinks.call(me);
                        	} catch (ex) {
                                
                        	}
                        }, 100);
                    }
                }
            },

            unrender: function unrender() {
                if (this.subscr) {
                    mstrmojo.publisher.unsubscribe(this.subscr);
                    delete this.subscr;
                }
                
                this._super();
            },

            getDataService: function getDataService(options) {
                return this.model.getDataService();
            },

            setData: function setData(data) {
                this.set('gridData', data);
            },

            createZone: function createZone(cfg) {
                cfg = cfg || {};
                var ds = this.getDataService();
                cfg.imgCacheMap = (ds && ds.imgCache) || this.imgCacheMap;
                cfg.unCachedMap = {};

                return new mstrmojo.XtabZone(cfg);
            },

            showDownloadStatus: function showDownloadStatus() {
            },

            onclick: mstrmojo.emptyFn,

            
            setupTNs: function setupTNs() {

                
                var node = this.contentNode,
                    scrollBox = node.rows[1].cells[1].lastChild,
                    zIndex = 0;

                
                switch (this.lockHeadersCase) {
                case LOCK_OFF:
                    this._TSN.x = [ scrollBox.lastChild.lastChild ];
                    this._TSN.y = [ scrollBox.firstChild ];
                    break;

                case LOCK_COL:
                    this._TSN.x = [ node ];
                    this._TSN.y = [ scrollBox.firstChild ];
                    break;

                case LOCK_ROW:
                    this._TSN.x = [ scrollBox ];
                    this._TSN.y = [ node ];
                    zIndex = -1;
                    break;

                case LOCK_BOTH:
                    this._TSN.x = [
                        node.rows[0].cells[1].lastChild,    
                        scrollBox.firstChild                
                    ];
                    this._TSN.y = [ node.rows[1] ];
                    zIndex = 2;
                    break;
                }

                
                if (zIndex) {
                    this._TSN.x[0].style.zIndex = zIndex;
                }

                
                this.setOffsets();

                
                this.attachEventListener('scrolledOut', this.id, this.scrolledOut);
            },

            
            useDomToCalculateOffsets: function useDomToCalculateOffsets() {
                return (this.lockHeadersCase === LOCK_OFF || (this._super && this._super()));
            },

            setOffsets: function setOffsets() {
                var TW = 0,                                 
                    TH = 0;                                 

                
                var lockHeadersCase = this.lockHeadersCase;

                
                
                
                if (this.useDomToCalculateOffsets()) {
                    var touchNodes = this._TSN,
                        xScroll = touchNodes.x[0],
                        yScroll = touchNodes.y[0];

                    
                    TW = xScroll.offsetLeft + xScroll.offsetWidth + (!!(lockHeadersCase & LOCK_ROW) ? this._BL.offsetWidth : 0);
                    TH = yScroll.offsetTop + yScroll.offsetHeight + (!!(lockHeadersCase & LOCK_COL) ? this._TR.offsetHeight : 0);
                } else {
                    var zones = this.zones,
                        rh = (this.gridData.rh && parseInt(this.gridData.rh, 10)) || 0,           
                        cntTopRight = zones._TR ? zones._TR.cp.rc : 0,                 
                        cntBottomRight = zones._BR.cp.rc,              
                        widthBottomLeft = zones._BL ? zones._BL.totalColWidth : 0,     
                        widthBottomRight = zones._BR.totalColWidth;    

                    TH = ((lockHeadersCase === LOCK_ROW) ? cntBottomRight : cntTopRight + cntBottomRight) * rh;
                    TW = (lockHeadersCase === LOCK_COL) ? widthBottomRight :  widthBottomLeft + widthBottomRight;
                }

                
                var HEIGHT = 1,
                    WIDTH = 2,
                    scrollWidth = this.getGridDimension(WIDTH) || 0,
                    scrollHeight = this.getGridDimension(HEIGHT) || 0;

                
                
                this._TMAX = {
                    x: Math.min(scrollWidth - TW, 0),
                    y: Math.min(scrollHeight - TH, 0)
                };

                if (this._super) {
                    this._super();
                }
            },

            touchTap: function touchTap(touch) {
                
                if (!this.magnifier) {
                    if (this._super) {
                        this._super();
                    }

                    
                    if (this.performAction(touch) === false) {
                        
                        var ctrl = this.controller;
                        if (ctrl && ctrl.viewTap) {
                            
                            ctrl.viewTap();
                        }
                    }
                }
            },

            performAction: function performAction(touch) {
                
                this.deselectCell();

                
                var td = $DOM.findAncestorByAttr(touch.target, 'ei', true, this.domNode);

                
                if (!td || !td.value) {
                    
                    return false;
                }

                var node = td.node,
                    cell = this.getCellForNode(node),
                    actionType = cell.at;

                if (this._super && this._super(touch)) {
                    
                    return;
                }

                
                if (!actionType) {
                    
                    return false;
                }
                if ((actionType & 4) && ! node.getAttribute("hl_d")) {
                    var mask = document.createElement('div'),
                    	st = mask.style;
	                    id = this.id;
	
	                
	                mask.className = 'activeLink on';
	                st.left = node.offsetLeft + "px";
	                st.top = node.offsetTop + "px";
	                st.width = node.offsetWidth + "px";
	                st.height = node.offsetHeight + "px";
	                node.appendChild(mask);
	
	                
	                window.setTimeout(function () {
	                    
	                    var grid = mstrmojo.all[id];
	                    if (grid && grid.hasRendered) {
	                    	$DOM.attachOneTimeEvent(mask, 'webkitTransitionEnd', function () {
	                            
	                            node.removeChild(mask);
	                        });
	
	                        
	                    	$CSS.removeClass(mask, 'on');
	                    }
	                }, 200);
                }
                this.defaultAction(node);
            },


            
            selectCell: function selectCell(cell) {
                
                var highlight = document.createElement('div'),
                    highlightStyle = highlight.style;

                highlight.className = 'overlay';
                highlightStyle.top = cell.offsetTop + 'px';
                highlightStyle.left = (cell.offsetLeft + 1) + 'px';
                highlightStyle.height = (cell.clientHeight - 2) + 'px';
                highlightStyle.width = (cell.clientWidth - 1) + 'px';

                cell.appendChild(highlight);
            },

            flagDirtyUnit: function flagDirtyUnit(cellNode) {
                flagUnit(cellNode, true);
            },

            clearDirtyUnit: function clearDirtyUnit(cellNode) {
                flagUnit(cellNode, false);
            },

            
            deselectCell: function deselectCell() {
                
                var cell = this._selectedCell;
                if (cell) {
                    
                    cell.removeChild(cell.lastChild);

                    delete this._selectedCell;
                }
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                if (this.enableMagnifier) {
                	var controller = this.controller, magnifierConfig;
                	if (controller.getMagnifierConfig) {
                		magnifierConfig = controller.getMagnifierConfig();
                	}
                	
                    this.displayMagnifier(touch, magnifierConfig);
                }
            },

            touchSelectMove: function touchSelectMove(touch) {
                if (this.enableMagnifier) {
                    var me = this;
                    this.latestTouch = touch;
                    if (!this._moveMagnifierTimer) {
                        
                        
                        this._moveMagnifierTimer = setTimeout(function () {
                            me.displayMagnifier(me.latestTouch);
                            me._moveMagnifierTimer = null;
                        }, 50);
                    }
                }
            },

            touchSelectCancel: function touchSelectCancel(touch) {
                bringMagnifierToFront(this.magnifier);
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                bringMagnifierToFront(this.magnifier);
            },
            
            getCaptureDimensions: function getCaptureDimensions() {
            	var viewport = this.viewport,
            	    position = $DOM.position(this.domNode, true);
            	
            	position.w = Math.min(viewport.offsetWidth, position.w);
            	position.h = Math.min(viewport.offsetHeight, position.h)
            	
            	return position;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.css",
                         "mstrmojo.android.ui.CalendarMarkupBuilder",
                         "mstrmojo.ui.MobileCheckList",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.Dialog");

    var $CSS = mstrmojo.css,
        DIALOG_CSS = 'mstrmojo-CalDialog';

    
    mstrmojo.android.ui.CalendarDialog = mstrmojo.declare(

        
        mstrmojo.android.Dialog,

        
        null,

        
        {
            scriptClass: "mstrmojo.android.ui.CalendarDialog",

            
            markupBuilder: undefined,

            
            requiredOrientation: 0,

            
            init: function (props) {
                
                this._super(props);

                var calendar = this.calendar,
                    popDimensions = this.popDimensions = this.getPopupDimensions(),
                    requiredOr = this.requiredOrientation,
                    currentLockedOr = mstrMobileApp.getLockedOrientation();

                
                if (requiredOr !== 0 && requiredOr !== currentLockedOr) {
                    
                    mstrMobileApp.lockOrientation(requiredOr);

                    
                    this._prevOr = currentLockedOr;
                }

                
                calendar.markupBuilder = this.markupBuilder;

                
                calendar.width = popDimensions.w + 'px';
                calendar.height = popDimensions.h + 'px';
                calendar.layoutConfig = {
                    h: {
                        yearNode: '100px'
                    },
                    w: {
                        yearNode: '100%'
                    }
                };

                
                calendar.defaultCSS = this.cssClass;
                calendar.target = new mstrmojo.ui.MobileCheckList({
                    alias: 'contentList',
                    cssDisplay: ''
                });

                
                $CSS.addWidgetCssClass(this, [DIALOG_CSS]);
            },

            
            getPopupDimensions: function getPopupDimensions() {
                var screenDimensions = mstrApp.getScreenDimensions();

                return {
                    h: screenDimensions.h * 0.9,
                    w: Math.min(screenDimensions.w * 0.85, 720)
                };
            },

            
            getCancelBtnFn: function getCancelBtnFn() {
                var calList = this.calendar.target,
                    dialog = calList.parent,
                    items = calList.getSelectedItems(),
                    returnVal = true;

                
                if (items && items.length > 0) {
                    
                    calList.set('items', []);

                    
                    dialog.resizeDialog();

                    
                    returnVal = false;
                } else {
                    
                    dialog.close();
                }

                return returnVal;
            },

            
            close: function close() {
                
                this._super();

                var prevOrientation = this._prevOr;

                
                if (prevOrientation !== undefined) {
                    
                    if (prevOrientation === 0) {
                        
                        mstrMobileApp.releaseOrientation();
                    } else {
                        
                        mstrMobileApp.lockOrientation(prevOrientation);
                    }

                    
                    delete this._prevOr;
                }
            }
        }
    );

}());
(function(){
    mstrmojo.requiresCls("mstrmojo.android.Dialog", "mstrmojo.Button");
    
    mstrmojo.android.AndroidDICPopup = mstrmojo.declare(
            mstrmojo.android.Dialog,
            
            null,
            
            {
                scriptClass: 'mstrmojo.AndroidDICPopup',

                cssClass: 'mstrmojo-AndroidDICPopup',

                autoClose: false,
                
                fadeOnClose: false,
                
                init: function init(props) {
                    this._super(props);
                    
                    this.addChildren([this.widget]);
                },
                
                close: function close(){
                    
                    this.set('visible', false);
                    
                    
                    
                    if (this.widget.hasRendered){
                        this.widget.unrender();
                    }
                    
                    this.removeChildren(this.widget);
                    
                    this._super();
                },
                
                onpopupResized: function onpopupResized(e) {
                    if(this.widget.onpopupResized) {
                        this.widget.onpopupResized(e);
                    }
                },
                
                onkeyup: function onkeyup(evt) {
                    var hWin = evt.hWin,
                        e = evt.e || hWin.event;
                    
                    if(this.widget.applyOnEnter && e.keyCode === 13) {
                        
                        this.onApply();
                    } else if(e.keyCode === 27) {
                        this.onCancel();
                    }               
                },   
                              
                onApply: function() {
                    return this.widget.applyChanges();
                },
                
                onCancel: function() {
                    this.widget.cancelChanges();
                },
                
                enableApply: mstrmojo.emptyFn
            }
    );
}());
(function () {

	mstrmojo.requiresCls("mstrmojo.Vis", "mstrmojo._TouchGestures", "mstrmojo.TouchScroller", "mstrmojo._HasTouchScroller", "mstrmojo.css");

	var $CSS = mstrmojo.css;
	
	var FONT_SIZE = 15;
	
	function getTouchedElement(touch) {
        var item = mstrmojo.dom.findAncestorByAttr(touch.target, "clk", true, this.domNode);
		
        return item || null;
    }
    
    function setScrollerPosition() {
		var scl = this._scroller;
	        
	    var realWidth =  this.timeSelectorListContainer.width;
		
		var realOffSetWidth = this.timeSelectorList.offsetWidth;
		if(realOffSetWidth > realWidth) {
			this.scrollPast = true;
		}
		var offsetEnd = realOffSetWidth > realWidth? realOffSetWidth - realWidth : 0;
	    scl.origin = {
				x: 0,
				y: 0
		};

		scl.showScrollbars = true;
		scl.noHScroll = false;
		scl.hScroll = (offsetEnd !== 0 && scl.noHScroll !== true) || this.scrollPast;

		if (scl.hScroll) {
			
			scl.offset = {
				x: {
					start: 0,
					end: offsetEnd
				},
				scrollPast: this.scrollPast
			};
		}
		var icn = this.timeSelectorList;
		this.widget.utils.translateCSS(0,0,false,icn);
		
	}
    
     
    mstrmojo.VisTimeSeriesTimeSelector = mstrmojo.declare(

    
    mstrmojo.Vis,

    
    [mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

    {
        
        scriptClass: 'mstrmojo.VisTimeSeriesTimeSelector',

        
        scrollerConfig: {
            bounces: false,
            showScrollbars: true,
            useTranslate3d: true
        },

        
        scrollPast: false,
        
        isAndroidTab: false,
		
		offsetx: 0,
         
        widget:null,
        
        markupString: '<div id="{@id}-TimeSelector-Container" class="mstrmojo-timeseries-timeselector-div" style="position:absolute; left:{@offsetx}px; overflow:hidden;">' +
						'<div id="{@id}-TimeSelector-List" style="position:absolute;left:0;top:0"></div>' +
					'</div>' ,
			
        
        markupSlots: {
		
			timeSelectorListContainer: function(){return this.domNode;},
			
			timeSelectorList: function(){return this.domNode.firstChild;}
		
        },
        
        toggleSelected: function toggleSelected(el, selected){
        	if(!el){
        		return;
        	}
			var style = el.style;
			var ts = this.widget;
			var textClr = ts.utils.rgb2rgbStr(ts.formatProp.textClr);
			var bgClr = ts.utils.rgb2rgbStr(ts.formatProp.backgroundClr);
			if(selected){
				style.backgroundColor = textClr;
				style.color = bgClr;
			}else{
				style.backgroundColor = '';
				style.color = textClr;
			}
		},
		
        
        toggleGlowEffect: function toggleGlowEffect(el, glow){
        	if(!el){
        		return;
        	}
        	if(glow){
        		$CSS.applyShadow(el, 0, 0, 20, this.widget.glowColor );
        	}else{
        		$CSS.removeShadow(el);
        	}
        },
        
        drawTimeSelectorLabels: function drwtslbls() {
		    var tsl = this.widget.baseModel.vp.rl;
		    var chartStatus = this.chartStatus;
		    
		    if (tsl) {
		        var ts = this.widget,
		            mg = ts.margin,
		            utils = ts.utils,
		            width = ts.getWidth(),
		            totalWidth = 0;
		
		        
		        this.timeSelectorListContainer.width = width - mg.l - mg.r;
		        this.timeSelectorListContainer.style.width = (width - mg.l - mg.r) + 'px';
		        this.timeSelectorListContainer.style.height = mg.t + 'px';
		        
		        var d = tsl.length;
		
		        var x = (width - mg.l - mg.r) / (d + 1);
		
		        var id = ts.id,timeSelectorList = this.timeSelectorList;
		        
		        if(timeSelectorList.childNodes.length == 0){
		        	
		        	
		        	 ts.currSelection = null;
					for (var i = 0; i < d; i++) {
			            var lbl = document.createElement("div");
			            lbl.id = 'timeseries-intervals';
			            lbl.className = 'timeseries-intervals';
						
						lbl.style.fontWeight = "bold";
						lbl.style.fontFamily = "Arial";
						lbl.style.fontSize = FONT_SIZE + "px";
			            lbl.innerHTML = tsl[i].n;
			            lbl.setAttribute("clk", "S");
			            lbl.setAttribute("value", i);
			            lbl.style.position = 'relative';
			            lbl.style.whiteSpace = 'nowrap';
			            lbl.style.cssFloat = 'left';
			            
			            if (i === 0 && chartStatus.currSelectionIdx == -1 && !chartStatus.usingCustomInterval) {
			            	
			            	
			            	this.toggleSelected(lbl, true);			               
			                ts.currSelection = lbl;
			            } else if (!chartStatus.usingCustomInterval && chartStatus.currSelectionIdx == i) {
			            	
			            	
			            	this.toggleSelected(lbl, true);	
			                ts.currSelection = lbl;
			            }else{
			            	this.toggleSelected(lbl, false);	
			            }
			            
			            timeSelectorList.appendChild(lbl);
			
			            
			            offsetWidth = lbl.offsetWidth;
			            
			            totalWidth += offsetWidth;
			            
			            spaceWidth = offsetWidth < x? x - offsetWidth : 20;
			            
			            totalWidth += spaceWidth;
			            
			            if(i == 0){
							timeSelectorList.insertBefore(this.createWhiteSpace(spaceWidth) , timeSelectorList.firstChild);
							totalWidth += spaceWidth;
			            }
						timeSelectorList.appendChild(this.createWhiteSpace( spaceWidth ));
			        }
		        }else{
		        	
		        	var childNodes = timeSelectorList.childNodes;
		        	var childNodesLength = childNodes.length;
		        	for(var i = 0; i < childNodesLength; i ++){
		        		var lbl = childNodes[i];
		        		
			            offsetWidth = lbl.offsetWidth;
			            
			            totalWidth += offsetWidth;
						
						if (i == 0) {
							continue;
						}
			            
			            spaceWidth = offsetWidth < x? x - offsetWidth : 20;
			            
			            totalWidth += spaceWidth;
			            
			            if(i == 1){
			            	childNodes[0].style.paddingLeft = spaceWidth + 'px';
			            }
			            i++;
			            childNodes[i].style.paddingLeft = spaceWidth + 'px';
		        	}
		        }

		        
		        
		       this.timeSelectorList.style.width = totalWidth+'px';
		    }
	},

	postBuildRendering: function postBR() {
		
		FONT_SIZE = Math.round(15 * this.widget.utils.getScreenZoomFactor());
						
		this.scrollerConfig.scrollEl = this.timeSelectorList;
	
		if (this._super) {
			this._super();
		}

		this.drawTimeSelectorLabels();
	
	    setScrollerPosition.call(this);
	},
	
	
    reRender: function reRender() {   	
    	
    	this.drawTimeSelectorLabels();
    	
	    setScrollerPosition.call(this);
    },
	
	createWhiteSpace: function crtWhtSpc(w){
		var spaceDiv = document.createElement("div");
		spaceDiv.style.height = '30px';
		spaceDiv.style.position = 'relative';
		spaceDiv.style.whiteSpace = 'nowrap';
		spaceDiv.style.cssFloat = 'left';
		spaceDiv.style.paddingLeft = w + 'px';
		return spaceDiv;
	},

	initScroller: function initScroller(scroller) {
			scroller.hScroll = true;

			this._super(scroller);
	},
		
	touchBegin: function touchBegin(touch) {
		
		this.widget.hiddenTooltipAndShowTimeSelector();
	    
	},   
    
    touchSelectEnd: function touchEnd(touch) {	    
    	var currSelection = this.widget.currSelection;
    	if(currSelection){
    		this.toggleGlowEffect(currSelection, false);   
    	}
		
    },
    
    touchSelectBegin: function touchSelectBegin(touch) {
    	var item = getTouchedElement.call(this, touch);
		if (item) {
			var value = item.value;
			if (value === 'S'){
				this.widget.timeSelectorOnClick(item);
			}
		} 
    },
    
    touchTap: function touchTap(touch) {
    	var item = getTouchedElement.call(this, touch);
		if (item) {
			var value = item.value;
			if (value === 'S'){
				this.widget.timeSelectorOnClick(item);
			}
		} 
		this.toggleGlowEffect(this.widget.currSelection, false);   
    },
    
	destroy: function destroy() {
		if(this._super){
			 this._super();
		}
		
	}
    
    
    });

})();
(function(){

    mstrmojo.requiresCls('mstrmojo.url', 'mstrmojo.Vis', 'mstrmojo._CanSupportTransaction');
    
    mstrmojo.PhotoUploader = mstrmojo.declare(
            
            mstrmojo.Vis,
            
            [mstrmojo._CanSupportTransaction, mstrmojo._TouchGestures],
            
            {
                scriptClass: 'mstrmojo.PhotoUploader',
                
                photoNum: 0,
                
                markupString: '<div id="{@id}" class="mstrmojo-PhotoUploader" style="left:{@left};top:{@top};width:{@width};height:{@height}" mstrAttach:click>' +
                                  '<div class="actionButton" style="line-height:{@height}">{@n}</div>' +
                                  '<img class="preview"></img>' +
                                  '<div class="numberBadge">' +
                                      '<div class="badgeText"></div>' +
                                  '</div>' +
                              '</div>',
                
                markupSlots: {
                    buttonNode: function(){ return this.domNode.firstChild;},
                    previewNode: function(){ return this.domNode.childNodes[1];},
                    badgeNode: function() { return this.domNode.lastChild;},
                    badgeTextNode: function() {return this.domNode.lastChild.firstChild;}
                },
                
                markupMethods:{
                    onphotoNumChange: function(){
                        mstrmojo.css.toggleClass(this.domNode, 'empty', this.photoNum == 0);
                        if (this.photoNum > 0){
                            this.badgeTextNode.innerHTML = this.photoNum;
                        }
                    }
                },
               
                preBuildRendering: function(){
                    this._super();
                    
                    var dp = this.getDataParser(),
                        rowTitles = dp.getRowTitles(),
                        colTitles = dp.getColTitles(),
                        firstRow, t1, t2, t3, atid1, atid2;
                    
                    if (rowTitles.size() < 3 && colTitles.size() < 1){
                        
                        mstrmojo.alert("Incorrect grid template structure!");
                        return false;
                    } else if (dp.getTotalRows() < 10){
                        
                        mstrmojo.alert("At least 10 rows required!");
                        return false;
                    } 
                    
                    firstRow = dp.getRowHeaders(0);
                    t1 = rowTitles.getTitle(0); 
                    t2 = rowTitles.getTitle(1); 
                    atid1 = t1.getUnitId(); 
                    atid2 = t2.getUnitId();
                    t3 = colTitles.getTitle(0).getHeaderValues()[0]; 
                    
                    this.cellInfo = [{
                        atid: atid1,
                        form_id: t1.getFormId(),
                        ui: 0
                    }, {
                        atid: atid2,
                        form_id: t2.getFormId(),
                        ui: (atid1 == atid2) ? 0:1 
                    }, {
                        metric_id: t3.oid
                    }];

                    this.photoNum = 0; 
                    this.n = mstrmojo.desc(8470);
                },
                
                
                setModel: function(model){
                    this.model = this.txModel = model && model.docModel;
                },
                
                
                getKeyContext: function(k){
                    return { o: parseInt(k, 10) };
                },
                
                
                getUpdateObject: function(i){
                    var udvs = this.getUpdatedValues(),
                        CHANGE_DATA = 2, 
                        cells = [], ci = this.cellInfo;
                    
                    for (var i in udvs){
                        var udv = udvs[i],
                            photoPath = mstrmojo.string.encodeXMLAttribute(String(udv.v[0])),
                            photoDesc = mstrmojo.string.encodeXMLAttribute(String(udv.v[1])),
                            count = '1';
                        cells.push({
                            rowOrdinal: udv.o, 
                            attId: ci[0].atid,
                            formId: ci[0].form_id,
                            unitIndex: ci[0].ui,
                            newValue: photoPath
                        }, {
                            rowOrdinal: udv.o, 
                            attId: ci[1].atid,
                            formId: ci[1].form_id,
                            unitIndex: ci[1].ui,
                            newValue: photoDesc
                        }, {
                            rowOrdinal: udv.o, 
                            colOrdinal: 0,
                            newValue: count
                        });
                    }
                    
                    return {
                        manipulation: CHANGE_DATA,
                        nodeKey: this.k,
                        sliceId: this.sid,
                        cells: cells,
                        autoRefresh: false
                    };
                },
                
                
                getUpdates: function getUpdates(){
                    var eg = [], 
                        w = this, 
                        j, udt = false,
                        udvs = this.getUpdatedValues(), udv,
                        TX_ELEM_ATT_FORM = 1,
                        TX_ELEM_METRIC = 2,
                        DssXmlDataTypeVarChar = 9,
                        DssXmlDataTypeInteger = 1,
                        ci = this.cellInfo;
                    
                    eg.push('<gr rw_tree_type="' + this.defn.tt + '" rw_node_key="' + w.k + '" slice_id="' + (w.sid || 0) + '">');
                    
                    for(j in udvs) {
                        if(udvs.hasOwnProperty(j)) {
                            udv = udvs[j];
                            
                            for (var i = 0; i < 2; i++){
                                eg.push('<cli ax="1" attribute_id="' + ci[i].atid + '" form_id="' + ci[i].form_id + '">' + 
                                            '<updt types="' + TX_ELEM_ATT_FORM +'" ordinal="' + udv.o + '" value="' + udv.v[i] + '" dt="' + DssXmlDataTypeVarChar + '"/>' +
                                        '</cli>');
                            }
                            
                            eg.push('<cli cordinal="0" metric_id="' + ci[2].metric_id + '">' + 
                                        '<updt types="' + TX_ELEM_METRIC + '" rordinal="' + udv.o + '" value="1" dt="' + DssXmlDataTypeInteger + '"/>' +
                                    '</cli>');
                            
                            udt = true;
                        }
                    }
                    eg.push('</gr>');
                    if (!udt){
                        eg = [];
                    }
                    
                    return eg.join('');
                },
                
                
                photoUploaded: function(imagePath, description){
                    mstrMobileApp.setWaitScreenVisibility(false);
                    var url = mstrmojo.url.getAbsoluteURL(imagePath, mstrApp.getConfiguration().getCurrentProjectWebServerUrl()),
                        desc = description,
                        currentIdx = this.photoNum;
                    
                    this.previewNode.src = url;
                    
                    this.dataChanged(currentIdx, {}, {v: [url, desc]});

                    this.set('photoNum', currentIdx + 1);
                },
                
                touchTap: function(){
                    this.onclick();
                },
                
                onclick: function(){
                    if (this.photoNum == 10){
                        mstrmojo.alert("can upload at most 10 photos");
                    }else{
                        var params = {
                            serverUrl: mstrApp.getConfiguration().getTaskUrlByProject(mstrApp.getCurrentProjectId()),
                            sessionState: mstrApp.getSessionState(),
                            descs: {
                                'ADD_PHOTO' : mstrmojo.desc(8470),
                                'TAKE_NEW_PHOTO' : mstrmojo.desc(8471),
                                'CHOOSE_FROM_GALLERY' : mstrmojo.desc(8472),
                                'DONE' : mstrmojo.desc(8473),
                                'CANCEL' : mstrmojo.desc(221)
                            }
                        };
                        
                        
                        mstrMobileApp.uploadPhotos(JSON.stringify(params), 'mstrmojo.all["' + this.id + '"].photoUploaded');
                    }
                }
            }
    );

}());

  
  (function () {

    mstrmojo.requiresCls("mstrmojo.Vis",
                         "mstrmojo.hash",
                         "mstrmojo.GeoLocation",
                         "mstrmojo._TouchGestures");

    var GD_SEP = '\u001F',
    	GR_SEP = '\u001E',
    	GC_SEP = '\u001D',
    	GI_SEP = '\u001C',
    	GV_SEP = '\u001B';
    
    
    function togglePreviewCtrl(preview, opacity) {
    	if (!!preview && !!preview.imgNode) { 
            var imgNodeStyle = preview.imgNode.style;
            
            imgNodeStyle.opacity = opacity;
    	}
    }
    
    
    
    var PREVIEW_CLS_NAME = mstrmojo.Image.baseCssClass + '-prv';

    
    mstrmojo.maps.androidmap.AndroidMap = mstrmojo.declare(
        mstrmojo.Vis,

        null,

        {
            scriptClass: "mstrmojo.maps.androidmap.AndroidMap",

            cssClass : "mstr-googleMapView",

            markupString: '<div id="{@id}" class="mstrmojo-Box {@cssClass}" style="{@domNodeCssText}" mstrAttach:touchstart>' +
                          '</div>',

            reRenderOnDimensionChg: false,
            
            mapRendered: false,
            
            firstScreen: true,
            
            children: [{
                scriptClass: 'mstrmojo.Image',
                alias: 'imgPreview',
                cssClass: 'prv',
                cssText: 'position:absolute;left:0;top:0;',
                firstLoad:false,
                onload: function () {
                    
                    togglePreviewCtrl(this, 1);
                    var ths = this;
                    window.setTimeout(function() 
              		{
              			ths.parent.postImageProcessing(ths.firstLoad);
              			ths.firstLoad = false;
              		},300);
                }
            }],
            
           
           markupSlots : {
               containerNode : function() {return this.domNode;}
           },

            markupMethods: {
                onheightChange: function(){
                    this.domNode.style.height = this.getHeight() + 'px';
                },
                onwidthChange: function(){
                    this.domNode.style.width = this.getWidth() + 'px';
                }
            },

            setModel: function setModel(model) {
                this.set('model', model);
                this.xtabModel = model;
                if ( model.data ) {
                    this.set('gridData', model.data);
                }
            },
            
            postImageProcessing:function postImageProcessing(firstLoad) {
            	if (firstLoad && this.controller && this.controller.takeScreenShot) {
            		this.controller.takeScreenShot();
            	}
            	if (this.imgPreview.src != '' && mstrMobileApp && mstrMobileApp.hideMapView) {
                    window.setTimeout(function(){
                        mstrMobileApp.hideMapView(0);
                    }, 100);
                }
            },

            ongridDataChange: function() {
                this.parser = new mstrmojo.Vis.DataParser(this.gridData);
                
                delete this.dataMap;
            },

            update: function update(node) {
                node = node || this.node;
                if (node) { 
                	if (node.data) {
                	
                	    this.set('gridData', node.data);

                        var gd = this.gridData;
                		if (gd.layoutModel) this.layoutModel = gd.layoutModel;
                		if (gd.layoutNode) this.layoutNode = gd.layoutNode;
                		
                		delete gd.layoutModel;
                		delete gd.layoutNode;
                	}
                    var fmts = node.defn.fmts || node.defn.units[this.xtabModel.k].fmts;

                    this.width = parseInt(fmts.width, 10);
                    this.height = parseInt(fmts.height, 10);
                    this.top = parseInt(fmts.top,10);
                    this.left = parseInt(fmts.left,10);
                    this.fmts = fmts;
                }

                if (this.xtabModel) {
                	this.initFromVisProps(this.gridData.vp);
                }
                this.updated = true;
                
            },

            getMapModel: function() {
                var pid = mstrApp.getCurrentProjectId(),
                	sessions = mstrApp.serverProxy.getSessions();

                return {
                    pid: pid,
                    sessions: sessions,
                    mapId: this.id,
                    hasTarget: false,
                    hostUrl: mstrApp.getConfiguration().getHostUrlByProject(pid)
                };
            },
            
            getGridModel: function() {
            	var gridModel = mstrmojo.hash.copy(this.gridData, {}); 
            	
            	return gridModel;
            },

			initFromVisProps: function initFromVisProps(vp) {
                this.vp = vp;
            },
			
            dispatchMapData: function dispatchMapData() {
                var mapModel = this.getMapModel(),
                	gd = this.simplifyGridData();

                mstrMobileApp.loadMap(JSON.stringify(mstrmojo.hash.copy(mapModel, {
                	gdProp: gd.prop,
                    infoWindow: {dft: true}
                })), gd.es, gd.data, '');
                
                
                this.mapRendered = true;
            },
            
            
            simplifyGridData: function simplifyGridData() {
            	if(this.dataMap) {
            		return this.dataMap;
            	}
            	var gd = this.gridData,
            		ghs = [],
            		gvs = [],
            		gts = {row: [], col: []}, o, row, col, ges = [], res = [], ces = [],
            		rd = [], items = [], cv, 
            		ritems, citems, i, iLen, j, jLen;
            	
            	
            	if (typeof(gd.ghs) == 'undefined' || (gd.gts.row.length == 0)) {
            		gd.eg = 'no data returned';
            	}
            	
            	if(gd.eg) {
            		this.dataMap = {prop: {}, data: '', es: ''};
            	} else {
            		
                	for(i = 0, ritems = gd.ghs.rhs.items, iLen = ritems.length; i < iLen; i++) {
                		
                		for(j = 0, citems = ritems[i].items, jLen = citems.length; j < jLen; j++) {
                			rd.push(citems[j].idx);
                		}
                		
                		ghs.push(rd.join(GC_SEP));
                		
                		rd = [];
                	}

                	
                	for(i = 0, ritems = gd.gvs.items, iLen = ritems.length; i < iLen; i++) {
                		
                		for(j = 0, citems = ritems[i].items, jLen = citems.length; j < jLen; j++) {
                			
                			items.push(citems[j].v);
                			
                			items.push(citems[j].rv || 0);
                			
                			if(citems[j].ti !== undefined || citems[j].ts !== undefined) {
                				
                				v = '';
                				if(citems[j].ti !== undefined) {
                					
                					gd.th[citems[j].ti].ty = citems[j].ty;
                					v = citems[j].ti;
                				}
                				
                				v += GV_SEP;
                				if(citems[j].ts !== undefined) {
                					v += citems[j].ts;
                				}
                				items.push(v);
                			}
                			
                			rd.push(items.join(GI_SEP));
                			items = [];
                		}
                		
                		gvs.push(rd.join(GC_SEP));
                		rd = [];
                	}
                	
                	
                	
                	row = gd.gts.row;
                	mstrmojo.array.forEach(row, function(v){
                		o = {};
                		
                		mstrmojo.hash.copyProps(['n', 'id', 'fid', 'fs', 'sc'], v, o);
                		gts.row.push(o);
                		rd = [];
                		
                		mstrmojo.array.forEach(v.es, function(elem) {
                			rd.push(elem.n);
                		});
                		
                		res.push(rd.join(GI_SEP));
                	});
                	
                	ges.push(res.join(GR_SEP));
                	
                	
                	col = gd.gts.col;
                	mstrmojo.array.forEach(col, function(v) {
                		o = {};
                		mstrmojo.hash.copyProps(['n', 'id', 'fid'], v, o);
                		gts.col.push(o);
                		rd = [];
                		
                		mstrmojo.array.forEach(v.es, function(elem) {
                			rd.push(elem.n);
                		});
                		
                		ces.push(rd.join(GI_SEP));
                	});
                	
                	ges.push(ces.join(GR_SEP));
                	
                	
                	this.dataMap = {
                		prop: {
                			vp: gd.vp,
                			th: gd.th,
                			gts: gts
                		},
                		es: ges.join(GD_SEP),
                		data: ghs.join(GR_SEP) + GD_SEP + gvs.join(GR_SEP)
                	};
            	}
            	
            	return this.dataMap;
            },
            
            getModel: function getModel() {
                return this.gridData;
            },
            
            handleMarkerSelection: mstrmojo.emptyFn,
			
            postBuildRendering : function postBuildRendering(){
               
               this.dispatchMapData();
               
               this._super();
            },

            rebuildLayout: mstrmojo.emptyFn,

            resetLayout: mstrmojo.emptyFn,

            setDimensions: function setDimensions(h, w) {
                var map = this.googleMap,
                    center = map ? map.getCenter() : null,
                    dimensionChanged = this._super(h, w);

                if ( map ) {
                    this.map.style.height = this.getHeight() + "px";
                   	this.map.style.width = (this.getWidth() - 1) + "px";
                   	map.setCenter(center);
                }
               	
                return dimensionChanged;            	
            },
            
            unrender:function unrender() {
            	this.imgPreview.src = '';
            	if(this.mapRendered) {
                    this.removeMap();
                    this.mapRendered = false;
                }
            	this._super();
            },
            
            removeMap:function removeMap() {
            	mstrMobileApp.hideMapView("1");
            },
            switchToImage: function switchToImage(src,width,height) {
                
                var imgPreview = this.imgPreview;
                imgPreview.firstLoad = this.firstScreen;
                this.firstScreen = false;
                if (src && imgPreview.hasRendered) {
                    
                    if (imgPreview.src !== src) {
                        
                        togglePreviewCtrl(imgPreview, 0);
        
                        
                        imgPreview.domNode.className = PREVIEW_CLS_NAME;
        
                        
                        imgPreview.set('src', src);
                        
                        imgPreview.set('width',width);
                        imgPreview.set('heihgt',height);
                        
                        
                    } else if (mstrMobileApp && mstrMobileApp.hideMapView) {
                    	togglePreviewCtrl(this.imgPreview,1);
                    	
                    	this.postImageProcessing(false);
                    }
                } else {
                    mstrMobileApp.hideMapView(0);
                }
            },
            hidePreview:function hidePreview() {
            	togglePreviewCtrl(this.imgPreview,0);
            },
            showPreview:function showPreview() {
            	togglePreviewCtrl(this.imgPreview,1);
            },
            closeInfoWindow: function closeInfoWindow() {
                
                do{
                    mstrApp.closeDialog();
                } while(mstrmojo.all.mstrMapInfoWindow);
            },
            ontouchstart: function ontouchstart() {
                if(this.mapRendered) {
                    mstrMobileApp.showMapView(0);
                }
            },
            
            destroy: function destroy() {
                
                var p = this.parent;
                while(p) {
                    if(p._scroller && p.scrollMoveListener) {
                        
                    }
                    p = p.parent;
                }                
            	this._super();
            	if (this.mapRendered) {
            	    mstrMobileApp.navigateAway();
            	}
            }
        }
    );
})();

(function() {

	mstrmojo.requiresCls("mstrmojo.Vis",
						 "mstrmojo.VisChartUtils",
						 "mstrmojo.VisChartData",
						 "mstrmojo.boxmodel"
						 );

	function getTooltipName(ch, s) {
		var nm = "",
			l = ch.length;
		
		if(l !== s.hi.length) {
			
			return ch[0].items[s.hi[0]].n;
		}
		
		for(var i = 0; i < l; i++) {
			nm += (i > 0 ? " " : "") + ch[i].items[s.hi[i]].n;
		}

		return nm;
	}
		
	
	mstrmojo.VisChart = mstrmojo.declare(
			
			mstrmojo.Vis,

			
			null,
					
			{
				
				scriptClass: 'mstrmojo.VisChart',

				
				utils: mstrmojo.VisChartUtils,                        

				
				data: mstrmojo.VisChartData,                        

				
				model: null,

				
				prevYLabel: {x:0, y:0, h:0},

				
				prevXLabel: {x:0, y:0, w:0},

				
				context: null,

				
				themeColor: '#000000',

				
				highlightColor: '#ff8833',

				
				margin: {t:50, r:2, b:30, l:2},

				
				offsetLeft: null,

				
				xLabelPadding: 10,

				
				yLabelPadding: 10,

				
				isDrawAxis: true,

				
				drawXAxisLabels: true,

				
				drawYAxisLabels: true,

				
				isHighlightOnTouch: true,

				
				isLinearChart: true,

				
				showHighlightLine: true,

				browserSupportsHtml5: true,

				
				multiLine: true,

				
				drawGridLines: 3,

				
				drawHorizontalGridLines: 1,

				
				drawVerticalGridLines: 2,

				
				switchSeriesOnTouch: true,

				
				seriesIndex: -1,

				
				displayMode: 0,
				
				
				markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};top:{@top};left:{@left};position:relative;" ' +
				' mstrAttach:mousedown,mouseup,mousemove,click ' +                             
				'><canvas width="{@width}" height="{@height}"></canvas>' + 
				'<canvas style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>' + 
				'<canvas style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>' +
				'<div id="{@id}-tooltip" class="mstrmojo-Chart-tooltip"></div>' + 
				'</div>',

				
				markupSlots: {
					
					canvas: function(){ return this.domNode.firstChild; },

					
					animationCanvas: function(){ return this.domNode.childNodes[1]; },

					
					highlightCanvas: function(){ return this.domNode.childNodes[2]; },

					
					tooltip: function(){ return this.domNode.childNodes[3]; }
				},

				
				postBuildRendering: function postBR() {
					if (this._super) {
						this._super();
					}
					this.browserSupportsHtml5 = this.canvas.getContext; 
	                if (!this.browserSupportsHtml5) {
	                	this.renderErrorMessage(mstrmojo.desc(8126,'Your browser does not support HTML5')); 
	                	return;
	                }
	                if (!this.model) {
	                	this.renderErrorMessage(mstrmojo.desc(8426,'No model provided'));
	                	return; 
	                }
	                
	                if(this.model.err || this.model.eg) {
						this.renderErrorMessage(this.model.err  || this.model.eg);
						return;
					}
	                
	                
	                if(this.isLinearChart) {
	                	this.data.processLinearData(this);
	                } else {
	                	this.data.process(this);
	                }
	                
	                
	                this.windowSize = this.model.series[0].rv.length;						

					
	                this.context = this.canvas.getContext('2d');
					this.highlightContext = this.highlightCanvas.getContext('2d');
					this.animationContext = this.animationCanvas.getContext('2d');
										
					
					this.utils.fillBackground(this);

					if(this.windowSize <= 1) {
						return; 
					}
					
					this.plot();
				},
				
				
				getMaxValue: function getMaxV(){
					var vals = this.model.mvalues;					
					return vals && vals[vals.length - 1];
				},
				
				
				getMinValue: function getMinV(){
					var vals = this.model.mvalues;
					
					return vals && vals[0];
				},

				
				plot: function plt() {

					
					this.drawChart();

					
					
					if(this.model.err  || this.model.eg) {
						return;
					}

					
					if(this.isDrawAxis) {
						
						if(this.isTimeSeries || !(this.isAnimateLines && (!this.multiLine || this.model.series.length === 1 ))) {
							this.drawLabels();
						}
						else{
							this.drawAxis();
						}
					}
				},

				
				drawChart: function drwchrt() {},

				
				drawAxis: function drwAxs() {
					var utils = this.utils,
						margin = this.margin,
						width = this.getWidth(),
						height = this.canvas.height,
						context = this.context;

					context.save();

					
					context.strokeStyle =  utils.getColor(this);
					context.lineWidth = 2;
					context.globalAlpha = 0.3;

					
					utils.drawRectangle(this, margin.l, margin.t, width - margin.l - margin.r, height - margin.t - margin.b);

					context.restore();
				},

				
				drawLabels: function drwlbls() {
					if (!this.isDrawAxis || !this.drawYAxisLabels) return;
					var model = this.model,
					utils = this.utils,
					margin = this.margin,
					v = model.mvalues,
					ylbls = model.ylbls,
					l = v.length,
					dgl = this.drawGridLines;

					this.prevYLabel.x = 0;
					this.prevYLabel.y = 0;
					this.prevYLabel.h =0;
					
					for(var i = 0; i < l; i++) {
						var y = utils.getYValue(this, v[i]);
						var lbl = utils.addDataLabel(this, ylbls[i], y, this.prevYLabel);
						
						var yPos = Math.floor(y) + 0.5;
						if(lbl && (dgl & this.drawHorizontalGridLines) && i > 0 && i < l-1 ) {
							utils.drawHighlightLine(this, yPos);
						}
						if(i == l-1 && this.isTimeSeries && lbl && (dgl & this.drawHorizontalGridLines)){
							utils.drawHighlightLine(this, yPos);
						}
					}
				},

				renderTooltip: function rndrttp(valIndex, touchX, touchY) {
					if (valIndex < 0) {
						this.tooltip.style.display = 'none';
						return;
					}

					var m = this.model, 
						s = m.series,
						utils = this.utils,
						l = s.length,
						si = this.seriesIndex,
						ch = m.colHeaders,
						ttp = this.tooltip;

					
					var sn = ''; 

					
					if(!this.multiLine) {
						sn = getTooltipName(ch,s[0]) + ': ' + s[0].v[valIndex];
					} else {
						
						
						if(this.showHighlightLine) {
							for(var i = 0; i < l; i++) {
								sn += (i === 0 ? '' : '<br/>') + getTooltipName(ch,s[i]) + ': ' + s[i].v[valIndex];
							}
						} else {
							
							sn = getTooltipName(ch,s[si]) + ': ' + s[si].v[valIndex];
						}

					}

					
					var rVal = this.model.categories.items[valIndex];

					
					ttp.innerHTML = rVal + '<br/>' + sn;

					
					ttp.style.display = 'block';

					

					
					var tooltipWidth = ttp.offsetWidth;

					var toolx = touchX - tooltipWidth /2;
					var margin = this.margin;

					if (toolx < margin.l) {
						toolx = margin.l;
					} else if (toolx > this.getWidth() - margin.r - tooltipWidth) {
						toolx = this.getWidth() - margin.r - tooltipWidth;
					}

					
					if(this.showHighlightLine) {
						utils.translateCSS(toolx, 0, false, ttp);
					} else {
						
						
						var yPos = utils.getYValue(this, s[si].rv[valIndex]) - ttp.offsetHeight - 20;
						if(yPos < 0 ) {
							yPos = utils.getYValue(this, s[si].rv[valIndex]);
						}
						utils.translateCSS(toolx, yPos, false, ttp);
					}

				},

				
				getTouchValue: function gtvlindx(x,y) {
					var md = this.model,
						m = this.margin;

					var sz = md.rne - md.rns > 0 ? md.rne - md.rns > 1 ? md.rne - md.rns : 2 : this.windowSize;
					var touchVal = Math.round(((x - m.l) * (sz - 1))/(this.getWidth() - m.l - m.r - 1));
					return (touchVal < sz) ? touchVal: null;
				},

				
				highlightPoint: function hghlghtpnt(x, touchY) {

				},

				
				handleTouchBegin: function handleTouchBegin(touchX, touchY) {
					if(!this.isHighlightOnTouch || !this.browserSupportsHtml5) {
						return;
					}
					this.tooltipOn = true;
					this.adjustWidgetOffsets();
					this.handleTouchMove(touchX, touchY);
				},

				
				handleTouchMove: function handleTouchMove(touchX, touchY) {
					var me = this,
						m = me.model;
						
					if (!me.tooltipOn || !me.isHighlightOnTouch || !this.browserSupportsHtml5 || this.windowSize <= 1) {
						return;
					}

		             var touchPointOnWidget = me.utils.getTouchXYOnWidget(touchX, touchY, me);	
					touchX = touchPointOnWidget.touchX;
					touchY = touchPointOnWidget.touchY;     

					var margin = me.margin;

					
					if(touchX < margin.l || touchY < margin.t || touchY > me.canvas.height - margin.b) {
						return;
					}

					
					var touchVal = me.getTouchValue(touchX,touchY);

					
					if (touchVal !== null) {

					

						
						var rns = (m.rne - m.rns > 1) ? m.rns : m.rns - 1;

						
						if(me.seriesIndex === -1 || me.switchSeriesOnTouch) {
							me.seriesIndex = me.utils.getSeriesIndexAndYValue(me, rns + touchVal, touchY).si;
						}

						
						if(m.series[me.seriesIndex].rv[rns + touchVal] === "") {
							return;
						}
						
						
						me.prevHighlight = me.currentHighlight;
						
						
						me.currentHighlight = touchVal;
						
						
						me.renderTooltip(touchVal, touchX, touchY);
						
						
						if(this.isTimeSeries){
							me.highlightPoint(touchVal, touchX, touchY);
						}else{
							me.highlightPoint(touchVal, touchY);	
						}
						
					}
				},

				
				handleTouchEnd: function handleTouchEnd() {
			        if (!this.browserSupportsHtml5) {
			        	return;
			        }
					var me = this;
					
					if(me.model.err || this.model.eg) {
						return;
					}
					me.tooltipOn = false;

					me.seriesIndex = -1;
					me.currentHighlight = null;
					
					
					
					me.highlightCanvas.height = me.highlightCanvas.height;

					
					me.tooltip.style.display = 'none';
				},
				
				
				onmousedown: function(evt) {
					if(!this.isAndroid) {
						this.handleTouchBegin(evt.e.pageX, evt.e.pageY);
					}
				},

				
				onmouseup: function(evt) {
					if(!this.isAndroid) {
						this.handleTouchEnd();
					}
				},

				
				onmousemove: function(evt) {
					if (!this.isAndroid) {
						this.handleTouchMove(evt.e.pageX, evt.e.pageY);
					}
				}				
			}
	);

})();
(function () {

	mstrmojo.requiresCls( "mstrmojo.Vis", "mstrmojo._TouchGestures", "mstrmojo.TouchScroller", "mstrmojo._HasTouchScroller");

	var legendFontFamily = "Helvetica",
		legendFontStyle = "bold 14px Helvetica",
		legendFontStyleHighlight = "bold 20px Helvetica",
		legendSwitcherBarHeight = 30,
		zf = 1;

	function resetSizeByDPI(zoomfactor){
		zf = zoomfactor;
		legendFontStyle = "bold "+ Math.round(14*zf)+"px Helvetica";
		legendFontStyleHighlight = "bold "+Math.round(20*zf)+"px Helvetica";
		legendSwitcherBarHeight = Math.round(30*zf)
	}

	function getTouchedElement(touch) {
        var item = mstrmojo.dom.findAncestorByAttr(touch.target, "clk", true, this.domNode);
        return item || null;
    }

    function setScrollerPosition() {
		var scl = this._scroller;

		var realHeight = this.height - this.legendBarSwitcher.height - 15*zf;

		var realOffSetHeight = this.legendListDiv.offsetHeight;
		if(realOffSetHeight > realHeight) {
			this.scrollPast = true;
		}
		var offsetEnd = realOffSetHeight > realHeight? realOffSetHeight - realHeight : 0;
		scl.origin = {
				x: 0,
				y: 0
		};

		scl.showScrollbars = true;
		scl.noVScroll = false;
		scl.vScroll = (offsetEnd !== 0 && scl.noVScroll !== true) || this.scrollPast;

		if (scl.vScroll) {

			scl.offset = {
					y: {
				start: 0,
				end: offsetEnd
			},
			scrollPast: this.scrollPast
			};
		}
		var icn = this.legendListDiv;
		this.utils.translateCSS(0,0,false,icn);
	}

     
    mstrmojo.VisTimeSeriesLegend = mstrmojo.declare(

    
    mstrmojo.Vis,

    
    [mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

    {
        
        scriptClass: 'mstrmojo.VisTimeSeriesLegend',

        
        scrollerConfig: {
            bounces: false,
            showScrollbars: true,
            useTranslate3d: true
        },

         
        multiTouch: true,

        
        scrollPast: false,
        
        isAndroidTab: false,

		  
		legendBarWidth : 30,

		  
		isLegendBarOpen : false,

	      
         isLegendSelected:false,
	        	 
         legendSelectedIndex:-1,

         maxLegendAttrLength:0,
         
         widget:null,
        
         y_axis_interval: 25,
        
        markupString: '<div id="{@id}-legend-bar" style="position:absolute;top:{@top};right:{@right};z-index:{@zIndex};" >' +
							'<div id="{@id}-legend-switcher" class="mstrmojo-timeseries-legend-switcher" clk="S">'+
								'<canvas id="{@id}-legend-triangle" width="15px" height="17px" style="position:absolute;" ></canvas>' +
								'<div id="{@id}-legend-shadow" class="timeseries-legend-switcher-shadow" style="height:0px; width:0px;position:absolute"></div>' +
							'</div>' +
							'<div class="mstrmojo-timeseries-legend-List-Div" style="overflow:hidden;">' +
								'<div id="{@id}-legend-List" ></div>' +
							'</div>' +
							'<canvas style="z-index:-1;" clk="C"></canvas>' +
						'</div>' ,

        
        markupSlots: {
		
		legendBarDiv: function(){return this.domNode;},

		
		legendBarSwitcher: function(){return this.domNode.firstChild;},

		triangle: function(){return this.domNode.firstChild.firstChild;},

		
		legendListDivContainer: function(){return this.domNode.childNodes[1];},
		
		legendListDiv: function(){return this.domNode.childNodes[1].firstChild;},

		
		legendCanvas: function(){return this.domNode.childNodes[2];}
        },

		switchLegendBar : function switchLegendBar(){
		    this.isLegendBarOpen = !this.isLegendBarOpen;

		    this.calculateAndSetLegendWidth();

		    this.widget.reDrawSlaveChartImpl();

		    this.renderLegend(true);

		     setScrollerPosition.call(this);
		},

		enableLegendGlowEffect: function enableLegendGlowEffect(index,clr){
			 var selectedLegend = this.legendListDiv.childNodes[index];
			 var color = clr || selectedLegend.style.color;
			 selectedLegend.style.textShadow = color + '0px 0px 8px';
			 selectedLegend.style.font = legendFontStyleHighlight;
		},

		hiddenLegendGlowEffect: function hiddenLegendGlowEffect(index){
			var selectedLegend = this.legendListDiv.childNodes[index];
			selectedLegend.style.textShadow = 'none';
			selectedLegend.style.font = legendFontStyle;
		},

		toggleTriangle: function toggleTriangle(open){
			var canvas = this.triangle,
				tStyle = canvas.style,
				cntx = canvas.getContext('2d'),
				ts = this.widget;

			var triH = Math.round(17*zf),
				triW = Math.round(15*zf);
			
			canvas.height = triH;
			canvas.width = triW;

			tStyle.top = Math.round(7*zf) + 'px';
			tStyle.left = Math.round(8*zf) + 'px';

			cntx.save();
			cntx.fillStyle =  ts.utils.rgb2rgbStr(ts.formatProp.textClr, 0.75);

			cntx.beginPath();
			if(open){
				cntx.moveTo(0,0);
				cntx.lineTo(triW, triH/2);
				cntx.lineTo(0, triH);
				cntx.lineTo(0,0);
			}else{
				cntx.moveTo(0,triH/2);
				cntx.lineTo(triW, 0);
				cntx.lineTo(triW, triH);
				cntx.lineTo(0,triH/2);
			}

			cntx.closePath();
			cntx.fill();
			cntx.restore();
		},

		renderLegend: function renderLegend(hasGlowEffect) {
			var model = this.model,
				s = model.series,
				sl = s && s.length || 0,
				h = this.height,
				utils = this.utils,
				ch = model.colHeaders,
				lc = this.legendCanvas.getContext('2d'),
				legendListDiv = this.legendListDiv,
				legendBarSwitcher = this.legendBarSwitcher;


			this.legendBarDiv.style.width = this.legendBarWidth + 'px';
			this.legendBarDiv.style.height = h + 'px';
			legendListDiv.style.width = this.legendBarWidth+ 'px';

			legendBarSwitcher.width = this.legendBarWidth;
			legendBarSwitcher.height = legendSwitcherBarHeight;
			legendBarSwitcher.style.width = this.legendBarWidth + 'px';

			this.legendCanvas.width = this.legendBarWidth;
			this.legendCanvas.height = h;

			if(this.isLegendSelected && this.legendSelectedIndex >= sl){
			
				 this.legendSelectedIndex = 0;
				 this.widget.setLegendSelected(this.isLegendSelected,this.legendSelectedIndex);
			 }

			if(legendListDiv.childNodes.length == 0){
				
				for(var i = 0; i < sl; i++){
					var legendAttr = document.createElement("div");
					legendAttr.id = 'legendAttr'+i;

					legendAttr.style.font = legendFontStyle;
					legendAttr.className = 'timeseries-legendAttr';
					legendAttr.innerHTML = this.widget.getLegendName(ch,s,i);
					legendAttr.setAttribute("clk", "LA");
					legendAttr.setAttribute("vIndex",i);
					legendAttr.style.color = this.widget.getSerieColor(i) ;

					legendListDiv.appendChild(legendAttr);
					utils.changeElementSize(legendAttr,'height', utils.getScreenZoomFactor());
				}
				this.y_axis_interval = Math.max(legendAttr.offsetHeight, 25);

			}


			if(this.isLegendBarOpen){
				this.toggleTriangle(true);
				legendListDiv.style.display = 'block';

				
				this.legendListDivContainer.style.height = (h - legendBarSwitcher.height - 15*zf) + "px";
				this.legendListDivContainer.style.weight = this.legendBarWidth +"px";
				this._scroller.updateScrollBars();
				this.utils.translateCSS(0,legendBarSwitcher.height,false,this.legendListDivContainer);

				if(this.isLegendSelected){
					this.enableLegendGlowEffect(this.legendSelectedIndex);
				}
				 
				this.legendCanvas.height = h ;
				this.legendCanvas.style.position = "absolute";
				this.legendCanvas.style.top = "0px";
				this.legendCanvas.style.left = "0px";

				this.drawLegendOutline(h, legendBarSwitcher.height, lc);
			 }
			 else{
				this.toggleTriangle(false);

				legendListDiv.style.display = 'none';

				
				this.legendCanvas.height = h ;
				this.legendCanvas.style.position = "absolute";
				this.legendCanvas.style.top = "0px";
				this.legendCanvas.style.left = "0px";

				this.drawLegendOutline(h, legendBarSwitcher.height, lc);
				lc.save();
				var x = this.legendBarWidth/2;
				var y = this.y_axis_interval / 2;
				var r = Math.round(5*zf);

				
				for(var i = 0; i < sl && y+this.y_axis_interval< h-15*zf; i++){
					lc.fillStyle = this.widget.getSerieColor(i);
					y +=this.y_axis_interval;
					utils.drawArc(this, x, y, r, 0, Math.PI * 2, true, true, lc);
				}
				lc.restore();

			 }
			 var glowDiv = this.legendBarSwitcher.lastChild;
			 if(hasGlowEffect){
			 	glowDiv.className = "timeseries-legend-switcher-shadow";
			 	glowDiv.style.left = Math.round(15*zf) + 'px';
				glowDiv.style.top = Math.round(15*zf) + 'px';
				glowDiv.style.display = "";
				glowDiv.style.visibility = "visible"
			 }
			 else{
			 	glowDiv.className = "";
			 	glowDiv.style.visibility = "hidden";
			 }
		},

		
        reRender: function reRender() {
        	
        	this.calculateAndSetLegendWidth();

        	this.height = this.calculateHeight();

        	this.renderLegend(false);

        	this.legendBarDiv.style.top = this.widget.margin.t + "px";

		    setScrollerPosition.call(this);
        },

		hiddenSwitcherArrowGlowEffect: function hiddenSwitcherArrowGlowEffect(){
        	var glowDiv = this.legendBarSwitcher.lastChild;
        	
        	glowDiv.innerHTML = "";
        	glowDiv.style.visibility = "hidden";
        },

        drawLegendOutline: function drawLegendOutline(totalH, switcherH, context){
        	var utils = this.utils,
        		formatProp = this.widget.formatProp;

        	context.save();

        	context.globalAlpha = 1;
        	context.strokeStyle = utils.rgb2rgbStr(formatProp.textClr, 0.5) || '#58595B';
        	context.lineWidth = 2;
        	
			utils.drawHalfRoundedRectangle(this, 1, 1, this.legendBarWidth, totalH-2, Math.round(15*zf), false, context);

			var gradient = context.createLinearGradient(0, 0, this.legendBarWidth - 2, 0);
			var topGradient = utils.rgb2rgbStr(formatProp.textClr, 0.5) || '#58595B';
			var bottomGradient = utils.rgb2rgbStr(formatProp.textClr, 0.13) || '#222222';
			gradient.addColorStop(0, topGradient);
        	gradient.addColorStop(1, bottomGradient);
        	context.strokeStyle = gradient;
			context.lineWidth = 1;
			var yPos = switcherH - 0.5;
			utils.drawLineSet(this, [{
				x: 2,
				y: yPos
			}, {
				x: this.legendBarWidth,
				y: yPos
			}], false, context);

			context.restore();
        },

		calculateMaxLegendAttrLength: function calculateMaxLegendAttrLength( useHighlightFontStyle ){
			var model = this.model,
				s = model.series,
				sl = s.length,
				ch = model.colHeaders;
			for(var i = 0; i < sl; i++){
				 var tmpLegendLength = 0;
				 var legendName = this.widget.getLegendName(ch,s,i);
				 var fontStyle = useHighlightFontStyle ? legendFontStyleHighlight  : legendFontStyle ;
				 tmpLegendLength = this.widget.getTextWidth(legendName,fontStyle);
				 this.maxLegendAttrLength = Math.max(this.maxLegendAttrLength,tmpLegendLength);
			 }
			 
			 this.maxLegendAttrLength = this.maxLegendAttrLength + 10;
		},

		calculateAndSetLegendWidth: function cLegendWidth(){

			if(this.isLegendBarOpen){
				var maxLegendBarWidth = (this.widget.getWidth() - 50)*0.3+20;
				this.legendBarWidth = Math.min(maxLegendBarWidth, this.maxLegendAttrLength);
		    }
		    else{
		    	this.legendBarWidth = Math.round(40*zf);
		    }
			this.widget.setlegendStatus(this.isLegendBarOpen, this.legendBarWidth);
		},

		calculateHeight: function cHeight(){
			var m = this.widget.margin;
			return this.widget.getHeight() - this.widget.masterChartHeight - m.t - m.b;
		},

		postBuildRendering: function postBR() {
			resetSizeByDPI(this.utils.getScreenZoomFactor());

			this.height = this.calculateHeight();

			
			var sLength = this.model.series && this.model.series.length;
			if(sLength == 1){
				 this.isLegendSelected = true;
				 this.legendSelectedIndex = 0;
				 this.widget.setLegendSelected(this.isLegendSelected,this.legendSelectedIndex);
			}

			this.calculateMaxLegendAttrLength(sLength == 1);

			this.calculateAndSetLegendWidth();

			this.scrollerConfig.scrollEl = this.legendListDiv;

			if (this._super) {
				this._super();
			}

			this.renderLegend(false);

		    setScrollerPosition.call(this);

		  
		},

		 initScroller: function initScroller(scroller) {
			scroller.vScroll = true;

			this._super(scroller);
		},

		touchBegin: function touchBegin(touch) {
			
		 	this.widget.hiddenTooltipAndShowTimeSelector();
		    
		    var item = getTouchedElement.call(this, touch);
		    if (item) {
				var value = item.value;

				if (value === 'S' ){
					this.switchLegendBar();
				}else if(!this.isLegendBarOpen && value === 'C'){
					
					this.switchLegendBar();
				}

		    }
		},

		touchTap: function touchTap(touch) {

		    
		    var item = getTouchedElement.call(this, touch);
		    if (item) {
				var value = item.value;
				if(value === 'LA'){
					var itemIndex = mstrmojo.dom.findAncestorByAttr(touch.target, "vIndex", true, this.domNode);
					if(itemIndex){
						this.handleLegendItemTap(parseInt(itemIndex.value, 10));
					}
				}
		    }
		},

		touchEnd: function touchEnd(touch) {
	    	var me = this;

            me.hiddenSwitcherArrowGlowEffect();


	    },

		touchSelectBegin: function touchSelectBegin(touch) {
			var item = getTouchedElement.call(this, touch);
			if (item) {
				var value = item.value;
				if (value === 'LA' ){
					var itemIndex = mstrmojo.dom.findAncestorByAttr(touch.target, "vIndex", true, this.domNode);
					if(itemIndex){
						var fontStyle = (itemIndex.value == this.legendSelectedIndex)? legendFontStyleHighlight  : legendFontStyle ;
						var tmpItemLength = this.widget.getTextWidth(item.node.innerHTML, fontStyle);

						
						if(tmpItemLength > this.legendBarWidth - 12){
						
							var tooltipY = item.node.offsetTop -this._scroller.origin.y + this.widget.margin.t + this.legendBarSwitcher.height -5;
							this.widget.showLegendTooltip(item.node);
						}
					}
				}
			}
		},

		touchSelectEnd: function touchSelectEnd(touch) {
			this.widget.hiddenLegendTooltip();
			
	
		},

		touchMultiBegin: function touchMultiBegin(touch){
			this.touchSelectEnd(touch);
		},

		onCrossWidgetMultitouch: function onCrossWidgetMultitouch(){
			this.widget.hiddenLegendTooltip();
			this.hiddenSwitcherArrowGlowEffect();
		},

		handleLegendItemTap:function handleLegendItemTap(vIndex){
			
			if(this.model.series.length == 1){
				return;
			}
			if(this.isLegendSelected){
				if( this.legendSelectedIndex === vIndex){
					this.isLegendSelected  =  false;
					this.hiddenLegendGlowEffect(vIndex);
					this.legendSelectedIndex  = -1;
				}else{
					this.hiddenLegendGlowEffect(this.legendSelectedIndex);
					this.legendSelectedIndex =  vIndex;
					this.enableLegendGlowEffect(vIndex);
				}
			}else{
				this.isLegendSelected = true;
				this.legendSelectedIndex =  vIndex;
				this.enableLegendGlowEffect(vIndex);

			}
			this.widget.setLegendSelected(this.isLegendSelected,this.legendSelectedIndex);
			this.widget.reDrawSlaveChart();
		},

		destroy: function destroy() {
			if(this._super){
				 this._super();
			}
		}

    });

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Vis");

    var DEFAULT_DARK_THEME = 1;
    var DEFAULT_LIGHT_THEME = 2;
    var CUSTOM_DARK_THEME = 3;
    var CUSTOM_LIGHT_THEME = 4;

    mstrmojo.VisMicroChartBullet = mstrmojo.declare(

        mstrmojo.Vis,

        null,

        {

            scriptClass: 'mstrmojo.VisMicroChartBullet',

            isDrawAxis: false,

            margin: {t: 0, r: 5, b: 0, l: 5},

            showHighlightLine: false,

            themeColor: '#FFFFFF',

            noBackground: true,

            isAnimateLines: false,

            toolTipMain: null,

            mainWidth: 0,

            mainLeftPos: 0,

            showMinLabel: false,

            markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};top:{@top};left:{@left};position:relative;" ' +
                ' mstrAttach:mousedown,mouseup,mousemove,click ' +
                '><canvas width="{@width}" height="{@height}"></canvas>' +
                
                
                '<div style="position:absolute;left:0px;bottom:0px;display:none;font:7px Arial;text-align:left;line-height:7px;"></div>' +
                '<div style="width:100%;height:{@height};top:0px;left:0px;position:absolute;display:none;font:10pt Arial;overflow: hidden; text-overflow: ellipsis; white-space:nowrap"></div>' +
                '</div>',

            markupSlots: {

                canvas: function () {
                    return this.domNode.firstChild;
                },
                minLabel: function () {
                    return this.domNode.childNodes[1];
                },
                errorMsg: function () {
                    return this.domNode.childNodes[2];
                }
                
                
                
            },
            postBuildRendering: function postBR() {
                if (this._super) {
                    this._super();
                }
                this.browserSupportsHtml5 = this.canvas.getContext;
                if (!this.browserSupportsHtml5) {
                    this.renderErrorMessage(mstrmojo.desc(8126, 'Your browser does not support HTML5'));
                    return;
                }
                if (!this.model) {
                    this.renderErrorMessage(mstrmojo.desc(8426, 'No model provided'));
                    return;
                }

                if (this.model.err || this.model.eg) {
                    this.renderErrorMessage(this.model.err || this.model.eg);
                    return;
                }

                this.context = this.canvas.getContext('2d');
                
                
                this.setColorByTheme();
                this.drawChart();
            },

            setColorByTheme: function setColorByTheme() {
                var bulletProps = this.config;
                var dpi = mstrMobileApp && mstrMobileApp.getDeviceDPI() || 160;
                if (this.theme == DEFAULT_DARK_THEME) {
                    this.bandColor1 = "#494949";
                    this.bandColor2 = "#595959";
                    this.bandColor3 = "#727272";

                    this.refLinePosColor = "#FF781D";
                    this.refLineNegColor = "#FF781D";
                    this.refLineWidth = dpi >= 160 ? 2 : 1;
                    this.blueBarPosColor = "#00BDFF";
                    this.blueBarNegColor = bulletProps.mwNegCol;
                } else if (this.theme == DEFAULT_LIGHT_THEME) {
                    this.bandColor1 = "#A5A5A5";
                    this.bandColor2 = "#B3B3B3";
                    this.bandColor3 = "#C4C4C4";

                    this.refLinePosColor = "#FF781D";
                    this.refLineNegColor = "#FF781D";
                    this.refLineWidth = dpi >= 160 ? 2 : 1;
                    this.blueBarPosColor = "#00BDFF";
                    this.blueBarNegColor = bulletProps.mwNegCol;
                } else {
                    this.bandColor1 = bulletProps.mwBand1 || "#999999";
                    this.bandColor2 = bulletProps.mwBand2 || "#BBBBBB";
                    this.bandColor3 = bulletProps.mwBand3 || "#DEDEDE";

                    this.refLinePosColor = bulletProps.mwRefLineCol;
                    this.refLineNegColor = bulletProps.mwRefLineCol;
                    this.blueBarPosColor = bulletProps.mwPosCol;
                    this.blueBarNegColor = bulletProps.mwNegCol;
                }
            },

            showTooltip: function shwttp(touchX, touchY) {
                if (!this.config.mbShowTooltip) {
                    return false;
                }
                var minValue = this.config.mfMinValue;
                var refV = this.refv;
                var mc3 = refV[2].rv - minValue;
                var mc4 = refV[3].rv - minValue;
                var ttp = this.toolTipMain;

                var model = this.model;
                var metrics = model.mtrcs.items;

                var bulletProps = this.config;

                var ofht = 17;
                var line1;

                if ( this.widget.bulletProps.mstrAssMetric) {
                    line1 = this.widget.bulletProps.mstrAssMetric + ": " + refV[2].v;
                }
                else {
                    line1 = metrics[2] + ": " + refV[2].v;
                }
                var maxWidth = this.widget.getTextWidthByCanvas(line1, ttp);
                if (bulletProps.mbRefLine) {
                    line1 = '<div style="margin-left:5px;margin-top:5px;"><div style="float:left;margin-right:5px;margin-top:2px;width:12px;height:10px;background-color:' + this.targetColor + ';"></div><div style="float:left;text-align:top;">' + line1 + "</div></div>";
                } else {
                    line1 = '<div style="margin-left:5px;margin-top:5px;margin-bottom:5px;"><div style="float:left;margin-right:5px;margin-top:2px;width:12px;height:10px;background-color:' + this.targetColor + ';"></div><div style="float:left;text-align:top;">' + line1 + "</div></div>";
                }

                if (bulletProps.mbRefLine) {
                    ofht += 17;
                    var line2 = metrics[6] + ": " + refV[6].v;
                    var line2Width = this.widget.getTextWidthByCanvas(line2, ttp);
                    if (line2Width > maxWidth) {
                        maxWidth = line2Width;
                    }
                    line2 = '<div style="margin-left:5px;margin-bottom:5px;"><div style="float:left;margin-left:5px;margin-top:2px;margin-right:10px;width:2px;height:10px;background-color:' + this.refLineColor + ';"></div><div style="float:left;">' + line2 + "</div></div>";
                    line1 += "<br/>" + line2;
                }
                ofht += 10;

                
                
                
                
                
                

                if (this.tooltipErrMsg) {
                    ttp.innerHTML = this.tooltipErrMsg;
                } else {
                    ttp.innerHTML = line1;
                }

                var pos = mstrmojo.dom.position(this.domNode, true);
                var posWdt = mstrmojo.dom.position(this.widget._leftChart.domNode, true);
                maxWidth += 28;
                ttp.style.display = 'block';
                ttp.style.borderColor = this.targetColor;
                ttp.style.width = maxWidth + "px";
                var tpof = 0;
                if ((this.getHeight() - ofht) % 2 == 0) {
                    tpof = (pos.y - posWdt.y + (this.getHeight() - ofht) / 2);
                } else {
                    tpof = (pos.y - posWdt.y + (this.getHeight() - ofht - 1) / 2);
                }

                if (tpof < 0) {
                    tpof = 0;
                }
                if (tpof + ofht > this.widget.getHeight()) {
                    tpof = this.widget.getHeight() - ofht - 5;
                }
                ttp.style.top = tpof + "px";

                
                var ttpLeft = 0;
                if (pos.x + pos.w / 2 > (posWdt.x + posWdt.w / 2)) {
                    
                    ttpLeft = pos.x - posWdt.x - maxWidth - 10;
                } else {
                    
                    ttpLeft = pos.x - posWdt.x + pos.w + 10;
                }
                if (ttpLeft < 0) {
                    ttpLeft = 0;
                }

                ttp.style.left = ttpLeft + "px";
                return true;
            },

            drawChart: function drwchrt() {
                var bulletProps = this.config;
                var minValue = bulletProps.mfMinValue;
                var refV = this.refv;
                var mc3, mc4, mc5, mc6, mc7;
                
                var mMc3, mMc4, mMc5, mMc6, mMc7;
                mMc3 = parseFloat(refV[2].rv);
                mMc4 = parseFloat(refV[3].rv);
                mMc5 = parseFloat(refV[4].rv);
                mMc6 = parseFloat(refV[5].rv);
                mMc7 = parseFloat(refV[6].rv);
                mc3 = mMc3 - minValue;
                mc4 = mMc4 - minValue;
                mc5 = mMc5 - minValue;
                mc6 = mMc6 - minValue;
                mc7 = mMc7 - minValue;

                var isInverted = bulletProps.mbInvertAxis;
                var hasRefLine = bulletProps.mbRefLine;
                var hasRefBands = bulletProps.mbRefBands;
                var mShowTooltip = bulletProps.mbShowTooltip;
                var ctx = this.context;
                var ratioBetweenMetricViewWidth;
                var bulletHeight;

                var minLabelHeight = 7, minLabelWidth;
                var xPadding = 0, yPadding = 5;

                if (isNaN(mc3) || isNaN(mc4) || isNaN(mc5) || isNaN(mc6)) {
                    var err = mstrmojo.desc(10860, 'Insufficient data to plot the graph');
                    this.errorMsg.innerHTML = err;
                    this.errorMsg.style.display = 'block';
                    this.minLabel.style.display = "none";

                    this.tooltipErrMsg = err;
                    return;
                } else if (mc3 * mc4 > 0 && Math.abs(mc3) > Math.abs(mc4)) {
                    var err = mstrmojo.desc(10381, 'Metric of Butllet is out of the max graph range');
                    this.errorMsg.innerHTML = err;
                    this.errorMsg.style.display = 'block';
                    this.minLabel.style.display = "none";

                    this.tooltipErrMsg = err;
                    return;
                } else {
                    this.errorMsg.style.display = 'none';

                    this.tooltipErrMsg = null;
                }

                var xOri;
                var redComp, greenComp, blueComp;
                var mcOriX, mcOriY;
                var mcHeight, mcWidth;

                if (mc3 < 0 && mc4 > 0) {
                    ratioBetweenMetricViewWidth = (this.getWidth() - 2 * xPadding) / (mc4 - mc3);
                    xOri = xPadding - mc3 * ratioBetweenMetricViewWidth;
                    bulletHeight = this.getHeight() - minLabelHeight - 2 * yPadding - 2;
                    
                    if (hasRefBands) {
                        mcHeight = bulletHeight;

                        
                        mcWidth = this.getWidth() - 2 * xPadding;
                        mcOriX = xPadding;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.bandColor3;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                        
                        if (mc6 > mc3 && mc6 < mc4) {
                            mcWidth = (mc6 - mc3) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            ctx.fillStyle = this.bandColor2;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }

                        
                        if (mc5 > mc3 && mc5 < mc4) {
                            mcWidth = (mc5 - mc3) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            ctx.fillStyle = this.bandColor1;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }
                    }
                    
                    mcHeight = bulletHeight / 2.0;
                    mcWidth = Math.abs(mc3) * ratioBetweenMetricViewWidth;
                    mcOriX = xPadding;
                    mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                    ctx.fillStyle = this.targetColor = mMc3 >= 0 ? this.blueBarPosColor : this.blueBarNegColor;
                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    
                    if (hasRefLine && mc7 > mc3 && mc7 < mc4) {
                        mcHeight = bulletHeight;
                        mcWidth = 2;
                        mcOriX = xOri + mc7 * ratioBetweenMetricViewWidth;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.refLineColor = mMc3 >= 0 ? this.refLinePosColor : this.refLineNegColor;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    }
                } else if (mc3 < 0 && mc4 < 0) {
                    ratioBetweenMetricViewWidth = (this.getWidth() - 2 * xPadding) / (Math.abs(mc4));
                    xOri = xPadding;
                    bulletHeight = this.getHeight() - minLabelHeight - 2 * yPadding - 2;
                    isInverted = !isInverted;
                    
                    if (hasRefBands) {
                        mcHeight = bulletHeight;

                        
                        mcWidth = this.getWidth() - 2 * xPadding;
                        mcOriX = xPadding;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.bandColor3;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                        
                        if (mc6 < 0 && mc6 > mc4) {
                            mcWidth = Math.abs(mc6) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            ctx.fillStyle = this.bandColor2;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }

                        
                        if (mc5 < 0 && mc5 > mc4) {
                            mcWidth = Math.abs(mc5) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            ctx.fillStyle = this.bandColor1;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }
                    }
                    
                    mcHeight = bulletHeight / 2.0;
                    mcWidth = Math.abs(mc3) * ratioBetweenMetricViewWidth;
                    mcOriX = xPadding;
                    mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                    ctx.fillStyle = this.targetColor = mMc3 >= 0 ? this.blueBarPosColor : this.blueBarNegColor;
                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    
                    if (hasRefLine && mc7 < 0 && mc7 > mc4) {
                        mcHeight = bulletHeight;
                        mcWidth = 2;
                        mcOriX = xOri + Math.abs(mc7) * ratioBetweenMetricViewWidth;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                        ctx.fillStyle = this.refLineColor = mMc3 >= 0 ? this.refLinePosColor : this.refLineNegColor;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    }
                } else if (mc3 > 0 && mc4 > 0) {
                    if (this.showMinLabel) {
                        yPadding = 9.5;
                    } else {
                        yPadding = 5;
                    }
                    ratioBetweenMetricViewWidth = (this.getWidth() - 2 * xPadding) / mc4;
                    xOri = xPadding;
                    bulletHeight = this.getHeight() - 2 * yPadding;
                    
                    if (hasRefBands) {
                        mcHeight = bulletHeight;

                        
                        mcWidth = this.getWidth() - 2 * xPadding;
                        mcOriX = xPadding;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.bandColor3;
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                        
                        if (mc6 > 0 && mc6 < mc4) {
                            mcWidth = mc6 * ratioBetweenMetricViewWidth;
                            mcOriX = xOri;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            ctx.fillStyle = this.bandColor2;
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }

                        
                        if (mc5 > 0 && mc5 < mc4) {
                            mcWidth = mc5 * ratioBetweenMetricViewWidth;
                            mcOriX = xOri;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            ctx.fillStyle = this.bandColor1;
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }
                    }
                    
                    mcHeight = bulletHeight / 2.0;
                    mcWidth = mc3 * ratioBetweenMetricViewWidth;
                    mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                    mcOriX = xOri;
                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    ctx.fillStyle = this.targetColor = mMc3 >= 0 ? this.blueBarPosColor : this.blueBarNegColor;
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    
                    if (hasRefLine && mc7 > 0 && mc7 < mc4) {
                        mcHeight = bulletHeight;
                        mcWidth = 2;
                        mcOriX = xOri + mc7 * ratioBetweenMetricViewWidth;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.refLineColor = mMc3 >= 0 ? this.refLinePosColor : this.refLineNegColor;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    }

                } else {
                    
                    ratioBetweenMetricViewWidth = (this.getWidth() - 2 * xPadding) / (mc3 - mc4);
                    bulletHeight = this.getHeight() - minLabelHeight - 2 * yPadding - 2;
                    xOri = xPadding - mc4 * ratioBetweenMetricViewWidth;
                    ;
                    isInverted = !isInverted;

                    
                    if (hasRefBands) {
                        mcHeight = bulletHeight;

                        
                        mcWidth = this.getWidth() - 2 * xPadding;
                        mcOriX = xPadding;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.bandColor3;
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                        
                        if (mc6 < mc3 && mc6 > mc4) {
                            mcWidth = (mc3 - mc6) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                            ctx.fillStyle = this.bandColor2;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }

                        
                        if (mc5 < mc3 && mc5 > mc4) {
                            mcWidth = (mc3 - mc5) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                            ctx.fillStyle = this.bandColor1;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }
                    }
                    
                    mcHeight = bulletHeight / 2.0;
                    mcWidth = Math.abs(mc3) * ratioBetweenMetricViewWidth;
                    mcOriX = xOri;
                    mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                    ctx.fillStyle = this.targetColor = mMc3 >= 0 ? this.blueBarPosColor : this.blueBarNegColor;
                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    
                    if (hasRefLine && mc7 < mc3 && mc7 > mc4) {
                        mcHeight = bulletHeight;
                        mcWidth = 2;
                        mcOriX = xOri + mc7 * ratioBetweenMetricViewWidth;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.refLineColor = mMc3 >= 0 ? this.refLinePosColor : this.refLineNegColor;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    }
                }

                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                

                
                if (mc3 < 0) {
                    mcHeight = bulletHeight;
                    mcWidth = 2;
                    mcOriX = xOri;
                    mcOriY = yPadding;
                    redComp = 0;
                    greenComp = 0;
                    blueComp = 0;

                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }

                    ctx.fillStyle = "#000000";
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                    
                    minValue = minValue + "";
                    var disPlayValue = (minValue == "0") ? "" : "$";
                    var mlen = 0;
                    for (var i = 0; i < minValue.length; i++) {
                        if (minValue[i] == '.') {
                            break;
                        }
                        mlen++;
                    }
                    for (var i = 0; i < minValue.length; i++) {
                        disPlayValue += minValue[i];
                        mlen--;
                        if (mlen % 3 == 0 && mlen > 0) {
                            disPlayValue += ",";
                        }
                    }
                    minValue = disPlayValue;
                    var textWidth = this.widget.getTextWidthByCanvas(minValue, this.minLabel);

                    minLabelWidth = textWidth - 1;

                    mcOriX = xOri;

                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    if (mcOriX - minLabelWidth / 2 <= xPadding) {
                        this.minLabel.style.paddingLeft = xPadding;
                    } else if (mcOriX + minLabelWidth / 2 <= this.getWidth() - xPadding) {
                        this.minLabel.style.paddingLeft = Math.round(mcOriX - minLabelWidth / 2) + "px";
                    }
                    else {
                        this.minLabel.style.paddingLeft = Math.round((this.getWidth() - xPadding - minLabelWidth)) + "px";
                    }

                    this.minLabel.style.bottom = yPadding + "px";

                    
                    this.minLabel.style.fontSize = "7pt";
                    
                    if (this.labelColorRGB) {
                        this.minLabel.style.color = 'rgb(' + this.labelColorRGB[0] + ',' + this.labelColorRGB[1] + ',' + this.labelColorRGB[2] + ')';
                    } else {
                        this.minLabel.style.color = "";
                    }
                    this.minLabel.innerHTML = minValue;
                    this.minLabel.style.display = "block";

                } else {
                    this.minLabel.style.display = "none";
                }

            },

            convertColor: function convrtClr(ngv) {
                var ret = "#";
                var base = parseInt("0xff");
                var blueComp = ngv & base;
                base = parseInt("0xff00");
                var greenComp = ((ngv & base) >> 8);
                base = parseInt("0xff0000");
                var redComp = ((ngv & base) >> 16);
                var redP = redComp.toString(16);
                if (redP.length < 2) {
                    redP = "0" + redP;
                }

                var greenP = greenComp.toString(16);
                if (greenP.length < 2) {
                    greenP = "0" + greenP;
                }

                var blueP = blueComp.toString(16);
                if (blueP.length < 2) {
                    blueP = "0" + blueP;
                }
                ret += redP;
                ret += greenP;
                ret += blueP;
                return ret;
            },

            drawRect: function (ctx, x, y, width, height) {
                
                x = Math.round(x);
                y = Math.round(y);
                width = Math.round(width);
                height = Math.round(height);
                ctx.fillRect(x, y, width, height);
            },

            reDrawChart: function reDrwchart() {
                var context = this.context,
                    canvas = this.canvas,
                    wd = canvas.width,
                    ht = canvas.height;
                context.clearRect(0, 0, wd, ht);
                this.postBuildRendering();
            }
        }
    );

})();

  
  (function () {

    mstrmojo.requiresCls("mstrmojo.Vis",
                         "mstrmojo.array",
                         "mstrmojo.hash",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo.GeoLocation",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.DropDownList",
                         "mstrmojo.Label");

	mstrmojo.requiresDescs(7736, 8068, 8069, 8102, 8395, 8954);

    var $A = mstrmojo.array,
        $M = mstrmojo.android.EnumMenuOptions,
        REPROMPT = $M.REPROMPT,
        MAX_MARKERS = 1000; 

    
    function CustomMarker(lbl, latlng, rad, index, color) {
        this.title = lbl;
        this._latlng = latlng;
        this._rad = rad;
        this._ix = index;
        this._color = color;
    }

    function initCustomMarker() {

       CustomMarker.prototype = new google.maps.OverlayView();

       CustomMarker.prototype.draw = function() {

           
           var div = this.div_;
           if (!div) {
               
               div = this.div_ = document.createElement('DIV');
               
               var sty = div.style,
                   rad = this._rad,
                   radD2 = rad / 2,
                   radD2Px = radD2 + "px " + radD2 + "px",
                   panes = this.getPanes(),
                   me = this;

               sty.position = "absolute";
               sty.paddingLeft = "0px";
               sty.cursor = 'pointer';
               sty.backgroundColor = this._color;
               sty.opacity = '.65';
               sty.borderRadius = radD2Px;
               sty.height = sty.width = rad + "px";
               sty.border = "2px solid black";

               google.maps.event.addDomListener(div, "click", function(event) {
                   google.maps.event.trigger(me, "click");
               });

               
               panes.overlayMouseTarget.appendChild(div);
           }

           
           var point = this.getProjection().fromLatLngToDivPixel(this._latlng);
           if (point) {
               div.style.left = (point.x - this._rad / 2) + 'px';
               div.style.top = (point.y - this._rad / 2) + 'px';
           }
       };

       CustomMarker.prototype.remove = function() {
           
           var dv = this.div_;
           if (dv) {
               dv.parentNode.removeChild(dv);
               this.div_ = null;
           }
       };

       CustomMarker.prototype.getPosition = function() {
           return this._latlng;
       };

   }

    var getBounds = function getBounds(markers){
        var bnds;
        if(markers.length > 0){

            bnds = new google.maps.LatLngBounds();
            for(var i in markers){
                var m = markers[i],
                    p = m.getPosition();



                bnds.extend(p);
            }
        }
        return bnds;
    };

    function getFromPoint(laOrln, value){
        return value.replace(/POINT[ ]?\(|\)/g,"").split(' ')[laOrln == 'lat' ? 1 : 0];
    }

    function _getMapType() {
        return this._mapTypeToGoogleMapTypeId[this.mapType];
    }


    
    mstrmojo.maps.jsmap.AndroidMap = mstrmojo.declare(
        mstrmojo.Vis,

        [ mstrmojo._TouchGestures ],

        {
            scriptClass: "mstrmojo.maps.jsmap.AndroidMap",

            cssClass : "mstr-googleMapView",

            markupString: '<div id="{@id}" class="mstrmojo-Box {@cssClass}" style="{@domNodeCssText}">' +
                             '<div></div>' +
                              '<div class="androidMap-metricSelector"><span class="androidMap-toggleHeader"></span></div>' +
                              '<div class="mstr-googleMap" id="map_canvas_{@id}"></div>' +
                          '</div>',

            reRenderOnDimensionChg: false,
            
            noMapsMsg: mstrmojo.desc(8954,"Google Maps have not been configured for this device. Please check with your mobile administrator to enable Google Maps in the mobile configuration."),
            
            
            selMetricIx : 0,

           
            markerArr : [],

           
           googleMap : null,

           
           bubblesMaxInfo : [],

           
           maxBubbleSize : 50,
           minBubbleSize : 20,

           
           markupSlots : {
               msg : function() { return this.domNode.childNodes[0]; },
               metricSelector : function(){ return this.domNode.childNodes[1];},
               map : function(){ return this.domNode.childNodes[2];}
           },

            markupMethods: {
                onheightChange: function(){
                    this.domNode.style.height = this.getHeight() + 'px';
                },
                onwidthChange: function(){
                    this.domNode.style.width = this.getWidth() + 'px';
                }
            },

           
           layoutConfig: {
               h: {
                   metricSelector: '32px',
                   map: '100%'
               },
               w: {
                   metricSelector: '200px',
                   map: '100%'
               }
           },

           children: [{
                   scriptClass: 'mstrmojo.android.DropDownList',
                   slot: 'metricSelector',
                   options: null,
                   onidxChange: function(evt) {
                       this._super(evt);
                       this.parent.onselMetricIxChange( evt );
                       this.set('value', this.options[evt.value].v);
                   },
                   visible: false,
                   alias: "metricSel"
                },{
                   scriptClass: 'mstrmojo.Box',
                   slot: 'map'

                }, {
                    scriptClass: 'mstrmojo.Label',
                    cssClass: "androidMap-errorMsg",
                    visible: true,
                    alias: "errorMsg",
                    slot: "msg"
                }
            ],

            setModel: function setModel(model) {
                this.set('model', model);
                this.xtabModel = model;
                if ( model.data ) {
                    this.set('gridData', model.data);
                }
            },

            ongridDataChange: function() {
                this.parser = new mstrmojo.Vis.DataParser(this.gridData);
            },

            update: function update(node) {
                node = node || this.node;
                if (node) { 
                	if (node.data) {
                	
                	    this.set('gridData', node.data);

                        var gd = this.gridData;
                		if (gd.layoutModel) this.layoutModel = gd.layoutModel;
                		if (gd.layoutNode) this.layoutNode = gd.layoutNode;
                	}
                    var fmts = node.defn.fmts || node.defn.units[this.xtabModel.k].fmts;

                    this.width = parseInt(fmts.width, 10);
                    this.height = parseInt(fmts.height, 10);
                    this.top = parseInt(fmts.top,10);
                    this.left = parseInt(fmts.left,10);
                    this.fmts = fmts;
                }

                if (this.xtabModel) {
                	this.initFromVisProps(this.gridData.vp);
                }
                this.updated = true;
            },

            getMapModel: function() {
                return this.xtabModel;
            },

			initFromVisProps: function initFromVisProps(vp) {
				if(!vp) return;

				
				if(vp.dv) {
					this.mapType = parseInt(vp.dv,10);
				}				
                this.usePt = ( vp.gr == "1" );
                this.useAttributes = ( vp.af === "0" );
                this.geoAttr = vp.ga;
                this.markerType = vp.mtp;
                this.attrThresholds = vp.at;
                this.flong = vp.flong;
                this.flat = vp.flat;
                this.fpt = vp.fpt;
                this.mstyl = vp.mstyl;
                this.maxBubbleSize = vp.mbs || 50;
            },

            showErrorMsg: function showErrorMsg(show,msg) {
                this.errorMsg.set("text", msg );
                this.metricSelector.style.display = show ? "none" : "block";
                this.map.style.display = show ? "none" : "block";
                this.msg.style.display = show ? "block" : "none";
            },
			
            postBuildRendering : function postBuildRendering(){
console.log("JSMAP:androiMap:postBuildRendering");
               this._super();

               if ( typeof this.gridData.eg !== "undefined" ) {
                   this.showErrorMsg( true, this.gridData.eg );
               } else if ( typeof google === "undefined" || ( google && typeof google.maps === "undefined" )) {
                   this.showErrorMsg(true,this.noMapsMsg);
               } else {

                   this.showErrorMsg(false);

                    
                    var selectorCtrl = this.children[0];

                    selectorCtrl.idx = 0;
                    selectorCtrl.unset = true;
                    selectorCtrl.options = [{ v: '-1', n: '' }];

                    if( 
                        ( typeof google !== "undefined" && google.maps ) ) {

                        
                        if ( !mstrApp.isInfoWindow ) {
                            this.markerArr = [];
                            this.bubblesMaxInfo = [];
                        }

                        this._mapTypeToGoogleMapTypeId = [  google.maps.MapTypeId.ROADMAP,
                                                            google.maps.MapTypeId.SATELLITE,
                                                            google.maps.MapTypeId.HYBRID,
                                                            google.maps.MapTypeId.TERRAIN ];

                        
                        initCustomMarker();
                        
                        if(this.gridData){

                            var showSelector = this.buildMetricSelector(),
                                selectorHeight = showSelector ? parseInt(this.layoutConfig.h.metricSelector,10) : 0;

                            this.metricSel.set('visible',showSelector);

                            this.map.style.height = this.getHeight() + "px";
                           	this.map.style.width = (this.getWidth() - 1) + "px";

                            this.metricSelector.style.height = selectorHeight + "px";
                            this.metricSelector.style.display = showSelector ? "block" : "none";

                            this.initMap();

                            if ( this.map.firstChild ) {
                                this.map.firstChild.style.zIndex = 1;
                            }
                        }
                    }
               }
           },



            gup: function gup(n){
            	n = n.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
            	var rxs = "[\\?&]"+n+"=([^&#]*)",
            	    rx = new RegExp(rxs),
            	    r = rx.exec(window.location.href);
            	return r == null ? "" : r[1];
            },

           
           onselMetricIxChange: function(evt){
               var f = function(map,mks){
                   for(var i in mks){
                       if(mks[i].setMap){
                           mks[i].setMap(map);
                       }
                   }
               };

               
               if(this.openedInfoWindow){
                   this.openedInfoWindow.close();
               }
               
               var mks = this.getMarkers(evt.value),
                   oldMks = this.getMarkers(evt.valueWas);

               this.selMetricIx = evt.value;

               
               f(null, oldMks);
               
               f(this.googleMap, mks);
           },

           
           buildMetricSelector : function buildMetricSelector() {
               var  col = this.gridData.gts.col,
                    useSelector = false;

               if ( col.length > 0 ) {
                   var metrics = col[0].es;

                   if( metrics.length > 1 ) {

                        var  items = [],
                             x = -1;

                        
                        $A.forEach(metrics, function (m, idx) {
                            
                            items[++x] = {
                                n: m.n,
                                v: x,
                                id: m.id
                            };
                        });

                        var selector = this.children[0];

                        selector.set('options',items);
                        selector.set('value', 0 );

                        useSelector = true;
                    }
               }
               return useSelector;
           },

            

            initMap : function () {
                var map,
                    gm = google.maps,
                    gme = gm.event,
                    mapType = _getMapType.call(this) || gm.MapTypeId.ROADMAP,
                   
                   mapOptions = {
                       mapTypeControl : true,
                       mapTypeControlOptions: {
                           position: gm.ControlPosition.TOP_LEFT,
                           style: gm.MapTypeControlStyle.HORIZONTAL_BAR 
                       },
                       streetViewControl :false,
                       mapTypeId : mapType,
                       navigationControlOptions : {
                         position : gm.ControlPosition.RIGHT_BOTTOM,
                         style : gm.NavigationControlStyle.ANDROID
                       },
                       zoomControlOptions: {
                           style: gm.ZoomControlStyle.LARGE
                       },
                       tilt: 0

                     };

                
                this.googleMap = map = new gm.Map(this.map, mapOptions);

                
                this.selMetricIx = this.selMetricIx;

                
                var markers = this.getMarkers(this.selMetricIx);

                if ( markers.length > 0 ) {
                    
                    var bnds = this.mapBounds; 

                   
                   if ( bnds ) {
                       map.fitBounds(bnds);
                       map.setCenter(bnds.getCenter());
                   }
                } else {
                    
                    var mstrHQ = new gm.LatLng(38.893444,77.221648);
                    map.setCenter(mstrHQ);
                }

                
                
                var INTERVAL = 30,
                    t = 0,
                    mz = map.getZoom(),
                    ti = setInterval(function() {
	                	mz = map.getZoom();	                	
	                    t += INTERVAL;
	                    if ( mz !== undefined ) {
	                        
                            
			                if ( mz > 20 ) {
			                    map.setZoom(15);			
			                } else if ( mz < 2 ) {
			                    map.setZoom(2);
			                }
	                        clearTimeout(ti);
	                    } else if (t > 10*INTERVAL) {
	                        
	                        clearTimeout(ti);
	                        map.setZoom(2);
	                    }
	                }, INTERVAL);	                
           },

           
            getMarkers : function getMarkers(metricIx){
                
                if(!!this.markerArr[metricIx]){
                    return this.markerArr[metricIx];
                }

                var map = this.googleMap,
                    d = this.gridData,
                    vp = d.vp,
                    gts = d.gts,
                    row = gts.row,
                    usePt = this.usePt,
                    minVals = (usePt ? 1 : 2 ),  
                    useAttributes = this.useAttributes,
                    geoAttr = this.geoAttr,
                    longs, lats, labels,
                    longIdx = -1, latIdx = -1, labelIdx = -1,
                    mks = [],
                    tIcon = null;

                for( var r = 0, numRows = row.length, totalForms = 0; r < numRows; ++r ) {
                    var curRow = row[r],
                        rid = curRow.id;
					
                    

                    
                    if ( usePt ) {
                        
                        if ( rid == this.fpt ) {
                            longs = lats = curRow;
                            longIdx = latIdx = totalForms;
                        }
                    } else {
                        
                        
                        if ( rid == this.flong ) {
                            longs = curRow;
                            longIdx = totalForms;

                        
                        } else if ( rid == this.flat ) {
                            lats = curRow;
                            latIdx = totalForms;
                        }
                    }

                    for( var f = 0, numForms = curRow.fs.length; f < numForms; ++f ) {
                        var curForm = curRow.fs[f],
                            fid = curForm.id;

                        
                        if ( usePt ) {
                            
                            if ( fid == this.fpt ) {
                                longs = lats = curRow;
                                longIdx = latIdx = totalForms + f;
                            }
                        } else {
                            
                            
                            if ( fid == this.flong ) {
                                longs = curRow;
                                longIdx = totalForms + f;
                            
                            } else if ( fid == this.flat ) {
                                lats = curRow;
                                latIdx = totalForms + f;
                            }
                        }

                        
                        if ( labelIdx < 0 ) {
                            labels = curRow;
                            labelIdx = totalForms + f;
                        }
                    }

                    totalForms += numForms;
                }

                
                if ( Math.min(longIdx,latIdx,labelIdx) < 0 ) {
                    throw new Error(mstrmojo.desc(8395, 'Not enough data to display map.'));
                }

                var rhs = d.ghs.rhs.items,
                    numMarkers = Math.min( rhs.length , MAX_MARKERS ),
                    lat_hi = -90, lat_lo = 90, lng_hi = -180, lng_lo = 180;

                for( var i = 0; i < numMarkers; i++ ) {
                    var vals = rhs[i].items; 

                    
                    
                    if ( vals.length < minVals) {
                        continue;
                    }
                    
                    
                    var longV = longs.es[vals[longIdx].idx].n,
                        lon = parseFloat( usePt ? getFromPoint("long", longV ) : longV ),
                        lat = parseFloat( usePt ? getFromPoint("lat", longV ) : lats.es[vals[latIdx].idx].n ),
                        lbl = labels.es[vals[labelIdx].idx].n,
                        marker,
                        metricItem = d.gvs.items[i];

                    
                    if ( isNaN(lat) || isNaN(lon)) {
                        continue;
                    }

                    
                    lat_lo = ( lat < lat_lo ) ? lat : lat_lo;
                    lat_hi = ( lat > lat_hi ) ? lat : lat_hi;
                    lng_lo = ( lon < lng_lo ) ? lon : lng_lo;
                    lng_hi = ( lon > lng_hi ) ? lon : lng_hi;

                    
                    latLng = new google.maps.LatLng(lat, lon);

                    
                    if ( this.markerType == "2" ) {
                        marker = this.getMetricBubble(d.gvs.items[i], lbl, latLng, i, metricIx);
                    } else {

                        
                    	tIcon = "../" + this.mstyl;
                    	
                    	var gvsItem = d.gvs.items[i];
	                    if ( gvsItem ) {
	
	                    	var	mitems = gvsItem.items;
	                    	if ( mitems ) {
	                    		var mi = mitems[metricIx];

	                    		
		                        if( mi && (mi.ts == 4) && (this.attrThresholds == "1")){
		                            tIcon = this.getImage(mi.v);
		                        }
	                    	}
	                    }

                        
                        marker = new google.maps.Marker({
                            position: latLng,
                            title: lbl,
                            _ix : i,
                            icon : tIcon,
                            zIndex: i       
                        });
                    }

                    
                    marker.eid = labels.es[vals[labelIdx].idx].id;
                    marker.attrid = labels.id;

                    marker.setMap(map);

                    
                    google.maps.event.addListener(marker, 'click', function(ths,m) {
                        return function() {

                            
                            

                            
                            ths.handleMarkerClick(map,m);
                        };
                    }(this,marker) );

                    
                    mks[mks.length] = marker;
                }

                

                this.mapBounds = new google.maps.LatLngBounds(
                    new google.maps.LatLng(lat_lo,lng_lo),
                    new google.maps.LatLng(lat_hi,lng_hi)
                 );

                
                this.markerArr[metricIx] = mks;

               return mks;
           },

           handleMarkerClick: function(map,marker) {
                
                if( this.openedInfoWindow){
                    this.openedInfoWindow.close();
                    this.openedInfoWindow = null;
                }
                this.openInfoWindow(map,marker);

                this.postHandleMarkerClick(map,marker);
           },

           
           postHandleMarkerClick: mstrmojo.emptyFn,

           
           getImage: function getImage(url) {
                var app = mstrApp,
                    config = app.getConfiguration();

                if (config && url && url.indexOf('://') === -1) {

                    url = config.getHostUrlByProject(app.getCurrentProjectId()) + url;
                }

                return (mstrApp.useBinaryFormat) ? String(mstrMobileApp.getImage(url)) : url;
            },


          

           getMetricBubble : function getMetricBubble(metricItem, lbl, latLng, index, metricIx){

               var d = this.gridData,
                   mValues = d.gvs.items, 
                   maxVal = this.bubblesMaxInfo[metricIx], 
                   mv = parseFloat(metricItem.items[metricIx].rv), 
                   color = "red", 
                   bubbleRange = Math.abs(this.maxBubbleSize - this.minBubbleSize );

               
               if(!maxVal){
                   for(var i in mValues){
                       var item = mValues[i].items[metricIx],
                           v = parseFloat(item.rv) || 0; 
                       if(!maxVal){
                           maxVal = v;
                       }
                       maxVal = Math.max(maxVal,v);
                   }
                   
                   this.bubblesMaxInfo[metricIx] = maxVal;
               }

               
               if(this.attrThresholds == "1" && (typeof metricItem.items[metricIx].ty !== "undefined" )){
                    
                    var ty = metricItem.items[metricIx].ty;
                    if ( ty == 2 ) {
                        
                        color = d.th[metricItem.items[metricIx].ti].n;
                    } else {
                        
                        color = "#FFF";
                    }
               }

               
               return new CustomMarker(lbl, latLng, this.minBubbleSize + Math.round((mv/maxVal) * bubbleRange), index, color);
           },

           
           openInfoWindow : function(map,marker){
                var ix = marker._ix,
                    w = this.getInfoWindow(map,marker);

                
                
                if ( w ) {
                    
                    this.openedInfoWindow = w;
                    w.open(map,marker);
                }
           },

           
           getInfoWindow : function(map,marker){
               return this.getDefaultInfoWindow(this.gridData, marker );
           },

           getDefaultInfoWindow : function getDefaultInfoWindow(d , marker ){
                var ix = marker._ix,
                    
                    mLabels = [],  
                    mValues = d.gvs.items,      
                    res = document.createElement("div"),
                    innerHTML = '<table><tbody><tr>' +
                                   '<td colspan="2" class="androidMap-infoWindowTitle" style="padding-right: 20px">'+ marker.title +'</td>' +
                               '</tr>';
							   
				if (d.gts.col.length != 0) {
					mLabels = d.gts.col[0].es;
				}
							   
               for(var i in mLabels){
                   var item = mValues[ix].items[i];

                   
                   if(item.ts == 4){
                       var path = item.v;
                       if ( path.indexOf("http") !== 0 ) {
                           path = "../" + path;
                       }
                       innerHTML += '<tr><td class="androidMap-infoWindowText">'+ mLabels[i].n +'</td><td><img src="'+ path +'"></td></tr>';
                   } else {
                       
                       var fColor = 'black',
                           bColor = 'white';

                       
                       if(d.th && this.attrThresholds == "1" && (typeof item.ti !== "undefined") ){
                           fColor = d.th[item.ti].n;   
                       }
                       innerHTML += '<tr><td class="androidMap-infoWindowText">'+ mLabels[i].n +'</td><td style="background-color:'+ bColor +';color:'+ fColor +';">'+ item.v + '</td></tr>';
                   }
               }

               innerHTML += '</tbody></table>';

               res.innerHTML = innerHTML;

                return new google.maps.InfoWindow({
                    content: res
                });
            },
               		
            
            touchBegin: function(touch) {
               touch.stop();
               return false;
            },

            rebuildLayout: mstrmojo.emptyFn,

            setDimensions: function setDimensions(h, w) {
                var map = this.googleMap,
                    center = map ? map.getCenter() : null,
                    dimensionChanged = this._super(h, w);

                if ( map ) {
                    this.map.style.height = this.getHeight() + "px";
                   	this.map.style.width = (this.getWidth() - 1) + "px";
                   	map.setCenter(center);
                }
               	
                return dimensionChanged;            	
            },

            unrender: function unrn(ignoreDom) {
                if ( this.googleMap ) {
                    delete this.googleMap;
                }

            	this._super(ignoreDom);
            },
            
            destroy: function destroy() {
                if ( this.googleMap ) {
                    delete this.googleMap;
                }

            	this._super();
            }
        }
    );
})();
(function(){
    
    mstrmojo.requiresCls("mstrmojo.Vis", 
                         "mstrmojo.url",
                         "mstrmojo._TouchGestures", 
                         "mstrmojo.HBox",
                         "mstrmojo.Label",
                         "mstrmojo.Image",
                         "mstrmojo._HasTouchScroller");
    
    var $M = Math,
        $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom,
        BORDER_WIDTH = 30,
        MARGIN_BOTTOM = 50,
        DOT_INTERVAL = 32;
    
    
    function getDimension(dimension) {
        
        var n = 'container' + dimension;
        if(!this[n]) {
            var domNode = this.domNode,
            x = parseInt(this[dimension.toLowerCase()], 10);
            
            
            this[n] = (isNaN(x)) ? domNode['client' + dimension] : x;
        }
        return this[n];
    }    
    
    
    function getColGroupHTML(len) {
        var i, cols = '';
        if(len > 0) {
            for(i = 0; i < len; i++) {
                
                cols += '<col style="width:' + (100/len) + '%" />';
            }
        }
        return '<colgroup>' + cols + '</colgroup>';
    }
        
    
    function getImagePath(n) {
        return mstrmojo.url.getAbsoluteURL(n, mstrApp.getConfiguration().getCurrentProjectWebServerUrl());
    }
    
    
    function transitTo(domNode, xpos) {
        domNode.style[$DOM.CSS3_TRANSITION_DURATION] = '500ms';
        $DOM.translate(domNode, xpos, 0, 0, '', true);
    }
    
    
    function resizeImage(n, w, h) {
        
        if(!n) {
            return ;
        }
        var iw = n.clientWidth, 
            ih = n.clientHeight, 
            rw, rh,
            resized = false;
        
        
        if(w < iw || h < ih) {
            resized = true;
            rw = w/iw; 
            rh = h/ih; 

            
            if(rw < rh) {
                
                n.width = w;
            } else {
                
                n.height = h;
            }
        }
        return resized;
    }
    
    
    function getHeadersByColumn(dp) {
        var cols = [], r, c, col,
            rhs, hds,
            rc = dp.getTotalRows(), 
            cc = rc > 0 ? dp.getRowTitles().size() : 0; 
        
        for(r = 0; r < rc; r++) {
            
            rhs = dp.getRowHeaders(r);
            
            for(c = 0; c < cc; c++) {
                
                if(!cols[c]) {
                    cols[c] = [];
                }
                
                hds = rhs.getHeader(c);
                
                cols[c].push({n: hds.getName()});
            }      
        }
        return cols;
    }
    
        
    mstrmojo.ImageCarousel = mstrmojo.declare(
        
        mstrmojo.Vis,
        
        [mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],
                
        {
            scriptClass: 'mstrmojo.ImageCarousel',
            
            markupString: '<div class="mstrmojo-ImageCarousel {@cssClass}" style="overflow:hidden;{@cssText}">'+
                              '<div class="imageViewer" mstrAttach:click>{@noImageMsg}</div>' +
                              '<div class="imageTitle"></div>' +
                              '<div class="statusBar" style="overflow:hidden"></div>' +
                          '</div>',            
        
            markupSlots: {
                viewerNode: function() { return this.domNode.firstChild; },
                textNode: function() { return this.domNode.childNodes[1]; },
                statusBarNode: function() { return this.domNode.lastChild; }
            },
                          
            formatHandlers: {
                domNode: [ 'RW' ]
            },
            
            
            scrollerConfig: {
                friction: 0.0087,
                bounces: false,
                vScroll: false,
                hScroll: true
            },            
                        
            
            selected: -1,
            
            
            children: [{
                scriptClass: 'mstrmojo.HBox',
                slot: 'viewerNode',
                alias: 'viewer',                
                onitemsChange: function() {
                    var v, i, len, c = [],
                        vp = this.parent.vp,
                        bdcss;
                    
                    v = this.items;
                    if(!this.hasRendered) {
                        var p = this.parent,
                            cw = getDimension.call(p, 'Width'), 
                            ch = getDimension.call(p, 'Height'); 

                        if(this.children) {
                            this.removeChildren();
                        }                        
                        
                        len = v.length;
                        
                        this.colHTML = getColGroupHTML(len);
                        
                        
                        this.cssText = 'width:' + (cw*len) + 'px;height:' + (ch - MARGIN_BOTTOM) + 'px';
                        
                        bdcss = (vp && vp.bw) ? ('border:' + vp.bw + 'px solid #' + (vp.bc || 'FFF')) : ''; 
                        
                        for(i = 0; i < len; i++) {
                            c.push({
                                scriptClass: 'mstrmojo.Image',
                                cssText: bdcss,
                                cssDisplay: 'inline-block',
                                src: getImagePath(v[i].n || v[i].v),
                                onload: function() {
                                    
                                    resizeImage(this.imgNode, cw - BORDER_WIDTH, ch - MARGIN_BOTTOM);
                                }
                            });
                        }
                        this.addChildren(c);
                    }
                }
            },{
                scriptClass: 'mstrmojo.Label',
                slot: 'textNode',
                alias: 'description'
            }, {
                scriptClass: 'mstrmojo.HBox',
                slot: 'statusBarNode',
                alias: 'sb',
                onitemsChange: function() {                
                    var v = this.items, c = [], i, len;
                    
                    
                    if(this.children) {
                        this.removeChildren();
                        delete this.numVisibleDots;
                        this.lastSelected = -1;
                    }
                    
                    for(i = 0, len = v.length; i < len; i++) {
                        c.push({
                            scriptClass: 'mstrmojo.Label'                            
                        });
                    }
                    this.addChildren(c);
                    
                    
                },
                lastSelected: 0, 
                select: function(idx) {
                    var lstPg, curPg, dn = this.domNode, dts = this.numVisibleDots; 
                    
                    if(this.selectedNode) {
                        $CSS.removeClass(this.selectedNode.domNode, 'selected');
                    }
                    
                    
                    if(this.items.length > 0) {
                        this.selectedNode = this.children[idx];
                        $CSS.addClass(this.selectedNode.domNode, 'selected');
                        
                        
                        
                        if(!dts) {
                            dts = this.numVisibleDots = $M.floor(getDimension.call(this.parent, 'Width')/DOT_INTERVAL);
                            if(this.items.length < dts) {
                                $CSS.addClass(dn, 'center');
                            } else {
                                $CSS.removeClass(dn, 'center');
                            }
                        }
                        
                        lstPg = $M.floor(this.lastSelected/this.numVisibleDots);
                        curPg = $M.floor(idx/this.numVisibleDots);
                        
                        if(lstPg !== curPg) {
                            transitTo(dn, -curPg * dts * DOT_INTERVAL);
                        } 
                        this.lastSelected = idx;
                    }
                }
            }],
            
            
            updateScrollerConfig: function updateScrollerConfig() {
                var len = this.viewer.items.length;
                mstrmojo.hash.copy({
                    scrollEl: this.viewerNode,
                    origin: {x: 0, y: 0},
                    offset: {
                        x: {
                            start: 0,
                            end: ((len > 0) ? (len - 1) : 0) * getDimension.call(this, 'Width')
                        }    
                    }
                }, this.scrollerConfig);
                return this._super();
            },
            
            touchSwipeEnd: function touchSwipeEnd(touch) {
                var delta = touch.delta,
                    len = this.viewer.items.length;
                
                
                if(delta && delta.x > 0) {
                    this.set('selected', Math.max(0, this.selected - 1));
                } else if(delta && delta.x < 0) {
                    this.set('selected', Math.min(this.selected + 1, len));
                }
            },
            
            
            
            onclick: function(e) {
                var dlgCfg;
                
                if(mstrApp.getScreenDimensions && this.selectedImage) {
                    dlgCfg = {
                            cssClass: 'image-FullScreen',
                            onclick: function() { this.close(); },
                            
                            resizeDialog: function() {
                                var d = mstrApp.getScreenDimensions(),
                                    dm = this.domNode,
                                    ds = dm && dm.style;
                                if(d && ds) {
                                    ds.width = d.w + 'px';
                                    ds.height = d.h + 'px';
                                }
                            },
                            
                            children:[{
                                scriptClass: 'mstrmojo.Image',
                                src: this.selectedImage,
                                onload: function() {
                                    var d = mstrApp.getScreenDimensions();
                                    if(d) {
                                        
                                        
                                        resizeImage(this.imgNode, d.w, d.h);
                                        
                                        
                                        this.parent.positionDialog();
                                    }
                                }
                            }]};
                    mstrApp.showDialog(dlgCfg);
                }
            },
            
            touchTap: function(e) {
                this.onclick(e);
            },
            
            preBuildRendering: function preBuildRendering() {
                var dp = this.getDataParser(),
                    headers = getHeadersByColumn(dp),
                    imgs, desc;
                
                
                if(!this.vp) {
                    this.vp = this.model.vp;
                }
                
                imgs = headers[0] || []; 
                desc = headers[1] || []; 
                this.viewer.set('items', imgs);
                
                this.sb.set('items', desc);
                this.selected = -1;
                
                
                if(imgs.length > 0) {
                    this.cssClass = this.cssClass ? '' : this.cssClass.replace(/noImage/, '');
                    this.noImageMsg = '';
                } else {
                    this.cssClass += this.cssClass ? '' : ' noImage';
                    this.noImageMsg = 'No Photo Found';
                }
                
                
                if(this.vp && this.vp.bgc) {
                    this.cssText = 'background-color:#' + this.vp.bgc + ';';
                }
                
                this._super();
            },
            
            postBuildRendering: function postBuildRendering() {
                this._super();
                
                
                this.set('selected', 0);
            },
            
            
            onselectedChange: function onselectedChange() {
                var idx = this.selected, 
                    s = this.sb,
                    img = this.viewer.items[idx],
                    desc = s.items[idx];
                
                
                if(img) {
                    
                    this._scroller.scrollTo(idx * getDimension.call(this, 'Width'), 0, 500);
                    
                    this.selectedImage = getImagePath( (img && img.n) || '');
                    
                    
                    s.select(idx);
                    
                    
                    this.description.set('text', (desc && desc.n) || '');
                }
            }
            
            
        });
}());
(function() {

	mstrmojo.requiresCls("mstrmojo.Vis",
						 "mstrmojo.dom",
						 "mstrmojo.VisHeatMapColorTheme",
						 "mstrmojo.VisHeatMapPopup",
						 "mstrmojo.VisHeatMapTree",
						 "mstrmojo._TouchGestures",
						 "mstrmojo._HasTouchScroller",
						 "mstrmojo.num",
						 "mstrmojo._HasWaitIcon",
						 "mstrmojo.EnumReadystate",
						 "mstrmojo.css",
						 "mstrmojo.VisHeatMapCanvas"
						 );

	var $READYSTATE = mstrmojo.EnumReadystate;
	var DRILLING_ACTION = 1,
		SELECTOR_ACTION = 2,
		HYPERLINK_ACTION = 4,
		INFOWINDOW_ACTION = 4;
	var $CSS = mstrmojo.css,
		cssShow = "heatmap-show";
	var LabelSize = {
		On : 0,
		Off : 1,
		Proportional : 2
	};
	var AggregationType = {
		Sum : 0,
		Avg : 1,
		Cnt : 2,
		Max : 3,
		Min : 4,
		GeoAvg : 5
	};
	var BandDirection = {
		LeftToRight : 0,
		RightToLeft : 1,
		Center : 2,
		None : 3
	};
	var LayoutAlgorithm = {
		Squarified : 0,
		PivotByMiddle : 1,
		SliceAndDice : 2
	};

	var LayoutProperties = {
		Padding : 6,
		MaxLegendHeight : 60,
		LegendMenuEditorWidth: 70,
		LegendTickCount: 5,
		LegendMinWidth: 15,
		LegendTickLength: 4,
		LegendMaxBandWidth: 400,
		LegendWidthPercent: 0.9,
		LegendMinPadding: 15,
		LegendBottomPadding: 3,
		LegendGutter: 5,
		LegendBandAspect: 10,
		MinShowLabelDimension: 6,
        DeletedListHeight: 500,
        EditorDialogWidth: 565,
        EditorDialogHeight: 574,
        EditButtonWidth: 60,
        EditButtonHeight: 40,
        EditButtonRight: 10,
        
        WaitIconWidth: 205,
        WaitIconHeight: 105,
        WaitIconMargin: 10,
        WaitIconFontSize: 20
	};

    var Spec = {
            heatmap_popup_panel_title: {
                    font_size: {value: 18, unit: 'pt'}
            },
            heatmap_gray_label: {
                    padding_bottom: { value: 7, unit: 'px' },
                    font_size: { value:10, unit: 'pt' },
                    height: { value: 32, unit: 'px' },
                    padding_left: {value: 22, unit: 'px' }
            },

            
            heatmap_tree_button: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_one_level_1: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_multi_level_1: {
                    font_size: {value: 24, unit: 'pt'}
            },
            heatmap_two_level_2: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_multi_level_2: {
                    font_size: {value: 20, unit: 'pt'}
            },
            heatmap_multi_level_3: {
                    font_size: {value: 10, unit: 'pt'}
            },
            heatmap_size_legend: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_color_legend: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_color_legend_label: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_color_legend_tooltip: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_color_legend: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_editor_button: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_tooltip_gray_bold: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_tooltip_gray: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_tooltip_black_bold: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_tooltip_black: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_tree_div: {
                    font_size: {value: 18, unit: 'pt'}
            },
            heatmap_tree_root__heatmap_tree_div: {
                    font_size: {value: 14, unit: 'pt'}
            }
    };





	var Fake_Metric_ID = "--";
	var Background_Color = 0xF5F5F7;
	var EID_SELECTALL = "OA:(All)";
	function adjustPixel(px,forceFix){
            var DPIX = 149,
                base = 160;
            if(forceFix){
                    base = 149;
            }
            if(this.enableMultiDPI || forceFix){
                    DPIX = this.DPIX;
            }
            return parseInt(px*(DPIX/base));
	}

	

	

	function getCSSColor(rgb) {
		var c = 0x1000000 + rgb;
		var str = '#' + c.toString(16).substring(1).toUpperCase();
		return str;
	}
	function roundNumber(n, l) { 
		return Math.round(n*Math.pow(10,l))/Math.pow(10,l);
	}
	function createPath(x, y, w, h, r, ctx) {
		ctx.beginPath();
	    ctx.moveTo(x + r, y);
	    ctx.lineTo(x + w - r - 1, y);
	    ctx.quadraticCurveTo(x + w - 1, y, x + w - 1, y + r);
	    ctx.lineTo(x + w - 1, y + h - r - 1);
	    ctx.quadraticCurveTo(x + w - 1, y + h - 1, x + w - r - 1, y + h - 1);
	    ctx.lineTo(x + r, y + h - 1);
	    ctx.quadraticCurveTo(x, y + h - 1, x, y + h - r - 1);
	    ctx.lineTo(x, y + r);
	    ctx.quadraticCurveTo(x, y, x + r, y);
	    ctx.closePath();
	}


	function updateEntityAggValue(ev, rawValue, needsCopy) {
		if (needsCopy && ev.total === undefined) {
			ev.avgTotal = ev.total = ev.geomProduct = ev.max = ev.min = ev.value;
			ev.count = isNaN(ev.value) ? 0 : 1;
			ev.positiveCount = ev.value > 0 ? 1 : 0;
		}
		ev.value = rawValue;
		ev.allChildrenCount++;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.total)) {
				ev.total = rawValue;
			} else {
				ev.total += rawValue;
			}
			if (isNaN(ev.avgTotal)) {
				ev.avgTotal = rawValue;
			} else {
				ev.avgTotal += rawValue;
			}
			if (isNaN(ev.max)) {
				ev.max = rawValue;
			} else {
				ev.max = Math.max(ev.max, rawValue);
			}
			if (isNaN(ev.min)) {
				ev.min = rawValue;
			} else {
				ev.min = Math.min(ev.min, rawValue);
			}
			if (isNaN(ev.geomProduct)) {
				if (rawValue > 0) {
					ev.geomProduct = rawValue;
					ev.positiveCount++;
				}
			} else {
				if (rawValue > 0) {
					ev.geomProduct *= rawValue;
					ev.positiveCount++;
				}
			}
			ev.count++;
		}
	}
	function updateEntityContainerAggValue(ev, oldev) {
		var rawValue = oldev.total;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.total)) {
				ev.total = rawValue;
			} else {
				ev.total += rawValue;
			}
			ev.count++;
		}
		rawValue = oldev.avg;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.avgTotal)) {
				ev.avgTotal = rawValue;
			} else {
				ev.avgTotal += rawValue;
			}
		}
		rawValue = oldev.max;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.max)) {
				ev.max = rawValue;
			} else {
				ev.max = Math.max(ev.max, rawValue);
			}
		}
		rawValue = oldev.min;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.min)) {
				ev.min = rawValue;
			} else {
				ev.min = Math.min(ev.min, rawValue);
			}
		}
		rawValue = oldev.geomAvg;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.geomProduct)) {
				if (rawValue > 0) {
					ev.geomProduct = rawValue;
					ev.positiveCount++;
				}
			} else {
				if (rawValue > 0) {
					ev.geomProduct *= rawValue;
					ev.positiveCount++;
				}
			}
		}
	}
	function decodeXML(s){
		return s.replace(/&lt;/g, "<"
			   ).replace(/&gt;/g, ">"
			   ).replace(/&quot;/g,"\"");
			   
	}

	var delStatus = {
			dftUnDel: 0, 
			dftDel: 1, 
			usrDel: 2 
	};

	function parseDeletedList(s){
		var oParser = new DOMParser(),
			oDOM = oParser.parseFromString(decodeXML(s), "text/xml"),
			i = 0,
			ce = oDOM.childNodes[0], 
			l = oDOM.childNodes[0].childElementCount; 
		if(l == 0) return {};
		var	cr = ce.firstElementChild,
			at = cr.attributes,
			al = at.length,
			ret = this.props.deletedList || {},
			dict = ret,
			key;
		while (i < l) {
			dict = ret;
			at = cr.attributes;
			for (var j = 0; j < al; j++) {
				key = at[j].value;
				if (j === (al - 1)) {
					dict[key] = delStatus.dftDel; 
				} else {
					if (!dict[key]) {
						dict[key] = {};
					}
					dict = dict[key];
				}
			}
			i++;
			cr = cr.nextElementSibling;
		}
		return ret;
	}

    function loadSession() {
            var props = this.props,
                session = this.controller.view.model.session;
            if(session) {
                    
                    if(session.db !== undefined) {
                            props.delButtonEnabled = session.db;
                    }
                    
                    if(session.dl !== undefined) {
                            props.deletedList = mergeDeletedList(props.deletedList, session.dl);
                    }
                    
                    if(session.ps != undefined) {
                            this.previousSelected = lookUpSelectionDic.call(this, session.ps);
                    }

                    this.isUsingSavedColorTheme = session.isUsingSavedColorTheme;
                    this.isUsingDefaultColorTheme = session.isUsingDefaultColorTheme;
            }

            function lookUpSelectionDic(sd) {
                    var root = this.root;
                    for(var i = 0, len = sd.length; i < len; i++) {
                            var children = root.entityChildren;
                            for(var j = 0, l = children.length; j < l; j++){
                                    var ret = null;
                                    if(this.getEntityDisplayName(children[j]) === sd[i]){
                                            ret = children[j];
                                            root = ret;
                                            break;
                                    }
                            }
                    }
                    return ret;
            }

            function mergeDeletedList(d1, d2) {
                    
                    function merge(a, b) {
                            var keys = Object.keys(b),
                                len = keys.length;
                            for(var i = 0; i < len; i++) {
                                    var key = keys[i];
                                    if(typeof b[key] !== 'object') {
                                            a[key] = b[key];
                                    }else {
                                            if(a[key] === undefined) {
                                                    a[key] = {};
                                            }
                                            merge(a[key], b[key]);
                                    }
                            }
                    }
                    var ret = {};
                    merge(ret, d1);
                    merge(ret, d2);
                    return ret;
            }
    }

    function storeSession() {
            var cvm = this.controller.view.model,
                session = {},
                props = this.props;
            cvm.session = session;
            if(props.delButtonEnabled !== undefined) {
                    session.db = props.delButtonEnabled;
            }
            if(props.deletedList !== undefined) {
                    session.dl = props.deletedList;
            }
            if(this.previousSelected) {
                    session.ps = generateSelectionDic.call(this, this.previousSelected);
            }

            session.isUsingSavedColorTheme = this.isUsingSavedColorTheme;
            session.isUsingDefaultColorTheme = this.isUsingDefaultColorTheme;

            function generateSelectionDic(entity) {
                    var sd = [];
                    while(entity.parent){
                            sd.push(this.getEntityDisplayName(entity));
                            entity = entity.parent;
                    }
                    return sd;
            }
    }



	function loadProps() {
		this.props = {};
		var props = this.props,
			m = this.model,
			propValue = m.vp? m.vp : {},
			temp;
		
        props.deletedList = {};
		props.delButtonEnabled = false;
		props.showMetricValues = false;
		props.refreshType = 0;
		props.labelSize = LabelSize.On;
		props.showLegend = true;

		props.sizeMetricEnabled = true;
		props.colorMetricEnabled = true;
		props.layout = LayoutAlgorithm.Squarified;
		props.legendAsc = true;

		var w = mstrmojo.VisHeatMapColorTheme.newInstance();
		w.initialize();
		this.colorTheme = w;

		if(propValue.dl){
			props.deletedList = parseDeletedList.call(this, propValue.dl);
		}
		if(propValue.ed){
			props.delButtonEnabled = (propValue.ed == "true" ? true:false);
		}
		if(propValue.mv){
			props.showMetricValues = (propValue.mv == "true" ? true:false);
		}
		if(propValue.rt != ""){
			props.refreshType = parseInt(propValue.rt);
		}
		if(propValue.ml){
			temp = propValue.ml.split(',');
			if(temp.length >= 2){
				props.sizeMetricID = temp[0];
				props.colorMetricID = temp[1];
			}
		}
		if(propValue.lb){
			temp = propValue.lb;
			if(temp == "Off"){
				props.labelSize = LabelSize.Off;
			}else if(temp == "Proportional"){
				props.labelSize = LabelSize.Proportional;
			}
		}
		if(propValue.lg){
			props.showLegend = (propValue.lg == "true" ? true:false);
		}
		if(propValue.rlp == "false" && propValue.abs)
			w.convertAbsoluteToBlend(this,propValue);

		if(propValue.blc){
			w.isBlend = (propValue.blc == "true" ? true:false);
		}
		if(propValue.gradientColors && propValue.bandColors){
			w.createDataProviderFromString(propValue.gradientColors, propValue.bandColors);
		}
		
		if(propValue.la){
			props.layout = parseInt(propValue.la, 10);
		}
        
        if(propValue.rlp == "false" && propValue.abs){
                this.colorTheme.convertAbsoluteToBlend(this,propValue);
                this.colorTheme.createDataProviderFromString(propValue.gradientColors, propValue.bandColors);
        }

	}

    function setLayout(){
		var widgetWidth = parseInt(this.width, 10),
			widgetHeight = parseInt(this.height, 10),
			heatMapWidth = widgetWidth - 2*this.LayoutProperties.Padding,
			legendHeight = 0, heatMapHeight;
		
		if(this.model.gvs.items.length <= 0)
			this.props.showLegend = false;
		if(this.props.showLegend){
                legendHeight = Math.min(Math.floor(0.2*(widgetHeight-2*this.LayoutProperties.Padding)), this.LayoutProperties.MaxLegendHeight);
                heatMapHeight = widgetHeight - legendHeight - 3*this.LayoutProperties.Padding;
        }else
                heatMapHeight = widgetHeight - 2*this.LayoutProperties.Padding;
		this.heatMapSize = {
				x : 0,
				y : 0,
				w : heatMapWidth,
				h : heatMapHeight
		};
        this.legendSize = {
                x : 0,
                y : widgetHeight - 2*this.LayoutProperties.Padding - legendHeight,
                w : widgetWidth,
                h : legendHeight
        };
        this.infoWindowSize = {
                maxWidth : parseInt(this.width) - 60,
                maxHeight : parseInt(this.height) - 60
        };

        
        this.maxScale = 10;
		
		
        
        
    }
	function resetMetricIndices() {
		
		var m = this.model,
			l = m.ghs.chs.items[0] ? m.ghs.chs.items[0].items.length:0,
			sid = this.props.sizeMetricID,
			cid = this.props.colorMetricID,
			a = [];
		this.metricArray = a;
		for(var i = 0; i < l; i++){
			a.push(getMetricID.call(this, i));
		}
		a.push(Fake_Metric_ID);
		l++;

		
		this.sizeMetricIndex = 0;
		this.colorMetricIndex = l>2 ? 1:0;
		
			
		
			
		
		
		
		for(var i = 0; i < l; i++){
			if(sid == a[i]){
				this.sizeMetricIndex = i;
			}
			if(cid == a[i]){
				this.colorMetricIndex = i;
			}
		}
		
		if(sid === undefined){
			
				
				
					
					
				
			sid = a[this.sizeMetricIndex];
			this.props.sizeMetricID = sid;
		}

		if(cid === undefined){
			
				
				
					
					
				
			cid = a[this.colorMetricIndex];
			this.props.colorMetricID = cid;
		}

        var gvs = m.gvs && m.gvs.items,
            lgvs = gvs && gvs.length,
            i,
            sidx = this.sizeMetricIndex,
            cidx = this.colorMetricIndex;
        this.sizeByMetricMissing = true;
        this.colorByMetricMissing = true;
        for(i = 0; i < lgvs; i++) {
            var values = gvs[i] && gvs[i].items;
            if(values[sidx] === undefined || values[sidx].rv !== '') {
                this.sizeByMetricMissing = false;
                break;
            }
        }
        for(i = 0; i < lgvs; i++) {
            var values = gvs[i] && gvs[i].items;
            if(values[cidx] === undefined || values[cidx].rv !== '') {
                this.colorByMetricMissing = false;
                break;
            }
        }

        if(this.sizeByMetricMissing) {
            this.props.sizeMetricEnabled = false;
            this.sizeMetricIndex = a.length -1;
            this.props.sizeMetricID = a[this.sizeMetricIndex];
        }
        if(this.colorByMetricMissing) {
            this.props.colorMetricEnabled = false;
        }

		if(this.props.sizeMetricID === Fake_Metric_ID)
			this.props.sizeMetricEnabled = false;
		if(this.props.colorMetricID === Fake_Metric_ID){
			this.props.colorMetricEnabled = false;
            this.colorTheme.hasNoColorMetric = true;
        }

		if(this.props.sizeMetricEnabled == false && this.props.colorMetricEnabled == false)
			this.props.showLegend = false;

	}
	function loadMetricsInfo(){
		this.aggFunctions = [];
		var props = this.props,
			cid = props.colorMetricID,
			af = this.aggFunctions,
			m = this.model,
			propValue = m.vp? m.vp : {},
			ar = this.metricArray,
			l = ar.length - 1;
		
		if(cid != Fake_Metric_ID){
			var mlEnabled = (propValue["mle"+cid] == "true") ? true : false;
			if(mlEnabled){
				var val = parseFloat(propValue["mlma"+cid]);
				if(!isNaN(val)){
					this.mlmax = val;
				}
				val = parseFloat(propValue["mlmi"+cid]);
				if(!isNaN(val)){
					this.mlmin = val;
				}
			}
		}
		
		for(var i = 0; i < l; i++){
			var id = "agf" + ar[i];
			if(propValue[id] !== undefined){
				af.push(parseInt(propValue[id]));
			}else{
				af.push(AggregationType.Sum);
			}
		}
	}
	function totalRow(row){
		for(var i = 0; i < row.length; i++){
			var obj = row[i].etk;
			if(obj == -1 || obj == "-1"){
				return true;
			}
		}
		return false;
	}

    function convertDataToModels() {
            resetMetricIndices.call(this);
            loadMetricsInfo.call(this);
            var m = this.model,
            deletedList = this.props.deletedList,
            att = m.gts.row, 
            atl = att.length, 
            mv = m.gvs.items, 
            
            rl = m.ghs.rhs? m.ghs.rhs.items.length : 0;
            ml = mv[0] ? mv[0].items.length:0, 
            rhs = m.ghs.rhs.items;


            if(atl <= 0){
                    var errmsg = "The Heat Map requires at least one attribute on row axis to render properly; it is recommended that two metrics be placed on the column axis as well.";

                    m.err = mstrmojo.desc(11147, errmsg);
                    return ;
            }
            this.singleSelection = false;
            this.hasNegativeSizeValue = false;

            this.levelAttributes = [];
            
            
            this.root = {
                    aggValues : [],
                    entityChildren : [],
                    level : 0
            };
            
            for ( var i = 0; i < atl; i++) {
                    this.levelAttributes[i] = {
                            index : i,
                            order : i + 1,
                            isInLOA : i + 1 > 0 ? true : false
                    }
            }
            var hashDict = {},
            attSpan = [];
            
            for(var i = 0; i < atl; i++){
                    var o = att[i].fs;
                    attSpan[i] = Math.max(1, o ? o.length: 1);
            }
            this.attSpan = attSpan;

            var isAllSelectable = true,
                lastSerialRowIndex,
                serialEntity,
                highestLevelEntity,
                highestLevelIndex;

            
            for (var i = 0; i < rl; i++) { 
                    var attributeArray = [],
                    rowHeaderData = rhs[i].items,
                    k;
                    if(totalRow(rowHeaderData)) continue;

                    
                    var levelID = "",
                        delDict = deletedList,
                        parent = this.root,
                        cur = 0,
                        entity,
                        str,
                        serialEndIndex = -1;
                    for (var j = 0; j < atl; j++) {
                            var index,
                                newEntity;
                            str = "";
                            for(var k = 0; k < attSpan[j]; k++, cur++){
                                    index = rowHeaderData[cur].idx;
                                    if(index == -1)
                                            continue;
                                    str += att[j].es[index].n + " ";
                                    if(k == 0){
                                            levelID += index;
                                    }
                            }
                            str = str.substring(0, str.length-1);
                            if (delDict) {
                                    delDict = delDict[decodeXML(str)];
                            }
                            
                            if(j != atl -1){
                                    if (hashDict[levelID] !== undefined) {
                                            parent = hashDict[levelID];
                                    } else {
                                            var entityContainer = {
                                                    aggValues : [],
                                                    entityChildren : [],
                                                    parentEntity : parent
                                            };
                                            var childrenArray = parent.entityChildren;
                                            childrenArray.push(entityContainer);
                                            hashDict[levelID] = entityContainer;
                                            parent = entityContainer;
                                            entityContainer["deleted"] = false;
                                            entityContainer["text"] = str;
                                            entityContainer["label"] = str;
                                            entityContainer["level"] = j;
                                            entityContainer["index"] = i;
                                    }
                                    levelID += ":";
                                    newEntity = entityContainer;
                            }else { 
                                    if (hashDict[levelID] !== undefined) {
                                            entity = hashDict[levelID];
                                            var indice = entity.indices;
                                            indice.push(i);
                                            for ( var k = 0; k < ml + 1; k++) {
                                                    var ev = entity.aggValues[k];
                                                    var rawValue;
                                                    
                                                    if (k == ml) {
                                                            rawValue = 1.0;
                                                    } else {
                                                            rawValue = mv[i].items[k].rv;
                                                    }
                                                    updateEntityAggValue(ev, parseFloat(rawValue), true);
                                                    if (!isNaN(rawValue)) {
                                                            this.aggregated = true;
                                                    }
                                            }
                                    } else {
                                            entity = {
                                                    indices : [],
                                                    aggValues : [],
                                                    parentEntity : parent
                                            };
                                            var indice = entity.indices;
                                            indice.push(i);
                                            var aggValues = entity.aggValues;
                                            for (var k = 0; k < ml + 1; k++) {
                                                    var ev = {};
                                                    aggValues[k] = ev;
                                                    var rawValue;
                                                    
                                                    if (k == ml) {
                                                            rawValue = 1.0;
                                                    } else {
                                                            rawValue = mv[i].items[k].rv;
                                                    }
                                                    
                                                    ev.value = parseFloat(rawValue);
                                                    ev.allChildrenCount = 1;
                                            }
                                            this.aggregated = false;
                                            
                                            if (delDict) { 
                                                    entity["deleted"] = true;
                                                    this.colorTheme.useDefault = false;
                                            }
                                            
                                            var childrenArray = parent.entityChildren;
                                            childrenArray.push(entity);
                                            entity["level"] = atl - 1;
                                            entity["text"] = str;
                                            entity["label"] = str;
                                            hashDict[levelID] = entity;
                                            
                                            
                                            
                                            
                                            
                                    }
                                    newEntity = entity;
                            }
                            
                            if(rowHeaderData[j].cet != undefined){
                                    if(j - serialEndIndex != 1 || (!isNaN(lastSerialRowIndex) && lastSerialRowIndex != i))
                                            isAllSelectable = false;
                                    if(isAllSelectable){
                                            serialEntity = newEntity;
                                            serialEndIndex = j;
                                            lastSerialRowIndex = i;
                                    }
                                    if(isNaN(highestLevelIndex) || highestLevelIndex < j){
                                            highestLevelIndex = j;
                                            highestLevelEntity = newEntity;
                                    }
                            }
                    }

            }
            if(isAllSelectable)
                    this.previousSelected = serialEntity;
            else
                    this.previousSelected = highestLevelEntity;
            
            
            
            checkSelector.call(this);
            checkLinkDrill.call(this);
    }

	function clearMaxMinValues(){
		this.cmax = NaN;
		this.cmin = NaN;
		this.smax = NaN;
		this.smin = NaN;
	}

	function checkLinkDrill(){
			this.hasLinkDrill = false;
			
			var rowHeader = this.model.gts.row,
			rl = rowHeader.length;
			for(var i = 0; i < rl; i++){
					var attr = rowHeader[i];
					if(attr.lm){
							for(var j = 0; j < attr.lm.length; j++)
									if(attr.lm[j].links)break;
							if(j != attr.lm.length){
									this.hasLinkDrill = true;
									this.firstRowLinkDrillIndex = i;
									break;
							}
					}
			}

			
			var metricH = this.model.gts.col[0];
            if(!metricH)
                    return;
            var metricHL = metricH.es.length;
			for(var i = 0; i < metricHL; i++){
					var metric = metricH.es[i],
						lm = metricH.lm[i];
					if(lm && lm.links){
						this.hasLinkDrill = true;
						this.firstColLinkDrillIndex = i;
						break;
					}
			}
	}
	function checkSelector(){
		this.hasSelector = false;
		var m = this.model,
			rown = m.gts.row, 
			rl = rown.length;
        var xtabModel = this.xtabModel,
            docModel = (xtabModel && xtabModel.docModel),
            layouts = (docModel && docModel.defn && docModel.defn.layouts),
            currentLayout;
        for(var i = 0; layouts && i < layouts.length; i++){
                if(layouts[i].loaded == true){
                        currentLayout = layouts[i];
                        break;
                }
        }

        var units =  (currentLayout && currentLayout.units);

		for(var i = 0; i < rl; i++){
			var att = rown[i];
            if(att.otp != -1 && att.sc !== undefined){
                    this.hasSelector = true;
                    
                    var targets = att.sc.tks;
                    if(typeof targets != 'string')
                            continue;
                    targets = targets.split('\x1E');

                    var len = targets.length;
                    this.hasGridTarget = false;
                    for(var j = 0; j < len; j++){
                            if(targets[j] == '')
                                    continue;
                            targetName = targets[j];
                            if(units && units[targetName] && !units[targetName]['ifw']){
                                    this.hasGridTarget = true;
                                    return ;
                            }
                    }
            }
		}
      
      
      
              
	}

	function layoutEntities() {
		var width = this.width - 2*this.LayoutProperties.Padding;
		var legendHeight = 0;
		if(this.props.showLegend){
			legendHeight = Math.min(Math.floor(0.2*(parseInt(this.height)-2*this.LayoutProperties.Padding)), this.LayoutProperties.MaxLegendHeight);
		}
		var hm = this,
			area = copyRect(this.heatMapSize);
		area.w *= this.scaleFactor;
		area.h *= this.scaleFactor;
		var min = Math.min(area.w, area.h);
		var ch = this.root.entityChildren;
		switch (this.props.layout) {
		case LayoutAlgorithm.Squarified:
			var arr = ch.slice(0);
			arr.sort(function sortEntity(s, t) {
				var vs = getSizeValue(s, hm);
				var vt = getSizeValue(t, hm);
				if (isNaN(vs)) {
					if (isNaN(vt))
						return 0;
					return 1;
				} else {
					if (isNaN(vt))
						return -1;
					return vs < vt ? 1 : -1;
				}
				return 0;
			});
			squarify.call(this, arr, {
				r : []
			}, min, area);
			break;
		case LayoutAlgorithm.SliceAndDice:
			sliceAndDice.call(this, ch, area);
			break;
		case LayoutAlgorithm.PivotByMiddle:
			var arr = getVisibleEntities.call(this, ch), l = arr.length;
			if (l > 0) {
				pivotByMiddle.call(this, arr, 0, l - 1, area);
			}
			break;
		}
	}
	
	
	
	
	function squarify(t, r, m, c, a) {
		var newRow = false;
		if (t.length == 0) {
			setLayoutOrder.call(this, r, c);
		} else {
			var area = c.w * c.h;
			var cwa;
			if (a !== undefined) {
				cwa = a;
			} else {
				cwa = worstAspect.call(this, r, m, area);
															
			}

			var data = t[0], arr = r.r;
			arr.push(data);

			var fwa = worstAspect.call(this, r, m, area); 
															
			if (cwa >= fwa || cwa == -1) {
				t.shift();
				squarify.call(this, t, r, m, c, fwa);
			} else {
				r.r.pop();
				setLayoutOrder.call(this, r, c);
				m = Math.min(c.w, c.h);
				if (r.t === undefined) {
					squarify.call(this, t, {
						r : []
					}, m, c);
				} else {
					squarify.call(this, t, {
						r : [],
						t : r.t
					}, m, c);
				}
			}
		}
	}

	function getTextStyle(l, w) {
		var fs, css, len = w.levelAttributes.length;
		if(len == 1){
			if(l == 0){
				css  = "heatmap-one-level-1";
                fs = this.Spec.heatmap_one_level_1.font_size.value;
				
			}
		}
		else if (len == 2) {
			if(l == 0){
				css = "heatmap-multi-level-1";
                fs = this.Spec.heatmap_multi_level_1.font_size.value;
				
			}else if(l == 1){
				css = "heatmap-two-level-2";
                fs = this.Spec.heatmap_two_level_2.font_size.value;
				
			}
		}
		else if (len >= 3) {
			if(l == 0){
				css = "heatmap-multi-level-1";
                fs = this.Spec.heatmap_multi_level_1.font_size.value;
				
			}else if(l == 1){
				css = "heatmap-multi-level-2";
                fs = this.Spec.heatmap_multi_level_2.font_size.value;
				
			}else{
				css = "heatmap-multi-level-3";
                fs = this.Spec.heatmap_multi_level_3.font_size.value;
				
			}
		}
		return {css:css, size:fs};
	}
	function getRectangleGap(e) {
			var getGapPixel = function(){
					var te = e, level = e.level,
					l = this.levelAttributes.length;
					if (l == 1)
							return 1;
					
							
							
							
									
									
									
									if (l == 2) {
											if (level == 0)
													return 3;
											return 1;
									}
									if (l == 3) {
											if (level == 0)
													return 6;
											if (level == 1)
													return 3;
											return 1;
									} else {
											if (level == 0)
													return 8;
											if (level == 1)
													return 4;
											if (level == 2)
													return 2;
											return 1;
									}
			};
			var ret,
                gap = getGapPixel.call(this);
            if(this.DPI > 160)
                    ret = adjustPixel.call(this,gap);
            else
                    ret = gap;
            if(ret <= 0)
                    ret = 1;
            return ret;

	}

	function rectIsValid(a){
		return a.w > 0 && a.h > 0;
	}

	function rectIntersection(a, b) {
		var x = Math.max(a.x, b.x);
		var y = Math.max(a.y, b.y);
		var w = Math.min(a.x + a.w, b.x + b.w) - x;
		var h = Math.min(a.y + a.h, b.y + b.h) - y;
		if (w < 0 || h < 0) {
			return {
				x : NaN,
				y : NaN,
				w : NaN,
				h : NaN
			};
		}
		return {
			x : x,
			y : y,
			w : w,
			h : h
		};
	}

    function rectIsEqual(a ,b) {
            if(a.x == b.x && a.y == b.y && a.w == b.w && a.h == b.h)
                    return true;
            else
                    return false;
    }

    
    function rectCanEncircle(a, b) {
            var c = rectIntersection(a, b);
            return rectIsEqual(c,b);
    }

    
    function rectPutAside(a, b, c) {
            var p = [{x: b.x - a.w, y: b.y + b.h/2 - a.h/2, w:a.w, h:a.h},
                     {x: b.x + b.w, y: b.y + b.h/2 - a.h/2, w:a.w, h:a.h},
                     {x: b.x + b.w/2 - a.w/2, y: b.y - a.h, w:a.w, h:a.h},
                     {x: b.x + b.w/2 - a.w/2, y: b.y + b.h, w:a.w, h:a.h}];
            for(var i = 0; i < 4; i++){
                    if(rectCanEncircle(c, p[i]))
                            return {rect:p[i], index:i};
            }
    }

	function swapRect(a) {
		var temp = a.x;
		a.x = a.y;
		a.y = temp;
		temp = a.w;
		a.w = a.h;
		a.h = temp;
		return a;
	}
	function copyRect(a) {
		var b = {};
		b.x = a.x;
		b.y = a.y;
		b.w = a.w;
		b.h = a.h;
		return b;
	}

	function worstAspect(r, m, a) {
		var worst, arr = r.r, l = arr.length;
		if (l > 0 && a > 0) {
			var e = arr[0];
			var pval = getSizeValue(e.parentEntity, this);
			if (isNaN(pval) || pval <= 0) {
				return -1;
			}
			var min, max, sum = 0, val, e, inited = false;
			for ( var i = 0; i < l; i++) {
				e = arr[i];
				if (!e.deleted) {
					val = getSizeValue(e, this);
					if (!isNaN(val)) {
						if (inited == false) {
							max = min = val;
							inited = true;
						} else {
							max = Math.max(val, max);
							min = Math.min(val, min);
						}
						sum += val;
					}
				}
			}
			var suba = a * sum / pval, otherMin = suba / m, newMin = (m < otherMin) ? m
					: otherMin;
			max = a * max / pval;
			min = a * min / pval;
			var e1 = max / (newMin * newMin);
			var e2 = min / (newMin * newMin);
			e1 = (e1 > 1) ? e1 : (1 / e1);
			e2 = (e2 > 1) ? e2 : (1 / e2);
			worst = Math.max(e1, e2);
		} else {
			worst = -1;
		}
		return worst;
	}

	function layoutRow(r, c, n, sum, swapped) {
		var width, height, ch = r.r, l = ch.length, w, h, tmpc, localSwapped = false;
		if (l == 0)
			return;
		if (n < c.h) {
			w = n;
			h = c.h;
			tmpc = c;
		} else {
			w = c.h;
			h = n;
			var tmpc = copyRect(c);
			swapRect(tmpc);
			localSwapped = true;
		}
		var x = tmpc.x, y = tmpc.y, bound = {
			x : x,
			y : y,
			w : w,
			h : h
		};
		var gap = getRectangleGap.call(this, ch[0]);

		for ( var i = 0; i < l; i++) {
			var e, rect, minDim;
			e = ch[i];
			if (e.deleted) {
				if ((swapped == true && localSwapped != true)
						|| (swapped == false && localSwapped == true)) {
					e.size = {
						x : y,
						y : x,
						w : 0,
						h : 0
					};
				} else {
					e.size = {
						x : x,
						y : y,
						w : 0,
						h : 0
					};
				}
				continue;
			}
			var value = getSizeValue(e, this);
			height = (sum <= 0 || e.deleted) ? 0 : Math.ceil(h * value / sum);
			width = w;
			if (e.entityChildren !== undefined) {
				if (value < sum) {
					if (i == 0) {
						if (gap > 1) {
							height -= (gap>>1);
						} else {
							height--;
						}
					} else if (i < l - 1) {
						if (gap > 1) {
							height -= gap;
						} else {
							height--;
						}
					} else {
						height = h + tmpc.y - y ;
					}
				}
				var nc = {
					x : x,
					y : y,
					w : width,
					h : height
				};
				rect = rectIntersection(nc, bound);
				if ((swapped == true && localSwapped != true)
						|| (swapped == false && localSwapped == true)) {
					swapRect(nc);
					swapRect(rect);
				}
				if(rectIsValid(rect)){
					e.size = rect;
				}
				else{
					e.size = {
						x : rect.x,
						y : rect.y,
						w : 0,
						h : 0
					};
				}
				minDim = Math.min(rect.w, rect.h);
				var hm = this;
				var arr = e.entityChildren.slice(0);
				arr.sort(function sortEntity(s, t) {
					var vs = getSizeValue(s, hm);
					var vt = getSizeValue(t, hm);
					if (isNaN(vs)) {
						if (isNaN(vt))
							return 0;
						return 1;
					} else {
						if (isNaN(vt))
							return -1;
						return vs < vt ? 1 : -1;
					}
					return 0;
				});
				squarify.call(this, arr, {
					r : []
				}, minDim, nc);
				y += height + gap;
			} else {
				if (value < sum) {
					if (i == 0 || i == l - 1) {
						if (gap > 1) {
							if (height > (gap>>1)) {
								height -= (gap>>1);
							}
						} else {
							if (height > 1) {
								height--;
							}
						}
					} else {
						if (height > gap) {
							height -= gap;
						}
					}
				}
				width = Math.max(0, width);
				height = Math.max(0, height);
				var rect = rectIntersection({
					x : x,
					y : y,
					w : width,
					h : height
				}, bound);
				rect.x = x;
				rect.y = y;
				y += height + gap;
				if (y >= tmpc.y + h) {
					rect.h = tmpc.y + h - rect.y;
				}
				if ((swapped == true && localSwapped != true)
						|| (swapped == false && localSwapped == true)) {
					rect = swapRect(rect);
				}
				if(rectIsValid(rect)){
					e.size = rect;
				}
				else{
					e.size = {
						x : rect.x,
						y : rect.y,
						w : 0,
						h : 0
					};
				}
			}
		}
	}

	function setLayoutOrder(r, c) {
		var sum = 0.0, arr = r.r, l = arr.length;
		if (l == 0)
			return;

		var ra, p = arr[0].parentEntity, ch = p.entityChildren, ll = ch.length;
		for ( var i = 0; i < l; i++) {
			var e = arr[i], v = getSizeValue(e, this);
			if (!e.deleted && v > 0) {
				sum += v;
			}
		}
		if (r.t === undefined) {
			var t = 0.0;
			for ( var i = 0; i < ll; i++) {
				var e = ch[i], v = getSizeValue(e, this);
				if (!e.deleted && v > 0) {
					t += v;
				}
			}
			r.t = t;
		}

		var e = arr[0], gap = getRectangleGap.call(this, e), bound = {
			x : 0,
			y : 0,
			w : 0,
			h : 0
		};

		if (e == this.root) {
			ra = this.heatMapSize.w * this.scaleFactor * this.heatMapSize.h * this.scaleFactor;
			bound.w = this.heatMapSize.w * this.scaleFactor;
			bound.h = this.heatMapSize.h * this.scaleFactor;
		} else {
			if (p == this.root) {
				ra = this.heatMapSize.w * this.scaleFactor * this.heatMapSize.h * this.scaleFactor;
				bound.w = this.heatMapSize.w * this.scaleFactor;
				bound.h = this.heatMapSize.h * this.scaleFactor;
			} else {
				var pSize = p.size;
				ra = pSize.w * pSize.h;
				bound = copyRect(pSize);
			}
			if (r.t == 0)
				ra = 0;
			else {
				ra *= sum / r.t;
			}
		}

		var aw = c.w, 
		ah = c.h, 
		swapped = false;
		if (c.h < c.w) {
		} else {
			swapped = true;
			swapRect(c);
			swapRect(bound);
			var temp = aw;
			aw = ah;
			ah = temp;
		}
		
		if ((bound.x < c.x) || (bound.x + bound.w > c.x + c.w)) {
			if (gap > 1) {
				aw += (gap>>1);
			}
		}
		
		if ((bound.y < c.y) || (bound.y + bound.h > c.y + c.h)) {
			if (gap > 1) {
				ah += (gap>>1);
			}
		}
		var width = ah == 0 ? 0 : Math.min(c.w, Math.ceil(ra / ah));
		if (sum < r.t && sum > 0) {
			if (c.x + width < bound.x + bound.w) {
				if (gap > 1) {
					width -= (gap>>1);
				} else {
					width--;
				}
			}
		}

		layoutRow.call(this, r, c, width, sum, swapped);

		var newX = c.x + width, newWidth = c.w - width;
		if (sum < r.t && sum > 0) {
			if (c.x + width < bound.x + bound.w) {
				if (gap > 1) {
					newX += gap;
					newWidth -= gap;
				} else {
					newX++;
					newWidth--;
				}
			}
		}
		c.x = newX;
		c.w = Math.max(0, newWidth);
		if (swapped) {
			swapRect(c);
		}
	}

	function getVisibleEntities(a) {
		if (a == null)
			return [];
		var arr = a.slice(0), total = 0, l = arr.length;
		arr.t = [];
		for ( var i = 0; i < l; i++) {
			var e = arr[i], val = getSizeValue(e, this);
			if (e.deleted || isNaN(val) || val <= 0) {
				arr.splice(i, 1);
				i--;
				l--;
				continue;
			}
			total += val;
			arr.t[i] = total;
		}
		return arr;
	}

	function pivotByMiddle(t, l, r, c) {
		var e = t[0], gap = getRectangleGap.call(this, e), lc, rc, 
																	
																	
																	
																	
																	
		lv, rv, lp, swapped = false, n = r - l + 1, pivot = (n > 2 ? ((n - 1)>>1)
				: (n>>1))
				+ l, cc;
		cc = copyRect(c);
		if (cc.w > cc.h) {
		} else {
			swapRect(cc);
			swapped = true;
		}
		lc = copyRect(cc);
		rc = copyRect(cc);
		
		if (l == r) {
			e = t[l];
			layoutEntityByMiddle.call(this, e, cc, swapped);
			return;
		}
		
		if (l + 1 == r) {
			e = t[l];
			lv = getSizeValue(e, this);
			e = t[r];
			rv = getSizeValue(e, this);
		} else {
			if (l == 0) {
				lv = t.t[pivot - 1];
			} else {
				lv = t.t[pivot - 1] - t.t[l - 1];
			}
			if (pivot == 0) {
				rv = t.t[r];
			} else {
				rv = t.t[r] - t.t[pivot - 1];
			}
		}
		lp = lv / (lv + rv);
		lc.w = Math.ceil(lc.w * lp);
		if (lc.w < c.w) {
			if (gap > 1) {
				if (lc.w > (gap>>1)) {
					lc.w -= (gap>>1);
				}
			} else {
				if (lc.w > 1) {
					lc.w--;
				}
			}
		}
		
		if (l + 1 == r) {
			rc.w -= lc.w + gap;
			rc.x += lc.w + gap;
			e = t[l];
			layoutEntityByMiddle.call(this, e, lc, swapped);
			e = t[r];
			layoutEntityByMiddle.call(this, e, rc, swapped);
			return;
		}
		var mc = copyRect(cc), as, 
		pap, 
		cv = 0, 
		pi = -1, 
		la = 1, 
		pv;

		if (pivot > l) {
			var llc = copyRect(lc);
			if (swapped) {
				swapRect(llc);
			}
			pivotByMiddle.call(this, t, l, pivot - 1, llc);
		}

		mc.w -= lc.w + gap;
		mc.x += lc.w + gap;
		rc.w = mc.w;
		rc.x = mc.x;
		as = mc.w / mc.h;
		e = t[pivot];
		pv = getSizeValue(e, this);
		pap = pv / rv;

		for ( var i = pivot; i <= r; i++) {
			e = t[i];
			cv += getSizeValue(e, this);
			if (i == r - 1) {
				continue;
			}
			var pwp = cv / rv, php = pv / cv, a = pwp / php * as;
			if (a >= 1) {
				if (la < 1 && la * a > 1) {
					pi = (i == r) ? i - 2 : i - 1;
				} else {
					pi = i;
				}
				break;
			}
			la = a;
		}
		pi = pi < 0 ? r : pi;

		var mv, pw, ph;

		if (pivot == 0) {
			mv = t.t[pi];
		} else {
			mv = t.t[pi] - t.t[pivot - 1];
		}
		pw = Math.ceil(mc.w * (mv / rv));
		ph = Math.ceil(mc.h * (pv / mv));
		if (pw < mc.w) {
			if (gap > 1) {
				if (pw > (gap>>1)) {
					pw -= (gap>>1);
				}
			} else {
				if (pw > 1) {
					pw--;
				}
			}
		}
		if (ph < mc.h) {
			if (gap > 1) {
				if (ph > (gap>>1)) {
					ph -= (gap>>1);
				}
			} else {
				if (ph > 1) {
					ph--;
				}
			}
		}
		var pc = {
			x : mc.x,
			y : mc.y,
			w : pw,
			h : ph
		};
		e = t[pivot];
		layoutEntityByMiddle.call(this, e, pc, swapped);

		if (pivot < pi) {
			mc.y += ph + gap;
			mc.w = pw;
			mc.h -= ph + gap;
			if (swapped) {
				swapRect(mc);
			}
			pivotByMiddle.call(this, t, pivot + 1, pi, mc);
		}
		if (pi < r) {
			rc.x += pw + gap;
			rc.w -= pw + gap;
			if (swapped) {
				swapRect(rc);
			}
			pivotByMiddle.call(this, t, pi + 1, r, rc);
		}
	}

	function layoutEntityByMiddle(e, c, swapped) {
		var size = copyRect(c);
		if (swapped == true) {
			swapRect(size);
		}
		if(rectIsValid(size)){
			e.size = size;
		}
		else{
			e.size = {
				x : size.x,
				y : size.y,
				w : 0,
				h : 0
			};
		}
		var ch = e.entityChildren;
		if (ch !== undefined) {
			var arr = getVisibleEntities.call(this, ch), l = arr.length;
			if (l > 0) {
				pivotByMiddle.call(this, arr, 0, l - 1, size);
			}
		}
	}

	function sliceAndDice(r, c) {
		if (r == null || r.length == 0) {
			return;
		}
		var t = 0, e = r[0], val, gap = getRectangleGap.call(this, e), swapped = false, l = r.length, x, y, w, h;
		for ( var i = 0; i < l; i++) {
			e = r[i], val = getSizeValue(e, this);
			if (!e.deleted && val > 0) {
				t += val;
			}
		}
		if (c.w < c.h) {
		} else {
			swapped = true;
			swapRect(c);
		}
		w = c.w;
		h = c.h;
		x = c.x;
		y = c.y;
		for ( var i = 0; i < l; i++) {
			e = r[i], val = getSizeValue(e, this);
			if (!e.deleted && val > 0) {
				var width, height;
				height = t <= 0 ? 0 : Math.ceil(val / t * h);
				width = w;
				if (val < t) {
					if (i == 0 || i == l - 1) {
						if (gap > 1) {
							if (height > (gap>>1)) {
								height -= (gap>>1);
							}
						} else {
							if (height > 1) {
								height--;
							}
						}
					} else {
						if (height > gap) {
							height -= gap;
						}
					}
				}
				width = Math.max(0, width);
				height = Math.max(0, height);
				var nc = {
					x : x,
					y : y,
					w : width,
					h : height
				}, rect = rectIntersection(nc, c);
				y += height + gap;
				if (y >= c.y + h) {
					rect.h = c.y + h - rect.y;
				}
				if (swapped) {
					swapRect(rect);
				}
				if(rectIsValid(rect)){
					e.size = rect;
				}
				else{
					e.size = {
						x : rect.x,
						y : rect.y,
						w : 0,
						h : 0
					};
				}
				if (e.entityChildren !== undefined) {
					sliceAndDice.call(this, e.entityChildren, rect);
				}
			} else {
				e.size = {};
				if (swapped) {
					e.size = {
						x : y,
						y : x,
						w : 0,
						h : 0
					};
				} else {
					e.size = {
						x : x,
						y : y,
						w : 0,
						h : 0
					};
				}
				continue;
			}
		}
		if (swapped) {
			swapRect(c);
		}
	}

	
	
	
    function setShow(mf, s, fm, sfm, ec, w, ml) {
            
            if (ec.entityChildren !== undefined) {
                    
                    
                    var parent = ec.parentEntity, del = true, 
                    
                    cd = false, 
                    teAggValues = [], eChildren = ec.entityChildren, l = eChildren.length;
                    for ( var i = 0; i < ml; i++) {
                            teAggValues[i] = {
                                    count : 0,
                                    allChildrenCount : 0,
                                    positiveCount : 0
                            };
                    }

                    for ( var i = 0; i < l; i++) {
                            var child = eChildren[i];
                            setShow(mf, s, fm, sfm, child, w, ml);
                            if (!child.deleted) {
                                    del = false;
                            }
                            
                            if (child.entityChildren === undefined) {
                                    if (child.deleted) {
                                            cd = true;
                                    }
                            } else {
                                    if (child.hasChildDeleted) {
                                            cd = true;
                                    }
                            }
                            if (!child.deleted) {
                                    aggregateTotals(ec, child, teAggValues, w, ml);
                            }
                    }
                    ec.deleted = del;
                    ec.hasChildDeleted = cd;
                    for ( var i = 0; i < ml; i++) {
                            var ev = ec.aggValues[i];
                            if (ev == null) {
                                    ev = {};
                                    ec.aggValues[i] = ev;
                            }
                            
                            var temp = teAggValues[i];
                            ev.total = temp.total;
                            ev.avg = temp.count == 0 ? 0 : temp.avgTotal / temp.count;
                            ev.geomAvg = temp.positiveCount == 0 ? NaN : Math.pow(
                                    temp.geomProduct, 1 / temp.positiveCount);
                                    ev.min = temp.min;
                                    ev.max = temp.max;
                                    ev.count = temp.count;
                                    ev.positiveCount = temp.positiveCount;
                    }
            }
            
            else {
                    if(ec.deleted)
                            return ;
                    
                    var sv = getSizeValue(ec, w);
                    if(!isNaN(sv)){
                            if(isNaN(w.smax)){
                                    w.smax = w.smin = sv;
                            } else{
                                    if(sv > w.smax){
                                            w.smax = sv;
                                    }
                                    if(sv < w.smin){
                                            w.smin = sv;
                                    }
                            }
                    }
                    var cv = getColorValue(ec, w);
                    if(!isNaN(cv)){
                            if(isNaN(w.cmax)){
                                    w.cmax = w.cmin = cv;
                            } else{
                                    if(cv > w.cmax){
                                            w.cmax = cv;
                                    }
                                    if(cv < w.cmin){
                                            w.cmin = cv;
                                    }
                            }
                    }
            }
    }
	function aggregateTotals(ec, child, teAggValues, w, ml) {
		var ev, agg = child.aggValues;
		
		if (child.entityChildren !== undefined) {
			ev = getEntityValue(child, w.sizeMetricIndex);
			if (ev !== null) {
				var cnt = ev.count;
				if (cnt > 0) {
					for ( var i = 0; i < ml; i++) {
						ev = teAggValues[i];
						updateEntityContainerAggValue(ev, agg[i]);
					}
				}
			}
		}
		
		else {
			if (getSizeValue(child, w) > 0 && !child.deleted) {
				for ( var i = 0; i < ml; i++) {
					ev = teAggValues[i];
					updateEntityAggValue(ev, getAggValue(child, i, w));
				}
			}
		}
	}

	function getEntityValue(e, index) {
		var agg = e.aggValues;
		if (index >= agg.length)
			return NaN;
		return agg[index];
	}

	function getColorValue(e, w){
		var idx = w.colorMetricIndex;
		return getAggValue(e, idx, w);
	}

	function getSizeValue(e, w){
		var idx = w.sizeMetricIndex,
			val = getAggValue(e, idx, w);
		if(val < 0){
			w.hasNegativeSizeValue = true;
			return Math.abs(val);
		}
		return val;
	}

	function getSizeRawValue(e, w){
		var idx = w.sizeMetricIndex;
		return getAggValue(e, idx, w);
	}
	
	function getAggValue(e, i, w) {
		var agg = e.aggValues;
		if (i >= agg.length)
			return NaN;
		var ev = agg[i],
			t = w.aggFunctions[i]; 
		
		if (e.entityChildren !== undefined) {
			switch (t) {
				case AggregationType.Sum:
					return ev.total;
				case AggregationType.Avg:
					return ev.avg;
				case AggregationType.Cnt:
					return ev.count;
				case AggregationType.Max:
					return ev.max;
				case AggregationType.Min:
					return ev.min;
				case AggregationType.GeoAvg:
					return (ev.positiveCount > 0) ? ev.geomAvg : 0;
				default:
					return ev.total;
			}
		}
		
		else {
			if (ev.allChildrenCount == 1) {
				return ev.value;
			}
			switch (t) {
				case AggregationType.Sum:
					return ev.total;
				case AggregationType.Avg:
					return ev.count == 0 ? 0 : ev.avgTotal / ev.count;
				case AggregationType.Cnt:
					return ev.count;
				case AggregationType.Max:
					return ev.max;
				case AggregationType.Min:
					return ev.min;
				case AggregationType.GeoAvg:
					return ev.positiveCount > 0 ? NaN : Math.pow(ev.geomProduct,
							1.0 / ev.positiveCount);
				default:
					return ev.total;
			}
		}
	}
	function getLegendMaxMin() {






		if(!isNaN(this.mlmax) || !isNaN(this.mlmin)){
			if(!isNaN(this.mlmax)){
				this.cmax = this.mlmax;
				if(isNaN(this.mlmin) && (this.mlmax < this.cmin)){
					this.cmin = this.mlmax;
				}
			}
			if(!isNaN(this.mlmin)){
				this.cmin = this.mlmin;
				if(isNaN(this.mlmax) && (this.mlmin > this.cmax)){
					this.cmax = this.mlmin;
				}
			}

		}
		if (!isNaN(this.mlmax) && this.cmax > this.mlmax) {
			this.cmax = this.mlmax;
		}
		if (!isNaN(this.mlmin) && this.cmin < this.mlmin) {
			this.cmin = this.mlmin;
		}
		this.colorTheme.min = this.cmin;
		this.colorTheme.max = this.cmax;
		this.colorTheme.checkMinMax();
	}

	function getMetricID(idx){
		var str = "",
			m = this.model,
			col = m.ghs.chs.items,
			cnt = col.length,
			ml = col[0].items.length,
			coln = m.gts.col;
		if (idx < 0 || idx >= ml) return "";
		for(var i = 0; i < cnt; i++){
			var index = col[i].items[idx].idx;
			var temp = coln[i].es[index];
			var id = (temp.oid !== undefined) ? temp.oid : temp.id;
			str += id + " ";
		}
		return str.slice(0, str.length-1);
	}
	function getNumberForTick(i){
		var v;
		if(this.props.legendAsc){
			v = this.cmin + (this.cmax - this.cmin) * i/this.legendTickCount;
		}
		else{
			v = this.cmax + (this.cmin - this.cmax) * i/this.legendTickCount;
		}
		if(this.props.legendRounded){
			v = Math.floor(v);
		}
		return v;
	}

	function getTooltip(e, w){
		
		var level = e.level,
			index = (e.index === undefined) ? e.indices[0] : e.index,
			st = 0, 
			str = '',
			ret = '',
			ar = w.attSpan,
			rhs = w.model.ghs.rhs.items,
			rowHeaderData = rhs[index].items,
			attr = w.model.gts.row,
			mv = w.model.gvs.items, 
			ml = mv[0] ? mv[0].items.length:0,
			
			att, fs;

		for(var i = 0; i < level; i++){
			att = attr[i];
			
			ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-gray-bold">' + att.n + '</div>' + '<div class="heatmap-tooltip-gray-bold"><p>:&nbsp;</p></div>';
			str = '';
			for(var j = st; j < st + ar[i]; j++){
				var idx = rowHeaderData[j].idx;
				if(idx == -1)
					continue;
				str += att.es[idx].n + " ";
			}
			str = str.substring(0, str.length-1);
			ret += '<div class = "heatmap-tooltip-gray">' + str + '</div></div>';
			st += ar[i];
		}
		att = attr[level];
		ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-black-bold">' + att.n + '</div>' +  '<div class="heatmap-tooltip-black-bold"><p>:&nbsp;</p></div>';
		str = '';
		for(var i = st; i < st + ar[level]; i++){
			var idx = rowHeaderData[i].idx;
			if(idx == -1)
				continue;
			str += att.es[idx].n + " ";
		}
		str = str.substring(0, str.length-1);
		ret += '<div class = "heatmap-tooltip-black">' + str + '</div></div>';
		
		
		var si = w.sizeMetricIndex,
			ci = w.colorMetricIndex,
			n, v;
		if(si != ml){
			n = w.getMetricName(si);
			if(e.entityChildren !== undefined || w.aggregated){
				var tmp = w.aggFunctions[si];
				n = tooltipMacro(n, tmp);
				v = getSizeRawValue(e, w);
				if(isNaN(v)){
					v = '-';
				}
				else if(AggregationType.Cnt != tmp){
					fs = w.getFormatString(si);
					v = w.nf.formatByMask(fs, v);
				}
			}else{
				v = mv[index].items[si].v;
			}
			ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-black-bold">' + n + '</div>' + '<div class="heatmap-tooltip-black-bold"><p>:&nbsp;</p></div>';
			ret += '<div class = "heatmap-tooltip-black">' + v + '</div></div>';
		}
		if(e.entityChildren === undefined && ci != ml && si != ci){
			n = w.getMetricName(ci);
			if(e.entityChildren !== undefined || w.aggregated){
				var tmp = w.aggFunctions[ci];
				n = tooltipMacro(n, tmp);
				v = getColorValue(e, w);
				if(isNaN(v)){
					v = '-';
				}
				else if(AggregationType.Cnt != tmp){
					fs = w.getFormatString(ci);
					v = w.nf.formatByMask(fs, v);
				}
			}else{
				v = mv[index].items[ci].v;
			}
			ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-black-bold">' + n + '</div>' + '<div class="heatmap-tooltip-black-bold"><p>:&nbsp;</p></div>';
			ret += '<div class = "heatmap-tooltip-black">' + v + '</div></div>';
		}
		for(var i = 0; i < ml; i++){
			if(i == si) continue;
			if(i == ci && e.entityChildren === undefined && si != ci) continue;
			n = w.getMetricName(i);
			if(e.entityChildren !== undefined || w.aggregated){
				var tmp = w.aggFunctions[i];
				n = tooltipMacro(n, tmp);
				v = getAggValue(e, i, w);
				if(isNaN(v)){
					v = '-';
				}
				else if(AggregationType.Cnt != tmp){
					fs = w.getFormatString(i);
					v = w.nf.formatByMask(fs, v);
				}
			}else{
				v = mv[index].items[i].v;
			}
			ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-gray-bold">' + n + '</div>' + '<div class="heatmap-tooltip-gray-bold"><p>:&nbsp;</p></div>';
			ret += '<div class = "heatmap-tooltip-gray">' + v + '</div></div>';
		}
		return ret;
	}

	function tooltipMacro(n, t){
		var macro;
		switch(t){
			case AggregationType.Sum:
				macro = "Sum of {0}";
				break;
			case AggregationType.Avg:
				macro = "Average of {0}";
				break;
			case AggregationType.Cnt:
				macro = "Count of {0}";
				break;
			case AggregationType.Max:
				macro = "Maximum of {0}";
				break;
			case AggregationType.Min:
				macro = "Minimum of {0}";
				break;
			case AggregationType.GeoAvg:
				macro = "Geometry Average of {0}";
				break;
			default:
				macro = "Sum of {0}";
		}
		return macro.replace('{0}', n);
	};

    function bindTouchEvents(d, owner) {
            if(d.eventOwner == owner)
                    return;
            var $D = mstrmojo.dom,
                eventList = [$D.TOUCHSTART, $D.TOUCHMOVE, $D.TOUCHEND, $D.TOUCHCANCEL];
            for(var i = 0; i < eventList.length; i++){
                    if(eventList[i] == '')
                            continue;
                    if(document.createTouch){
                            d['on' + eventList[i]] = function (e) {
                                    var evt = document.createEvent("TouchEvent"),
                                        t = e.touches[0];
                                    
                                    if(!t){
                                            t = {};
                                    }
                                    
                                    evt.initTouchEvent(e.touches, e.targetTouches, e.changedTouches, e.type, e.view, t.screenX, t.screenY, t.clientX, t.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey);

                                    
                                    
                                    owner.dispatchEvent(evt);
                            };
                    }else{
                            d['on' + eventList[i]] = function (e) {
                                    var evt = document.createEvent('MouseEvent');
                                    evt.initMouseEvent(e.type, e.bubbles, e.cancelable, e.view, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);
                                    owner.dispatchEvent(evt);
                            };
                    }
                    
            }
            d.eventOwner = owner;
    };




	mstrmojo.VisHeatMap = mstrmojo.declare(

					mstrmojo.Vis,

					[ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

					{

						scriptClass : 'mstrmojo.VisHeatMap',

						scrollerConfig : {
							bounces : false,
							showScrollbars : false,
							useTranslate3d : true,
							vScroll: true,
							hScroll: true,
							offset : {
									y: {
										start: 0,
										end: 0
									},
									x: {
										start: 0,
										end: 0
									}
							},
							origin: {
								x: 0,
								y: 0
							}
						},

						selectedStyle : "background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #058CF5), color-stop(1, #015DE6));color:#FFFFFF;",

						selectedClass : "",

                        insertedStyles : [],

                        LayoutProperties: {},

						highlightBoxWidth: 3,

                        waitIconString: mstrmojo.desc("8445","Loading"),


						markupString :
						'<div id="{@id}" class="mstrmojo-{@cssClass}" style="background-color:#333333;width:{@width};height:{@height}; left:{@left}; top:{@top}; z-index: {@zIndex}; position:absolute;" mstrAttach:mousedown,mouseup,mousemove,click>'
                                
                                +'<div class="heatmap-canvas-outer-container" style="padding: {@LayoutProperties.Padding}px; height:{@heatMapSize.h}px; width:{@heatMapSize.w}px">'
                                        
                                        +'<div id ="{@id}-heatmap-canvas-container" class="heatmap-canvas-container" style="left: {@LayoutProperties.Padding}px; top: {@LayoutProperties.Padding}px; height:{@heatMapSize.h}px; width:{@heatMapSize.w}px">'
                                                
                                                +'<div>'
                                                        
                                                        + '<div></div>'
                                                        
                                                        +'<div class="heatmap-selection-highlight-box heatmap-round-corner" style="border: {@highlightBoxWidth}px solid white;"></div>'
                                                +'</div>'
                                        +'</div>'
                                +'</div>'
								
								+'<div class="heatmap-legend" style="left:{@legendSize.x}px; top:{@legendSize.y}px; height:{@legendSize.h}px; width:{@legendSize.w}px">'
											
											+ '<div  class="heatmap-size-legend">'
												
												+ '<div class="heatmap-size-legend-title">Rectangle Size:</div>'
												
												+ '<div id="{@id}-color-legend-ticker" class="heatmap-size-legend-label" ></div>'
											
											+ '</div>'
											+
											
											'<div  class="heatmap-color-legend">'
												
												+ '<div class="heatmap-color-legend-title">Rectangle Color:</div>'
												
												+ '<table cellpadding="4" class="heatmap-color-legend-label">'
													+ '<tbody><tr>'
														+ '<td class="heatmap-color-legend-label-td"></td>'
													+ '</tr></tbody>'
												+ '</table>'
												+ '<div style="position:relative;">'
													
													+ '<canvas id="{@id}-color-legend-band" class="heatmap-color-legend-band"></canvas>'
													
													+ '<div id="{@id}-legend-tooltip" class="heatmap-color-legend-tooltip"></div>'
												+ '</div>'
											
											+ '</div>'
											
											+ '<div id="{@id}-editor-div" class="heatmap-editor-button" style="width: {@LayoutProperties.EditButtonWidth}px; height:{@LayoutProperties.EditButtonHeight}px; right:{@LayoutProperties.EditButtonRight}px"></div>'
								
								+ '</div>'

								
								+'<span id="textSpan" class="heatmap-measure-text"></span>'

                                
                                +'<div class="mojo-overlay-wait" style="display: -webkit-box; -webkit-box-align:center; -webkit-box-pack:center; position: absolute; left: -100000px; top: -100000px">'
                                        +'<div class="overlay"></div>'
                                        +'<div style="width:{@LayoutProperties.WaitIconWidth}px; height:{@LayoutProperties.WaitIconHeight}px; background-color: black; opacity: 0.8; display: -webkit-box">'
                                            +'<div style="display: -webkit-box; -webkit-box-align: center; -webkit-box-pack: center; -webkit-box-flex:1;  margin: {@LayoutProperties.WaitIconMargin}px; border: 1px solid white; color: white; font-family: Helvetica; font-weight: bold; font-size:{@LayoutProperties.WaitIconFontSize}pt">'
                                                +'{@waitIconString}'
                                            +'</div>'
                                        +'</div>'
                                +'</div>'

                                
                                + '<div></div>'

                        + '</div>',

						markupSlots : {

							canvas: function() {
								return this.domNode.childNodes[0].childNodes[0].childNodes[0].childNodes[0];
							},

							canvasContainer: function() {
								return this.domNode.childNodes[0].childNodes[0];
							},

                            canvasOuterContainer: function() {
                               return this.domNode.childNodes[0];
                            },

                            scrollNode: function() {
                                return this.domNode.childNodes[0].childNodes[0].childNodes[0];
                            },

							selectionHighlightBox : function() {
								return this.domNode.childNodes[0].childNodes[0].childNodes[0].childNodes[1];
							},

							legend: function() {
								return this.domNode.childNodes[1];
							},

							sizeLegend : function(){
								return this.domNode.childNodes[1].childNodes[0];
							},
							sizeLegendTitle : function() {
								return this.domNode.childNodes[1].childNodes[0].firstChild;
							},
							sizeLegendLabel : function() {
								return this.domNode.childNodes[1].childNodes[0].lastChild;
							},

							colorLegend : function() {
								return this.domNode.childNodes[1].childNodes[1];
							},
							colorLegendTitle : function() {
								return this.domNode.childNodes[1].childNodes[1].firstChild;
							},
							colorLegendLabel : function() {
								return this.domNode.childNodes[1].childNodes[1].childNodes[1];
							},
							colorLegendBand : function() {
								return this.domNode.childNodes[1].childNodes[1].childNodes[2].firstChild;
							},
							legendTooltip : function() {
								return this.domNode.childNodes[1].childNodes[1].childNodes[2].childNodes[1];
							},
							editorButton : function() {
								return this.domNode.childNodes[1].lastChild;
							},
							textSpan : function() {
								return this.domNode.childNodes[2];
							},

                            waitIcon: function() {
                                    return this.domNode.childNodes[3];
                            },

                            infoBoxPuppet: function() {
                                    return this.domNode.childNodes[4];
                            }
						},

                        addCSSToHead: function(){
                                var cssString = {
                                        text:
                                                '.heatmap-popup-panel-title {'+
                                                '  font-size: ' + adjustPixel.call(this,22 , true) + 'pt !important;'+
                                                '  height: ' + adjustPixel.call(this,65 , true) + 'px !important;'+
                                                '}'+
                                                '.heatmap-gray-label {'+
                                                '        padding-bottom: ' + adjustPixel.call(this,7 , true) + 'px !important;'+
                                                '        font-size: ' + adjustPixel.call(this,14 , true) + 'pt !important;'+
                                                '  height: ' + adjustPixel.call(this,32 , true) + 'px !important;'+
                                                '  padding-left: ' + adjustPixel.call(this,22 , true) + 'px !important;'+
                                                '  line-height: ' + adjustPixel.call(this, 40 , true) + 'px !important;' +
                                                '}'+
                                                '.heatmap-tree-text {' +
                                                '  font-size: ' + adjustPixel.call(this, 18 , true) + 'pt !important;' +
                                                '  line-height: ' + adjustPixel.call(this, 65 , true) + 'px !important;'+
                                                '}' +
                                                '.heatmap-tree-div {'+
                                                '  font-size: ' + adjustPixel.call(this,18 , true) + 'pt !important;'+
                                                '  line-height: ' + adjustPixel.call(this, 40 , true) + 'px !important;'+
                                                '}'+
                                                '.heatmap-tree-button {'+
                                                '  font-size: ' + adjustPixel.call(this,16 , true) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-apply-button > .mstrmojo-Button-text {'+
                                                '  font-size: ' + adjustPixel.call(this,14 , true) + 'pt !important;'+
                                                '  line-height: ' + adjustPixel.call(this,24 , true) + 'px !important; '+
                                                '  height: ' + adjustPixel.call(this,24 , true) + 'px !important; '+
                                                '}'+
                                                '.heatmap-tree.root > .heatmap-tree-div > div {'+
                                                '  font-size: ' + adjustPixel.call(this,14 , true) + 'pt !important;'+
                                                '  line-height: ' + adjustPixel.call(this, 40 , true) + 'px !important;'+
                                                '  height: ' + adjustPixel.call(this, 40 , true) + 'px !important;'+
                                                '}'+
                                                '.heatmap-one-level-1 {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-multi-level-1 {'+
                                                '  font-size: ' + adjustPixel.call(this,24) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-two-level-2 {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-multi-level-2 {'+
                                                '  font-size: ' + adjustPixel.call(this,20) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-multi-level-3 {'+
                                                '  font-size: ' + adjustPixel.call(this,10) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-size-legend {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-color-legend {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-color-legend-label {'+
                                                '  font-size: ' + adjustPixel.call(this,10) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-color-legend-tooltip {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-legend {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-editor-button {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-tooltip-gray-bold {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-tooltip-gray {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-tooltip-black-bold {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-tooltip-black {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'
                                };

                                this.addAdjustedClassToDocument(cssString.text);

                        },

                        



						addAdjustedClassToDocument: function(classString){
							var beginIndex = classString.indexOf('.');
							if(beginIndex == -1)
								return;
                            var p = document.getElementsByTagName('head')[0];
                            this.CSSParent = p;
							for(var i = beginIndex; i < classString.length; ){
								var endIndex = i + classString.substring(i).indexOf('}');
								if(endIndex == -1)
									break;
								var style = document.createElement('style');
								style.type = 'text/css';
								style.innerHTML = classString.substring(i,endIndex+1);
                                this.insertedStyles.push(style);
								p.appendChild(style);
								i = endIndex + 1;
							}
						},

                        isMultipleDPIEnabled: function() {
                                var xtabModel = this.xtabModel,
                                    docModel = (xtabModel && xtabModel.docModel),
                                    fitToPage = false,
                                    microApp = false;
                                if (docModel) {
                                        fitToPage = docModel.zt && (docModel.zt==2);
                                        var layouts = (docModel && docModel.defn && docModel.defn.layouts),
                                            layout;
                                        var i;
                                        
                                        for(i in layouts) {
                                                if (layouts[i].loaded) {
                                                        layout = layouts[i];
                                                        break;
                                                }
                                        }
                                        if (layout && layout.hasOwnProperty("fch")) {
                                                microApp = layout.fch;
                                        }
                                }
                                if(fitToPage && microApp)
                                        return true;
                                else
                                        return false;
                                
                        },

                        init: function(e){

                                if(this._super)
                                        this._super(e);

                                
                                var canvas = document.createElement("canvas");
                                browserSupportsHtml5 = canvas.getContext;
                                if (!browserSupportsHtml5) {
                                        this.error = mstrmojo.desc(8126, 'Your browser does not support HTML5');
                                        return;
                                }



                        },
						preBuildRendering :function() {


                                delete this.error;
                                if(this._super){
                                        this._super();
                                }
                                
                                this.dpiAdjusted = true;
                                this.DPI = mstrMobileApp.getDeviceDPI();
                                if(mstrMobileApp.getDeviceDPIX)
                                        this.DPIX = mstrMobileApp.getDeviceDPIX();
                                else
                                        this.DPIX = 149;
                                if(this.isMultipleDPIEnabled()){
                                

                                        
                                        
                                        
                                                

                                        this.enableMultiDPI = true;
                                        
                                        
                                }else{
                                        
                                        this.enableMultiDPI = false;
                                        
                                        
                                        
                                                


                                        
                                        
                                        
                                }
                                
                                

                                this.adjustLocalDPI();
                                this.addCSSToHead();




                                this.zIndex = null;

                                this.loadDefinedFormat();


                                loadProps.call(this);
                                loadSession.call(this);


                                if (!this.model) {
                                        this.error = mstrmojo.desc(8426,'No model provided');

                                        return ;
                                }
                                
                                var err = this.model.err || this.model.eg;
                                if(err){
                                        this.error = err;
                                        return;
                                }

                                convertDataToModels.call(this);

                                var err = this.model.err || this.model.eg;
                                if(err){
                                        this.error = err;
                                        return;
                                }


                                setLayout.call(this);


                                this.calculateValuesInTree();

                                layoutEntities.call(this);


                                getLegendMaxMin.call(this);


                                this.nf = mstrmojo.num;

                                if (this.editorDialog) {
                                        this.editorDialog.destroy();
                                        this.editorDialog = null;
                                }

						},

                        
                        buildRendering: function () {


                                var that = this;
                                var backup = mstrmojo.string.apply;
                                mstrmojo.string.apply = function (tmpl, obj) {
                                        if (!tmpl) {
                                                return "";
                                        }
                                        return tmpl.replace(/\{([^\}]+)\}/gm,
                                                            function tokenRepl(token, prop) {
                                                                    var s = token.replace(/@/g, 'that.');
                                                                    var res;
                                                                    try{
                                                                            res = eval(s);
                                                                    }catch(e){
                                                                            res = undefined;
                                                                    }finally{
                                                                    }
                                                                    return res === undefined ? '' : res;
                                                            }
                                        );
                                };

                                if (this._super) {
                                        this._super();
                                }
                                mstrmojo.string.apply = backup;





                        },

                        createInfoBox: function(){
                                
                                
                                var html =
                                        
                                        '<div id="' + this.id + '-infobox" class="heatmap-infobox" style="position:absolute; left:0px; top:0px;">'  
                                            +'<div class="heatmap-highlight-box heatmap-round-corner" style="border: ' + this.highlightBoxWidth + 'px solid white;"></div>'  
                                            +'<div class="heatmap-shadow-box heatmap-round-corner"></div>'  
                                            +'<div class="heatmap-triangle"></div>'  
                                            +'<div class="heatmap-tooltip-box heatmap-round-corner" style="max-width: ' + document.body.offsetWidth + 'px; max-height: ' + document.body.offsetHeight + 'px; "></div>'  
                                            +'<div class="heatmap-delete-button"></div>'  
                                            +'<div class="heatmap-tooltip-shelter heatmap-round-corner"></div>'
                                        +'</div>';
                                
                            var div = document.createElement('div');
                            div.innerHTML = html;

							this.infoBox = div.childNodes[0];
                            this.highlightBox = this.infoBox.childNodes[0];
                            this.shadowBox = this.infoBox.childNodes[1];
                            this.triBox = this.infoBox.childNodes[2];
                            this.tooltipBox = this.infoBox.childNodes[3];
                            this.deleteButton = this.infoBox.childNodes[4];
                            this.shelter = this.infoBox.childNodes[5];

                            
                            

                            div.style.cssText = 'position: absolute; left: 0px; top: 0px';

                            
                            bindTouchEvents(div, this.infoBoxPuppet);

                            document.body.appendChild(div);
                        },

                        








						postBuildRendering : function postBR() {

                                if(this.error){

                                        this.renderErrorMessage(this.error);
                                        return ;
                                }
                            var heatMap = this;
                            
                            var tmpFunction = this.controller.onorientationChange;
                            this.controller.onorientationChange = function(){
                                    tmpFunction.call(heatMap.controller);
                                    heatMap.onorientationChange();
                            }

                            
                            
                            
                            this.enableGlobalDismiss();



                            this.setupScroller();
							if(this._super) {
			                	this._super();
                            }
                            var backup = this._tsCallback;
                            this._tsCallback = function(e){
                                    
                                    if(heatMap.isInfoWindowDisplayed())
                                            heatMap.infoWindowMode = true;
                                    else
                                            heatMap.infoWindowMode = false;


                                    backup.call(heatMap,e);
                            };

                            
                            

                            var $DAE = mstrmojo.dom.attachEvent,
                                $DDE = mstrmojo.dom.detachEvent,
                                TOUCHSTART = mstrmojo.dom.TOUCHSTART;
                            $DDE(this._tn, TOUCHSTART, backup);
                            $DAE(this._tn, TOUCHSTART, this._tsCallback);

                            
                            if(this.isUsingSavedColorTheme) {
                                this.useSavedColorTheme();
                            }

                            if(this.isUsingDefaultColorTheme) {
                                this.useDefaultColorTheme();
                            }

                            this.initCanvas();
							
							this.renderLegend();
                            
                            if(!this.infoBox)
                                    this.createInfoBox();

							
							if (this.props.delButtonEnabled) {
								this.deleteButton.style.display = "block";
							}

							if(this.previousSelected && this.previousSelected.parentEntity){
                                
								this.highlightEntity(this.selectionHighlightBox, this.previousSelected);
                                
                                
							}

							


                        },

                        unrender: function(){
                                

                                
                                
                                
                                
                                storeSession.call(this);


                                this.disableGlobalDismiss();
                                var $DAE = mstrmojo.dom.attachEvent,
                                    $DDE = mstrmojo.dom.detachEvent,
                                    TOUCHSTART = mstrmojo.dom.TOUCHSTART;
                                $DDE(this._tn, TOUCHSTART, this._tsCallback);
                                if(this.infoBox && this.infoBox.parentNode && this.infoBox.parentNode.parentNode)
                                        this.infoBox.parentNode.parentNode.removeChild(this.infoBox.parentNode);
                                delete this.infoBox;
                                
                                if(this._super)
                                        this._super();
                        },

                        getFirstInfowindow: function getFirstInfowindow() {
                                var me = this,
                                    model = me.model,
                                    xtabModel = me.xtabModel,
                                    docModel = (xtabModel && xtabModel.docModel),
                                    row = model && model.gts && model.gts.row,
                                    tks;
                                if (row && row.length>0) {
                                        tks = row[0] && row[0].sc && row[0].sc.tks;
                                }
                                if (docModel && tks) {
                                        ifws = docModel.getTargetInfoWin(tks);
                                        if (ifws && ifws.length) {
                                                var ifwunit = docModel.infoWinByKey[ifws[0]];
                                                var id = ifwunit && (ifwunit.id + "_ifw");
                                                return mstrmojo.all[id];
                                        }
                                }
                        },

                        isInfoWindowDisplayed: function() {
                                var ifw = this.getFirstInfowindow();
                                if(ifw)
                                        ifw = ifw.domNode;
                                if(!ifw)
                                        return false;

                                if(ifw.style.display == 'block')
                                        return true;
                                else
                                        return false;
                        },

                        globalListener: function (){
                                
                                var that = window.heatMap;
                                if(!that)
                                        return ;
                                that.hideInfoBox();
                                if(!that.selectAll)
                                        that.doSelection(that.previousSelected);
                        },


                        addGlobalListener: function() {
                                window.heatMap = this;
                                var p = document.getElementsByClassName('mstrmojo-DocLayoutViewer-layout')[0];
                                if(p)
                                        p.addEventListener(mstrmojo.dom.TOUCHSTART, window.heatMap.globalListener, false);
                        },

                        removeGlobalListener: function() {
                                var p = document.getElementsByClassName('mstrmojo-DocumentView')[0];
                                if(p)
                                        p.removeEventListener('click', this.globalListener, false);
                                delete window.heatMap;
                        },



                        addCurtain: function(){
                                var p = document.getElementsByClassName('mstrmojo-DocLayoutViewer-layout')[0];
                                var div = document.createElement('div'),
                                    
                                    that = this;
                                div.style.width = p.offsetWidth + 'px';
                                div.style.height = p.offsetHeight+ 'px';
                                div.style.position = 'absolute';
                                
                                div.style.zIndex = -1;
                                div.id = this.id + 'curtain';

                                div.onclick = this.globalListener;
                                p.appendChild(div);
                        },
                        removeCurtain: function(){
                                var div = document.getElementById(this.id+'curtain');
                                if(div)
                                        div.parentNode.removeChild(div);
                        },
                        renderErrorMessage: function renderErrorMessage(msg) {
                                var d = this.domNode,
                                    p = d.parentNode,
                                    div = document.createElement('div'),
                                    textDiv = document.createElement('div');

                                if(d){

                                        div.style.width = d.offsetWidth - 2 + 'px' ;
                                        div.style.height = d.offsetHeight - 2 + 'px';
                                        div.style.left = d.offsetLeft + 'px';
                                        div.style.top = d.offsetTop + 'px';
                                        div.style.zIndex = this.zIndex ;
                                }else{

                                        div.style.width = parseInt(this.width) - 2 + 'px';
                                        div.style.height = parseInt(this.height) - 2 + 'px';
                                        div.style.left = this.left;
                                        div.style.top  = this.top;
                                        div.style.zIndex = this.zIndex;
                                }

                                div.style.cssText += "background-color:#F5F5F2; position:absolute; display:-webkit-box; -webkit-box-pack:center; -webkit-box-align:center; -webkit-box-orient:vertical; border-style:solid; border-color:#A7A7A7; border-width:1px; ";
                                textDiv.className = "mstrmojo-message";
                                textDiv.innerText = msg;
                                div.appendChild(textDiv);
                                if(d)
                                        p.replaceChild(div, d);
                                else
                                        p.appendChild(div);
                        },

                        convertDPI: function(props) {
                                if(typeof props != 'object'){
                                        if(typeof props == 'number' && props%1 == 0)
                                                return adjustPixel.call(this, props);
                                        else
                                                return props;
                                }else{
                                        var ret = {};
                                        for(var key in props)
                                                ret[key] = this.convertDPI(props[key]);
                                        return ret;
                                }
                        },

						adjustLocalDPI: function(){
								
                                this.LayoutProperties = this.convertDPI(LayoutProperties);
                                this.LayoutProperties.LegendTickCount = 5;
                                this.LayoutProperties.LegendWidthPercent = 0.9;
                                this.LayoutProperties.LegendBandAspect = 10;
                                this.LayoutProperties.EditorDialogWidth = adjustPixel.call(this,565, true);
                                this.LayoutProperties.EditorDialogHeight = adjustPixel.call(this,574, true);
                                var h = document.body.offsetHeight,
                                    eh = this.LayoutProperties.EditorDialogHeight,
                                    sfh = h / eh,
                                    sf = 1;
                                if(sfh < 1){
                                        sf = sfh;
                                        sf *= 0.9;
                                        this.LayoutProperties.EditorDialogHeight = parseInt(eh * sf);
                                }

                                this.LayoutProperties.DeletedListHeight = adjustPixel.call(this,500*sf , true);
                                this.LayoutProperties.EditButtonWidth = adjustPixel.call(this,60);
                                this.LayoutProperties.EditButtonHeight = adjustPixel.call(this,40);
                                this.LayoutProperties.EditButtonRight = adjustPixel.call(this,10);
                                
						},

						onorientationChange: function(){
								if(this.editorDialog){
										var domNode = this.editorDialog.domNode;
                                        if(domNode && domNode.firstChild){
                                                var d = domNode.firstChild, 
                                                    t = d.firstChild.firstChild;
                                                d.style.marginTop = parseInt((document.body.offsetHeight - this.LayoutProperties.DeletedListHeight - t.offsetHeight)/2) + 'px';
                                        }
								}
						},


                        loadDefinedFormat: function() {
                                
                                if (this.defn && this.defn.fmts) {
                                        var fmts = this.defn.fmts,
                                            pWidgetHeight = fmts && fmts.p_fmts && fmts.p_fmts.height;

                                        if (fmts.height) {
                                                this.height = fmts.height;
                                        }
                                        if(!this.isFullScreenWidget) {
                                                if (fmts.width) {
                                                        this.width = fmts.width;
                                                }
                                        }

                                        if (fmts["z-index"]) {
                                                this.zIndex = fmts["z-index"];
                                        }
                                }
                        },

                        checkErrors: function() {
                                var err = this.error;
                                if(err){
                                        this.renderErrorMessage(err);
                                        return true;
                                }
                                if (!this.model) {
                                        this.renderErrorMessage(mstrmojo.desc(8426,'No model provided'));

                                        return true;
                                }
                                var err = this.model.err || this.model.eg;
                                if (err) {
                                        this.renderErrorMessage(err);

                                        return true;
                                }
                                return false;
                        },


                        setupScroller: function(){
                                
                                var sclConfig = this.scrollerConfig;
                                sclConfig.scrollEl = this.scrollNode;
                                sclConfig.offset.x.start = 0;
                                sclConfig.offset.x.end = this.heatMapSize.w * (this.scaleFactor - 1);
                                sclConfig.offset.y.start = 0;
                                sclConfig.offset.y.end = this.heatMapSize.h * (this.scaleFactor - 1);
                                if (sclConfig.origin.x > sclConfig.offset.x.end) {
                                        sclConfig.origin.x = sclConfig.offset.x.end;
                                }
                                if (sclConfig.origin.y > sclConfig.offset.y.end) {
                                        sclConfig.origin.y = sclConfig.offset.y.end;
                                }
                        },




                        refreshLabelInTree: function(){
                                var getLabel = function(e, idx){
                                        if(e == this.root)
                                                return;
                                        var text = this.getLabelForEntity(e);
                                        e.text = text;
                                        e.idx = idx;
                                };
                                this.dfs(this.root, getLabel, "");
                        },

						refreshColorInTree: function() {
							var paintColor = function(e) {
                                    if(e.EntityChildren || e == this.root)
                                            return;
                                    
                                    var color = getCSSColor(this.colorTheme.getColor(getColorValue(e,this)));
                                    e.color = color;
							};
							this.dfs(this.root,paintColor,"");
						},





























						dfs: function (root, f, indexString) {
							if(root.deleted) {
								return;
							}
							if(indexString === undefined){
								f.call(this,root);
							}else{
								f.call(this,root, indexString);
							}

							if(root.entityChildren === undefined){
								return;
							}
							var arr = root.entityChildren,
								l = arr.length;
							for(var i = 0; i < l; i++){
								var e = arr[i];
								if(indexString === undefined){
									this.dfs(e, f);
								}else{
									var param = indexString;
									if (!param) {
										param = i.toString();
									} else {
										param = param + ":" + i;
									}
									this.dfs(e, f, param);
								}
							}
						},

						
						traverseBFS: function traverse(){
							var heatMap = this,
								canvas = this.textCanvas,
								renderText = function(e, indexString) {

								},
								terminate = function(level){
									var lv = level - heatMap.levelToShowText;
									if(lv >= 3) return false;
									return true;
								};











						},

                        initCanvas: function() {
								this.refreshColorInTree();
                                this.refreshLabelInTree();
                                var props = {
                                        colorTheme: this.colorTheme,
                                        placeholder: this.canvas,
                                        root: this.root,
                                        width: this.heatMapSize.w,
                                        height: this.heatMapSize.h,
                                        scale: this.scaleFactor,
                                        attributes: this.levelAttributes,
                                        showMetric: this.props.showMetricValues,
                                        labelSetting: this.props.labelSize
                                };
                                this.canvasObject = new mstrmojo.VisHeatMapCanvas(props);
                                this.canvasObject.render();
                                this.canvasObject.updateOffsets(this._scroller.origin.x, this._scroller.origin.y);
                                this.canvas = this.canvasObject.domNode;
                        },


						renderRectangles: function(){
								this.refreshColorInTree();
                                this.refreshLabelInTree();
                                this.canvasObject.scale = this.scaleFactor;
                                this.canvasObject.offsetX =  this._scroller.origin.x;
                                this.canvasObject.offsetY =  this._scroller.origin.y;
                                this.canvasObject.draw();
						},

						renderLegend : function renderLegend() {
							if(this.props.showLegend == false) {
                                this.editorButton.style.height = '';
                                this.editorButton.style.width = '';
                                this.editorButton.style.right = '';
                                this.editorButton.style.bottom = '';

								this.editorButton.className = "heatmap-editor-legend-unshown";
								this.editorButton.innerHTML = "";
								this.editorButton.style.top = "";
								this.sizeLegend.style.display = "none";
								this.colorLegend.style.display = "none";
                                this.legend.style.left = '';
                                this.legend.style.top = '';
                                this.legend.style.right = '0px';
                                this.legend.style.bottom = '0px';
                                this.legend.style.zIndex = '100';
								return;
							}
                                var el = mstrmojo.desc(11158,'EDIT'),
                                rsl = mstrmojo.desc(10079,'Rectangle Size'),
                                rcl = mstrmojo.desc(10080,'Rectangle Color');

							this.editorButton.className = "heatmap-editor-button";
							this.editorButton.innerHTML = el;
							var w = parseInt(this.width), h = parseInt(this.height), canvasHeight = this.heatMapSize.h,
								computedStyle = window.getComputedStyle(this.editorButton,null),
								editorButtonHeight = parseInt(computedStyle['height']),
								editorButtonWidth = parseInt(computedStyle['width']),
                                legendHeight = this.legendSize.h,
                                legendWidth = this.legendSize.w - editorButtonWidth - parseInt(computedStyle['right']),
                                sfs = this.getFormatString(this.sizeMetricIndex);
							this.legend.style.top = this.heatMapSize.h  + 2*this.LayoutProperties.Padding + 'px';
							
							
							
								
							
							this.editorButton.style.top = ((legendHeight - editorButtonHeight)>>1) + "px" ;
							this.editorButton.style.bottom = "";
							if(this.props.showEditor){
								legendWidth -= this.LayoutProperties.LegendMenuEditorWidth;
							}
							var sizeT = {w:0, h:0}, sizeL = {w:0, h:0}, sizeSize = {w:0, h:0},
								tickCount, padding,
								bandWidth, bandHeight;
							if(this.props.sizeMetricEnabled){
								var sizeTitle = "<span style='font-weight: bold'>" + rsl + ":</span>";
								var vld = this.checkMetricValid(this.sizeMetricIndex),
									mn = this.getMetricName(this.sizeMetricIndex);
								if(this.hasNegativeSizeValue){
									mn = "Absolute value of " + mn;
								}
								if(isNaN(this.smin)){
									this.smin = 0;
									
								}
								
								if(isNaN(this.smax))
									this.smax = 0;
								
								
									


								var sizeLabel = "<div>" + (vld ? this.nf.formatByMask(sfs, this.smin) : "0")
												+ " < " + "</div>"
                                                + "<div class='heatmap-flex'>" + mn + "</div>"
                                                + "<div>" + " < "
												+ (vld ? this.nf.formatByMask(sfs, this.smax) : "0") + "</div>";
								
								
								
								this.sizeLegendTitle.innerHTML = sizeTitle;
								
								this.sizeLegendLabel.innerHTML = sizeLabel;
								
								
                                sizeSize = {w:Math.max(this.sizeLegendTitle.offsetWidth, this.sizeLegendLabel.offsetWidth), h: this.sizeLegendTitle.offsetHeight};
							}else{
								this.sizeLegend.style.display = "none";
							}
							if(this.props.colorMetricEnabled){
								var colorTitle;
								if( this.props.sizeMetricEnabled )
									colorTitle = rcl + ": " + "<span style='font-weight:normal;'>"
												 + this.getMetricName(this.colorMetricIndex)+ "</span>";
								else
									colorTitle = "<span style='font-weight:bold'>"
												 + this.getMetricName(this.colorMetricIndex)+ "</span>";
								tickCount = this.LayoutProperties.LegendTickCount;
								if(isNaN(this.cmin) || this.cmin >= this.cmax) {
									tickCount = 1;
								}
								this.legendTickCount = tickCount;
								
								bandWidth = Math.min(this.LayoutProperties.LegendMaxBandWidth, this.LayoutProperties.LegendWidthPercent*(legendWidth-sizeSize.w));
								padding = Math.floor((legendWidth - sizeSize.w - bandWidth)/3);
								var pd = this.renderTickLabels(bandWidth, tableHeight, tickCount);
								if(padding >= this.LayoutProperties.LegendMinPadding + pd.l + pd.r){
									bandWidth += pd.l + pd.r;
									padding -= ((pd.l + pd.r)>>1);
								}
								else if(padding < this.LayoutProperties.LegendMinPadding){
									padding = this.LayoutProperties.LegendMinPadding;
									var temp = ((legendWidth-3*padding)>>1);
									if(temp > sizeSize.w){
										bandWidth = legendWidth - 3*padding - sizeSize.w;
									}else{
										sizeSize.w = temp;
										bandWidth = sizeSize.w;
									}
								}
								bandHeight = Math.min(Math.floor(bandWidth/this.LayoutProperties.LegendBandAspect), Math.floor(legendHeight/3)) - this.LayoutProperties.LegendBottomPadding;
								this.colorLegend.style.display = "";
								
								this.colorLegendTitle.innerHTML = colorTitle;
							}else{
								padding = ((legendWidth - sizeSize.w)>>1);
								this.colorLegend.style.display = "none";
							}
							if(this.props.sizeMetricEnabled){
								this.sizeLegend.style.left = padding + 'px';
								this.sizeLegend.style.width = sizeSize.w + this.LayoutProperties.LegendGutter + 2*this.LayoutProperties.Padding + 'px';
								
								this.sizeLegend.style.height = legendHeight + 'px';
								
								
							}
							else{
								this.sizeLegend.style.left = '0px';
								this.sizeLegend.style.width = '0px';
								this.sizeLegend.top =  '0px';
								this.sizeLegend.style.height = '0px';
								this.sizeLegendLabel.style.marginTop = '0px';
								padding = ((legendWidth - bandWidth)>>1);
							}

							if(this.props.colorMetricEnabled){
								
								if (this.props.sizeMetricEnabled)
									this.colorLegend.style.left = sizeSize.w + 2*padding + 'px';
								else
									this.colorLegend.style.left = sizeSize.w + padding + 'px';
								this.colorLegend.style.width = bandWidth + 'px';
								this.colorLegend.style.height = legendHeight + 'px';


								
                                sizeT = {w:this.colorLegendTitle.offsetWidth, h:this.colorLegendTitle.offsetHeight};
								var tableHeight = legendHeight - bandHeight - sizeT.h - 2*this.LayoutProperties.LegendBottomPadding;
								
								this.colorLegendLabel.style.width = bandWidth + 'px';
								this.colorLegendLabel.style.height = tableHeight + 'px';

								this.colorLegendBand.width = bandWidth;
								this.colorLegendBand.height = bandHeight + 10;  
								var pd = this.renderTickLabels(bandWidth, tableHeight, tickCount);
                                
                                this.colorTheme.tooltipInfo = null;
								
									
								
								
								this.legendBand = {x:pd.l, y:0, w:bandWidth-pd.r-pd.l, h:bandHeight};
                                this.colorLegendBand.parentNode.style.width = bandWidth + 'px';
                                this.colorLegendBand.parentNode.style.height= bandHeight + 'px';

								this.renderGradientBand(this.legendBand);
							}
						},
						renderTickLabels: function renderLabel(w, h, t){
							var count = t + 1;
							var p = this.colorLegendLabel.firstChild.firstChild,
								nodes = p.childNodes,
								curCount = nodes.length,
								lastNode = p.lastChild,
								diff = curCount - count,
								cfs = this.getFormatString(this.colorMetricIndex);
							lastNode.style.display = "";
							lastNode.style.width = "";
							lastNode.style.textAlign = "center";
							if(diff < 0){
								for(var i = 0; i < Math.abs(diff); i++){
									var node = lastNode.cloneNode(true);
									p.insertBefore(node, lastNode.nextSibling);
									lastNode = node;
								}
							}
							else {
								for(var i = 0; i < diff; i++){
									if(t == 0 && i == diff-1){
										lastNode.style.display = "none";
										break;
									}
									
									p.removeChild(p.lastChild);
									
								}
							}
							p.firstChild.style.textAlign = "left";
							p.lastChild.style.textAlign = "right";
							var valid = true;
							if(isNaN(this.cmax) || isNaN(this.cmin)){
								valid = false;
							}
							for(var i = 0; i < count; i++){
								node = nodes[i];
								var v = "Null";
								if(valid){
									v = getNumberForTick.call(this, i);
								}
								node.innerHTML = '<div style="display: inline-block; overflow: hidden; text-overflow: ellipsis; max-width: 100%; white-space: nowrap;">' + this.nf.formatByMask(cfs, v) + '</div>';
								if(this.props.legendRounded){

								}
							}
							var firstV = p.firstChild.innerHTML,
								lastV = p.lastChild.innerHTML,
								
								
                                fSize = {w:p.firstChild.firstChild.offsetWidth, h:p.firstChild.firstChild.offsetHeight};
                                lSize = {w:p.lastChild.firstChild.offsetWidth, h: p.lastChild.firstChild.offsetHeight};
								left = Math.min(w/count, fSize.w)>>1,
								right = Math.min(w/count, lSize.w)>>1;

							return {l:left, r:right};

						},
						renderGradientBand: function renderBand(frame){
							var x = frame.x, y = frame.y, w = frame.w, h = frame.h,
								ctx = this.colorLegendBand.getContext("2d");
							ctx.clearRect(x, y, w+2, h);
							var lingrad = ctx.createLinearGradient(x,y,w+x,y);
							lingrad.addColorStop(0,"#333333");
							var gradientInfo = this.colorTheme.getGradientFillInfo(this.cmin, this.cmax);
							var c = gradientInfo.c,
								r = gradientInfo.r,
								l = c.length;
							for(var i = 0; i < l; i++){
								lingrad.addColorStop(roundNumber(r[i], 2), getCSSColor(c[i]));
							}
							ctx.fillStyle = lingrad;
							createPath(x, y, w, h, 0, ctx);
							ctx.fill();
						},
						renderHilightedBand: function renderHighlightedBand(i){
							var frame = this.legendBand,
								info = this.colorTheme.tooltipInfo[i],
								x = frame.x, y = frame.y, w = frame.w, h = frame.h,
								ctx = this.colorLegendBand.getContext("2d");
							this.renderGradientBand(frame);
							this.selectedBandIndex = i;
							
							ctx.strokeStyle = "#FFFFFF";
							ctx.lineWidth = 2;
							ctx.strokeRect(info.r.x+x+1, y+1, info.r.w-1, h-3);
						},

						getTextSize: function gts(str, fontName, fontSize, isBold, isItalic) {
							this.textSpan.style = "";
							this.textSpan.style.fontFamily = fontName;
							this.textSpan.style.fontSize = isNaN(fontSize) ? fontSize : fontSize + 'px';
							this.textSpan.style.fontWeight = isBold ? "bold" : "normal";
							this.textSpan.style.fontStyle = isItalic ? "italic" : "normal";
							this.textSpan.innerHTML = str;
							var w = this.textSpan.offsetWidth,
								h = this.textSpan.offsetHeight;
							return {w:w, h:h};
						},


						reRender : function reRender() {
							if (this.model.err || this.model.eg) {
								
								
								return;
							}
                            if(this._super) {
                                    this._super();
                            }
						},

						useDefaultColorTheme: function(callback){
							var colorTheme = this.colorTheme,
								needsRefresh = false;
							if(colorTheme.useDefault == false){
								needsRefresh = true;
								colorTheme.isBlend = true;
								colorTheme.setDefaultDataProvider();
							}
							if (this.scaleFactor != 1) {
								needsRefresh = true;
								this.scaleFactor = 1;
							}

							
							function markUndelete (delDict) {
								for (var key in delDict) {
									var childDict = delDict[key];
									if (typeof childDict === "object") {
										if (Object.keys(childDict).length === 0) { 
											delete delDict[key];
										} else { 
											markUndelete(childDict);
										}
									} else if (childDict === delStatus.dftDel) { 
										needsRefresh = true;
										delDict[key] = delStatus.dftUnDel;
									} else if (childDict === delStatus.usrDel) { 
										needsRefresh = true;
										delete delDict[key];
									}
								}
							};
							markUndelete(this.props.deletedList); 
							this.loadDeleteStatus(this.root, this.props.deletedList);

							if(needsRefresh){
								colorTheme.tooltipInfo = null;
								this.refreshWidget();
							}
							if (callback) {
								callback();
							}
						},

						loadDeleteStatus: function (node, delDict) {
							if (!node.entityChildren) { 
								if (delDict === delStatus.dftDel || delDict === delStatus.usrDel) {
									node.deleted = true;
								} else { 
									delete node.deleted;
								}
								return;
							}
							
							if ((!delDict || Object.keys(delDict).length === 0) && !node.hasChildDeleted) { 
								return;
							}
							
							var children = node.entityChildren;
							for (var i = 0; i < children.length; i++) {
								var child = children[i];
								var name = this.getEntityDisplayName(child);
								var thisDict = delDict && delDict[name];
								this.loadDeleteStatus(child, thisDict);
							}
						},

						useSavedColorTheme:function(callback){
							var colorTheme = this.colorTheme,
								needsRefresh = false;
							if(colorTheme.useDefault == true){
								needsRefresh = true;
								var propValue = this.model.vp;
								if(propValue){
									colorTheme.isBlend = ((propValue.blc === undefined || propValue.blc == "true") ? true:false);
								}
								if(propValue.gradientColors && propValue.bandColors){
									colorTheme.createDataProviderFromString(propValue.gradientColors, propValue.bandColors);
								}
								colorTheme.useDefault = false;
							}
							if (this.scaleFactor != 1) {
								needsRefresh = true;
								this.scaleFactor = 1;
							}

							
							function markDelete (delDict) {
								for (var key in delDict) {
									var childDict = delDict[key];
									if (typeof childDict === "object") {
										if (Object.keys(childDict).length === 0) { 
											delete delDict[key];
										} else { 
											markDelete(childDict);
										}
									} else if (childDict === delStatus.dftUnDel) { 
										needsRefresh = true;
										delDict[key] = delStatus.dftDel;
									} else if (childDict === delStatus.usrDel) { 
										needsRefresh = true;
										delete delDict[key];
									}
								}
							};
							markDelete(this.props.deletedList); 
							this.loadDeleteStatus(this.root, this.props.deletedList);

							if(needsRefresh){
								colorTheme.tooltipInfo = null;
								this.refreshWidget();
							}

							if (callback) {
								callback();
							}
						},

						getFormatString: function getFormatString(idx){
							var m = this.model,
								col = m.gvs.items[0] ? m.gvs.items[0].items:[],
								cnt = col.length;
							if(idx >= 0 && idx < cnt){
								var obj = col[idx];
								if(obj.formatstring !== undefined){
									return obj.formatstring.replace(/\'/g, '"');
								}
								return "";
							}
							return "";
						},

						checkMetricValid: function checkMetric(idx) {
							var str = "",
								m = this.model,
								col = m.ghs.chs.items,
								cnt = col.length,
								ml = col[0] ? col[0].items.length:0,
								coln = m.gts.col;
							if (idx < 0 || idx >= ml) return false;
							return true;
						},

						getMetricName: function getMetricName(idx){
							var str = "",
								m = this.model,
								col = m.ghs.chs.items,
								cnt = col.length,
								coln = m.gts.col;
							if(!this.checkMetricValid(idx)) return Fake_Metric_ID;
							for(var i = 0; i < cnt; i++){
								var index = col[i].items[idx].idx;
								var name = coln[i].es[index].n;
								str += name + " ";
							}
							return str.slice(0, str.length-1);
						},

						getEntityDisplayName: function getEntityDisplayName(e){
							var level = e.level,
								index = (e.index === undefined) ? e.indices[0] : e.index,
								st = 0, 
								str = "",
								ar = this.attSpan,
								rhs = this.model.ghs.rhs.items,
								rowHeaderData = rhs[index].items,
								att = this.model.gts.row[level];

							for(var i = 0; i < level; i++){
								st += ar[i];
							}
							str = "";
							for(var i = st; i < st + ar[level]; i++){
								var idx = rowHeaderData[i].idx;
								if(idx == -1)
									continue;
								str += att.es[idx].n + " ";
							}
							str = str.substring(0, str.length-1);
							return str;
						},

						previousTooltip: null,

                        previousSelected: null,


                        highlightEntity: function(box, entity) {
                                if(!entity || !box)
                                        return;
                                var w = this.canvasContainer.offsetWidth,
                                    h = this.canvasContainer.offsetHeight,
                                    size = entity.size,
                                    origin = this._scroller.origin,
                                    border = this.highlightBoxWidth,
                                    widgetRect = mstrmojo.dom.position(this.canvasContainer, true);

                                var container = {
                                        x: origin.x,
                                        y: origin.y,
                                        w: w,
                                        h: h
                                };

                                var canvasRect = {
                                        x: 0,
                                        y: 0,
                                        w: Math.ceil(this.heatMapSize.w * this.scaleFactor),
                                        h: Math.ceil(this.heatMapSize.h * this.scaleFactor)
                                };

                                
                                var rect = {
                                        x: size.x - border,
                                        y: size.y - border,
                                        w: size.w + 2*border,
                                        h: size.h + 2*border
                                };

                                var inters = rectIntersection(rect, canvasRect);

                                if(box == this.highlightBox){
                                        inters = rectIntersection(inters, container);
                                        this.previousHighlighted = entity;
                                }


                                if (isNaN(inters.x)) {
                                        return null;
                                }

                                
                                inters.x += (border - origin.x);
                                inters.y += (border - origin.y);
                                inters.w -= 2*border;
                                inters.h -= 2*border;


                                if(box == this.highlightBox){
                                        box.style.left = inters.x  - border + widgetRect.x + "px";
                                        box.style.top = inters.y - border  + widgetRect.y + "px";
                                        inters.x += widgetRect.x;
                                        inters.y += widgetRect.y;
                                }else {
                                        box.style.left = inters.x  - border + "px";
                                        box.style.top = inters.y - border + "px";
                                }
                                box.style.width = inters.w + "px";
                                box.style.height = inters.h + "px";
                                box.style.display = "block";


                                return inters;
                        },

						getLowestLevelRectangle: function(touch){
									target = document.elementFromPoint(touch.pageX, touch.pageY);
									var hiddenStack = [];
									
									while(!this.isLowestLevelRectangle(target)){
										target.style.display = "none";
										
										hiddenStack.push(target); 
										target = document.elementFromPoint(touch.pageX, touch.pageY);
									}
									while (hiddenStack.length) { 
										hiddenStack.pop().style.display = "block";
										
									}
									return target;
						},

						getEntityByTouch: function(touch,getLowest) {
                                
								var entity = null;
                                
                                var pageX = touch.pageX,
                                    pageY = touch.pageY;
console.log("#getEntityByTouch#" + "pageX:" + pageX + " " + "pageY:" + pageY);
								var target = document.elementFromPoint(pageX,pageY),
									backUps = [];

								if(!target) {
                                    console.log("target is null! at elementFromPoint.");
									return null;
                                }
                                
                                var lastLevel = target;
								while(!this.isRectangle(target) && target != this.domNode){
										backUps.push(target);
										target.style.visibility = 'hidden';
										target = document.elementFromPoint(pageX,pageY);
										if(!target || target == lastLevel)
											break ;
                                        lastLevel = target;
								}
                                
                                if(getLowest){
                                        lastLevel = target;
                                        while(target != this.domNode && target.tagName.toLowerCase() != 'img'){
                                                backUps.push(target);
                                                target.style.visibility = 'hidden';
                                                target = document.elementFromPoint(pageX,pageY);
                                                
                                                        
                                                if(!target || target == lastLevel)
                                                        break ;
                                                lastLevel = target;
                                        }
                                }

								var backLen = backUps.length;
								while(backUps.length > 0){
										var node = backUps.pop();
										node.style.visibility = 'visible';
								}
								if(!target) {
                                    console.log("target is null. At backups.");
									return null;
                                }
                                
								if(target != this.domNode){
										if (target.getAttribute('idx') && !getLowest) {
												var entity = this.getIdxObjectByTarget(target);
										}
										else{
                                                var rectPosition = mstrmojo.dom.position(this.canvas,true),
                                                offsetX = pageX - rectPosition.x,
                                                offsetY = pageY - rectPosition.y;
                                                var position = {x:offsetX,y:offsetY},
                                                    entity = this.canvasObject.getEntity(position);
                                                
                                                
                                                
										}
								} else {
                                        
                                }
                                
                                
								return entity;
						},
						getLabelForEntity : function(e) {
                            if(!this.props.showMetricValues || e.entityChildren !== undefined)
                                    return this.getEntityDisplayName(e);
							var	index = (e.index === undefined) ? e.indices[0] : e.index,
								st = '',
								si = this.sizeMetricIndex,
								ci = this.colorMetricIndex,
								mv = this.model.gvs.items,
								ml = mv[0].items.length,
								n, v,
                                dn = this.getEntityDisplayName(e);

							st = '<span style="font-weight:bold;">';
                            
                            if(dn !== '') {
                                st += dn + '<br>';
                            }
							if(si != ml){
								if(e.entityChildren !== undefined || this.aggregated){
									var tmp = this.aggFunctions[si];
									v = getSizeValue(e, this);
									if(isNaN(v)){
										v = '-';
									}
									else if(AggregationType.Cnt != tmp){
										fs = this.getFormatString(si);
										v = this.nf.formatByMask(fs, v);
									}
								}else{
									v = mv[index].items[si].v;
								}
                                if(v !== ''){
                                    st += v + '<br>';
                                }
							}
							if(e.entityChildren === undefined && ci != ml && si != ci){
								if(e.entityChildren !== undefined || this.aggregated){
									var tmp = this.aggFunctions[ci];
									v = getColorValue(e, this);
									if(isNaN(v)){
										v = '-';
									}
									else if(AggregationType.Cnt != tmp){
										fs = this.getFormatString(ci);
										v = this.nf.formatByMask(fs, v);
									}
								}else{
									v = mv[index].items[ci].v;
								}
                                if(v !== '') {
                                    st += v + '<br>';
                                }
							}
							st += '</span><span style="font-weight:normal;">';
							for(var i = 0; i < ml; i++){
								if(i == si) continue;
								if(i == ci && e.entityChildren === undefined && si != ci) continue;
								if(e.entityChildren !== undefined || this.aggregated){
									var tmp = this.aggFunctions[i];
									n = tooltipMacro(n, tmp);
									v = getAggValue(e, i, this);
									if(isNaN(v)){
										v = '-';
									}
									else if(AggregationType.Cnt != tmp){
										fs = this.getFormatString(i);
										v = this.nf.formatByMask(fs, v);
									}
								}else{
									v = mv[index].items[i].v;
								}
                                if(v !== '') {
                                    st += v;
                                    if(i !== ml-1){
                                        st += '<br>';
                                    }
                                }
							}
							st += '</span>';
							return st;
						},




						multiTap: true,
                        touchBegin: function(touch) {
                                
                                
                        },
						touchTap: function (touch) {
								if (touch.count >= 2) { 
										if (this.scaleFactor > 1) {
												this.scaleFactor = 1;
												this._scroller.offset.x.start = 0;
												this._scroller.offset.x.end = 0;
												this._scroller.offset.y.start = 0;
												this._scroller.offset.y.end = 0;
												this._scroller.scrollTo(0, 0, 0);
												this.refreshWidget();
										}
										return;
								}
								


								
								

								var target = touch.target;
                                
                                if(target == this.infoBoxPuppet){
                                    target = document.elementFromPoint(touch.pageX, touch.pageY);
                                }

								if(this.touchLegendTooltipValid(touch))
										this.showLegendTooltip(touch);
								else
										this.hideLegendTooltip();
								switch(target){
										case this.editorButton:{
												target.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
												var callback = function () {
														mstrmojo.VisHeatMapAnimation.animate(target, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
												};
												var that = this;
												setTimeout(function(){
														setTimeout(function(){
																try {
																		that.popupEditor(target);
																} catch (e) {
																} finally {
																		callback();
																}
														}, 0);
												}, 0);

												return; 
										}
										case this.deleteButton:{
                                                if (this.previousTooltip) {
                                                        var delDict = this.props.deletedList;
                                                        var delNode = this.previousTooltip;
                                                        
                                                        var keyStack = [];
                                                        var tempNode = delNode;
                                                        do { 
                                                                keyStack.push(this.getEntityDisplayName(tempNode));
                                                                tempNode = tempNode.parentEntity;
                                                        } while (tempNode.parentEntity);
                                                        var parentDict, key;
                                                        for (var i = keyStack.length - 1; i >= 0; i--) { 
                                                                parentDict = delDict;
                                                                key = keyStack.pop();
                                                                var tempDict = delDict[key];
                                                                if (!tempDict) {
                                                                        delDict[key] = {};
                                                                        tempDict = delDict[key];
                                                                }
                                                                delDict = tempDict;
                                                        }
                                                        this.deleteNode(delNode, delDict, parentDict, key);
                                                        this.hideInfoBox();
                                                        this.refreshWidget();
                                                        
                                                        var deleteTreeId = this.id + "-deleteTree";
                                                        var object = mstrmojo.all[deleteTreeId];
                                                        if (object) {
                                                                object.needRefresh = true;
                                                        }
                                                }
                                                this.previousTooltip = null;
                                                break;
										}

										case this.selectionHighlightBox: {
												this.doSelection(this.previousSelected);
												break;
										}

                                        case this.highlightBox: {
                                                this.hideInfoBox();
                                                var entity = this.previousHighlighted;
                                                if(this.hasSelector){
                                                        if(!this.previousHighlighted.entityChildren){
                                                                this.doSelection(entity);
                                                                
                                                        }
                                                }
                                                else if(this.hasLinkDrill){
                                                        this.doLinkDrill(entity);
                                                }
                                                break;
                                        }



										default:{
												
                                                if(this.isRectangle(target)){
                                                        if(this.hasSelector){
                                                                this.hideInfoBox();
                                                                var entity = this.getEntityByTouch(touch,true);
                                                                
                                                                this.doSelection(entity);
                                                                
                                                        }
                                                        else if(this.hasLinkDrill){
                                                                var entity = this.getEntityByTouch(touch);
                                                                this.doLinkDrill(entity);
                                                        }
                                                        else {
                                                                var entity = this.getEntityByTouch(touch);
                                                                this.showInfoBox(entity);
                                                                
                                                        }

														break;
												}
                                                
												else if(target.parentNode == this.infoBox){
                                                        this.hideInfoBox();
                                                }else{
														this.hideInfoBox();
                                                        if(!this.selectAll){
                                                                this.doSelection(this.previousSelected);
                                                        }
												}
										}
								}
						},

						isRectangle: function(target){
							if(this.canvasObject.domNode == target.parentNode || (target.parentNode && this.canvasObject.domNode == target.parentNode.parentNode) || target.tagName.toLowerCase() == 'img')
								return true;
							else
								return false;
						},
						isLowestLevelRectangle: function(target){
							if(target.getAttribute && target.getAttribute("idx") && !(target.innerHTML))
								return true;
							else
								return false;
						},

						doLinkDrill: function(entity){
								if(!entity)
									return;
								var actionObj = this.getActionObj({entity: entity, type:HYPERLINK_ACTION});
								if(actionObj){
										this.highlightEntity(this.selectionHighlightBox,entity);
										this.performAction([actionObj]);
								}
						},


						

						getActionObj: function(actionInfo) {
							if(!actionInfo)
								return null;
							var actionType = actionInfo.type,
								entity = actionInfo.entity,
								actionObj = null;

							switch(actionType){
									case HYPERLINK_ACTION: {
                                            
                                            var rowHeader = this.model.gts.row,
                                                rl = rowHeader.length,
                                                level = entity['level'],
                                                attrIndex;
                                            for(var i = 0; i <= level; i++){
                                                    var attr = rowHeader[i];
                                                    if(attr.lm){
                                                            for(var j = 0; j < attr.lm.length; j++)
                                                                if(attr.lm[j].links)break;
                                                            if(j != attr.lm.length){
                                                                    attrIndex = i;
                                                                    break;
                                                            }
                                                    }
                                            }
                                            var rowIndex = (entity.index === undefined) ? entity.indices[0] : entity.index,
                                                ghs = this.model.ghs;

											if(!isNaN(attrIndex)){
                                                    var attr = this.model.gts.row[attrIndex];
                                                        linkDrillNode = {};
                                                    linkDrillNode.titleInfo = attr;
                                                    linkDrillNode._e = attr.es[ghs.rhs.items[rowIndex].items[attrIndex].idx];
                                                    actionObj = {at:actionType, k: this.getModelKey(), node: linkDrillNode};
                                                    break;
                                            }

											
											index = this.firstColLinkDrillIndex;
											if(!isNaN(index)){
													var metricH = this.model.gts.col[0],
														metric = metricH.es[index],
														lm = metricH.lm[index];
													if(lm && lm.links){
														linkDrillNode = {};
														linkDrillNode.titleInfo = metricH;
														linkDrillNode.mix = index;
														actionObj = {at: actionType, k: this.getModelKey(), node: linkDrillNode};
													}
                                                    break;
											}

											break;
									}

							case SELECTOR_ACTION: {
                                    var entity = actionInfo.entity,
                                        anchor = actionInfo.anchor;
									if(!entity || !anchor){
											
											break;
									}

									if(entity){
											var m = this.model,
											rown = m.gts.row, 
											rl = rown.length,
											rhs = m.ghs.rhs.items,
											index = (entity.index === undefined) ? entity.indices[0] : entity.index,
											row = rhs[index].items,
											selectorObjects = [];
											for(var i = 0; i < rl; i++){
													var att = rown[i],
													sc = att.sc;
													if(att.otp != -1 && sc !== undefined){
															var ix = row[i].idx,
															elementId = att.es[ix].id,
															
															
															es = att.es[ix].n,
															eid;
															if (!elementId || elementId.substring(0, 1) === "D") {
																	
																	continue;
															};
															if(sc.all != 'false' && sc.all != false && actionInfo.needSelectAll)
																eid = EID_SELECTALL;
															else
																eid = att.es[ix].id;
															selectorObjects.push({ 
																	
																	
																	
																	sc: sc,
																	es: es,
																	eid: eid
															});
													}
                                            }
                                            actionObj = {at:actionType, k:this.getModelKey(), scObjList: selectorObjects,anchor:anchor};
									}


									break;
							}
                            
							case INFOWINDOW_ACTION: {
									var entity = actionInfo.entity,
									anchor = actionInfo.anchor;
									if(!entity || !anchor){

											break;
									}

									if(entity){
											var m = this.model,
											rown = m.gts.row, 
											rl = rown.length,
											rhs = m.ghs.rhs.items,
											index = (entity.index === undefined) ? entity.indices[0] : entity.index,
											row = rhs[index].items,
											selectorObjects = [];
											for(var i = 0; i < rl; i++){
													var att = rown[i],
													sc = att.sc;
													if(att.otp != -1 && sc !== undefined){
															var ix = row[i].idx,
															elementId = att.es[ix].id,
															
															
															es = att.es[ix].n,
															eid;
															if (!elementId || elementId.substring(0, 1) === "D") {
																	
																	continue;
															};
															if(sc.all != 'false' && sc.all != false && actionInfo.needSelectAll)
																eid = EID_SELECTALL;
															else
																eid = att.es[ix].id;
															selectorObjects.push({ 
																	
																	
																	
																	sc: sc,
																	es: es,
																	eid: eid
															});
													}
											}
													actionObj = {at:actionType, k:this.getModelKey(), scObjList: selectorObjects, anchor: anchor};
									}


									break;
							}
									default: {

											break;
									}

							}
							return actionObj;
						},
						getModelKey: function(){
							return this.model && this.model.k;
						},

						deleteNode: function (node, delDict, parentDict, key) { 
                            
                            if(!(node.size && node.size.w && node.size.h)){
                                return ;
                            }
							if (!node.entityChildren) { 
								node.deleted = true;
								if (parentDict && key) {
									if (delDict === delStatus.dftUnDel || delDict === delStatus.dftDel) { 
										parentDict[key] = delStatus.dftDel;
									} else { 
										parentDict[key] = delStatus.usrDel;
									}
								}
								return;
							} else {
								parentDict = delDict;
								for (var index in node.entityChildren) {
									var thisChild = node.entityChildren[index];
									key = this.getEntityDisplayName(thisChild);
									var thisDict = parentDict[key];
									if (!thisDict) {
										parentDict[key] = {};
										thisDict = parentDict[key];
									}
									this.deleteNode(thisChild, thisDict, parentDict, key);
								}
							}
						},

                        
						toggleSelectAll: function(entity){
                                var sc = this.model.gts.row[entity.level].sc;
                                if((sc && sc.all != 'false' && sc.all != false) || !this.hasGridTarget){
                                        if(this.selectAll)
                                                this.selectAll = false;
                                        else
                                                this.selectAll = true;
                                        return true;
                                }
                                return false;
						},
						doSelection: function(entity){
							if(!entity)
								return ;
							if(entity == this.previousSelected){
                                
                                if(!this.toggleSelectAll(entity))
                                        return;

                                
								var anchor = this.selectionHighlightBox,
                                    actionInfo = {entity: entity, type:SELECTOR_ACTION, needSelectAll:this.selectAll, anchor:anchor};
							        actionObject = this.getActionObj(actionInfo);
								if(this.selectAll){
									
									this.selectionHighlightBox.style.display = "none";
                                    delete actionObject.anchor;
                                }
								else
									this.highlightEntity(this.selectionHighlightBox,entity)
								this.performAction([actionObject]);
								
							}
							else{
								this.selectAll = false;
								var anchor = this.selectionHighlightBox,
                                    actionInfo = {entity: entity, type:SELECTOR_ACTION, needSelectAll:this.selectAll, anchor:anchor};
								this.previousSelected = entity;
								this.highlightEntity(this.selectionHighlightBox,entity);
							    var actionObject = this.getActionObj(actionInfo);
								this.performAction([actionObject]);
								
							}
						},

						getObjectByIdx: function (idx) {
							if (idx) {
								var indexArray = idx.split(":");
								var obj = this.root;
								for (var i = 0; i < indexArray.length; i++) {
									obj = obj.entityChildren[indexArray[i]];
								}
								return obj;
							}
							return null;
						},


						toggleDeleteButton: function () {
                            if(!this.infoBox)
                                    return;
							
								
								
							
								
								

							if (this.props.delButtonEnabled) {
								this.deleteButton.style.display = "none";
                                this.props.delButtonEnabled = false;
							} else {
								this.deleteButton.style.display = "block";
                                this.props.delButtonEnabled = true;
							}
						},


						editorDialog: null,  


						popupEditor: function (anchor) {
                                this.hideInfoBox();
                                var heatmapId = this.id;
                                var deleteTreeId = heatmapId + "-deleteTree";
                                var editorId = heatmapId + "-editor";
								var that = this;

								var defaultSelectionStatus = 0;
								if (this.props.delButtonEnabled) {
									defaultSelectionStatus = 1;
								}
                                var strSettings = mstrmojo.desc(7831, 'Settings'),
                                    strDeletedItems = mstrmojo.desc(10081, 'Deleted Items'),
                                    strRefresh = mstrmojo.desc(10378, 'REFRESH'),
                                    strRTSC = mstrmojo.desc(10082, 'Refresh to saved configuration'),
                                    strRTDC = mstrmojo.desc(10083, 'Refresh to default configuration'),
                                    strApply = mstrmojo.desc(10379, 'APPLY'),
                                    strDelete = mstrmojo.desc(10380, 'DELETE'),
                                    strEnableDelete = mstrmojo.desc(10085, 'Enable Delete'),
                                    strRestore = mstrmojo.desc(10084, 'Please select elements that you want to restore'),
                                    strButtonCancel = mstrmojo.desc(221, 'Cancel'),
                                    strButtonApply = mstrmojo.desc(134, 'Apply');


								var prop = {
									anchor: this.editorButton,
									title: "Heat Map",
									id: editorId,
									anchorOrientation: "h",
									width: this.LayoutProperties.EditorDialogWidth + 'px',
                                    
								    contentMaxHeight: this.LayoutProperties.DeletedListHeight,
									panels: [{
										
                                        title: strSettings,
										scriptClass: "mstrmojo.VisHeatMapPopupPanel",
                                        width: "100%",
									    height: "100%",
										children:[
										       {
										    	   scriptClass: 'mstrmojo.Label',
											       
                                                   text: strRefresh,
                                                   cssDisplay: "-webkit-box",
                                                   cssClass: "heatmap-gray-label"
                                                   
										       },
										       {
										    	   scriptClass: 'mstrmojo.VisHeatMapTree',
                                                   showIndicators: false,
										    	   isSelectable: false,
										    	   cssClass: "simple-tree",
										    	   cssText: "padding-left:15px;padding-right:15px;",
										    	   buttonNodeCss: "",
										    	   items: [
										    	           {
										    	        	   
                                                               n: strRTSC,
										    	        	   buttonNodeWidget: {
										    	        		   scriptClass: 'mstrmojo.Button',
																   
                                                                   text: strApply,
																   cssClass: "heatmap-apply-button",
										    	        		   onclick: function () {
                                                                       that.isUsingSavedColorTheme = true;
                                                                       that.isUsingDefaultColorTheme = false;
															    	   var node = this.domNode;
															    	   node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
															    	   that.hideInfoBox();
															    	   that.hideLegendTooltip();

															    	   
															    	   
															    	   that._scroller.offset.x.start = 0;
															    	   that._scroller.offset.x.end = 0;
															    	   that._scroller.offset.y.start = 0;
															    	   that._scroller.offset.y.end = 0;
															    	   that._scroller.scrollTo(0, 0, 0);

															    	   var callback = function () {
															    		   mstrmojo.VisHeatMapAnimation.animate(node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
															    	   };
															    	   setTimeout(function () {
														    		   		setTimeout(function () {
														    		   			that.useSavedColorTheme(callback);
														    		   			var object = mstrmojo.all[deleteTreeId];
																		    	if (object) {
																		    		object.needRefresh = true;
																		    	}
														    		   		}, 0);
														    		   },0); 
										    	        		   }
										    	        	   }
										    	           },
										    	           {
										    	        	   
                                                               n: strRTDC,
										    	        	   buttonNodeWidget: {
										    	        		   scriptClass: 'mstrmojo.Button',
																   
                                                                   text: strApply,
																   cssClass: "heatmap-apply-button",
										    	        		   onclick: function () {
                                                                       that.isUsingSavedColorTheme = false;
                                                                       that.isUsingDefaultColorTheme = true;
															    	   var node = this.domNode;
															    	   node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
															    	   that.hideInfoBox();
															    	   that.hideLegendTooltip();

															    	   
															    	   
															    	   that._scroller.offset.x.start = 0;
															    	   that._scroller.offset.x.end = 0;
															    	   that._scroller.offset.y.start = 0;
															    	   that._scroller.offset.y.end = 0;
															    	   that._scroller.scrollTo(0, 0, 0);

															    	   var callback = function () {
															    		   mstrmojo.VisHeatMapAnimation.animate(node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
															    	   };
															    	   setTimeout(function () {
														    		   		setTimeout(function () {
														    		   			that.useDefaultColorTheme(callback);
														    		   			var object = mstrmojo.all[deleteTreeId];
																		    	if (object) {
																		    		object.needRefresh = true;
																		    	}
														    		   		}, 0);
														    		   }, 0); 

															       }
										    	        	   }
										    	           }
										    	   ]
										       },
										       {
										    	   scriptClass: 'mstrmojo.Label',
											       
                                                   text: strDelete,
                                                   cssDisplay: "-webkit-box",
                                                   cssClass: "heatmap-gray-label"
                                                   
										       },
										       {
										    	   scriptClass: 'mstrmojo.VisHeatMapTree',
										    	   isSelectable: true,
										    	   cssClass: "simple-tree",
										    	   cssText: "margin-left:15px;margin-right:15px;",
                                                   showIndicators: false,
										    	   defaultSelectionStatus: defaultSelectionStatus,
										    	   items: [
										    	           {
										    	        	   
                                                               n: strEnableDelete,
										    	        	   itemFunction: function () {
																		that.toggleDeleteButton();
															   }
										    	           }
										    	   ]
										       },
										]
									}, {
										
                                        title: strDeletedItems,
										scriptClass: "mstrmojo.VisHeatMapPopupPanel",
                                        cssText: "position: relative",
										
										
                                        
                                        
                                        width: "100%",
                                        
										naviAction: function () {
											var object = mstrmojo.all[deleteTreeId];
									    	if (object) {
									    		object.refresh();
									    	}
										},
										children:[
										       {
										    	   scriptClass: "mstrmojo.Box",
										    	   cssText: "padding-left:16px;padding-right:16px; maxHeight:" + parseInt(this.LayoutProperties.DeletedListHeight * 0.89) + 'px',
										    	   children: [
															{
																scriptClass: "mstrmojo.VisHeatMapTree",
																height: "100%",
																heightLimit: parseInt(this.LayoutProperties.DeletedListHeight * 0.89),
                                                                showIndicators: true,
                                                                showScrollbars: true,
																id: deleteTreeId,
																itemDisplayField: "label",
																itemChildrenField: "entityChildren",
																draggable:  true,
																showRoot: true,
																
                                                                rootText: strRestore,
																itemIncludeFunction: function (item) {
																	if (item && (item.deleted || item.hasChildDeleted)) {
																		return true;
																	} else {
																		return false;
																	}
																},

													            apply: function (callback) {
													            	var itemFunction = function () {
																		if (this.selectionStatus === 1 && this.dataProvider && this.dataProvider.deleted) {
																			this.dataProvider.deleted = false;
																			
																			var tempNode = this.dataProvider;
																			if (!tempNode.entityChildren) {
																				var keyStack = [];
																				while (tempNode.parentEntity) {
																					keyStack.push(that.getEntityDisplayName(tempNode));
																					tempNode = tempNode.parentEntity;
																				}
																				var delDict = that.props.deletedList;
																				while (keyStack.length > 1) {
																					delDict = delDict[keyStack.pop()];
																				}
																				var key = keyStack.pop(); 
																				if (delDict[key] === delStatus.dftDel) {
																					delDict[key] = delStatus.dftUnDel;
																				} else {
																					delete delDict[key];
																				}
																			}
																		}
																	};
													            	var iterator = function (item, itemFunction) {
													            		itemFunction.apply(item);
													            		if (!item.childTree) {
													            			return;
													            		}
													            		for (var i = 0; i < item.childTree.length; i++) {
													            			var subItem = item.childTree[i];
													            			iterator(subItem, itemFunction);
													            		}
													            	};
													            	iterator(this, itemFunction);
													            	that.refreshWidget();
                                                                    var tree = this;
                                                                    window.setTimeout(function(){
                                                                                    
                                                                                    tree.needRefresh = true;
                                                                                    tree.refresh();

                                                                                    if (callback) {
                                                                                        callback();
                                                                                    }
                                                                    },50);
													            },

																dataProvider: that.root,

																owner: that
													    	}

										    	   ]
										       },{
										    		scriptClass: "mstrmojo.Box",
										    		cssText: "background-color:whiteSmoke; position:relative; bottom:0px;font:12pt Roboto,Regular;text-align:center;vertical-align:middle;line-height:55px;border-top: 1px solid rgba(34, 34, 34, 0.18);",
										    		height: parseInt(this.LayoutProperties.DeletedListHeight * 0.11) + 'px',
                                                    
										    		width: "100%",
										    		children: [
										    		           {
											    	        		   scriptClass: 'mstrmojo.Button',
																       
                                                                       text: strButtonCancel,
																       cssClass: "heatmap-tree-button",
																       cssDisplay: "inline-block",
																       cssText: "border-right: 1px solid rgba(34, 34, 34, 0.18); position: absolute; left:0px; top: 0px; height:100%;",
																       width: "49.5%",
																       onclick: function () {
																    	   var node = this.domNode;
																    	   node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
																    	   mstrmojo.VisHeatMapAnimation.animate(node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
																    	   setTimeout(function() { 
																    		   mstrmojo.all[editorId].close();
																    		   }, 100);
																       }
										    		           },
										    		           {
										    	        		   scriptClass: 'mstrmojo.Button',
															       
                                                                   text: strButtonApply,
															       cssClass: "heatmap-tree-button",
															       cssDisplay: "inline-block",
															       cssText: "position: absolute; right:0px; top:0px; height: 100%",
															       width: "50.5%",
															       postBuildRendering: function () {
															    	   mstrmojo.all[deleteTreeId].register(this);
															       },
															       notify: function (enabled) {
															    	   this.set("enabled", enabled);
															    	   
															       },
															       onclick: function () {
															    	   var node = this.domNode;
															    	   node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
															    	   that.hideInfoBox();
															    	   var callback = function () {
															    		   mstrmojo.VisHeatMapAnimation.animate(node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
															    	   };
															    	   setTimeout(function () {
															    		   setTimeout(function () {
															    			   mstrmojo.all[deleteTreeId].apply(callback);
															    		   }, 0);
															    	   }, 0); 
															    	   
															       }
										    		           }
										    		]
										    	}
										]
									}]
								};
								this.editorDialog = mstrApp.showDialog(prop,'HeatMapEditor'); 
						},

						showWaitIcon: function (delay){
							

                                var w = this.waitIcon;
                                w.style.display = '-webkit-box';
                                w.style.left = '0px';
                                w.style.top = '0px';
                        },
						hideWaitIcon: function (){
							
                                var w = this.waitIcon;
                                w.style.left = '-100000px';
                                w.style.top = '-100000px';

						},

						clearChildren: function(node) {
							var firstChild;
							if(!node)
								return;
							while(firstChild = node.firstChild)
								node.removeChild(firstChild);
						},

                        calculateValuesInTree: function() {
							var ml = this.model.gvs.items[0] ? this.model.gvs.items[0].items.length:0;
							clearMaxMinValues.call(this);
							setShow(false, false, true, true, this.root, this, ml+1);
                        },

						refreshWidget: function () {
							

                            this.showWaitIcon();
                            var that = this;
                            var refresh = function(){
                                    that.calculateValuesInTree();
                                    getLegendMaxMin.call(that);

                                    layoutEntities.call(that)
                                    that.renderRectangles()

                                    that.renderLegend()

                                    var ps = that.previousSelected;
                                    if(ps){
                                            if(ps.deleted){
                                                    that.selectionHighlightBox.style.display = 'none';
                                            }else if(!that.selectAll){
                                                    that.highlightEntity(that.selectionHighlightBox, that.previousSelected);
                                            }
                                    }
                                    that.hideWaitIcon();
                            };
                            
                            window.setTimeout(refresh,10);
                            
                                

                        },


						hideInfoBox: function () {
							
							
							
							
							
							
                            if(!this.infoBox)
                                    return;
                            this.infoBox.style.zIndex = "-50";
                            this.infoBox.style.opacity = 0;
                            
                                    
                                    
                            
                            
                            
							
							
									
							
									
							
									
							
							

							
							
							
							this.previousTooltip = null;
						},

						getIdxObjectByTarget: function (target) {
							var ancestor = mstrmojo.dom.findAncestorByAttr(target, "idx", true, this.domNode);
							var idx = ancestor && ancestor.value;
							if (!idx) {
								return null;
							}
							var idxObject = this.getObjectByIdx(idx);
							return idxObject;
						},

						showInfoBox: function (entity) {
                                
                            if(!entity)
                                    return;
                            if(!this.infoBox)
                                    this.createInfoBox();

							var idxObject = entity;

							if (idxObject === this.previousTooltip) {
								
								return;
							}
							this.previousTooltip = idxObject;
                            if(this.infoBox.style.display != "block")
                                    this.infoBox.style.display = "block";
                            this.infoBox.style.zIndex = "75";
                            this.infoBox.style.opacity = 1;
							
							
							
							

							var	hBoxWidth = this.highlightBoxWidth,
								
								
                                domRect = mstrmojo.dom.position(document.body, true),
                                
								interRect = this.highlightEntity(this.highlightBox, idxObject);

							if (!interRect || isNaN(interRect.x)) {
								return;
							}

							
							this.deleteButton.style.left = interRect.x + "px";
							this.deleteButton.style.top = interRect.y + "px";

							
							this.tooltipBox.style.width = "";
							this.tooltipBox.innerHTML = getTooltip(idxObject, this);





							
							var anchorBox = {
								x: interRect.x - hBoxWidth,
								y: interRect.y - hBoxWidth,
								w: interRect.w + hBoxWidth * 2,
								h: interRect.h + hBoxWidth * 2
							}; 
							
							this.triBox.style.display = "block";
							var anchorCenterX = anchorBox.x + (anchorBox.w>>1);
							var anchorCenterY = anchorBox.y + (anchorBox.h>>1);
							var triSize = this.triBox.offsetWidth * 0.717;


                            
                            var cNodes = this.tooltipBox.childNodes,
                                len = cNodes.length;
                            for(var i = 0; i < len; i++){
                                    var cInline = cNodes[i].childNodes;
                                    if(cInline[0].offsetWidth + cInline[1].offsetWidth + cInline[2].offsetWidth > cNodes[i].offsetWidth)
                                            cInline[0].className += ' heatmap-half-width';
                            }


							var tHeight = this.tooltipBox.offsetHeight;
							var tWidth = this.tooltipBox.offsetWidth;





							
							var matched = false;

							
							var xFit = ((anchorCenterX - (tWidth>>1)) > 0) && (anchorCenterX + (tWidth>>1)) < (domRect.w);
							var yFit = ((anchorCenterY - (tHeight>>1)) > 0) && (anchorCenterY + (tHeight>>1)) < (domRect.h);

							
							var canShiftPadding = 10; 
							function calcPosition (triBox, tooltipBox, deleteButton,  canShift) {
								if (canShift === undefined) {
									canShift = false; 
								}
								if (!matched && (canShift || yFit)) { 
									if (anchorBox.x - triSize - tWidth >= 0) { 
										matched = true;
										triBox.style.left = anchorBox.x - triSize + "px";
										tooltipBox.style.left = anchorBox.x - triSize - tWidth + "px";

										
										deleteButton.style.left = interRect.x + interRect.w + "px";
									} else if (anchorBox.x + anchorBox.w + triSize + tWidth <= domRect.w) { 
										matched = true;
										triBox.style.left = anchorBox.x + anchorBox.w + triSize + "px";
										tooltipBox.style.left = anchorBox.x + anchorBox.w + triSize + "px";
									}
									if (matched) { 
										var triTop = anchorCenterY;
										var tooltipTop = anchorCenterY - tHeight / 2;
										if (canShift) {
											if (tHeight + canShiftPadding * 2 > domRect.h) {
												matched = false; 
											} else {
												var upLimit = canShiftPadding;
												var downLimit = domRect.h - canShiftPadding - tHeight;
												if (tooltipTop < upLimit) { 
													tooltipTop = upLimit;
												} else if (tooltipTop > downLimit) { 
													tooltipTop = downLimit;
												}
											}
										}
										triBox.style.top = triTop + "px";
										tooltipBox.style.top = tooltipTop + "px";
									}
								}

								if (!matched && (canShift || xFit)) { 
									if (anchorBox.y - triSize - tHeight >= 0) { 
										matched = true;
										triBox.style.top = anchorBox.y - triSize + "px";
										tooltipBox.style.top = anchorBox.y - triSize - tHeight + "px";

										
										deleteButton.style.top = interRect.y + interRect.h + "px";
									} else if (anchorBox.y + anchorBox.h + triSize + tHeight <= domRect.h) { 
										matched = true;
										triBox.style.top = anchorBox.y + anchorBox.h + triSize + "px";
										tooltipBox.style.top = anchorBox.y + anchorBox.h + triSize + "px";
									}
									if (matched) { 
										var triLeft = anchorCenterX;
										var tooltipLeft = anchorCenterX - tWidth / 2;
										if (canShift) {
											if (tWidth + canShiftPadding * 2 > domRect.w) {
												matched = false; 
											} else {
												var leftLimit = canShiftPadding;
												var rightLimit = domRect.w - canShiftPadding - tWidth;
												if (tooltipLeft < leftLimit) { 
													tooltipLeft = leftLimit;
												} else if (tooltipLeft > rightLimit) { 
													tooltipLeft = rightLimit;
												}
											}
										}
										triBox.style.left = triLeft + "px";
										tooltipBox.style.left = tooltipLeft + "px";
									}
								}
							};

							
							
							calcPosition (this.triBox, this.tooltipBox, this.deleteButton, false);
							
							this.infoBox.style.display = 'block';
							if (!matched) { 
								anchorBox = {
										x: anchorCenterX,
										y: anchorCenterY,
										w: 0,
										h: 0
								};
								this.triBox.style.display = "none";
								triSize = 0;
								calcPosition (this.triBox, this.tooltipBox, this.deleteButton, true);
							}
							if (!matched) { 
								this.triBox.style.display = "none";
								this.tooltipBox.style.left = anchorCenterX - tWidth / 2 + "px";
								this.tooltipBox.style.top = anchorCenterY - tHeight / 2 + "px";
							}
							
							this.shadowBox.style.left = this.tooltipBox.style.left;
							this.shadowBox.style.top = this.tooltipBox.style.top;
							this.shadowBox.style.width = this.tooltipBox.offsetWidth + "px";
							this.shadowBox.style.height = this.tooltipBox.offsetHeight + "px";
							this.shelter.style.left = this.tooltipBox.style.left;
							this.shelter.style.top = this.tooltipBox.style.top;
							this.shelter.style.width = this.tooltipBox.offsetWidth + "px";
							this.shelter.style.height = this.tooltipBox.offsetHeight + "px";

                            
                            var span = this.tooltipBox.childNodes[0].childNodes[0];
                            var style = window.getComputedStyle(span,null);

                            

						},


						enableGlobalDismiss: function(){
								var touchManager = mstrmojo.touchManager;
								var heatMap = this;
								this._globalTouchListener = touchManager.attachEventListener("touchesBegin",
										this.id,
										function(evt){
                                                if(!evt || !evt.touch || !evt.touch.target)
                                                        return;
                                            var target = evt.touch.target,
                                                backgroundDiv1 = document.getElementsByClassName('mstrmojo-DocLayoutViewer-layout')[0],
                                                backgroundDiv2 = document.getElementsByClassName('mstrmojo-DocSubsection')[0];

                                            
											if(heatMap.infoBoxPuppet != target && !mstrmojo.dom.contains(heatMap.infoBox, target, true)){
                                                    heatMap.hideInfoBox();
                                            }
                                            
                                            if(target != backgroundDiv1 && target != backgroundDiv2)
                                                    return ;
                                            if(!this.selectAll)
                                                heatMap.doSelection(heatMap.previousSelected);
											
										}
								);
						},

						disableGlobalDismiss: function(){
								var touchManager = mstrmojo.touchManager;
								if(this._globalTouchListener){
										touchManager.detachEventListener(this._globalTouchListener);
										delete this._globalTouchListener;
								}
						},


						touchInfoBoxValid: function(touch) {
								var taget = touch.target;
								if(target.id == this.id+"-infobox") return true;
						},

						touchLegendTooltipValid: function touchValid(touch){
							var target = touch.target;
							if(target.id != this.id+'-color-legend-band') return false;
							var	frame = mstrmojo.dom.position(target, true),
								x = touch.clientX-frame.x,
								y = touch.clientY-frame.y,
								p = this.legendBand;
							if(x < p.x || x >= p.x + p.w - 1) {
								return false;
							}
							return true;
						},

						showLegendTooltip: function (touch) {
							var target = touch.target,
								frame = mstrmojo.dom.position(target, true),
								x = touch.clientX-frame.x,
								y = touch.clientY-frame.y,
								p = this.legendBand,
								idx;
							var ct = this.colorTheme;
							if(ct.tooltipInfo === undefined || ct.tooltipInfo === null){
								ct.createTooltipInfo(this.legendTickCount, p.w, this);
								this.selectedBandIndex = -1;
							}
							var i = ct.getTooltipInfo(x-p.x);
							if(i != this.selectedBandIndex){
								this.renderHilightedBand(i);
							}
							
							var t = this.colorTheme.tooltipInfo[i],
								cfs = this.getFormatString(this.colorMetricIndex),
								mn = this.getMetricName(this.colorMetricIndex),
								sign = (t.sign === undefined) ? " < " : " > ",
								str = "<div>" + this.nf.formatByMask(cfs, t.sv)
									  + sign + "</div>"
                                      + "<div class='heatmap-flex'>" + mn + "</div>"
                                      +"<div>" + sign
									  + this.nf.formatByMask(cfs, t.ev) + "</div>";
							
							
							this.legendTooltip.innerHTML = str;
							this.legendTooltip.style.borderColor = getCSSColor(t.c);
							
							
							this.legendTooltip.style.lineHeight = this.legendTooltip.style.height;
							this.legendTooltip.style.display = "-webkit-box";
                            var size = {w: this.legendTooltip.offsetWidth, h: this.legendTooltip.offsetHeight};
							var lc = mstrmojo.dom.position(this.colorLegend, true),
								cv = mstrmojo.dom.position(this.canvas, true), 
								tx = t.r.x+((t.r.w-size.w)>>1);
							if(tx < 0){
								tx = 0;
							}else if(tx > frame.w - size.w){
								tx = frame.w - size.w;
							}
							this.legendTooltip.style.left = tx + 'px';
							this.legendTooltip.style.top = -35 + 'px';
						},

						hideLegendTooltip: function () {
							if (this.selectedBandIndex === undefined || this.selectedBandIndex == -1) return;
							this.renderGradientBand(this.legendBand);
							this.selectedBandIndex = -1;
                            this.legendTooltip.style.left = '-100000px';
							
						},


						touchSelectBegin: function (touch) {
							if (touch.evt.ctrlKey) { 
								this.touchMultiBegin(touch);
								return;
							}
							var target = touch.target;
							if(!target) return;
                            this.lastTouchSelectTarget = target;
							if(this.touchLegendTooltipValid(touch)){
								this.showLegendTooltip(touch);
								this.hideInfoBox();
							}else{
								this.hideLegendTooltip();
								
                                var entity;
                                if(this.infoWindowMode){
                                        entity = this.getEntityByTouch(touch,true);
                                }else{
                                        entity = this.getEntityByTouch(touch);
                                }
								if(!entity)
									return;
								if (this.timer) {
									cleatTimeout(this.timer);
									this.timer = null;
								}
                                if(this.infoWindowMode){
                                        this.doSelection(entity);
                                }else{
                                        this.showInfoBox(entity);
                                        
                                }
							}
						},

						touchSelectMove: function (touch) {
							if (touch.evt.ctrlKey) {
								this.touchMultiMove(touch);
								return;
							}
							var target = touch.target;
							if(!target) return;
                            
                                    
							if(this.touchLegendTooltipValid(touch)){
								this.showLegendTooltip(touch);
								this.hideInfoBox();
							}else{
								this.hideLegendTooltip();
								
                                var entity;
                                if(this.infoWindowMode){
                                        entity = this.getEntityByTouch(touch,true);
                                }
                                else{
                                        entity = this.getEntityByTouch(touch);
                                }
								if(!entity)
									return;
								var that = this;
								if (this.timer) {
									clearTimeout(this.timer);
									this.timer = null;
								}
								
                                if(this.infoWindowMode){
                                        if(this.previousSelected != entity){
                                                this.doSelection(entity);
                                        }
                                }else{
                                        this.showInfoBox(entity);
                                        
                                }
							}
						},


						touchSelectEnd: function (touch) {
							if (touch.evt.ctrlKey) {
								this.touchMultiEnd(touch);
							}
							return;
						},


						initScroller: function (scroller) {
							scroller.attachEventListener('scrollMoved', this.id, function (evt) {
								this.hideInfoBox();
							});
                            scroller.attachEventListener('scrollDone', this.id, function (evt) {
                                    this.canvasObject.updateOffsets(scroller.origin.x, scroller.origin.y);
                            });
                        },


						multiTouch: true,

						touchMultiBegin: function (touch) {
							
							
							this.hideLegendTooltip();
							this.hideInfoBox();
                            
                            

							var touch1;
							var touch2;
							if (touch.evt.touches && touch.evt.touches.length == 2) {
								touch1 = touch.evt.touches[0];
								touch2 = touch.evt.touches[1];
							} else {
								touch1 = touch;
								touch2 = {pageX: 300, pageY:300};
							}
							var xDiff = touch1.pageX - touch2.pageX;
							var yDiff = touch1.pageY - touch2.pageY;
							this.initDiffDiff = xDiff * xDiff + yDiff * yDiff;
							this.initCenterX = ((touch1.pageX + touch2.pageX)>>1);
							this.initCenterY = ((touch1.pageY + touch2.pageY)>>1);
							this.initScrollX = this._scroller.origin.x;
							this.initScrollY = this._scroller.origin.y;

							this.relScaleFactor = 1;

							
							
						},

						touchMultiMove: function (touch) {
							
							var touch1;
							var touch2;
							if (touch.evt.touches && touch.evt.touches.length == 2) {
								touch1 = touch.evt.touches[0];
								touch2 = touch.evt.touches[1];
							} else {
								touch1 = touch;
								touch2 = {pageX: 300, pageY: 300};
							}
							var xDiff = touch1.pageX - touch2.pageX;
							var yDiff = touch1.pageY - touch2.pageY;
							var curDiffDiff = xDiff * xDiff + yDiff * yDiff;

							var curCenterX = ((touch1.pageX + touch2.pageX)>>1);
							var curCenterY = ((touch1.pageY + touch2.pageY)>>1);

							var scale = Math.sqrt(curDiffDiff / this.initDiffDiff);


							var offset = { 
								x: scale * (this.initCenterX + this.initScrollX) - curCenterX,
								y: scale * (this.initCenterY + this.initScrollY) - curCenterY
							};
							var transform = {scale: scale, offset: offset};

							this.relScaleFactor = scale;
                            if(this.relScaleFactor * this.scaleFactor >= this.maxScale && !this.oldTransform){
                                    this.oldTransform = transform;
                            }
							
							this.applyTransform(transform);
						},

						touchMultiEnd: function (touch) {
                                var finalScale = this.relScaleFactor * this.scaleFactor;
							if (finalScale < 1) {
								
                                var initTransform = {offset:{x:0,y:0}, scale: 1 / this.scaleFactor};
								this.relScaleFactor = initTransform.scale;
								this.applyTransform(initTransform, 500, this.postScale);
                            } else if(finalScale > this.maxScale){
                                    this.relScaleFactor = this.maxScale / this.scaleFactor;
                                    this.applyTransform(this.oldTransform, 500, this.postScale);
                                    delete this.oldTransform;
                            }else{
								this.postScale();
							}
						},

						relScaleFactor: 1,

						scaleFactor: 1,

                        applyTransform: function (transform, duration, callback) {
                                var scl = this._scroller;

                                if (duration === undefined) {
                                        duration = 0;
                                }
                                scl.scrollEl.style["webkitTransformOrigin"] = "left top";

                                scl.transform = "scale(" + transform.scale + "," + transform.scale + ")";
                                var scrollX = transform.offset.x,
                                    scrollY = transform.offset.y,
                                    scrollerOffsetScale = this.scaleFactor * this.relScaleFactor - 1,
                                    vOffsetEnd = this.heatMapSize.h * scrollerOffsetScale,
                                    hOffsetEnd = this.heatMapSize.w * scrollerOffsetScale;
                                scl.offset = {
                                        y: {
                                                start: 0,
                                                end: vOffsetEnd
                                        },
                                        x: {
                                                start: 0,
                                                end: hOffsetEnd
                                        }
                                };
                                this._scroller.scrollTo(scrollX, scrollY, duration);
                                if (callback) {
                                        var that = this;
                                        setTimeout(function () {callback.apply(that); that = null;}, duration);
                                }


                        },


						postScale: function () {
							delete this._scroller.transform;
							this._scroller.scrollTo(this._scroller.origin.x, this._scroller.origin.y, 0);
							this.scaleFactor *= this.relScaleFactor;
                            
                            if(this.scaleFactor > this.maxScale)
                                    this.scaleFactor = this.maxScale;
							this.refreshWidget();
						},


						destroy: function (skipCleanup) {
							this._super(skipCleanup);
							if (this.editorDialog) {
								
								this.editorDialog.destroy();
                                delete this.editorDialog;
							}
						}

					});
})();


(function() {

	mstrmojo.requiresCls("mstrmojo.Vis",
			"mstrmojo.VisChartUtils",
			"mstrmojo._TouchGestures",
			"mstrmojo._HasTouchScroller",
			"mstrmojo.color",
			"mstrmojo.array",
			"mstrmojo.css" );


	var browserSupportsHtml5 = true;

	var DISPLAY_MODE_AUTOMATIC = "0",
		DISPLAY_MODE_AREA = "1",
		DISPLAY_MODE_BUBBLE = "2";

	var MARKER_UNDEFINED = 0,
		MARKER_IMAGE = 1,
		MARKER_BUBBLE = 2;

	var SHAPE_FILE_UNDEFINED = 0,
		SHAPE_FILE_POLYGON = 1,
		SHAPE_FILE_POINT = 2;

	var THRESHOLD_UNDEFINED = 0,
		THRESHOLD_COLOR = 1,
		THRESHOLD_IMAGE = 2;

	var SIZE_MODE_AUTOMATIC = 0,
		SIZE_MODE_MANUAL = 1;
	
	
	var MAX_RATIO_UP_LIMIT = 1.0,
		MAX_RATIO_LOW_LIMIT = 0.01;
	
	var MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER = 0.3,
		MAX_SIZE_DEFAULT_RATIO_FOR_AUTOMATIC = 0.3,
		MAX_SIZE_DEFAULT_RATIO_FOR_MANUAL = 0.3;

	var HIGHLIGHT_MODE_NORMAL = 0,
		HIGHLIGHT_MODE_HOVER = 1,
		HIGHLIGHT_MODE_SELECTED = 2;

	var THEME_DARK = 0,
		THEME_LIGHT = 1;
		
	var DRILLING_ACTION = 1,
		SELECTOR_ACTION = 2,
		HYPERLINK_ACTION = 4;
		
	var ROW_AXIS = 1,
		COL_AXIS = 2;

	var DEFAULT_BG_COLOR = "#FFFFFF";

	var POLY_COLOR_NO_ALT_DARK_THEME = "RGBA(139,139,139,0.8)", 
		POLY_COLOR_NO_COLORBY_DARK_THEME = "RGBA(33,195,255,0.8)", 
		POLY_COLOR_NO_ALT_LIGHT_THEME = "RGBA(195,195,195,0.8)", 
		POLY_COLOR_NO_COLORBY_LIGHT_THEME = "RGBA(112,168,207,0.8)", 
		POLY_STROKE_COLOR_DARK_THEME = "#4C4C4C",
		POLY_STROKE_COLOR_LIGHT_THEME = "#FFFFFF",
		POLY_NORMAL_OPACITY = 0.8,
		POLY_ABOVE_BG_OPACITY = 0.7,
		POLY_UNDER_BUBBLE_OPACITY = 1,
		POLY_HOVER_OPACITY = 0.5,
		POLY_LINKDRILL_OPACITY = 0.5,
		POLY_SELECTED_OPACITY_WITHOUT_BG = 1,
		POLY_SELECTED_OPACITY_WITH_BG = 0.7,
		POLY_UNSELECTED_OPACITY = 0.5,
		POLY_SELECTED_HOVER_OPACITY_WITH_BG = 0.7,
		POLY_SELECTED_HOVER_OPACITY_WITHOUT_BG = 1,
		POLY_STROKE_COLOR_HOVER_DARK_THEME = "#FFFFFF",
		POLY_STROKE_COLOR_HOVER_LIGHT_THEME = "#000000",
		POLY_STROKE_COLOR_LINKDRILL_DARK_THEME = "#FFFFFF",
		POLY_STROKE_COLOR_LINKDRILL_LIGHT_THEME = "#000000",
		POLY_STROKE_COLOR_SELECTED_DARK_THEME = "#FFFFFF",
		POLY_STROKE_COLOR_SELECTED_LIGHT_THEME = "#000000",
		POLY_STROKE_COLOR_SELECTED_HOVER_DARK_THEME = "RGBA(0,0,0,0)",
		POLY_STROKE_COLOR_SELECTED_HOVER_LIGHT_THEME = "RGBA(0,0,0,0)",
	
		BUBBLE_COLOR_NO_COLORBY_DARK_THEME = "RGBA(33,195,255,0.8)", 
		BUBBLE_COLOR_NO_COLORBY_LIGHT_THEME = "RGBA(31,119,180,0.8)", 
		BUBBLE_STROKE_COLOR_DARK_THEME = "RGBA(129,129,129,0.8)", 
		BUBBLE_STROKE_COLOR_LIGHT_THEME = "RGBA(129,129,129,0.8)", 
		BUBBLE_NORMAL_OPACITY = 0.8,
		BUBBLE_HOVER_OPACITY = 0.5,
		BUBBLE_SELECTED_OPACITY = 1,
		BUBBLE_LINKDRILL_OPACITY = 0.8,
		BUBBLE_STROKE_COLOR_HOVER_DARK_THEME = "RGBA(129,129,129,0.8)", 
		BUBBLE_STROKE_COLOR_HOVER_LIGHT_THEME = "RGBA(129,129,129,0.8)", 
		BUBBLE_STROKE_COLOR_LINKDRILL_DARK_THEME = "RGBA(129,129,129,0.8)", 
		BUBBLE_STROKE_COLOR_LINKDRILL_LIGHT_THEME = "RGBA(129,129,129,0.8)", 
		BUBBLE_STROKE_COLOR_SELECTED_DARK_THEME = "RGBA(255,255,255,0.8)", 
		BUBBLE_STROKE_COLOR_SELECTED_LIGHT_THEME = "RGBA(0,0,0,0.8)", 
		BUBBLE_HIGHLIGHT_STROKE_COLOR_DARK_THEME = "#FFFFFF",
		BUBBLE_HIGHLIGHT_STROKE_COLOR_LIGHT_THEME = "#000000";
	

	
	var ERROR_MSG_FONT_COLOR_DARK_THEME = "#FFF",
		ERROR_MSG_FONT_COLOR_LIGHT_THEME = "#000";
	
	
	var RENDERING_TIME = 300;
	
	
	
	function isOwnEmpty(obj) {
		var name;
		for (name in obj) {
			if(obj.hasOwnProperty(name)) {
				return false;
			}
		}
		return true;
	}
	
	
	function getLighterColor(c) {
		
		var rgb = mstrmojo.color.hex2rgb(c);
		mstrmojo.array.forEach(rgb, function (v, idx) {
			
			rgb[idx] = Math.floor(v * 0.75);
		});

		return 'rgb(' + rgb.join(',') + ')';
	}

	
	function positionTooltip(tooltip, touchX, touchY) {
		var tooltipStyle = tooltip.style,
			translateValue = 'translate(' + touchX + 'px, ' + touchY + 'px)',
			translateValue3d = translateValue.replace('late(', 'late3d(').replace('px)', 'px, 0)');

		tooltipStyle.MozTransform = translateValue;
		tooltipStyle.msTransform = translateValue;
		tooltipStyle.webkitTransform = translateValue3d;
		tooltipStyle.transform = translateValue3d;
	}

	
	function inPoly(poly, px, py) {
		var npoints = poly.length, 
			inside = false,
			xnew,
			ynew,
			xold,
			yold,
			x1,
			y1,
			x2,
			y2,
			i;

		if (npoints / 2 < 3) { 
			return false;
		}

		xold = poly[npoints - 2];
		yold = poly[npoints - 1];

		for (i = 0; i < npoints; i = i + 2) {
			xnew = poly[i];
			ynew = poly[i + 1];

			if (xnew > xold) {
				x1 = xold;
				x2 = xnew;
				y1 = yold;
				y2 = ynew;
			} else {
				x1 = xnew;
				x2 = xold;
				y1 = ynew;
				y2 = yold;
			}
			if ((xnew < px) === (px <= xold) && ((py - y1) * (x2 - x1) < (y2 - y1) * (px - x1))) {
				inside = !inside;
			}

			xold = xnew;
			yold = ynew;
		}

		return inside;
	}
	
	
	function drawPoly(ctx, coordsArray, offset, strokeColor, strokeWidth, fillColor) {
		try {
			var offsetX = offset ? offset.x : 0,
				offsetY = offset ? offset.y : 0;
			
			var getPointAt = function(j){
				var offset = j%2  ? offsetY : offsetX;
				return pointsArray[j] + offset;
			};
			
			var i, j;
			for (i = 0; i < coordsArray.length; i++) {
				var pointsArray = coordsArray[i];

				ctx.beginPath();
				ctx.moveTo(getPointAt(0), getPointAt(1));

				for (j = 2; j < pointsArray.length - 1; j = j + 2) {
					var xx = getPointAt(j),
						yy = getPointAt(j + 1);

					ctx.lineTo(xx, yy);

				}
				
				
				var x = getPointAt(0),
					y = getPointAt(1),
					fillStyle = fillColor;
				
				ctx.lineTo(x, y);
				ctx.fillStyle = fillStyle;
				ctx.fill();
				ctx.strokeStyle = strokeColor;
				ctx.lineWidth = strokeWidth;
				ctx.stroke();
			}
		} catch (e) {
			
		}
	}

	
	function drawBubble(context, pt, offset, color, radius) {
		context.fillStyle = color;
		context.beginPath();
		context.arc(pt[0] + offset.x, pt[1] + offset.y, radius, 0, Math.PI * 2, true);
		context.closePath();
		context.fill();
	}

	
	function drawStroke(context, pt, offset, color, radius, strokeWidth) {
		context.strokeStyle = color;
		context.lineWidth = strokeWidth;
		context.beginPath();
		context.arc(pt[0] + offset.x, pt[1] + offset.y, radius, 0, Math.PI * 2, true);
		context.closePath();
		context.stroke();
	}

	
	function getShapeFileType(coords) {
		if (coords) {
			var elem;
			for (elem in coords) {
				if (coords.hasOwnProperty(elem)) {
					if (elem === "bgImage") {
						continue;
					}
					if (coords[elem][0]) {
						if (coords[elem][0].length === 2) {
							return SHAPE_FILE_POINT;
						} else if (coords[elem][0].length > 2) {
							return SHAPE_FILE_POLYGON;
						} else {
							return SHAPE_FILE_UNDEFINED;
						}
					} else {
						return SHAPE_FILE_UNDEFINED;
					}
				}				
			}
		} else {
			return SHAPE_FILE_UNDEFINED;
		}
		
	}


	
	function getPolygonCenter(pointsArr) {
		var sumX=0,
			sumY=0
			i;
		for (i=0; i<pointsArr.length; i++) {
			sumX = sumX + pointsArr[i];
			i++;
			sumY = sumY + pointsArr[i];
		}
		var centerX = sumX / (pointsArr.length/2),
			centerY = sumY / (pointsArr.length/2),
			center1 = [centerX, centerY]
			center2 = [];
		center2.push(center1);
		
		return center2;
	}
	
	
	function getCentroidOfPolygon(points) {
		if (points == null || points.length < 4) {
			return null;
		}

		var area = 0,
			len = points.length,
			i,
			px,
			py,
			p2x,
			p2y;

		for (i=0; i<len-2; i+=2) {
			px = points[i];
			py = points[i+1];
			p2x = points[i+2];
			p2y = points[i+3];
	
			area += (px * p2y - p2x * py);
		} 
		px = points[len-2];
		py = points[len-1];
		p2x = points[0];
		p2y = points[1];
		area += (px * p2y - p2x * py);
		area = Math.abs(area / 2.0);

		if (area <= 0) {
			return null;
		}

		var centroid = [0, 0];
		for (i=0; i<len-2; i+=2) {
			px = points[i];
			py = points[i+1];
			p2x = points[i+2];
			p2y = points[i+3];
			centroid[0] += ((px + p2x) * (px * p2y - p2x * py));
			centroid[1] += ((py + p2y) * (px * p2y - p2x * py));
		}
		px = points[len-2];
		py = points[len-1];
		p2x = points[0];
		p2y = points[1];
		centroid[0] += ((px + p2x) * (px * p2y - p2x * py));
		centroid[1] += ((py + p2y) * (px * p2y - p2x * py));

		centroid = [Math.abs(centroid[0] / (area * 6.0)), Math.abs(centroid[1] / (area * 6.0))];
		
		var two_dim_centroid = [];
		two_dim_centroid.push(centroid);

		return two_dim_centroid;
	}

		
	function getOpacityColor(color, opacity) {
		var opacityColor,
			i;
		var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
		if (color) {
			var colorNew;
			if (/^(rgba|RGBA)/.test(color)) {
				var tempColor = color.replace(/rgba\(|RGBA\(/, "");
				tempColor = tempColor.replace(")", "");
				colorNew = tempColor.split(",");
				opacityColor = "RGBA(" + colorNew[0] + "," + colorNew[1] + "," + colorNew[2] + "," + opacity + ")";
				return opacityColor;
			} else if (/^(rgb|RGB)/.test(color)) {
				colorNew = color.replace(/rgb\(|RGB\(/, "");
				colorNew = colorNew.replace(")", "");
				opacityColor = "RGBA(" + colorNew + "," + opacity + ")";
				return opacityColor;
			} else if (reg.test(color)) {
				if (color.length === 4) {
					colorNew = "#";
					for (i=1; i<4; i++) {
						colorNew += color.slice(i,i+1).concat(color.slice(i,i+1));
					}
					color = colorNew;
				}
				var colorChange = [];
				for (i=1; i<7; i+=2) {
					colorChange.push(parseInt("0x" + color.slice(i,i+2)));
				}
				colorChange.push(opacity);
				opacityColor = "RGBA(" + colorChange.join(",") + ")";
				return opacityColor;
			} else {
				return color;
			}
		} else {
			return null;
		}
		
	}
	

	
	
	function getThemeMode(color) {
		var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/,
			i,
			r,
			g,
			b,
			brightness;
		if (color) {
			var colorNew,
				tempColor;
			if (/^(rgba|RGBA)/.test(color)) {
				tempColor = color.replace(/rgba\(|RGBA\(/, "");
				tempColor = tempColor.replace(")", "");
				colorNew = tempColor.split(",");
				r = colorNew[0];
				g = colorNew[1];
				b = colorNew[2];
			} else if (/^(rgb|RGB)/.test(color)) {
				tempColor = color.replace(/rgb\(|RGB\(/, "");
				tempColor = tempColor.replace(")", "");
				colorNew = tempColor.split(",");
				r = colorNew[0];
				g = colorNew[1];
				b = colorNew[2];
			} else if (reg.test(color)) {
				if (color.length === 4) {
					colorNew = "#";
					for (i=1; i<4; i++) {
						colorNew += color.slice(i,i+1).concat(color.slice(i,i+1));
					}
					color = colorNew;
				}
				var colorChange = [];
				for (i=1; i<7; i+=2) {
					colorChange.push(parseInt("0x" + color.slice(i,i+2)));
				}
				r = colorChange[0];
				g = colorChange[1];
				b = colorChange[2];
			} else {
				return THEME_DARK;
			}
			
			brightness = (r*299 + g*587 + b*114) / 1000;
			if (brightness > 150) {
				return THEME_LIGHT;
			} else {
				return THEME_DARK;
			}
		} else {
			return THEME_DARK;
		}
	}
	
	
	
	function drawWhiteRectCorner(hlContext, xOffset, yOffset, width, height) {
		hlContext.strokeStyle = "#FFF";
		hlContext.lineWidth = 2;
		hlContext.beginPath();
		hlContext.moveTo(xOffset+width*0.25, yOffset);
		hlContext.lineTo(xOffset, yOffset);
		hlContext.lineTo(xOffset, yOffset+height*0.25);
		hlContext.moveTo(xOffset, yOffset+height*0.75);
		hlContext.lineTo(xOffset, yOffset+height);
		hlContext.lineTo(xOffset+width*0.25, yOffset+height);
		hlContext.moveTo(xOffset+width*0.75, yOffset+height);
		hlContext.lineTo(xOffset+width, yOffset+height);
		hlContext.lineTo(xOffset+width, yOffset+height*0.75);
		hlContext.moveTo(xOffset+width, yOffset+height*0.25);
		hlContext.lineTo(xOffset+width, yOffset);
		hlContext.lineTo(xOffset+width*0.75, yOffset);
		hlContext.stroke();
		hlContext.closePath();
	}
	
	
	
	


	mstrmojo.AndroidVisMap = mstrmojo.declare(

			mstrmojo.Vis,

			[mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

			{

				scriptClass: 'mstrmojo.AndroidVisMap',
				
				
				model: null,

				
				utils: mstrmojo.VisChartUtils,  
				
				scrollerConfig : {
					bounces : false,
					showScrollbars : false,
					useTranslate3d : true,
					vScroll: true,
					hScroll: true,
					offset : {
							y: {
								start: 0,
								end: 0
							},
							x: {
								start: 0,
								end: 0
							}
					},
					origin: {
						x: 0,
						y: 0
					}
				},
				
				
				relScaleFactor: 1, 
				
				
				scaleFactor: 1,
				
				
				currSelectedObj: null,
				
				
				defaultSelectedObjs: {},
				
				
				currHoverObj: null,
				
				
				currLinkObj: null,
				
				
				tooltipOn: false,
				
				
				context: null,
				
				
				multiTap: true,
				
				
				multiTouch: true,

				browserSupportsHtml5: true,
				

				
				markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};top:{@top};left:{@left};z-index:{@zIndex};position:absolute;{@cssText};overflow:hidden;" ' +
									' mstrAttach:mouseover,mousemove >' +
									
									'<div id="{@id}"-scroll-element style="position:absolute;left:0;top:0;width:{@width};height={@height}">' +
										'<canvas id="{@id}-highlightCanvas" style="position:absolute;left:0;top:0;z-index:100" width="{@width}" height="{@height}"></canvas>' +
										'<canvas id="{@id}-animationCanvas" style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>'+
									'</div>'+
									'<div id="{@id}-tooltip" style="z-index:200" class="mstrmojo-ImageLayout-tooltip" clk="clk"><table style="margin:5px 7px"></table></div>' +
									'<div id="{@id}-infowindow-anchor" style="position:absolute;width:18px;height:18px;display:block"></div>'+
									'<div id="{@id}-css" style="display:none"></div>'+
									'<div id="{@id}-errMsg" align="center" style="position:absolute; z-index:300; top:35%; word-wrap:break-word;"></div>'+
								'</div>',

				
				markupSlots: {
					
					
					
					
					scrollableCanvasDiv: function () { return this.domNode.childNodes[0]; },

					
					highlightCanvas: function () { return this.domNode.childNodes[0].firstChild; },

					
					animationCanvas: function () { return this.domNode.childNodes[0].lastChild; },

					
					tooltip: function () { return this.domNode.childNodes[1]; },
					
					
					infowindowAnchor: function() {return this.domNode.childNodes[2];},
					
					
					cssDiv: function() { return this.domNode.childNodes[3]; },
					
					
					errorMessage: function() { return this.domNode.childNodes[4]; }
				},
				
				postBuildRendering: function postBuildRendering() {
					var me = this;
					
					
					me.setFontByDPI();

					browserSupportsHtml5 = me.highlightCanvas.getContext;
					if (!browserSupportsHtml5) {
						me.renderErrorMessage(mstrmojo.desc(8126, 'Your browser does not support HTML5'));
						return;
					}
					
					
					if (me.model.hasOwnProperty("eg")) {
						var errorMessage = me.model.eg,
							wrongTemplateStr = "The Image Layout requires:";
						if (errorMessage.match(wrongTemplateStr)) {
							me.renderErrorMessage(mstrmojo.desc(9853, errorMessage));
						} else {
							me.renderErrorMessage(errorMessage);
						}
						
						return;
					}

					me.newRenderFlag = true;
					
					me.attrIndices = me.getAttrIndices();
					me.createTooltipTable();
					
					
					
					



















					
					
					me.getDefaultSelectedObjs();
					
					
					
					me.highlightContext =  me.highlightCanvas.getContext('2d');
					me.animationContext =  me.animationCanvas.getContext('2d');
					
					
					var sclConfig = me.scrollerConfig;
					sclConfig.scrollEl = me.scrollableCanvasDiv;
					sclConfig.offset.x.start = 0;
					sclConfig.offset.x.end = me.getWidth() * (me.scaleFactor - 1);
					sclConfig.offset.y.start = 0;
					sclConfig.offset.y.end = me.getHeight() * (me.scaleFactor - 1);
					if (sclConfig.origin.x > sclConfig.offset.x.end) {
						sclConfig.origin.x = sclConfig.offset.x.end;
					}
					if (sclConfig.origin.y > sclConfig.offset.y.end) {
						sclConfig.origin.y = sclConfig.offset.y.end;
					}

					
					me.animationCanvas.width = me.highlightCanvas.width = me.getWidth() * 2;
					me.animationCanvas.height = me.highlightCanvas.height = me.getHeight() * 2;
					
















					
					
					if (!me.model.coords) {






						
						
						if(typeof(mstrApp) != 'undefined' && mstrApp.serverRequest) {
							
							var xhrCfg = {
									success: function(res) {
										if (!res) {
											return;
										}
										me.model.coords = res.coords;
										
										me.drawMap();
										if (me.markerType !== MARKER_IMAGE) {
											
											
											me.highlightPoint();
										}
										
										me.adjustWidgetOffsets();
										
										
										if (!me.mapDataScreenshotTaken) {
											me.mapDataScreenshotTaken = true;
											me.localTakeScreenshot(RENDERING_TIME);
										}
									},
									
									failure: function(res) { 



									}
															
								};
							
							params = {
									taskId: 'getMapCoordinates'
							};
							var vp = me.model.vp;
							if (vp && vp.mf) {
								params.coordinatesFile = vp.mf;
							}
							mstrApp.serverRequest(params,xhrCfg,{src:"postBuildRendering"});
						}
					} else {






						
						
						me.drawMap();
						
						me.highlightPoint();
						
						
						this.adjustWidgetOffsets();
					}
					
					if(this._super) {
						this._super();
					}
					
					
					
					if (this._tn) {
						var backup = this._tsCallback;
						this._tsCallback = function(e) {
							me.infowindowOn = me.model.infowindowOn;
							me.currSelectedObjBackup = me.currSelectedObj; 
							backup.call(this, e);
						};
						mstrmojo.dom.detachEvent(this._tn, mstrmojo.dom.TOUCHSTART, backup);
						mstrmojo.dom.attachEvent(this._tn, mstrmojo.dom.TOUCHSTART, this._tsCallback);
					}
					
					
					var xtabModel = me.xtabModel,
						docModel = (xtabModel && xtabModel.docModel);
					if(docModel){
						me.docModelListener = me.xtabModel.docModel.attachEventListener('infoWindowClosed', this.id, function (evt) {
							












							me.model.infowindowOn = false;
							if (!me.hasNonifwTarget && me.currSelectedObj) {
								window.setTimeout(function() {
									
									me.currSelectedObj = null;
									me.highlightPoint();
								}, 10);
							}



						});
					}
					
					
					
					me.fullScreenListener = mstrmojo.touchManager.attachEventListener('fullScreenStateChange', this.id, function(evt) {
						me.adjustWidgetOffsets();
					});
					
					
					
					

					





				},
				
				
				getFullPath: function getFullPath(path) {
					var fullPath = '';
					var reg = /^[A-z]:\/\//; 
					if (reg.test(path)) {
						
						fullPath = path;
					} else {
						
						
						
						var tempReg1 = /^(..\/|..\\)/; 
						var tempReg2 = /^(.\/|.\\)/;
						var tempReg3 = /^(\/|\\)/;
						path = path.replace(tempReg1, '');
						path = path.replace(tempReg2, '');
						path = path.replace(tempReg3, '');
						
						if (typeof(mstrApp)!='undefined' && mstrApp.getConfiguration) {
							fullPath = mstrmojo.url.getAbsoluteURL(path, mstrApp.getConfiguration().getCurrentProjectWebServerUrl());
						}
					}
					
					return fullPath;
				},
				
				
				touchMultiBegin: function (touch) {
					
					this.hideTooltip();
					
					
					
					
					var touch1,
						touch2;
					if (touch.evt.touches && touch.evt.touches.length == 2) {
						touch1 = touch.evt.touches[0];
						touch2 = touch.evt.touches[1];
					} else {
						touch1 = touch;
						touch2 = {pageX: 100, pageY:100};
					}
					var xDiff = touch1.pageX - touch2.pageX,
						yDiff = touch1.pageY - touch2.pageY;
					this.initDiffDiff = xDiff * xDiff + yDiff * yDiff;
					this.initCenterX = (touch1.pageX + touch2.pageX)>>1;
					this.initCenterY = (touch1.pageY + touch2.pageY)>>1;
					this.initScrollX = this._scroller.origin.x;
					this.initScrollY = this._scroller.origin.y;
					
					this.relScaleFactor = 1;
					
					
				},
				
				touchMultiMove: function (touch) {
					
					
					
					var touch1,
						touch2;
					if (touch.evt.touches && touch.evt.touches.length == 2) {
						touch1 = touch.evt.touches[0];
						touch2 = touch.evt.touches[1];
					} else {
						touch1 = touch;
						touch2 = {pageX: 100, pageY: 100};
					}
					var xDiff = touch1.pageX - touch2.pageX,
						yDiff = touch1.pageY - touch2.pageY,
						curDiffDiff = xDiff * xDiff + yDiff * yDiff,
						curCenterX = (touch1.pageX + touch2.pageX)>>1,
						curCenterY = (touch1.pageY + touch2.pageY)>>1;
					
					var scale = Math.sqrt(curDiffDiff / this.initDiffDiff);
					
					var offset = { 
						x: scale * (this.initCenterX + this.initScrollX) - curCenterX,
						y: scale * (this.initCenterY + this.initScrollY) - curCenterY
					};
					var transform = {scale: scale, offset: offset};
					
					this.relScaleFactor = scale;
					
					this.applyTransform(transform);
				},
				
				touchMultiEnd: function (touch) {
					if (this.relScaleFactor * this.scaleFactor < 1) {
						
						this.relScaleFactor = 1 / this.scaleFactor;
						this.applyTransform({scale: this.relScaleFactor}, 500, this.postScale);
					} else if(this.relScaleFactor * this.scaleFactor > 2) {
						var scaleBack = this.relScaleFactor * this.scaleFactor / 2;
						this.relScaleFactor = 2 / this.scaleFactor;
						this.applyTransform({scale: this.relScaleFactor, scaleBack: scaleBack}, 500, this.postScale);
					} else {
						this.postScale();
					}
				},
				
				
				handleTouchSelectWithIfw: function handleTouchSelectWithIfw (touchX, touchY) {
					var me = this,
						nearestObj = me.getAreaOrNearestBubble(false, touchX, touchY);
					
					if (!nearestObj) { 
						me.closeInfowindow();
					} else if (nearestObj.hdrIndex < 0) { 
						me.closeInfowindow();
					} else if (!me.currSelectedObj || nearestObj.touchVal !== me.currSelectedObj.touchVal) {
						me.showInfowindow(nearestObj);						
						me.currSelectedObj = nearestObj;

						me.highlightPoint();
					} else { 
						
					}
				},
				
				handleTouchSelectNoIfw: function handleTouchSelectNoIfw (touchX, touchY) {
					var me = this,
						nearestObj = me.getAreaOrNearestBubble(false, touchX, touchY);
					
					if (!nearestObj) { 
						me.hideTooltip();
					} else if (!me.currHoverObj || nearestObj.touchVal !== me.currHoverObj.touchVal) {
						me.currHoverObj = nearestObj;
						
						me.highlightPoint();
					} else {
						me.renderTooltip(nearestObj.touchVal, nearestObj.point.x, nearestObj.point.y, nearestObj.hdrIndex);
					}
				},
				
				touchSelectBegin: function (touch) {
					if (touch.evt.ctrlKey) { 
						this.touchMultiBegin(touch);
						return;
					}
					
					if (this.infowindowOn) {
						this.touchSelectWithIfw = true;
						this.handleTouchSelectWithIfw(touch.pageX, touch.pageY);						
					} else {
						this.handleTouchSelectNoIfw(touch.pageX, touch.pageY);
					}

				},
				
				touchSelectMove: function (touch) {
					if (touch.evt.ctrlKey) {
						this.touchMultiMove(touch);
						return;
					}
					
					if (this.touchSelectWithIfw) {
						this.handleTouchSelectWithIfw(touch.pageX, touch.pageY);
					} else {
						this.handleTouchSelectNoIfw(touch.pageX, touch.pageY);
					}				

				},
				
				touchSelectEnd: function (touch) {
					if (touch.evt.ctrlKey) {
						this.touchMultiEnd(touch);
					}
					this.touchSelectWithIfw = false;
					return;
				},				
				
				
				touchSwipeBegin: function touchSwipeBegin(touch) {
					this.hideTooltip();
					

					if (this._super) {
						this._super(touch);
					}
				},
				
				applyTransform: function (transform, duration, callback) {
					var scl = this._scroller;
					
					if (duration === undefined) {
						duration = 0;
					}
					scl.scrollEl.style["webkitTransformOrigin"] = "left top";
					
					scl.transform = "scale(" + transform.scale + "," + transform.scale + ")";
					var scrollX,
						scrollY;
					if (transform.offset) {
						scrollX = transform.offset.x;
						scrollY = transform.offset.y;
					} else {
						var scaleBack = transform.scaleBack || 1;
						scrollX = this._scroller.origin.x / scaleBack;
						scrollY = this._scroller.origin.y / scaleBack;
					}
					
					var scrollerOffsetScale = this.scaleFactor * this.relScaleFactor - 1,
						vOffsetEnd = this.getHeight() * scrollerOffsetScale,
						hOffsetEnd = this.getWidth() * scrollerOffsetScale;
					if (scrollerOffsetScale < 0) { 
						scl.offset = {
								y: {
									start: vOffsetEnd,
									end: 0
								},
								x: {
									start: hOffsetEnd,
									end: 0
								}
						};
					} else { 
						scl.offset = {
								y: {
									start: 0,
									end: vOffsetEnd
								},
								x: {
									start: 0,
									end: hOffsetEnd
								}
						};
					}
					this._scroller.scrollTo(scrollX, scrollY, duration);
					if (callback) {
						var that = this;
						setTimeout(function () {callback.apply(that); that = null;}, duration);
					}
						
					
				},
				
				pointCanBeSelected: function pointCanBeSelected(touchObj){
					
					var me = this,
						m = me.model,
						gts = m.gts,
						colHeaders = gts.col,
						colHL = colHeaders.length,
						rowHeaders = gts.row,
						rowHL = rowHeaders.length,
						i;

					for(i = 0; i < rowHL; i++){
						var rowH = rowHeaders[i];
						if(rowH.sc && rowH.sc.tks){
							return true;
						}
						if(rowH.lm && rowH.lm[0] && rowH.lm[0].links && rowH.lm[0].hasOwnProperty("di")){ 
							return true;
						}
					}
					return false;
				},
				
				getModelK: function getModelK(){
					var k = this.model && this.model.k;
					
					return k;
				},
				
				getActionObj: function getActionObj(touchedObj, selectedAll, sameAsCurrSelectedPoint){
					var scObjList = [],
						actionType = 0,
						actionObjList = [],
						linkDrillNode = null;
				
					var me = this,
						model = me.model,
						gts = model.gts,
						rowH = gts.row[0];
						
					
					if(rowH.sc && rowH.sc.tks && (!touchedObj || touchedObj.hdrIndex>=0)){
						if(selectedAll && (rowH.sc.all === "false" || rowH.sc.all === false)){
							
							return null;
						}
						var scObj = {};
						scObj.sc = rowH.sc;
						if (touchedObj && touchedObj>=0) {
							scObj.es = rowH.es[touchedObj.hdrIndex].n;
						} else {
							scObj.es = null;
						}
						
						scObj.eid = selectedAll ? "OA:(All)" : rowH.es[touchedObj.hdrIndex].id;					
						scObjList.push(scObj);
						actionType = rowH.at || 0;
					}
					if(rowH.lm && rowH.lm[0] && rowH.lm[0].links && !linkDrillNode && touchedObj && touchedObj.hdrIndex>=0){
						
						linkDrillNode = {};
						linkDrillNode.titleInfo = rowH;
						linkDrillNode._e = rowH.es[touchedObj.hdrIndex];
					}
					
					
					var colH = gts.col && gts.col.length>0 && gts.col[0];
					
								
					if(scObjList.length >0){
						actionType = actionType | SELECTOR_ACTION;
						if (touchedObj && touchedObj.hdrIndex>=0) {
							if (!sameAsCurrSelectedPoint) {
								if (this.hasIfwTarget) {
									
									this.getAnchorStyle(touchedObj);								
									
									
									
									this.model.infowindowOn = true;
									
									return {at:actionType, k:this.getModelK(), scObjList:scObjList, anchor:this.infowindowAnchor};									
								} else {
									return {at:actionType, k:this.getModelK(), scObjList:scObjList};
								}

							} else {
								
								
								return {at:actionType, k:this.getModelK(), scObjList:scObjList};
							}
						} else if (touchedObj && touchedObj.hdrIndex<0) {
							
							return {at:actionType, k:this.getModelK(), scObjList:scObjList};
						} else if (!touchedObj) { 
							
							
							
							
							return {at:actionType, k:this.getModelK(), scObjList:scObjList};
						}

					}
					
					if(!linkDrillNode && touchedObj && touchedObj.hdrIndex>=0){
					
						var metricH = colH,
							metricHL = metricH && metricH.es && metricH.es.length,
							i;
						if (metricH && metricHL>0) {
							for(i = metricHL - 1; i >= 0; i--){
								var metric = metricH.es[i],
									lm = metricH.lm[i];
								
								if(lm && lm.links){
									linkDrillNode = {};
									linkDrillNode.titleInfo = metricH;
									
									linkDrillNode.mix = i;
									
									var currNode = linkDrillNode,
										nodeLP = {};
									nodeLP.titleInfo = rowH;
									nodeLP._e = rowH.es[touchedObj.hdrIndex];						
												
									currNode._lp = nodeLP;
									currNode.axis = ROW_AXIS;
								}
							}
						}						
					}
					if(linkDrillNode){
						actionType = actionType | HYPERLINK_ACTION;
						return {at:actionType, k:this.getModelK(), node:linkDrillNode};
					}
					return null;
				},
				
				getAnchorStyle: function getAnchorStyle(touchedObj) {
					if (!touchedObj) { return; }
					
					var touchVal = touchedObj.touchVal,
						me = this,
						model = me.model,
						coords = model.coords,
						i,
						j,
						k;
					
					
					me.infowindowAnchor.style.left = (touchedObj.point.x - 9) + 'px';
					me.infowindowAnchor.style.top = (touchedObj.point.y - 9) + 'px';
					
					if(me.displayMode === DISPLAY_MODE_AREA) {
						var minX = Number.POSITIVE_INFINITY,
							maxX = 0,
							minY = Number.POSITIVE_INFINITY,
							maxY = 0;
						if (coords.hasOwnProperty(touchVal)) {
							var rgn = coords[touchVal];
							for (i in rgn) {
								if (!rgn.hasOwnProperty(i)) {
									continue;
								}
								var c = rgn[i];
								for (j=0; j<c.length; j++) {
									if (minX > c[j]) { minX = c[j]; }
									if (maxX < c[j]) { maxX = c[j]; }
									j++;
									if (minY > c[j]) { minY = c[j]; }
									if (maxY < c[j]) { maxY = c[j]; }
								}
							}
							me.infowindowAnchor.style.left = (minX + me.leftOffset - me._scroller.origin.x) + "px";
							me.infowindowAnchor.style.top = (minY + me.topOffset - me._scroller.origin.y) + "px";
							me.infowindowAnchor.style.width = (maxX - minX) + "px";
							me.infowindowAnchor.style.height = (maxY - minY) + "px";
							
						}
					} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
						if (me.shapeFileType === SHAPE_FILE_POLYGON) {
							coords = model.polygonCenters;
						}
						if (coords.hasOwnProperty(touchVal)) {
							if (me.markerType === MARKER_BUBBLE) {
								var ct = coords[touchVal][0],
									rd = me.getRadiusFromName(touchVal);
								me.infowindowAnchor.style.left = (ct[0] + me.leftOffset - rd - me._scroller.origin.x) + "px";
								me.infowindowAnchor.style.top = (ct[1] + me.topOffset - rd - me._scroller.origin.y) + "px";
								me.infowindowAnchor.style.width = (2 * rd) + "px";
								me.infowindowAnchor.style.height = (2 * rd) + "px";
							} else if (me.markerType === MARKER_IMAGE) {
								var ct = coords[touchVal][0],
									_image = model["imageIcon_" + touchVal],
									_width = 0,
									_height = 0;
								
								if (_image) {
									_width = _image.width;
									_height = _image.height;
								}
								
								me.infowindowAnchor.style.left = (ct[0] + me.leftOffset - _width/2 - me._scroller.origin.x) + "px";
								me.infowindowAnchor.style.top = (ct[1] + me.topOffset - _height/2 - me._scroller.origin.y) + "px";
								me.infowindowAnchor.style.width = _width + "px";
								me.infowindowAnchor.style.height = _height + "px";
							}
							
						}
					}
				},
				
				
				getLastHighlightPoint: function gtLstHighlightPnt(){
					
					return this.currHoverObj || null;
				},
				
				
				getTouchedObj: function getTouchedObj(isTap, touchX, touchY){
					var me = this;
					if( me.displayMode == DISPLAY_MODE_AREA ){
						
						return this.getAreaOrNearestBubble(isTap, touchX, touchY);

					}else if( me.displayMode == DISPLAY_MODE_BUBBLE ){
						var touchedObj = this.getLastHighlightPoint(),
							touchPointOnWidget = me.utils.getTouchXYOnWidget(touchX, touchY, me);
						
						
						var touchPointInHighlightArea = false,
							tx = 0,
							ty = 0,
							twx = 0,
							twy = 0;
						if (touchedObj && touchPointOnWidget) {
							tx = touchedObj.point.x;
							ty = touchedObj.point.y;
							twx = touchPointOnWidget.touchX;
							twy = touchPointOnWidget.touchY;
							
							touchPointInHighLightArea = this.tooltipOn && (tx-twx)*(tx-twx) + (ty-twy)*(ty-twy)<= this.bias * this.bias; 
						}
						
						
						
						
					
						if(touchPointInHighlightArea){
							
							me.hideTooltip();	
							touchedObj = this.getLastHighlightPoint();
						}else{
							touchedObj = this.getAreaOrNearestBubble(isTap, touchX, touchY);
						}  
						
						return touchedObj;
						
					}
				
					return null;
				},
				
				closeInfowindow: function closeInfowindow() {
					var me = this;
					me.getFirstInfowindow();
					if (me.model.infowindowOn && me.infowindow) {
						me.model.infowindowOn = false;
						me.infowindow.close();
						if (me.infowindow._tchHandler) { 
							mstrmojo.touchManager.detachEventListener(me.infowindow._tchHandler);
							delete me.infowindow._tchHandler; 
						}
					}
					
				},
				
				getFirstInfowindow: function getFirstInfowindow() {
					var me = this,
						model = me.model,
						xtabModel = me.xtabModel,
						docModel = (xtabModel && xtabModel.docModel),
						row = model && model.gts && model.gts.row,
						tks = null;
					if (row && row.length>0) {
						tks = row[0] && row[0].sc && row[0].sc.tks;
					}
					if (docModel && tks) {
						var ifws = docModel.getTargetInfoWin(tks);
						if (ifws && ifws.length>0) {
							var ifwunit = docModel.infoWinByKey[ifws[0]],
								id = ifwunit && (ifwunit.id + "_ifw");
							me.infowindow = mstrmojo.all[id];						
						}
					}
				},
				
				hasNoninfowindowTarget: function hasNoninfowindowTarget(actionObj) {	
					var xtabModel = this.xtabModel,
						docModel = (xtabModel && xtabModel.docModel);
					if (docModel) {
						var layouts = docModel.defn && docModel.defn.layouts,
							layout = null,
							i;
						
						if (layouts) {
							for(i in layouts) {
								if (layouts.hasOwnProperty(i)) {
									if (layouts[i].loaded) {
										layout = layouts[i];
										break;
									}
								}								
							}
						}
						
						var units = layout && layout.units;
						if (units) {
							for(i = 0; i < actionObj.scObjList.length; i++){
								var scObj = actionObj.scObjList[i];
								
								
								var tksList = scObj.sc.tks.split("\x1E"),
									j;
								for(j = 0; j < tksList.length; j++){
									var unit = units[tksList[j]];
									if (unit) {
										if (!unit.ifw) {
											return true;
										}
									}
								}								
							}
						}
					}
					
					return false;
				},
				
				hasInfowindowTarget: function hasInfowindowTarget(actionObj) {	
					var xtabModel = this.xtabModel,
						docModel = (xtabModel && xtabModel.docModel);
					if (docModel) {
						var layouts = docModel.defn && docModel.defn.layouts,
							layout = null,
							i;
						
						if (layouts) {
							for(i in layouts) {
								if (layouts.hasOwnProperty(i) && layouts[i].loaded) {
									layout = layouts[i];
									break;
								}
							}
						}
						
						var units = layout && layout.units;
						if (units) {
							for(i = 0; i < actionObj.scObjList.length; i++){
								var scObj = actionObj.scObjList[i];
								
								







								
								var tksList = scObj.sc.tks.split("\x1E"),
									j;
								for(j = 0; j < tksList.length; j++){
									var unit = units[tksList[j]];
									if (unit) {
										if (unit.ifw) {
											return true;
										}
									}
								}								
							}
						}
					}
					
					return false;
				},
				
				
				touchTap: function touchTap(touch){
					
					var me = this;
					if (touch.count == 2) { 
						
						me.hideTooltip();
						
						me.relScaleFactor = 1 / me.scaleFactor;
						me.applyTransform({scale: me.relScaleFactor}, 500, me.postScale);
					} else if (touch.count == 1) { 
						
						
						var actionObj;
						if (me.tooltipOn) {
							var item = mstrmojo.dom.findAncestorByAttr(touch.target, "clk", true, this.domNode) || null;
							if (item) {
								var value = item.value;
								if (value === "clk" ){
									me.hideTooltip();
									return;
								}						
							} 
						}
						
						var touchedObj = this.getTouchedObj(true, touch.pageX, touch.pageY);
						
						if (touchedObj && touchedObj.hdrIndex>=0){
							
							var canBeSelected = me.pointCanBeSelected(touchedObj),
								sameAsCurrSelectedPoint = me.currSelectedObjBackup && (touchedObj.touchVal == me.currSelectedObjBackup.touchVal),
								sameAsLastHighlight;
							
							if (canBeSelected){
								
								if (!sameAsCurrSelectedPoint){
									
									me.defaultSelectedObjs = {};
									
									
																		
									me.hideTooltip();								
									
									actionObj = this.getActionObj(touchedObj);
									if (actionObj && actionObj.scObjList){
										me.currSelectedObj = touchedObj;
										
										if (!me.hasOwnProperty("hasNonifwTarget") || !me.hasOwnProperty("hasIfwTarget")) {
											me.hasNonifwTarget = me.hasNoninfowindowTarget(actionObj);
											me.hasIfwTarget = me.hasInfowindowTarget(actionObj);
											actionObj = this.getActionObj(touchedObj);
										}
										


















										
										me.highlightPoint();
										
										me.performAction([actionObj]);
									
									} else if (actionObj && actionObj.node) { 
										me.currLinkObj = touchedObj;
										me.highlightPoint();
										
										me.performAction([actionObj]);
										me.currLinkObj = null;
										
									} 
									
									
								} else { 
									
									
									
									
									if (this.currHoverObj && this.currSelectedObj && this.currHoverObj.touchVal===this.currSelectedObj.touchVal){ 
										
									} else {
										if (me.hasNonifwTarget) { 
											
											actionObj = me.getActionObj(touchedObj, true, true);	
											if(actionObj){ 
												me.performAction([actionObj]);	
												me.currSelectedObj = null;
												me.highlightPoint();
											} else { 
												
												me.getFirstInfowindow();
												if (!me.infowindowOn && me.infowindow) {
													me.model.infowindowOn = true;
													me.infowindow.open();
												}
												
											}
										}										
									}
									
									me.hideTooltip();
								}
							} else { 
								sameAsLastHighlight = me.currHoverObj && (touchedObj.touchVal == me.currHoverObj.touchVal);
								if(!sameAsLastHighlight){
									
									me.currHoverObj = touchedObj;
									
									me.highlightPoint();
								} else { 
									me.hideTooltip();
								}
								
							}
						
						} else if (touchedObj && touchedObj.hdrIndex<0) { 
							
							sameAsLastHighlight = me.currHoverObj && (touchedObj.touchVal == me.currHoverObj.touchVal);
							if (!sameAsLastHighlight){
								
								me.currHoverObj = touchedObj;
								
								me.highlightPoint();
							} else {
								me.hideTooltip();
							}
						} else if (!touchedObj){ 
							
							
							me.hideTooltip();
							
							
														
							if (me.currSelectedObjBackup && me.hasNonifwTarget){
								
								
								actionObj = this.getActionObj(touchedObj, true);	
								
								if (actionObj){
									me.performAction([actionObj]);
									me.currSelectedObj = null;
									me.highlightPoint();
								}
								
							}
						}
					}
					
							
				},
				
				showInfowindow: function showInfowindow(touchedObj) {
					var me = this,
						actionObj;
					
					if (touchedObj && touchedObj.hdrIndex>=0){
						
						var canBeSelected = me.pointCanBeSelected(touchedObj),
							sameAsCurrSelectedPoint = me.currSelectedObj && (touchedObj.touchVal == me.currSelectedObj.touchVal);
						
						if( canBeSelected ){
							
							if( !sameAsCurrSelectedPoint ){
								
								me.hideTooltip();
								
								actionObj = me.getActionObj(touchedObj);
								if (actionObj && actionObj.scObjList){
									me.currSelectedObj = touchedObj;
								}
								
								
								me.highlightPoint();
								
								me.performAction([actionObj]);
								
							} else { 
								if (this.currHoverObj && this.currSelectedObj && this.currHoverObj.touchVal===this.currSelectedObj.touchVal){ 
									
									me.hideTooltip();
								} else {
									me.hideTooltip();
																		
									actionObj = this.getActionObj(touchedObj, true, true);	
									
									if (actionObj){					
										me.performAction([actionObj]);	
										me.currSelectedObj = null;
										me.highlightPoint();
									}
								}
							}
						} else { 

						}					
					} else if ((touchedObj && touchedObj.hdrIndex<0) || !touchedObj){ 
						
						
						
						me.hideTooltip();
						
						
													
						if(me.currSelectedObj){
							
							
							actionObj = me.getActionObj(touchedObj, true);	
							
							if(actionObj){
								me.performAction([actionObj]);
								me.currSelectedObj = null;
								me.highlightPoint();
							}
							
						}
					}
				},
				
				
				
				
				postScale: function () {
					delete this._scroller.transform;
					this._scroller.scrollTo(this._scroller.origin.x, this._scroller.origin.y, 0);
					this.scaleFactor *= this.relScaleFactor;
					this.refreshWidget();
				},
				
				
				refreshWidget: function () {
					this.drawMap();
					this.highlightPoint();
				},
				
				
				getAttrIndices: function getAttrIndices() {
					var me = this,
						model = me.model,
						rows = model && model.gts && model.gts.row,
						i,j;
					
					if (rows) {
						var attrIndices = [],
							idx = 0;
						for (i=0; i<rows.length; i++) {
							var fs = rows[i] && rows[i].fs;
							attrIndices.push(new Array());
							if (fs) {
								for (j=0; j<fs.length; j++) {
									attrIndices[i].push(idx++);
								}
							}						
						}					
						return attrIndices;
					} else {
						return null;
					}
				},
				
				createTooltipTable: function createTooltipTable() {
					var me = this,
						model = me.model,
						table = me.tooltip.childNodes[0],
						rows = model && model.gts && model.gts.row,
						cols = model && model.gts && model.gts.col && model.gts.col[0] && model.gts.col[0].es,
						i;
					
					if (table.childNodes.length===0 && rows && rows.length>0) {
						var trNum = rows.length + (cols?cols.length:0); 
						for (i=0; i<trNum; i++) {
							var tr = document.createElement("tr");
							
							var tdLeft = document.createElement("td");
							tdLeft.align = "right";
							tdLeft.style.color = "#545462";
							tr.appendChild(tdLeft);
							
							var tdRight = document.createElement("td");
							tdRight.align = "left";
							tdRight.style.color = "#000000";
							tr.appendChild(tdRight);
							
							table.appendChild(tr);
						}
					}
					
				},
				
				localTakeScreenshot: function localTakeScreenshot(_time) {
					var me = this;
					window.setTimeout(function() {
						var ctrlID = me.controller.id;
						var ctrl = mstrmojo.all[ctrlID];
						if (ctrl && ctrl.rootCtrl.getCurrent() === ctrl) {
							ctrl.takeScreenShot();
							
						}
					}, _time);
				},
				
				
				getDefaultSelectedObjs: function getDefaultSelectedObjs() {
					var me = this,
						model = me.model,
						idxs = model && model.ghs && model.ghs.rhs && model.ghs.rhs.items,
						gts_rows = model && model.gts && model.gts.row,
						i,name,idx,item;
					
					
					if (me.haveGotDftSltObjs) {
						return;
					} else {
						me.haveGotDftSltObjs = true;
					}
					
					me.defaultSelectedObjs = {};
					if (idxs && gts_rows && gts_rows.length>0) {
						for (i in idxs) {
							if (idxs.hasOwnProperty(i)) {
								item = idxs[i].items[0];
								if (item && item.hasOwnProperty("cet")) {
									idx = item.idx;
									name = gts_rows[0].es[idx].n;
									if (!(me.defaultSelectedObjs.hasOwnProperty(name))) {
										me.defaultSelectedObjs[name] = idx;
									}							
								}
							}						
						}
					}
						
				},
				
				renderErrorMessage: function renderErrorMessage(errorMessage) {
					
									
					
					var me = this,
						msgDiv = me.errorMessage,
						newErrorMessage = errorMessage.replace(/-/g, "<br />-");
					msgDiv.innerHTML = newErrorMessage;
					
					msgDiv.style.width = me.getWidth() + "px";
					msgDiv.style.fontSize = me.errMsgFontSize + "px";
					msgDiv.style.fontFamily = "Tahoma";
					msgDiv.style.color = ERROR_MSG_FONT_COLOR_DARK_THEME;
					msgDiv.style.backgroundColor = "RGBA(0,0,0,0)";
					
					var bgColor = DEFAULT_BG_COLOR;
					if (me.model.hasOwnProperty("vp") && me.model.vp.hasOwnProperty("bc") && me.model.vp.bc!=="") {
						bgColor = "#" + me.model.vp.bc;
					} else {
						bgColor = me.utils.getAncestorBgColor(me) || DEFAULT_BG_COLOR;
					}		
					me.domNode.style.backgroundColor = bgColor;
					me.model.themeMode = getThemeMode(bgColor);
					if (me.model.themeMode === THEME_LIGHT) {
						msgDiv.style.color = ERROR_MSG_FONT_COLOR_LIGHT_THEME;
					}
					
				},
				
				setFontByDPI: function setFontByDPI() {
					
					if (this.setFontByDPIFlag) {
						return;
					}
					var me = this;
					me.setFontByDPIFlag = true;
					
					
					me.hoverBubbleRadiusLarger = 5;
					me.bubbleStrokeWidth = 2;
					me.baseMaxBubbleSizeAuto = 12;
					me.baseMaxBubbleSizeManual = 24;
					me.polygonStrokeWidth = 1;
					me.highlightPolygonStrokeWidth = 2;
					me.borderSpace = 5;
					
					me.tooltipFontSize = 12; 
					me.tooltipBorderWidth = 1; 
					me.tooltipBorderRadius = 5;
					
					me.errMsgFontSize = 16; 
					me.bias = 30; 
					me.tooltipRightShadowWidth = 4; 
					
					
					var xtabModel = me.xtabModel,
						docModel = (xtabModel && xtabModel.docModel),
						fitToPage = false, 
						microApp = false;
					if (docModel) {
						fitToPage = docModel.zt && (docModel.zt==2);
						var layouts = docModel.defn && docModel.defn.layouts,
							layout,
							i;
						
						for(i in layouts) {
							if (layouts.hasOwnProperty(i) && layouts[i] && layouts[i].loaded) {
								layout = layouts[i];
								break;
							}
						}
						if (layout && layout.hasOwnProperty("fch")) {
							microApp = layout.fch;
						}
					}
					if (fitToPage && microApp) {




						
						var devicedpi = mstrMobileApp.getDeviceDPIX();
						var baseDpi = 149;
						var ratio = 1;
						if (devicedpi > 0 ) { ratio = devicedpi / baseDpi; }
						
						if (ratio > 1) {
							me.hoverBubbleRadiusLarger *= ratio;
							me.bubbleStrokeWidth *= ratio;
							me.baseMaxBubbleSizeAuto *= ratio;
							me.baseMaxBubbleSizeManual *= ratio;
							me.polygonStrokeWidth *= ratio;
							me.highlightPolygonStrokeWidth *= ratio;
							me.borderSpace *= ratio;
							me.tooltipFontSize *= ratio;
							me.tooltipBorderWidth *= ratio;
							me.tooltipBorderRadius *= ratio;
							me.errMsgFontSize *= ratio;
							me.bias *= ratio;
							me.tooltipRightShadowWidth *= ratio;
							
											
							
							var tooltip = me.tooltip,
								table = tooltip.childNodes[0];
							
							tooltip.style.fontSize = me.tooltipFontSize + "px";
							tooltip.style.borderWidth = me.tooltipBorderWidth + "px";
							tooltip.style.borderRadius = me.tooltipBorderRadius + "px";
							tooltip.style.boxShadow = 3*ratio + "px " + 3*ratio + "px " + 4*ratio + "px " + "RGBA(0,0,0,0.45)";
							table.style.margin = 5*ratio + "px " + 7*ratio + "px";
						}
					}
					
					
				},
				
				initScroller: function initScroller(scroller) {
					scroller.vScroll = true;
					scroller.hScroll = true;

					this._super(scroller);
				},
				
				
				
				getIndexFromHdrindex: function getIndexFromHdrIndex(hdrIndex) {
					var me = this,
						idxs = me.model.ghs.rhs.items;
					
					if (idxs) {
						var i,
							curRow,
							nextRow;
						for (i=0; i<idxs.length; i++) {
							curRow = idxs[i].items;
							if (curRow.length>0 && curRow[0].idx==hdrIndex) {
								if (i===idxs.length-1) {
									return i;
								} else {
									nextRow = idxs[i+1].items;
									if (nextRow.length>0 && nextRow[0].idx!=hdrIndex) {
										return i;
									} else {
										continue;
									}
								}
							} else {
								continue;
							}
						}
					}
					
					return 0;
				},

				
				drawMap: function drawMap(){
					var me = this,
						model = me.model;
					
					
					
					
					
					me.animationCanvas.width = me.animationCanvas.width;
					me.highlightCanvas.width = me.highlightCanvas.width;
				
					
					if (!me.hasOwnProperty("displayMode")) { me.displayMode = DISPLAY_MODE_AUTOMATIC; }
					if (!me.hasOwnProperty("markerType")) { me.markerType = MARKER_UNDEFINED; }
					if (!me.hasOwnProperty("shapeFileType")) { me.shapeFileType = SHAPE_FILE_UNDEFINED; }
					if (!me.hasOwnProperty("colorByIndex")) { me.colorByIndex = -1; }
					if (!me.hasOwnProperty("sizeByIndex")) { me.sizeByIndex = -1; }
					
					if (!me.hasOwnProperty("drawBgImageFlag")) { me.drawBgImageFlag = false; } 
					
					if (!me.hasOwnProperty("thresholdType")) { me.thresholdType = THRESHOLD_UNDEFINED; }
					
					if (!me.hasOwnProperty("curPolygonOpacity")) { me.curPolygonOpacity = POLY_NORMAL_OPACITY; }
					if (!model.hasOwnProperty("infowindowOn")) { model.infowindowOn = false; }
					if (!me.hasOwnProperty("touchSelectWithIfw")) { me.touchSelectWithIfw = false; }
					
					if (me.model.hasOwnProperty("vp")) {
						var bgColor = DEFAULT_BG_COLOR;
						if (me.model.vp.hasOwnProperty("bc") && me.model.vp.bc!=="") {
							bgColor = "#" + me.model.vp.bc;
						} else {
							bgColor = me.utils.getAncestorBgColor(me) || DEFAULT_BG_COLOR;
						}
						me.domNode.style.backgroundColor = bgColor;
						me.model.themeMode = getThemeMode(bgColor);
						me.model.bgColor = bgColor;
						
						me.tooltip.style.top = "0px";
						
						me.setDisplayParas();
						
						if (me.displayMode === DISPLAY_MODE_AREA) { 
							me.drawAreaMap();
						} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
							me.drawBubbleMap();
						}
					}

				},
				
				
				getIndexById: function getIndexById(id) {
					var me = this,
						model = me.model,
						gtsCol = model.gts && model.gts.col,
						gtsColEle = null,
						i;
					if (gtsCol && gtsCol.length > 0 && gtsCol[0].hasOwnProperty("es")) {
						gtsColEle = gtsCol[0].es;
						
						for (i=0; i<gtsColEle.length; i++) {
							if (gtsColEle[i].oid === id) {
								return i;
							}
						} 
					}
					
					return -1;
				},
				
				
				
				setDisplayParas: function setDisplayParas(){
					
					var me = this,
						model = me.model;  
					
					
					if (!me.hasOwnProperty("setDisplayParasFlag")) {
						me.setDisplayParasFlag = true;
					} else {
						return;
					}

					me.shapeFileType = getShapeFileType(model.coords);
					
					var colCount = 0;
					if (model.hasOwnProperty("gvs") 
							&& model.gvs.hasOwnProperty("items") 
							&& model.gvs.items.length > 0
							&& model.gvs.items[0].hasOwnProperty("items")
							&& model.gvs.items[0].items.length > 0) {
						colCount = model.gvs.items[0].items.length;
					}
					
					me.displayMode = model.vp.mt;
					if (me.displayMode === DISPLAY_MODE_AREA) {
						if (colCount > 0) {
							if (model.vp.hasOwnProperty("ColorBy")) {
								me.colorByIndex = me.getIndexById(model.vp.ColorBy);
								if (me.colorByIndex < 0) {
									me.colorByIndex = 0;
								}
							} else {
								me.colorByIndex = 0;
							}
							
							me.thresholdType = me.getThresholdType(me.colorByIndex);
							
							











						} else { 
							
						}
					} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
						if (colCount > 0) {
							this.setBubbleModeParasWithData(colCount);
						} else { 
							
							me.markerType = MARKER_BUBBLE;
						}					
					} else if (me.displayMode === DISPLAY_MODE_AUTOMATIC) {
						if (colCount > 0) {
							me.displayMode = DISPLAY_MODE_BUBBLE;
							this.setBubbleModeParasWithData(colCount);
						} else { 
							if (me.shapeFileType === SHAPE_FILE_POLYGON) {
								me.displayMode = DISPLAY_MODE_AREA;
							} else if (me.shapeFileType === SHAPE_FILE_POINT) {
								me.displayMode = DISPLAY_MODE_BUBBLE;
								me.markerType = MARKER_BUBBLE;
							}						
							
						}
						
					} else if (!me.displayMode) { 
						if (colCount > 0) {
							me.displayMode = DISPLAY_MODE_BUBBLE;
							this.setBubbleModeParasWithData(colCount);
						} else { 
							if (me.shapeFileType === SHAPE_FILE_POLYGON) {
								me.displayMode = DISPLAY_MODE_AREA;
							} else if (me.shapeFileType === SHAPE_FILE_POINT) {
								me.displayMode = DISPLAY_MODE_BUBBLE;
								me.markerType = MARKER_BUBBLE;
							}						
							
						}
					}
					
					






					
				},
				
				
				setBubbleModeParasWithData: function setBubbleModeParasWithData(colCount) {
					var me = this,
						model = me.model;
					if (model.vp.hasOwnProperty("SizeBy")) {
						me.sizeByIndex = this.getIndexById(model.vp.SizeBy);
						if (me.sizeByIndex < 0) {
							me.sizeByIndex = 0;
						}
					} else {
						me.sizeByIndex = 0;
					}
					
					if (model.vp.hasOwnProperty("ColorBy")) {
						me.colorByIndex = this.getIndexById(model.vp.ColorBy);
						if (me.colorByIndex < 0) {
							me.colorByIndex = 0;
						}
						
						me.thresholdType = me.getThresholdType(me.colorByIndex);
						if (me.thresholdType === THRESHOLD_IMAGE) {
							me.markerType = MARKER_IMAGE;
						} else {
							me.markerType = MARKER_BUBBLE;
						}
					} else {
						if (colCount===1) {
							me.colorByIndex = 0;
							me.thresholdType = this.getThresholdType(0);
							if (me.thresholdType === THRESHOLD_IMAGE) {
								me.markerType = MARKER_IMAGE;
							} else {
								me.markerType = MARKER_BUBBLE;
							}
						} else if (colCount>1) {
							var firstThresholdType = this.getThresholdType(0); 
							if (firstThresholdType === THRESHOLD_IMAGE) {
								me.colorByIndex = 0;
								me.thresholdType = firstThresholdType;
								me.markerType = MARKER_IMAGE;
							} else {
								me.colorByIndex = 1;
								me.thresholdType = this.getThresholdType(1);
								if (me.thresholdType === THRESHOLD_IMAGE) {
									me.markerType = MARKER_IMAGE;
								} else {
									me.markerType = MARKER_BUBBLE;
								}
								
							}
						}
					}

				},
				
				
				getThresholdType: function getThresholdType(colIndex) {
					var me = this,
						th = me.model && me.model.th,
						subTh = th && th[colIndex],
						gvs = me.model && me.model.gvs,
						gts_es = me.model.gts.row[0].es,
						elem,
						i,
						cellData;
					
					if (subTh && gvs.items.length>0) { 
						if (colIndex >= gvs.items[0].items.length || colIndex<0 || subTh.length === 0) { 
							return THRESHOLD_UNDEFINED; 
						}
						for (i in gts_es) {
							if (gts_es.hasOwnProperty(i)) {
								cellData = gvs.items[me.getIndexFromHdrindex(i)].items[colIndex];
								if (cellData.hasOwnProperty("ty") && parseInt(cellData.ty,10)===4) {
									return THRESHOLD_IMAGE;
								}
							}						
						}
						
						var isImgReg = /(jpg|jpeg|png|gif|tiff|bmp)$/i;
						for (elem in subTh) {
							if (subTh.hasOwnProperty(elem) && isImgReg.test(subTh[elem].n)) {
								return THRESHOLD_IMAGE;
							}
						}

						for (i in gts_es) {
							if (gts_es.hasOwnProperty(i)) {
								cellData = gvs.items[me.getIndexFromHdrindex(i)].items[colIndex];
								if (cellData.hasOwnProperty("ty") && parseInt(cellData.ty,10)===2) {
									return THRESHOLD_COLOR;
								}
							}						
						}
						return THRESHOLD_UNDEFINED;
					} else { 
						return THRESHOLD_UNDEFINED;
					}
				},
				
				
				scalePolygonCoords: function scalePolygonCoords() { 
					var me = this,
						model = me.model,
						coords = model.coords;
					
					var maxX = 0,
						maxY = 0, 
						rgn, c, i, j, k;

					for (i in coords) {
						if (coords.hasOwnProperty(i)) {
							if (i === "bgImage") {
								continue;
							}
							rgn = coords[i];
							for (j in rgn) {
								if (rgn.hasOwnProperty(j)) {
								c = rgn[j];
									for (k = 0; k < c.length; k++) {
										if (c[k] > maxX) {
											maxX = c[k];
										}
										k++;
										if (c[k] > maxY) {
											maxY = c[k];
										}							
									}
								}							
							}
						}					
					}

					var xRatio = maxX / ((this.getWidth() - 10) * this.scaleFactor),
						yRatio = maxY / ((this.getHeight() - 10) * this.scaleFactor),
						ratio = Math.max(yRatio, xRatio) ;
					
					
					this.topOffset = (this.getHeight()*this.scaleFactor - maxY/ratio) / 2 ;
					this.leftOffset = (this.getWidth()*this.scaleFactor - maxX/ratio) / 2 ;
					
					
					for (i in coords) {
						if (coords.hasOwnProperty(i)) {
							if (i === "bgImage") {
								continue;
							}
							rgn = coords[i];
							for (j in rgn) {
								if (rgn.hasOwnProperty(j)) {
									c = rgn[j];
									for (k = 0; k < c.length; k++) {
										c[k] = parseInt(c[k] / ratio, 10);
									}
								}							
							}
						}					
					}
				},
				
				
				getBubbleColorFromName: function getBubbleColorFromName(elem) {
					if (this.allBubblesColor && this.allBubblesColor.hasOwnProperty(elem)) {
						return this.allBubblesColor[elem];
					} else {
						return null;
					}
				},
				
				getBgColorFromCSS: function getBgColorFromCSS(cellData) {
					var cssDiv = this.cssDiv,
						csss = null,
						th = null,
						cni,
						cssStyle;
					if (this.model.hasOwnProperty("css")) {
						csss = this.model.css;
					}
					if (this.model.hasOwnProperty("th")) {
						th = this.model.th && this.model.th[this.colorByIndex];
					}
									
					if (csss && th && cellData && cellData.hasOwnProperty("ty")) {
						if ((parseInt(cellData.ty, 10) === 2 || parseInt(cellData.ty, 10) === 4) && cellData.hasOwnProperty("ti") && th.length>cellData.ti && th[cellData.ti].udbg===1) {
							
							cni = th[cellData.ti].cni;
							cssDiv.className = cni && csss[cni] && csss[cni].n;
							cssStyle = mstrmojo.css.getComputedStyle(cssDiv);
							if (cssStyle.hasOwnProperty("backgroundColor")) {
								return cssStyle.backgroundColor;
							}




						}
					}

					return null;
				},

				
				drawPolygonInMap: function drawPolygonInMap(opacity) {
					var me = this,
						model = me.model,
						coords = model.coords,
						context = this.animationContext,
						elem;
					
					me.animationCanvas.width = me.animationCanvas.width;
					
					
					if (me.drawBgImageFlag && model.bgImg) {
						var xRatio = me.oriBgImageWidth / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
							yRatio = me.oriBgImageHeight / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), 
							ratio = Math.max(yRatio, xRatio); 
						
						me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
						me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;

						context.drawImage(model.bgImg, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
					}
					
					me.curPolygonOpacity = opacity;
					
					var noAltColor = POLY_COLOR_NO_ALT_DARK_THEME,
						noColorByColor = POLY_COLOR_NO_COLORBY_DARK_THEME,
						strokeColor = POLY_STROKE_COLOR_DARK_THEME;
					if (model.themeMode === THEME_LIGHT) {
						noAltColor = POLY_COLOR_NO_ALT_LIGHT_THEME;
						noColorByColor = POLY_COLOR_NO_COLORBY_LIGHT_THEME;
						strokeColor = POLY_STROKE_COLOR_LIGHT_THEME;
					}
					
					if (model.vp && model.vp.npc) {
						noAltColor = getOpacityColor("#"+model.vp.npc, POLY_NORMAL_OPACITY);
					}
					
					
					for (elem in coords) {
						if (!coords.hasOwnProperty(elem)) {
							continue;
						}
						if (coords.hasOwnProperty(elem)) {
							if (elem === "bgImage") {
								continue;
							}
							
							
							var clr = noAltColor;
							
							
							if (me.displayMode === DISPLAY_MODE_AREA) {
								var hdrIndex = this.getHeaderIndex(elem);
								if (hdrIndex >= 0) {
									if (me.colorByIndex >= 0) { 
										var mv = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
										clr = me.getBgColorFromCSS(mv);
										if (!clr) {
											clr = noColorByColor;
										}
										if (me.drawBgImageFlag) {
											clr = getOpacityColor(clr, POLY_ABOVE_BG_OPACITY);
										} else {
											clr = getOpacityColor(clr, POLY_NORMAL_OPACITY);
										}
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
									} else {
										clr = noColorByColor;
									}
								} else {
									clr = noAltColor;
								}
							} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
								clr = noAltColor;
							}
						}					
						
						clr = getOpacityColor(clr, opacity);

						
						
						
						drawPoly(context, coords[elem], {x:this.leftOffset,y:this.topOffset}, strokeColor, me.polygonStrokeWidth, clr);
					}
				},
				
				
				getRadiusFromName: function getRadiusFromName(name) {
					var me = this,
						model = me.model;
					
					if (model.coords.hasOwnProperty(name)) {
						if (me.model.hasOwnProperty("oriBubbleSize")) {
							return me.model.oriBubbleSize[name] * me.scaleFactor;
						} else {
							if (me.model.hasOwnProperty("maxBubbleRadius")) {
								return me.model.maxBubbleRadius * me.scaleFactor;
							} else {
								return 2;
							}
						}					
					} else {
						return -1;
					}
				},


				
				drawBubblesInMap: function drawBubblesInMap() {
					var me = this,
						model = me.model,
						coords = model.coords,
						elem;
					if (model.hasOwnProperty("polygonCenters")) {
						coords = model.polygonCenters;
					}
					
					me.highlightCanvas.width = me.highlightCanvas.width;
					
					var defBubbleColor = BUBBLE_COLOR_NO_COLORBY_DARK_THEME,
						strokeColor = BUBBLE_STROKE_COLOR_DARK_THEME;
					if (model.themeMode === THEME_LIGHT) {
						defBubbleColor = BUBBLE_COLOR_NO_COLORBY_LIGHT_THEME;
						strokeColor = BUBBLE_STROKE_COLOR_LIGHT_THEME;
					}
					var defRadius = Math.max(2, Math.min(12, MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER*0.15*Math.min(me.getWidth(),me.getHeight())));
					defRadius = defRadius * me.scaleFactor;
					
					var th = model.th && model.th[me.colorByIndex];
					if (me.markerType === MARKER_IMAGE) {
						var notFoundImageIconPath = me.getFullPath("images/image_not_found.jpg");
							defaultImageIconPath = me.getFullPath("images/roundedpp.png");
						
							
							
						for (elem in coords) {
							if (coords.hasOwnProperty(elem)) {
								if (elem === "bgImage") {
									continue;
								}
								var propName = "imageIcon_" + elem;
								
								
								if (model.hasOwnProperty(propName)) {
									var _image = model[propName];
									if (_image && _image.width && _image.height && _image.width<me.getWidth()*me.scaleFactor && _image.height<me.getHeight()*me.scaleFactor) {
										var xOffset = coords[elem][0][0] - _image.width/2 + me.leftOffset,
											yOffset = coords[elem][0][1] - _image.height/2 + me.topOffset;
										me.animationContext.drawImage(_image, xOffset, yOffset);
									}
									continue;
								}
								
								
								var hdrIndex = me.getHeaderIndex(elem);
								if (th && hdrIndex >= 0 && me.colorByIndex >= 0 && me.thresholdType === THRESHOLD_IMAGE) {
									var cellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
									if (cellData.hasOwnProperty("ty") && parseInt(cellData.ty, 10) === 4) {
										var iconPath = th.length>cellData.ti && th[cellData.ti].n;
										if (iconPath) {
											var fullIconPath = me.getFullPath(iconPath);
											model[propName] = new Image();
											model[propName].src = fullIconPath;
											model[propName].id = elem;
											model[propName].onload = function() {
												if (this.width<me.getWidth()*me.scaleFactor && this.height<me.getHeight()*me.scaleFactor) {
													var xOffset = coords[this.id][0][0] - this.width/2 + me.leftOffset,
														yOffset = coords[this.id][0][1] - this.height/2 + me.topOffset;
													me.animationContext.drawImage(this, xOffset, yOffset);
													
													
													



													
													
													
													
													
													
													if (me.defaultSelectedObjs.hasOwnProperty(this.id)) {
														me.highlightCanvas.width = me.highlightCanvas.width;
														for (var dftSltObj in me.defaultSelectedObjs) {
															if (me.defaultSelectedObjs.hasOwnProperty(dftSltObj)) {
																me.highlightImageIcon(me.highlightContext, coords, dftSltObj, 0);
															}
														}
													}
												}
											};
											model[propName].onerror = function() {
												model["imageIcon_" + this.id].src = notFoundImageIconPath;
											};
										}								
									} else { 
										
										model[propName] = new Image();
										model[propName].src = defaultImageIconPath;
										model[propName].id = elem;
										model[propName].onload = function() {
											if (this.width<me.getWidth()*me.scaleFactor && this.height<me.getHeight()*me.scaleFactor) {
												var xOffset = coords[this.id][0][0] - this.width/2 + me.leftOffset,
													yOffset = coords[this.id][0][1] - this.height/2 + me.topOffset;
												me.animationContext.drawImage(this, xOffset, yOffset);
												
												if (me.defaultSelectedObjs.hasOwnProperty(this.id)) {
													me.highlightImageIcon(me.highlightContext, coords, this.id, 0);
												}
											}
										};
										model[propName].onerror = function() {
											model["imageIcon_" + this.id].src = notFoundImageIconPath;
										};
									}							
								} else { 
									delete coords[elem];
								}
							}
							
						}
						
						if (!me.imageIconScreenshotTaken) {
							me.imageIconScreenshotTaken = true;
							
						}					
					} else if (me.markerType === MARKER_BUBBLE) {
						for (elem in coords) {
							if (!coords.hasOwnProperty(elem)) {
								continue;
							}
							if (elem === "bgImage" 
								|| elem === (me.currHoverObj && me.currHoverObj.touchVal)
								|| elem === (me.currSelectedObj && me.currSelectedObj.touchVal)
								|| elem === (me.currLinkObj && me.currLinkObj.touchVal)
								|| (!isOwnEmpty(me.defaultSelectedObjs) && me.defaultSelectedObjs.hasOwnProperty(elem))) {
								continue;
							}
							var bubbleColor = defBubbleColor,
								bubbleRadius = defRadius,
								hdrIndex = me.getHeaderIndex(elem);
							if (hdrIndex >= 0) { 
								if (me.sizeByIndex >= 0) {
									
									bubbleRadius = me.getRadiusFromName(elem);
								}
								if (me.colorByIndex >= 0 && me.thresholdType === THRESHOLD_COLOR) {
									bubbleColor = me.getBubbleColorFromName(elem);
									
									if (!bubbleColor) {
										bubbleColor = defBubbleColor;
									} else {
										bubbleColor = getOpacityColor(bubbleColor, BUBBLE_NORMAL_OPACITY);
									}
								}
								
								var offset = {x:me.leftOffset, y:me.topOffset};
								drawBubble(me.highlightContext, coords[elem][0], offset, bubbleColor, bubbleRadius);
								drawStroke(me.highlightContext, coords[elem][0], offset, strokeColor, bubbleRadius, me.bubbleStrokeWidth);
							} else { 
								delete coords[elem];
							}						
						}
					}			   	

				},
				
				
				getOriPolygonCoords: function getOriPolygonCoords() {
					var me = this,
						model = me.model,
						coords = model.coords,
						i,
						j,
						k,
						rgn,
						c;
					
					if (!model.hasOwnProperty("oriPolyCoords")) {
						model.oriPolyCoords = {};
						for (i in coords) {
							if (coords.hasOwnProperty(i)) {
								if (i === "bgImage") {
									continue;
								}
								var arr2 = [];
								rgn = coords[i];
								for (j in rgn) {
									if (rgn.hasOwnProperty(j)) {
										c = rgn[j];
										var arr1 = [];
										for (k=0; k<c.length; k++) {
											arr1.push(c[k]);
										}
										arr2.push(arr1);
									}								
								}
								model.oriPolyCoords[i] = arr2;
							}
						}
					}
				},
				
				
				getAllBubblesColor: function getAllBubblesColor() {
					var me = this,
						model = me.model,
						coords = model.coords,
						elem;
					
					
	 
					if (me.haveAllBubblesColor) {
						return;
					} else {
						
						
						
						me.allBubblesColor = {};
					}
					
					var defBubbleColor = BUBBLE_COLOR_NO_COLORBY_DARK_THEME;
					if (model.themeMode === THEME_LIGHT) {
						defBubbleColor = BUBBLE_COLOR_NO_COLORBY_LIGHT_THEME;
					}
					
					if (me.markerType === MARKER_BUBBLE && me.colorByIndex >= 0 && me.thresholdType === THRESHOLD_COLOR) {
						for (elem in coords) {
							if (coords.hasOwnProperty(elem)) {
								if (elem === "bgImage") {
									continue;
								}
								var hdrIndex = me.getHeaderIndex(elem);
								if (hdrIndex >= 0) { 
									var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex],
										bubbleColor = me.getBgColorFromCSS(colorByCellData);
									
									if (!bubbleColor) {
										bubbleColor = defBubbleColor;
									}
									me.allBubblesColor[elem] = bubbleColor;
								} else { 
									
								}
							}												
						}
					}
				},
				
				
				getOriBubbleSize: function getOriBubbleSize() {
					var me = this,
						model = me.model,
						gvs = model.gvs,
						idxs = model.ghs.rhs.items,
						gts_es = model.gts.row[0].es,
						elem,i,j,k,pt,
						maxRadius = 0;
					
					
					





					
					
					var ratio = 1;
					if (model.vp.ty === "0") { 
						if (me.sizeByIndex < 0) {
							ratio = MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER;
						} else if (me.sizeByIndex >= 0) {
							ratio = MAX_SIZE_DEFAULT_RATIO_FOR_AUTOMATIC;
						}
					} else if (model.vp.ty === "1") { 
						if (model.vp.hasOwnProperty("val") && model.vp.val!==null && model.vp.val!=="") {
							ratio = parseFloat(model.vp.val);
							if (ratio > MAX_RATIO_UP_LIMIT) { ratio = MAX_RATIO_UP_LIMIT; }
							if (ratio < MAX_RATIO_LOW_LIMIT) { ratio = MAX_RATIO_LOW_LIMIT; }
						} else {
							if (me.sizeByIndex < 0) {
								ratio = MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER;
							} else if (me.sizeByIndex >= 0) {
								ratio = MAX_SIZE_DEFAULT_RATIO_FOR_MANUAL;
							}
						}					
					} else { 
						if (me.sizeByIndex < 0) {
							ratio = MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER*2;
						} else if (me.sizeByIndex >= 0) {
							ratio = MAX_SIZE_DEFAULT_RATIO_FOR_MANUAL*2;
						}
					}
					var maxMaxSize = me.baseMaxBubbleSizeAuto;
					if (me.sizeByIndex >= 0) { maxMaxSize = me.baseMaxBubbleSizeManual; }
									
					var baseSize = 0.15*Math.min(me.getWidth(), me.getHeight());
					if (model.vp.ty === "0") {
						maxRadius = Math.min(ratio*baseSize, maxMaxSize);
					} else if (model.vp.ty === "1") {
						maxRadius = ratio * baseSize;
					} else { 
						maxRadius = ratio * baseSize;
					}
					
					if (maxRadius <= 2) { maxRadius = 3; }
					me.model.maxBubbleRadius = maxRadius;
					
					
					if (me.sizeByIndex >= 0) {
						var idx = me.sizeByIndex,
							maxValue = Math.abs(parseFloat(gvs.items[0].items[idx].rv)),
							minValue = Math.abs(parseFloat(gvs.items[0].items[idx].rv));
						for (i in gts_es) {
							if (gts_es.hasOwnProperty(i)) {
								var gvsIndex = me.getIndexFromHdrindex(i),
									tempVal = Math.abs(parseFloat(gvs.items[gvsIndex].items[idx].rv));
								if (maxValue < tempVal) {
									maxValue = tempVal;
								}
								if (minValue > tempVal) {
									minValue = tempVal;
								}
							}						
						}
						
						var oriBubbleSize = {};
						if (maxValue > minValue) { 
							var minRadius = maxRadius * minValue / maxValue;
							if (minRadius < 2) { minRadius = 2; }
							var step = (maxRadius - minRadius) / (maxValue - minValue),
								radius;
							for (i in gts_es) {
								if (gts_es.hasOwnProperty(i)) {
									radius = (Math.abs(parseFloat(gvs.items[me.getIndexFromHdrindex(i)].items[idx].rv))-minValue) * step + minRadius;
									oriBubbleSize[gts_es[i].n] = radius;
								}							
							}

						} else {
							for (i=0; i<gts_es.length; i++) {
								oriBubbleSize[gts_es[i].n] = maxRadius;
							}
						}
						
						
						
						me.model.oriBubbleSize = oriBubbleSize;
						
					}
					
				},
				
				
				
				storeOriPoints: function storeOriPoints() {
					var coords = this.model.coords,
						oriCoords = {},
						point,
						newPoint,
						elem;
					for(elem in coords) {
						if (coords.hasOwnProperty(elem)) {
							point = coords[elem][0];
							newPoint = [point[0], point[1]];
							oriCoords[elem] = newPoint;
						}
					}
					return oriCoords;
				},
				
				
				drawBubbleMap: function drawBubbleMap() {
					var me = this,
						model = me.model,
						context = this.animationContext,
						coords = model.coords,
						elem,i,j,k,pt;
					
					



					
					
					me.getAllBubblesColor();
					
					me.getOriBubbleSize();

					
					if (model.hasOwnProperty("bgImg") && model.bgImg.hasOwnProperty("src") && model.bgImg.src!="" && model.bgImg.src!=null) {
						me.drawBgImageFlag = true;
						if (!me.hasOwnProperty("oriBgImageWidth")) { me.oriBgImageWidth = model.bgImg.width; }
						if (!me.hasOwnProperty("oriBgImageHeight")) { me.oriBgImageHeight = model.bgImg.height; }
						if (!me.hasOwnProperty("oriCoords")) { me.oriCoords = me.storeOriPoints(); }
						
						var xRatio = model.bgImg.width / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
							yRatio = model.bgImg.height / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), 
							ratio = Math.max(yRatio, xRatio); 
						
						me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
						me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
						
						context.drawImage(model.bgImg, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
						
						if (me.shapeFileType === SHAPE_FILE_POLYGON) {
						
							var polygonCenters = {};
							for (i in coords) {
								if (coords.hasOwnProperty(i)) {
									if (i === "bgImage") {
										continue;
									}
									var center = getCentroidOfPolygon(coords[i][0]);
									polygonCenters[i] = center;
									polygonCenters[i][0][0] /= ratio;
									polygonCenters[i][0][1] /= ratio;
								}
							}
							model.polygonCenters = polygonCenters;
						} else {
							
								var oriCoords = me.oriCoords;
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										pt = coords[i][0];
										pt[0] = parseInt(oriCoords[i][0] / ratio, 10);
										pt[1] = parseInt(oriCoords[i][1] / ratio, 10);
									}
								}
							
						}

						me.drawBubblesInMap();
					} else {
						model.bgImg = new Image();

						model.bgImg.onerror = function() {
							var errorMessage = "The backgrond Image cannot be found.";
							me.renderErrorMessage(mstrmojo.desc(9856, errorMessage));
							return;
						};

						model.bgImg.onload = function() {
							
							me.drawBgImageFlag = true;
							if (!me.hasOwnProperty("oriBgImageWidth")) { me.oriBgImageWidth = this.width; }
							if (!me.hasOwnProperty("oriBgImageHeight")) { me.oriBgImageHeight = this.height; }
							if (!me.hasOwnProperty("oriCoords")) { me.oriCoords = me.storeOriPoints(); }
							
							var xRatio = this.width / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
								yRatio = this.height / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), 
								ratio = Math.max(yRatio, xRatio); 
							
							me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
							me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
							
							me.animationCanvas.width = me.animationCanvas.width;
							context.drawImage(this, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
							
							if (me.shapeFileType === SHAPE_FILE_POLYGON) {
								
								var polygonCenters = {};
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										var center = getCentroidOfPolygon(coords[i][0]);
										polygonCenters[i] = center;
										polygonCenters[i][0][0] /= ratio;
										polygonCenters[i][0][1] /= ratio;
									}									
								}
								model.polygonCenters = polygonCenters;
							} else {
								
									var oriCoords = me.oriCoords;
									for (i in coords) {
										if (coords.hasOwnProperty(i)) {
											if (i === "bgImage") {
												continue;
											}
											pt = coords[i][0];
											pt[0] = parseInt(oriCoords[i][0] / ratio, 10);
											pt[1] = parseInt(oriCoords[i][1] / ratio, 10);
										}
									}
								
							}
								
							me.drawBubblesInMap();

							if (!me.bgImageScreenshotTaken) {
								me.bgImageScreenshotTaken = true;
								me.localTakeScreenshot(RENDERING_TIME);
							}						
						};
					}
					
					if (coords.hasOwnProperty("bgImage") && coords.bgImage!=="") {
						if (!model.hasOwnProperty("bgImg") || !model.bgImg.hasOwnProperty("src") || model.bgImg.src=="" || model.bgImg.src==null) {
							var bgImgPath = coords.bgImage;
							model.bgImg.src = me.getFullPath(bgImgPath);
							
							
						}					
					} else if (me.shapeFileType === SHAPE_FILE_POLYGON) { 
						me.drawBgImageFlag = false;
						me.scalePolygonCoords();
						me.drawPolygonInMap(POLY_UNDER_BUBBLE_OPACITY);
						
						
						var polygonCenters = {};
						for (i in coords) {
							if (coords.hasOwnProperty(i)) {
								if (i === "bgImage") {
									continue;
								}
								var center = getCentroidOfPolygon(coords[i][0]);
								polygonCenters[i] = center;
							}						
						}
						model.polygonCenters = polygonCenters;
						
						me.drawBubblesInMap();
					}
					
					

				},

				
				drawAreaMap: function drawAreaMap() {
					var me = this,
						model = me.model,
						context = this.animationContext,
						coords = model.coords,
						elem,i,j,k,rgn,oriRng,c,oriC,pt;
					
					if (!model.hasOwnProperty("oriPolyCoords")) {
						me.getOriPolygonCoords();
					}
					
					var oriCoords = model.oriPolyCoords;
					
					context.save();
					context.lineWidth = 2;
					context.strokeStyle = '#AAAAAA';
					
					
					if (model.hasOwnProperty("bgImg") && model.bgImg.hasOwnProperty("src") && model.bgImg.src!="" && model.bgImg.src!=null) {
						if (me.shapeFileType === SHAPE_FILE_POINT) { 
								me.drawBgImageFlag = false;
							} else if (me.shapeFileType === SHAPE_FILE_POLYGON) { 
								me.drawBgImageFlag = true;
								
								if (!me.hasOwnProperty("oriBgImageWidth")) { me.oriBgImageWidth = model.bgImg.width; }
								if (!me.hasOwnProperty("oriBgImageHeight")) { me.oriBgImageHeight = model.bgImg.height; }
								
								var xRatio = model.bgImg.width / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
									yRatio = model.bgImg.height / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), 
									ratio = Math.max(yRatio, xRatio);
								
								me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
								me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
								
								context.drawImage(model.bgImg, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
								
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										rgn = coords[i];
										oriRgn = oriCoords[i];
										for (j in rgn) {
											if (rgn.hasOwnProperty(j)) {
												c = rgn[j];
												oriC = oriRgn[j];
												for (k=0; k<c.length; k++) {
													c[k] = parseInt(oriC[k]/ratio, 10);
												}
											}										
										}
									}								
								}
								
								
								var polygonCenters = {};
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										var center = getCentroidOfPolygon(coords[i][0]);
										polygonCenters[i] = center;
									}								
								}
								model.polygonCenters = polygonCenters;
							
								me.drawPolygonInMap(POLY_ABOVE_BG_OPACITY);
							}
					} else {
						model.bgImg = new Image();
						
						model.bgImg.onerror = function() {
							var errorMessage = "The backgrond Image cannot be found.";
							me.renderErrorMessage(mstrmojo.desc(9856, errorMessage));
							return;
						};
						
						model.bgImg.onload = function() {
							if (me.shapeFileType === SHAPE_FILE_POINT) { 
								me.drawBgImageFlag = false;
							} else if (me.shapeFileType === SHAPE_FILE_POLYGON) { 
								me.drawBgImageFlag = true;
								
								if (!me.hasOwnProperty("oriBgImageWidth")) { me.oriBgImageWidth = this.width; }
								if (!me.hasOwnProperty("oriBgImageHeight")) { me.oriBgImageHeight = this.height; }
								
								var xRatio = this.width / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
									yRatio = this.height / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), 
									ratio = Math.max(yRatio, xRatio);
								
								me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
								me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
								
								context.drawImage(this, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
								
								
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										rgn = coords[i];
										oriRgn = oriCoords[i];
										for (j in rgn) {
											if (rgn.hasOwnProperty(j)) {
												c = rgn[j];
												oriC = oriRgn[j];
												for (k=0; k<c.length; k++) {
													c[k] = parseInt(oriC[k]/ratio, 10);
												}
											}
										}
									}
								}
								
								
								var polygonCenters = {};
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										var center = getCentroidOfPolygon(coords[i][0]);
										polygonCenters[i] = center;
									}								
								}
								model.polygonCenters = polygonCenters;
								
								me.drawPolygonInMap(POLY_ABOVE_BG_OPACITY);
							}
							if (!me.bgImageScreenshotTaken) {
								me.bgImageScreenshotTaken = true;
								me.localTakeScreenshot(RENDERING_TIME);
							}						
						}; 
					}
					
					
					if (coords.hasOwnProperty("bgImage") && coords.bgImage!=="") {
						if (!model.bgImg.hasOwnProperty("src") || model.bgImg.src=="" || model.bgImg.src==null) {
							model.bgImg.src = me.getFullPath(coords.bgImage);
						}					
					} else if (me.shapeFileType === SHAPE_FILE_POLYGON) {
						me.drawBgImageFlag = false;
						
						this.scalePolygonCoords();
						
						
						var polygonCenters = {};
						for (i in coords) {
							if (coords.hasOwnProperty(i)) {
								if (i === "bgImage") {
									continue;
								}
								var center = getCentroidOfPolygon(coords[i][0]);
								polygonCenters[i] = center;
							}						
						}
						model.polygonCenters = polygonCenters;
						
						
						











						
						this.drawPolygonInMap(POLY_NORMAL_OPACITY);

					}
					
					context.restore();
				},

				
				getHeaderIndex: function getHeaderIndex(headerName) {
					var hdrIndex = -1,
						hdrs = this.model.gts.row[0].es,
						i;

					if (headerName) {
						headerName = headerName.toLowerCase();
						for (i = 0; i < hdrs.length; i++) {
							var name = hdrs[i].n;
							if (name && name.toLowerCase() === headerName) {
								hdrIndex = i;
								break;
							}
						}
					}

					return hdrIndex;
				},
				
				
				getNewColorForOpacityChange: function getNewColorForOpacityChange(bgColor, haveBgImage, curColor, curOpacity, destOpacity) {
					if (curOpacity>1 || curOpacity<0 || destOpacity>1 || destOpacity<0) {
						return curColor;
					}
					
					var eps = 0.0001,
						newBgColor = bgColor;
					if (!bgColor || haveBgImage) { newBgColor = "#FFFFFF"; }				
					
					if (destOpacity >= curOpacity) {
						if (curOpacity + eps > 1) {
							return curColor;
						} else {
							return getOpacityColor(curColor, (destOpacity-curOpacity)/(1-curOpacity));
						}
					} else if (destOpacity < curOpacity) {
						if (curOpacity - eps < 0) {
							return getOpacityColor(curColor, 0);
						} else {
							return getOpacityColor(newBgColor, (curOpacity-destOpacity)/curOpacity);
						}
					}
				},
				
				
				drawPartOpacityBG: function drawPartOpacityBG(ctx, coordsArray, bgOpacity) {
					ctx.save();
				
					var me = this,
						model = me.model,
						offsetX = me.leftOffset ? me.leftOffset : 0,
						offsetY = me.topOffset ? me.topOffset : 0;
					
					var getPointAt = function(j){
						var offset = j%2  ? offsetY : offsetX;
						return pointsArray[j] + offset;
					};
					
					ctx.beginPath();
					
					var i,
						j;
					for (i = 0; i < coordsArray.length; i++) {
						var pointsArray = coordsArray[i],
							minX = getPointAt(0),
							minY = getPointAt(1),
							maxY = getPointAt(1),
							x,
							y;
		
						
						ctx.moveTo(getPointAt(0), getPointAt(1));
		
						for (j = 2; j < pointsArray.length - 1; j = j + 2) {
							x = getPointAt(j);
							y = getPointAt(j + 1);
		
							ctx.lineTo(x, y);
		
							
							maxY = Math.max(y, maxY);
							minY = Math.min(y, minY);
							minX = Math.min(x, minX);
						}
						
						
						x = getPointAt(0);
						y = getPointAt(1);
						ctx.lineTo(x, y);
					}
					
					ctx.clip();
					
					
					ctx.globalAlpha = bgOpacity;
					
					var xRatio = me.oriBgImageWidth / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
						yRatio = me.oriBgImageHeight / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), 
						ratio = Math.max(yRatio, xRatio);
					
					me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
					me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
					
					ctx.drawImage(model.bgImg, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
					
					
					ctx.restore();
				},
				
				
				highlightImageIcon: function highlightImageIcon(hlContext, coords, touchVal, radiusLarget) {
					var me = this,
						model = me.model,
						fillColor = "RGBA(255,255,255,0.5)",
						iconName = "imageIcon_" + touchVal;
					
					if (model.hasOwnProperty(iconName)) {								
						var imgIcon = model[iconName],
							width = imgIcon.width + radiusLarget*2,
							height = imgIcon.height + radiusLarget*2,
							xOffset = coords[touchVal][0][0] - width/2 + me.leftOffset,
							yOffset = coords[touchVal][0][1] - height/2 + me.topOffset;
						
						
						hlContext.fillStyle = fillColor;
						hlContext.fillRect(xOffset, yOffset, width, height);
						
						
						
						drawWhiteRectCorner(hlContext, xOffset, yOffset, width, height);
						
					}
				},

				
				highlightPoint: function highlightPoint() {
					var me = this,
						model = me.model,
						hlContext = me.highlightContext,
						hdrIndex; 
					
					
					me.highlightCanvas.width = me.highlightCanvas.width;
					
					
					if (me.currSelectedObj===null && isOwnEmpty(me.defaultSelectedObjs) && me.displayMode===DISPLAY_MODE_AREA) {
						if (me.drawBgImageFlag) {
							if (me.curPolygonOpacity !== POLY_ABOVE_BG_OPACITY) {
									me.drawPolygonInMap(POLY_ABOVE_BG_OPACITY);
							}
						} else {
							if (me.curPolygonOpacity !== POLY_NORMAL_OPACITY) {
								me.drawPolygonInMap(POLY_NORMAL_OPACITY);
							}
						}
					}

					if (me.displayMode === DISPLAY_MODE_AREA) {
						
						var bgColor = model.bgColor,
							selectedStrokeColor = POLY_STROKE_COLOR_SELECTED_DARK_THEME,
							hoverStrokeColor = POLY_STROKE_COLOR_HOVER_DARK_THEME,
							selectedHoverStrokeColor = POLY_STROKE_COLOR_SELECTED_HOVER_DARK_THEME,
							noAltColor = POLY_COLOR_NO_ALT_DARK_THEME,
							noColorByColor = POLY_COLOR_NO_COLORBY_DARK_THEME;
						if (model.themeMode === THEME_LIGHT) {
							selectedStrokeColor = POLY_STROKE_COLOR_SELECTED_LIGHT_THEME;
							hoverStrokeColor = POLY_STROKE_COLOR_HOVER_LIGHT_THEME;
							selectedHoverStrokeColor = POLY_STROKE_COLOR_SELECTED_HOVER_LIGHT_THEME;
							noAltColor = POLY_COLOR_NO_ALT_LIGHT_THEME;
							noColorByColor = POLY_COLOR_NO_COLORBY_LIGHT_THEME;
						}
						if (model.vp && model.vp.npc) {
							noAltColor = getOpacityColor("#"+model.vp.npc, POLY_NORMAL_OPACITY);
						}
						
						var fillColor = noAltColor;
						
						
						var dftSltObjs = me.defaultSelectedObjs;
						if (!isOwnEmpty(dftSltObjs)) {
							if (me.curPolygonOpacity !== POLY_UNSELECTED_OPACITY) {
								me.drawPolygonInMap(POLY_UNSELECTED_OPACITY);
							}	
							
							var i;
							for (i in dftSltObjs) {
								if (dftSltObjs.hasOwnProperty(i)) {
									if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null
											&& me.currHoverObj.touchVal===i) {
										continue;
									} else {
										var hIndex = me.defaultSelectedObjs[i]; 
										if (hIndex >= 0) {
											if (me.colorByIndex>=0) {
												if (me.thresholdType === THRESHOLD_COLOR) {
													var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hIndex)].items[me.colorByIndex];
													fillColor = me.getBgColorFromCSS(colorByCellData);
													if (!fillColor) {
														fillColor = noColorByColor;
													}
												} else {
													fillColor = noColorByColor;
												}								
											} else {
												fillColor = noColorByColor;
											}
																		
										} else {
											fillColor = noAltColor;
										}
										
										if (me.drawBgImageFlag) {
											fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_OPACITY_WITH_BG);
										} else {
											fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_OPACITY_WITHOUT_BG);
										}
										
										drawPoly(hlContext, model.coords[i], {x:me.leftOffset, y:me.topOffset}, selectedStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
									}
								}						
							}
							
							fillColor = noAltColor;
						} else if (me.currSelectedObj!==null && me.currSelectedObj.hasOwnProperty("touchVal") && me.currSelectedObj.touchVal!=="" && me.currSelectedObj.touchVal!==null) {
							if (me.curPolygonOpacity !== POLY_UNSELECTED_OPACITY) {
								me.drawPolygonInMap(POLY_UNSELECTED_OPACITY);
							}						
							
							if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null
									&& me.currHoverObj.touchVal===me.currSelectedObj.touchVal) {
								
							} else {
								if (me.currSelectedObj.hasOwnProperty("hdrIndex")) {
									hdrIndex = me.currSelectedObj.hdrIndex;
								} else {
									hdrIndex = me.getHeaderIndex(me.currSelectedObj.touchVal);
								}
								if (hdrIndex>=0) {
									if (me.colorByIndex>=0) {
										if (me.thresholdType === THRESHOLD_COLOR) {
											var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
											fillColor = me.getBgColorFromCSS(colorByCellData);
											if (!fillColor) {
												fillColor = noColorByColor;
											}
										} else {
											fillColor = noColorByColor;
										}								
									} else {
										fillColor = noColorByColor;
									}
																
								} else {
									fillColor = noAltColor;
								}
								
								if (me.drawBgImageFlag) {
									fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_OPACITY_WITH_BG);
								} else {
									fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_OPACITY_WITHOUT_BG);
								}
								
								drawPoly(hlContext, model.coords[me.currSelectedObj.touchVal], {x:me.leftOffset, y:me.topOffset}, selectedStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
							}
						} else if (me.currLinkObj!==null && me.currLinkObj.hasOwnProperty("touchVal") && me.currLinkObj.touchVal!=="" && me.currLinkObj.touchVal!==null) {
							if (me.currLinkObj.hasOwnProperty("hdrIndex")) {
									hdrIndex = me.currLinkObj.hdrIndex;
								} else {
									hdrIndex = me.getHeaderIndex(me.currLinkObj.touchVal);
								}
								if (hdrIndex>=0) {
									if (me.colorByIndex>=0) {
										if (me.thresholdType === THRESHOLD_COLOR) {
											var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
											fillColor = me.getBgColorFromCSS(colorByCellData);
											if (!fillColor) {
												fillColor = noColorByColor;
											}
										} else {
											fillColor = noColorByColor;
										}
									} else {
										fillColor = noColorByColor;
									}
																
								} else {
									fillColor = noAltColor;
								}
								
								if (me.drawBgImageFlag) {
									fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_ABOVE_BG_OPACITY, POLY_LINKDRILL_OPACITY);
								} else {
									fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_NORMAL_OPACITY, POLY_LINKDRILL_OPACITY);
								}						
								
								drawPoly(hlContext, model.coords[me.currLinkObj.touchVal], {x:me.leftOffset, y:me.topOffset}, hoverStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
						}
						if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null) {
								var hvObj = me.currHoverObj;
								
								if (hvObj.hasOwnProperty("hdrIndex")) {
									hdrIndex = hvObj.hdrIndex;
								} else {
									hdrIndex = me.getHeaderIndex(hvObj.touchVal);
								}
								
								if (hdrIndex>=0) {
									if (me.colorByIndex>=0) {
										if (me.thresholdType === THRESHOLD_COLOR) {
											var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
											fillColor = me.getBgColorFromCSS(colorByCellData);
											if (!fillColor) {
												fillColor = noColorByColor;
											}
										} else {
											fillColor = noColorByColor;
										}
									} else {
										fillColor = noColorByColor;
									}						
								} else {
									fillColor = noAltColor;
								}
								
								
								if (me.currSelectedObj!==null || !isOwnEmpty(me.defaultSelectedObjs)) { 
		
		
		
									
									if (me.drawBgImageFlag) {
										fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_HOVER_OPACITY_WITH_BG);
									} else {
										fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_HOVER_OPACITY_WITHOUT_BG);
									}

									drawPoly(hlContext, model.coords[me.currHoverObj.touchVal], {x:me.leftOffset, y:me.topOffset}, selectedHoverStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
								} else { 
									
									if (me.drawBgImageFlag) {
										
										var bgOpacity = (POLY_ABOVE_BG_OPACITY - POLY_HOVER_OPACITY) / POLY_ABOVE_BG_OPACITY;
										this.drawPartOpacityBG(hlContext, model.coords[me.currHoverObj.touchVal], bgOpacity);
										
										fillColor = "RGBA(0,0,0,0)";
										drawPoly(hlContext, model.coords[me.currHoverObj.touchVal], {x:me.leftOffset, y:me.topOffset}, hoverStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
									} else {
										fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_NORMAL_OPACITY, POLY_HOVER_OPACITY);
										drawPoly(hlContext, model.coords[me.currHoverObj.touchVal], {x:me.leftOffset, y:me.topOffset}, hoverStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
									}
									
									
								}						
								
								
								if (me.newRenderFlag) {
									
									me.newRenderFlag = false;
									var polygonCenter = me.model.polygonCenters && me.model.polygonCenters[me.currHoverObj.touchVal] && me.model.polygonCenters[me.currHoverObj.touchVal][0];
									if (polygonCenter) {
										var xOnWidget = polygonCenter[0] + me.leftOffset - me._scroller.origin.x;
										var yOnWidget = polygonCenter[1] + me.topOffset - me._scroller.origin.y;
										me.renderTooltip(this.currHoverObj.touchVal, xOnWidget, yOnWidget, this.currHoverObj.hdrIndex);
									}
								} else {
									me.renderTooltip(this.currHoverObj.touchVal, this.currHoverObj.point.x, this.currHoverObj.point.y, this.currHoverObj.hdrIndex);
								}
								
								

											
						}
					} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
						var selectedStrokeColor = BUBBLE_STROKE_COLOR_SELECTED_DARK_THEME,
							hoverStrokeColor = BUBBLE_STROKE_COLOR_HOVER_DARK_THEME,
							linkdrillStrokColor = BUBBLE_STROKE_COLOR_LINKDRILL_DARK_THEME,
							highlightStrokeColor = BUBBLE_HIGHLIGHT_STROKE_COLOR_DARK_THEME,
							noColorByColor = BUBBLE_COLOR_NO_COLORBY_DARK_THEME;
						if (model.themeMode === THEME_LIGHT) {
							selectedStrokeColor = BUBBLE_STROKE_COLOR_SELECTED_LIGHT_THEME;
							hoverStrokeColor = BUBBLE_STROKE_COLOR_HOVER_LIGHT_THEME;
							linkdrillStrokColor = BUBBLE_STROKE_COLOR_LINKDRILL_LIGHT_THEME;
							highlightStrokeColor = BUBBLE_HIGHLIGHT_STROKE_COLOR_LIGHT_THEME;
							noColorByColor = BUBBLE_COLOR_NO_COLORBY_LIGHT_THEME;
						}
						if (me.markerType === MARKER_BUBBLE) {
							me.drawBubblesInMap();
							
							
							var dftSltObjs = me.defaultSelectedObjs;
							if (!isOwnEmpty(dftSltObjs)) {
								var i;
								for (i in dftSltObjs) {
									if (dftSltObjs.hasOwnProperty(i)) {
										var sltBubbleRadius = me.getRadiusFromName(i);
										fillColor = me.getBubbleColorFromName(i);
										if (!fillColor) {
											continue;
										}
										
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
										
										
										fillColor = getOpacityColor(fillColor, BUBBLE_SELECTED_OPACITY);
										
										
										if (me.shapeFileType === SHAPE_FILE_POLYGON) {
											if (model.hasOwnProperty("polygonCenters")) {
												sltCoord = model.polygonCenters[i][0];
											}
										} else if (me.shapeFileType === SHAPE_FILE_POINT) {
											sltCoord = model.coords[i][0];
										}
										
										drawBubble(hlContext, sltCoord, {x:me.leftOffset,y:me.topOffset}, fillColor, sltBubbleRadius);
										drawStroke(hlContext, sltCoord, {x:me.leftOffset,y:me.topOffset}, selectedStrokeColor, sltBubbleRadius, me.bubbleStrokeWidth);
									}								
								}
								
								fillColor = noAltColor;
							} else if (me.currSelectedObj!==null && me.currSelectedObj.hasOwnProperty("touchVal") && me.currSelectedObj.touchVal!=="" && me.currSelectedObj.touchVal!==null) {
								var fillColor = noColorByColor,
									sltCoord,
									sltBubbleRadius;
								
								
								sltBubbleRadius = me.getRadiusFromName(me.currSelectedObj.touchVal);
								
								
								fillColor = me.getBubbleColorFromName(me.currSelectedObj.touchVal);
								if (!fillColor) {
									fillColor = noColorByColor;
								}






















								
								
								fillColor = getOpacityColor(fillColor, BUBBLE_SELECTED_OPACITY);
								
								
								if (me.shapeFileType === SHAPE_FILE_POLYGON) {
									if (model.hasOwnProperty("polygonCenters")) {
										sltCoord = model.polygonCenters[me.currSelectedObj.touchVal][0];
									}
								} else if (me.shapeFileType === SHAPE_FILE_POINT) {
									sltCoord = model.coords[me.currSelectedObj.touchVal][0];
								}
								
								drawBubble(hlContext, sltCoord, {x:me.leftOffset,y:me.topOffset}, fillColor, sltBubbleRadius);
								drawStroke(hlContext, sltCoord, {x:me.leftOffset,y:me.topOffset}, selectedStrokeColor, sltBubbleRadius, me.bubbleStrokeWidth);
							} else if (me.currLinkObj!==null && me.currLinkObj.hasOwnProperty("touchVal") && me.currLinkObj.touchVal!=="" && me.currLinkObj.touchVal!==null) {
								var linkCoord,
									linkBubbleRadius;
								
								
								linkBubbleRadius = me.getRadiusFromName(me.currLinkObj.touchVal);
								
								
								fillColor = me.getBubbleColorFromName(me.currLinkObj.touchVal);
								if (!fillColor) {
									fillColor = noColorByColor;
								}
								























								
								fillColor = getOpacityColor(fillColor, BUBBLE_LINKDRILL_OPACITY);
								
								
								if (me.shapeFileType === SHAPE_FILE_POLYGON) {
									if (model.hasOwnProperty("polygonCenters")) {
										linkCoord = model.polygonCenters[me.currLinkObj.touchVal][0];
									}
								} else if (me.shapeFileType === SHAPE_FILE_POINT) {
									linkCoord = model.coords[me.currLinkObj.touchVal][0];
								}
								
								drawBubble(hlContext, linkCoord, {x:me.leftOffset,y:me.topOffset}, fillColor, linkBubbleRadius);
								drawStroke(hlContext, linkCoord, {x:me.leftOffset,y:me.topOffset}, linkdrillStrokColor, linkBubbleRadius, me.bubbleStrokeWidth);
								drawStroke(hlContext, linkCoord, {x:me.leftOffset,y:me.topOffset}, highlightStrokeColor, linkBubbleRadius+me.hoverBubbleRadiusLarger, me.bubbleStrokeWidth);
							}
							if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null) {
								var hoverCoord, 
									hoverBubbleRadius,
									hoverTouchVal = me.currHoverObj.touchVal;
								
								
								hoverBubbleRadius = me.getRadiusFromName(hoverTouchVal);
								
								
								fillColor = me.getBubbleColorFromName(hoverTouchVal);
								if (!fillColor) {
									fillColor = noColorByColor;
								}
								























								
								var nodeStrokeColor = hoverStrokeColor;
								if ((me.currSelectedObj && me.currSelectedObj.touchVal===hoverTouchVal) 
										|| (!isOwnEmpty(me.defaultSelectedObjs) && me.defaultSelectedObjs.hasOwnProperty(hoverTouchVal))) {
									fillColor = getOpacityColor(fillColor, BUBBLE_SELECTED_OPACITY);
									nodeStrokeColor = selectedStrokeColor;
								} else {
									fillColor = getOpacityColor(fillColor, BUBBLE_HOVER_OPACITY);
								}
															
								
								
								if (me.shapeFileType === SHAPE_FILE_POLYGON) {
									if (model.hasOwnProperty("polygonCenters")) {
										hoverCoord = model.polygonCenters[me.currHoverObj.touchVal][0];
									}
								} else if (me.shapeFileType === SHAPE_FILE_POINT) {
									hoverCoord = model.coords[me.currHoverObj.touchVal][0];
								}
								
								drawBubble(hlContext, hoverCoord, {x:me.leftOffset,y:me.topOffset}, fillColor, hoverBubbleRadius); 
								drawStroke(hlContext, hoverCoord, {x:me.leftOffset,y:me.topOffset}, nodeStrokeColor, hoverBubbleRadius, me.bubbleStrokeWidth);
								drawStroke(hlContext, hoverCoord, {x:me.leftOffset,y:me.topOffset}, highlightStrokeColor, hoverBubbleRadius+me.hoverBubbleRadiusLarger, me.bubbleStrokeWidth);
								
								
								if (me.newRenderFlag) {
									
									me.newRenderFlag = false;
									var _center;
									if (me.shapeFileType === SHAPE_FILE_POLYGON) {
										_center = me.model.polygonCenters && me.model.polygonCenters[me.currHoverObj.touchVal] && me.model.polygonCenters[me.currHoverObj.touchVal][0];
									} else if (me.shapeFileType === SHAPE_FILE_POINT) {
										_center = me.model.coords && me.model.coords[me.currHoverObj.touchVal] && me.model.coords[me.currHoverObj.touchVal][0];
									}
									if (_center) {
										var xOnWidget = _center[0] + me.leftOffset - me._scroller.origin.x;
										var yOnWidget = _center[1] + me.topOffset - me._scroller.origin.y;
										me.renderTooltip(this.currHoverObj.touchVal, xOnWidget, yOnWidget, this.currHoverObj.hdrIndex);
									}
								} else {
									me.renderTooltip(this.currHoverObj.touchVal, this.currHoverObj.point.x, this.currHoverObj.point.y, this.currHoverObj.hdrIndex);
								}
								
					
							}
							
						} else if (me.markerType === MARKER_IMAGE) { 
							var coords = model.coords;
							if (model.hasOwnProperty("polygonCenters")) {
								coords = model.polygonCenters;
							}
							
							
							var dftSltObjs = me.defaultSelectedObjs;
							if (!isOwnEmpty(dftSltObjs)) {

								var i;

								for (i in dftSltObjs) {
									if (dftSltObjs.hasOwnProperty(i)) {
										me.highlightImageIcon(hlContext, coords, i, 0);
















									}								
								}
								

							} else if (me.currSelectedObj!==null && me.currSelectedObj.hasOwnProperty("touchVal") && me.currSelectedObj.touchVal!=="" && me.currSelectedObj.touchVal!==null) {
								var touchVal = me.currSelectedObj.touchVal;
								me.highlightImageIcon(hlContext, coords, touchVal, 0);

								
















								
							} else if (me.currLinkObj!==null && me.currLinkObj.hasOwnProperty("touchVal") && me.currLinkObj.touchVal!=="" && me.currLinkObj.touchVal!==null) {
								var touchVal = me.currLinkObj.touchVal;


								
								me.highlightImageIcon(hlContext, coords, touchVal, me.hoverBubbleRadiusLarger);
















							}
							if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null) {
								var touchVal = me.currHoverObj.touchVal,
									fillColor = "RGBA(255,255,255,0.5)";
								
								var iconName = "imageIcon_" + touchVal;
								if (model.hasOwnProperty(iconName)) {
									var imgIcon = model[iconName],
										width = imgIcon.width + me.hoverBubbleRadiusLarger*2,
										height = imgIcon.height + me.hoverBubbleRadiusLarger*2,
										xOffset = coords[touchVal][0][0] - width/2 + me.leftOffset,
										yOffset = coords[touchVal][0][1] - height/2 + me.topOffset;
									
									
									hlContext.fillStyle = fillColor;
									hlContext.fillRect(xOffset, yOffset, width, height);
									
									
									
									var sltObj = me.currSelectedObj,
										hvTouchVal = me.currHoverObj.touchVal;
									if ((sltObj!==null && sltObj.hasOwnProperty("hdrIndex") && sltObj.hdrIndex >= 0 && sltObj.touchVal === hvTouchVal) 
											|| (!isOwnEmpty(me.defaultSelectedObjs) && me.defaultSelectedObjs.hasOwnProperty(hvTouchVal))) {
										
									} else {
										drawWhiteRectCorner(hlContext, xOffset, yOffset, width, height);
									}
								}
								
								
								if (me.newRenderFlag) {
									
									me.newRenderFlag = false;
									var _center;
									if (me.shapeFileType === SHAPE_FILE_POLYGON) {
										_center = me.model.polygonCenters && me.model.polygonCenters[me.currHoverObj.touchVal] && me.model.polygonCenters[me.currHoverObj.touchVal][0];
									} else if (me.shapeFileType === SHAPE_FILE_POINT) {
										_center = me.model.coords && me.model.coords[me.currHoverObj.touchVal] && me.model.coords[me.currHoverObj.touchVal][0];
									}
									if (_center) {
										var xOnWidget = _center[0] + me.leftOffset - me._scroller.origin.x;
										var yOnWidget = _center[1] + me.topOffset - me._scroller.origin.y;
										me.renderTooltip(this.currHoverObj.touchVal, xOnWidget, yOnWidget, this.currHoverObj.hdrIndex);
									}
								} else {
									me.renderTooltip(this.currHoverObj.touchVal, this.currHoverObj.point.x, this.currHoverObj.point.y, this.currHoverObj.hdrIndex);
								}
								
					
							}
						}
					}
					
				},
					

				
				getTouchValue: function getTouchValue(x, y) {
					var me = this,
						model = this.model,
						coords = model.coords,
						elem,
						i;				

					
					if (me.displayMode === DISPLAY_MODE_AREA) {
						if (me.shapeFileType === SHAPE_FILE_POLYGON) {
							for (elem in coords) {
								if (coords.hasOwnProperty(elem)) {
									if (elem === "bgImage") {
										continue;
									}
									var coordsArray = coords[elem],
										l = coordsArray.length;
									for (i = 0; i < l; i++) {
										if (inPoly(coordsArray[i], x, y)) {
											return elem;
										}
									}
								}							
							}
						}
					} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
						if (me.shapeFileType === SHAPE_FILE_POLYGON && model.hasOwnProperty("polygonCenters")) {
							coords = model.polygonCenters;
						}
						var minDistance = Number.MAX_VALUE,
							touchName = "";
						for (elem in coords) {
							if (coords.hasOwnProperty(elem)) {
								if (elem === "bgImage") {
									continue;
								}
								var coord = coords[elem][0],
									distance = Math.sqrt((x-coord[0])*(x-coord[0])+(y-coord[1])*(y-coord[1]));
								if (distance < minDistance) {
									minDistance = distance;
									touchName = elem;
								}
							}						
						}
						
						if (minDistance < this.bias) {
							return touchName;
						}
											
					}
					










					return null;
				},


				
				
				getAreaOrNearestBubble: function (isTap, touchX, touchY){
					var me = this,
						model = me.model,
						coords = model.coords;
					
					
					
					var touchPointOnWidget = me.utils.getTouchXYOnWidget(touchX, touchY, me);
					touchX = touchPointOnWidget.touchX;
					touchY = touchPointOnWidget.touchY;
					
					
					var x = touchX+ me._scroller.origin.x-me.leftOffset,
						y = touchY+ me._scroller.origin.y-me.topOffset,
						touchVal;
					if (isTap && me.tooltipOn && me.currHoverObj!==null) {
						var crHP = null;
						if (me.shapeFileType === SHAPE_FILE_POLYGON){
							crHP = model.polygonCenters && model.polygonCenters[me.currHoverObj.touchVal] && model.polygonCenters[me.currHoverObj.touchVal][0];
						} else if (me.shapeFileType === SHAPE_FILE_POINT) {
							crHP = coords[me.currHoverObj.touchVal] && coords[me.currHoverObj.touchVal][0]; 
						}
						
						if (crHP) {
							var dis = Math.sqrt((x-crHP[0])*(x-crHP[0]) + (y-crHP[1])*(y-crHP[1]));
							if (dis < me.bias) {
								touchVal = me.currHoverObj.touchVal;
							} else {
								touchVal = me.getTouchValue(x, y);
							}
						}
					} else {
						touchVal = me.getTouchValue(x, y);
					}
					
					if(!touchVal){
						return null;
					}
					
					var hdrIndex = me.getHeaderIndex(touchVal);

							
					return {touchVal:touchVal, hdrIndex:hdrIndex, point:{x:touchX, y:touchY}};
				},
				
				renderTooltip: function renderTooltip(touchVal, touchX, touchY, hdrIndex) {
					var me = this,
						tooltip = this.tooltip,
						model = this.model,
						table = this.tooltip.childNodes[0],
						tooltipIndex = 0,
						i, j, tr, tdLeft, tdRight;
					
					
					if (table) {
						for (i=0; i<table.childNodes.length; i++) {
							tr = table.childNodes[i];
							if (tr) {
								tr.childNodes[0].innerHTML = '';
								tr.childNodes[1].innerHTML = '';
							}
						}
					}
					
					
					this.tooltip.style.visibility = "visible";
					
					if (!me.tooltipOn) {				
						me.tooltipOn = true;
						
						var touchManager = mstrmojo.touchManager;
						me.tooltipListener = touchManager.attachEventListener('touchesBegin', me.id, function (evt) {
							if(!me.isTouchedOnWidget(evt.touch)){
								me.hideTooltip();
							}
						});
					}				

					var gts = model.gts,
						leftHtml,
						rightHtml;

					if (hdrIndex >= 0) {
						var rows = gts.row,
							idxs = model.ghs.rhs.items,
							idx;
						
						
						tr = tooltipIndex<table.childNodes.length && table.childNodes[tooltipIndex++];
						if (tr) {
							
							tr.childNodes[0].style.display = 'table-cell';
							tr.childNodes[1].style.align = 'left';
							
							tr.childNodes[0].style.paddingRight = "5px";
							leftHtml = rows[0].n + ':';
							tr.childNodes[0].innerHTML = leftHtml;
							
							rightHtml = rows[0].es[hdrIndex].n;
							tr.childNodes[1].innerHTML = rightHtml;
						}
						
						
						var ghsIndex = me.getIndexFromHdrindex(hdrIndex);
						for (i=1; i<rows.length; i++) {
							tr = tooltipIndex<table.childNodes.length && table.childNodes[tooltipIndex++];
							if (tr) {
								tr.childNodes[0].style.paddingRight = "5px";
								leftHtml = rows[i].n + ':';
								tr.childNodes[0].innerHTML = leftHtml;
								rightHtml = '';
								var _indices = me.attrIndices[i];
								if (_indices) {
									for (j=0; j<_indices.length; j++) {
										
										idx = idxs[ghsIndex].items[_indices[j]].idx;
										rightHtml += rows[i].es[idx].n;
										if (j !== _indices.length-1) {
											rightHtml += ' ';
										}
									}							
								}						
								tr.childNodes[1].innerHTML = rightHtml;
							}
						}
						
						
						var gtsCol = gts.col;
						if (gtsCol && gtsCol.length>0) {
							var units = gtsCol[0].es,
								values = model.gvs.items[ghsIndex].items;

							for (i = 0; i < units.length; i++) {
								tr = tooltipIndex<table.childNodes.length && table.childNodes[tooltipIndex++];
								if (tr) {
									tr.childNodes[0].style.paddingRight = "5px";
									var mv = values[i],
										v = mv.v;
									
									if (mv && mv.hasOwnProperty('ty') && mv.ty!=4 && mv.ty!=10 && mv.ty!=3 && mv.hasOwnProperty('ti')) {
										var th = model.th && model.th[i];
										v = (th && th[mv.ti] && th[mv.ti].n) ? th[mv.ti].n : mv.v;
									}
									
									leftHtml = units[i].n + ':';
									tr.childNodes[0].innerHTML = leftHtml;
									rightHtml = '' + v;
									tr.childNodes[1].innerHTML = rightHtml;
								}							
							}
						} else {
							
						}
					} else if (hdrIndex < 0) {
						rightHtml = touchVal;
						tr = tooltipIndex<table.childNodes.length && table.childNodes[tooltipIndex++];
						if (tr) {
							tr.childNodes[1].innerHTML = rightHtml;
							tr.childNodes[0].style.display = 'none';
							tr.childNodes[1].style.align = 'center';
							
							
						}					
					}
					
					
					var TLx = touchX + this.bias,
						TLy = touchY - this.bias - tooltip.offsetHeight,
						RightX = this.getWidth() - tooltip.offsetWidth - this.tooltipRightShadowWidth, 
						RightY = this.getHeight() - tooltip.offsetHeight;   
					if (TLx > RightX) {
						if (TLy < 0) {
							TLy = 0;
							TLx = Math.max(touchX - this.bias - tooltip.offsetWidth, 0);
						} else if (TLy >= 0) {
							TLx = RightX;
						}
					} else if (TLx <= RightX) {
						if (TLy < 0) {
							TLy = 0;
						} else if (TLy >= 0) {
							
						}
					}
					
					
					positionTooltip(tooltip, TLx, TLy);
				},
				
				
				hideTooltip: function hideTooltip() {
					if(this.tooltipOn){	
						this.tooltipOn = false;	
						this.currHoverObj = null;					
						this.highlightPoint();	
						






						
						
						
						this.tooltip.style.visibility = "hidden";
						
						
						
						if (this.tooltipListener) {
							
							
							mstrmojo.touchManager.detachEventListener(this.tooltipListener);
							delete this.tooltipListener;
						}						
					}
				},

				
				
				isTouchedOnWidget: function isTouchedOnWidget(touch) {
					
					if(!touch){
						return false;
					}
					
					var me = this,
						touchPointOnWidget = me.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, me),
						x = touchPointOnWidget.touchX,
						y = touchPointOnWidget.touchY;

					if ((x > 0 && x < me.getWidth()) && (y >0 && y < me.getHeight())) {
						return true;
					}
					return false;
				},
				
				unrender: function unrender(ignoreDom) {
					var me = this,
						model = me.model;
										
					if (this._super) {
						this._super(ignoreDom);
					}
					
					if (me.docModelListener) {
						if (me.xtabModel && me.xtabModel.docModel) {
							me.xtabModel.docModel.detachEventListener(me.docModelListener);
						}						
						delete me.docModelListener;
					}
					
					if (me.fullScreenListener) {
						mstrmojo.touchManager.detachEventListener(me.fullScreenListener);
						delete me.fullScreenListener; 
					}
	
					if (me.tooltipListener) {
						mstrmojo.touchManager.detachEventListener(me.tooltipListener);
						delete me.tooltipListener;
					}
					
					if (me.highlightContext) {
						delete me.highlightContext;
					}
					if (me.animationContext) {
						delete me.animationContext;
					}
									
					if (me._tn) {
						delete me._tn;
					}
					
				},
				
				destroy: function destroy() {
					
					if (this._super) {
						this._super();
					}
				}

			}

			

	);

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
        "mstrmojo._HasLayout",
        "mstrmojo.android.ui.PromptsList",
        "mstrmojo.android.ui.Button");

    mstrmojo.requiresDescs(2550, 3649, 3650);

    var $DESC = mstrmojo.desc,
        $100 = '100%';

    
    function passToParent(methodName, args) {
        
        var parent = this.parent;
        if (parent[methodName]) {
            
            parent[methodName].apply(parent, args);
            return true;
        }

        
        return false;
    }

    
    var $PV = mstrmojo.android.ui.PromptsView = mstrmojo.declare(
        mstrmojo.Container,

        [ mstrmojo._HasLayout ],

        
        {
            scriptClass: 'mstrmojo.android.ui.PromptsView',

            markupString: '<div id="{@id}" class="mstrmojo-Prompts {@cssClass}" style="{@cssText}">' +
                '<div class="summary"></div>' +
                '<div class="command"></div>' +
                '</div>',

            markupSlots: {
                summaryNode: function () {
                    return this.domNode.firstChild;
                },
                cmdNode: function () {
                    return this.domNode.lastChild;
                }
            },

            layoutConfig: {
                h: {
                    summaryNode: $100,
                    cmdNode: '90px'
                },
                w: {
                    summaryNode: $100,
                    cmdNode: $100
                }
            },

            init: function init(props) {
                this._super(props);

                var prompts = this.prompts,
                    supportedPrompts = this.supportedPrompts;

                
                if (prompts && supportedPrompts) {
                    
                    var cmdButton = mstrmojo.android.ui.Button.newButton((prompts.host.st === 14081) ? $DESC(3650, 'Run Document') : $DESC(3649, 'Run Report'), function () {
                        this.parent.controller.answerPrompts();
                    }, {
                        slot: 'cmdNode',
                        alias: 'cmdButton',
                        cssClass: 'mstrmojo-GlowButton',
                        ignoreLayout: true,
                        enabled: mstrMobileApp.isOnline(),                    
                        glowClass: 'glow'
                    });

                    
                    var publisher = mstrmojo.publisher;
                    publisher.subscribe(publisher.NO_SRC, publisher.CONNECTIVITY_CHANGED_EVENT, function (isOnline) {
                        
                        this.cmdButton.set('enabled', isOnline);
                    }, this.id);

                    
                    this.addChildren([ cmdButton ]);

                    
                    if (mstrApp.isTablet()) {
                        
                        supportedPrompts = [
                            {
                                title: $DESC(2550, 'FILTERS'),
                                isTtl: true
                            }
                        ].concat(supportedPrompts);
                    }

                    
                    this.promptList.set('items', supportedPrompts);
                }
            },

            
            rootOrientationChange: function rootOrientationChange() {
                
                if (!this.ignoreRotation) {
                    
                    mstrApp.closeDialog();
                }
            },

            children: [
                {
                    scriptClass: 'mstrmojo.android.ui.PromptsList',
                    slot: 'summaryNode',
                    alias: 'promptList',
                    canItemLinger: function canItemLinger(item) {
                        return !mstrApp.isTablet() || item.getStyle() === mstrmojo.prompt.WebPrompt.STYLES.SWITCH;
                    }
                }
            ],

            openPrompt: function openPrompt(fnOpen) {

                var controller = this.controller;

                
                if (!controller.prevController && !controller.nextController) {
                    return;
                }

                
                this.ignoreRotation = true;
                
                if (!passToParent.call(this, 'openPrompt', [ fnOpen ])) {
                    
                    fnOpen();
                }
                var me = this;
                window.setTimeout(function () {
                    delete me.ignoreRotation;
                }, 300);
            },

            closePrompt: function closePrompt() {
                passToParent.call(this, 'closePrompt');
            }
        }
    );

    
    mstrmojo.DPIManager.registerClass($PV, 'h', 'cmdNode', {
        160: 60,
        213: 60,
        240: 90,
        320: 120
    });

}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.HomeScreenController",
                         "mstrmojo.android.controllers._HasFolderView",
                         "mstrmojo.hash");


    
    mstrmojo.android.large.controllers.HomeScreenController = mstrmojo.declare(

    	mstrmojo.android.controllers.HomeScreenController,

        [ mstrmojo.android.controllers._HasFolderView ],

        
        {
            scriptClass: "mstrmojo.android.large.controllers.HomeScreenController",

            start: function start(params) {
                this._super(params);

                
                var view = this.initFolderView(),
                	hs = mstrApp.getConfiguration().getHomeScreen(true);

                
                view.set('items', hs.btns);

                
                this.rootCtrl.updateFolder(view);

                
                this.updatePropertiesMsg();
            },

            openFolder: function openFolder(folder) {
                this.openItem(folder);
            },

            makeCurrent: function makeCurrent(isBack) {
                this._super(isBack);

                
                this.view.clearSelect();

                
                var rootCtrl = this.rootCtrl;
                rootCtrl.updateFolder(this.view);

                
                rootCtrl.restoreNavigation();

                
                this.updatePropertiesMsg();
            },

            goUp: function goUp() {
                
                if (!this._super()) {
                    
                    this.rootCtrl.goBack();
                }

                
                return true;
            }        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.RootController",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.hash");

    var EnumHSType = mstrmojo.android.controllers.RootController.EnumHSType,
        $BTN = mstrmojo.android.ui.Button.newButton,
        $HASH = mstrmojo.hash;

    
    mstrmojo.android.large.controllers.RootController = mstrmojo.declare(

        mstrmojo.android.controllers.RootController,

        null,

        
        {
            scriptClass: "mstrmojo.android.large.controllers.RootController",

            initHomeScreen: function initHomeScreen(screenType, params) {
                
                if (screenType === EnumHSType.RESULTSET) {
                    this._super(screenType, params);
                } else {
                    
                    this.initNav();

                    
                    this.spawn(mstrApp.controllerFactory.newController('Browser', params), $HASH.copy(params, {
                        screenType: screenType
                    }));
                }
            },

            updateFolder: function updateFolder(folderView, title, isBack) {
                
                if (folderView) {
                    
                    this.nextController.updateFolder(folderView, title, isBack);
                }

                this._super(folderView, title, isBack);
            },

            updateProperties: function updateProperties(view, title) {
                
                this.nextController.updateProperties(view);
            },
            
            updateDisplayMessage: function updateDisplayMessage(view){

            	this.nextController.updateDisplayMessage(view);
            },            

            updateTransactions: function updateTransactions(txView, title) {
                
                txView.isElastic = true;

                
                var tabletDimensions = mstrApp.getScreenDimensions();
                txView.elasticHeight = Math.round(tabletDimensions.h * 0.406);
                txView.width = Math.round(tabletDimensions.w * (mstrApp.isLandscape() ? 0.43 : 0.65)) + 'px';

                
                this._txDialog = mstrApp.showDialog({
                    title: title,
                    cssClass: 'txDialog',
                    onTitleClick: function (evt) {
                        
                        if (evt.target.tagName.toLowerCase() === 'em') {
                            
                            txView.goBack();
                        }
                    },
                    btnVisible: false,         
                    children: [ txView ],
                    buttons: [ $BTN(mstrmojo.desc(9252, 'Delete'), function () {
                        
                        txView.deleteRecord();
                        return false;
                    }), $BTN(mstrmojo.desc(9253, 'Edit'), function () {
                        
                        txView.editRecord();
                        return false;
                    })],
                    goBack: function () {
                        
                        return txView.controller.rootCtrl.goBack();
                    }
                });

                
                this.generateActionToolbar();
            },

            closeTransactions: function closeTransactions() {
                
                var txDialog = this._txDialog;
                if (txDialog) {
                    
                    txDialog.children[0].controller.detach();

                    
                    txDialog.close();
                    delete this._txDialog;

                    
                    this.generateActionToolbar();
                }
            },

            spawn: function spawn(controller, startParams) {
                var ctrlType = controller.type;
                if (ctrlType !== 'Browser' && ctrlType !== "Document" && ctrlType !== "Report" && ctrlType !== "Graph") {
                    var nextCtrl = this.nextController;
                    if (!nextCtrl || nextCtrl.type !== 'Browser') {
                        if (nextCtrl) {
                            nextCtrl.destroy();
                        }

                        
                        this._super(mstrApp.controllerFactory.newController('Browser'), {});
                        nextCtrl = this.nextController;
                    }

                    nextCtrl.spawn(controller, startParams);

                    return;
                }

                this._super(controller, startParams);
            },

            contentUpdated: function contentUpdated(subtype) {
                this._super(subtype);

                
                if (subtype === 2048) {
                    
                    this.nextController.syncPath();
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList",
                         "mstrmojo.android.controllers.SettingsController",
                         "mstrmojo.android._HasLingeringListSelections",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.ui.MobileCheckList",
                         "mstrmojo.android.ui.TextInput",
                         "mstrmojo.android.ui.ValidationTextInput",
                         "mstrmojo.expr",
                         "mstrmojo.array",
                         "mstrmojo.css");

    mstrmojo.requiresDescs(221, 1442, 7883, 9454);

    var $STYLES = mstrmojo.android.controllers.SettingsController.STYLES,
        $BTN = mstrmojo.android.ui.Button.newButton,
        $ARR = mstrmojo.array,
        $VAL = mstrmojo.validation,
        $TRIG = $VAL.TRIGGER,
        $SC = $VAL.STATUSCODE,
        itemMarkup = {},
        $D = mstrmojo.dom,
        $TRANS_DURATION = $D.CSS3_TRANSITION_DURATION;

    
    mstrmojo.android.ui.SettingsView = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        [ mstrmojo.android._HasLingeringListSelections ],

        
        {
            scriptClass: "mstrmojo.android.ui.SettingsView",

            init: function init(props) {
                this._super(props);

                
                mstrmojo.css.addWidgetCssClass(this, 'mstrmojo-AndroidSettings');
            },

            
            allowTouchBubble: false,

            
            getList: function getList() {
                return this;
            },

            listHooks: {
                select: function (el, item, idx) {
                    
                    el.style[$TRANS_DURATION] = 0;

                    
                    if (item.disabled) {
                        
                        return true;
                    }

                    
                    if (item.style !== $STYLES.VIEW_BUTTON) {
                        
                        this.setClearHandler(200);
                    }
                },
                unselect: function (el, item, idx) {
                    
                    el.style[$TRANS_DURATION] = '300ms';
                }
            },

            getItemMarkup: function (item) {
                var s = item.style;
                
                if (!itemMarkup[s]) {
                    
                    var newMarkup = '<div><h3>{@ttl}</h3><h4>{@value}</h4></div>';

                    
                    if (s === $STYLES.TEXT_AREA) {
                        
                        newMarkup = '<div readonly="readonly">{@ttl}</div>';

                    
                    } else if (s === $STYLES.IMAGE) {
                        
                        newMarkup = '<h3></h3>';
                    }

                    
                    itemMarkup[s] = this._super(item).replace('{@n}', newMarkup);
                }

                return itemMarkup[s];
            },

            getItemProps: function getItemProps(item, idx) {
                var value = item.v,
                    props = this._super(item, idx);

                
                props.ttl = item.nm;
                props.value = value || '';

                
                var cls = item.cls;
                if (cls) {
                    
                    props.addCls(cls);
                }

                
                var fnTimeNumberText = function () {
                    
                    props.addCls('drop-down');

                    
                    if (item.pwd) {
                        props.value = '********';

                    
                    } else if (item.showHint && value === '') {
                        props.value = mstrmojo.desc(9454, '&lt;not set&gt;');

                    }
                };

                
                switch (item.style) {

                case $STYLES.TEXT_AREA:
                    props.addCls('textarea');
                    break;

                case $STYLES.HEADER:
                    
                    props.addCls('header');
                    break;

                    case $STYLES.TIME:
                    
                    props.value = new Date((item.v < 60000) ? item.v * 60000 : item.v).toJSON().replace(/.*T/, '').replace(/\.[0-9]{3}Z/, '');
                    fnTimeNumberText();
                    break;

                case $STYLES.NUMBER:
                case $STYLES.TEXT:
                    fnTimeNumberText();
                    break;

                case $STYLES.LIST:
                    
                    props.addCls('drop-down');

                    
                    var items = item.items;
                    props.value = items[$ARR.find(items, 'v', value)].n;
                    break;

                case $STYLES.CHECK:
                    
                    props.addCls('check');

                    
                    if (value === item.on) {
                        
                        props.addCls('on');
                    }

                    
                    props.value = item.desc;
                    break;
                }

                
                if (item.hidden) {
                    
                    props.addCls('hidden');

                
                } else if (item.disabled) {
                    
                    props.addCls('disabled');

                    
                    props.value = '';
                }

                
                if (props.value) {
                    
                    props.addCls('with-desc');
                }

                return props;
            },

            
            touchSelectBegin: function touchSelectBegin(touch) {
                
                var idx = this.getItemIdxTouch(touch);
                if (idx > -1) {
                    
                    var item = this.items[idx],
                        fnPress = item.fnPress;

                    
                    if (fnPress) {
                        
                        fnPress.call(this.controller, item);

                        
                        return false;
                    }
                }

                
                return true;
            },

            preselectionChange: function preselectionChange(evt) {
                
                var added = evt.added;
                if (!added) {
                    
                    return true;
                }

                
                var idx = added[0],
                    item = this.items[idx];

                
                if (item.disabled || item.noclick) {
                    
                    return false;
                }

                
                if (item.style === $STYLES.HEADER) {
                    
                    if (!this._listTarget.getAttribute('hidx')) {
                        
                        return false;
                    }
                }

                
                return true;
            },

            
            postselectionChange: function postselectionChange(evt) {
                var added = evt.added;
                if (!added) {
                    return;
                }

                
                var idx = added[0],
                    item = this.items[idx];

                
                var me = this,
                    dialogConfig = {
                        title: item.nm
                    },
                    dialogChildren = [],
                    fnOk,
                    dialog,
                    fnUpdateValue = function (item, value) {
                        
                        item.fn(value);

                        
                        me.updateItem(idx);
                    };

                
                switch (item.style) {
                case $STYLES.HEADER:
                    
                    var headerIdx = this._listTarget.getAttribute('hidx');
                    if (headerIdx) {
                        
                        this.controller.jumpTo(parseInt(headerIdx, 10), true);
                    }
                    break;

                case $STYLES.BUTTON:
                case $STYLES.VIEW_BUTTON:
                    
                    if (item.fn) {
                        
                        item.fn();
                    }
                    break;

                case $STYLES.NUMBER:
                case $STYLES.TEXT:
                    var isNum = (item.style === $STYLES.NUMBER),
                        tb = {
                            scriptClass: 'mstrmojo.android.ui.' + (isNum ? 'Validation' : '') + 'TextInput',
                            alias: 'textInput',
                            textValue: item.v,
                            textType: isNum ? 'number' : (item.pwd ? 'password' : 'text'),
                            onEnter: function (value) {
                                
                                fnUpdateValue(item, value);

                                
                                dialog.close();
                            }
                        };

                    
                    if (isNum) {
                        
                        tb.valProps = {
                            dtp: mstrmojo.expr.DTP.UNSIGNED,
                            min: item.limits.min,
                            max: item.limits.max,
                            constraints: {
                                trigger: $TRIG.ONKEYUP,
                                validator: function (v) {
                                    v = parseInt(v, 10);

                                    var min = this.min,
                                        max = this.max,
                                        msg = (v >= min && v <= max) ? '' : mstrmojo.desc(7883).replace('##', min).replace('###', max);

                                    return {
                                        code: msg ? $SC.INVALID : $SC.VALID,
                                        msg: msg
                                    };
                                }
                            }
                        };
                    }

                    
                    dialogChildren.push(tb);

                    
                    fnOk = function () {
                        
                        var eb = dialog.textInput;
                        if (eb.validate) {
                            
                            eb.validate();

                            
                            if (eb.isValid()) {

                                
                                fnUpdateValue(item, eb.getValue());
                                return true;
                            }

                            
                            return false;
                        }

                        
                        fnUpdateValue(item, eb.getValue());
                        return true;
                    };

                    break;

                case $STYLES.LIST:
                    var items = item.items;

                    
                    var optionList = new mstrmojo.ui.MobileCheckList({
                        items: items,
                        multiSelect: false,
                        isElastic: true,
                        selectedIndex: $ARR.find(items, 'v', item.v)
                    });

                    
                    dialogChildren.push(optionList);

                    
                    fnOk = function () {
                        
                        fnUpdateValue(item, items[optionList.selectedIndex].v);
                    };
                    break;

                case $STYLES.CHECK:
                    
                    fnUpdateValue(item, (item.v === item.on) ? item.off : item.on);
                    break;

                case $STYLES.TIME:
                    

                    
                    var v = (item.v < 60000) ? item.v * 60000 : item.v,
                        date = new Date(v),
                        timePicker = new mstrmojo.ui.MobileDateTimePicker({
                            value: {
                                time: {
                                    hour: date.getUTCHours(),
                                    min: date.getUTCMinutes(),
                                    sec: 0
                                }
                            },
                            is24HourMode: false,
                            dtp: mstrmojo.expr.DTP.TIME
                        });

                    dialogChildren.push(timePicker);

                    
                    fnOk = function () {
                        var time = timePicker.getTime();
                        
                        fnUpdateValue(item, time.hour * 60 + time.min);
                    };
                    break;
                }

                
                if (dialogChildren.length) {
                    
                    dialogConfig.children = dialogChildren;

                    
                    if (fnOk) {
                        
                        dialogConfig.buttons = [ $BTN(mstrmojo.desc(221, 'Cancel')), $BTN(mstrmojo.desc(1442, 'OK'), fnOk) ];
                    }

                    
                    dialog = mstrApp.showDialog(dialogConfig);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.hash",
                         "mstrmojo.dom",
                         "mstrmojo.array",
                         "mstrmojo._ResultSetXt",
                         "mstrmojo._ReportDataService");

    function submitAndGetResults(request, callback, config, resultParams) {
        var me = this;

        mstrApp.serverRequest(request, {
            success: function (res) {
                
                me.msgId = res.id;

                
                me.visName = res.visName;

                
                me.getResults(resultParams, callback);
            },
            
            
            failure: function( res ) {
            	if ( callback.failure ) {
            		callback.failure( res );
            	}
            },
            canceled: function() {
            	if ( callback.canceled ) {
            		callback.canceled();
            	}
            }
        }, config);
    }

    function waitConfig(noHideWait, isProgress) {
        var cfg = {
            hideWait: !noHideWait,
            delay: true    
        };
        
        
        cfg['show' + (isProgress ? 'Progress' : 'Wait')] = true;
        
        
        return cfg;
    }

    var promptObjType = {
        objectType: 3
    };

    var $C = mstrmojo.hash.copy,
        $ARR = mstrmojo.array;

    function getXtabStyleName() {
        var styleName = 'MojoXtabStyle',       
            visName = this.visName;            

        
        if (visName) {
            
            
            
            var visObj = mstrmojo.AndroidVisList.getVis(visName);

            
            styleName = (visObj && visObj.s) || styleName;
        }

        return styleName;
    }

    
    mstrmojo.XtabDataService = mstrmojo.declare(
        mstrmojo.Obj,

        [ mstrmojo._ResultSetXt, mstrmojo._ReportDataService ],

        
        {
            scriptClass: "mstrmojo.XtabDataService",

            
            execute: function execute(params, callback, resParams) {
                var id = this.id;

                
                var ab = this.controller.ab;
                if (ab) {
                    var abArr = ab.split('|'),
                        visId = mstrApp.isTablet() ? '73^' : '72^';
                        
                    $ARR.forEach( abArr, function(value, index, arr) {
                        var i = value.indexOf( visId );
                        if (i >= 0) {
                            mstrmojo.all[id].visName = value.substring(i + 3);
                            return false;
                        }
                    } );
                }

                var request = mstrmojo.hash.copy(params, {});
                request.taskId = request.taskId || 'reportExecute';
                request.reportID = request.reportID || this.dssId;
                
                
                request.styleName = mstrApp.isTablet() ? "AndroidTabletMessageResultStyle" : "AndroidMessageResultStyle";                
                
                if (params) {
                    if (params.dssId) {
                        request.reportID = params.dssId;
                    }
                }
                this.dssId = request.reportID;
                this._super(request, callback, resParams);
            },

            
            getResults: function getResults(params, callback) {
                var styleName = getXtabStyleName.call(this),
                    dpi = mstrMobileApp.getDeviceDPI(),
                    zoom = 160;       
                
                if (dpi < 160) {
                    zoom = 80; 
                } else if (dpi > 240) {
                    zoom = 230;
                }

                 
                var request = {
                    taskId: 'iPhoneGetReportResults',
                    styleName:  styleName,
                    zoomFactor: zoom,
                    deviceMode: mstrApp.isTablet ? (mstrApp.isTablet() ? 73 : 72) : 0   
                };

                if (params) {
                    var pbUnits = params.pbUnits,
                        yPos = params.yPos,
                        colsPerPage = params.colsPerPage,
                        rowPerPage = params.rowsPerPage;

                    if (pbUnits) {
                        request.pageByKeys = this.pageByUnitsToKeys(pbUnits);
                    }
                    if (yPos) {
                        request.yPos = yPos;
                    }
                    
                    if (colsPerPage) {
                        request.colsPerPage = colsPerPage;
                    }
                    if (rowPerPage) {
                        request.rowsPerPage = rowPerPage;
                    }
                }

                this._super(request, callback);
            },

            
            answerPrompts: function answerPrompts(prompts, callback) {
                this._super(prompts, callback, $C(promptObjType));
            },

            
            loadPrompts: function loadPrompts(callback, request) {
                this._super(callback, $C(promptObjType, request));
            },

            drill2Grid: function drill2Grid(params, callback) {
                var p = {
                    taskId: 'RWGridDrillToReport',
                    msgID: params.srcMsgId,
                    displayMode: -1,
                    retainParent: 3,
                    retainThreshold: 3,
                    drillPathKey: params.drillPathKey,
                    drillPathIndex: params.drillPathIndex,
                    elementList: params.drillElements,
                    nodeKey: params.nodeKey,
                	
                    rwGroupByElements: params.rwGroupByElements
                };
                
                
                if (params.sliceId) {
                    p.sliceId = params.sliceId;
                }
                
                submitAndGetResults.call(this, p, callback, waitConfig(true, true));
            },

            drillGrid: function drillGrid(params, callback) {
                submitAndGetResults.call(this, {
                    taskId: 'gridDrill',
                    msgID: params.srcMsgId,
                    drillPathKey: params.drillPathKey,
                    drillPathIndex: params.drillPathIndex,
                    elementList: params.drillElements
                }, callback, waitConfig(true, true));
            },

            pageBy: function pageBy(pbUnits, callback) {
                var app = mstrApp,
                    request = {
                        taskId: 'changePageBy',
                        messageID: this.msgId,
                        pageByKeys: this.pageByUnitsToKeys(pbUnits)
                    };

                if (!app.useBinaryFormat) {
                    request.taskId = 'iPhoneGetReportResults';
                    request.styleName = getXtabStyleName.call(this);
                    request.zoomFactor = 200; 
                }

                mstrApp.serverRequest(request, callback, waitConfig());
            },

            sort: function sort(params, callback) {
                submitAndGetResults.call(this, {
                    taskId: 'gridSort',
                    msgID: this.msgId,
                    sortKey: params.sortKey,
                    sortOrder: ((params.isAsc) ? 1 : 0),
                    subtotalPos: params.subTotalsPos,
                    clearSorts: 1
                }, callback, waitConfig());
            },

            pivot: function pivot(params, callback) {
                var request = {
                    taskId: 'gridPivot',
                    msgID: this.msgId,
                    objectId: params.objectId,
                    pos: params.pos,
                    objectType: params.objectType
                };

                if (params.axis) {
                    request.axis = params.axis;
                }

                submitAndGetResults.call(this, request, callback, waitConfig());
            },

            
            getImage: function getImage(url) {
                if (url && url.indexOf('://') === -1) {
                    
                    url = mstrApp.getConfiguration().getHostUrlByProject(mstrApp.getCurrentProjectId()) + url;
                }

                return (mstrApp.useBinaryFormat) ? String(mstrMobileApp.getImage(url)) : url;
            },

            
            downloadGridData: function downloadGridData(params, callback) {
                mstrApp.serverRequest({
                    taskId: 'DocXtabIncrementalFetch',
                    nodeKey: '',
                    rowPosition: params.rowPosition,
                    maxRows: params.maxRows,
                    colPosition: -1,
                    maxColumns: -1
                }, callback);
            }
        }
    );
}());
(function () {
    
    mstrmojo.requiresCls("mstrmojo.DocDataService", 
                         "mstrmojo._ResultSetXt");
    
    var docObjType = {
        objectType: 55
    };
    var $C = mstrmojo.hash.copy;
    
    
    mstrmojo.DocDataServiceXt = mstrmojo.declare(
        mstrmojo.DocDataService,

        [ mstrmojo._ResultSetXt ],

        
        {
            scriptClass: "mstrmojo.DocDataServiceXt",
            
            
            execute: function execute(params, callback, resParams) {
                var request = mstrmojo.hash.copy(params, {});
                
                
                request.taskId = 'RWExecute';
                
                
                if (!request.objectID) {
                    request.objectID = (params && params.dssId) || this.dssId;
                }
                 
                
                this.dssId = request.objectID;
                
                
                this._super(request, callback, resParams);
            },
             
            
            getResults: function getResults(params, callback) {  
                params = params || {};
                params.taskId = params.taskId || 'androidRWExecute';
                params.styleName = params.styleName || 'RWDocumentMobileStyle';
                params.useTerseElementId = params.useTerseElementId || 1;
                 
                
                
                
                var dim = this.model.controller.getContentDimensions(); 
                params.availableWidth = dim.w;
                params.availableHeight = dim.h;
                params.executionOrientation = mstrMobileApp.getOrientation();
                
                this._super(params, this.wrapCallback(callback));
            },
             
            
            answerPrompts: function answerPrompts(prompts, callback) {
                this._super(prompts, this.wrapCallback(callback), $C(docObjType));
            },
             
            
            loadPrompts: function loadPrompts(callback, request) {
                this._super(this.wrapCallback(callback), $C(docObjType, request));
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.hash",
                         "mstrmojo._ResultSetXt",
                         "mstrmojo._ReportDataService",
                         "mstrmojo._IsGraphDataService");

    var promptObjType = {
            objectType: 3
        },
        waitConfig = {
            showWait: true,
            hideWait: true
        },
        $C = mstrmojo.hash.copy;

    function getResultsParams() {
        var availableDim = mstrApp.getContentDimensions(true);

        return {
            taskId: 'getReportGraphImage',
            height: 0,
            width: 0,
            availHeight: availableDim.h,
            availWidth: availableDim.w,
            imgType: 4,
            showTooltips: true
        };
    }
    
    mstrmojo.GraphDataService = mstrmojo.declare(
        mstrmojo.Obj,

        [ mstrmojo._ResultSetXt, mstrmojo._ReportDataService, mstrmojo._IsGraphDataService ],

        
        {
            scriptClass: "mstrmojo.GraphDataService",

            
            execute: function execute(params, callback) {
                var request = mstrmojo.hash.copy(params, {});

                request.taskId = request.taskId || 'reportExecute';

                request.reportID = request.reportID || (params && params.dssId) || this.dssId;
                this.dssId = request.reportID;

                this._super(request, callback);
            },

            
            getResults: function getResults(params, callback) {
                this._super(getResultsParams(), callback);
            },

             
            answerPrompts: function answerPrompts(answer, callback) {
                this._super(answer, callback, $C(promptObjType));
            },

            
            loadPrompts: function loadPrompts(callback, request) {
                this._super(callback, $C(promptObjType, request));
            },

            pageBy: function pageBy(pbUnits, callback) {
                var app = mstrApp,
                    request = {
                        taskId: 'changePageBy',
                        messageID: this.msgId,
                        pageByKeys: this.pageByUnitsToKeys(pbUnits)
                    };

                if (!app.useBinaryFormat) {
                    $C(getResultsParams(), request);
                }

                mstrApp.serverRequest(request, callback, waitConfig);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.FolderDataService",
                         "mstrmojo.XtabDataService",
                         "mstrmojo.DocDataServiceXt",
                         "mstrmojo.GraphDataService",
                         "mstrmojo.RptXtabModel",
                         "mstrmojo.ResultSetDocumentModel",
                         "mstrmojo.GraphModel",
                         "mstrmojo.prompt.WebPrompts",
                         "mstrmojo.maps.AndroidMapModel",
                         "mstrmojo.mstr.ElementDataService",
                         "mstrmojo.SubscriptionsDataService");

    
    mstrmojo.android.factories.ModelFactory = mstrmojo.declare(

        mstrmojo.Obj,

        null,

        
        {
            scriptClass: 'mstrmojo.android.factories.ModelFactory',

            
            newFolderDataService: function newFolderDataService(params) {
                return new mstrmojo.FolderDataService(params);
            },

            
            newXtabDataService: function newXtabDataService(params) {
                return new mstrmojo.XtabDataService(params);
            },

            
            newGraphDataService: function newGraphDataService(params) {
                return new mstrmojo.GraphDataService(params);
            },

            
            newDocumentDataService: function newDocumentDataService(params) {
                return new mstrmojo.DocDataServiceXt(params);
            },

            
            newElementDataService: function newElementDataService() {
                return mstrmojo.mstr.ElementDataService;
            },

            
            newSubscriptionsDataService: function newSubscriptionsDataService() {
                return new mstrmojo.SubscriptionsDataService();
            },

            
            newXtabModel: function newXtabModel(params) {
                return new mstrmojo.RptXtabModel(params);
            },

            
            newDocumentModel: function newDocumentModel(params) {
                return new mstrmojo.ResultSetDocumentModel(params);
            },

            
            newGraphModel: function newGraphModel(params) {
                return new mstrmojo.GraphModel(mstrmojo.hash.copy(params, {
                    dataService: this.newGraphDataService()
                }));
            },

            
            newPromptsModel: function newPromptsModel(prompts, answers) {
                
                var promptModel = new mstrmojo.prompt.WebPrompts({
                    rsl: prompts
                });

                
                if (answers) {
                    
                    promptModel.populateAnswers(answers);
                }

                
                return promptModel;
            },

            
            newMapModel: function newMapModel(params) {
                return new mstrmojo.maps.AndroidMapModel(params);
            },

            
            newDataService: function newDataService(type, params) {
                return this['new' + type + 'DataService'](params);
            },

            
            newModel: function newModel(type, params) {
                return this['new' + type + 'Model'](params);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo.android.ui.SettingsView",
                         "mstrmojo.css",
                         "mstrmojo.array");

    var $100 = '100%';

    
    function getWidthLayoutCfg(isPortrait) {
        var frameWidth = isPortrait ? 100 : 85,
            navWidth = Math.round(frameWidth * 0.33),
            percent = '%';

        return {
            frameNode: frameWidth + percent,
            navNode: navWidth + percent,
            detailsNode: (frameWidth - navWidth) + percent
        };
    }

    
    function adjustDetailsDimensions(isDetails, h, w) {
        
        var borderWidth = this._borderWidth || 12;

        
        if (isDetails) {
            
            h = (parseInt(h, 10) - borderWidth) + 'px';
            w = (parseInt(w, 10) - borderWidth) + 'px';
        }

        
        return {
            h: h,
            w: w
        };
    }

    
    mstrmojo.android.large.ui.SettingsView = mstrmojo.declare(

        mstrmojo.Container,

        [ mstrmojo._HasLayout ],

        
        {
            scriptClass: "mstrmojo.android.large.ui.SettingsView",

            markupString: '<div id="{@id}" class="mstrmojo-TabletSettings {@cssClass}" style="{@cssText}" >' +
                              '<div>' +
                                  '<div></div>' +
                                  '<div>' +
                                      '<div>' +
                                          '<div>' +
                                          '</div>' +
                                      '</div>' +
                                  '</div>' +
                              '</div>' +
                          '</div>',

            markupSlots: {
                frameNode: function () { return this.domNode.firstChild; },
                navNode: function () { return this.domNode.firstChild.firstChild; },
                detailsNode: function () { return this.domNode.firstChild.lastChild.firstChild.firstChild; }
            },

            layoutConfig: {
                h: {
                    frameNode: $100,
                    navNode: $100,
                    detailsNode: $100
                },
                w: getWidthLayoutCfg()
            },

            children: [{
                scriptClass: 'mstrmojo.android.ui.SettingsView',
                alias: 'nav',
                slot: 'navNode',
                cssClass: 'navList',
                preselectionChange: function preselectionChange(evt) {
                    
                    var added = evt.added;
                    if (!added) {
                        
                        return;
                    }

                    
                    this.parent.controller.jumpTo(0);
                }
            }, {
                scriptClass: 'mstrmojo.android.ui.SettingsView',
                alias: 'details',
                slot: 'detailsNode',
                cssClass: 'detailsList',
                setDimensions: function (h, w) {
                    
                    var adjusted = adjustDetailsDimensions.call(this.parent, true, h, w);

                    
                    mstrmojo.android.ui.SettingsView.prototype.setDimensions.call(this, adjusted.h, adjusted.w);
                }
            }, {
                scriptClass: 'mstrmojo.Label',                          
                slot: 'frameNode'
            }],

            postCreate: function postCreate() {
                
                var ctrl = this.controller;
                mstrmojo.array.forEach(this.children, function (child) {
                    
                    child.controller = ctrl;
                });
            },

            postBuildRendering: function postBuildRendering() {
                
                this.layoutConfig.w = getWidthLayoutCfg(!!this.controller.orientation);


















                
                this._borderWidth = {
                    160: 12,
                    213: 12,
                    240: 18,
                    320: 24
                }[mstrMobileApp.getDeviceDPI()];

                this._super();
            },

            rootOrientationChange: function rootOrientationChange(evt) {
                
                this.layoutConfig.w = getWidthLayoutCfg(!evt.isLandscape);

                
                this.doLayout();
            },

            
            getList: function getList(isHome) {
                return isHome ? this.nav : this.details;
            },

            
            setSlotDimensions: function setSlotDimensions(slot, h, w) {
                
                var adjusted = adjustDetailsDimensions.call(this, (slot === 'detailsNode'), h, w);

                
                this._super(slot, adjusted.h, adjusted.w);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._HasLayout",
                         "mstrmojo.android.ui.PromptsView",
                         "mstrmojo.css");

    function positionPromptsNode(promptsNodeStyle, position) {
        promptsNodeStyle.webkitTransitionDuration = (this._noAnimation) ? 0 : '';
        promptsNodeStyle.left = position;
    }

    
    var screenDimensions = mstrMobileApp.getScreenDimensions().split('|'),
        promptsNodeWidth = Math.round(Math.max(screenDimensions[0], screenDimensions[1]) * 0.33),
        promptsNodeOffset = Math.floor(promptsNodeWidth * 0.47);

    
    mstrmojo.android.large.ui.PromptsView = mstrmojo.declare(
        mstrmojo.Container,

        [ mstrmojo._HasLayout ],

        
        {
            scriptClass: 'mstrmojo.android.large.ui.PromptsView',

            markupString: '<div id="{@id}" class="mstrmojo-TabletPrompts {@cssClass}" style="{@cssText}">' +
                              '<div class="curtain" mstrAttach:click></div>' +
                              '<div class="prompts"></div>' +
                          '</div>',

            markupSlots: {
                promptsNode: function () { return this.domNode.lastChild; }
            },

            layoutConfig: {
                h: {
                    promptsNode: '100%'
                },
                w: {
                    promptsNode: promptsNodeWidth + 'px'
                }
            },

            init: function init(props) {
                this._super(props);

                
                this.addChildren([ {
                    scriptClass: 'mstrmojo.android.ui.PromptsView',
                    slot: 'promptsNode',
                    controller: this.controller,
                    prompts: this.prompts,
                    supportedPrompts: this.supportedPrompts
                } ]);
            },

            postBuildRendering: function postBuildRendering() {
                
                var maskNode = this.maskNode;
                if (maskNode) {
                    
                    maskNode.className = 'mask';

                    
                    var domNode = this.domNode;
                    mstrmojo.css.addClass(domNode, 'has-mask');

                    
                    domNode.appendChild(maskNode);
                }

                return this._super();
            },

            rootOrientationChange: function rootOrientationChange() {
                
                this._noAnimation = true;

                
                mstrApp.closeDialog();
            },

            openPrompt: function openPrompt(fnOpen) {
                
                if (this.controller.orientation) {
                    
                    var promptsNode = this.promptsNode;
                    mstrmojo.dom.attachOneTimeEvent(promptsNode, 'webkitTransitionEnd', function () {
                        
                        fnOpen();
                    });

                    
                    delete this._noAnimation;

                    
                    positionPromptsNode.call(this, promptsNode.style, '-' + promptsNodeOffset + 'px');
                } else {
                    
                    fnOpen();
                }
            },

            
            closePrompt: function closePrompt() {
                var promptsNodeStyle = this.promptsNode.style,
                    currentPosition = promptsNodeStyle.left;

                
                if (currentPosition && currentPosition !== '0px') {
                    
                    positionPromptsNode.call(this, promptsNodeStyle, 0);
                }
            },

            onclick: function onclick() {
                
                if (this.maskNode) {
                    
                    mstrApp.goBack();
                }
            },

            ontouchend: function ontouchend() {
                this.onclick();
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.maps.jsmap.AndroidMap");

    
    mstrmojo.maps.jsmap.AndroidRptMap = mstrmojo.declare(
        
        mstrmojo.maps.jsmap.AndroidMap,

        
        null,

        {
            scriptClass: 'mstrmojo.maps.jsmap.AndroidRptMap',

            setModel: function setModel(model) {
                this._super(model);

                
                this.controller.getPageByTree(false);
            }
        }
    );
}());


(function () {
    mstrmojo.requiresCls("mstrmojo.maps.jsmap.AndroidMap",
                         "mstrmojo.maps.jsmap.AndroidDocMapInfoWindow",
                         "mstrmojo.Overlay",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.dom");

    var $DOM = mstrmojo.dom;

    
    mstrmojo.maps.jsmap.AndroidDocMap = mstrmojo.declare(
        mstrmojo.maps.jsmap.AndroidMap,

        [ mstrmojo._Formattable ],

        {
            scriptClass: "mstrmojo.maps.jsmap.AndroidDocMap",

            cssClass: "mstr-googleMapView",

            formatHandlers: {
                domNode: ['left', 'top', 'z-index', 'height', 'width', 'border', 'border-color', 'border-style', 'border-width' ]
            },

            sc: null,

            getMapModel: function getMapModel() {
                var d = this.doc,
                    m = d.model,
                    pid = mstrApp.getCurrentProjectId(),
                    sessions = mstrApp.serverProxy.getSessions();

                return {
                    pid: pid,
                    sessions: sessions,
                    model: this.model,
                    docData: {
                        did: d.did,
                        ttl: d.ttl,
                        st: d.st,
                        mid: m.mid,
                        bs: m.bs,
                        data: m.data,
                        defn: m.defn
                    },
                    cfg: mstrApp.getConfiguration().getConfiguration()
                };
            },

            
            postBuildRendering: function postBuildRendering() {
                
                this._touchListener = mstrmojo.touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                    
                    var openInfoWindow = this.openedInfoWindow;
                    if (openInfoWindow) {
                        
                        if (!$DOM.contains(this.domNode, evt.touch.target, true, document.body) && !mstrApp.isDialogUp()) {
                            
                            openInfoWindow.close();
                        }
                    }
                });

                return this._super();
            },

            destroy: function destroy(ignoreDom) {
                
                var listener = this._touchListener;
                if (listener) {
                    
                    mstrmojo.touchManager.detachEventListener(listener);
                    delete this._touchListener;
                }

                this._super(ignoreDom);
            },

            setModel: function setModel(d) {
                
                this.doc = d.controller.view;
                this._super(d);
            },

            initFromVisProps: function initFromVisProps(vp) {
                this._super(vp);

                if (!vp) {
                    return;
                }

                this.iwDocLayout = (parseInt(vp.dl, 10) === 1);

                
                if (vp.lyt) {
                    this.iwLayoutKey = vp.lyt;
                }
            },

            
            findSelectorTarget: function findSelectorTarget(sc) {
                if (sc && sc.tks) {
                    var dm = this.model.docModel,
                        targets = sc.tks.split('\u001E'),
                        i = 0,
                        len = targets.length;

                    for (i = 0; i < len; ++i) {
                        var d = dm.getTargetDefn(targets[i]);
                        if (d[targets[i]].ifw) {
                            return targets[i];
                        }
                    }
                }
            },

            showInfoWindow: function showInfoWindow(mp, mkr, w) {
                this.openedInfoWindow = w;
                w.open(mp, mkr);
            },

            
            getInfoWindow: function getInfoWindow(map, marker) {
                var gd = this.gridData;

                
                if (this.iwDocLayout) {

                    
                    this.getInfoWindowFromLayout(gd, map, marker, this.showInfoWindow);

                } else {

                    var sc = this.getInfoWindowSelectorControl(gd),
                        firstInfoWinKey = this.findSelectorTarget(sc);

                    
                    if (!(!!sc && firstInfoWinKey)) {
                        
                        return this.getDefaultInfoWindow(gd, marker);
                    }

                    
                }
            },

            getInfoWindowFromLayout: function getInfoWindowFromLayout(d, map, marker, callback) {
                
                var ths = this,
                    doc = this.doc,
                    layouts = doc.getLayouts(),
                    lyt = this.iwLayoutKey,
                    layout = layouts[mstrmojo.array.find(layouts, 'k', lyt)],
                    sep = "\x1F",
                    dssXmlTypeAttribute = "12",
                    
                    
                    gbIDs = marker.attrid + sep + dssXmlTypeAttribute + sep + marker.eid;

                var taskParams = {
                    layoutKey: lyt,
                    groupByIDs: gbIDs
                };

                doc.selectLayout(layout, (lyt !== doc.model.currlaykey), {
                    complete: function () {

                        layout.defn.loaded = false;

                        doc.getNewLayout(taskParams, layouts, false, {
                            complete: function () {
                                mstrApp.hideMessage();
                            },
                            submisson: function () {
                                mstrApp.showMessage();
                            },
                            success: function (res) {
                                var node = res.node, overlay,
                                    content = document.createElement('div'),
                                    contentStyle = content.style,
                                    w = node.defn.fmts.width,
                                    h = node.defn.fmts.height || node.data.mh; 

                                overlay = new mstrmojo.Overlay({
                                    children: [res]
                                });
                                
                                overlay.set('width', w);
                                overlay.set('height', h);

                                
                                var cn = document.createElement('div');
                                overlay.placeholder = cn;
                                overlay.render();

                                contentStyle.overflow = "hidden";
                                content.appendChild(overlay.domNode);

                                var win = new google.maps.InfoWindow({
                                    content: content
                                });

                                
                                ths.openedInfoWindow = win;
                                win.open(map, marker);

                                var INTERVAL = 300,
                                    t = 0,
                                    ti = window.setInterval(function () {
                                        var n = content.parentNode;
                                        if (n) {
                                            var ow = n.offsetWidth,
                                                oh = n.offsetHeight;
                                            if (ow !== parseInt(w, 10) || oh !== parseInt(h, 10)) {
                                                overlay.setDimensions(oh + 'px', ow + 'px');
                                                window.clearTimeout(ti);
                                            }
                                        }
                                        t += INTERVAL;
                                        
                                        
                                        if (t > 10 * INTERVAL) {
                                            window.clearTimeout(ti);
                                        }
                                    }, INTERVAL); 
                            }
                        }, true);
                    }
                });
            },

            getInfoWindowSelectorControl: function getInfoWindowSelectorControl(d) {
                if (!this.sc) {
                    
                    this.sc = d.gts.row[0].sc;
                }
                return this.sc;
            },

            
            postHandleMarkerClick: function postHandleMarkerClick(map, marker) {

                var d = this.gridData,
                    sc = this.getInfoWindowSelectorControl(d);

                if (sc && sc.tks) {
                    var ths = this,
                        dataCacheUpdate = null,
                        dm = ths.model.docModel;

                    dm.getDataService().setDocSelectorElements(sc.ck, marker.eid, sc.ckey, sc.include, {
                        success: function (res) {

                            
                            var tgtDefs = dm.getTargetDefn(sc.tks);

                            
                            if (res.pukeys) {
                                tgtDefs = dm.getTargetDefn(res.pukeys);
                            }

                            
                            
                            
                            dataCacheUpdate = dm.updateDataCache(res.data, tgtDefs);

                            var firstInfoWinKey = ths.findSelectorTarget(sc);

                            
                            if (firstInfoWinKey) {
                                
                                

                                var targetDef = dm.getTargetDefn(firstInfoWinKey),
                                    psId = "*l" + res.currlaykey + "*k" + firstInfoWinKey + "*x1*t" + dm.buildTime,
                                    id = psId + "_ifw",
                                    widget = mstrmojo.all[id];

                                
                                if (widget) {
                                    widget.destroy();
                                }

                                
                                
                                var ifw = new mstrmojo.maps.jsmap.AndroidDocMapInfoWindow({
                                    id: id,
                                    parent: ths,
                                    builder: ths.builder,
                                    model: dm,
                                    psKey: firstInfoWinKey,
                                    psId: psId
                                });

                                
                                var fmts = targetDef[firstInfoWinKey].fmts,
                                    content = document.createElement('div'),
                                    contentStyle = content.style,
                                    w = fmts.width,
                                    h = fmts.height;

                                
                                ifw.set('width', w);
                                ifw.set('height', h);

                                
                                var cn = document.createElement('div');
                                ifw.placeholder = cn;
                                ifw.render();

                                contentStyle.height = h;
                                contentStyle.width = w;
                                contentStyle.overflow = "hidden";
                                content.appendChild(ifw.domNode);

                                
                                var iw = new google.maps.InfoWindow({
                                    content: content
                                    
                                    
                                });

                                
                                var fnClose = iw.close;
                                iw.close = function () {
                                    
                                    fnClose.call(iw);

                                    
                                    ifw.destroy();

                                    
                                    delete ths.openedInfoWindow;
                                };

                                
                                

                                ths.openedInfoWindow = iw;
                                iw.open(map, marker);

                                var INTERVAL = 300,
                                    t = 0,
                                    ti = window.setInterval(function () {
                                        var n = content.parentNode;
                                        if (n) {
                                            var ow = n.offsetWidth,
                                                oh = n.offsetHeight;
                                            if (ow !== parseInt(w, 10) || oh !== parseInt(h, 10)) {
                                                ifw.setDimensions(oh + 'px', ow + 'px');
                                                window.clearTimeout(ti);
                                            }
                                        }
                                        t += INTERVAL;
                                        
                                        
                                        if (t > 10 * INTERVAL) {
                                            window.clearTimeout(ti);
                                        }
                                    }, INTERVAL); 






                            }

                            
                            
                            var ue = {
                                name: 'partialUpdate',
                                tree: res.data,   
                                ids: dataCacheUpdate
                            };

                            
                            if (!mstrmojo.hash.isEmpty(ue.ids.ifws)) {
                                
                                delete ue.ids.ifws[firstInfoWinKey];
                            }

                            
                            dm.raiseEvent(ue);
                        }
                    }, dm.zf, true);
                }
            }
        }
    );
}());
(function() {

	mstrmojo.requiresCls("mstrmojo.VisChart");

	var DEFAULT_DARK_THEME = 1;
	var DEFAULT_LIGHT_THEME = 2;
	var CUSTOM_DARK_THEME = 3;
	var CUSTOM_LIGHT_THEME = 4;


	mstrmojo.VisMicroChartBar = mstrmojo.declare(

			mstrmojo.VisChart,

			null,

			{

				scriptClass: 'mstrmojo.VisMicroChartBar',


				isDrawAxis: false,


				margin:{t:0, r:1, b:0, l:1},


				showHighlightLine: false,


				themeColor: '#FFFFFF',


				noBackground: true, 


				isAnimateLines: false,


				toolTipMain: null,

				labelLen: 0,

				mainWidth: 0,


				mainLeftPos: 0,

				markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};top:{@top};left:{@left};position:relative;" ' +
				' mstrAttach:mousedown,mouseup,mousemove,click ' +
				'><canvas width="{@width}" height="{@height}"></canvas>' +
				'<canvas style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>' +
				'<canvas style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>' +
				'<div style="position:absolute;left:0px;top:0px;padding-left:1px;padding-top:1px;text-align:left;-webkit-text-size-adjust: none"></div>' +
				'<div style="position:absolute;left:0px;bottom:0px;padding-left:1px;padding-bottom:1px;text-align:left;-webkit-text-size-adjust: none"></div>' +
				'</div>',

				
				markupSlots: {
					
					canvas: function(){ return this.domNode.firstChild; },
					animationCanvas: function(){ return this.domNode.childNodes[1]; },
					highlightCanvas: function(){ return this.domNode.childNodes[2]; },
					minLabel: function(){ return this.domNode.childNodes[3];},
					maxLabel: function(){ return this.domNode.childNodes[4];}
				},

				postBuildRendering: function postBR() {
					if (this._super) {
						this._super();
					}
					
					this.windowSize = this.model.series[0].rv.length;
	                if (this.windowSize === 1) {
	                	this.plot();
	                }

				},


                
                 getTouchValue: function gtvlindx(touchX) {
                    var series = this.model.series[0];
                    var ind = 0;
                    for (var i = 0; i < series.v.length; i++) { 
                        if (touchX < this.hightLightPos[i].x) {
                            if (i === 0) {
                                ind = i;
                            } else {
                                ind = (this.hightLightPos[i].x + this.hightLightPos[i - 1].x)/2 > touchX? (i - 1): i;
                            }
                            break;
                        }
                    }
                    if (i !== series.v.length) {
                    } else {
                        ind = i - 1;
                    }
                    return ind;
				},


                
                isTouchPointInGraphRange: function tpInGR(touchX, touchY){
                    if (touchX <= this.labelLen + 1 || touchX >= this.getWidth() - 1 ) {
                        return false;
                    }
                    return true;
                },

                
				showTooltip: function rndrttp(pageX, pageY) {
					if(!this.config.mbShowTooltip || this.noDataToShowTtp) {
						return false;
					}

                    var m = this.model,
                        series = m.series[0];

                    if(series.rv.length <= 1){
                        return false;
                    }

					var pos = mstrmojo.dom.position(this.domNode, true);
					var touchX = pageX - pos.x;
					var touchY = pageY - pos.y;

                    if(!this.isTouchPointInGraphRange(touchX, touchY)){
                        return false;
                    }


                    var touchVal = this.getTouchValue(touchX, touchY);



                    var x =  this.hightLightPos[touchVal].x;
                    
                    if(this.widget.enableSmoothScroll){
                        if(this.domNode.offsetLeft + x < this.widget._scroller.origin.x){
                            return false;
                        }
                    }

                    this.prevHighlight = this.currentHighlight;
                    this.currentHighlight = touchVal;

                    
                    
                    if(!this.widget.tooltipShow || this.prevHighlight != this.currentHighlight){

                        touchX = Math.round(this.hightLightPos[touchVal].x);
                        touchY = Math.round(this.hightLightPos[touchVal].y);

                        var vl = series.rv[touchVal] * 1.0;
                        var tColor = this.posBarColor;
                        if(vl < 0) {
                            tColor = this.negBarColor;
                        }
                        if(series.thClr && series.thClr[touchVal]){
                            
                            tColor = series.thClr[touchVal];
                        }

                        this.renderTooltip(touchVal, x, touchY, tColor);
                        this.highlightPoint(touchX, touchY, tColor);
                    }
                    return true;
                },

                renderTooltip: function rndrttp(valIndex, touchX, touchY, tColor) {
                    var model = this.model;
                    var barProps = this.config;
                    var series = model.series[0],
                        categories = model.categories.items,
                        width = this.getWidth();
                    var metrics = model.mtrcs;
                    metrics = metrics.items;
                    var ttp = this.toolTipMain;

					var line1 = model.categories.tn + ": " + categories[valIndex];
					if(isNaN(this.kpiOffset)) {
						this.kpiOffset = 0;
					}

					if(this.widget.sparklineProps.mstrAssMetric)
						line2 = this.widget.sparklineProps.mstrAssMetric + ": " + series.v[valIndex];
					else
						line2 = metrics[this.kpiOffset] + ": " + series.v[valIndex];

					var maxLength = this.widget.getTextWidthByCanvas(line1, ttp);
					var leng2 = this.widget.getTextWidthByCanvas(line2, ttp);
					if(leng2 > maxLength) {
						maxLength = leng2;
					}
					var domHtml =  line1 + '<br/>' + line2;

					if(this.refv && this.refv.length > 1 && this.config.mbRefLine) {
						domHtml += "<br/>";

						var line3 = metrics[this.kpiOffset + 1] + ": " + this.refv[1].v;
						var leng3 = this.widget.getTextWidthByCanvas(line3, ttp);
						if(leng3 > maxLength) {
							maxLength = leng3;
						}
						domHtml += line3;
					}
					ttp.innerHTML = '<div style="margin-left:5px;margin-bottom:4px;margin-top:5px;">' + domHtml + "</div>";

					

                    var pos = mstrmojo.dom.position(this.domNode, true);
					var posWdt = mstrmojo.dom.position(this.widget.domNode, true);
					var oft =  {
							left: pos.x - posWdt.x,
							top: pos.y - posWdt.y
					};

					var maxWidth = maxLength + 10;
					ttp.style.display = 'block';
					ttp.style.borderColor = tColor;
					ttp.style.width = maxWidth + "px";

					var topOff = (touchY + pos.y - posWdt.y - ttp.offsetHeight - 29);
					if(topOff < 0) {
						topOff = 0;
					}
					var leftOff = (oft.left + touchX + maxWidth + 20);
					if(leftOff > this.widget.getWidth()) {
						leftOff = (touchX + oft.left  - maxWidth - 20);
						if(leftOff < 0) {
							leftOff = 0;
						}
					} else {
						leftOff -= maxWidth;
					}
					ttp.style.display = 'none';
					ttp.style.top = (topOff) + "px";
					ttp.style.left = (leftOff) + "px";
					ttp.style.display = 'block';

				},

				highlightPoint: function highlightPoint(touchX, touchY, tColor){







                    var ctx = this.highlightContext,
                        width = this.getWidth(),
                        height = this.getHeight(),
                        utils = this.utils;


                    ctx.clearRect(0, 0, width, height);
                    ctx.globalAlpha = 1;

                    touchX = touchX > 5 ? touchX : 5;
                    if(touchX > width - 5) {
                        touchX = width - 5;
                    }
                    touchY = touchY > 5 ? touchY : 5;
                    if(touchY > height - 5) {
                        touchY = height - 5;
                    }
                    ctx.globalAlpha = 0.8;
                    ctx.strokeStyle = "FFFFFF";
                    ctx.fillStyle = ctx.strokeStyle;
                    utils.drawArc(this, touchX, touchY, 5, 0, Math.PI * 2, true, true, ctx);

                    ctx.strokeStyle = tColor;
                    ctx.fillStyle = ctx.strokeStyle;

                    ctx.globalAlpha = 1.0;
                    utils.drawArc(this, touchX, touchY, 5, 0, Math.PI * 2, true, false, ctx);
                    utils.drawArc(this, touchX, touchY, 2.5, 0, Math.PI * 2, true, true, ctx);
                    this.highlightCanvas.id = "highLightCav" + this.widget.domNode.id;
				},

				textLen: function txtLn(str) {
					
					var len = 0;
				    for (var i = 0; i < str.length; i++) {
				        if (str.charCodeAt(i) > 255 || str.charCodeAt(i<0)) len += 2; else len ++;
				    }
				    return len;
				},

				handleTouchMove: function () {
					
				},

				reDrawChart: function reDrwchart(){
					var context = this.context,
						canvas = this.canvas,
						wd = canvas.width,
						ht = canvas.height;
					context.clearRect(0,0, wd, ht);
					this.data.processLinearData(this);
					 
	                this.windowSize = this.model.series[0].rv.length;
	              
					this.utils.fillBackground(this);

					if(this.windowSize < 1) {
						return; 
					}
					this.drawChart();
				},

				setColorByTheme: function setColorByTheme(){
					var barProps = this.config;
					if(this.theme == DEFAULT_DARK_THEME || this.theme == DEFAULT_LIGHT_THEME){
						this.posBarColor = "#598200";
						this.negBarColor = "#CC3A06";

						this.xAxisLineWidth = 1;
						this.xAxisLineColor = "#7F7F7F";
						this.refLineWidth = 1;
						this.refLineColor = "#00A6EF";
					}else{
						this.posBarColor = barProps.mwPosCol;
						this.negBarColor = barProps.mwNegCol;

						this.xAxisLineWidth = 1;
						this.xAxisLineColor = "#000000";
						this.refLineWidth = 1;
						this.refLineColor = barProps.mwRefLineCol;
					}
				},

				drawChart: function drwchrt() {

					var model = this.model;
					var barProps = this.config;
					if(model.err) {
						this.noDataToShowTtp = true;
						return;
					}

					this.setColorByTheme();

					var context = this.context,
					values = model.series,
					height = this.getHeight(),
					width = this.getWidth(),
					me = this,
					utils = this.utils;
					var barOffset = 0;
					var barPadLeft = this.margin.l;
					var barPadRight = this.margin.r;

					var min = 0,
						max = 0,
						minLabel = maxLabel = "",
						series = model.series[0];

					for (var i = 0; i < series.v.length; i ++) {
						var vl = parseFloat(series.rv[i]);
						if (i === 0) {
							max = min = vl;
							minLabel = maxLabel = series.v[i];
						} else if(vl > max) {
							max = vl;
							maxLabel = series.v[i];
						} else if(vl < min) {
							min = vl;
							minLabel = series.v[i];
						}
					}

					if(isNaN(min) && isNaN(max)){
						
						this.minLabel.innerHTML = "";
						this.maxLabel.innerHTML = "";
						this.noDataToShowTtp = true;
						return;
					}

					this.noDataToShowTtp = false;

					if (barProps.mbShowLegend) { 
						var fontSize = Math.ceil(Math.min(12, (height / 2) * 0.7));  
						var mintxt = "Min:" + minLabel.replace(/[ ]/g, "");
						var maxtxt = "Max:" + maxLabel.replace(/[ ]/g, "");

						this.minLabel.innerHTML = mintxt;
						this.maxLabel.innerHTML = maxtxt;

						
						var maxBarOffset = width - 10;
						if(maxBarOffset > width * 0.5){
							maxBarOffset = Math.floor(width*0.5);
						}
						do {
							this.minLabel.style.fontSize = fontSize + "px";
							this.maxLabel.style.fontSize = fontSize + "px";
							var fontFamily = "Arial";
							var minTxtLen = this.widget.getTextWidth(mintxt, "", fontFamily, fontSize, "px", this.isTextBold);
							var maxTxtLen = this.widget.getTextWidth(maxtxt, "", fontFamily, fontSize, "px", this.isTextBold);
							var txtLen = minTxtLen > maxTxtLen? minTxtLen: maxTxtLen; 
							barOffset = txtLen + barPadLeft;
							fontSize -= 1;
						} while ( barOffset > maxBarOffset && fontSize > 5); 
						fontSize += 1;
					} else {
						barOffset = barPadLeft;
					}

					this.labelLen = barOffset;

					
					if(this.refv && this.refv.length > 1 && barProps.mbRefLine) {
						var refValue = this.refv[1].rv * 1.0;
						if(refValue < min) {
							min = refValue;
						}
						if(refValue > max) {
							max = refValue;
						}
					}
					
					var ts = max - min;
					var baseY = 0;
					var barPadTop = 5;
					var barPadBottom = 5;
					var rangeRatio = height - barPadTop - barPadBottom; 
					if (ts == 0) { 
						if (min == 0) {
							baseY = height / 2;
							rangeRatio = 0;
						} else {
							rangeRatio /= Math.abs(max);
							if (max < 0) {
								baseY = barPadTop;
							} else {
								baseY = height - barPadBottom;
							}
						}
					} else if(max < 0) {
						baseY = barPadTop;
						rangeRatio /= Math.abs(min);
					} else if (min < 0) {
						baseY = max / ts * rangeRatio + barPadTop;
						rangeRatio /= ts;
					} else { 
						baseY = height - barPadBottom;
						rangeRatio /= max;
					}


					
					
					var barTotalWidth = width - barOffset - barPadRight;
					var barCount = series.v.length;
					var barSpaceWidth = barTotalWidth * 0.4 / barCount; 
					barSpaceWidth = barSpaceWidth >= 1? barSpaceWidth: 1; 
					var barWidth = barTotalWidth / barCount - barSpaceWidth;
					this.hightLightPos = [];
					for(var i = 0; i < barCount; i ++) {
						this.hightLightPos[i] = {};
						var vl = series.rv[i] * 1.0;
						var direct = true;
						if(vl < 0) {
							vl = 0 - vl;
							direct = false;
						}
						
						var hgt = vl * rangeRatio;
						
						var cw = (width - barOffset) / series.v.length;
						this.drawBar(barOffset + (barWidth + barSpaceWidth) * i + barSpaceWidth / 2, baseY, barWidth, hgt, context, series.thClr && series.thClr[i],direct, this.hightLightPos[i]);
					}

					
					context.strokeStyle = this.xAxisLineColor;
					context.lineWidth = this.xAxisLineWidth;
					if (context.lineWidth % 2 === 1) {
						baseY = Math.round(baseY + 0.5) - 0.5; 
					}

					context.beginPath();
					context.moveTo(barOffset, baseY);
					context.lineTo(width - barPadRight, baseY);
					context.stroke();

					
					if(this.refv && this.refv.length > 1 && barProps.mbRefLine) {
						var refValue = this.refv[1].rv * 1.0;
						var refH = baseY - refValue * rangeRatio;
						
						
						if (context.lineWidth % 2 === 1) {
							refH = Math.round(refH + 0.5) - 0.5; 
						}
						context.beginPath();
						context.moveTo(barOffset, refH);
						context.lineTo(width - barPadRight, refH);
						context.strokeStyle = this.refLineColor;
						context.stroke();
					}
				},

				drawBar: function drwBr(x, y, width, height, context, color, direct, posStore) {
					

					
					if (width >= 3) { 
						x = Math.round(x);
						y = Math.round(y);
						width = Math.round(width);
					}
					if (height != 0) {
						height = Math.round(height);
						if (height < 1) { 
							height = 1;
						}
					}

				    if(direct) {
				    	context.fillStyle = color ? color : this.posBarColor;
				    	context.fillRect(x,y - height,width,height);
				    	posStore.x = x + Math.round(width / 2.0);
				    	posStore.y = y - height;
				    } else {
				    	context.fillStyle = color ? color : this.negBarColor;
				    	context.fillRect(x,y,width,height);
				    	posStore.x = x + Math.round(width / 2.0);
				    	posStore.y = y + height;
				    }
				}
			}
	);

})();
(function() {

	mstrmojo.requiresCls(
						"mstrmojo.VisChart",
						"mstrmojo.locales"
						);

	
	
	
	var ROTATE_X_ADJUST = 20;
	var ROTATE_Y_ADJUST = -20;

	
	var PLAIN_Y_ADJUST = 25;

	var $H = mstrmojo.hash;
	
	var prevDate = null; 

	
	mstrmojo.VisChartLine = mstrmojo.declare(
			
			mstrmojo.VisChart,

			
			null,

			
			{
				 
				scriptClass: 'mstrmojo.VisChartLine',

				
				fillinColor: null,

				
				rotateXLabels: false,

				
				isFillLinesArea: null,

				
				isAnimateLines: true,

				
				isDrawStartEndPoints: 0,

				
				startEndPointRadius: 5,

				
				startPointColor: null,

				
				endPointColor: null,

				
				prevLines: null,

				
				chartLineColors: ['#0099FF', '#FFB03C', '#F26AE1', '#888BF4', '#93CA20', '#FE2F68'],

				
				maxXLabels: 6,
				
				
				DSS_XML_BASE_FORM_DATE : "8",
				
				            
				drawChart: function drwchrt() {
					
					var model = this.model;
					if(model.err) {
						return;
					}

					
					var context = this.animationContext,
					mvalues = model.mvalues,
					values = model.series,
					margin = this.margin,lines = [],linesFrom = [],
					height = this.getHeight(),
					width = this.getWidth(),
					me = this,
					utils = this.utils;

					if (!values) return; 

					var vl = values.length;

					if(this.isDrawAxis && this.drawYAxisLabels) {
						margin.l = utils.getLabelWidthForMargin(this,model.mls);
					}

					
					me.RTY = (height - margin.t - margin.b - 5) / (mvalues[mvalues.length - 1] - mvalues[0]);
					me.RTX = (width - margin.l - margin.r - 1) / (me.windowSize - 1);

					var mn = (mvalues[0] + mvalues[mvalues.length - 1]) / 2;
					var mnY = utils.getYValue(me, mn); 
					
					for(var j = 0; j < vl; j++) {
						lines = [];
						var k = 0;
						for (var i = 0; i < me.windowSize; i++) {
							var val = values[j].rv[i];
							if(val.length === 0) continue;

							lines[k] = {x:(i * me.RTX) + margin.l, y:utils.getYValue(me, val)};

							if (!this.prevLines) {
								
								linesFrom[k] = {x:lines[k].x, y:mnY};
							}
							k++;
						}

						this.drawChartLine(lines, linesFrom, vl, j, context);

						if(!this.multiLine) break; 
					}

					this.prevLines = lines;

			},

			drawChartLine: function drwcl(lines, linesFrom, vl, si, context, lw) {

				var me = this, 
					height = me.getHeight(),
					utils = me.utils;

				
				var cfg = {
						rate: 6
				};

				context.strokeStyle = utils.getColor(me);
				context.lineCap = 'round';
				context.lineWidth = lw || 2;
				context.lineJoin = 'round';

				if(me.isAnimateLines && (!me.multiLine || vl === 1 )) {
					if (me.prevLines) {
						linesFrom = me.prevLines;
						
						if (linesFrom.length < lines.length) {
							for (var i = linesFrom.length; i < lines.length; i++) {
								linesFrom.push(lines[linesFrom.length-1]);
							}
						}
					}

					
					utils.animateLineSet(me, me.prevLines || linesFrom, lines, cfg);
				} else {

					if(me.multiLine && vl > 1) {
						context.strokeStyle = me.chartLineColors[si % 6];
					}

					
					utils.drawLineSet(me, lines, false, context);

					if(me.isFillLinesArea) {
						utils.fillLinesArea(me,lines.slice(0));
					}

					if(me.isDrawStartEndPoints ) {
						utils.drawStartEndPoints(me, lines, context, me.isDrawStartEndPoints);
					}
				}

			},

			
			setMicroChartProperties: function setMicroChartProperties() {
				this.isDrawAxis = false;
				this.margin = {t:0, r:5, b:0, l:5};
				this.showHighlightLine = false;
				this.isDrawStartEndPoints = 3;
			},
			
			initFromVisProps: function initFromVisProps(vp) {
				if(!vp) return;
				
				if(vp.thc) {
					this.themeColor = "#" + vp.thc;
				}
				
				if(vp.shl === "0") {
					this.showHighlightLine = false;
				}
				
				if(vp.mc === "1") {
					this.setMicroChartProperties();
				}
			},
			
			 
			postCreate: function pstCrt() {
				if (this._super) {
					this._super();
				}

				if (this.rotateXLabels) {
					this.margin.b = 75;
				}

				
				if(typeof(this.isFillLinesArea) === 'undefined' && !this.multiLine) {
					this.isFillLinesArea = true;
				}
			},
			
			
			drawLabels: function drwlbls(needNotDrawVerticalGridLine) {					
				
				if (!this.isDrawAxis) return;            	

				if (this._super) {
					
					this._super();
				}

				if(!this.drawXAxisLabels) return;
				
				
				var me = this,
					cat = me.model.categories,
					labels = cat.items,
					tp = cat.tp,
					utils = me.utils,
					mg = me.margin,
					l = labels.length,
					li = null,
					x = null,
					y = 0,
					lbl = null,
					ts = me.isTimeSeries,
					ctx = me.animationContext,
					dgl = me.drawGridLines;

				
				var pxl = me.prevXLabel;
				pxl.x = 0;
				pxl.y = 0;
				pxl.w = 0;

				ctx.save();
				
				ctx.globalAlpha = 1;
				ctx.strokeStyle = utils.rgb2rgbStr(me.formatProp.textClr, 0.35);
				ctx.lineWidth = 1;
				ctx.lineCap = 'round';

				
				var totalLabels = l > me.maxXLabels ? me.maxXLabels : l;
				
				var xlblDiv = null;
				
				
				if(ts) {
					xlblDiv = document.createElement("div");
					me.xdiv = xlblDiv;

					
					totalLabels *= (me.totalChartWidth/(me.chartWidth));
				} 

				
				if(me.rotateXLabels) {
					y = me.canvas.height + ROTATE_Y_ADJUST;
				} else {
					if(ts){
						
						y =  me.canvas.height - this.margin.b + 5;
					}else{
						y =  me.canvas.height - PLAIN_Y_ADJUST;
					}

				}
				
				var labInterval = Math.round(l / totalLabels);
				
				if(labInterval === 0) {
					labInterval = 1;
				}
				
				var lw = Math.round(labInterval * me.RTX) - me.xLabelPadding;
					
				prevDate = null;
				var curPrevDate = {mn:0,dt:0,yr:0};
				if(ts){
					
					var labelDisplayStatus = -1;
					this.needRedrawVerticalLine = false;
					for(var i = me.ACrns; i < me.ACrne; i+=labInterval) {
						x = ((i - me.ACrns) * me.RTX);
						var dtlbl = labels[i];
						if(labelDisplayStatus < 0 && i >= me.model.rns){
							
							labelDisplayStatus = 0;
						}
						if(ts && (tp.toString() === me.DSS_XML_BASE_FORM_DATE)) {
							
							if(labelDisplayStatus == 0){
								prevDate = null;
								labelDisplayStatus = 1;
							}
							dtlbl = me.getFormattedDateLabel(dtlbl, curPrevDate);
							
						}
						
						if (me.rotatXLabels) {
							lbl = utils.addLabel(me, dtlbl, x - ROTATE_X_ADJUST, y, null, true, pxl);
						} else {
							lbl = utils.addLabel(me, dtlbl, x , y, null, false, pxl);
						}
						
						if(lbl) {
							if(dgl & me.drawVerticalGridLines) {
								prevDate = $H.clone(curPrevDate);
								if(!needNotDrawVerticalGridLine){
									var xPos = Math.floor(x) + 0.5;
									utils.drawLineSet(me,[{x:xPos,y:me.canvas.height - mg.b},{x:xPos, y:mg.t}], false, ctx);
								}
							}
						}

					}
					
				}else{
				
					for(var i = 0; i < l; i+=labInterval) {
						x = (i * me.RTX) + mg.l;
						var dtlbl = labels[i];
						if(ts && (tp.toString() === me.DSS_XML_BASE_FORM_DATE)) {
							dtlbl = me.getFormattedDateLabel(dtlbl, curPrevDate);
						}
						
						if (me.rotateXLabels) {
							lbl = utils.addLabel(me, dtlbl, x - ROTATE_X_ADJUST, y, null, true, pxl);
						} else {
							lbl = utils.addLabel(me, dtlbl, x, y, lw, false, pxl);
						}
						
						if(lbl) {
							if(dgl & me.drawVerticalGridLines) {
								prevDate = $H.clone(curPrevDate);
								utils.drawLineSet(me,[{x:x,y:me.canvas.height - mg.b},{x:x, y:mg.t}], false, ctx);
							}
						}
					}
				}
				
				
				
				if(xlblDiv) {
					if(this.isTimeSeries){
						
						me.xLabelsDiv.innerHTML = xlblDiv.innerHTML;
						
						me.xdiv = null;
						
					}else{
						var tc = me.animationCanvas;
						me.itemsContainerNode.innerHTML = xlblDiv.innerHTML;
						me.itemsContainerNode.insertBefore(tc, me.itemsContainerNode.firstChild);
						me.xdiv = null;
						
					}
					
				}
				
				ctx.restore();
			},

			
			getFormattedDateLabel: function getFormattedDateLabel( val, cpv) {
				if(isNaN(val)) {
					return val;
				}
				
				var fVal = val;
				try {
					val = this.utils.convertRawValueToMilliseconds(val);
					var dt = new Date(Number(val));
					var mn = cpv.mn = mstrmojo.locales.datetime.MONTHNAME_SHORT[dt.getMonth()];
					var yr = cpv.yr = dt.getFullYear().toString().substring(2);
					cpv.dt = dt.getDate();
					
					if(!prevDate || (mn !== prevDate.mn && yr !== prevDate.yr)) {
						fVal = mn + " " + cpv.dt + " " + yr;
					} else if(mn !== prevDate.mn) {
						fVal = mn + " " + cpv.dt;
					} else {
						fVal = cpv.dt;
					}
				} catch(e) {
				}
				return fVal;
			},

			removeLabels: function rmvlbls() {
				
				var todel = this.domNode.getElementsByClassName('mstrmojo-Chart-lbl');
				for (var i = todel.length - 1; todel && i >= 0; i--) {
					todel[i].parentElement.removeChild(todel[i]);
				}
				
			},

			
			highlightPoint: function hghlghtpnt(x, touchY) {

				
				var me = this,
				ctx = me.highlightContext,
				height = me.getHeight(),
				margin = me.margin,
				model = me.model,
				utils = me.utils,
				si = me.seriesIndex;

				
				var xcoord = (x * me.RTX) + margin.l;
				if (this.prevHighlight >= 0) {
					var prevXCoord = (this.prevHighlight * me.RTX) + margin.l;
					var PADDING = 10;
					var TOP_PADDING = 8;
					var y = margin.t-TOP_PADDING > 0 ?  margin.t-TOP_PADDING : 0; 
					ctx.clearRect(prevXCoord-PADDING, y , prevXCoord + PADDING, height - margin.b);					
				}		

				if (x < 0) return;

				var xcoord = (x * me.RTX) + margin.l;

				ctx.shadowBlur    = 5;
				ctx.shadowColor   = '#000';
				ctx.globalAlpha = 1;

				if(me.showHighlightLine) {
					
					ctx.strokeStyle = this.highlightColor;
					ctx.fillStyle = this.highlightColor;
					ctx.lineWidth = 2;
					ctx.lineCap = "round";				

					
					utils.drawLineSet(me, 
							[ {x:xcoord, y:margin.t},
							  {x:xcoord, y:height - margin.b}
							], false, ctx);
				} else {
					ctx.strokeStyle = utils.getColor(me);
					ctx.fillStyle = ctx.strokeStyle;
				}

				var s = model.series,
				l = s.length,
				y = utils.getYValue(me, s[si].rv[x]);

				
				if(!me.multiLine) {
					utils.drawArc(me, xcoord, y, 5, 0, Math.PI * 2, true, true, ctx);
				} else {
					if(me.showHighlightLine) {
						if(l > 1) {
							ctx.strokeStyle = this.chartLineColors[0];
							ctx.fillStyle = ctx.strokeStyle;
						}
						for(var i = 0; i < l; i++) {
							ctx.strokeStyle = this.chartLineColors[i % 6];
							if(i > 0) {
								ctx.fillStyle = ctx.strokeStyle;
							}
							y = utils.getYValue(me, s[i].rv[x]);
							utils.drawArc(me, xcoord, y, 5, 0, Math.PI * 2, true, true, ctx);
						}
					} else {
						if(l > 1) {
							ctx.strokeStyle = this.chartLineColors[si];
							ctx.fillStyle = ctx.strokeStyle;
						}
						utils.drawArc(me, xcoord, utils.getYValue(me, s[si].rv[x]), 5, 0, Math.PI * 2, true, true, ctx);
					}
				}
			},

			refreshChart: function refreshChart() {
				
				var height = this.getHeight(),
					width = this.getWidth();
				this.highlightContext.clearRect(0, 0, width, height);    
				this.animationContext.clearRect(0, 0, width, height);

				
				this.removeLabels();

				
				this.drawChart();

				
				this.drawLabels();
			}
		}
	);

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.VisChart");

    var DEFAULT_DARK_THEME = 1;
    var DEFAULT_LIGHT_THEME = 2;
    var CUSTOM_DARK_THEME = 3;
    var CUSTOM_LIGHT_THEME = 4;

    mstrmojo.VisMicroChartLine = mstrmojo.declare(

        mstrmojo.VisChart,

        null,

        {

            scriptClass: 'mstrmojo.VisMicroChartLine',

            isDrawAxis: false,

            
            margin: {t: 5, r: 2, b: 1, l: 2},

            showHighlightLine: false,

            themeColor: '#FFFFFF',

            isDrawRefArea: true,

            noBackground: true, 

            isAnimateLines: false,

            toolTipMain: null,

            mainWidth: 0,

            mainLeftPos: 0,

            reDrawChart: function reDrwchart() {
                var context = this.context,
                    canvas = this.canvas,
                    wd = canvas.width,
                    ht = canvas.height;
                context.clearRect(0, 0, wd, ht);

                this.data.processLinearData(this);
                
                this.windowSize = this.model.series[0].rv.length;
                
                this.utils.fillBackground(this);

                if (this.windowSize <= 1) {
                    return; 
                }
                this.drawChart();
            },

            setColorByTheme: function setColorByTheme() {
                var lineProps = this.config;
                if (this.theme === DEFAULT_DARK_THEME || this.theme === DEFAULT_LIGHT_THEME) {
                    this.startPointColor = '#50B5D8';
                    this.endPointColor = '#50B5D8';
                    this.otherPointColor = '#50B5D8';
                    this.isDrawRefArea = false;
                    this.sparkLineColor = "#50B5D8";
                    this.refLineColor = "#FF781D";
                } else {
                    
                    this.startPointColor = '#000000';
                    
                    this.endPointColor = '#FF0000';
                    
                    this.otherPointColor = '#663300';
                    this.isDrawRefArea = lineProps.mbRefArea;
                    this.sparkLineColor = lineProps.mwSeriesLineCol;
                    this.refLineColor = lineProps.mwRefLineCol;
                }
                var dpi = mstrMobileApp.getDeviceDPI();
                this.sparkLineWidth = dpi > 160 ? 2 : 1;
                this.refLineWidth = 1;
                
                this.startEndPointRadius = dpi >= 320 ? 4 : dpi >= 240 ? 3 : 2;
            },

            drawChart: function drwchrt() {
                this.setColorByTheme();
                var lineProps = this.config;
                var context = this.context;
                var model = this.model;
                var values = model.series;
                var mvalues = model.mvalues;
                var margin = this.margin;
                var height = this.getHeight();
                var width = this.getWidth();
                var utils = this.utils;
                var maxVR = mvalues[mvalues.length - 1]; 
                var minVR = mvalues[0]; 
                var maxYValue = mvalues[mvalues.length - 1];
                var minYValue = mvalues[0];

                

                
                if (this.refv && this.refv.length > 1 && lineProps.mbRefLine) {
                    var refValue = parseFloat(this.refv[1].rv);
                    if (isNaN(refValue)) {
                        
                    } else {
                        
                        if (refValue > maxVR) {
                            maxVR = refValue;
                            if (mvalues.length === 1) {
                                mvalues[1] = maxVR;
                            } else {
                                mvalues[mvalues.length - 1] = maxVR;
                            }
                        }
                        if (refValue < minVR) {
                            minVR = refValue;
                            if (mvalues.length === 1) {
                                mvalues[1] = mvalues[0];
                                mvalues[0] = maxVR;
                            } else {
                                mvalues[0] = minVR;
                            }
                        }
                    }

                }
                this.themeColor = lineProps.mwRefAreaCol;
                
                this.isDrawStartEndPoints = lineProps.mbAllPoints ? 7 : (lineProps.mbEndPoints ? 3 : 0);
                if (this.isDrawStartEndPoints & 1 && margin.l < this.startEndPointRadius) {
                    margin.l = this.startEndPointRadius;
                }
                if (this.isDrawStartEndPoints & 2 && margin.r < this.startEndPointRadius) {
                    margin.r = this.startEndPointRadius - 1; 
                }

                if (model.err) {
                    return;
                }

                if (!values) {
                    return;
                }

                
                if (maxVR !== minVR) {
                    this.RTY = (height - margin.t - margin.b - 4) / (maxVR - minVR);
                } else {
                    this.RTY = 0;
                }
                if (this.windowSize !== 1) {
                    this.RTX = (width - margin.l - margin.r - 1) / (this.windowSize - 1);
                } else {
                    this.RTX = 0;
                }
                
                var lines = [];
                var k = 0;
                
                
                for (var i = 0; i < this.windowSize; i++) {
                    var val = values[0].rv[i];
                    if (val.length === 0) {
                        continue;
                    }
                    var x = (i * this.RTX) + margin.l;
                    var y = utils.getYValue(this, val);
                    lines[k] = {x: x, y: y};
                    
                    k++;
                }
                if (lines.length === 0) {
                    
                    return;
                }
                maxYValue = utils.getYValue(this, maxYValue);
                minYValue = utils.getYValue(this, minYValue);
                
                if (maxYValue === undefined || minYValue === undefined) { 
                    maxYValue = height - 4 - margin.b;
                    minYValue = margin.t;
                }
                
                if (this.isDrawRefArea) {
                    context.fillStyle = this.themeColor;
                    context.fillRect(margin.l, minYValue, width - margin.r - margin.l, (maxYValue - minYValue));
                }
                
                context.lineCap = 'round';
                context.lineWidth = this.sparkLineWidth;
                context.lineJoin = 'round';
                context.strokeStyle = this.sparkLineColor;

                utils.drawLineSet(this, lines, false, context);

                
                if (this.isDrawStartEndPoints) {
                    utils.drawStartEndPoints(this, lines, context, this.isDrawStartEndPoints);
                }

                
                if (this.refv && this.refv.length > 1 && lineProps.mbRefLine) {
                    var refValue = this.refv[1].rv * 1.0;
                    var y = this.utils.getYValue(this, refValue);
                    if (isNaN(y)) {
                        y = height - 5;
                    }
                    if (context.lineWidth % 2 === 1) {
                        y = Math.round(y + 0.5) - 0.5; 
                    }
                    context.beginPath();
                    context.moveTo(margin.l, y);
                    context.lineTo(width - margin.r, y);
                    context.lineWidth = this.refLineWidth;
                    context.strokeStyle = this.refLineColor;
                    context.stroke();
                }
            },

            
            highlightPoint: function hghlghtpnt(x, touchY) {

                var me = this,
                    ctx = me.highlightContext,
                    height = me.getHeight(),
                    width = me.getWidth(),
                    margin = me.margin,
                    model = me.model,
                    utils = me.utils;

                ctx.clearRect(0, 0, width, height);

                if (x < 0) {
                    return;
                }

                var xcoord = (x * me.RTX) + margin.l;

                ctx.globalAlpha = 1;

                ctx.strokeStyle = this.sparkLineColor;
                ctx.fillStyle = ctx.strokeStyle;

                var y = utils.getYValue(me, model.series[0].rv[x]);

                if (xcoord < 5) {
                    xcoord = 5;
                }
                if (xcoord > width - 5) {
                    xcoord = width - 5;
                }
                if (y < 5) {
                    y = 5;
                }
                if (y > height - 5) {
                    y = height - 5;
                }
                ctx.strokeStyle = "FFFFFF";
                ctx.fillStyle = ctx.strokeStyle;
                ctx.globalAlpha = 0.8;
                utils.drawArc(this, xcoord, y, 5, 0, Math.PI * 2, true, true, ctx);

                ctx.strokeStyle = this.sparkLineColor;
                ctx.fillStyle = ctx.strokeStyle;
                ctx.globalAlpha = 1.0;
                utils.drawArc(me, xcoord, y, 5, 0, Math.PI * 2, true, false, ctx);
                utils.drawArc(me, xcoord, y, 2.5, 0, Math.PI * 2, true, true, ctx);
                this.highlightCanvas.id = "highLightCav" + this.widget.domNode.id;
            },

            renderTooltip: function rndrttp(valIndex, touchX, touchY) {
                if (valIndex < 0) {
                    this.toolTipMain.style.display = 'none';
                    return;
                }

                var highLightCav = document.getElementById("highLightCav" + this.widget.domNode.id);
                if (highLightCav) {
                    var highlightCt = highLightCav.getContext('2d');
                    highLightCav.id = "";
                    highlightCt.clearRect(0, 0, 1000, 1000);
                }

                var m = this.model,
                    s = m.series,
                    utils = this.utils,
                    l = s.length,
                    si = this.seriesIndex,
                    ch = m.colHeaders,
                    rh = this.baseModel.rowHeaders,
                    ttp = this.toolTipMain;

                var me = this,
                    ctx = me.highlightContext,
                    height = me.getHeight(),
                    width = me.getWidth(),
                    margin = me.margin,
                    utils = me.utils;

                var metrics = m.mtrcs;
                metrics = metrics.items;
                if (isNaN(this.kpiOffset)) {
                    this.kpiOffset = 0;
                }
                var sn = '';

                var line1 = m.categories.tn + ': ' + m.categories.items[valIndex];
                var line2;
                if ( this.widget.sparklineProps.mstrAssMetric) {
                    line2 = this.widget.sparklineProps.mstrAssMetric + ": " + s[0].v[valIndex];
                }
                else {
                    line2 = metrics[this.kpiOffset] + ": " + s[0].v[valIndex];
                }
                var relx = (valIndex * me.RTX) + margin.l;
                var rely = utils.getYValue(me, s[0].rv[valIndex]);

                var leng1 = this.widget.getTextWidthByCanvas(line1, ttp);
                var leng2 = this.widget.getTextWidthByCanvas(line2, ttp);

                var domHtml = line1 + '<br/>' + line2;

                var leng3 = 0;
                if (this.refv && this.refv.length > 1 && this.config.mbRefLine) {
                    domHtml += "<br/>";
                    var line3 = metrics[this.kpiOffset + 1] + ": " + this.refv[1].v;
                    leng3 = this.widget.getTextWidthByCanvas(line3, ttp);
                    domHtml += line3;
                }
                ttp.innerHTML = '<div style="margin-left:5px;margin-bottom:4px;margin-top:5px;">' + domHtml + "</div>";

                var maxLength = Math.max(leng1, leng2, leng3);

                var oft = mstrmojo.boxmodel.offset(this.domNode, this.widget.domNode);
                var pos = mstrmojo.dom.position(this.domNode, true);
                var posWdt = mstrmojo.dom.position(this.widget.domNode, true);
                var maxWidth = maxLength + 10;
                ttp.style.display = 'block';
                ttp.style.borderColor = this.sparkLineColor;
                ttp.style.width = maxWidth + "px";

                var topOff = (rely + pos.y - posWdt.y - ttp.offsetHeight - 29);
                if (topOff < 0) {
                    topOff = 0;
                }
                var leftOff = (oft.left + relx + maxWidth + 20);
                if (leftOff > this.widget.getWidth()) {
                    leftOff = (relx + oft.left - maxWidth - 20);
                    if (leftOff < 0) {
                        leftOff = 0;
                    }
                } else {
                    leftOff -= maxWidth;
                }

                ttp.style.top = topOff + "px";
                ttp.style.left = leftOff + "px";

                var yadjust = this.mainOffsetTop === 0 ? ttp.offsetHeight + 20 : (2 * ttp.offsetHeight) + 30;
                var yPos = utils.getYValue(this, s[si].rv[valIndex]) - yadjust + this.offsetTop;
                if (yPos < 0) {
                    yPos = 0;
                }

                if (this.mainWidth > 0) {
                    var xposr = touchX + ttp.offsetWidth + this.offsetLeft - this.mainLeftPos;
                    if (xposr > this.mainWidth) {
                        touchX -= (xposr - this.mainWidth);
                    }
                }

            },

            
            isTouchPointInGraphRange: function tpInGR(touchX, touchY) {
                var margin = this.margin;
                if (touchX < margin.l || touchY < margin.t || touchY > this.canvas.height - margin.b) {
                    return false;
                }

                return true;
            },

            showTooltip: function handleTouchMove(touchX, touchY) {
                if (!this.config.mbShowTooltip) {
                    return false;
                }
                var me = this,
                    m = me.model;

                if (m.series[0].rv.length <= 1) {
                    return false;
                }

                
                var pos = mstrmojo.dom.position(this.domNode, true);
                touchX = touchX - pos.x;
                touchY = touchY - pos.y;

                if (!this.isTouchPointInGraphRange(touchX, touchY)) {
                    return false;
                }

                var touchVal = me.getTouchValue(touchX, touchY);

                var margin = this.margin;

                if (touchVal !== null) {

                    var x = (touchVal * me.RTX) + margin.l;

                    

                    if (me.widget.enableSmoothScroll) {
                        if (this.domNode.offsetLeft + x < this.widget._scroller.origin.x) {
                            return false;
                        }
                    }

                    var rns = (m.rne - m.rns > 1) ? m.rns : m.rns - 1;

                    if (me.seriesIndex === -1 || me.switchSeriesOnTouch) {
                        me.seriesIndex = me.utils.getSeriesIndexAndYValue(me, rns + touchVal, touchY).si;
                    }

                    if (m.series[me.seriesIndex].rv[rns + touchVal] === "") {
                        return false;
                    }

                    me.prevHighlight = me.currentHighlight;
                    me.currentHighlight = touchVal;

                    
                    
                    if (!me.widget.tooltipShow || me.prevHighlight != me.currentHighlight) {
                        me.renderTooltip(touchVal, x, touchY);
                        me.highlightPoint(touchVal, touchY);
                    }

                    return true;

                }
            }

        }
    );

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.maps.androidmap.AndroidMap");

    
    mstrmojo.maps.androidmap.AndroidRptMap = mstrmojo.declare(
        mstrmojo.maps.androidmap.AndroidMap,

        null,

        
        {
            scriptClass: 'mstrmojo.maps.androidmap.AndroidRptMap',

            setModel: function setModel(model) {
                this._super(model);

                
                this.controller.getPageByTree(false);
            }
        }
    );
}());


(function () {
    mstrmojo.requiresCls("mstrmojo.maps.androidmap.AndroidMap",
                         "mstrmojo.maps.androidmap.AndroidDocMapInfoWindow",
                         "mstrmojo.Image",
                         "mstrmojo.DynamicClassFactory",
                         "mstrmojo.Box",
                         "mstrmojo._HasLayout",
                         "mstrmojo.DocPanel",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.dom");

    var $DOM = mstrmojo.dom;

    var REGULAR_SIZE = 0,
        FULL_SCREEN = 1,
        $H = mstrmojo.hash;
   
    function adjustFormat(fmt) {
    	if (!fmt || !fmt.p_fmts) return fmt;
    	var panel_fmt = fmt.p_fmts;
    	var panel_top = parseInt(panel_fmt.top)||0;
    	var panel_height = parseInt(panel_fmt.height)||0;
    	var height = parseInt(fmt.height)||0;
    	return { top:(panel_top+panel_height-height)+"px",
    		left:panel_fmt.left,
    		width:fmt.width,
    		height:fmt.height,
    		'z-index':panel_fmt['z-index']
    	};
    }
    
    function compareFormats(fmt1, fmt2) {
        if (fmt1 && fmt2) {
        	if (fmt1['z-index']>fmt2['z-index']) return false;
            var x1 = parseInt(fmt1.left),
                y1 = parseInt(fmt1.top),
                w1 = parseInt(fmt1.width),
                h1 = parseInt(fmt1.height),
                x2 = parseInt(fmt2.left),
                y2 = parseInt(fmt2.top),
                w2 = parseInt(fmt2.width)||0,
                h2 = parseInt(fmt2.height)||0;
            return ((((x1 <= x2) && (x2 < x1+w1)) || ((x2 < x1) && (x1 < x2 + w2))) &&
                    (((y1 <= y2) && (y2 < y1+h1)) || ((y2 < y1) && (y1 < y2 + h2))));
        }
        return false;
    }
    
   
      
    
    function registerMapRendering() {
        if( !mstrApp.renderingMap || (mstrApp.renderingMap === this.id) ) {
            mstrApp.renderingMap = this.id;
            return true;
        } else {
            return false;
        }
    }
    
    
    function deregisterMapRendering() {
        if(mstrApp.renderingMap === this.id) {
            delete mstrApp.renderingMap;
            return true;
        }
        return false;
    }
    
    
    mstrmojo.maps.androidmap.AndroidDocMap = mstrmojo.declare(
        mstrmojo.maps.androidmap.AndroidMap,

        [ mstrmojo._Formattable ],

        {
            scriptClass: "mstrmojo.maps.androidmap.AndroidDocMap",

            markupString: '<div id="{@id}" class="mstrmojo-Box {@cssClass}" style="{@domNodeCssText}" mstrAttach:touchstart>' +
            			  '</div>',

            formatHandlers: {
                domNode: ['left', 'top', 'z-index', 'height', 'width', 'border', 'border-color', 'border-style', 'border-width' ]
            },

            sc: null,
            
            domNodeCssText:'position:relative;',
            
            lastSelectedRow: null,
            
            hasTarget: function hasTarget() {
                var sc = this.getInfoWindowSelectorControl(this.gridData);
                return !!(sc && sc.tks);
            },

            
            postBuildRendering: function postBuildRendering() {
                
                this._touchListener = mstrmojo.touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                    
                    var openInfoWindow = this.openedInfoWindow;
                    if (openInfoWindow) {
                        
                        if (!$DOM.contains(this.domNode, evt.touch.target, true, document.body)) {
                            
                            openInfoWindow.close();
                        }
                    }
                });

                return this._super();
            },
            
            destroy: function destroy(ignoreDom) {
                
                var listener = this._touchListener;
                if (listener) {
                    
                    mstrmojo.touchManager.detachEventListener(listener);
                    delete this._touchListener;
                }
                if(this.mapRendered) {
                    this.removeMap();
                }
                this._super(ignoreDom);
            },

            setModel: function setModel(d) {
                
                this.doc = d.controller.view;
                this._super(d);
            },
            
            initFromVisProps: function initFromVisProps(vp) {
                this._super(vp);

                if (!vp) {
                    return;
                }

                this.iwDocLayout = (parseInt(vp.dl, 10) === 1);

                
                if (vp.lyt) {
                    this.iwLayoutKey = vp.lyt;
                }
            },

            
            findSelectorTarget: function findSelectorTarget(sc) {
                if (sc && sc.tks) {
                    var dm = this.xtabModel.docModel,
                        targets = sc.tks.split('\u001E'),
                        i = 0,
                        len = targets.length;

                    for (i = 0; i < len; ++i) {
                        var d = dm.getTargetDefn(targets[i]);
                        if (d[targets[i]].ifw) {
                            return targets[i];
                        }
                    }
                }
                return null;
            },

            findIntersectingComponents: function findIntersectingComponents() {
            	var container = this,
            	    skipNode,
            	    fmt = this.getFormats();
            	while (container.scriptClass != "mstrmojo.DocSubsection" || container.scriptClass != "mstrmojo.DocInfoWindow") {
            		skipNode = container;
            		container = container.parent;            		
            		if(!container) {
            		    break;
            		}
            		var children = container.children,
            		    numChild = (children && children.length) || 0,
            		    comp = null,
            		    idx;
            		for (idx = 0; idx < numChild; idx++) {
            			comp = children[idx];
            			
            			
            			if (comp != skipNode && comp.getFormats && compareFormats(adjustFormat(fmt), adjustFormat(comp.getFormats()))) {
            				return true;
            			}
            		}
            		
            	}
            	return false;
            },
            
            getGridModel: function() {
            	var gridModel = this._super();
            	
            	
            	delete gridModel.layoutModel;
            	delete gridModel.layoutNode;
            	return gridModel;
            },
            
            dispatchMapData: function dispatchMapData() {
                
                if(!registerMapRendering.call(this)) {
                    this.domNode.innerHTML = mstrmojo.desc(9480, 'Only one map visualization is supported at a time');
                    mstrmojo.css.addClass(this.domNode, 'noMapVis');
                    return ;
                }
                
                var doc = this.doc,
                	m = doc.model,
                    viewTree = this.getViewHierarchy(),
                    mapModel = this.getMapModel(),
                    gridModel = this.simplifyGridData(),
                    layouts = (doc.getSupportedLayouts && doc.getSupportedLayouts()) || doc.getLayouts(),
                    fullScreen = !!this.isFullScreenWidget? FULL_SCREEN : REGULAR_SIZE,
                    isActive = false,
                    curLyt = doc.getCurrentLayout(),
                    docData;
                
                    docData = JSON.stringify({
                        did: doc.did,
                        ttl: doc.ttl,
                        st: doc.st,
                        mid: m.mid,
                        ci: m.ci,
                        bs: m.bs,
                        zt: m.zt,
                        defn: m.defn,
                        currlaykey: m.currlaykey
                    });
                    
                    
                
                delete mapModel.model;
                
                
                if (curLyt.setMapID){
                    curLyt.setMapID(this.id);
                }
                
                
                if(!fullScreen) {
                	isActive = this.findIntersectingComponents();
                }
                               
                mstrMobileApp.loadMap(JSON.stringify($H.copy({
                	fullScreen: fullScreen,
                	infoWindow: this.getInfoWindowConfig(),
                	viewTree: viewTree,
                	mapPath: this.mapPath,
                	active: isActive,
                	docModelId: this.xtabModel.docModel.id,
                	hasTarget:this.hasTarget(),
                	zt: m.zt,
                	gdProp: gridModel.prop
                }, mapModel)), gridModel.es, gridModel.data, docData);       
                
                
                this.mapRendered = true;
            },
            
            getViewHierarchy: function () {
                
                var mapPath = [];
                
                
                
                
                
                var p = this.parent, w = [], c = $H.copy(this.fmts, {}), me = this;
                w.push(c);
                while(p) {
                    c = $H.copy(p.fmts, {});
                    c.id = p.id;                    
                    mapPath.push(c.id);
                    
                    if(p.scriptClass === "mstrmojo.MobileDocLayoutViewer") {
                        
                        delete c.width;
                        delete c.height;
                    } else if(p instanceof mstrmojo.DocPanel) {
                        
                        
                        var left = parseInt(p.domNode.style.left, 10); 
                        if(left > 0) {
                            p.parent._scrollOffsetLeft = left;
                        }
                    } else if(p.scriptClass === "mstrmojo.DocSection") {
                        
                        
                        
                        if(p.domNode.offsetTop) {
                            c.top = p.domNode.offsetTop + 'px';
                        }
                    } else if(p.scriptClass === "mstrmojo.DocInfoWindow") {
                        
                        
                        if(p.containerNode) {
                            c.top = p.containerNode.offsetTop + 'px';
                            c.left = p.containerNode.offsetLeft + 'px';
                        }
                        
                        p.onClose = function() {
                            mstrMobileApp.hideMapView(1);
                        };
                    }

                    if(p._scroller) {
                        if(!p._scroller.scrollMoveListener) {
                            var scrollerUpdate = function(e) {
                                mstrMobileApp.scrollerUpdated(JSON.stringify({id: this.id,  x: e.x - (this._scrollOffsetLeft || 0) , y: e.y}));
                            };
                            p._scroller.attachEventListener('scrollMoved', p.id, scrollerUpdate);
                            p._scroller.attachEventListener('scrollDone', p.id, scrollerUpdate);
                            p._scroller.attachEventListener('transformAnim', p.id, scrollerUpdate);
                            p._scroller.scrollMoveListener = true;
                        }
                        c.scroller = true;
                    }
                    w.splice(0, 0, c);
                    p = p.parent;
                }
                
                this.mapPath = mapPath.join('') + ':' + JSON.stringify(w);
                return w;
            },            
            
            getInfoWindowConfig: function useDefaultInfoWindow() {
                
                if(!this.iwConfig) {
                    if(this.iwDocLayout) {
                        this.iwConfig = {dft: false};
                    } else {
                        var d = this.gridData,
                            sc = this.getInfoWindowSelectorControl(d);
                        if(sc) {
                            var dm = this.xtabModel.docModel,
                            tgtDefs = dm.getTargetDefn(sc.tks);

                            if(this.findSelectorTarget(sc)) {
                                this.iwConfig = {dft: false};
                                if(tgtDefs && tgtDefs[sc.tks]) {
                                    var fmt = tgtDefs[sc.tks].fmts;
                                    this.iwConfig.size = {
                                        w: parseInt(fmt.width, 10), 
                                        h: parseInt(fmt.height, 10)
                                    };
                                    return this.iwConfig;
                                }
                            }
                        } 
                        this.iwConfig = {dft: true};
                    }
                } 
                
                return this.iwConfig;
            },
           
            
            resetLayout: function resetLayout() {
                
                if (this.iwDocLayout && this.preIWLayout) {
                    this.doc.selectLayout(this.preIWLayout, true, null, true);
                    this.preIWLayout = null;
                }
            },
            
            closeInfoWindow: function closeInfoWindow() {
                
                do{
                    mstrApp.closeDialog();
                } while(mstrmojo.all.mstrMapInfoWindow);
            },
            
            removeMarkerAnchor: function removeMarkerAnchor() {
                var anchor = mstrmojo.all.mstrMapMarkerAnchor;
                if(anchor) {
                    anchor.destroy();
                }
            },
            beforeViewHidden: function beforeViewHidden(isBackOperation) {
            	
            	this.unrender();
            },
            
            handleMarkerSelection: function handleMarkerSelection(ri, ancherX, ancherY) {
                
                this.removeMarkerAnchor();
                
                
                var anchor = mstrmojo.insert({
                    id: 'mstrMapMarkerAnchor',
                    scriptClass: 'mstrmojo.Box',
                    cssText: 'left:' + ancherX + 'px;top:' + ancherY + 'px;position:absolute;z-index:100',
                    width: '1px',
                    height: '1px'
                });
                anchor.render();
                document.body.appendChild(anchor.domNode);
                this.handleMarkerTargetSelection(ri,anchor);
                this.handleMarkerInfoWindowLayoutSelection(ri,anchor);
            },
                
            handleMarkerInfoWindowLayoutSelection: function handleMarkerInfoWindowLayoutSelection(ri,anchor) {
                
                var d = this.gridData,
                    att = d.gts.row[0],
                    attrid = att.id,
                    r = d.ghs.rhs.items[ri],
                    c = r && r.items[0].idx,
                    ths = this,
                    eid = (c >= 0) ? att.es[c].id : -1;
                
              
                if (this.iwDocLayout) {
                    
                    var doc = this.doc,
                        layouts = doc.getLayouts(),
                        lyt = this.iwLayoutKey,
                        layout = layouts[mstrmojo.array.find(layouts, 'k', lyt)],
                        sep = "\x1F",
                        dssXmlTypeAttribute = "12",
                        gbIDs = attrid + sep + dssXmlTypeAttribute + sep + eid;

                    var taskParams = {
                            layoutKey: lyt,
                            groupByIDs: gbIDs,
                            reload: true
                        };
                    
                        
                        if(!this.preIWLayout) {
                            this.preIWLayout = layouts[mstrmojo.array.find(layouts, 'k', this.defn._lkz)];
                        }

                    (function (params, layouts) {
                        var me = doc,
                            model = me.model,
                            dataService = model.getDataService(),
                            key = params.layoutKey,
                            layout = layouts[mstrmojo.array.find(layouts, 'k', key)];  

                        
                        if (layout.defn && (params.reload || layout.defn.loaded === false)) {
                            
                            
                            dataService.loadDocLayout(params, {
                            success: function (res) {
                                var model = ths.xtabModel.docModel,
                                    key = lyt,
                                    newLayout;
                                
                                
                                res.key = key;
                                res.isSelected = false;
                                
                                
                                model.replaceLayout(key, res);
                                
                                newLayout = doc.rebuildLayout(key, layouts);
                                
                                ths.lastSelectedRow = ri;
                                
                                var node = newLayout.node, 
                                    overlay,
                                    dimensions = mstrApp.getScreenDimensions(),
                                    mw = dimensions.w * 0.85,
                                    mh = dimensions.h * 0.9,
                                    dw = dimensions.w * 0.6, 
                                    dh = dimensions.h * 0.5, 
                                    w = node.defn.fmts.width || (dw + 'px'),
                                    h = node.defn.fmts.height || node.data.mh || (dh + 'px'); 
    
                                ths.closeInfoWindow();
                                
                                overlay = new mstrmojo.Overlay({
                                    cssClass: 'iwOverlay',
                                    children: [newLayout]
                                });

                                
                                overlay.set('width', w);
                                overlay.set('height', h);
                                mstrApp.showPopup({
                                    id: 'mstrMapInfoWindow',
                                    cssClass: 'mapInfoWindow',
                                    scriptClass: 'mstrmojo.android.Popup',
                                    anchorOffset: 1,
                                    onClose: function() {
                                        window.setTimeout(function(){
                                            ths.resetLayout();
                                        }, 0);
                                    },
                                    
                                    resizeDialog: function() {
                                        var editorNode = this.editorNode; 
                                        
                                        
                                        if (mstrApp.isTablet()) {
                                            
                                            var popDimensions = this.popDimensions;
                                            if (popDimensions) {
                                                mh = popDimensions.h;
                                                mw = popDimensions.w;
                                            } else {
                                                
                                                mh = Math.min(488, mh);
                                                mw = Math.min(550, parseInt(w, 10));
                                            }
                                        }
                                        
                                        
                                        this.set('width', Math.min(parseInt(w, 10), mw) + 'px');
                                        
                                        
                                        if(editorNode) {
                                            editorNode.style.height = Math.min(parseInt(h, 10), mh) + 'px';
                                        }
                                        
                                        mstrmojo.Dialog.prototype.resizeDialog.call(this);
                                    },
                                    children: [overlay]
                                }, anchor.domNode);
                                
                                var INTERVAL = 300,
                                    t = 0,
                                    ti = window.setInterval(function () {
                                        var n = overlay.parent.editorNode;
                                        if (n) {
                                            var ow = n.clientWidth,
                                                oh = n.clientHeight;
                                            if (ow !== parseInt(w, 10) || oh !== parseInt(h, 10)) {
                                                overlay.setDimensions(oh + 'px', ow + 'px');
                                                window.clearTimeout(ti);
                                            }
                                        }
                                        t += INTERVAL;
                                        
                                        
                                        if (t > 10 * INTERVAL) {
                                            window.clearTimeout(ti);
                                        }
                                    }, INTERVAL); 
                                
                                doc.selectLayout(layout, true);
                                }
                            });
                        } else {
                            
                            me.selectLayout(layout, true);
                        }
                    })(taskParams, layouts);
                }
            },
            handleMarkerTargetSelection:function handleMarkerTargetSelection(ri,anchor){
            	var d = this.gridData,
                    att = d.gts.row[0],
                    attrid = att.id,
                    r = d.ghs.rhs.items[ri],
                    c = r && r.items[0].idx,
                    ths = this,
                    eid = (c >= 0) ? att.es[c].id : -1;
                
                
                var sc = this.getInfoWindowSelectorControl(d),
                    firstInfoWinKey = this.findSelectorTarget(sc);
    
                if (sc && sc.tks) {
                    var dataCacheUpdate = null,
                        dm = ths.xtabModel.docModel;

                    
                    dm.getDataService().setDocSelectorElements(sc.ck, eid, sc.ckey, sc.include, {
                        success: function (res) {

                            
                            var tgtDefs = dm.getTargetDefn(sc.tks);

                            
                            if (res.pukeys) {
                                tgtDefs = dm.getTargetDefn(res.pukeys);
                            }

                            
                            
                            
                            dataCacheUpdate = dm.updateDataCache(res.data, tgtDefs);

                            var firstInfoWinKey = ths.findSelectorTarget(sc);
                            
                            
                            if(firstInfoWinKey) {
                                var targetDef = dm.getTargetDefn(firstInfoWinKey),
                                    id = firstInfoWinKey + "_ifw",
                                    w = mstrmojo.all[id],
                                    psId = "*l" + res.currlaykey + "*k" + firstInfoWinKey + "*x1*t" + dm.buildTime;
    
                                
                                if (w) {
                                    w.destroy();
                                }
    
                                var ifw = new mstrmojo.maps.androidmap.AndroidDocMapInfoWindow({
                                    id: id,
                                    builder: ths.doc.builder,
                                    model: dm,
                                    psKey: firstInfoWinKey,
                                    psId: psId
                                });
                            
                             
                                var fmts = targetDef[firstInfoWinKey].fmts,
                                    iw = parseInt(fmts.width, 10) || width,
                                    ih = parseInt((fmts.p_fmts && fmts.p_fmts.height) || fmts.height, 10) || height;
    
                                ifw.set('width', iw + 'px');
                                ifw.set('height', ih + 'px');
                                
                                mstrApp.showPopup({
                                    id: 'mstrMapInfoWindow',
                                    scriptClass: 'mstrmojo.android.Popup',
                                    cssClass: 'mapInfoWindow',
                                    anchorOffset: 1,
                                    children: [ifw],
                                    resizeDialog: function() {
                                        var editorNode = this.editorNode;
                                        
                                        this.set('width', iw + 'px');
                                        
                                        
                                        if(editorNode) {
                                            editorNode.style.height = ih + 'px';
                                        }
                                        
                                        mstrmojo.Dialog.prototype.resizeDialog.call(this);
                                    }
                                }, anchor.domNode);
                            }
                            
                            
                            
                            var ue = {
                                name: 'partialUpdate',
                                tree: res.data,   
                                ids: dataCacheUpdate,
                                anchor: anchor.domNode
                            };

                            
                            if (!mstrmojo.hash.isEmpty(ue.ids.ifws)) {
                                
                                delete ue.ids.ifws[firstInfoWinKey];
                            }
                            
                            
                            dm.raiseEvent(ue);
                        }
                    }, dm.zf, true);
                } 
            },
            
            getInfoWindowSelectorControl: function getInfoWindowSelectorControl(d) {
                if (!this.sc && !d.eg) {
                    
                    this.sc = d.gts.row[0].sc;
                }
                return this.sc;
            },
            
            afterViewVisible: function afterViewVisible() {
                window.setTimeout(function() {mstrMobileApp.showMapView(1);},300);
            },
            
            removeMap:function removeMap() {
            	 
                this.closeInfoWindow();
                
                this.removeMarkerAnchor();
                
                
                
                
                
                
                
                
                
                
                
                
                this.resetLayout();
                
                
                if(deregisterMapRendering.call(this)) {
                    
                    mstrMobileApp.hideMapView(1);
                } 
            },
            
            unrender: function() {
                this.lastSelectedRow = null;
                this._super();
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.android.AndroidDICPopup",
                         "mstrmojo.DefaultDIC",
                         "mstrmojo.android.inputControls.SliderDIC",
                         "mstrmojo.android.inputControls.TextFieldDIC",
                         "mstrmojo.android.inputControls.CheckBoxDIC",
                         "mstrmojo.android.inputControls.PullDownDIC",
                         "mstrmojo.android.inputControls.RadioListDIC",
                         "mstrmojo.android.inputControls.LikertScaleDIC",
                         "mstrmojo.android.inputControls.CalendarDIC",
                         "mstrmojo.android.inputControls.DateTimePickerDIC",
                         "mstrmojo.android.inputControls.TextAreaDIC",
                         "mstrmojo.android.inputControls.MarkRowDIC",
                         "mstrmojo.android.inputControls.ToggleDIC",
                         "mstrmojo.android.inputControls.SignatureDIC",
                         "mstrmojo.android.inputControls.StepperDIC",
                         "mstrmojo.android.inputControls.RatingDIC",
                         "mstrmojo.android.inputControls.BarcodeDIC",
                         "mstrmojo.android.ui.Button");

    mstrmojo.requiresDescs(221, 1442);

    var $BTN = mstrmojo.android.ui.Button.newButton,
        TEXTFIELD = 1,
        SWITCH = 2,
        LIST = 3,
        SLIDER = 4,
        CALENDAR = 5,
        TIMEPICKER = 6,
        TOGGLE = 7,
        TEXTAREA = 8,
        SIGNATURE = 9,
        RATING = 10,
        STEPPER = 12,
        BARCODE = 13,
        LIKERTSCALE = 14,
        MARKROW = 102;
        




    var $ADC = mstrmojo.android.AndroidDICConfig = mstrmojo.provide(

        "mstrmojo.android.AndroidDICConfig",

        {
            DICList: {
                1: mstrmojo.android.inputControls.TextFieldDIC,
                2: mstrmojo.android.inputControls.CheckBoxDIC,
                3: {
                    0: mstrmojo.android.inputControls.PullDownDIC,
                    1: mstrmojo.android.inputControls.RadioListDIC
                },
                4: mstrmojo.android.inputControls.SliderDIC,
                5: mstrmojo.android.inputControls.DateTimePickerDIC,
                6: mstrmojo.android.inputControls.DateTimePickerDIC,
                7: mstrmojo.android.inputControls.ToggleDIC,
                8: mstrmojo.android.inputControls.TextAreaDIC,
                9: mstrmojo.android.inputControls.SignatureDIC,
                10: mstrmojo.android.inputControls.RatingDIC,
                11: mstrmojo.DefaultDIC,
                12: mstrmojo.android.inputControls.StepperDIC,
                13: mstrmojo.android.inputControls.BarcodeDIC,
                14: mstrmojo.android.inputControls.LikertScaleDIC,
                102: mstrmojo.android.inputControls.MarkRowDIC
            },

            DICPopup: {
                getInstance: function (opener, dic) {
                    
                    return mstrApp.showPopup({
                        scriptClass: 'mstrmojo.android.AndroidDICPopup',
                        widget: dic,
                        buttons: [ $BTN(mstrmojo.desc(221, 'Cancel'), function () {
                            this.parent.parent.onCancel();
                        }), $BTN(mstrmojo.desc(1442, 'OK'), function () {
                            return this.parent.parent.onApply();
                        }) ],
                        title: dic.popupTitle || opener.parent.title        
                    });
                }
            },

            
            getDICClass: function getDICClass(dic) {
                if (dic.t === LIST) {
                    return this.DICList[dic.t][dic.st || 0];
                }
                return this.DICList[dic.t];
            },

            
            showDICByDefault: function showDICByDefault(dic, openerType) {
                if (dic.sbd === undefined) {
                    switch (dic.t) {
                    case LIST:
                        dic.sbd = (!!dic.st) ? true : false; 
                        break;
                    case CALENDAR:
                    case TIMEPICKER:
                    case TEXTFIELD:
                    case BARCODE:
                        dic.sbd = false;
                        break; 

                    case TOGGLE:
                    case SWITCH:
                    case MARKROW:
                    case RATING:
                    case STEPPER:
                    case LIKERTSCALE:
                        dic.sbd = true;
                        break;

                    default:
                        dic.sbd = (dic.dm === 1); 
                    }
                }

                return dic.sbd;
            },

            
            hasDICPreview: function hasDICPreview(dic, openerType) {
                
                return true;
            },

            isKeyNavigable: function isKeyNavigable(dic) {
                if (dic.ikn === undefined) {
                    dic.ikn = false;
                }
                return dic.ikn;
            }
        }
    );

    $ADC.TYPES = {
        TEXTFIELD: TEXTFIELD,
        SWITCH: SWITCH,
        LIST: LIST,
        SLIDER: SLIDER,
        CALENDAR: CALENDAR,
        TIMEPICKER: TIMEPICKER,
        TOGGLE: TOGGLE,
        TEXTAREA: TEXTAREA,
        SIGNATURE: SIGNATURE,
        RATING: RATING,
        STEPPER: STEPPER,
        LIKERTSCALE: LIKERTSCALE
    };

    mstrmojo.DICConfig = $ADC;
    mstrmojo.DICList = $ADC.DICList;
    mstrmojo.DICPopup = $ADC.DICPopup;
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.ui.Button",
                         "mstrmojo.android.large.ui.CalendarMarkupBuilder",
                         "mstrmojo.android.ui.CalendarDialog",
                         "mstrmojo.android.EnumOrientationTypes",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $D = mstrmojo.dom,
        $CSS = mstrmojo.css,
        $BTN = mstrmojo.android.ui.Button.newButton,
        CANCEL_TEXT = mstrmojo.desc(221, 'Cancel'),
        CLEAR_TEXT = mstrmojo.desc(2827, 'Clear'),
        OK_TEXT = mstrmojo.desc(1442, 'OK');

    
    function alignView(isTargetInView) {
        var dialogNode = this.domNode,
            targetDialogNode = this.targetDialog.domNode,
            targetListWidth = this.targetListWidth,
            offset = this.initialLeftPos;

        targetDialogNode.firstChild.style.left = (isTargetInView ? 0 : -targetListWidth + offset) + 'px';
        dialogNode.firstChild.style.left = (isTargetInView ? targetListWidth : offset) + 'px';
    }

    
    function setupTargetDialog() {
        var calendarDialog = this,
            calendarPosition = $D.position(calendarDialog[calendarDialog.popupNodeName]),
            offset = calendarDialog.initialLeftPos = calendarPosition.x,
            calendar = this.calendar,
            calList = calendar.target,
            items = calList.items,
            sizingFactor = 0.95,
            isLandscape = mstrApp.isLandscape(),
            availableHeight = mstrApp.getScreenDimensions().h - mstrApp.getContentDimensions().h,
            dialog;

        this.targetDialog = dialog = mstrApp.showDialog({
            title: calendar.title,

            manualClose: true,

            anchor: document.body,

            autoClose: true,

            anchorOffset: 10,

            children: [calList],

            buttons: [
                $BTN((items && items.length) ? CLEAR_TEXT : CANCEL_TEXT, function () {
                    calendarDialog.getCancelBtnFn();
                }, {
                    alias: 'cancelBtn'
                }),

                $BTN(OK_TEXT, calendar.fnOk)
            ],

            _elasticChild: calList,

            positionDialog: function () {
                
                var popupNodeStyle = this[this.popupNodeName].style;
                popupNodeStyle.top = (isLandscape ? availableHeight : calendarPosition.y) + 'px';
                popupNodeStyle.left = (isLandscape ? 0 : -calendarDialog.targetListWidth + offset) + 'px';
            },

            popDimensions: {
                w: calendarDialog.targetListWidth * sizingFactor,
                h: calendarDialog.targetListHeight * (isLandscape ? 1 : sizingFactor)
            },

            onClose: function () {
                    
                calendarDialog.close();
            },

            onclick: function onclick(evt) {
                calendarDialog.touchBegin({
                    target: evt.e.target
                });
            },

            touchBegin: function touchBegin(touch) {
                calendarDialog.touchBegin(touch);
            },

            cssClass: calendar.defaultCSS + ' mstrmojo-CalListDialog'
        });

        
        $CSS.addClass(dialog.domNode, 'animates');
        $CSS.addClass(calendarDialog.domNode, 'animates');
    }

    
    mstrmojo.android.large.ui.CalendarDialog = mstrmojo.declare(

        
        mstrmojo.android.ui.CalendarDialog,

        
        null,

        
        {
            scriptClass: "mstrmojo.android.large.ui.CalendarDialog",

            
            markupBuilder: mstrmojo.android.large.ui.CalendarMarkupBuilder,

            init: function (props) {
                
                this._super(props);

                var calendar = this.calendar;

                
                calendar.layoutConfig.h.monthNode = (this.popDimensions.h - 100  - 28) + 'px';
                calendar.title = this.title;
                calendar.fnOk = this.buttons[1].onclick;
                delete this.title;
                delete this.buttons;
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                
                setupTargetDialog.call(this);

                
                delete this.targetDialog._elasticChild;
            },

            
            getPopupDimensions: function getPopupDimensions() {
                var result = this._super();

                
                if (mstrApp.isLandscape()) {
                    result.h = mstrApp.getContentDimensions().h * 0.9;
                }

                return result;
            },

            
            onclick: function onclick(evt) {
                this.touchBegin({
                    target: evt.e.target
                });
            },

            
            touchBegin: function touchBegin(touch) {
                var $CONTAINS = $D.contains,
                    isLandscape = mstrApp.isLandscape(),
                    dialogNode = this.domNode,
                    targetDialogNode = this.targetDialog.domNode,
                    targetNode = touch.target;

                
                if (this.autoClose && targetNode === this.curtainNode) {
                    
                    mstrApp.closeDialog();
                } else if (!isLandscape && $CONTAINS(dialogNode, targetNode, true, dialogNode)) {
                    alignView.call(this);
                } else if (!isLandscape && $CONTAINS(targetDialogNode, targetNode, true, targetDialogNode)) {
                    alignView.call(this, true);
                }
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.MobileXtab",
                         "mstrmojo.array",
                         "mstrmojo.hash");

    
    function removeStyleSheet() {
        var xtabStyleSheet = this.xtabStyleSheet,
            parentNode =  xtabStyleSheet && xtabStyleSheet.parentNode;

        
        if (parentNode) {
            parentNode.removeChild(xtabStyleSheet);

            
            delete this.xtabStyleSheet;
        }
    }

    
    mstrmojo.AndroidXtab = mstrmojo.declare(
        
        mstrmojo.MobileXtab,

        null,

        
        {
            scriptClass: "mstrmojo.AndroidXtab",

            
            scrollerFriction: 0.0015,

            preBuildRendering: function preBuildRendering() {
                
                removeStyleSheet.call(this);

                
                this.updateXtabStyles(this.model.data.cssString);

                
                this._super();
            },

            
            onwidthChange: function onwidthChange() {
                
                if (this.gridData.afw) {
                    var sbn = this.scrollboxNode,
                        width = this.width;

                    
                    if (sbn) {
                        sbn.style.width = width;
                    } else {
                        this.scrollboxNodeCssText = 'width: ' + width;
                    }
                }

                
                if (this._super) {
                    this._super();
                }
            },

            
            updateXtabStyles: function updateXtabStyles(css) {
                
                if (!this.xtabStyleSheet) {
                    this.xtabStyleSheet = document.getElementsByTagName('head')[0].appendChild(document.createElement('style'));
                }

                
                this.xtabStyleSheet.appendChild(document.createTextNode(css));
            },

            
            unrender: function unrender(ignoreDom) {
                this._super(ignoreDom);

                
                removeStyleSheet.call(this);
            },
            
            getMaskNode: function getMaskNode() {
                var div = document.createElement('div');
                div.appendChild(this.xtabStyleSheet.cloneNode(true));
                div.appendChild(this.domNode.cloneNode(true));
                
                return div;
            },

            
            updateActionMenu: function updateActionMenu(cell, actions) {
                
                this._selectionActions = actions;

                
                return true;
            },

            setModel: function setModel(model) {
                this._super(model);

                
                this.controller.getPageByTree(false);
            },

            deselectCell: function deselectCell() {
                this._super();

                
                delete this._selectionActions;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.array",
                         "mstrmojo.string",
                         "mstrmojo.elementHelper",
                         "mstrmojo.SimpleObjectInputBox");

    var $ARR = mstrmojo.array,
        $DOM = mstrmojo.dom,
        thousandsSeperator = mstrConfig.thousandsSep;

    
    if (thousandsSeperator === undefined) {
        
        thousandsSeperator = ',';
    }

    var ERR_SDK_E_INVALID = 0x80044033,
        ERR_SDK_E_PROMPT_NUMERICAL_VALUES = 0x80044056,
        ERR_SDK_E_PROMPT_DATE_TIME = 0x8004405D,
        MAX_SUGGESTION_POPUP_HEIGHT = 140;

    var markup;

    mstrmojo.SearchBoxSelectorList = mstrmojo.declare(

        mstrmojo.SuggestionList,

        null,

        {
            getItemMarkup: function (item, idx) {
                
                if (!markup) {
                    
                    markup = this._super(item, idx).replace('>{@' + this.itemField + '}<', '>{@' + this.itemField + '}{@weight}<');
                }

                return markup;
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx),
                    weight = item.wt;

                
                props.weight = (weight) ? '<em>(' + mstrmojo.num.addSeparators(weight, thousandsSeperator) + ' likes)</em>' : '';

                return props;
            }
        }
    );

    
    mstrmojo.SearchBoxSelector = mstrmojo.declare(

        mstrmojo.SimpleObjectInputBox,

        null,

        
        {
            cssClass: 'mstrmojo-SearchBoxSelector',

            srcid: null,

            dataSourcesXML: null,

            maxItemWidth: '',

            suggestionListClass: 'mstrmojo.SearchBoxSelectorList',

            postCreate: function postCreate() {
                var suggestionPopup = this.suggestionPopup;

                
                suggestionPopup.cssClass = 'mstrmojo-SearchBoxSelector-suggest';

                
                suggestionPopup.nudge = function () {
                    
                    var editorNode = this.editorNode;
                    if (!editorNode) {
                        
                        return;
                    }

                    var height = Math.min(editorNode.offsetHeight, MAX_SUGGESTION_POPUP_HEIGHT),
                        width = editorNode.offsetWidth,
                        windowDimensions = $DOM.windowDim(),
                        left = this.left,
                        top = this.top;

                    
                    if (top + height >= windowDimensions.h) {
                        
                        top -= height;
                    }

                    
                    if (left + width >= windowDimensions.w) {
                        
                        left -= width;
                    }

                    
                    var editorNodeStyle = editorNode.style;
                    editorNodeStyle.top = top + 'px';
                    editorNodeStyle.left = left + 'px';
                };
            },

            preBuildRendering: function preBuildRendering() {
                
                
                
                
                this.set('maxItemWidth', this.parent.contentNode.offsetWidth);

                this._super();
            },
            
            postBuildRendering: function postBuildRendering() {
            	var fmts = this.parent.defn.fmts;
            	
            	
            	
            	if (!fmts.height) {
            		this.domNode.style.height = "auto";
            	}
            	return this._super();
            },
            
            
            filterCandidates: function filterCandidates(items, t, max) {
                var filteredCandidates = items,
                    suggestCnt = this.suggestCount;

                if (!this.noCache) {
                    
                    max = max || suggestCnt;
                    t = mstrmojo.string.regEscape(t);

                    var itemField = this.itemField,
                        testExp = new RegExp('^' + t, 'i');

                    filteredCandidates = $ARR.filter(items, function (item) {
                        return testExp.test(item[itemField]);
                    }, {
                        max: max
                    });
                }

                
                if (filteredCandidates.length) {
                    $ARR.forEach(this.items, function (item) {
                        var idx = $ARR.find(filteredCandidates, 'v', item.v);
                        if (idx > -1) {
                            filteredCandidates.splice(idx, 1);
                        }
                    });
                }

                if (filteredCandidates.length >= suggestCnt) {
                    filteredCandidates = filteredCandidates.slice(0, suggestCnt);
                }

                return filteredCandidates;
            },

            getCandidatesThroughTaskCall: function getCandidatesThroughTaskCall(params, callbacks) {
                var id = this.id,
                    targetWas = this.getSuggestionTarget(),
                    searchPattern = params.pattern || '',
                    parent = this.parent,
                    attributeId = this.srcid;

                
                searchPattern = searchPattern.replace(/"/, '');

                
                if (attributeId) {
                    
                    var taskParams = {
                        taskId: 'browseElements',
                        styleName: 'MojoAttributeStyle',
                        attributeID: attributeId,
                        dataSourcesXML: this.dsrc || '',
                        blockCount: this.REQUEST_THRESHOLD,
                        searchPattern: searchPattern,
                        browseFlags: 1
                    };

                    
                    var defn = parent.defn;
                    if (defn.dsid) {
                        taskParams.datasetID = defn.dsid;
                        taskParams.messageID = parent.model.mid;
                        taskParams.ctlKey = parent.ckey;
                    }

                    
                    if (defn.sfid) {
                        
                        taskParams.searchForms = defn.sfid;

                        
                        if (parseInt(defn.sfdt, 10) === 8) {
                            
                            taskParams.searchPattern += '*';
                        }
                    }

                    callbacks.success = function (res) {
                        if (res && res.es) {
                            var box = mstrmojo.all[id],
                                target = box.getSuggestionTarget(),
                                len = res.es.length;

                            if (!res || !target || (targetWas !== target)) {
                                return;
                            }

                            
                            if (len && (len > box.suggestCount)) {
                                return;
                            }

                            var newPattern = target.getSearchPattern(),
                                items = res.es;

                            
                            if (attributeId) {
                                items = mstrmojo.elementHelper.buildElemsTerseID(items, attributeId, true);
                            }

                            var srcPattern = params.pattern;

                            
                            box._last_hit = {
                                items: items,
                                pattern: srcPattern
                            };

                            if (newPattern && newPattern.indexOf(srcPattern) > -1) {
                                box.updateSuggestion(box.filterCandidates(items, newPattern));
                            }
                        }
                    };

                    
                    
                    
                    
                    
                    
                    callbacks.failure = function (res) {
                        var ec = parseInt(res.getResponseHeader('X-MSTR-TaskErrorCode'), 10) + 0x100000000;
                        if (ec !== ERR_SDK_E_INVALID && ec !== ERR_SDK_E_PROMPT_NUMERICAL_VALUES && ec !== ERR_SDK_E_PROMPT_DATE_TIME) {
                            mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
                        }
                    };

                    mstrmojo.xhr.request('POST', mstrConfig.taskURL, callbacks, taskParams, false, null, true); 
                }
            },

            onsuggestionItemsChange: function onsuggestionItemsChange() {
                var suggestionItems = this.suggestionItems,
                    popup = this.suggestionPopup,
                    editorNode = popup.editorNode,
                    hasScrollBar = suggestionItems && (suggestionItems.length > 8),
                    height = '',            
                    px = '';                

                
                if (hasScrollBar) {
                    
                    height = MAX_SUGGESTION_POPUP_HEIGHT;
                    px = 'px';
                }

                
                if (editorNode) {
                    
                    editorNode.style.height = height + px;

                } else if (hasScrollBar) {
                    
                    px += ';';

                    
                    popup.cssText = (popup.cssText || '') + 'height:' + height + px;
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.desc",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo.android.controllers._HasPageBy");

    mstrmojo.requiresDescs(5136, 6189);

    
    var MENUS = mstrmojo.android.EnumMenuOptions,
        PAGE_BY = MENUS.PAGE_BY,
        REPROMPT = MENUS.REPROMPT;

    var $HASH = mstrmojo.hash,
        $DESC = mstrmojo.desc;

    
    mstrmojo.android.controllers._IsReportController = mstrmojo.provide(

        'mstrmojo.android.controllers._IsReportController',

        
        $HASH.copy(mstrmojo.android.controllers._HasPageBy, {

            _mixinName: 'mstrmojo.android.controllers._IsReportController',

            hasPageBy: function hasPageBy() {
                var gridData = this.gridData,
                    gridHeaders = gridData && gridData.ghs;

                return !!(gridHeaders && gridHeaders.phs);
            },

            updateActionToolbar: function updateActionToolbar(tbCfg) {
                
                this.addFullScreenButton(tbCfg);

                
                var view = this.view;
                if ((view && view.hasPageBy && view.hasPageBy()) || this.hasPageBy()) {
                    
                    tbCfg.addToolbarBtn(PAGE_BY, $DESC(5136, 'Page By'), PAGE_BY, true, 1);
                }

                
                if (mstrMobileApp.isOnline()) {
                    var model = this.xtabModel || this.model, 
                        prompts = model.prompts;

                    
                    if (prompts && prompts.hasSupported()) {
                        
                        tbCfg.addToolbarBtn(REPROMPT, $DESC(6189, 'Filter'), REPROMPT, true, 3);
                    }
                }

                return this._super(tbCfg);
            },

            handleMenuItem: function handleMenuItem(group, cmdId) {
                
                switch (group) {
                case PAGE_BY:
                    this.showPageByDialog();
                    break;

                case REPROMPT:
                    this.reprompt();
                    break;

                default:
                    return this._super(group, cmdId);
                }

                return false;
            }
        })
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ResultSetController",
                         "mstrmojo._IsDocController",
                         "mstrmojo.android.controllers._SupportsQueuedTransactions",
                         "mstrmojo.android.controllers._HasPageBy",
                         "mstrmojo.ui.MobileCheckList",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo.string",
                         "mstrmojo.array",
                         "mstrmojo.hash");

    mstrmojo.requiresDescs(1089, 1917, 2941, 6189, 9233, 9254, 9255, 9256, 9257);

    var $HASH = mstrmojo.hash,
        $ARR = mstrmojo.array,
        MENUS = mstrmojo.android.EnumMenuOptions,
        MNU_LAYOUTS = MENUS.DOC_LAYOUTS,
        MNU_GROUPBY = MENUS.GROUP_BY,
        MNU_REPROMPT = MENUS.REPROMPT,
        MNU_SHARE = MENUS.SHARE,
        MNU_ANNOTATION = MENUS.ANNOTATION,
        UNIT_SEPARATOR = '\u001F',
        MARK_ROW = 1;                   


    function getCurLayout(me) {
        var model = me.model,
	        lyts = model.data.layouts,
	        i = $ARR.find(lyts, 'k',  model.currlaykey);
    	return i >= 0 ? lyts[i] : null;
    }

    function getDrillGB(me, view) {
        var elements = me.getGroupByElements(view),
        	res = [],
	        lyt = getCurLayout(me),
	        gbys = lyt && lyt.gbys && lyt.gbys.groupbys,
	        elemSize = elements && elements.length;

	    if (elemSize && gbys) {
	        for (i = 0; i < elemSize; i++) {
	            var gb = gbys[i].unit.target;
	            res.push(gb.did);
	            res.push(gb.t);
	            res.push(elements[i]);
	        }
	    }
	    return res.join(UNIT_SEPARATOR);
    }

    function getDesiredUnits(me, elements) {
        var res = me.desiredUnits || {},                
            lyt = getCurLayout(me),
            elemSize = elements && elements.length;

        if (lyt && lyt.gbys) {
            var gbys = lyt.gbys.groupbys,
                size = gbys.length;

            for (i = 0; i < size; i++) {
                var gb = gbys[i].unit,
                    elem;
                if (elements) {
                    if (i < elemSize) {
                        elem = elements[i];
                    } else {
                        
                        
                        break;
                    }
                } else {
                    elem = gb.elms[gb.idx].v;
                }
                res[gb.target.did] = elem;
            }
        }
        return res;
    }

    function toDesiredElements(units) {
        var res = '',
            i = 0,
            u;

        for (u in units) {
            if (i > 0) {
                res += UNIT_SEPARATOR;
            }
            res += u + UNIT_SEPARATOR + units[u];
            i++;
        }

        return res;
    }

    
    function clearRefreshTimer() {
        if (this.refreshTimer) {
            clearInterval(this.refreshTimer);
            delete this.refreshTimer;
        }
    }

    
    function startRefreshTimer() {
        var rf = this.model.rf;
        if (rf && rf > 0) {
            var ths = this;
            this.refreshTimer = self.setInterval(function () {

                ths.checkCache( null, null, null, 2);

            }, rf * 1000);
        }
    }

    
    function clearOrientation() {
        
        var previousOrientation = this._previousOr;

        
        if (previousOrientation === -1) {
            
            return;
        }

        
        if (previousOrientation === 0) {
            
            window.setTimeout(function () {
                mstrMobileApp.releaseOrientation();
            });

        
        } else if (previousOrientation > 0) {
            
            mstrMobileApp.lockOrientation(previousOrientation);
        }

        
        this._previousOr = -1;
    }

    
    function getTxController() {
        return mstrApp.getTransactionNotificationController();
    }

    
    function createLinkParams(queryKeys, linkSrc) {
        
        var params = {
            srcMsgId: this.model.mid,
            desiredUnits: getDesiredUnits(this, this.getGroupByElements(linkSrc))
        };

        
        $HASH.forEach(queryKeys, function (v, k) {
            
            v = v.replace(/\+/g, ' ');
            params[k] = decodeURIComponent(v);
        });

        
        return params;
    }

    

    function fillTxData(params) {
        var txds = params.txData.split(';'),
            i,
            size = txds.length;

        for (i = 0; i < size; i++) {
            var t = txds[i],

                
                kvp = t.split(','),

                
                v = decodeURIComponent(kvp[1]),

                
                
                w = this.model.getFirstUnitInstanceByName(kvp[0]);

            
            if (w) {

                
                w.dataChanged(0, w.v, {
                    dv: v,
                    v: v
                }, w.valueNode);
            }
        }
    }

    
    mstrmojo.android.controllers.DocumentController = mstrmojo.declare(

        mstrmojo.android.controllers.ResultSetController,

        [ mstrmojo.android.controllers._SupportsQueuedTransactions, mstrmojo._IsDocController, mstrmojo.android.controllers._HasPageBy ],

        
        {
            scriptClass: "mstrmojo.android.controllers.DocumentController",

            initModel: function initModel(params) {
                return mstrApp.modelFactory.newModel('Document', $HASH.copy(params, {
                    controller: this
                }));
            },

            
            hasTxChanges: false,

            start: function start(params, callback) {
                
                var du = this.desiredUnits = params.desiredUnits;
                if (du) {
                    var desired = toDesiredElements(du);
                    if (desired) {
                        params.desiredElements = desired;
                    }
                    delete params.desiredUnits;
                }

                
                this.sub_id = params.sub_id;

                this.hasTxChanges = !!params.hasTxChanges;

                this._super(params, callback);
            },

            
            createView: function createView(res, params) {
                var layouts = res.defn.layouts,
                    currentLockedOrientation = mstrMobileApp.getLockedOrientation(),        
                    lastLayoutOrientation = -1,                                             
                    newOrientation = -1,                                                    
                    shouldLock = true,                                                      
                    cnt = layouts.length,
                    i;

                
                for (i = 0; i < cnt; i++) {

                    
                    if (layouts[i].iw) {
                    	continue;
                    }

                    
                    var layoutOrientation = layouts[i].or;

                    
                    if (lastLayoutOrientation === -1) {
                        
                        lastLayoutOrientation = layoutOrientation;
                    }

                    
                    if (layoutOrientation !== lastLayoutOrientation || layoutOrientation === 3) {
                        
                        shouldLock = false;

                        
                        break;
                    }
                }

                
                if (currentLockedOrientation > 0) {
                    
                    if (shouldLock) {
                        
                        if (lastLayoutOrientation !== currentLockedOrientation) {
                            
                            newOrientation = lastLayoutOrientation;
                        }

                    } else {
                        
                        newOrientation = 0;
                    }

                } else {
                    
                    if (shouldLock) {
                        
                        newOrientation = lastLayoutOrientation;
                    }
                }

                
                if (newOrientation > -1) {
                    
                    if (newOrientation === 0) {
                        
                        mstrMobileApp.releaseOrientation();
                    } else {
                        
                        mstrMobileApp.lockOrientation(newOrientation);
                    }

                    
                    this._previousOr = currentLockedOrientation;
                }

                
                var doc = this.view = this.newView('Document', params);
                doc.set('model', this.model);

                
                doc.buildChildren();

                
                return doc;
            },

            afterReprompt: function afterReprompt(response) {
                
                var view = this.view;
                view.unloadLayouts(null, false);
                view.model.loadLayout(response, true);
                this._super(response);
            },

            onPageBy: function onPageBy(pageByKeys) {

                var gbUnits = '';
                $ARR.forEach(pageByKeys, function (item, idx) {
                    if (idx) {
                        gbUnits += UNIT_SEPARATOR;
                    }

                    gbUnits += item.id + UNIT_SEPARATOR + item.v;
                });

                this.onGroupBy({
                    gbUnits: gbUnits
                });
            },

            hasPageBy: function hasPageBy() {
                var view = this.view,
                    layout = view && view.getLayouts() && view.getCurrentLayout();

                return !!(layout && layout.gb && layout.defn.dpb);
            },

            onGroupBy: function onGroupBy(params, callback, config) {
                var view = this.view,
                    model = this.model;

                config = config || {};
                config.showWait = true;
                config.hideWait = true;
                config.delay = true;

                
                callback = mstrmojo.func.wrapMethods(callback, {
                    success: function (res) {
                        
                        view.unloadLayouts(null, true);
                        model.loadLayout(res);
                    }
                });

                model.getDataService().changeDocGroupBy(params, callback, config);
            },

            setData: function setData(res, isNewData) {
                
                
                var view = this.view;

                if (isNewData && view) {
                    
                    view.unloadLayouts(null, false);
                }

                this.model.loadLayout(res);

                if ( res.rf != this.old_rf ) {
                    
                    clearRefreshTimer.call(this);

                    
                    startRefreshTimer.call(this);
                }

                
                this.rootCtrl.updateContent( null , this.model.n, false  );
            },

            onDrill: function onDrill(view, action) {
                
                if (!this.isInRequest()) {
                    
                    if (action.isWithin) {
                        
                        view.model.drillGrid(this._addNodeKeyToAction(view, action), this._getXtabCallback(view));
                    } else {
                    	
                        action.rwGroupByElements = getDrillGB(this, view);
                        
                        this._super(this._addNodeKeyToAction(view, action));
                    }
                }
            },

            onDownloadGridData: function onDownloadGridData(view, action) {
                this.model.downloadGridData(this._addNodeKeyToAction(view, action));
            },

            onExecuteNewObject: function onExecuteNewObject(view, action) {
                this._super(action);
            },

            onReExecute: function onReExecute(view) {
                this.reExecute(view);
            },

            
            refresh: function refresh(params, callback) {

                var id = this.id;
                
                this.model.getDataService().refresh( params, mstrmojo.func.wrapMethods({
                    success: function (res) {
                        mstrmojo.all[id].setData(res, true);
                    }
                }, callback) );
            },

            invalidClientCache: function () {
                if (mstrApp.useBinaryFormat) {
                    mstrMobileApp.removeLiveCache(mstrApp.getCurrentProjectId(), this.model.ci.cid);
                }
            },

            
            onTransactionUpdates: function onTransactionUpdates(view, updateObject, autoRefresh) {
                var md = this.model,
                    callback;

                if (mstrApp.useBinaryFormat) {
                    callback = md.newCallback({
                        success: function () {
                            
                            view.clear();

                            md.clearTxDeltaUpdate();

                            if (autoRefresh) {
                                
                                
                                setTimeout(function () {
                                    view.autoRefresh();
                                }, 250); 

                            }
                        }
                    });

                    var dataService = md.getDataService();
                    if (updateObject.manipulation === MARK_ROW) {
                        dataService.txMarkRows(updateObject, callback);
                    } else {
                        dataService.txChangeData(updateObject, callback);
                    }

                } else {
                    
                    if (autoRefresh) {
                        
                        view.autoRefresh();
                    }
                }

                
                this.hasTxChanges = true;
            },

            onLink: function onLink(view, action) {

                
                if (!action.url) {
                    return this._super(view, action);
                }

                
                var uri = mstrmojo.string.parseUri(action.url),
                    authority = uri.authority,
                    path = uri.path;

                if (uri.protocol === 'mstr') {
                    this.handleSpecialLink(uri, action);

                } else if (authority === 'mstrWeb' || authority === 'Main.aspx' || (/mstrWeb$/.test(path)) || (/Main\.aspx$/.test(path))) {
                    
                    this._super(view, createLinkParams.call(this, uri.queryKey, action.src));

                } else {
                    
                    var err = mstrMobileApp.openLink(uri.source, action.target);
                    if (err) {
                        mstrApp.onerror({
                            message: err
                        });
                    }
                }
            },

            
            getLinkRequest: function getLinkRequest(link) {
                var res;

                
                if (!link.url) {
                    res = this.buildLinkParams(link);

                } else {

                    
                    var uri = mstrmojo.string.parseUri(link.url),
                        uriParams = uri.queryKey,
                        authority = uri.authority,
                        path = uri.path;

                    if (uri.protocol !== 'mstr' && (authority === 'mstrWeb' || authority === 'Main.aspx' || (/mstrWeb$/.test(path)) || (/Main.aspx$/.test(path)))) {
                        res = this.buildLinkParams(createLinkParams.call(this, uriParams, link.src));

                        if (res) {
                            switch (parseInt(uriParams.evt, 10)) {
                            case 4001:
                                res.taskID = "reportExecute";
                                res.styleName = "AndroidMessageResultStyle"; 
                                break;

                            case 2048001:
                                res.taskID = "RWExecute";
                                res.objType = 55;
                                var du = res.desiredUnits;
                                if (du) {
                                    var desired = toDesiredElements(du);
                                    if (desired) {
                                        res.desiredElements = desired;
                                    }
                                    delete res.desiredUnits;
                                }
                                break;
                            }
                        }

                    }
                }
                if (res && res.link) {
                    res.linkAnswers = res.link.toXml();
                    delete res.link;
                }
                
                return res;
            },

            getDesiredElements: function getDesiredElements(elements) {
                var gbElements = this.model.gbElements,
                    res = '';

                
                
                if (gbElements) {
                    var gbs = gbElements.split(';'),
                        size = gbs.length,
                        i;

                    for (i = 0; i < size; i += 3) {
                        if (i > 0) {
                            res += UNIT_SEPARATOR;
                        }
                        res += gbs[i] + UNIT_SEPARATOR + gbs[i + 2];
                    }
                } else {
                    res = toDesiredElements(getDesiredUnits(this, elements));
                }
                return res;
            },

            
            confirmMsgBeforeSubmit: function confirmMsgBeforeSubmit() {
                var md = this.model,
                    txNtfCtl = getTxController(),
                    msg;

                if (this.hasTxChanges && txNtfCtl && txNtfCtl.hasPendingTransactions(this.did)) {
                    
                    
                    if (md.txrcd) {
                        msg = mstrmojo.desc(9254, 'Pending transaction exists') + '. ' + mstrmojo.desc(9255, 'You are about to replace a pending transaction.');
                    } else {
                        msg = mstrmojo.desc(9256, 'There are one or more pending submissions in the transaction queue for this document.') + ' ' + mstrmojo.desc(9257, 'Continuing will submit a new transaction.');
                    }
                }
                return msg;
            },

            offlineTransactionsSubmitted: function offlineTransactionsSubmitted(ck) {
                var txNtfCtl = getTxController();
                if (txNtfCtl) {
                    txNtfCtl.setOfflineRecords(this.did);
                }
                
                
                this.hasTxChanges = false;
            },

            openOfflineTransactions: function openOfflineTransactions() {
                var txNtfCtl = getTxController();
                if (txNtfCtl) {
                    txNtfCtl.showNotificationBoard(this, this.did, this.ttl);
                }
            },

            transactionDiscarded: function transactionDiscarded(ck) {
                this.hasTxChanges = false;
            },

            destroy: function destroy() {
                
                clearOrientation.call(this);

                
                this._super();
            },

            nudgeWidget: function nudgeWidget(id, update) {
                if (mstrMobileApp !== undefined && mstrMobileApp.nudgeWidget) {
                    mstrMobileApp.nudgeWidget(id, JSON.stringify(update));
                }
            },

            
            resetOrientation: function resetOrientation() {
                clearOrientation.call(this);
            },

            checkCache: function checkCache(res, params, cacheIsGoodCallback, option, config) {

                
                this.old_rf = this.model.rf;

                
                this._super(res || {
                    ifc: true,
                    ci: this.model.ci
                }, params, cacheIsGoodCallback, option, config);
            },

            beforeViewHidden: function beforeViewHidden(isBack) {
                this._super(isBack);

                
                if (isBack) {
                    
                    mstrmojo.GraphBase.hideTooltips();

                    
                    this.resetOrientation();
                }

                
                clearRefreshTimer.call(this);
            },

            afterViewVisible: function afterViewVisible() {
                this._super();

                
                var view = this.view;
                if (view && view.afterViewVisible) {
                    
                    view.afterViewVisible();
                }

                
                
                if ( !this.isSubscription ) {
                    startRefreshTimer.call(this);
                }
            },

            hasFullScreenInfoWindow: function hasFullScreenInfoWindow(){

            	var view = this.view;

            	return view && view.fullScreenInfoWindow;
            },

            updateActionToolbar: function updateActionToolbar(tbCfg) {
                
                if (!this.hasFullScreenInfoWindow()) {
                    
                    this.getTxnToolbarButton(tbCfg);

                    
                    this.addFullScreenButton(tbCfg);

                    
                    if (mstrMobileApp.isOnline()) {
                        
                        var model = this.model,
                            docModel = model.docModel || model,
                            prompts = docModel.prompts,
                            
                            currentLayoutDef = docModel.getCurrentLayoutDef && docModel.getCurrentLayoutDef(),
                            dri = (currentLayoutDef && currentLayoutDef.dri);

                        
                        if (prompts && prompts.hasSupported() && (dri === undefined || dri)) {
                            
                            tbCfg.addToolbarBtn(MNU_REPROMPT, mstrmojo.desc(6189, 'Filter'), MNU_REPROMPT, true, 3);
                        }
                    }

                    
                    if (this.hasPageBy()) {
                        
                        tbCfg.addToolbarBtn(MNU_GROUPBY, mstrmojo.desc(2941, 'Grouping'), MNU_GROUPBY, true, 2);
                    }

                    
                    var layouts = this.view && this.view.getSupportedLayouts();
                    if (layouts && (layouts.length > 1)) {
                        
                        tbCfg.addToolbarBtn(MNU_LAYOUTS, mstrmojo.desc(4174, 'Layouts'), MNU_LAYOUTS, false, 8);
                    }
                }

                return this._super(tbCfg);
            },

            handleMenuItem: function handleMenuItem(group, cmdId) {
                
                if (group !== MNU_SHARE && group !== MNU_ANNOTATION) {
                	
                	mstrmojo.GraphBase.hideTooltips();

                	
                	if (mstrApp.isTablet()) {
                		this.view.closeInfoWindowsOnTablet();
                	}
                }

                switch (group) {
                case MNU_LAYOUTS:
                    var view = this.view,
                        fnLayouts = function () {
                            var layouts = view.getSupportedLayouts();

                            
                            return {
                                l: layouts,
                                idx: $ARR.indexOf(layouts, view.getCurrentLayout())
                            };
                        },
                        info = fnLayouts();

                    
                    mstrApp.showDialog({
                        title: mstrmojo.desc(4174, 'Layouts'),
                        children: [{
                            scriptClass: 'mstrmojo.ui.MobileCheckList',
                            isElastic: true,
                            multiSelect: false,
                            items: info.l,
                            selectedIndex: info.idx,
                            postselectionChange: function (evt) {
                                
                                var added = evt.added;
                                if (added) {
                                    
                                    if (view.showLayout(this.items[added[0]])) {
                                        
                                        mstrApp.closeDialog();
                                    }
                                }
                            },
                            postCreate: function () {
                                
                                mstrApp.rootController.attachEventListener('rootOrientationChange', this.id, function () {
                                    
                                    var info = fnLayouts();

                                    
                                    this.set('items', info.l);
                                    this.select(info.idx);

                                    
                                    this.parent.resizeDialog();
                                });
                            }
                        }]
                    });

                    return;

                case MNU_GROUPBY:
                    this.showGroupByDialog();
                    return;

                case MNU_REPROMPT:
                    this.reprompt();
                    return;

                }

                return this._super(group, cmdId);
            },

            makeCurrent: function makeCurrent(isBack) {
            	this.isBack = true;
            	this._super(isBack);
            	delete this.isBack;
            },

            handleSpecialLink: function handleSpecialLink(uri, action) {
                var param = uri.queryKey,
                    view = this.view,
                    eventId = param.evt;

                if (eventId === "2048500") {
                    
                    var name = param.panelName,
                        model = view.model,
                        unit = model.getInfoWindow(name);
                    if (unit) {
                        view.showInfoWindow(unit.id, unit.k, action.src.domNode);
                    }
                } else if (eventId === "2048030") {
                    

                	
                	var	fresh = !!param.useCache && param.useCache === "0",
                		rparams = {
                			fresh: fresh,
                			useRefreshProgress: mstrApp.isTablet()
                		};

                    this.refresh( rparams );

                
                } else if (eventId === "2048258") {   
                    fillTxData.call(this, param);

                
                } else if (eventId === "3037") {
                	this.share(param.emailSubject, true);

                } else if (eventId === "3175") {
                	
                	this.startAnnotate();
                } else if (uri.authority === 'gb') {
                    
                    var me = this,
                        curLayout = view.getSelectedLayoutWidget(),
                        gpby = curLayout.gb,
                        attId = param.a,
                        eId = param.e,
                        $forEach = $ARR.forEach;


                    
                    $forEach(gpby.groupbys, function (gb) {
                        var unit = gb.unit,
                            target = unit.target;

                        if (target.did === attId) {
                            var showDialog = function () {
                                var options = unit.elms,
                                    items = [];

                                
                                $forEach(options, function (opt, idx) {
                                    items.push($HASH.copy(opt, {
                                        k: gb.k,
                                        on: (idx === unit.idx)
                                    }));
                                });

                                mstrApp.showDialog({
                                    title: target.n,
                                    children: [{
                                        scriptClass: 'mstrmojo.ui.MobileCheckList',

                                        
                                        selectionPolicy: 'reselect',
                                        items: items,
                                        multiSelect: false,
                                        isElastic: true,
                                        selectedIndex: unit.idx,

                                        
                                        preselectionChange: function (evt) {
                                            
                                            if (evt.added[0] === evt.removed[0]) {
                                                
                                                mstrApp.closeDialog();

                                                
                                                return false;
                                            }

                                            
                                            if (this._super) {
                                                return this._super(evt);
                                            }
                                        },

                                        postselectionChange: function (evt) {
                                            mstrApp.closeDialog();

                                            var item = items[evt.added[0]];
                                            me.onGroupBy({
                                                groupbyKey: item.k,
                                                elementId: item.v
                                            });
                                        }
                                    }]
                                });
                            };

                            if (eId && parseInt(eId, 10) !== 0) {
                                this.onGroupBy({ 
                                    groupbyKey: gb.k,
                                    elementId: eId
                                }, {   
                                    
                                    failure: showDialog
                                }, {   
                                    
                                    noErrorMessage: true
                                });

                            } else {
                                showDialog();

                            }

                            
                            return false;
                        }
                    });
                } else {
                    this._super(uri, action);

                }
            },

            
            
            getContentDimensions: function getContentDimensions() {

                var dim = mstrApp.getContentDimensions();

                return {
                	w: dim.w,
                	h: dim.h
                };
            },

            
            canDelegateToolBar: function canDelegateToolBar () {
            	if (this.hasFullScreenInfoWindow()) {
            		return false;
            	}

            	return this._super();
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ResultSetController",
                         "mstrmojo.android.controllers._IsReportController",
                         "mstrmojo.android.EnumMenuOptions");

    var MENUS = mstrmojo.android.EnumMenuOptions,
    	MNU_SHARE = MENUS.SHARE,
    	MNU_ANNOTATION = MENUS.ANNOTATION;
    
    
    mstrmojo.android.controllers.GraphController = mstrmojo.declare(

        mstrmojo.android.controllers.ResultSetController,

        [ mstrmojo.android.controllers._IsReportController ],

        
        {
            scriptClass: "mstrmojo.android.controllers.GraphController",

            initModel: function initModel() {
                return mstrApp.modelFactory.newModel('Graph', {
                    controller: this
                });
            },

            createView: function createView(res, params) {
                var graph = this.view = this.newView('Graph', params);

                
                graph.setModel(this.model);
                return graph;
            },

            hasPageBy: function hasPageBy() {
                var modelData = this.model && this.model.data;
                return !!(modelData && modelData.gd && modelData.gd.pb);
            },

            reprompt: function reprompt() {
                
                this.repromptOrientation = mstrMobileApp.getOrientation();

                this._super();
            },

            afterReprompt: function afterReprompt(response) {
                
                this.view.setGraphData(response);
                this._super(response);
            },

            onPageBy: function onPageBy(pageByKeys) {
                var graph = this.view;
                this.model.pageBy(pageByKeys, {
                    success: function () {
                        graph.refresh();
                    },
                    failure: function (res) {
                        mstrApp.onerror(res);
                    }
                });
            },

            setData: function setData(res) {
                this.model.setData(res);
                this.view.refresh();
            },

            beforeViewVisible: function beforeViewVisible(isBackOperation) {
                
                if (this.repromptFlag && (this.repromptOrientation !== mstrMobileApp.getOrientation()) && isBackOperation) {
                    
                    delete this.repromptFlag;
                    delete this.repromptOrientation;

                    
                    this.refresh();
                }
            },

            beforeViewHidden: function beforeViewHidden(isBackOperation) {
                
                mstrmojo.GraphBase.hideTooltips();
            },

            handleMenuItem: function handleMenuItem(group, cmdId) {
                
            	
                if (group !== MNU_SHARE && group !== MNU_ANNOTATION) {
                	this.view.syncTooltips(0, 0);
                }

                this._super(group, cmdId);
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.android.controllers.ResultSetController",
                         "mstrmojo.android.controllers._IsReportController");

    
    function getUpdateXtabCallback(ctrl) {
        return {
            success: function (res) {
                ctrl.setData(res);
            }
        };
    }

    
    function initiateXtabInteractivity(methodName, args) {
        
        args.push(getUpdateXtabCallback(this));

        
        var model = this.model;
        model[methodName].apply(model, args);
    }

    
    mstrmojo.android.controllers.XtabController = mstrmojo.declare(

        mstrmojo.android.controllers.ResultSetController,

        [ mstrmojo.android.controllers._IsReportController ],

        
        {
            scriptClass: "mstrmojo.android.controllers.XtabController",

            initModel: function initModel() {
                return mstrApp.modelFactory.newModel('Xtab', {
                    controller: this
                });
            },

            
            createView: function createView(res, params) {
                
                var styleName = this.model.data.visName;
                if (styleName) {
                    
                    var vis = mstrmojo.AndroidVisList.getVis(styleName);
                    if (vis) {
                        
                        params.viz = vis;
                    }
                }

                
                var xtab = this.view = this.newView('Xtab', params);

                
                xtab.setModel(this.model);
                return xtab;
            },

            afterReprompt: function afterReprompt(response) {
                
                this.view.set('gridData', response);

                
                this._super(response);
            },

            setData: function setData(res) {
                
                var xtab = this.view;
                xtab.unrender();

                
                xtab.set('gridData', res);

                
                var dim = mstrApp.getContentDimensions();
                xtab.width = dim.w + 'px';
                xtab.height = dim.h + 'px';

                
                xtab.render();
            },

            hasPageBy: function hasPageBy() {            	
                var data = this.model.data;
                if(this.view && this.view.isTimeSeries){
                      var phs = data && data.phs
                      return !!(phs && phs.show);         
                }else{            
                      var gridHeaders = data && data.ghs;
                      return !!(gridHeaders && gridHeaders.phs);
                }

            },

            checkCache: function checkCache(res, params, callback, option, config) {
                
                this._super(res || {
                    ifc: true,
                    ci: this.model.data.ci
                }, params, callback, option, config);
            },

            onDrill: function onDrill(view, action) {
                var me = this,
                    superDrill = this._super;

                
                this.checkCache(this.model.data, {
                    did: this.did,
                    t: this.t,
                    st: this.ctrlType
                }, function () {
                    
                    superDrill.call(me, action);
                }, false, {
                    silent: false,
                    showWait: true
                });
            },

            onSort: function onSort(action) {
                initiateXtabInteractivity.call(this, 'sort', [ action ]);
            },

            onPivot: function onPivot(action) {
                initiateXtabInteractivity.call(this, 'pivot', [ action ]);
            },

            onPageBy: function onPageBy(pageByKeys) {
                this.model.pageBy(pageByKeys, mstrmojo.func.wrapMethods(getUpdateXtabCallback(this), {
                    failure: function (res) {
                        mstrApp.onerror(res);
                    }
                }));
            },

            
            onDownloadGridData: function onDownloadGridData(view, action) {
                this.model.downloadGridData(action);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.MetricSlider",
                         "mstrmojo.MetricQualification",
                         "mstrmojo.SearchBoxSelector",
                         "mstrmojo.Label",
                         "mstrmojo.hash",
                         "mstrmojo.array");

    var $HASH = mstrmojo.hash,
        $ARR = mstrmojo.array,
        $FN = mstrmojo.emptyFn;

    var STYLES_PULLDOWN = 0,
        STYLES_SCROLLER = 1,
        STYLES_LIST = 2,
        STYLES_RADIO = 3,
        STYLES_CHECKBOX = 4,
        STYLES_BUTTON = 5,
        STYLES_LINK = 6,
        STYLES_METRIC_SLIDER = 7,
        STYLES_METRIC_QUAL = 8,
        STYLES_SEARCH_BOX = 9;

    var _ST_UC_ON_DS = 2;   

    var UNIT_CONDITION = 1,
		SUBTOTAL = 3;
    
    var ALL_ID = 'u;'; 

    
    var widgetMap = {};
    widgetMap[STYLES_METRIC_SLIDER] = 'MetricSlider';
    widgetMap[STYLES_METRIC_QUAL] = 'MetricQualification';
    widgetMap[STYLES_SEARCH_BOX] = 'SearchBoxSelector';

    
    function updateSelectorControl(selectorCtrl, style, data, defn, idx, elements) {
        
        switch (style) {
        case STYLES_PULLDOWN:
            
            selectorCtrl.idx = $HASH.any(idx, true);

            
            
            var selectorUnset = (typeof (selectorCtrl.idx) === 'undefined' || selectorCtrl.idx < 0);
            if (selectorUnset) {
                
                if ($ARR.find(elements, 'v', '-1') < 0) {
                    elements = [{
                        v: '-1',
                        n: ''
                    }].concat(elements);
                }
                selectorCtrl.idx = '0';
            }

            selectorCtrl.unset = !!selectorUnset;
            selectorCtrl.options = elements;
            break;

        case STYLES_METRIC_QUAL:
        case STYLES_METRIC_SLIDER:
            
            if (selectorCtrl.updateData) {
                selectorCtrl.updateData({
                    low: data.min,
                    high: data.max,
                    cnt: data.cnt,
                    nov: data.nov
                }, {
                    cs: data.cs,
                    f: data.f,
                    ft: data.ft,
                    qua : data.qt
                });
            }

            selectorCtrl.items = elements;
            selectorCtrl.selectedIndices = idx;
            break;

        case STYLES_SEARCH_BOX:

            if (elements && !defn.sos) {
                selectorCtrl.candidates = {
                    isComplete: true,
                    items: defn.srcid ? elements : []
                };
            }
            if (defn.srcid) {
                var ca = [],
                	ces = data.ces;
                if (ces && ces.constructor === Array) {
                	
                	if (defn['dfm'] == UNIT_CONDITION) {
                		for (var i = 0; i < ces.length; i++) {
                    		if (ces[i]['t'] != SUBTOTAL) {
                    			ca.push(ces[i]);
                    		}
                    	}
                	} else {
                		ca = ces.concat();
                	}
                }
                
                
              
              if (! defn.sos) {
                  var $ARRAY = mstrmojo.array,
                      new_ca = [];
                  $ARRAY.forEach(ca, function(item){
                      if ($ARRAY.find(selectorCtrl.candidates.items, 'v', item.v) > -1) {
                          new_ca.push(item);
                      }
                  });
                  ca = new_ca;
              }
                
                selectorCtrl.items = ca;
            }
            break;

        default:
            selectorCtrl.items = elements;
            selectorCtrl.selectedIndices = idx;
            break;
        }
    }

    
    mstrmojo.DocSelectorViewFactory = mstrmojo.declare(

        mstrmojo.Obj,

        null,

        
        {
            scriptClass: 'mstrmojo.DocSelectorViewFactory',

            
            newPulldown: $FN,

            attachTargetListeners: $FN,

            getSelectorClass: function getSelectorClass(selectorStyle, isHoriz) {
                
                var scriptClass = widgetMap[selectorStyle];

                
                if (scriptClass.constructor === Array) {
                    
                    scriptClass = scriptClass[(isHoriz) ? 0 : 1];
                }

                return scriptClass;
            },

            isSelectorSupported: function isSelectorSupported() {
                
                return true;
            },

            
            newSelector: function newSelector(selectorContainer) {
                var children = selectorContainer.children,
                    selectorCtrl = children && children[0],
                    selectorStyle = selectorContainer.style,
                    selectedIdx = selectorContainer.selIdx,
                    node = selectorContainer.node,
                    defn = node.defn,
                    data = node.data,
                    elements = data.elms,
                    elems;

                if (!this.isSelectorSupported(selectorContainer)) {
                    return null;
                }

                
                if (!selectorCtrl) {

                    
                    if (!selectorCtrl) {

                        var cekEvtListener = selectorContainer._cekEvtListener,
                            cekContextId = selectorContainer.id,
                            fnCEK;

                        
                        if (cekEvtListener) {
                            
                            defn.detachEventListener(cekEvtListener);

                            
                            delete selectorContainer._cekEvtListener;
                        }

                        
                        if (selectorStyle === STYLES_PULLDOWN) {
                            
                            selectorCtrl = this.newPulldown(selectorContainer);

                            
                            fnCEK = function (evt) {
                                
                                elems = this.options;

                                
                                if ($ARR.find(elems, 'v', evt.value) < 0) {
                                    if ($ARR.find(elems, 'v', '-1') < 0) {
                                        
                                        elems.unshift({
                                            v: '-1',
                                            n: ''
                                        });
                                    }

                                    selectorCtrl.idx = '0';
                                    selectorCtrl.options = elems;
                                    selectorCtrl.unset = true;

                                    selectorContainer._inSyncPhase = true;
                                    selectorCtrl.refresh();
                                    selectorContainer._inSyncPhase = false;
                                } else {
                                    selectorCtrl.set('value', evt.value);

                                }
                            };

                            
                            cekContextId = selectorCtrl.id;

                        } else {
                            
                            var cfg = this.getSelectorCtrlConfig(selectorContainer, selectorStyle, defn, elements),
                                scriptClass = cfg.scriptClass;

                            
                            if (!scriptClass) {
                                
                                selectorCtrl = new mstrmojo.Label({
                                    cssClass: 'unsupported',
                                    text: 'This selector is not supported.'
                                });

                            } else {
                                
                                delete cfg.scriptClass;

                                
                                var Clazz = $HASH.walk(scriptClass, mstrmojo);

                                
                                selectorCtrl = new Clazz(cfg);

                                
                                if (selectorStyle === STYLES_METRIC_SLIDER) {
                                    
                                    selectorContainer.attachEventListener('includeChange', selectorCtrl.id, function (evt) {
                                        
                                        this.set('include', evt.value);

                                        
                                        this.selectRange();
                                    });
                                }

                                
                                if (selectorStyle === STYLES_METRIC_SLIDER || selectorStyle === STYLES_METRIC_QUAL) {
                                    
                                    selectorContainer.attachEventListener('quaChange', selectorCtrl.id, function (evt) {
                                        
                                        this.set('qua', evt.value);
                                    });

                                    
                                    fnCEK = function (evt) {
                                        
                                        if (selectorContainer.id !== evt.value.id) {  
                                            selectorContainer._inSyncPhase = true;

                                            selectorCtrl.updateExpr(evt.value);

                                            if (selectorContainer.style === STYLES_METRIC_SLIDER) {
                                                selectorContainer.set('include', evt.value.include);
                                            }

                                            selectorContainer._inSyncPhase = false;
                                        }
                                    };

                                } else {

                                    
                                    fnCEK = function (evt) {
                                        var idxs = [];
                                        
                                        elems = this.node.data.elms;

                                        
                                        $ARR.forEach(evt.value, function (v) {
                                            var idx = $ARR.find(elems, 'v', v);
                                            if (idx > -1) {
                                                idxs.push(idx);
                                            }
                                        });

                                        this._inSyncPhase = true;
                                        selectorCtrl.select(idxs);
                                        this._inSyncPhase = false;
                                    };
                                }
                            }
                        }

                        
                        if (fnCEK) {
                            
                            selectorContainer._cekEvtListener = defn.attachEventListener('cekChange', cekContextId, fnCEK);
                        }
                    }

                    
                    selectorContainer.addChildren(selectorCtrl);
                }

                
                updateSelectorControl(selectorCtrl, selectorContainer.style, data, defn, selectedIdx, elements);

                return selectorCtrl;
            },

            
            getSelectorCtrlConfig: function getSelectorCtrlConfig(selectorContainer, selectorStyle, defn, elements) {
                
                var isHoriz = defn.horiz,
                    fmts = selectorContainer.getFormats(),
                    height = fmts && fmts.height,
                    copyProps = $HASH.copyProps,
                    data = selectorContainer.node.data,
                    cfg = {
                        scriptClass: this.getSelectorClass(selectorStyle, isHoriz),
                        multiSelect: defn.multi,
                        isHoriz: isHoriz,
                        include: defn.include,
                        itemWidthMode: defn.iwm,
                        allIdx: $ARR.find(elements, 'v', ALL_ID),
                        noneIdx: defn.include ? -1 : $ARR.find(elements, 'v', ALL_ID),
                        renderAllItems: !height,               
                        onchange: function () {
                            if (!selectorContainer._inSyncPhase) {
                                selectorContainer.selectorControlChange(this);
                            }
                        },
                        makeSelection: function(evt) {
                        	if (!selectorContainer._inSyncPhase) {
                        		selectorContainer.showInfoWin(evt && evt.selItem);
                        	}
                        }
                    };

                
                if (cfg.noneIdx !== -1) {
                    cfg.allIdx = -1;
                }

                
                if (selectorStyle === STYLES_SCROLLER || selectorStyle === STYLES_METRIC_SLIDER) {
                    
                    selectorContainer.extCls = 'extSlider';

                    if (defn.cek) {
                        defn.include = defn.cek.include;
                        data.cs = defn.cek.cs;
                        data.f = defn.cek.f;
                        data.ft = defn.cek.ft;
                        selectorContainer.qua = defn.cek.qua;
                    }

                }

                
                if (selectorStyle === STYLES_SCROLLER) {

                    
                    copyProps([ 'height', 'width' ], fmts, cfg);

                } else if (selectorStyle === STYLES_METRIC_QUAL || selectorStyle === STYLES_METRIC_SLIDER) {

                    if (selectorStyle === STYLES_METRIC_SLIDER) {
                        cfg.isHoriz = true;
                        cfg.include = defn.include;
                    }

                    copyProps([ 'height', 'width', 'font' ], fmts, cfg);
                    copyProps([ 'cs', 'ft' ], defn, cfg);
                    cfg.fmts = defn.f;
                    cfg.qua = selectorContainer.qua;
                    cfg.numFmts = defn.numFmts;
                }  else if (selectorStyle === STYLES_SEARCH_BOX) {
                	cfg = {
                			scriptClass: cfg.scriptClass,
                			cssText: fmts.height ? 'height: ' + fmts.height : '',
                			emptyText: mstrmojo.desc(4325, 'Search') + ' ' + (defn.ttl || ''),
                			items: defn.srcid ? (data.ces ? data.ces.concat() : []) : [],   
                			REQUEST_THRESHOLD: 55, 
                			suggestCount: 50, 
                			srcid: defn.srcid || '',
                			dsrc: defn.dsrc || '',
                			onitemsChange: function () {
                				if (!selectorContainer._inSyncPhase) {
                					
                					selectorContainer.showInfoWin();
                					
                					selectorContainer.selectorControlChange(this);
                				}
                			}
                	};

                	if (elements && !defn.sos) { 
                		cfg.candidates = {
                				isComplete: true,
                				items:  defn.srcid ? elements : []
                		};
                	} else {
                		cfg.useKeyDelay = true;
                		cfg.noCache = true;
                	}

                	if (!defn.multi) {
                		
                		cfg.maxObjectCount = 1;
                	}
                }

                return cfg;
            },

            
            updateControlStyles: function updateControlStyles(selectorContainer) {
                
                if (selectorContainer.isInFilterPanel() && !selectorContainer.isHorizFP()) {
                    
                    var style = selectorContainer.style;
                    if (style === STYLES_SCROLLER || style === STYLES_METRIC_QUAL || STYLES_METRIC_SLIDER) {
                        
                        selectorContainer.children[0].width = selectorContainer.parent.parent.contentWidth;
                    }
                }
            }

        }
    );

    var factory = mstrmojo.DocSelectorViewFactory;

    
    factory.STYLES = {
        PULLDOWN: STYLES_PULLDOWN,
        SCROLLER: STYLES_SCROLLER,
        LIST: STYLES_LIST,
        RADIO: STYLES_RADIO,
        CHECKBOX: STYLES_CHECKBOX,
        BUTTON: STYLES_BUTTON,
        LINK: STYLES_LINK,
        METRIC_SLIDER: STYLES_METRIC_SLIDER,
        METRIC_QUAL: STYLES_METRIC_QUAL,
        SEARCH_BOX: STYLES_SEARCH_BOX

    };

    factory.ELEM_ALL = ALL_ID;

    factory.UC_ON_DS = _ST_UC_ON_DS;

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.AndroidXtab");

    
    mstrmojo.AndroidXtabStandalone = mstrmojo.declare(
        
        mstrmojo.AndroidXtab,

        null,

        
        {
            scriptClass: "mstrmojo.AndroidXtabStandalone"
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.AndroidXtab",
                         "mstrmojo._IsInteractiveGrid",
                         "mstrmojo._Formattable",
                         "mstrmojo._IsDocXtab");

    
    mstrmojo.DocInteractiveGridXtab = mstrmojo.declare(

        mstrmojo.AndroidXtab,


        [ mstrmojo._IsInteractiveGrid, mstrmojo._Formattable, mstrmojo._IsDocXtab ],

        
        {
            scriptClass: 'mstrmojo.DocInteractiveGridXtab',

            
            formatHandlers: {
                domNode: [ 'RW', 'T', 'font'],
                msgNode: [ 'D' ],
                viewport: [ 'D', 'B', 'fx' ]
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.AndroidXtab",
                        "mstrmojo._IsInteractiveGrid");

    
    mstrmojo.AndroidInteractiveGridXtab = mstrmojo.declare(

        mstrmojo.AndroidXtab,

        [ mstrmojo._IsInteractiveGrid ],

        
        {
            scriptClass: 'mstrmojo.AndroidInteractiveGridXtab'            
        }
    );
}());


(function () {
    mstrmojo.requiresCls("mstrmojo.maps.jsmap.AndroidDocMap",
                         "mstrmojo.maps.androidmap.AndroidDocMap");
    mstrmojo.maps.AndroidDocMap =  mstrmojo.declare(
            mstrmojo.Obj ,

            null,

            {
            	scriptClass: 'mstrmojo.maps.AndroidDocMap'
            }
    );
    if ((typeof(mstrMobileApp) != 'undefined') && (typeof(mstrMobileApp.useNativeMap) != 'undefined') && mstrMobileApp.useNativeMap()) {
		mstrmojo.maps.AndroidDocMap = mstrmojo.maps.androidmap.AndroidDocMap;
	} else {
		mstrmojo.maps.AndroidDocMap = mstrmojo.maps.jsmap.AndroidDocMap;
	}
}());


(function () {
    mstrmojo.requiresCls("mstrmojo.maps.jsmap.AndroidRptMap",
                         "mstrmojo.maps.androidmap.AndroidRptMap",
                         "mstrmojo.Obj");

    mstrmojo.maps.AndroidRptMap =  mstrmojo.declare(
            mstrmojo.Obj ,

            null,

            {
            	scriptClass: 'mstrmojo.maps.AndroidRptMap'
            }
    );
    
    if ((typeof(mstrMobileApp) != 'undefined') && (typeof(mstrMobileApp.useNativeMap) != 'undefined') && mstrMobileApp.useNativeMap()) {
		mstrmojo.maps.AndroidRptMap = mstrmojo.maps.androidmap.AndroidRptMap;
	} else {
		mstrmojo.maps.AndroidRptMap = mstrmojo.maps.jsmap.AndroidRptMap;
	}
})();
(function () {
    mstrmojo.requiresCls("mstrmojo.Vis", "mstrmojo.dom", "mstrmojo._TouchGestures", "mstrmojo.VisChartUtils",
        "mstrmojo._HasTouchScroller", "mstrmojo.color", "mstrmojo.css", "mstrmojo.VisMicroChartLine", "mstrmojo.VisMicroChartBar", "mstrmojo.VisMicroChartBullet", "mstrmojo._NeedSyncScroller");

    
    var DEFAULT_DARK_THEME = 1;
    var DEFAULT_LIGHT_THEME = 2;
    var CUSTOM_DARK_THEME = 3;
    var CUSTOM_LIGHT_THEME = 4;

    
    var ATTR_NAME = 0,
        METRIC_NAME = 1,
        METRIC_VALUE = 2,
        CHART = 3,
        TREE_TRIANGLE = 4,
        DROP_SHADOW = 5;

    var TRIANGLE_NONE = 0;
    var TRIANGLE_OPEN = 1;
    var TRIANGLE_CLOSE = 2;
    var TRIANGLE_CLOSE_STYLE = "width:0px;height:0px;border-left:10px solid black;border-top:5px solid transparent;border-bottom:5px solid transparent;margin-left:auto;margin-right:auto;-webkit-transform:scale(0.8,0.9)";
    var TRIANGLE_OPEN_STYLE = "width:0px;height:0px;border-left:5px solid transparent;border-top:10px solid black;border-right:5px solid transparent;margin-left:auto;margin-right:auto;-webkit-transform:scale(0.9,0.8)";

    var DOCKED_HEADER = 0,
        OTHER_ROW = 1;

    var zf = 1;

    var $CLR = mstrmojo.color,
        $CSS = mstrmojo.css;

    var MC_TABLE_TEXT = "microchart-table-text";

    var ROW_HEIGHT = 0;
    var ROW_HEIGHT_FOR_CHART = 0;

    function removeChildren(container) {
        container.innerHTML = '';
    }

    function setDHBackGroundColor() {
        var backgroundColor = this.backgroundColor;
        if (!backgroundColor) {
            return;
        }
        this.dockedHeaderTable.style.backgroundColor = backgroundColor;
        this.dockedHeaderTable.style.opacity = '1';
        this.dockedHeaderReplaceDiv.firstChild.style.backgroundColor = backgroundColor;
        this.dockedHeaderReplaceDiv.firstChild.style.opacity = '1';
    }

    
    
    function setNodeCssText(node, cssText) {
        var height = node.style.height;
        var width = node.style.width;
        var textDecoration = node.style.textDecoration;
        var display = node.style.display;
        var fontSize = node.style.fontSize;
        var paddingLeft = node.style.paddingLeft;
        var paddingRight = node.style.paddingRight;
        var boxShadow = node.style.boxShadow;
        node.style.cssText = cssText;
        node.style.height = height;
        node.style.width = width;
        node.style.textDecoration = textDecoration;
        if (display) {
            node.style.display = display;
        }
        if (fontSize) {
            node.style.fontSize = fontSize;
        }
        if (paddingLeft) {
            node.style.paddingLeft = paddingLeft;
        }
        if (paddingRight) {
            node.style.paddingRight = paddingRight;
        }
        if (boxShadow) {
            node.style.boxShadow = boxShadow;
        }

    }

    function setTreeTriangle(arrowDiv, treeNode, color) {
        var level = treeNode.level;

        var state = "";
        if (treeNode.isLeaf) {
            
            state = TRIANGLE_NONE;
        } else {
            if (treeNode.needExpand) {
                state = TRIANGLE_OPEN;
            } else {
                state = TRIANGLE_CLOSE;
            }
        }

        var whichBorderColor = null;
        var bodyFontColorRGB = this.bodyFontColorRGB;
        var theme = this.theme;

        if (state == TRIANGLE_CLOSE) {
            arrowDiv.className = "microchart-tree-arrow-close";
            whichBorderColor = "border-left-color";
        } else if (state == TRIANGLE_OPEN) {
            arrowDiv.className = "microchart-tree-arrow-open";
            whichBorderColor = "border-top-color";
        } else {
            
            arrowDiv.className = "";
            arrowDiv.setAttribute("style", "");
            return;
        }

        var styleContent = "";

        if (color) {
            
            styleContent = whichBorderColor + ':' + color;
        } else if (theme == DEFAULT_LIGHT_THEME) {
            if (level == 0) {
                
                styleContent = whichBorderColor + ':' + '#4c4c4c';
            } else if (level == 1) {
                
                styleContent = whichBorderColor + ':' + 'rgba(76,76,76,0.8)';
            } else if (level > 1) {
                styleContent = whichBorderColor + ':' + 'rgba(76,76,76,0.6)';
            }
        } else if (theme == DEFAULT_DARK_THEME) {
            if (level == 0) {
                
                styleContent = whichBorderColor + ':' + 'white';
            } else if (level == 1) {
                
                styleContent = whichBorderColor + ':' + "rgba(255,255,255,0.8)";
            } else if (level > 1) {
                styleContent = whichBorderColor + ':' + "rgba(255,255,255,0.6)";
            }

        } else if (bodyFontColorRGB && bodyFontColorRGB.length > 2 && (theme == CUSTOM_LIGHT_THEME || theme == CUSTOM_DARK_THEME)) {
            if (level == 0) {
                
                styleContent = whichBorderColor + ':' + 'rgba(' + bodyFontColorRGB[0] + ',' + bodyFontColorRGB[1] + ',' + bodyFontColorRGB[2] + ',0.8)';
            } else if (level > 0) {
                
                styleContent = whichBorderColor + ':' + 'rgba(' + bodyFontColorRGB[0] + ',' + bodyFontColorRGB[1] + ',' + bodyFontColorRGB[2] + ',0.7)';
            }

        }

        arrowDiv.setAttribute("style", styleContent);
    }

    function renderOneRow(rowIdx, dockedHeaderRowInfo) {
        var widget = this.widget,
            rowInfo = widget.rows[rowIdx],
            curM = rowInfo.model,
            elms = curM.elms,
            rowTmpl = this.rowTemplate,
            treeNode = rowInfo.treeNode,
            colInfos = this.colInfos,
            rowIdx = rowInfo.rowIdx,
            rowRef = null,
            colCount = colInfos.length;
        var bodyFontColorRGB = this.bodyFontColorRGB;

        var ths = this.headerTable.firstChild.firstChild.childNodes;

        rowRef = dockedHeaderRowInfo ? dockedHeaderRowInfo.rowRef : rowInfo.rowRef;

        var tr = null;
        var tds = null;
        if (rowRef[this.domRefName]) {
            
            tr = rowRef[this.domRefName];
        } else {
            
            tr = rowTmpl.cloneNode(true);
            rowRef[this.domRefName] = tr;
        }
        tr.style.display = '';

        fillThemeColor.call(this, dockedHeaderRowInfo ? dockedHeaderRowInfo : rowInfo);

        
        if (!this.isAndroidTab) {
            
            tr.style.fontSize = 14 * zf + "px";
        }

        tr.setAttribute("rowType", dockedHeaderRowInfo ? DOCKED_HEADER : OTHER_ROW);

        var tds = tr.childNodes;

        var attr = null;

        for (var j = 0, tdsIdx = 0; j < colCount; j++, tdsIdx++) {
            var colInfo = colInfos[j];
            var colIdx = colInfo.colIdx;

            tds[j].setAttribute("mrow", rowInfo.rowIdx);

            if (colIdx == this.treeColumnIdx && treeNode) {
                
                var arrowDiv = tds[j].firstChild;

                setTreeTriangle.call(this, arrowDiv, treeNode);

                if (!treeNode.isLeaf) {

                    arrowDiv.parentNode.setAttribute("CLK", "T");
                }
                continue;
            }

            
            if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_NAME) {
                if (this.isTreeMode) {
                    var attrName = "";
                    for (var k = 0; k < treeNode.es.length; k++) {
                        attrName += treeNode.es[k].n;
                    }
                    
                    if (attrName.indexOf("&lt;") >= 0) {
                        attrName = attrName.replace(/&lt;/g, "<");
                        attrName = attrName.replace(/&gt;/g, ">");
                    }

                    tds[j].innerHTML = attrName;

                    if (treeNode.level == 0) {
                        tds[j].style.fontWeight = 'bold';
                    } else {
                        tds[j].style.fontWeight = '';
                    }
                    if (treeNode.level > 0 && (this.theme == CUSTOM_DARK_THEME || this.theme == CUSTOM_LIGHT_THEME)) {
                        
                        
                        if (bodyFontColorRGB && bodyFontColorRGB.length > 2) {
                            tds[j].style.color = 'rgba(' + bodyFontColorRGB[0] + ',' + bodyFontColorRGB[1] + ',' + bodyFontColorRGB[2] + ',0.8)';
                        }
                    } else {

                    }
                } else {
                    attr = elms[colInfo.order];
                    var attrName = attr ? attr.n : "";
                    
                    if (attrName.indexOf("&lt;") >= 0) {
                        attrName = attrName.replace(/&lt;/g, "<");
                        attrName = attrName.replace(/&gt;/g, ">");
                    }
                    tds[j].innerHTML = attrName;

                }

                continue;
            }

            if (colInfo.order == "LineChart") {

                if (rowRef[colIdx]) {
                    var w = rowRef[colIdx];
                    if (curM.isTotal && !this.isTreeMode) {
                        w.domNode.style.display = 'none';
                    } else {
                        
                        w.domNode.style.display = '';
                        w.model = curM.model;
                        w.refv = curM.refv;
                        w.kpiOffset = this.kpiOff * rowIdx;
                        w.reDrawChart();
                        
                    }

                } else {
                    if (curM.isTotal && !this.isTreeMode) {
                        continue;
                    }
                    var placeholder = document.createElement("div");
                    var props = {
                        placeholder: placeholder,
                        model: curM.model,
                        refv: curM.refv,
                        config: widget.sparklineProps,
                        widget: widget,
                        kpiOffset: this.kpiOff * rowIdx,
                        width: colInfo.contentWidth,
                        height: ROW_HEIGHT_FOR_CHART,
                        toolTipMain: widget.tooltip,
                        mainOffsetTop: this.offsetTop,
                        mainLeftPos: parseInt(this.domNode.style.left, 0) || 0,
                        mainWidth: this.getWidth(),
                        isTreeMode: this.isTreeMode,
                        theme: this.theme
                    };
                    tds[j].appendChild(placeholder);
                    var w = new mstrmojo.VisMicroChartLine(props);
                    w.render();
                    tds[j].removeAttribute("class");
                    rowRef[colIdx] = w;
                }

            } else if (colInfo.order == "BarChart") {

                if (rowRef[colIdx]) {
                    var w = rowRef[colIdx];
                    if (curM.isTotal && !this.isTreeMode) {
                        w.domNode.style.display = 'none';
                    } else {
                        
                        w.model = curM.model;
                        w.refv = curM.refv;
                        w.kpiOffset = this.kpiOff * rowIdx;
                        w.isTextBold = this.isTreeMode ? treeNode.level == 0 : false;
                        w.reDrawChart();
                        
                    }
                } else {
                    if (curM.isTotal && !this.isTreeMode) {
                        continue;
                    }
                    var placeholder = document.createElement("div");
                    var props = {
                        placeholder: placeholder,
                        model: curM.model,
                        refv: curM.refv,
                        widget: widget,
                        kpiOffset: this.kpiOff * rowIdx,
                        config: widget.barProps,
                        width: colInfo.contentWidth,
                        height: ROW_HEIGHT_FOR_CHART,
                        toolTipMain: widget.tooltip,
                        mainOffsetTop: this.offsetTop,
                        mainLeftPos: parseInt(this.domNode.style.left, 0) || 0,
                        mainWidth: this.getWidth(),
                        isTreeMode: this.isTreeMode,
                        theme: this.theme,
                        isTextBold: this.isTreeMode ? treeNode.level == 0 : false
                    };

                    tds[j].appendChild(placeholder);
                    var w = new mstrmojo.VisMicroChartBar(props);
                    w.render();
                    
                    tds[j].className = this.valueCssClass;
                    rowRef[colIdx] = w;
                }

            } else if (colInfo.order == "GaugeChart") {
                
                if (rowRef[colIdx]) {
                    
                    var w = rowRef[colIdx];
                    w.model = curM.model;
                    w.refv = curM.refv;
                    w.kpiOffset = this.kpiOff * rowIdx;
                    w.labelColorRGB = this.bodyFontColorRGB;
                    w.reDrawChart();
                } else {
                    var placeholder = document.createElement("div");
                    var props = {
                        placeholder: placeholder,
                        model: curM.model,
                        refv: curM.refv,
                        widget: widget,
                        config: widget.bulletProps,
                        width: colInfo.contentWidth,
                        height: ROW_HEIGHT_FOR_CHART,
                        toolTipMain: widget.tooltip,
                        mainOffsetTop: this.offsetTop,
                        mainLeftPos: parseInt(this.domNode.style.left, 0) || 0,
                        mainWidth: this.getWidth(),
                        labelColorRGB: this.bodyFontColorRGB,
                        showMinLabel: this.showMinLabel,
                        isTreeMode: this.isTreeMode,
                        theme: this.theme

                    };
                    tds[j].appendChild(placeholder);
                    var w = new mstrmojo.VisMicroChartBullet(props);
                    w.render();
                    tds[j].removeAttribute("class");
                    rowRef[colIdx] = w;
                }

            } else {
                var metricIdx = -1;
                var idx = -1;

                if (this.widget.isKPI) {
                    
                    idx = parseInt(colInfo.order) % this.kpiOff;

                    
                    var metricIdx = rowInfo.model.metricIdx + idx;
                } else {
                    if (colInfo.type == METRIC_VALUE) {
                        metricIdx = parseInt(colInfo.order);
                        idx = metricIdx;
                    }
                }

                var innerHTML = "";
                var cssClass = "";

                if (!curM.refv[idx]) {
                    continue;
                }

                if (curM.refv[idx].ti === undefined) { 
                    if (curM.refv[idx].ts === 4) { 
                        innerHTML = "<img src='" + curM.refv[idx].v + "'/>";
                    } else {
                        innerHTML = curM.refv[idx].v;
                    }
                } else { 
                    try { 
                        
                        var model = this.widget.model;
                        var th = model.th['' + metricIdx];
                        var ti = curM.refv[idx].ti;

                        if (curM.refv[idx].ty === 4) { 
                            var path;
                            if (th[ti] && th[ti].n) {
                                path = th[ti].n;
                            } else {
                                path = curM.refv[idx].v;
                            }
                            if (path.indexOf(":") >= 0) { 
                                
                            } else { 
                                var baseURL;
                                try {
                                    baseURL = mstrApp.getConfiguration().getHostUrlByProject(mstrApp.getCurrentProjectId());
                                } catch (err) {
                                    baseURL = "";
                                }
                                path = baseURL + path;
                            }
                            innerHTML = "<img src='" + path + "'/>";
                        } else {
                            if (th[ti] && th[ti].n && th[ti].cni !== undefined) { 
                                innerHTML = th[ti].n;
                            } else {
                                innerHTML = curM.refv[idx].v;
                            }
                            tds[j].style.fontSize = this.widget.fontSize; 
                            
                        }
                        cssClass = model.css[th[ti].cni].n;
                    } catch (err) {
                        if (!innerHTML) { 
                            innerHTML = curM.refv[idx].v;
                        }
                    }
                }

                if (cssClass) {
                    tds[j].className = colInfo.valueCssClass + " " + cssClass;
                } else if (this.valueCssClass) {
                    tds[j].className = colInfo.valueCssClass + " " + this.valueCssClass;
                } else {
                    tds[j].className = colInfo.valueCssClass;
                }

                tds[j].innerHTML = innerHTML;
            }

            
            if (this.isTreeMode) {
                if (treeNode.level == 0) {
                    tds[j].style.fontWeight = 'bold';
                } else {
                    tds[j].style.fontWeight = '';
                }
            }
        }

        if (this.isTreeMode) {
            
            var preRowInfo = widget.rows[rowIdx - 1];
            var preRowExpanded = preRowInfo && preRowInfo.treeNode.level < rowInfo.treeNode.level;
            var isDockedHeader = dockedHeaderRowInfo != undefined;
            var isFirstRow = rowIdx == 0;

            if (preRowExpanded || ( isDockedHeader && treeNode.level > 0)) {
                
                var tdCount = tds.length;
                for (var i = 0; i < tdCount; i++) {
                    if (this.theme == DEFAULT_LIGHT_THEME || this.theme == CUSTOM_LIGHT_THEME) {
                        tds[i].style.boxShadow = '0px 5px 3px -3px rgba(0,0,0,0.2) inset';
                    } else if (this.theme == DEFAULT_DARK_THEME || this.theme == CUSTOM_DARK_THEME) {
                        tds[i].style.boxShadow = '0px 6px 3px -3px rgba(0,0,0,0.5) inset';
                    }

                }

                
                
                tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0)';

            } else if ((isDockedHeader && treeNode.level == 0 || isFirstRow) && (this.theme == DEFAULT_LIGHT_THEME || this.theme == DEFAULT_DARK_THEME)) {
                
                tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0)';
            } else {
                var tdCount = tds.length;
                for (var i = 0; i < tdCount; i++) {
                    tds[i].style.boxShadow = '';
                }
            }
        }

        var rowInfoToHighlight = dockedHeaderRowInfo ? dockedHeaderRowInfo : rowInfo;
        if (this.isTreeMode) {
            
            if (treeNode.selected) {
                this.widget.highlightRowByRowInfo(rowInfoToHighlight);
            } else {
                this.widget.unHighlightRowByRowInfo(rowInfoToHighlight);
            }

        } else {
            
            if (this.widget.isAllAttrSelectable) {
                if (rowInfo.selected[-1]) {
                    
                    this.widget.highlightRowByRowInfo(rowInfo);
                } else {
                    this.widget.unHighlightRowByRowInfo(rowInfo);
                }
            } else {
                
                this.widget.highlightCellsByRowInfo(rowInfo);
            }
        }

        return tr;
    }

    function fillThemeColor(rowInfo) {
        var tr = rowInfo.rowRef[this.domRefName];
        
        if (this.isTreeMode) {

            var treeNode = rowInfo.treeNode
            var level = treeNode.level;

            if (level == 0) {
                
                if (this.theme == DEFAULT_LIGHT_THEME) {

                    tr.style.backgroundColor = '#f9f9f9';
                    tr.style.color = '#191919';
                    
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.3)';

                } else if (this.theme == DEFAULT_DARK_THEME) {

                    tr.style.backgroundColor = '#333333';
                    tr.style.color = 'white';
                    
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.3)';

                } else if (this.theme == CUSTOM_DARK_THEME) {
                    tr.style.backgroundColor = '';

                    
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.3)';

                } else if (this.theme == CUSTOM_LIGHT_THEME) {
                    tr.style.backgroundColor = '';
                    
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.3)';

                }

                tr.style.font = 'bold 12pt Helvetica';

            } else if (level == 1) {
                
                if (this.theme == DEFAULT_LIGHT_THEME) {

                    tr.style.backgroundColor = '#e5e5e5';
                    tr.style.color = '#4c4c4c';
                    
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.2)';

                } else if (this.theme == DEFAULT_DARK_THEME) {

                    tr.style.backgroundColor = '#232323';
                    tr.style.color = '#cccccc';
                    
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.2)';

                } else if (this.theme == CUSTOM_DARK_THEME) {

                    tr.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                    
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.2)';

                } else if (this.theme == CUSTOM_LIGHT_THEME) {

                    tr.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
                    
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.2)';

                }

                tr.style.font = '12pt Helvetica';

            } else if (level == 2) {
                
                if (this.theme == DEFAULT_LIGHT_THEME) {

                    tr.style.backgroundColor = '#d1d1d1';
                    tr.style.color = '#333333';
                    
                    
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.1)';

                } else if (this.theme == DEFAULT_DARK_THEME) {

                    tr.style.backgroundColor = '#0F0F0F';
                    tr.style.color = '#cccccc';
                    
                    
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.1)';

                } else if (this.theme == CUSTOM_DARK_THEME) {

                    tr.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                    
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.1)';

                } else if (this.theme == CUSTOM_LIGHT_THEME) {

                    tr.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';
                    
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.1)';

                }
                tr.style.font = '12pt Helvetica';
            } else if (level > 2) {
                
                var opc = level > 9 ? 1 : level / 10;

                if (this.theme == DEFAULT_LIGHT_THEME) {

                    tr.style.backgroundColor = '#BDBDBD';
                    tr.style.color = '#333333';

                } else if (this.theme == DEFAULT_DARK_THEME) {

                    tr.style.backgroundColor = '#000000';
                    tr.style.color = '#cccccc';

                } else if (this.theme == CUSTOM_DARK_THEME) {

                    tr.style.backgroundColor = 'rgba(255, 255, 255, ' + opc + ')';

                } else if (this.theme == CUSTOM_LIGHT_THEME) {

                    tr.style.backgroundColor = 'rgba(0, 0, 0, ' + opc + ')';

                }

                tr.style.font = '12pt Helvetica';
                
                tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.1)';
            }

        } else {
            
            if (this.theme == DEFAULT_LIGHT_THEME) {
                tr.style.backgroundColor = '#f9f9f9';
                tr.style.font = '12pt Helvetica';
                tr.style.color = '#191919';
            } else if (this.theme == DEFAULT_DARK_THEME) {
                tr.style.backgroundColor = '#333333';
                tr.style.font = '12pt Helvetica';
                tr.style.color = 'white';
            }
        }
    }

    function setScrollerPosition(scrollTo) {
        var scl = this._scroller,
            icn = this.chartTable,
        
            offsetEnd = Math.max(this.chartTableOffsetHeight + this.headerTableOffsetHeight - this.getHeight(), 0);

        scl.origin = {
            x: scrollTo && scrollTo.x || 0,
            y: scrollTo && scrollTo.y || 0
        };

        scl.showScrollbars = this.showScrollbars;
        scl.vScroll = (offsetEnd !== 0 && scl.noVScroll !== true) || this.scrollPast;

        if (scl.vScroll) {

            scl.offset = {
                y: {
                    start: 0,
                    end: offsetEnd
                },
                scrollPast: this.scrollPast

            };
        }

        this.utils.translateCSS(-scl.origin.x, -scl.origin.y, false, icn);
    }

    mstrmojo.VisMicroChartTable = mstrmojo.declare(

        mstrmojo.Vis,

        
        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller, mstrmojo._NeedSyncScroller ],

        {
            scriptClass: 'mstrmojo.VisMicroChartTable',

            utils: mstrmojo.VisChartUtils,

            scrollerConfig: {
                bounces: false,
                showScrollbars: false,
                useTranslate3d: false,
                hScroll: false,
                vScroll: true
            },

            scrollPast: false,

            
            colInfos: null,

            rowTemplate: null,

            theme: -1,

            isTreeMode: false,

            showMinLabel: false,

            bodyFontColorRGB: null,

            markupString: '<div id="{@id}-microchart-table" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};z-index:{@zIndex};position:absolute;background-color:{@backgroundColor}">'
                +
                '<div id="{@id}-header-bar" class="microchart-header-div" style="width:{@width};">'
                + '<table id="{@id}-header-table" style="width:{@width};table-layout:fixed;">'
                + '<tr class="microchart-table-row" >'
                + '<th style="border:none;text-decoration:none;"></th>'
                + '</tr>'
                + '</table>'
                + '</div>'
                +
                '<div id="{@id}-chart-table-container" class="microchart-canvas-div" style="position:absolute;overflow:hidden;width:{@width};">'
                + '<table id="{@id}-charts-body" style="width:{@width};table-layout:fixed">'
                + '<tr class="microchart-table-row">'
                + '<td style="border:none;background:transparent;text-decoration:none;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-top:0px;padding-bottom:0px"></td>'
                + '</tr>'
                + '</table>'
                + '</div>'
                +
                '<div style="position:absolute;z-index:2;">'
                + '<table id="{@id}-docked-header" style="width:{@width};table-layout:fixed;position:relative;background-color:white;">'
                + '<tbody></tody>'
                + '</table>'
                + '<div id="{@id}-docked-header-replace-div" style="width:{@width};position:relative;overflow:hidden">'
                + '<table id="{@id}-docked-header-replace" style="width:{@width};table-layout:fixed;background-color:white;">'
                + '<tbody></tody>'
                + '</table>'
                + '</div>'
                + '</div>'
                +
                '</div>',

            markupSlots: {

                headerTable: function () {
                    return this.domNode.childNodes[0].firstChild;
                },

                itemsContainerNode: function () {
                    return this.domNode.childNodes[1];
                },

                chartTable: function () {
                    return this.domNode.childNodes[1].firstChild;
                },

                dockedHeaderTable: function () {
                    return this.domNode.childNodes[2].firstChild;
                },

                dockedHeaderReplaceDiv: function () {
                    return this.domNode.childNodes[2].lastChild;
                }
            },

            postBuildRendering: function postBR() {

                
                ROW_HEIGHT = (this.widget.otherProps.mRowHeight - 1) + 'px';
                ROW_HEIGHT_FOR_CHART = (this.widget.otherProps.mRowHeight - 2) + 'px';
                zf = this.utils.getScreenZoomFactor();
                this.scrollerConfig.scrollEl = this.chartTable;
                this.scrollerConfig.indicatorEl = this.widget.indicatorEl;
                this.scrollerConfig.showScrollbars = this.showScrollbars;
                this._super();
                this.renderMicroChart();
                this.updateRowOffsetHeight();
                this.updateHeaderTableOffsetH();
                this.updateChartTableOffsetH();
                setScrollerPosition.call(this, this.widget.mcStatus && this.widget.mcStatus.scrollTo);

                setDHBackGroundColor.call(this);

                
                
                var widget = this.widget;
                if (this._tn) {
                    var backup = this._tsCallback;
                    this._tsCallback = function (e) {
                        widget.closedIfwAttr = null;
                        backup.call(this, e);
                    };
                    mstrmojo.dom.detachEvent(this._tn, mstrmojo.dom.TOUCHSTART, backup);
                    mstrmojo.dom.attachEvent(this._tn, mstrmojo.dom.TOUCHSTART, this._tsCallback);
                }
            },

            renderMicroChart: function rmc() {

                var colLen = this.colInfos.length;

                var ht = this.headerTable;
                
                ht.style.font = 'bold 13pt Helvetica';
                if (this.theme == DEFAULT_LIGHT_THEME) {
                    ht.style.backgroundColor = '#B5BDC4';
                    ht.style.color = 'black';
                } else if (this.theme == DEFAULT_DARK_THEME) {
                    ht.style.backgroundColor = '#1C273A';
                    ht.style.color = 'white';
                }
                if (!this.isAndroidTab) {
                    
                    ht.style.height = zf * 32 + 'px';
                    ht.style.fontSize = 14 * zf + "px";
                }

                
                var htr = ht.firstChild.firstChild;

                
                var tbody = this.chartTable.firstChild;
                var rowTmpl = tbody.firstChild;

                var th0 = htr.firstChild;
                var td0 = rowTmpl.firstChild;
                
                for (var i = ht.childNodes.length; i < colLen; i++) {
                    htr.appendChild(th0.cloneNode(true));
                    rowTmpl.appendChild(td0.cloneNode(true));
                }
                this.rowTemplate = rowTmpl;

                var fnSD = function (e, width, noSetHeight) {
                    var paddingWidth = 0;

                    var compStyle = mstrmojo.css.getComputedStyle(e);
                    if (compStyle.paddingLeft) {
                        paddingWidth += parseFloat(compStyle.paddingLeft);
                    }
                    if (compStyle.paddingRight) {
                        paddingWidth += parseFloat(compStyle.paddingRight);
                    }

                    e.style.width = (width - paddingWidth) + 'px';

                    if (!noSetHeight) {
                        e.style.height = ROW_HEIGHT;
                    }

                };

                
                var ths = htr.childNodes;
                
                var tds = rowTmpl.childNodes;

                if (this.isTreeMode) {
                    
                    $CSS.removeClass(rowTmpl, "microchart-table-row");
                    $CSS.removeClass(htr, "microchart-table-row");
                }

                for (var i = 0; i < colLen; i++) {

                    var colInfo = this.colInfos[i];

                    ths[i].innerHTML = colInfo.title ? colInfo.title : '';

                    if (colInfo.padding.l != undefined) {
                        tds[i].style.paddingLeft = colInfo.padding.l + "px";
                    }
                    if (colInfo.padding.r != undefined) {
                        tds[i].style.paddingRight = colInfo.padding.r + "px";
                    }

                    ths[i].className = colInfo.headerCssClass;
                    if (this.treeColumnIdx == colInfo.colIdx) {
                        
                        var arrowDiv = document.createElement('div');
                        tds[i].appendChild(arrowDiv);
                        arrowDiv.style.display = "";
                    } else {
                        
                        tds[i].className = colInfo.valueCssClass + " " + this.valueCssClass;
                    }

                    if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_NAME) {
                        this.bodyFontColorRGB = this.valueCssClass && $CLR.rgbStr2rgb(mstrmojo.css.getStyleValue(tds[i], 'color'));
                    }

                    fnSD(ths[i], colInfo.colWidth);
                    fnSD(tds[i], colInfo.colWidth);

                    ths[i].style.wordBreak = "break-word";
                    ths[i].style.whiteSpace = "normal";

                    tds[i].setAttribute("mcol", colInfo.colIdx);
                    ths[i].setAttribute("mcol", colInfo.colIdx);
                    ths[i].setAttribute("mrow", -1);

                }

                for (var i = 0; i < colLen; i++) {
                    var colInfo = this.colInfos[i];
                    colInfo.titleOverflow = this.utils.truncateTextToLineWithWordWrap2(ths[i], this.textCanvas, 2);

                    if (colInfo.type == CHART) {
                        colInfo.contentWidth = tds[i].offsetWidth - colInfo.padding.l - colInfo.padding.r;
                    }

                }

                var otherProps = this.widget.otherProps;
                this.kpiOff = otherProps.mnMetricsPerKPI;
                if (!this.widget.isKPI) {
                    this.kpiOff = 0;
                }

                var w = this.widget;

                var fragment = document.createDocumentFragment();
                for (var i = w.startCnt; i < w.endCnt; i++) {
                    var newTR = renderOneRow.call(this, i);
                    fragment.appendChild(newTR);

                }
                tbody.appendChild(fragment);

                rowTmpl.style.display = "none";

                
                if (otherProps.mbHideColHeaders) {
                    this.headerTable.style.display = "none";
                }

                this.itemsContainerNode.style.top = this.headerTableOffsetHeight + 'px';
            },

            reRenderRows: function reRenderRows(scrollTo, firstRowRemain, lastRowRemain, firstRowToRender, lastRowToRender) {
                var tbody = this.chartTable.firstChild;
                tbody.innerHTML = "";
                var w = this.widget;

                var fragment = document.createDocumentFragment();

                if (firstRowRemain == undefined) {
                    firstRowRemain = 0;
                    lastRowRemain = 0;
                    firstRowToRender = w.startCnt;
                    lastRowToRender = w.endCnt;
                }

                var rows = w.rows;
                if (firstRowRemain < firstRowToRender) {
                    for (var i = firstRowRemain; i < lastRowRemain; i++) {
                        var newTR = rows[i].rowRef[this.domRefName];
                        fragment.appendChild(newTR);
                    }

                    for (var i = firstRowToRender; i < lastRowToRender; i++) {
                        var newTR = renderOneRow.call(this, i);
                        fragment.appendChild(newTR);

                    }
                } else {
                    for (var i = firstRowToRender; i < lastRowToRender; i++) {
                        var newTR = renderOneRow.call(this, i);
                        fragment.appendChild(newTR);

                    }
                    for (var i = firstRowRemain; i < lastRowRemain; i++) {
                        var newTR = rows[i].rowRef[this.domRefName];
                        fragment.appendChild(newTR);
                    }
                }

                tbody.appendChild(fragment);

                this.updateChartTableOffsetH();
                setScrollerPosition.call(this, scrollTo);
            },

            updateHeaderTableOffsetH: function updateHeaderTableOffsetH() {
                if (this.widget.otherProps.mbHideColHeaders) {
                    this.headerTableOffsetHeight = 0;
                } else {
                    this.headerTableOffsetHeight = this.headerTable.offsetHeight;
                }
            },

            updateRowOffsetHeight: function updateRowOffsetHeight() {
                this.rowOffsetHeight = this.chartTable.firstChild.lastChild.offsetHeight;

            },

            updateChartTableOffsetH: function updateChartTableOffsetH() {
                this.chartTableOffsetHeight = this.chartTable.firstChild.offsetHeight;
            },

            onScrollDone: function onScrollDone(evt) {
                if (this._super) {
                    this._super(evt);
                }
                this.widget.onScrollDone(evt);
            },

            onScrollMoved: function onScrollMoved(evt) {
                if (this._super) {
                    this._super(evt);
                }
                this.widget.onScrollMoved(evt);
            },

            initScroller: function initScroller(scroller) {

                if (!scroller.offset && this.scrollPast) {
                    scroller.offset = {scrollPast: this.scrollPast};
                }

                scroller.vScroll = true;

                if (this._super) {
                    this._super(scroller);
                }

                var me = this;
            },

            initDHs: function initDHs() {
                var dockedHeaderTable = this.dockedHeaderTable;
                dockedHeaderTable.parentNode.style.top = this.headerTableOffsetHeight + 'px';
            },

            
            addRowsToDH: function addRowsToDH(rowCount, toDHReplacingTable) {
                var w = this.widget;
                var rows = null;
                if (toDHReplacingTable) {
                    rows = w.dockedHeaderReplaceRows;
                } else {
                    rows = w.dockedHeaderRows;
                }

                var fragment = document.createDocumentFragment();
                for (var i = rows.length - rowCount; i < rows.length; i++) {
                    var newTR = renderOneRow.call(this, rows[i].rowIdx, rows[i]);
                    rows[i].rowRef[this.domRefName] = newTR;
                    fragment.appendChild(newTR);
                }
                if (toDHReplacingTable) {
                    this.dockedHeaderReplaceDiv.firstChild.firstChild.appendChild(fragment);
                } else {
                    this.dockedHeaderTable.firstChild.appendChild(fragment);
                }

            },

            removeRowsFromDH: function removeRowsFromDH(rowCount, moveToReplacingTable) {
                var dockedHeaderTable = this.dockedHeaderTable,
                    dockedHeaderTbody = dockedHeaderTable.firstChild;
                var dockedHeaderReplaceTbody = this.dockedHeaderReplaceDiv.firstChild.firstChild;

                if (rowCount > dockedHeaderTbody.childNodes.length) {
                    
                    rowCount = dockedHeaderTbody.childNodes.length;
                }

                if (rowCount > 1) {
                    
                    dockedHeaderTable.removeChild(dockedHeaderTbody);
                    for (var i = 0; i < rowCount; i++) {
                        dockedHeaderTbody.removeChild(dockedHeaderTbody.lastChild);
                    }
                    dockedHeaderTable.appendChild(dockedHeaderTbody);

                } else if (rowCount == 1) {
                    var dockedHeaderTR = dockedHeaderTbody.lastChild;
                    dockedHeaderTbody.removeChild(dockedHeaderTR);
                    if (moveToReplacingTable) {
                        dockedHeaderReplaceTbody.appendChild(dockedHeaderTR);
                    }

                }
            },

            moveRowFromDHRplcTableToDH: function moveRowFromDHRplcTableToDH() {
                var dockedHeaderTable = this.dockedHeaderTable,
                    dockedHeaderTbody = dockedHeaderTable.firstChild;
                var dockedHeaderReplaceTbody = this.dockedHeaderReplaceDiv.firstChild.firstChild;

                var replacingTR = dockedHeaderReplaceTbody.firstChild;
                if (replacingTR) {
                    removeChildren(dockedHeaderReplaceTbody);
                    dockedHeaderTbody.appendChild(replacingTR);
                }

            },

            removeChildrenForDHReplaceTable: function removeChildrenForDHReplaceTable() {
                var dockedHeaderReplaceTbody = this.dockedHeaderReplaceDiv.firstChild.firstChild;

                removeChildren(dockedHeaderReplaceTbody);
            },

            showDockedHeader: function showDockedHeader() {
                this.dockedHeaderTable.parentNode.style.display = 'block';
            },

            hideDockedHeader: function hideDockedHeader() {
                this.dockedHeaderTable.parentNode.style.display = 'none';
            },

            setTreeArrow: function setTreeArrow(rowInfo, color) {
                var tr = rowInfo.rowRef[this.domRefName];
                var tds = tr.childNodes;
                var arrowDiv = tds[this.treeColumnIdx].firstChild;
                setTreeTriangle.call(this, arrowDiv, rowInfo.treeNode, color);
            },

            scrollTo: function (origin) {
                var icn = this.chartTable;
                this.utils.translateCSS(-origin.x, -origin.y, false, icn);
            },

            shouldTouchBubble: function shouldTouchBubble(touch) {
                var scroller = this._scroller,
                    isVertical = touch.isVertical;

                var vScrollable = !!scroller.offset && scroller.offset['y'].end !== 0;

                return isVertical ? !vScrollable : this._super(touch);
            },

            multiTap: true,

            touchTap: function (touch) {
                this.widget.touchTap(touch);
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                this.bubbleTouchEvent(touch);
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                this.bubbleTouchEvent(touch);
            },

            touchSelectMove: function touchSelectMove(touch) {
                this.bubbleTouchEvent(touch);
            },

            multiTouch: true,

            touchMultiBegin: function (touch) {
                this.bubbleTouchEvent(touch);
            },

            touchMultiMove: function (touch) {
                this.bubbleTouchEvent(touch);
            },

            touchMultiEnd: function (touch) {
                this.bubbleTouchEvent(touch);
            },

            destroy: function destroy() {
                delete this.widget;
                delete this.parent;
                delete this.rowTemplate;

                this._super();
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.VisChartLine", "mstrmojo.EnumRWUnitType",
        "mstrmojo.VisTooltip",
        
        "mstrmojo.dom", "mstrmojo._TouchGestures", "mstrmojo.TouchScroller", "mstrmojo._HasTouchScroller", "mstrmojo.css", "mstrmojo.color",
        "mstrmojo.VisTimeSeriesLegend", "mstrmojo.VisTimeSeriesTimeSelector");

    mstrmojo.requiresDescs(5674, 8475, 8626);

    
    var $CSS = mstrmojo.css,
        $CLR = mstrmojo.color;

    var DRILLING_ACTION = 1,
        SELECTOR_ACTION = 2,
        HYPERLINK_ACTION = 4;
    var ROW_AXIS = 1,
        COL_AXIS = 2;
    var chartStatus = {},
        widgetCount = 0,
        tooltipShown = false,
        itemClicked = false,
        isDataSetChanged = false,
        chartSizeChanged = false,
        originalTouchPosition = 0,
        masterSliderClicked = null,
    
        rangeToSeriesMaxRatio = 5;

    var MCHW = 20; 
    var MCHH = 20; 
    var MAXPOINTS_PER_DRAW = 80; 
    
    var SWidthChanged = false;

    var masterMargin = {
        t: 5,
        r: MCHW / 2,
        b: 5,
        l: MCHW / 2
    }; 

    
    var PADDING = 10,
        TOP_PADDING = 8;

    var canvasReseted = false;

    var $_DT = mstrmojo.locales.datetime;

    
    function resetLocalVars() {
        tooltipShown = false;
        itemClicked = false;
        isDataSetChanged = false;
        chartSizeChanged = false;
        originalTouchPosition = 0;
        masterSliderClicked = null;
    }

    function getParentBkgColor() {
        var parentNode = this.domNode.parentNode;
        while (parentNode) {
            var compStyle = mstrmojo.css.getComputedStyle(parentNode);
            var bkgColor = compStyle.backgroundColor;
            if (bkgColor) {
                if (bkgColor.indexOf('rgba') >= 0) {
                    var rgba = this.utils.rgbaStr2rgba(bkgColor);
                    if (rgba && rgba[4]) {
                        return rgba;
                    }
                } else if (bkgColor.indexOf('rgb') >= 0) {
                    var rgb = $CLR.rgbStr2rgb(bkgColor);
                    return rgb;
                }

            }
            parentNode = parentNode.parentNode;
        }

        
        return [255, 255, 255];
    }

    var LIGHT_THEME = 0;
    var DARK_THEME = 1;

    function getUITheme() {
        var utils = this.utils;

        
        

        var rgb = getParentBkgColor.call(this);

        var opacity = this.formatProp.backgroundAlpha;

        rgb = utils.getRGBWithOpacity(rgb, opacity, this.formatProp.backgroundClr);

        var brightness = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
        if (brightness > 150) {
            this.theme = LIGHT_THEME;
        } else {
            this.theme = DARK_THEME;
        }

    }

    
    function addChartStatus(id) {
        chartStatus[id] = {isLegendBarOpen: false,
            legendBarWidth: 30,
            isLegendSelected: false,
            legendSelectedIndex: -1,
            timeSelectedIntervalPosition: {},
            currSelectionIdx: -1,
            usingCustomInterval: false};
    }

    
    function isScrollableElementTouched(touch) {

        
        var me = this,
            m = me.margin,
            chartWidth = me.getChartWidthOnScreen();

        var touchPointOnWidget = me.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, me);

        var x = touchPointOnWidget.touchX,
            y = touchPointOnWidget.touchY;

        if (x < m.l || x > (chartWidth + m.l) || y < m.t || y > this.canvas.height - m.b) {
            return false;
        }
        return true;
    }

    function isTouchedOnWidget(touch) {

        if (!touch) {
            return false;
        }
        var me = this;

        var touchPointOnWidget = me.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, me);

        var x = touchPointOnWidget.touchX,
            y = touchPointOnWidget.touchY;

        if ((x > 0 && x < me.getWidth()) && (y > 0 && y < me.getHeight())) {
            return true;
        }
        return false;
    }

    function getTouchedElement(touch) {
        var item = mstrmojo.dom.findAncestorByAttr(touch.target, "clk", true, this.domNode);
        return item || null;
    }

    
    function getMinYPosition(lines) {
        var l = lines.length;
        var i = 0, min;
        while (i < l) {
            if (lines[i]) {
                min = lines[i].y;
                break;
            }
            i++;
        }
        for (i = 0; i < l; i++) {
            if (lines[i]) {
                min = Math.min(min, lines[i].y);
            }
        }
        return min;
    }

    function resetBaseAndDerivedData(tsl) {
        var obm = this.baseModel;
        var currStatus = chartStatus[this.chartID];
        this.baseModel = this.getModel(tsl.ds) || this.baseModel;
        var bm = this.baseModel;

        this.checkData(bm);
        
        var err = bm.err || bm.eg;

        if (err) {
            this.renderErrorMessage(err);
            return false;
        }

        var bms = bm.series,
            m = this.model,
            cs = m.series,
        
        
            sl = bms.length,
            s = [],
            j = 0;

        for (j = 0; j < sl; j++) {
            s[j] = bms[j];
            
        }
        this.model.categories = bm.categories;
        this.model.series = s;
        this.model.colHeaders = bm.colHeaders;

        var currWindowSize = this.model.series[0].rv.length;
        if (this.windowSize !== currWindowSize) {
            
            currStatus.rns = 0;
            currStatus.rne = currWindowSize;
        }
        this.windowSize = currWindowSize;

        
        if (!bm.vp || !bm.vp.rl || bm.vp.rl.length < obm.vp.rl.length) {
            bm.vp = obm.vp;
        }
        isDataSetChanged = true;
        return true;
    }

    
    function localUpdateScrollerConfig() {
        var scl = this._scroller,
            m = this.model,
            margin = this.margin,
            currStatus = chartStatus[this.chartID],
            animationCanvas = this.animationCanvas,
            chartWidth = this.getChartWidthOnScreen(),
            offsetEnd = Math.max(this.acContentWidth - chartWidth, 0);
        var rns = (currStatus.rns !== 0 && currStatus.rns + 1 === currStatus.rne) ? currStatus.rns - 1 : currStatus.rns; 
        
        scl.origin = {
            x: parseInt(((rns - this.ACrns) * this.RTX), 10),
            y: 0
        };

        
        scl.hScroll = (offsetEnd !== 0 && scl.noHScroll !== true) || this.scrollPast;

        if (scl.hScroll) {
            
            scl.offset = {
                x: {
                    start: 0,
                    end: offsetEnd
                },
                scrollPast: this.scrollPast

            };
        }
        
        
        this.utils.translateCSS(-(scl.origin.x), scl.origin.y, false, this.animationCanvasDiv);
        this.utils.translateCSS(-(scl.origin.x) + this.maxYLblWidth, scl.origin.y, false, this.xLabelsDiv);

    }

    
    function getCurrencySymbolForMetric(m) {
        var s = m.series,
            ch = m.colHeaders,
            chl = ch[0].items.length;

        
        var hi0 = s[0].hi,
            fInfo = ch[ch.length - 1].items[hi0[hi0.length - 1]],
            f = fInfo.f;
        var cs = (fInfo && f && f.indexOf(fInfo.cs) >= 0) ? "," + fInfo.cs : "";

        if (cs === "" && f) {
            cs = f.indexOf("%") >= 0 ? ",%" : "";
        }

        if (cs === "" && f) {
            var q = null;
            if (f.indexOf('\'') >= 0) {
                q = '\'';
            } else if (f.indexOf("\"") >= 0) {
                q = "\"";
            }
            if (q) {
                var temp = f.substring(f.indexOf(q) + 1);
                cs = "," + temp.substring(0, temp.indexOf(q));
            }
        }

        return cs;
    }

    function hideMasterSliderTooltip() {
        var ms = this.masterSlider,
            stt = this.sliderTooltip,
            sttF = stt.firstChild,
            sttP = stt.lastChild,
            fc = ms.firstChild,
            lc = ms.lastChild;

        
        $CSS.removeClass(fc, 'mstrmojo-timeseries-span-shadow');
        $CSS.removeClass(lc, 'mstrmojo-timeseries-span-shadow');

        
        sttF.innerHTML = '';
        sttF.style.display = 'none';
        sttP.style.display = 'none';
    }

    
    function resizeMasterSliderDone() {
        var me = this,
            currStatus = chartStatus[this.chartID];

        
        if (currStatus.usingCustomInterval && me.currSelection) {
            me._timeSelector.toggleSelected(me.currSelection, false);
            me._timeSelector.toggleGlowEffect(me.currSelection, false);

            this.updateIntervalPosition();
            me.currSelection = null;
            currStatus.currSelectionIdx = -1;
        }
        if (chartSizeChanged && masterSliderClicked !== 'MS') {
            me.showMessage(); 

            this.makeSureMasterSliderNotBeyondTheMargin();
            this.makeSureSliderOnPoint();
            this.makeSureSelectedIntervalMoreThanTwo();
            this.makeSureMasterSliderNoOverlap();
            this.setMasterSliderLayout();
            window.setTimeout(function () {
                me.reDrawSlaveChart();
            }, 10);

        } else {
            
            masterSliderClicked = null;
        }
        
        hideMasterSliderTooltip.call(this);
    }

    function getFormattedDateForSliderTooltip(sliderTooltipXPosition) {
        var me = this,
            cat = me.model.categories,
            tp = cat.tp;

        var pos = Math.round((sliderTooltipXPosition - masterMargin.l) / me.MRTX),
            rVal = cat.items[pos];

        if (tp.toString() === me.DSS_XML_BASE_FORM_DATE) {
            rVal = me.getFormattedDateForTooltip(rVal, true);
        }

        return rVal;
    }

    function getPointDistanceSquare(p1, p2) {
        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
    }

    function getACRnsRne(rns, rne) {
        var me = this,
            currStatus = chartStatus[me.chartID],
            model = me.model,
            windowSize = me.windowSize,
            needRedraw = true,
            ACrns,
            ACrne;

        if ((!rns && rns !== 0) || !rne) {
            rns = currStatus.rns;
            rne = currStatus.rne;
        }

        var diff = rne - rns;

        model.currentRatio = Math.round(windowSize / ((diff - 1) || 1));
        if (model.currentRatio > rangeToSeriesMaxRatio) {
            var ACRation = (rangeToSeriesMaxRatio - 1) / 2;
            
            ACrns = Math.max(0, rns - ACRation * (diff - 1));
            ACrne = Math.min(windowSize, rne + ACRation * (diff - 1));
            if (ACrns === 0) {
                ACrne = rangeToSeriesMaxRatio * (diff - 1) + 1;
            } else if (ACrne === windowSize) {
                ACrns = ACrne - rangeToSeriesMaxRatio * (diff - 1) - 1;
            }
        } else {
            ACrns = 0;
            ACrne = windowSize;
            var ACdiff = ACrne - ACrns;
        }
        if (me.ACrns === ACrns && me.ACrne === ACrne) {
            needRedraw = false;
        } else {
            me.ACrns = ACrns;
            me.ACrne = ACrne;
        }

        return needRedraw;
    }

    function removeChildren(container) {
        var count = container && container.childNodes && container.childNodes.length,
            i;
        for (i = 0; i < count; ++i) {
            container.removeChild(container.firstChild);
        }

    }

    function removeLegendAndTimeSelectorChildren() {
        
        
        
        if (this._legend) {
            this._legend.destroy();
        }

        
        
        
        if (this._timeSelector) {
            this._timeSelector.destroy();
        }
    }

    
    mstrmojo.VisTimeSeries = mstrmojo.declare(

        
        mstrmojo.VisChartLine,

        
        [mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

        {
            
            scriptClass: 'mstrmojo.VisTimeSeries',

            
            isLinearChart: true,

            
            highlightColor: '#ffffff',

            chartLineColors: ['#16b0ff', '#ff3729', '#04ba22', '#ff960e',
                '#ae79de', '#cccd25', '#19cee0', '#a9a9a9',
                '#b3cdef', '#ffa796', '#98df8a', '#ffbf80',
                '#dac3ec', '#dac3ec', '#a1dfea', '#d6d6d6'],

            
            switchSeriesOnTouch: false,

            
            multiTouch: true,

            
            margin: {
                t: 70,
                r: 1,
                b: 50,
                l: 5
            },

            SLXP: 0,
            
            SRXP: 0,
            

            
            isTimeSeries: true,

            
            maxXLabels: 4,

            
            scrollerConfig: {
                bounces: false,
                showScrollbars: false,
                useTranslate3d: true
            },
            
            scrollPast: true,
            
            isAndroidTab: false,

            
            masterContext: null,

            
            selectionOrLinkdrillOnRow: false,

            
            lastSelectedPoint: null,

            
            markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};left:{@left};top:{@top};z-index:{@zIndex};position:absolute;-webkit-transition: 0ms; transition: 0ms; -webkit-transform: translate3d(0px, 0px, 0px);" ' +
                ' mstrAttach:mousedown,mouseup,mousemove,click >' +
                '<canvas width="{@width}" height="{@slaveChartHeight}"></canvas>' +
                '<div style="overflow:hidden;position:absolute;left:0px;top:0px;">' +
                '<div id="{@id}-animation-canvas-div" class="mstrmojo-timeseries-animation-canvas" style="position:absolute;left:0px;top:0px;width:{@width};height:{@slaveChartHeight+"px"};">' +
                '<canvas style="position:absolute;left:0px;top:0px;" width="{@width}" height="{@slaveChartHeight}"></canvas>' +
                '</div>' +
                '</div>' +
                '<div style="overflow:hidden;position:absolute;left:0px;top:0px;">' +
                '<div id="{@id}-x-labels-div" class="mstrmojo-timeseries-animation-canvas" style="position:absolute;left:0px;top:0px;width:{@width};height={@slaveChartHeight+"px"}">' +
                '</div>' +
                '</div>' +
                '<canvas id="{@id}-highlight-canvas" style="position:absolute;left:0px;top:0px;" width="{@width}" height="{@slaveChartHeight}"></canvas>' +
                '<div id="{@id}-tooltip"></div>' +
                '<div id="{@id}-time-selector-div"></div>' +
                '<div id="{@id}-legend-bar-div" ></div>' +
                '<div id="{@id}-loading-msg" class="mstrmojo-loading-msg" style="display:none"></div>' +
                '<canvas id="{@id}-master-canvas" style=" position:absolute;left:0px;bottom:0px;" width="{@width}" height="{@masterChartHeight}"></canvas>' +
                '<div id="{@id}-master-div" class="mstrmojo-master-parent-div" width="{@width}" style="position:absolute;bottom:5px" >' +
                '<div id="{@id}-master-cover-span" style="position:absolute;left:0px;" class="mstrmojo-master-cover-span"></div>' +
                '<div id="{@id}-master-slider" class="mstrmojo-master-slider-div" clk="MS">' +
                '<canvas id="{@id}-master-img-L" width="20" height="20" style="position:absolute;left:0px" class="mstrmojo-timeseries-master-span" clk="L" ></canvas>' +
                '<canvas id="{@id}-master-slider" width="{@width}" height="{@masterChartHeight}" style="top:0px;left:0px" class="mstrmojo-master-slider-div-top"></canvas>' +
                '<canvas id="{@id}-master-img-R" width="20" height="20" style="position:absolute;right:0px" class="mstrmojo-timeseries-master-span" clk="R" ></canvas>' +
                '</div>' +
                '<div id="{@id}-master-cover-span" style="position:absolute;right:0px;" class="mstrmojo-master-cover-span"></div>' +
                '</div>' +
                '<div id="{@id}-slider-tooltip" style="position:absolute;left:0;top:0;z-index:150;width:{@width};">' +
                '<div class="timeseries-slider-tooltip"></div>' +
                '<canvas style="position:absolute;left:0px;top:20px;display: none;" width="6px" height="5px"></canvas>' +
                '</div>' +
                '<div id="{@id}-legend-tooltip" class="mstrmojo-Chart-tooltip timeseries-legend-tooltip"></div>' +
                '<span id="textSpan" style="z-index:-10;visibility:hidden;"></span>' +
                '<div id="{@id}-infowindow-anchor" style="position:absolute;width:18px;height:18px;display:block"></div>' +
                '<div id="{@id}-errMsg" class="mstrmojo-message" style="width:{@width};height:{@height};top:0px;left:0px;position:absolute;display:none; z-index:20;"></div>' +
                '</div>',
            
            markupSlots: {
                
                canvas: function () {
                    return this.domNode.firstChild;
                },

                
                animationCanvasDiv: function () {
                    return this.domNode.childNodes[1].firstChild;
                },

                
                animationCanvas: function () {
                    return this.domNode.childNodes[1].firstChild.firstChild;
                },

                
                itemsContainerNode: function () {
                    return this.domNode.childNodes[1];
                },

                
                xLabelsDiv: function () {
                    return this.domNode.childNodes[2].firstChild;
                },

                
                xLabelsDivContainer: function () {
                    return this.domNode.childNodes[2];
                },

                
                highlightCanvas: function () {
                    return this.domNode.childNodes[3];
                },

                
                tooltip: function () {
                    return this.domNode.childNodes[4];
                },

                timeSelectorDiv: function () {
                    return this.domNode.childNodes[5];
                },

                
                legendBarDiv: function () {
                    return this.domNode.childNodes[6];
                },

                loadingMsg: function () {
                    return this.domNode.childNodes[7];
                },

                masterCanvas: function () {
                    return this.domNode.childNodes[8];
                },

                masterSlider: function () {
                    return this.domNode.childNodes[9].childNodes[1];
                },

                sliderTooltip: function () {
                    return this.domNode.childNodes[10];
                },

                legendTooltip: function () {
                    return this.domNode.childNodes[11];
                },

                textSpan: function () {
                    return this.domNode.childNodes[12];
                },

                infoWindowAnchor: function () {
                    return this.domNode.childNodes[13];
                },

                errorMsg: function () {
                    return this.domNode.childNodes[14];
                }
            },

            
            getTextWidth: function gtw(str, fontStyle, zf) {
                this.textSpan.style.font = fontStyle;
                this.textSpan.innerHTML = str;
                if (zf) {
                    this.utils.changeElementSize(this.textSpan, 'font', zf);
                }
                var ret = this.textSpan.offsetWidth;

                return ret;
            },

            
            getTextWidthByElem: function gtwCvs(text, elem) {

                var computedStyle = mstrmojo.css.getComputedStyle(elem);
                var fontStyle = computedStyle.fontStyle + " "
                    + computedStyle.fontWeight + " "
                    + computedStyle.fontSize + "/"
                    + computedStyle.fontVariant
                    + " " + computedStyle.fontFamily;

                return this.getTextWidth(text, fontStyle);
            },

            
            getTextHeight: function gtw(str, fontStyle, zf) {
                this.textSpan.style.font = fontStyle;
                this.textSpan.innerHTML = str;
                if (zf) {
                    this.utils.changeElementSize(this.textSpan, 'font', zf);
                }
                var ret = this.textSpan.offsetHeight;

                return ret;
            },

            getMaxTextWidth: function (textArray, fontStyle) {
                var me = this,
                    l = textArray.length,
                    maxWidth = 0,
                    currWidth = 0,
                    i;
                for (i = 1; i < l; i++) {
                    currWidth = me.getTextWidth(textArray[i], fontStyle);
                    maxWidth = currWidth > maxWidth ? currWidth : maxWidth;
                }

                return maxWidth;
            },

            
            getChartWidthOnScreen: function getChartWidthOnScreen() {
                var m = this.margin;
                return this.getWidth() - m.r - m.l - chartStatus[this.chartID].legendBarWidth;
            },

            
            drawChartXYAxis: function drawChartXYAxis() {
                var utils = this.utils,
                    m = this.margin,
                    w = this.getWidth() - chartStatus[this.chartID].legendBarWidth,
                    h = this.canvas.height,
                    c = this.context;

                c.save();

                
                c.strokeStyle = utils.rgb2rgbStr(this.formatProp.textClr);
                c.lineWidth = 1;
                c.globalAlpha = 0.8;

                
                var xPos = Math.floor(m.l) - 0.5;
                utils.drawLineSet(this, [
                    {
                        x: xPos,
                        y: m.t
                    },
                    {
                        x: xPos,
                        y: h - m.b
                    }
                ], false, c);
                
                var yPos = Math.floor(h - m.b) + 0.5;
                utils.drawLineSet(this, [
                    {
                        x: m.l - this.maxYLblWidth,
                        y: yPos
                    },
                    {
                        x: w - m.r,
                        y: yPos
                    }
                ], false, c);

                c.restore();

            },

            
            setMasterSlider: function setMasterSlider() {
                var width = this.getWidth(),
                    h = this.masterCanvas.height - masterMargin.t - masterMargin.b,
                    utils = this.utils,
                    msl = this.masterSlider,
                    msStyle = msl.style,
                    mslp = msl.parentNode,
                
                    lcStyle = mslp.firstChild.style,
                
                    rcStyle = mslp.childNodes[2].style,
                    m = this.model,
                    mrtx = this.MRTX,
                    currStatus = chartStatus[this.chartID];

                
                mslp.style.display = 'block';
                mslp.style.height = h + 'px';
                mslp.style.width = width + 'px';
                

                msStyle.height = h + 'px';

                
                lcStyle.height = h - 2 + 'px';
                rcStyle.height = h - 2 + 'px';
                lcStyle.backgroundColor = rcStyle.backgroundColor = utils.rgb2rgbStr(this.formatProp.backgroundClr, this.formatProp.backgroundAlpha * 0.5);

                
                this.drawMasterChartHandler(msl.firstChild, MCHW, MCHH, true);
                
                this.drawMasterChartHandler(msl.lastChild, MCHW, MCHH, false);
                
                msl.firstChild.style.marginTop = msl.lastChild.style.marginTop = Math.round((h - MCHH) / 2) + 'px';

                
                this.calculateSXP(currStatus.rns, currStatus.rne, true);
                this.makeSureMasterSliderNotBeyondTheMargin();
                this.makeSureMasterSliderNoOverlap();
                this.setMasterSliderLayout();
            },

            drawMasterChartHandler: function drwMCH(canvas, w, h, isLeft) {
                var utils = this.utils,
                    ctx = canvas.getContext('2d');

                
                canvas.width = w;
                canvas.height = h;

                ctx.save();
                
                ctx.fillStyle = utils.rgb2rgbStr(this.formatProp.backgroundClr, 0.76);
                utils.drawRoundRect(ctx, 0.5, 0.5, w - 1, h - 1, 1, true);
                
                ctx.strokeStyle = utils.rgb2rgbStr(this.formatProp.textClr);
                ctx.lineWidth = 1;
                utils.drawRoundRect(ctx, 0.5, 0.5, w - 1, h - 1, 1);
                
                ctx.beginPath();
                ctx.lineWidth = 2;
                if (isLeft) {
                    ctx.moveTo(11, 6);
                    ctx.lineTo(7, 10);
                    ctx.lineTo(11, 14);
                } else {
                    ctx.moveTo(9, 6);
                    ctx.lineTo(13, 10);
                    ctx.lineTo(9, 14);
                }
                ctx.stroke();

                ctx.restore();
            },

            drawMasterChartDiv: function drwMCD(x, w) {
                var canvas = this.masterSlider.childNodes[1],
                    width = this.SRXP - this.SLXP + MCHW;

                
                if (canvas.width == width) {
                    
                } else {
                    var margin = masterMargin,
                        mcHeight = this.masterChartHeight,
                        divHeight = mcHeight - margin.t - margin.b,
                        h = (divHeight - MCHH) / 2;

                    
                    canvas.height = divHeight
                    canvas.width = width;

                    var ctx = canvas.getContext('2d');
                    ctx.save();
                    ctx.strokeStyle = this.utils.rgb2rgbStr(this.formatProp.textClr);
                    ctx.lineWidth = 1;
                    ctx.beginPath();

                    var leftX = 0.5 + MCHW / 2;
                    var rightX = width - 0.5 - MCHW / 2;
                    ctx.moveTo(leftX, h);
                    ctx.lineTo(leftX, 0);
                    ctx.lineTo(rightX, 0);
                    ctx.lineTo(rightX, h);

                    ctx.moveTo(leftX, h + MCHH);
                    ctx.lineTo(leftX, divHeight);
                    ctx.lineTo(rightX, divHeight);
                    ctx.lineTo(rightX, h + MCHH);

                    ctx.stroke();
                    ctx.restore();
                }

            },

            
            setMasterSliderLayout: function setMasterSliderLayout() {
                var width = this.getWidth(),
                    utils = this.utils,
                    msl = this.masterSlider,
                    msStyle = msl.style,
                    mslp = msl.parentNode,
                
                    lcStyle = mslp.firstChild.style,
                
                    rcStyle = mslp.childNodes[2].style;

                lcStyle.width = (this.SLXP) + 'px';
                rcStyle.width = (width - this.SRXP) + 'px';

                
                var slWidth = (this.SRXP - this.SLXP);

                msStyle.width = (slWidth + MCHW) + 'px';
                
                utils.translateCSS(this.SLXP - MCHW / 2, 0, false, msl);

                this.drawMasterChartDiv();

            },

            makeSureMasterSliderNoOverlap: function makeSureMasterSliderNoOverlap(fixWhich) {
                var slWidth = this.SRXP - this.SLXP;

                
                if (slWidth < MCHW) {
                    slWidth = MCHW;
                    var width = this.getWidth();

                    if (!fixWhich) {
                        fixWhich = this.SRXP + MCHW / 2 === width - 1 ? "R" : "L";
                    }

                    if (fixWhich == "L") {
                        this.SRXP = this.SLXP + MCHW;
                    } else {
                        this.SLXP = this.SRXP - MCHW;
                    }

                }
            },

            
            calculateSXP: function calculateSXP(rns, rne, intervalChanged) {
                if (intervalChanged) {
                    this.SLXP = Math.round((this.MRTX * rns) + masterMargin.l);
                    this.SRXP = Math.round((this.MRTX * (rne - 1)) + masterMargin.l);
                } else {
                    var width = this.SRXP - this.SLXP;
                    this.SLXP = Math.round((this.MRTX * rns) + masterMargin.l);
                    this.SRXP = this.SLXP + width;
                }

            },

            makeSureMasterSliderNotBeyondTheMargin: function makeSureMasterSliderNotBeyondTheMargin(keepWidth) {
                var SWidth = this.SRXP - this.SLXP;
                var width = this.getWidth();
                if (this.SLXP < masterMargin.l) {
                    this.SLXP = masterMargin.l; 
                    if (keepWidth) {
                        this.SRXP = this.SLXP + SWidth;
                    }
                }
                if (this.SRXP > width - masterMargin.r - 1) {
                    this.SRXP = width - masterMargin.r - 1; 
                    if (keepWidth) {
                        this.SLXP = this.SRXP - SWidth;
                    }
                }
            },

            makeSureSelectedIntervalMoreThanTwo: function makeSureSelectedIntervalMoreThanTwo() {
                var mrtx = this.MRTX,
                    width = this.getWidth();
                if (this.SRXP - this.SLXP < mrtx) {
                    if (masterSliderClicked) {
                        if (masterSliderClicked === 'L') {
                            this.SLXP = this.SRXP - mrtx;
                        } else {
                            this.SRXP = this.SLXP + mrtx;
                        }
                    } else if (this.SLXP + mrtx <= width - masterMargin.r) {
                        this.SRXP = this.SLXP + mrtx;
                    } else {
                        this.SLXP = this.SRXP - mrtx;
                    }
                }
            },

            makeSureSXPNotEqual: function makeSureSXPNotEqual() {
                var mrtx = this.MRTX,
                    width = this.getWidth();
                if (this.SLXP === this.SRXP) {
                    if (masterSliderClicked) {
                        if (masterSliderClicked === 'L') {
                            this.SLXP -= mrtx;
                        } else {
                            this.SRXP += mrtx;
                        }
                    } else if (this.SRXP + mrtx <= width - masterMargin.r) {
                        this.SRXP += mrtx;
                    } else {
                        this.SLXP -= mrtx;
                    }
                }
            },

            makeSureSliderOnPoint: function makeSureSliderOnPoint() {
                var mrtx = this.MRTX,
                    diff = 0,
                    currStatus = chartStatus[this.chartID];
                ;
                if (masterSliderClicked) {
                    diff = Math.round((this.SRXP - this.SLXP) / mrtx);
                    if (masterSliderClicked === 'L') {
                        this.SLXP = this.SRXP - diff * mrtx;
                    } else if (masterSliderClicked === 'R') {

                        this.SRXP = this.SLXP + diff * mrtx;
                    } else {
                        this.calculateSXP(currStatus.rns, currStatus.rne, true);
                    }
                }
            },

            
            initScroller: function initScroller(scroller) {

                if (!scroller.offset && this.scrollPast) {
                    scroller.offset = {
                        scrollPast: this.scrollPast
                    };
                }

                this._super(scroller);

                var me = this;

                
                this._scrollDoneListener = this._scroller.attachEventListener('scrollDone', me.id, function (evt) {
                    
                    var m = me.model,
                        currStatus = chartStatus[me.chartID],
                        r = currStatus.rne - currStatus.rns,
                        rns = me.ACrns + parseInt(Math.round(me._scroller.origin.x / me.RTX), 10);
                    if (r === 1) { 
                        rns++;
                    }

                    var rne = rns + r;

                    
                    if (rns < 0) {
                        currStatus.rns = 0;
                        currStatus.rne = currStatus.rns + r;
                    } else if (rne > m.series[0].rv.length) {
                        currStatus.rne = m.series[0].rv.length;
                        currStatus.rns = currStatus.rne - r;
                    } else {
                        currStatus.rns = rns;
                        currStatus.rne = rne;
                    }
                    me.updateRnsRne();
                    SWidthChanged = false;

                    
                    me.incFetchChart();
                    
                });

                
                this._scrollMovedListener = this._scroller.attachEventListener('scrollMoved', me.id, function (evt) {
                    if (tooltipShown) {
                        me.hiddenTooltipAndShowTimeSelector();
                    }

                    
                    var m = me.model,
                        currStatus = chartStatus[me.chartID],
                        sl = m.series[0].rv.length,
                        r = currStatus.rne - currStatus.rns,
                        rns = me.ACrns + Math.round(evt.x / me.RTX),
                        rne = Math.min(rns + r, sl);

                    if (rns < 0) {
                        rns = 0;
                    }

                    if (rne - rns != r) {
                        SWidthChanged = true;
                    }

                    
                    me.utils.translateCSS(-evt.x + me.maxYLblWidth, -evt.y, false, me.xLabelsDiv);

                    me.calculateSXP(rns, rne, SWidthChanged);

                    me.makeSureSXPNotEqual();
                    me.makeSureMasterSliderNoOverlap();
                    me.setMasterSliderLayout();

                });

            },

            initFromVisProps: function (vp) {
                var propValue = vp ? vp : {};

                this.formatProp = {};

                this.formatProp.backgroundClr = propValue.fbg ? $CLR.hex2rgb(propValue.fbg) : [0, 0, 0];

                this.formatProp.textClr = propValue.flt ? $CLR.hex2rgb(propValue.flt) : [255, 255, 255];

                this.formatProp.tooltipClr = propValue.ftt ? $CLR.hex2rgb(propValue.ftt) : [255, 255, 255];

                this.formatProp.backgroundAlpha = propValue.fbt != undefined ? ( 1 - parseInt(propValue.fbt) / 100) : 1;

                var getBool = function (v) {
                    if (v == true || v == "1" || v == 1 || v == "true") {
                        return true;
                    }

                    return false;
                }

                this.formatProp.useCustomAxisScale = propValue.fcas ? getBool(propValue.fcas) : false;

                var numCheck = function (num) {
                    if (num > Number.MAX_VALUE) {
                        num = Number.MAX_VALUE;
                    }
                    if (num < -1 * Number.MAX_VALUE) {
                        num = -1 * Number.MAX_VALUE;
                    }
                    return num;

                }

                this.formatProp.minValue = propValue.fmiav ? numCheck(parseFloat(propValue.fmiav)) : "";

                this.formatProp.maxValue = propValue.fmaav ? numCheck(parseFloat(propValue.fmaav)) : "";

                this.formatProp.condenseLabels = propValue.fcl ? getBool(propValue.fcl) : true;

                this.chartLineColors = ['#16b0ff', '#ff3729', '#04ba22', '#ff960e',
                    '#ae79de', '#cccd25', '#19cee0', '#a9a9a9',
                    '#b3cdef', '#ffa796', '#98df8a', '#ffbf80',
                    '#dac3ec', '#dac3ec', '#a1dfea', '#d6d6d6'];

                for (var i = 0; i < this.chartLineColors.length; i++) {
                    var propName = '' + Math.floor(i / 4) + i % 4;
                    propName = "fs" + propName;

                    var color = propValue[propName];
                    if (color) {
                        this.chartLineColors[i] = "#" + color;
                    }
                }

                
                this.glowColor = this.utils.rgb2rgbStr(this.formatProp.tooltipClr);
                
            },

            
            getMaxValue: function getMaxV() {
                if (typeof this.formatProp.maxValue == "number") {
                    return this.formatProp.maxValue;
                } else {
                    return this._super();
                }

            },

            
            getMinValue: function getMinV() {
                if (typeof this.formatProp.minValue == "number") {
                    return this.formatProp.minValue;
                } else {
                    return this._super();
                }
            },

            preBuildRendering: function preBR() {
                if (this._super) {
                    this._super();
                }
                this.masterChartHeight = 90;
                this.slaveChartHeight = this.getHeight() - this.masterChartHeight;
            },

            buildRendering: function () {
                var that = this;
                var backup = mstrmojo.string.apply;
                mstrmojo.string.apply = function (tmpl, obj) {
                    if (!tmpl) {
                        return "";
                    }
                    return tmpl.replace(/\{([^\}]+)\}/gm,
                        function tokenRepl(token, prop) {
                            var s = token.replace(/@/g, 'that.');
                            var res = eval(s);
                            return res === undefined ? '' : res;
                        }
                    );
                };

                if (this._super) {
                    this._super();
                }

                mstrmojo.string.apply = backup;
            },

            
            postBuildRendering: function postBR() {
                var model = this.model;

                this.checkData(model);

                
                var err = model.err || model.eg;

                
                var xtabModel = this.xtabModel,
                    docModel = (xtabModel && xtabModel.docModel);

                if (err) {
                    
                    if (docModel && docModel.prompts) {
                        this.model.docModel = docModel;
                    }
                    this.renderErrorMessage(err);
                    return;
                } else {
                    this.errorMsg.style.display = 'none';
                }

                resetLocalVars();
                getUITheme.call(this);

                this.updateSelectionLinkdrillInfo(model);
                
                
                if (this.baseModel && !model.vp) {
                    this.model = this.baseModel;
                }

                this.chartID = this.getChartID(docModel);

                if (!chartStatus[this.chartID]) {
                    addChartStatus(this.chartID);
                }
                
                this.scrollerConfig.scrollEl = this.animationCanvasDiv;

                
                this.isAndroidTab = !!mstrApp.isTablet(); 
                this.masterContext = this.masterCanvas.getContext('2d');

                this.renderVisTooltip();
                
                this.setMarginTopByTooltipHeight();

                this.renderLegend();

                if (this._super) {
                    this._super();
                }

                this.renderTimeSelector();
                this.setAnimationCanvasContainer();

                
                localUpdateScrollerConfig.call(this);

                
                if (docModel && docModel.prompts) {
                    this.model.docModel = docModel;
                }

                this.drawSliderTooltipPointer();

                
                var me = this;
                if (docModel) {
                    this._infoWClosedListener = this.xtabModel.docModel.attachEventListener('infoWindowClosed', this.id, function (evt) {
                        var infoWindowK = evt.psKey;
                        
                        if (!me.hasNonifwTarget && me.selectorTargets && me.selectorTargets[infoWindowK]) {
                            

                            
                            
                            
                            
                            
                            
                            
                            
                            me.lastSelectedPoint = null;
                            me.incFetchChart(true);
                            
                            return;
                        }

                    });
                }

                this.fullScreenListener = mstrmojo.touchManager.attachEventListener('fullScreenStateChange', this.id, function (evt) {
                    this.adjustWidgetOffsets();
                });

                this.renderLegendTooltip();

                
                
                

                
                

            },

            
            ongridDataChange: function onGridDataChange(evt) {
                this.model = this.gridData;
            },

            getChartID: function getChartID(docModel) {
                var chartID = "";

                var layoutModel = docModel ? docModel : (this.layoutModel ? this.layoutModel : ( this.model.layoutModel ? this.model.layoutModel : null ));

                if (layoutModel) {
                    chartID = layoutModel.oid + "_" + layoutModel.currlayKey + "_" + this.model.k;
                    
                    

                } else if (this.model.mid) {
                    chartID = this.model.mid;
                } else {
                    chartID = widgetCount++;
                }
                
                return chartID;

            },

            checkData: function checkData(model) {
                var colHeaders = model.colHeaders,
                    categories = model.categories;

                if (!colHeaders || (colHeaders && colHeaders.length < 1)) {
                    this.model.err = mstrmojo.desc(8626, "The Time Series widget requires at least one attribute on the row axis and at least one metric on the column axis; optionally, one attribute can be placed above the metrics.");
                }
                if (colHeaders && colHeaders.length >= 1 && !this.isMetric(colHeaders[colHeaders.length - 1].items)) {
                    this.model.err = mstrmojo.desc(8626, "The Time Series widget requires at least one attribute on the row axis and at least one metric on the column axis; optionally, one attribute can be placed above the metrics.");
                }

                if ((categories && (!categories.items || categories.items.length < 2))) {
                    this.model.err = mstrmojo.desc(8475, 'There is not enough data to plot the graph.');
                }

            },

            renderErrorMessage: function renderErrorMessage(msg) {
                this.errorMsg.innerHTML = msg; 
                this.errorMsg.style.display = 'block';
            },

            isMetric: function isMetric(items) {
                if (items && items.length > 0 && items[0].cs != null) {
                    return true;
                }
                return false;
            },

            updateSelectionLinkdrillInfo: function uscld(model) {
                
                var rowHeaders = model.rowHeaders,
                    rowHL = rowHeaders.length;
                for (var i = 0; i < rowHL; i++) {
                    var rowH = rowHeaders[i];
                    if (rowH.sc && rowH.sc.tks) {
                        this.selectionOrLinkdrillOnRow = true;
                        return;
                    }
                    if (rowH.lm && rowH.lm[0] && rowH.lm[0].links) {
                        this.selectionOrLinkdrillOnRow = true;
                        return;
                    }
                }
            },

            
            hasPageBy: function hasPageBy() {
                if (this.baseModel && this.baseModel.phs && this.baseModel.phs.show) {
                    return true;
                }
                return false;
            },




            setlegendStatus: function setlegendStatus(ilo, lbw) {
                chartStatus[this.chartID].legendBarWidth = lbw;
                chartStatus[this.chartID].isLegendBarOpen = ilo;
            },

            setLegendSelected: function setLegendSelected(ils, lsi) {
                chartStatus[this.chartID].isLegendSelected = ils;
                chartStatus[this.chartID].legendSelectedIndex = lsi;

            },

            getLegendBarDiv: function getLegendBarDiv() {
                return this.domNode.childNodes[6];
            },

            getTimeSelectorDiv: function getTimeSelectorDiv() {
                return this.domNode.childNodes[5];
            },

            renderLegend: function renderLegend() {
                var placeholder = this.legendBarDiv;
                var m = this.margin;
                var chartID = this.chartID;
                var props = {
                    placeholder: placeholder,
                    model: this.model,
                    utils: this.utils,
                    widget: this,
                    isLegendBarOpen: chartStatus[chartID].isLegendBarOpen,
                    isAndroidTab: this.isAndroidTab,
                    isLegendSelected: chartStatus[chartID].isLegendSelected,
                    legendSelectedIndex: chartStatus[chartID].legendSelectedIndex,
                    top: m.t + "px",
                    right: "0px",
                    zIndex: 1
                };

                var w = new mstrmojo.VisTimeSeriesLegend(props);
                w.render();
                this._legend = w;
            },

            renderTimeSelector: function renderTimeSelector() {
                var placeholder = this.timeSelectorDiv;
                var m = this.margin;
                var chartID = this.chartID;
                var props = {
                    placeholder: placeholder,
                    offsetx: this.margin.l,
                    widget: this,
                    chartStatus: chartStatus[this.chartID]
                };

                var w = new mstrmojo.VisTimeSeriesTimeSelector(props);
                w.render();
                this._timeSelector = w;
            },

            renderVisTooltip: function renderVisTooltip() {
                
                var props = {
                    placeholder: this.tooltip,
                    cssClass: 'timeseries-tooltip'
                };
                this._tooltip = new mstrmojo.VisTooltip(props);
                this._tooltip.render();

                this._tooltip.toggle(false);
            },

            renderLegendTooltip: function renderLegendTooltip() {
                var props = {
                    placeholder: this.legendTooltip,
                    boundary: this.domNode
                };
                this._legendTooltip = new mstrmojo.VisTextTooltip(props);
                this._legendTooltip.render();

                this._legendTooltip.toggle(false);
            },

            setAnimationCanvasContainer: function setAnimationCanvasContainer() {
                var currStatus = chartStatus[this.chartID],
                    m = this.margin;
                
                this.itemsContainerNode.style.left = m.l + 'px';
                this.xLabelsDivContainer.style.left = (m.l - this.maxYLblWidth) + 'px';
            },

            
            updateRnsRne: function updateRnsRne(rns, rne) {
                var currStatus = chartStatus[this.chartID],
                    m = this.model;

                if ((rns == 0 || rns) && rne) {
                    currStatus.rns = rns;
                    currStatus.rne = rne;
                }
                m.rns = currStatus.rns;
                m.rne = currStatus.rne;
            },

            
            drawPreparation: function drawPreparation(windowSize, rns, rne) {
                var me = this,
                    margin = this.margin,
                    model = me.model,
                    diff = rne - rns,
                    height = me.getHeight() - me.masterChartHeight,
                    ctx = me.animationContext;

                
                var chartWidth = me.getChartWidthOnScreen();
                
                this.chartWidth = chartWidth;

                getACRnsRne.call(this, rns, rne);
                var ACdiff = me.ACrne - me.ACrns;

                
                if (diff < windowSize) {
                    if (diff > 1) {
                        diff--;
                    }
                    if (ACdiff > 1) {
                        ACdiff--;
                    }
                    windowSize--;
                }

                this.itemsContainerNode.style.width = chartWidth + 'px';
                this.itemsContainerNode.style.height = height + 'px';

                this.xLabelsDivContainer.style.width = me.maxYLblWidth + chartWidth + 'px';
                this.xLabelsDivContainer.style.height = height + 'px';

                
                totalChartWidth = (windowSize / diff) * chartWidth;

                me.totalChartWidth = totalChartWidth;
                var acContentWidth = 0;
                if (model.currentRatio > rangeToSeriesMaxRatio) {
                    acContentWidth = (ACdiff / diff) * chartWidth;
                } else {
                    acContentWidth = totalChartWidth;
                }
                this.acContentWidth = acContentWidth;

                var acWidth = rangeToSeriesMaxRatio * this.getWidth();
                if (me.animationCanvas.width !== acWidth) {
                    canvasReseted = true;
                }
                me.animationCanvas.width = acWidth;

                
                me.RTX = (totalChartWidth - 1) / (this.windowSize - 1);

            },

            
            drawChart: function drwchrt() {
                var model = this.model;
                if (model.err) {
                    return;
                }

                var me = this,

                    mvalues = model.mvalues,
                    width = me.getWidth(),
                    margin = me.margin,
                    utils = me.utils,
                    values = model.series,
                    ylbls = model.ylbls,
                    windowSize = me.windowSize,
                    currStatus = chartStatus[this.chartID];

                
                if ((!currStatus.rns && currStatus.rns != 0) || !currStatus.rne || currStatus.rns < 0 || currStatus.rne > windowSize) {
                    currStatus.rns = model.rns;
                    currStatus.rne = model.rne;

                    
                    if ((currStatus.rne - currStatus.rns) < 2) {
                        if (currStatus.rns > 0) {
                            currStatus.rns = currStatus.rne - 2;
                        } else {
                            currStatus.rne = currStatus.rns + 2;
                        }
                    }
                }
                this.updateRnsRne();
                
                var mch = me.masterChartHeight;

                var height = me.slaveChartHeight;

                if (!values) {
                    return;
                }

                if (me.isDrawAxis && me.drawYAxisLabels) {
                    margin.l = utils.getLabelWidthForMargin(me, model.mls);
                }

                
                me.masterCanvas.height = mch;
                me.masterCanvas.width = width;
                
                utils.fillMasterChartBackground(me, 0, masterMargin.t, width, mch - masterMargin.t - masterMargin.b, masterMargin.b, me.masterContext);

                me.MRTY = (mch - masterMargin.t - masterMargin.b - 1 - 3 ) / (mvalues[mvalues.length - 1] - mvalues[0]);
                me.MRTX = (width - masterMargin.l - masterMargin.r - 1) / (windowSize - 1);

                
                me.drawSeries(0, windowSize, currStatus.rns, currStatus.rne, values, me.masterContext, true);

                me.setMasterSlider();

                this.calculateRnsRneFromSXP();

                if (me.canvas.height != height || me.animationCanvas.height != height || me.highlightCanvas.height != height || me.canvas.width != width) {
                    me.canvas.height = me.animationCanvas.height = me.highlightCanvas.height = height;
                    me.canvas.width = me.highlightCanvas.width = width;
                    canvasReseted = true

                    
                    utils.fillBackground(me);
                }

                
                this.maxYLblWidth = this.getMaxTextWidth(ylbls, this.mstrmojo_Chart_lbl_font) + 5;

                this.drawPreparation(windowSize, currStatus.rns, currStatus.rne);
                
                me.RTY = (height - margin.t - margin.b - 1 - 4) / (mvalues[mvalues.length - 1] - mvalues[0]);

                
                

                me.drawSeries(me.ACrns, me.ACrne, currStatus.rns, currStatus.rne, values, me.animationContext, false);

            },

            calculateRnsRneFromSXP: function calrns() {
                var me = this;

                var rne = Math.round((me.SRXP - masterMargin.l) / me.MRTX) + 1; 
                rne = Math.min(rne, me.windowSize); 
                var rns = Math.round((me.SLXP - masterMargin.l) / me.MRTX);

                this.updateRnsRne(rns, rne);
            },

            
            reDrawSlaveChartImpl: function reDrawSlaveChartImpl() {
                var me = this,
                    model = me.model,
                    currStatus = chartStatus[this.chartID],
                    values = model.series,
                    context = me.animationContext;



                this.drawPreparation(me.windowSize, currStatus.rns, currStatus.rne);

                me.drawSeries(me.ACrns, me.ACrne, currStatus.rns, currStatus.rne, values, context, false);

                
                localUpdateScrollerConfig.call(me);
                this.removeLabels();
                itemClicked = true;
                this.drawLabels();
                itemClicked = false;
            },

            
            redrawSeries: function redrawSeries() {
                var me = this,
                    model = me.model,
                    values = model.series,
                    context = me.animationContext,
                    windowSize = me.windowSize,
                    ht = me.getHeight(),
                    currStatus = chartStatus[this.chartID];

                
                me.animationCanvas.width = me.animationCanvas.width;

                me.drawSeries(me.ACrns, me.ACrne, currStatus.rns, currStatus.rne, values, context, false);

                localUpdateScrollerConfig.call(me);

                this.removeLabels();
                itemClicked = true;
                this.drawLabels();
                itemClicked = false;
            },

            
            incFetchChart: function incFetchChart(mustRedraw) {
                var me = this,
                    model = me.model,
                    currStatus = chartStatus[this.chartID],
                    values = model.series,
                    context = me.animationContext,
                    m = me.margin,
                    utils = me.utils,
                    lines = [],
                    width = me.getWidth(),
                    chartWidth = me.getChartWidthOnScreen(),
                
                    h = me.canvas.height,
                
                    windowSize = me.windowSize;

                var v0l = values[0].rv.length;
                var diff = currStatus.rne - currStatus.rns;
                var needRedraw = getACRnsRne.call(this);
                
                var redrawChart = mustRedraw || needRedraw || currStatus.isLegendSelected || me.needRedrawVerticalLine;
                if (redrawChart) {
                    var ACdiff = me.ACrne - me.ACrns;
                    
                    if (diff < v0l) {
                        if (diff > 1) {
                            diff--;
                        }
                        if (ACdiff > 1) {
                            ACdiff--;
                        }
                        v0l--;
                    }

                    
                    totalChartWidth = (v0l / diff) * chartWidth;

                    me.totalChartWidth = totalChartWidth;
                    var acContentWidth = 0;
                    if (model.currentRatio > rangeToSeriesMaxRatio) {
                        acContentWidth = (ACdiff / diff) * chartWidth;
                    } else {
                        acContentWidth = totalChartWidth;
                    }
                    this.acContentWidth = acContentWidth;

                    
                    me.animationCanvas.width = me.animationCanvas.width;

                    me.drawSeries(me.ACrns, me.ACrne, currStatus.rns, currStatus.rne, values, context, false);

                    
                    localUpdateScrollerConfig.call(me);
                }

                this.removeLabels();
                itemClicked = true;
                this.drawLabels(!redrawChart);
                itemClicked = false;
            },

            
            reDrawSlaveChart: function reDrawSlaveChart() {
                var me = this;

                this.calculateRnsRneFromSXP();
                this.reDrawSlaveChartImpl();

                chartSizeChanged = false;
                masterSliderClicked = null;
                this.hideMessage();
            },

            drawSeries: function drawSeries(start, end, rns, rne, values, context, isMasterChart) {
                var me = this,
                    utils = me.utils,
                    lines = [],
                    k = 0,
                    vl = values.length;

                var lineWidth = isMasterChart ? 1 : (rne - rns > 180 ? 1 : 2);
                
                for (var j = vl - 1; j >= 0; j--) {
                    lines = [];
                    k = 0;
                    for (var i = start; i < end; i++) {
                        var val = values[j].rv[i];
                        if (val.length === 0) {
                            lines[k++] = null;
                            continue;
                        }

                        lines[k] = {
                            x: isMasterChart ? ((i * me.MRTX) + masterMargin.l + 1) : ((i - start) * me.RTX ),
                            y: isMasterChart ? utils.getMasterYValue(me, val, masterMargin) : utils.getYValue(me, val)
                        };
                        k++;
                    }

                    me.drawChartLine(lines, rns - start, rne - start, j, context, isMasterChart, lineWidth);

                }

                if (!isMasterChart && me.lastSelectedPoint) {
                    me.highlightSelectedPoint();
                }
            },

            getSerieColor: function getSerieColor(serieIndex) {
                var clrLength = this.chartLineColors.length;
                
                return this.chartLineColors[serieIndex % clrLength];
            },

            
            drawChartLine: function drwcl(lines, rns, rne, si, context, isMasterChart, lw) {

                var me = this,
                    m = me.model,
                    s = m.series[si],
                    utils = this.utils,
                    currStatus = chartStatus[this.chartID];

                context.save();
                context.lineCap = 'round';
                context.lineWidth = lw || 2;
                context.lineJoin = 'round';

                context.beginPath();


                if (this.formatProp && this.formatProp.useCustomAxisScale) {
                    var margin;
                    if (!isMasterChart) {
                        margin = me.margin;
                        context.rect(0, margin.t, me.animationCanvas.width, me.slaveChartHeight - margin.b - margin.t);
                    } else {
                        margin = masterMargin;
                        context.rect(0, margin.t, me.getWidth(), me.masterChartHeight - margin.b - margin.t);
                    }
                    context.clip();
                }


                var clr = this.getSerieColor(si),
                    rgbClr = $CLR.hex2rgb(clr),
                    l = lines.length,
                    dataPointPerScreen = rne - rns;

                context.strokeStyle = clr;

                if (currStatus.isLegendSelected && !isMasterChart) {
                    if (currStatus.legendSelectedIndex === si) {
                        var MaxY = this.canvas.height - this.margin.b;
                        var start = rns, end = rne - 1;
                        for (var i = 0; i < Math.ceil((l - 1 - rns) / (dataPointPerScreen - 1)); i++) {
                            if (mstrmojo.dom.isIE10) {
                                utils.drawLineAreaWithSplit(me, lines, start, end, MaxY, rgbClr, context, MAXPOINTS_PER_DRAW);
                            } else {
                                utils.drawLineArea(me, lines, start, end, MaxY, rgbClr, context);
                            }
                            start = end;
                            end = Math.min(start + dataPointPerScreen - 1, l - 1);
                        }
                        start = Math.max(rns - dataPointPerScreen + 1, 0), end = rns;
                        for (var i = Math.ceil((rns) / (dataPointPerScreen - 1)); i > 0; i--) {
                            if (mstrmojo.dom.isIE10) {
                                utils.drawLineAreaWithSplit(me, lines, start, end, MaxY, rgbClr, context, MAXPOINTS_PER_DRAW);
                            } else {
                                utils.drawLineArea(me, lines, start, end, MaxY, rgbClr, context);
                            }

                            end = start;
                            start = Math.max(start - dataPointPerScreen + 1, 0);
                        }
                        if (mstrmojo.dom.isIE10) {
                            utils.drawLineAreaWithSplit(me, lines, start, end, MaxY, rgbClr, context, MAXPOINTS_PER_DRAW);
                        } else {
                            utils.drawLineArea(me, lines, start, end, MaxY, rgbClr, context);
                        }
                        context.strokeStyle = this.highlightColor;
                        context.globalAlpha = 1;
                        context.lineWidth = 2;
                    } else {
                        context.globalAlpha = 0.3;
                        context.lineWidth = 1;
                    }
                }

                if (mstrmojo.dom.isIE10) {
                    utils.drawLineSetWithSplit(me, lines, false, context, MAXPOINTS_PER_DRAW);
                } else {
                    utils.drawLineSet(me, lines, false, context);
                }

                
                

                context.restore();

            },

            
            drawLabels: function drwlbls(needNotDrawVerticalGridLine) {
                
                this.drawChartXYAxis();
                if (this._super) {
                    this._super(needNotDrawVerticalGridLine);
                }
            },

            drawSelector: function drwsl(lbl, rl, intervalChanged) {
                var m = this.model,
                    sl = m.series[0].rv.length,
                    rng = sl,
                    bm = this.baseModel,
                    row = bm.rowHeaders,
                    currStatus = chartStatus[this.chartID],
                    rns = currStatus.rns,
                    rne = currStatus.rne;

                if (intervalChanged) {

                    
                    var rs = parseInt(rl.rs, 10);
                    var sr = rl.sr;

                    for (var i = 0; i < row.length; i++) {
                        
                        if (row[i].id === sr) {
                            rng = row[i].l * rs;
                            break;
                        }
                    }

                    
                    if (rng < 2) {
                        rng = 2;
                    }

                    var index = mstrmojo.dom.findAncestorByAttr(lbl, "value", true, this.domNode);

                    
                    
                    
                    
                    
                    
                    
                    
                    
                    var right = rne;
                    if (right - rng >= 0) {
                        currStatus.rns = right - rng;
                        currStatus.rne = right;
                    } else {
                        currStatus.rns = 0;
                        currStatus.rne = rng < sl ? rng : sl;
                    }
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    

                    this.updateIntervalPosition();
                    
                    this.updateRnsRne();
                }
                this.refreshChart(true, isDataSetChanged);

                itemClicked = false;
                this.hideMessage();
            },

            
            getTouchValue: function gtvlindx(x, y) {
                var md = this.model,
                    m = this.margin,
                    currStatus = chartStatus[this.chartID];

                
                var sz = currStatus.rne - currStatus.rns > 0 ? currStatus.rne - currStatus.rns > 1 ? currStatus.rne - currStatus.rns : 2 : this.windowSize;
                var touchVal = Math.round(((x - m.l) * (sz - 1)) / (this.getChartWidthOnScreen() ));
                return (touchVal < sz) ? touchVal : null;
            },

            
            getNearestPoint: function getNP(touchX, touchY) {
                var me = this,
                    currStatus = chartStatus[this.chartID],
                    margin = me.margin;

                var touchPointOnWidget = me.utils.getTouchXYOnWidget(touchX, touchY, me);
                touchX = touchPointOnWidget.touchX;
                touchY = touchPointOnWidget.touchY;

                
                if (touchX < margin.l || touchY < margin.t || touchY > me.canvas.height - margin.b) {
                    return;
                }

                var xIndexOnScreen = this.getTouchValue(touchX, touchY);

                var rowIdx = xIndexOnScreen + currStatus.rns;
                var pointX = (xIndexOnScreen * me.RTX) + me.margin.l;
                var pointY, serieIdx;

                if (currStatus.isLegendSelected) {
                    serieIdx = currStatus.legendSelectedIndex;
                    pointY = me.utils.getYValue(me, me.model.series[serieIdx].rv[rowIdx]);
                } else {
                    var nearestPoint = me.utils.getSeriesIndexAndYValue(me, rowIdx, touchY);
                    serieIdx = nearestPoint.si;
                    pointY = nearestPoint.y;
                }

                return { rowIdx: rowIdx, serieIdx: serieIdx, point: {x: pointX, y: pointY} };
            },

            
            highlightPoint: function hghlghtpnt(x, touchX, touchY) {

                
                var me = this,
                    ctx = me.highlightContext,
                    height = me.highlightCanvas.height,
                    mg = me.margin,
                    m = me.model,
                    utils = me.utils,
                    currStatus = chartStatus[this.chartID],
                    si = currStatus.isLegendSelected ? currStatus.legendSelectedIndex : me.seriesIndex;

                
                
                
                this.highlightCanvas.width = this.highlightCanvas.width;
                if (x < 0) {
                    return;
                }

                var xcoord = (x * me.RTX) + mg.l;

                
                
                ctx.strokeStyle = this.utils.rgb2rgbStr(this.formatProp.textClr);

                ctx.lineCap = "round";

                
                ctx.lineWidth = 2;
                ctx.globalAlpha = 1;
                utils.drawLineSet(me, [
                    {
                        x: touchX,
                        y: this._tooltip.domNode.offsetHeight
                    },
                    {
                        x: touchX,
                        y: height - mg.b
                    }
                ], false, ctx);

                ctx.strokeStyle = me.highlightColor;
                ctx.fillStyle = ctx.strokeStyle;
                
                var s = m.series,
                    l = s.length,
                    rns = (currStatus.rns === 0 || currStatus.rne - currStatus.rns > 1) ? currStatus.rns : currStatus.rns - 1,
                    rowIdx = rns + x,
                    y = utils.getYValue(me, s[si].rv[rowIdx]); 
                
                if (!chartStatus[this.chartID].isLegendSelected) {
                    ctx.strokeStyle = me.getSerieColor(si);
                }
                ctx.fillStyle = ctx.strokeStyle;

                if (y >= mg.t && y <= this.canvas.height - mg.b) {
                    
                    utils.drawArc(me, xcoord, y, 5, 0, Math.PI * 2, true, true, ctx);
                }

                
                this.lastHighlightPoint = {rowIdx: rowIdx, serieIdx: si, point: {x: xcoord, y: y}};

            },

            hideTimeSelectorLabels: function htsl() {
                var lbls = this.domNode.getElementsByClassName('timeseries-intervals');
                for (var i = 0; i < lbls.length; i++) {
                    lbls[i].style.display = 'none';
                }
            },

            showTimeSelectorLabels: function stsl() {
                var lbls = this.domNode.getElementsByClassName('timeseries-intervals');
                for (var i = 0; i < lbls.length; i++) {
                    lbls[i].style.display = 'block';
                }
            },

            
            getFormattedDateForTooltip: function getFormattedDateForTooltip( val, isLongFormat) {
                if (isNaN(val)) {
                    return val;
                }
                var fVal = val;
                try {
                    val = this.utils.convertRawValueToMilliseconds(val);
                    var dt = new Date(Number(val)),
                        $_DT = mstrmojo.locales.datetime;
                    var mn = isLongFormat ? $_DT.MONTHNAME_FULL[dt.getMonth()] : $_DT.MONTHNAME_SHORT[dt.getMonth()];
                    var yr = dt.getFullYear().toString();
                    if (isLongFormat) {
                        fVal = mn + " " + dt.getDate() + ", " + yr;
                    } else {
                        fVal = mn + "-" + dt.getDate() + "-" + yr.substring(2);
                    }
                } catch (e) {
                    
                }
                return fVal;
            },

            showLegendTooltip: function showLegendTooltip(e) {
                 this._legendTooltip.updateContent(e);
            },

            hiddenLegendTooltip: function hiddenLegendTooltip() {
                this._legendTooltip && this._legendTooltip.toggle(false);
            },

            getLegendName: function getLegendName(colHeaders, series, i) {
                var colHLength = colHeaders.length;
                var hiLength = series[i].hi.length;

                if (colHLength < 1) {
                    return "null";
                }

                if (hiLength == colHLength) {

                    var legendName = "";

                    for (var j = 0; j < hiLength; j++) {
                        var colHeader = colHeaders[j];
                        var colName = "";

                        if (colHeader.es) {
                            colName = colHeader.es[series[i].hi[j]];
                        } else {
                            colName = colHeader.items[series[i].hi[j]].n;
                        }

                        if (j > 0) {
                            legendName += " ";
                        }
                        if (colName != "") {
                            legendName += colName;
                        }
                    }
                    return legendName;
                } else {
                    var items = colHeaders[0].items
                    legendName = items[i % items.length].n;
                    return legendName;
                }
                return "null";
            },

            
            getRowHeader: function getrh(idx) {
                var me = this,
                    m = me.model,
                    riArray = m.ri,
                    s = m.series,
                    cat = m.categories,
                    tp = cat.tp,
                    currStatus = chartStatus[this.chartID],
                    rowHs = m.rowHeaders,
                    rowHLength = rowHs.length,
                    rowHeader = [];

                
                var rVal = cat.items[idx];

                var ri = riArray && riArray[idx];

                if (!ri) {
                    return rowHeader;
                }

                
                if (tp.toString() === me.DSS_XML_BASE_FORM_DATE) {
                    rVal = me.getFormattedDateForTooltip(rVal, true);
                    var rowHeaderObj = {};
                    rowHeaderObj.n = rowHs[rowHLength - 1].n;
                    rowHeaderObj.v = rVal;
                    rowHeader.push(rowHeaderObj);
                } else {
                    

                    for (var i = 0; i < rowHLength; i++) {
                        var rowHeaderObj = {}

                        var rowH = rowHs[i];
                        rowHeaderObj.n = rowH.n;
                        rowHeaderObj.v = rowH.es[ri[i]] || "";
                        rowHeader.push(rowHeaderObj);
                    }
                }

                return rowHeader;

            },

            setMarginTopByTooltipHeight: function setMarginTopByTooltipHeight() {
                var me = this,
                    m = me.model,
                    mg = me.margin,
                    s = m.series,
                    colH = m.colHeaders;

                if (this._tooltip) {
                    this._tooltip.displayInfo([
                        {n: 'legendName', v: 'val'},
                        {n: 'rowHeaderName', v: 'rowHeaderValue'}
                    ]);
                    this._tooltip.toggle(true);
                    var height = this._tooltip.domNode.offsetHeight + 10;
                    this._tooltip.toggle(false);

                    if (me.margin.t < height) {
                        me.margin.t = height;
                    }
                }

                
                var stt = me.sliderTooltip,
                    sttF = stt.firstChild,
                    sttP = stt.lastChild;

                sttF.innerHTML = "name: value";
                sttF.style.display = 'block';

                var sliderTooltipHeight = sttF.offsetHeight;

                
                me.sliderTooltipYPosition = me.getHeight() - me.masterChartHeight - sliderTooltipHeight - 7 + masterMargin.t;
                sttP.style.top = sliderTooltipHeight + 'px';

                sttF.style.display = 'none';

            },

            
            renderTooltip: function rndrttp(valIndex, touchX, touchY) {
                if (valIndex < 0) {
                    this._tooltip.toggle(false);
                    return;
                }

                var me = this,
                    m = me.model,
                    mg = me.margin,
                    s = m.series,
                    currStatus = chartStatus[this.chartID],
                    si = currStatus.isLegendSelected ? currStatus.legendSelectedIndex : me.seriesIndex,
                    rns = (currStatus.rns === 0 || currStatus.rne - currStatus.rns > 1) ? currStatus.rns : currStatus.rns - 1,
                    colH = m.colHeaders;
                var width = me.getWidth();

                if (!tooltipShown) {
                    me.hideTimeSelectorLabels();
                    tooltipShown = true;

                    var touchManager = mstrmojo.touchManager;
                    this._touchListener = touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                        if (!isTouchedOnWidget.call(me, evt.touch)) {
                            me.hiddenTooltipAndShowTimeSelector();   
                        }
                    });
                }
                var vIdx = rns + valIndex;
                var val = s[si].v[vIdx] ? s[si].v[vIdx] : "null";
                var legendName = this.getLegendName(colH, s, si);
                
                var rowHeaders = this.getRowHeader(vIdx),
                    rowHeaderName = "",
                    rowHeaderValue = "";
                for (var i = 0; i < rowHeaders.length; i++) {
                    rowHeaderName += rowHeaders[i].n;
                    rowHeaderValue += rowHeaders[i].v;
                    if (i < rowHeaders.length - 1) {
                        rowHeaderName += " ";
                        rowHeaderValue += " ";
                    }
                }

                this._tooltip.displayInfo([
                    {n: legendName, v: val},
                    {n: rowHeaderName, v: rowHeaderValue}
                ]);
                this._tooltip.toggle(true);

                this._tooltip.doLayout(width - 10);

                
                
                var ttw = this._tooltip.domNode.offsetWidth,
                    x = touchX - ttw / 2;

                
                if (x < 5) {
                    x = 5;
                } else if (x > width - 5 - ttw) {
                    x = width - 5 - ttw;
                }

                this._tooltip.posTo({x: x, y: 5});

            },

            
            handleTouchEnd: function handleTouchEnd() {
                this._super();
                this._tooltip && this._tooltip.toggle(false);
            },

            showMessage: function shmsg(text) {
                var msg = this.loadingMsg,
                    mns = msg.style;

                
                msg.innerHTML = text || mstrmojo.desc(5674, 'Loading...');
                mns.display = 'block';
                mns.opacity = 1;

                
                var x = Math.round(this.getWidth() / 2 - msg.offsetWidth / 2);
                var y = Math.round(this.getHeight() / 2 - msg.offsetHeight / 2);

                this.utils.translateCSS(x, y, false, msg);

            },

            hideMessage: function hmsg() {
                this.loadingMsg.style.opacity = 0;
            },

            showMasterSliderTooltip: function showMasterSliderTooltip(item) {
                $CSS.addClass(item.node, 'mstrmojo-timeseries-span-shadow');

                var stt = this.sliderTooltip;
                stt.firstChild.style.display = 'block';
                stt.lastChild.style.display = 'block';
                
                this.renderSliderTooltip(item.value === 'L' ? this.SLXP : this.SRXP);

            },

            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            


            unrender: function unrender(ignoreDom) {

                if (this._tooltip) {
                    this._tooltip.destroy();
                    delete this._tooltip;
                }
                if (this._legend) {
                    this._legend.destroy();
                    delete this._legend;
                }
                if (this._timeSelector) {
                    this._timeSelector.destroy();
                    delete this._timeSelector;
                }

                if (this._legendTooltip) {
                    this._legendTooltip.destroy();
                    delete this._legendTooltip;
                }

                if (this._super) {
                    this._super(ignoreDom);
                }
            },

            
            refresh: function refresh() {
                var me = this;

                removeLegendAndTimeSelectorChildren.call(this);

                
                me.removeLabels();

                me.lastSelectedPoint = null;

                me.render();
            },

            
            removeLabels: function rmvlbls() {
                var me = this;

                
                me.canvas.width = me.canvas.width;
                
                me.utils.fillBackground(me);

                
                me.xLabelsDiv.innerHTML = '';
                
                var lbls = me.domNode.getElementsByClassName('mstrmojo-chart-ylbl-div')[0];
                if (lbls) {
                    lbls.innerHTML = '';
                }

            },

            refreshChart: function refcht(isMetric, pld) {
                var me = this,
                    wd = me.getWidth(),
                    ht = me.getHeight();
                if (me.model.err) {
                    return;
                }
                
                
                me.highlightCanvas.width = wd;
                
                me.animationCanvas.width = me.animationCanvas.width;

                if (isMetric) {
                    me.context.clearRect(0, 0, wd, ht);

                    
                    me.removeLabels();

                    if (pld) { 
                        me.data.processLinearData(me);
                    }

                }

                
                me.drawChart();
                this.setAnimationCanvasContainer();
                me.drawLabels();

                
                localUpdateScrollerConfig.call(me);

                
                
            },

            
            timeSelectorOnClick: function hoc(item) {
                var currStatus = chartStatus[this.chartID];
                if (!itemClicked) {
                    itemClicked = true;

                    var me = this,
                        v = item.value,
                        node = item.node,
                        intervalChanged = true;

                    
                    if (node === me.currSelection && !currStatus.usingCustomInterval) {
                        itemClicked = false;
                        return;
                    }

                    if (v === 'S') {
                        if (currStatus.usingCustomInterval) {
                            currStatus.usingCustomInterval = false;
                        } else {
                            me.updateIntervalPosition();
                        }

                        if (me.currSelection) {
                            me._timeSelector.toggleSelected(me.currSelection, false);
                            me._timeSelector.toggleGlowEffect(me.currSelection, false);
                        }

                        me._timeSelector.toggleSelected(node, true);
                        me._timeSelector.toggleGlowEffect(node, true);

                        var bm = me.baseModel, tslIndex = parseInt(node.getAttribute("value"));
                        var tsl = bm.vp.rl[tslIndex];

                        
                        if ((bm.k && bm.k !== tsl.ds) && me.layoutModel) { 
                            var getData = resetBaseAndDerivedData.call(this, tsl);
                            if (!getData) {
                                return;
                            }
                        } else {
                            isDataSetChanged = false;
                        }

                        intervalChanged = node !== me.currSelection;
                        me.currSelection = node;
                        currStatus.currSelectionIdx = me.currSelection.getAttribute('value');
                        me.showMessage();

                        window.setTimeout(function () {
                            me.drawSelector(node, tsl, intervalChanged);
                        }, 10);

                    }
                }

            },

            moveMasterSlider: function moveMasterSlider(x ) {
                var me = this,
                    m = me.model,
                    width = me.getWidth(),
                    delta = Math.round(x - originalTouchPosition),
                    currStatus = chartStatus[this.chartID];

                
                
                
                
                
                
                
                
                

                
                
                this.SLXP += delta;
                this.SRXP += delta;

                this.SLXP = Math.round(this.SLXP);
                this.SRXP = Math.round(this.SRXP);

                this.makeSureMasterSliderNotBeyondTheMargin(true);
                this.setMasterSliderLayout();

                this.calculateRnsRneFromSXP();

                
                
                
                
                
                
                
                
                
                
                
                
                
                
                

                
                localUpdateScrollerConfig.call(me);
                
                if (!currStatus.usingCustomInterval && this.currSelection) {
                    this.updateIntervalPosition();
                }
            },

            updateIntervalPosition: function updateIntervalPosition() {
                var me = this,
                    m = me.model,
                    currStatus = chartStatus[this.chartID];
                
                if(me.currSelection){
                    var index = me.currSelection.getAttribute("value");
                    currStatus.timeSelectedIntervalPosition[index] = {rns: currStatus.rns, rne: currStatus.rne};
                }

            },

            drawSliderTooltipPointer: function drawSliderTooltipPointer() {
                var canvas = this.sliderTooltip.lastChild,
                    cntx = canvas.getContext('2d'),
                    width = canvas.width,
                    height = canvas.height;
                cntx.fillStyle = '#ffffff';
                cntx.beginPath();
                cntx.moveTo(0, 0);
                cntx.lineTo(width, 0);
                cntx.lineTo(width / 2, height);
                cntx.lineTo(0, 0);
                cntx.closePath();
                cntx.fill();

            },

            renderSliderTooltip: function renderSliderTooltip(sliderTooltipXPosition) {
                var me = this,
                    stt = me.sliderTooltip,
                    sttF = stt.firstChild,
                    sttP = stt.lastChild,
                    width = me.getWidth();

                var pointerPos = sliderTooltipXPosition;

                var content = getFormattedDateForSliderTooltip.call(this, sliderTooltipXPosition);
                if (content == "") {
                    content = "--";
                }

                sttF.innerHTML = content;

                var stWidth = sttF.offsetWidth,
                    stHalfWidth = stWidth / 2;

                if (sliderTooltipXPosition !== this.SLXP) {
                    
                    sliderTooltipXPosition = this.SRXP - stHalfWidth;
                } else {
                    
                    sliderTooltipXPosition -= stHalfWidth;
                }

                
                if (sliderTooltipXPosition < 0) {
                    sliderTooltipXPosition = 0;
                } else if (sliderTooltipXPosition + stWidth > width) {
                    sliderTooltipXPosition = width - stWidth;
                }

                
                sttP.style.left = (pointerPos - sliderTooltipXPosition - 3) + 'px';
                
                me.utils.translateCSS(sliderTooltipXPosition, me.sliderTooltipYPosition, false, stt);
            },

            resizeMasterSlider: function resizeMasterSlider(x ) {
                var me = this,
                    width = me.getWidth(),
                    msl = me.masterSlider,
                    msls = msl.style,
                
                    lcs = msl.parentNode.firstChild.style,
                
                    rcs = msl.parentNode.childNodes[2].style;

                var touchPoint = me.utils.getTouchXYOnWidget(x, 0, me);
                x = touchPoint.touchX;
                var fixWhich;
                if (masterSliderClicked === 'L') {
                    this.SLXP = x;
                    fixWhich = "R";
                } else {
                    this.SRXP = x;
                    fixWhich = "L";
                }

                me.makeSureMasterSliderNotBeyondTheMargin();
                me.makeSureMasterSliderNoOverlap(fixWhich);
                this.setMasterSliderLayout();

                if (masterSliderClicked === 'L') {
                    me.renderSliderTooltip(this.SLXP);
                } else {
                    me.renderSliderTooltip(this.SRXP);
                }

                chartStatus[this.chartID].usingCustomInterval = true;
                chartSizeChanged = true;
            },

            shouldTouchBubble: function shouldTouchBubble(touch) {
                
                return false;
            },

            hiddenTooltipAndShowTimeSelector: function hsctooltip() {
                if (tooltipShown) {	
                    
                    this.handleTouchEnd();
                    tooltipShown = false;
                    this.showTimeSelectorLabels();

                    var touchManager = mstrmojo.touchManager;
                    touchManager.detachEventListener(this._touchListener);
                    delete this._touchListener;
                }
            },

            
            onCrossWidgetMultitouch: function onCrossWidgetMultitouch() {
                this.hiddenTooltipAndShowTimeSelector();
            },

            touchBegin: function touchBegin(touch) {
                
                this.adjustWidgetOffsets();
                var item = this.isMasterSliderTouched(touch);
                if (item) {
                    this.hiddenTooltipAndShowTimeSelector();
                    var value = item.value;
                    if (value === 'L' || value === 'R' || value === 'MS') {
                        
                        masterSliderClicked = item.value;
                        originalTouchPosition = touch.pageX; 
                        if (item.value !== 'MS') {
                            
                            this.showMasterSliderTooltip(item);
                        }

                    } else {
                        return false;
                    }
                    
                } else if (!isScrollableElementTouched.call(this, touch)) {
                    this.hiddenTooltipAndShowTimeSelector();
                    if (this.shouldTouchBubble(touch)) {
                        
                        return this.bubbleTouchEvent(touch);
                    }
                    return false;
                }
            },

            isMasterSliderTouched: function isMasterSliderTouched(touch) {
                var item = getTouchedElement.call(this, touch);
                if (item && (item.value === 'L' || item.value === 'R')) {
                    return item;
                }

                
                var touchRadius = 45 * this.utils.getScreenZoomFactor();
                var position = this.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, this);
                var touchX = position.touchX,
                    touchY = position.touchY;

                
                var height = this.getHeight();
                if (touchY > height || touchY < height - this.masterChartHeight) {
                    return null;
                }

                if (touchX < this.SRXP && touchX > this.SLXP) {
                    return {node: this.masterSlider.childNodes[1], value: "MS"};
                }

                var LDistance = Math.abs(touchX - this.SLXP);
                var RDistance = Math.abs(this.SRXP - touchX);
                var minDistance = Math.min(LDistance, RDistance);

                if (minDistance < touchRadius) {
                    if (LDistance == minDistance) {
                        return {node: this.masterSlider.firstChild, value: "L"};
                    } else if (RDistance == minDistance) {
                        return {node: this.masterSlider.lastChild, value: "R"};
                    }
                } else {
                    return null;
                }

                return null;
            },

            touchSelectBegin: function touchSelectBegin(touch) {

                this.hiddenTooltipAndShowTimeSelector();
                var item = this.isMasterSliderTouched(touch);
                if (item) {
                    if (item.value === 'L' || item.value === 'R' || item.value === 'MS') {
                        
                        masterSliderClicked = item.value;
                        originalTouchPosition = touch.pageX; 
                    }
                } else {
                    
                    this.handleTouchBegin(touch.pageX, touch.pageY);
                }
            },

            touchSelectMove: function touchSelectMove(touch) {
                if (masterSliderClicked) {
                    if (masterSliderClicked === 'MS') {
                        
                        this.moveMasterSlider(touch.pageX);
                    } else {
                        this.resizeMasterSlider(touch.pageX);
                    }
                    originalTouchPosition = touch.pageX; 
                    return false;
                }
                
                this.handleTouchMove(touch.pageX, touch.pageY);
            },

            handleTouchSelectEnd: function handleTouchSelectEnd(touch) {
                if (masterSliderClicked) {
                    if (masterSliderClicked === 'MS') {
                        this.makeSureSliderOnPoint();
                        this.setMasterSliderLayout();
                        this.incFetchChart();
                    } else {
                        resizeMasterSliderDone.call(this);
                    }
                    return false;
                }
                
                var canBeSelected = false;
                if (touch) {
                    var nearestPoint = this.getLastHighlightPoint();
                    canBeSelected = nearestPoint && this.pointCanBeSelected(nearestPoint.rowIdx, nearestPoint.serieIdx);
                }
                if (!canBeSelected) {
                    
                    this.handleTouchEnd();

                    if (tooltipShown) {
                        tooltipShown = false;
                        this.showTimeSelectorLabels();
                    }
                } else {
                    this.seriesIndex = -1;
                }

                this.hiddenLegendTooltip();
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                this.handleTouchSelectEnd(touch);
            },

            touchMultiBegin: function touchMultiBegin(touch) {
                this.handleTouchSelectEnd();
            },

            touchSwipeMove: function touchSwipeMove(touch) {
                
                if (isScrollableElementTouched.call(this, touch) && this._super) {
                    this._super(touch);
                } else {
                    if (masterSliderClicked) {
                        if (masterSliderClicked === 'MS') {
                            
                            this.moveMasterSlider(touch.pageX);
                        } else {
                            this.resizeMasterSlider(touch.pageX);
                        }
                        originalTouchPosition = touch.pageX; 
                    }
                }
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                if (masterSliderClicked) {
                    if (masterSliderClicked === 'MS') {
                        this.makeSureSliderOnPoint();
                        this.setMasterSliderLayout();
                        this.incFetchChart();
                    } else {
                        resizeMasterSliderDone.call(this);
                    }
                    return false;
                } else if (this._super) {
                    this._super(touch);
                }
            },

            touchSelectCancel: function touchSelectCancel(touch) {
                this.touchCancel(touch);
            },

            touchCancel: function touchCancel(touch) {
                this.touchSelectEnd(touch);
            },

            touchEnd: function touchEnd(touch) {
                if (masterSliderClicked && !chartSizeChanged) {
                    hideMasterSliderTooltip.call(this);
                    masterSliderClicked = null;
                }
                this._legend.hiddenSwitcherArrowGlowEffect();
                return false;
            },

            pointCanBeSelected: function pcbs(rowIdx, serieIdx) {
                if (this.selectionOrLinkdrillOnRow) {
                    return true;
                }

                var me = this,
                    m = me.model,
                    colHeaders = m.colHeaders,
                    colHL = colHeaders.length,
                    hi = m.series[serieIdx].hi,
                    hiLength = hi.length;

                for (var i = 0; i < colHL; i++) {
                    var colH = colHeaders[i];
                    if (colH.es) {
                        
                        if (colH.sc && colH.sc.tks) {
                            return true;
                        }
                        if (colH.lm && colH.lm[0] && colH.lm[0].links) {
                            return true;
                        }
                    } else {
                        
                        if (colH.sc && colH.sc.tks) {
                            return true;
                        }
                        var lmArray = colH.lm,
                            lm = lmArray && lmArray[hi[i]];
                        if (lm && lm.links) {
                            return true;
                        }

                    }
                }

                return false;
            },

            getModelK: function getModelK() {
                var k = this.baseModel && this.baseModel.k;

                return k;
            },

            
            getActionObjList: function getActionObjList(nearestPoint, selectedAll) {
                var actionObjList = [];

                var scObjList = [];
                var actionType = 0;
                var actionObjList = [];
                var linkDrillNode = null;
                var metricColHIdx = -1;

                var me = this,
                    model = me.model,
                    riArray = model.ri,
                    ri = riArray[nearestPoint.rowIdx],
                    rowHeaders = model.rowHeaders,
                    rowHL = rowHeaders.length;
                for (var i = 0; i < rowHL; i++) {
                    var rowH = rowHeaders[i];
                    if (rowH.sc && rowH.sc.tks) {
                        if (selectedAll && (rowH.sc.all === "false" || rowH.sc.all === false)) {
                            
                            return null;
                        }
                        var scObj = {};
                        scObj.sc = rowH.sc;
                        scObj.es = rowH.es[ri[i]];
                        scObj.eid = selectedAll ? "OA:(All)" : rowH.eid[ri[i]];
                        scObjList.push(scObj);
                        actionType = rowH.at || 0;
                    }
                    if (rowH.lm && rowH.lm[0] && rowH.lm[0].links && !linkDrillNode) {
                        
                        linkDrillNode = {};
                        linkDrillNode.titleInfo = rowH;
                        linkDrillNode._e = {id: rowH.eid[ri[i]], n: rowH.es[ri[i]]};
                    }
                }

                var colHeaders = model.colHeaders,
                    colHL = colHeaders.length,
                    hi = model.series[nearestPoint.serieIdx].hi,
                    hiLength = hi.length;

                for (var i = colHL - 1; i >= 0; i--) {
                    var colH = colHeaders[i];
                    if (colH.es) { 
                        if (colH.sc && colH.sc.tks) {
                            if (selectedAll && (colH.sc.all === "false" || colH.sc.all === false)) {
                                
                                return null;
                            }
                            var scObj = {};
                            scObj.sc = colH.sc;
                            scObj.es = colH.es[hi[i]];
                            scObj.eid = selectedAll ? "OA:(All)" : colH.eid[hi[i]];
                            scObjList.push(scObj);
                            actionType = colH.at || 0;
                        }
                        if (colH.lm && colH.lm[0] && colH.lm[0].links && !linkDrillNode) {
                            
                            linkDrillNode = {};
                            linkDrillNode.titleInfo = colH;
                            linkDrillNode._e = {id: colH.eid[hi[i]], n: colH.es[hi[i]]};
                        }
                    } else {
                        if (colH.sc && colH.sc.tks) {
                            
                            if (selectedAll && (colH.sc.all === "false" || colH.sc.all === false)) {
                                
                                return null;
                            }
                            var scObj = {};
                            scObj.sc = colH.sc;
                            scObj.es = colH.items[hi[i]].n;
                            scObj.eid = selectedAll ? "OA:(All)" : colH.items[hi[i]].id;
                            scObjList.push(scObj);
                            actionType = colH.at || 0;
                        }
                        
                        metricColHIdx = i;
                    }
                }
                if (scObjList.length > 0) {
                    actionType = actionType | SELECTOR_ACTION;

                    
                    this.infoWindowAnchor.style.left = (nearestPoint.point.x - 9) + 'px';
                    this.infoWindowAnchor.style.top = (nearestPoint.point.y - 9) + 'px';

                    

                    actionObjList.push({at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: this.infoWindowAnchor});
                    return actionObjList;
                }

                
                if (!linkDrillNode) {
                    
                    var metricH = colHeaders[metricColHIdx],
                        metric = metricH.items[hi[metricColHIdx]],
                        lm = metricH.lm[hi[metricColHIdx]];
                    if (lm && lm.links) {
                        linkDrillNode = {};
                        linkDrillNode.titleInfo = metricH;
                        linkDrillNode.mix = hi[metricColHIdx];
                        
                        var currNode = linkDrillNode;
                        for (var i = 0; i < rowHL; i++) {
                            var rowH = rowHeaders[i];
                            var nodeLP = {};
                            nodeLP.titleInfo = rowH;
                            nodeLP._e = {id: rowH.eid[ri[i]], n: rowH.es[ri[i]]};

                            currNode._lp = nodeLP;
                            currNode.axis = ROW_AXIS;
                            currNode = nodeLP;
                        }

                        currNode = linkDrillNode;
                        for (var i = colHL - 1; i >= 0; i--) {
                            var colH = colHeaders[i];
                            if (colH.es) { 
                                var nodeTP = {};
                                nodeTP.titleInfo = colH;
                                nodeTP._e = {id: colH.eid[hi[i]], n: colH.es[hi[i]]};

                                currNode._tp = nodeTP;
                                currNode.axis = COL_AXIS;
                                currNode = nodeTP;
                            }
                        }
                    }
                }
                if (linkDrillNode) {
                    actionType = actionType | HYPERLINK_ACTION;

                    actionObjList.push({at: actionType, k: this.getModelK(), node: linkDrillNode});
                    return actionObjList;
                }
                return null;
            },

            getLastHighlightPoint: function gtLstHighlightPnt() {
                
                return this.lastHighlightPoint || null;
            },

            performAction: function performAction(actionObjList) {
                this.hasNonifwTarget = this.hasNoninfowindowTarget(actionObjList[0]);

                if (this._super) {
                    this._super(actionObjList);
                }

            },

            touchTap: function touchTap(touch) {
                var me = this,
                    nearestPoint = this.getLastHighlightPoint(),
                    touchPointOnWidget = me.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, me);
                var touchPointInHighlightArea = tooltipShown && getPointDistanceSquare({x: nearestPoint.point.x, y: nearestPoint.point.y}, {x: touchPointOnWidget.touchX, y: touchPointOnWidget.touchY}) <= 45 * 45;

                if (touchPointInHighlightArea) {
                    
                    me.hiddenTooltipAndShowTimeSelector();
                    nearestPoint = this.getLastHighlightPoint();
                } else {
                    nearestPoint = this.getNearestPoint(touch.pageX, touch.pageY);
                }
                if (isScrollableElementTouched.call(this, touch)) {
                    var fallInPointArea = getPointDistanceSquare({x: nearestPoint.point.x, y: nearestPoint.point.y}, {x: touchPointOnWidget.touchX, y: touchPointOnWidget.touchY}) <= 45 * 45,
                        canBeSelected = me.pointCanBeSelected(nearestPoint.rowIdx, nearestPoint.serieIdx),
                        sameAsLastSelectedPoint = me.lastSelectedPoint && (nearestPoint.rowIdx == me.lastSelectedPoint.rowIdx && nearestPoint.serieIdx == me.lastSelectedPoint.serieIdx );
                    if (fallInPointArea && canBeSelected && !sameAsLastSelectedPoint) {
                        if (tooltipShown) {
                            me.hiddenTooltipAndShowTimeSelector();
                        }
                        me.lastSelectedPoint = nearestPoint;
                        me.incFetchChart(true);

                        var actionObjList = this.getActionObjList(nearestPoint);

                        me.performAction(actionObjList);

                    }
                    else if (fallInPointArea && !canBeSelected) {
                        
                        if (touchPointInHighlightArea) {
                            
                        } else {
                            this.handleTouchBegin(touch.pageX, touch.pageY);
                        }

                    } else {
                        
                        if (tooltipShown) {
                            me.hiddenTooltipAndShowTimeSelector();
                        }
                        else if (me.lastSelectedPoint) {
                            

                            var actionObjList = this.getActionObjList(nearestPoint, true);
                            
                            if (actionObjList) {
                                me.performAction(actionObjList);
                                me.lastSelectedPoint = null;
                                me.incFetchChart(true);
                            }
                        }
                    }

                }

            },

            
            highlightSelectedPoint: function highlightSelectedPoint() {

                
                var me = this,
                    ctx = me.animationContext,
                    utils = me.utils,
                    pointInfo = me.lastSelectedPoint,
                    point = pointInfo.point,
                    currStatus = chartStatus[this.chartID];

                ctx.save();

                if (currStatus.isLegendSelected && currStatus.legendSelectedIndex != pointInfo.serieIdx) {
                    ctx.globalAlpha = 0.3;
                } else {
                    ctx.globalAlpha = 1;
                }
                
                var pointX = (pointInfo.rowIdx - me.ACrns) * me.RTX;
                
                
                
                
                
                
                
                
                
                ctx.fillStyle = me.getSerieColor(pointInfo.serieIdx);
                ctx.lineWidth = 1;
                utils.drawArc(me, pointX, point.y, 4, 0, Math.PI * 2, true, true, ctx);

                if (this.theme == LIGHT_THEME) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    utils.drawArc(me, pointX, point.y, 5, 0, Math.PI * 2, true, false, ctx);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    utils.drawArc(me, pointX, point.y, 7, 0, Math.PI * 2, true, false, ctx);
                } else {
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2;
                    utils.drawArc(me, pointX, point.y, 5, 0, Math.PI * 2, true, false, ctx);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    utils.drawArc(me, pointX, point.y, 7, 0, Math.PI * 2, true, false, ctx);
                }
                
                
                
                
                
                
                
                ctx.restore();
            },

            destroy: function destroy() {
                
                if (this.currSelection) {
                    delete this.currSelection;
                }

                
                if (this._touchListener) {
                    
                    mstrmojo.touchManager.detachEventListener(this._touchListener);
                    delete this._touchListener;
                }
                
                 if(this._scrollDoneListener){
                    this._scroller.detachEventListener(this._scrollDoneListener);
                    delete this._scrollDoneListener;
                 }
                 if(this._scrollMovedListener){
                    this._scroller.detachEventListener(this._scrollMovedListener);
                    delete this._scrollMovedListener;
                 }

                 if(this._infoWClosedListener){
                    this.xtabModel.docModel.detachEventListener(this._infoWClosedListener);
                    delete this._infoWClosedListener;
                 }



                if (this.fullScreenListener) {
                    mstrmojo.touchManager.detachEventListener(this.fullScreenListener);
                    delete this.fullScreenListener;
                }

                if (this.selectorTargets) {
                    delete this.selectorTargets;
                }

                this._super();

                if (this._tn) {
                    delete this._tn;
                }
            }


        });

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.VisTimeSeries");

    
    mstrmojo.DocVisTimeSeries = mstrmojo.declare(

        mstrmojo.VisTimeSeries,

        null,

        
        {
            scriptClass: 'mstrmojo.DocVisTimeSeries'
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.VisTimeSeries");

    
    mstrmojo.AndroidVisTimeSeries = mstrmojo.declare(

        mstrmojo.VisTimeSeries,

        null,
        
        {
            scriptClass: 'mstrmojo.AndroidVisTimeSeries'
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.Vis",
        "mstrmojo.VisMicroChartTable",
        "mstrmojo.dom",
        "mstrmojo._TouchGestures",
        "mstrmojo._HasTouchScroller",
        "mstrmojo.VisTextTooltip",
        
        "mstrmojo.hash",
        "mstrmojo.color",
        "mstrmojo.css");

    var $CLR = mstrmojo.color,
        $CSS = mstrmojo.css,
        $HASH = mstrmojo.hash,
        $forEachHash = $HASH.forEach,
        $M = Math,
        $D = mstrmojo.dom;

    var zf = 1;

    
    var PAGE_COUNT = 5;

    var TRIANGLE_WIDTH = 30;

    
    var COMPACT = 0;
    var NORMAL = 1;
    var LARGE = 2;

    var DEFAULT_TH_CSS = "border:none;word-break:break-word;white-space:normal;";
    var DEFAULT_TD_CSS = "border:none;background:transparent;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-top:0px;padding-bottom:0px;";
    var TD_SELECTED_CSS = "border:none;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-top:0px;padding-bottom:0px;";
    var TH_SELECTED_CSS = "border:none;word-break:break-word;white-sapce:normal;";

    var NO_REPLACE = 2;
    var IN_REPLACE = 3;

    var TOP_Z_INDEX = 200;

    var DOCKED_HEADER = 0,
        OTHER_ROW = 1;

    var ROW_AXIS = 1, COL_AXIS = 2;
    var DRILLING_ACTION = 1, SELECTOR_ACTION = 2, HYPERLINK_ACTION = 4;
    var linkCount = 0;
    var attrCount = 0;
    var order = [];
    var ID_NAME = {};
    var METRIC_INDEX = {};
    var METRICS = [];
    var models = [];

    var LEFT_CHART_ROW = 'leftRow';
    var RIGHT_CHART_ROW = 'rightRow';

    
    var GFL = 1;
    
    var CGL = 0;

    var textAlign = { 
        
        left: "microchart-table-text-L",
        center: "microchart-table-text-M",
        right: "microchart-table-text-R"
    };

    function getParentBkgColor() {
        var parentNode = this.domNode.parentNode;
        while (parentNode) {
            var compStyle = mstrmojo.css.getComputedStyle(parentNode);
            var bkgColor = compStyle.backgroundColor;
            if (bkgColor) {
                if (bkgColor.indexOf('rgba') >= 0) {
                    var rgba = this.utils.rgbaStr2rgba(bkgColor);
                    if (rgba && rgba[4]) {
                        return rgba;
                    }
                } else if (bkgColor.indexOf('rgb') >= 0) {
                    var rgb = $CLR.rgbStr2rgb(bkgColor);
                    return rgb;
                }

            }
            parentNode = parentNode.parentNode;
        }

        bkgColor = this.model['background-color'];
        if (bkgColor) {
            return $CLR.hex2rgb(bkgColor);
        }

        
        return  [255, 255, 255];
    }

    var DEFAULT_DARK_THEME = 1;
    var DEFAULT_LIGHT_THEME = 2;
    var CUSTOM_DARK_THEME = 3;
    var CUSTOM_LIGHT_THEME = 4;

    function getUITheme() {
        var ct = this.model.vp.ct;
        if (!ct || ct == "") {
            
            ct = "0";
        }
        this.theme = parseInt(ct);

        if (this.theme == 0) {
            
            var rgb = getParentBkgColor.call(this);

            var opacity = this.otherProps.mfBkgOpacity;
            rgb = this.utils.getRGBWithOpacity(rgb, opacity);

            
            this.backgroundColor = this.utils.rgb2rgbStr(rgb);

            var brightness = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
            if (brightness > 150) {
                this.theme = CUSTOM_LIGHT_THEME;
            } else {
                this.theme = CUSTOM_DARK_THEME;
            }
        } else if (this.theme == 1) {
            
            this.backgroundColor = '#333333';
        } else if (this.theme == 2) {
            
            this.backgroundColor = '#f9f9f9';
        }

        this.domNode.style.backgroundColor = this.backgroundColor;
    }

    function setDimensionWithDPI() {
        zf = this.utils.getScreenZoomFactor();

        var otherProps = this.otherProps;
        otherProps.mRowHeight = Math.round(zf * otherProps.mRowHeight);
        TRIANGLE_WIDTH = Math.round(zf * 36);

        this.dropShadowWidth = Math.round(zf * 7);

        paddingForSS = [Math.round(5 * zf), Math.round(8 * zf), Math.round(10 * zf)];
        colWidthForChart = [Math.round(100 * zf), Math.round(150 * zf), Math.round(200 * zf)];
        maxColWidthForAttr = [Math.round(120 * zf), Math.round(150 * zf), Math.round(180 * zf)];
        maxColWidthForMetric = [Math.round(100 * zf), Math.round(150 * zf), Math.round(200 * zf)];
        adjustWidthForColumnValue = [Math.round(20 * zf), Math.round(40 * zf), Math.round(80 * zf)];
    }

    function isScrollableElementTouched(touch) {
        if (this.enableSmoothScroll) {
            var touchPointOnWidget = this.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, this);

            var x = touchPointOnWidget.touchX,
                y = touchPointOnWidget.touchY;

            if (x < this.leftWidth) {
                return false;
            }
            return true;
        } else {
            return true;
        }
    }

    
    
    function setNodeCssText(node, cssText) {
        var height = node.style.height;
        var width = node.style.width;
        var textDecoration = node.style.textDecoration;
        var display = node.style.display;
        var fontSize = node.style.fontSize;
        var fontWeight = node.style.fontWeight;
        var paddingLeft = node.style.paddingLeft;
        var paddingRight = node.style.paddingRight;
        var boxShadow = node.style.boxShadow;
        node.style.cssText = cssText;
        node.style.height = height;
        node.style.width = width;
        node.style.textDecoration = textDecoration;
        if (display) {
            node.style.display = display;
        }
        if (fontSize) {
            node.style.fontSize = fontSize;
        }
        if (fontWeight) {
            node.style.fontWeight = fontWeight;
        }
        if (paddingLeft) {
            node.style.paddingLeft = paddingLeft;
        }
        if (paddingRight) {
            node.style.paddingRight = paddingRight;
        }
        if (boxShadow) {
            node.style.boxShadow = boxShadow;
        }
        
        
        
        
        
        
        
        
    }

    function init(w) {
        METRICS = [];
        METRIC_INDEX = {};
        ID_NAME = {};
        order = [];
        models = [];
        GFL = 1;
        CGL = 0;
        linkCount = 0;
        attrCount = 0;
    }

    function initProp() {
        
        
        
        
        
        
        var sparklineProps = this.sparklineProps = {};
        sparklineProps.mbShow = true;
        sparklineProps.mbAllPoints = false;
        sparklineProps.mbEndPoints = true;
        sparklineProps.mbRefLine = true;
        sparklineProps.mbRefArea = true;
        sparklineProps.mbAssMetric = true;
        sparklineProps.mbShowTooltip = true;
        sparklineProps.mwSeriesLineCol = "#333333";
        sparklineProps.mwRefLineCol = "#0066FF";
        sparklineProps.mwRefAreaCol = "#DEDEDE";
        sparklineProps.mstrHeader = "[Sparkline]";
        sparklineProps.mstrAssMetric = "";

        var barProps = this.barProps = {};
        barProps.mbShow = false;
        barProps.mbShowLegend = true;
        barProps.mbRefLine = true;
        barProps.mbShowTooltip = true;
        barProps.mwPosCol = "#66CC00";
        barProps.mwNegCol = "#FF0000";
        barProps.mwRefLineCol = "#0066FF";
        barProps.mstrHeader = "[Bar]";

        var bulletProps = this.bulletProps = {};
        bulletProps.mbShow = true;
        bulletProps.mbRefLine = true;
        bulletProps.mbRefBands = true;
        bulletProps.mbShowLegend = true;
        bulletProps.mbAssMetric = true;
        bulletProps.mbInvertAxis = false;
        bulletProps.mbShowTooltip = true;
        bulletProps.mfMinValue = 0;
        bulletProps.mwPosCol = "#000066";
        bulletProps.mwNegCol = "#FF0000";
        bulletProps.mwRefLineCol = "#0066FF";
        bulletProps.mwBand1 = "#999999";
        bulletProps.mwBand2 = "#BBBBBB";
        bulletProps.mwBand3 = "#DEDEDE";
        bulletProps.mstrHeader = "[Bullet]";
        bulletProps.mstrAssMetric = "";
        bulletProps.mstrBand1 = "Low";
        bulletProps.mstrBand2 = "Medium";
        bulletProps.mstrBand3 = "High";

        var otherProps = this.otherProps = {};
        otherProps.mfBkgOpacity = 1.0;
        otherProps.mnMetricsPerKPI = 1;
        otherProps.mbHideColHeaders = false;
        otherProps.mbHideTextColumns = false;
        otherProps.mbLockLayout = false;
        otherProps.mbShowForHiddenGraphs = true;
        otherProps.mbInheritFromGridGraph = false;
        otherProps.mbInSingleColumnMode = false;

        otherProps.mpColumnIDs = [];
        otherProps.mpColumnIDsInTreeMode = [];
        otherProps.mpColumnPositions = null;
        otherProps.mpColumnWidths = null;
        otherProps.mpSortKey = null;

        otherProps.mbSortDescend = true;

        
        otherProps.mRowHeight = 36;
        
        
        
        
        

    }

    function isTouchedOnWidget(touch) {

        if (!touch) {
            return false;
        }
        var me = this;

        var pos = mstrmojo.dom.position(this.domNode);

        
        
        

        var x = touch.pageX - pos.x,
            y = touch.pageY - pos.y;

        if ((x > 0 && x < me.getWidth()) && (y > 0 && y < me.getHeight())) {
            return true;
        }
        return false;
    }

    
    function convertToColor(intString) {
        var colorString = parseInt(intString).toString(16);
        var len = colorString.length;
        for (var i = len; i < 6; i++) {
            colorString = "0" + colorString;
        }
        colorString = "#" + colorString;
        return colorString;
    }

    function buildNonTreeRows() {
        this.rows = [];
        for (var i = 0; i < models.length; i++) {
            this.rows[i] = {model: models[i],
                rowIdx: i,
                selected: {},
                rowRef: {}};
        }
    }

    function isSubTotal(row, rowTitles) {
        for (var i = 0; i < row.length; i++) {
            if (row[i].etk != undefined && row[i].etk < 0) {
                return true;
            }
        }
        return false;
    }

    
    function getAttrIdxArray(w) {

        var attrIDArray = w.attrIDArray;

        var m = w.model, gts = m.gts, rows = gts.row;
        var id = rows[0].id;

        attrIDArray[0] = id;
        for (var i = 1; i < rows.length; i++) {
            if (id == rows[i].id || id == rows[i].id + ":CG") {
                
                
            } else {
                
                id = rows[i].id;
                attrIDArray[i] = id;
            }
        }
    }

    
    function getTreeNode(tree, treePath) {
        var treePathArray = treePath.split("_");
        var treeNode = tree;
        for (var i = 0; i < treePathArray.length; i++) {
            var idx = treePathArray[i];
            treeNode = treeNode.childrenTreeNodeList[idx];
        }
        return treeNode;
    }

    function getPreSiblingTreeNode(tree, treePath) {
        var treePathArray = treePath.split("_");
        var lowestLevelIdx = treePathArray[treePathArray.length - 1];
        if (lowestLevelIdx > 0) {
            
            treePathArray[treePathArray.length - 1] = lowestLevelIdx - 1;
            var treeNode = tree;
            for (var i = 0; i < treePathArray.length; i++) {
                var idx = treePathArray[i];
                treeNode = treeNode.childrenTreeNodeList[idx];
            }
            return treeNode;
        } else {
            return null;
        }
        return null;
    }

    function getParentTreeNodeAtLevel(tree, treePath, level) {
        var treePathArray = treePath.split("_");
        var treeNode = tree;
        for (var i = 0; i <= level; i++) {
            var idx = treePathArray[i];
            treeNode = treeNode.childrenTreeNodeList[idx];
        }
        return treeNode;
    }

    function getBoolValue(value) {
        if (value === true || value === "true") {
            return true;
        }
        return false;
    }

    
    function setNeedExpandToLevel(tree, level) {
        if (!tree) {
            return;
        }

        if (tree.level <= level) {
            tree.needExpand = true;
        } else {
            tree.needExpand = false;
        }

        var treeNodeList = tree.childrenTreeNodeList;

        for (var j = 0; j < treeNodeList.length; j++) {
            setNeedExpandToLevel(treeNodeList[j], level);
        }

    }

    function initTree() {

        this.tree = {};
        this.tree.childrenTreeNodeList = [];
        this.tree.needExpand = true;
        
        this.tree.treePath = "";
        this.tree.level = -1;

        this.attrIDArray = [];

        
        this.currSelectedObj = [];
        this.lastSelectedObj = [];

        this.initDockedHeadersDone = false;
    }

    
    
    
    
    
    
    

    
    function compareTreePath(src, des) {
        var count = src.length;
        if (des.length != count) {
            return false;
        }
        for (var i = 0; i < count - 1; i++) {
            if (src[i] != des[i].idx) {
                return false;
            }
        }
        return true;
    }

    
    function convertDataToTreeModels(AttrIndexes) {
        var treeNodeList = this.tree.childrenTreeNodeList,
            model = this.model,
            rhs = model.ghs.rhs,
            rowTitles = model.gts.row,
            gvs = model.gvs,
            expsTree = model.vp.exps && model.vp.exps.tree;
        var allExpanded = expsTree && getBoolValue(expsTree.allExpanded);
        
        var mcStatus = this.mcStatus;
        var expandToLevel = -1;
        var expandedEntryArray = mcStatus ? mcStatus.expandedEntryArray : expsTree && expsTree.expandedEntry;

        this.attrIDArray = [];

        var attrIdxArray = this.attrMapIdx;

        
        getAttrIdxArray(this);

        var rowAttrCount = rhs.items && rhs.items[0] && rhs.items[0].items
            && rhs.items[0].items.length;
        
        var levelCount = attrIdxArray.length - 1;
        this.maxTreeLevel = levelCount - 2;

        expandToLevel = mcStatus ? mcStatus.expandToLevel : allExpanded ? this.maxTreeLevel - 1 : -1;

        var lastTreePath = [];
        
        for (var i = 0; i < rowAttrCount; i++) {
            lastTreePath.push(-1);
        }
        var modelIdx = -1;
        var gridRowCount = rhs.items.length;
        if (this.mcStatus && this.mcStatus.currSelectedObj) {
            this.currSelectedObj = this.mcStatus.currSelectedObj;
        }
        for (var i = 0; i < gridRowCount; i++) {
            var currRow = rhs.items[i].items;
            var sameAsLastRow = compareTreePath(lastTreePath, currRow);
            if (!sameAsLastRow) {
                modelIdx++;
            } else {
                continue;
            }

            
            for (var j = 0; j < levelCount - 1; j++) {
                var attrIdx = attrIdxArray[j];
                var currSelectedNodeID = this.currSelectedObj[j];
                if (lastTreePath[attrIdx] != currRow[attrIdx].idx) {
                    var isSubtotal = isSubTotal(currRow);
                    
                    var addToNodeList = treeNodeList;
                    var lastSameNode = null;
                    
                    var treePath = "";
                    for (var k = 1; k <= j; k++) {
                        var treeNodeIdx = addToNodeList.length - 1;
                        if (k == j) {
                            lastSameNode = addToNodeList[treeNodeIdx];
                        }
                        addToNodeList = addToNodeList[treeNodeIdx].childrenTreeNodeList
                        treePath += treeNodeIdx;
                        treePath += "_";
                    }

                    if (isSubtotal && lastSameNode) {
                        lastSameNode.model = models[modelIdx];
                        break;
                    } else {

                        
                        var newTreeNode = {};
                        newTreeNode.es = [];
                        
                        newTreeNode.es.push(rowTitles[j].es[currRow[attrIdx].idx]);
                        
                        var elem = rowTitles[j].es[currRow[attrIdx].idx];
                        newTreeNode.id = elem.id;
                        newTreeNode.n = elem.n;

                        newTreeNode.model = models[modelIdx];

                        newTreeNode.selected = false;
                        newTreeNode.childrenTreeNodeList = [];
                        
                        newTreeNode.attrElemIdx = currRow[attrIdx].idx;
                        newTreeNode.isLeaf = (j == this.maxTreeLevel);
                        newTreeNode.level = j;

                        var preSiblingCount = addToNodeList.length;
                        newTreeNode.preSiblingCount = preSiblingCount;
                        newTreeNode.preSibling = preSiblingCount > 0 ? addToNodeList[preSiblingCount - 1] : null;

                        treePath += addToNodeList.length;
                        newTreeNode.treePath = treePath;

                        
                        

                        addToNodeList.push(newTreeNode);

                        
                        newTreeNode.needExpand = j <= expandToLevel ? true : false;

                        
                        if (currSelectedNodeID == newTreeNode.id) {
                            this.currSelectedObj[j] = newTreeNode;
                        }

                    }
                }
            }
            
            for (var j = 0; j < rowAttrCount; j++) {
                lastTreePath[j] = currRow[j].idx;
            }
        }

        if (expandToLevel < 0 && expandedEntryArray) {
            

            for (var i = 0; i < expandedEntryArray.length; i++) {
                var expandedEntry = expandedEntryArray[i];
                var treeNode = this.tree;
                for (var j = 0; j < expandedEntry.length; j++) {
                    var eid = expandedEntry[j].element;
                    var idx = mstrmojo.array.find(
                        treeNode.childrenTreeNodeList, 'id', eid);
                    if (idx < 0) {
                        break;
                    }
                    treeNode = treeNode.childrenTreeNodeList[idx];
                }
                treeNode.needExpand = true;
            }
        }

        
        var preOrderTreeNodeQueue = [];
        preOrderTreeNodeQueue.push(this.tree);
        var treeNode = null;
        
        while (preOrderTreeNodeQueue.length > 0) {
            treeNode = preOrderTreeNodeQueue.pop();
            var treeNodeList = treeNode.childrenTreeNodeList;
            var childrenCount = treeNodeList.length;
            for (var i = childrenCount - 1; i >= 0; i--) {
                treeNode = treeNodeList[i];
                preOrderTreeNodeQueue.push(treeNode);
                treeNode.postSiblingCount = childrenCount - treeNode.preSiblingCount;
            }

        }

    }

    
    var ATTR_NAME = 0,
        METRIC_NAME = 1,
        METRIC_VALUE = 2,
        CHART = 3,
        TREE_TRIANGLE = 4;
    DROP_SHADOW = 5;

    function scaleColumnWidthToFitWidget(colInfos, fitToWidth) {
        var colLen = colInfos.length;
        var totalWidth = 0;
        for (var i = 0; i < colLen; i++) {
            if (colInfos[i].type == TREE_TRIANGLE) {
                
                fitToWidth -= TRIANGLE_WIDTH;
            } else {
                totalWidth += colInfos[i].colWidth;
            }
        }

        var scaleRatio = fitToWidth / totalWidth;

        for (var i = 0; i < colLen; i++) {
            if (colInfos[i].type == TREE_TRIANGLE) {
                colInfos[i].colWidth = TRIANGLE_WIDTH;
            } else {
                colInfos[i].colWidth = Math.round(colInfos[i].colWidth * scaleRatio);
            }
        }

        return scaleRatio;
    }

    function getContentOffsetWidth(rows, rowIdx, colIdx) {
        var rowInfo = rows[rowIdx],
            curM = rowInfo.model,
            elms = curM.elms,
            treeNode = rowInfo.treeNode,
            colInfos = this.colInfos,
            rowIdx = rowInfo.rowIdx,
            colCount = colInfos.length,
            colInfo = colInfos[colIdx],
            colIdx = colInfo.colIdx;

        if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_NAME) {
            if (this.isTreeMode) {
                var attrName = "";
                for (var k = 0; k < treeNode.es.length; k++) {
                    attrName += treeNode.es[k].n;
                }
                
                if (attrName.indexOf("&lt;") >= 0) {
                    attrName = attrName.replace(/&lt;/g, "<");
                    attrName = attrName.replace(/&gt;/g, ">");
                }

                return this.getTextWidth(attrName, colInfo.valueCssClass, null, null, null, treeNode.level == 0 ? true : false);

            } else {
                attr = elms[colInfo.order];
                var attrName = attr ? attr.n : "";
                
                if (attrName.indexOf("&lt;") >= 0) {
                    attrName = attrName.replace(/&lt;/g, "<");
                    attrName = attrName.replace(/&gt;/g, ">");
                }
                return this.getTextWidth(attrName, colInfo.valueCssClass, null, null, null, false);

            }

        }

        if (colInfo.type == METRIC_VALUE) {
            var metricIdx = -1;
            var idx = -1;

            if (this.isKPI) {
                
                idx = parseInt(colInfo.order) % this.otherProps.mnMetricsPerKPI;

                
                var metricIdx = rowInfo.model.metricIdx + idx;
            } else {
                if (colInfo.type == METRIC_VALUE) {
                    metricIdx = parseInt(colInfo.order);
                    idx = metricIdx;
                }
            }

            var innerHTML = "";
            var cssClass = "";

            if (curM.refv[idx].ti === undefined) { 
                if (curM.refv[idx].ts === 4) { 
                    innerHTML = "<img src='" + curM.refv[idx].v + "'/>";
                } else {
                    innerHTML = curM.refv[idx].v;
                }
            } else { 
                try { 
                    
                    var model = this.model;
                    var th = model.th['' + metricIdx];
                    var ti = curM.refv[idx].ti;

                    if (curM.refv[idx].ty === 4) { 
                        var path;
                        if (th[ti] && th[ti].n) {
                            path = th[ti].n;
                        } else {
                            path = curM.refv[idx].v;
                        }
                        if (path.indexOf(":") >= 0) { 
                            
                        } else { 
                            var baseURL;
                            try {
                                baseURL = mstrApp.getConfiguration().getHostUrlByProject(mstrApp.getCurrentProjectId());
                            } catch (err) {
                                baseURL = "";
                            }
                            path = baseURL + path;
                        }
                        innerHTML = "<img src='" + path + "'/>";
                    } else {
                        if (th[ti] && th[ti].n && th[ti].cni !== undefined) { 
                            innerHTML = th[ti].n;
                        } else {
                            innerHTML = curM.refv[idx].v;
                        }
                        
                        
                    }
                    cssClass = model.css[th[ti].cni].n;
                } catch (err) {
                    if (!innerHTML) { 
                        innerHTML = curM.refv[idx].v;
                    }
                }
            }

            var className = "";
            if (cssClass) {
                className = colInfo.valueCssClass + " " + cssClass;
            } else if (this.valueCssClass) {
                className = colInfo.valueCssClass + " " + this.valueCssClass;
            } else {
                className = colInfo.valueCssClass;
            }

            return this.getTextWidth(innerHTML, className, null, null, null, this.isTreeMode && treeNode.level == 0 ? true : false);

        }

        return 0;

    }

    
    var paddingForSS = [5, 8, 10];
    var colWidthForChart = [100, 150, 200];
    var maxColWidthForAttr = [120, 150, 180];
    var maxColWidthForMetric = [100, 150, 200];
    var adjustWidthForColumnValue = [20, 40, 80];

    function updateColumnWidth() {
        var colInfos = this.colInfos,
            width = this.getWidth();

        if (this.enableSmoothScroll) {
            
            var rows = this.isTreeMode ? getTreeNodeRows.call(this, true, 50) : this.rows;
            var rowCount = Math.min(rows.length, 50);
            var mcs = this.metricColumnsSpacing;
            var paddingWidth = paddingForSS[mcs];

            for (var j = 0; j < this.colInfos.length; j++) {
                var colInfo = this.colInfos[j];

                if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_NAME || colInfo.type == METRIC_VALUE) {

                    
                    var maxColumnValueW = 0;
                    for (var i = 0; i < rowCount; i++) {
                        var columnW = getContentOffsetWidth.call(this, rows, i, j);
                        if (columnW > maxColumnValueW) {
                            maxColumnValueW = columnW;
                        }
                    }

                    
                    var headerStr = colInfo.title;
                    var midPos = Math.round(headerStr.length / 2);

                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    var leftHalf = headerStr.slice(0, midPos);
                    var rightHalf = headerStr.slice(midPos);

                    var leftW = this.getTextWidth(leftHalf, colInfo.headerCssClass, null, null, null, true, false);
                    var rightW = this.getTextWidth(rightHalf, colInfo.headerCssClass, null, null, null, true, false);
                    var maxColumnHeaderW = Math.max(leftW, rightW);

                    var finalColumnW = 0;
                    if (maxColumnValueW > maxColumnHeaderW) {
                        finalColumnW = Math.min(maxColumnValueW, maxColWidthForMetric[mcs]);
                    } else {
                        finalColumnW = Math.min(maxColumnValueW + adjustWidthForColumnValue[mcs], maxColumnHeaderW, 100);
                    }

                    colInfo.colWidth = Math.round(finalColumnW + paddingWidth);
                    colInfo.padding.l = Math.floor(paddingWidth / 2);
                    colInfo.padding.r = Math.ceil(paddingWidth / 2);
                } else if (colInfo.type == TREE_TRIANGLE) {
                    colInfo.colWidth = Math.round(TRIANGLE_WIDTH);
                } else if (colInfo.type == DROP_SHADOW) {
                    colInfo.colWidth = Math.round(this.dropShadowWidth);
                } else {
                    
                    colInfo.colWidth = Math.round(colWidthForChart[mcs] + paddingWidth);
                    colInfo.padding.l = Math.floor(paddingWidth / 2);
                    colInfo.padding.r = Math.ceil(paddingWidth / 2);
                }
            }

            
            this.leftWidth = 0;
            for (var i = 0; i < this.attrColumnCount; i++) {
                this.leftWidth += colInfos[i].colWidth;
            }

            this.rightWidth = 0;
            var maxMetricWidth = 0;
            for (var i = this.attrColumnCount; i < colInfos.length; i++) {
                console.log(i + ": " + colInfos[i].colWidth);
                this.rightWidth += colInfos[i].colWidth;
                if (colInfos[i].colWidth > maxMetricWidth) {
                    maxMetricWidth = colInfos[i].colWidth;
                }
            }

            if (this.leftWidth + this.rightWidth < this.getWidth()) {
                
                var scaleRatio = scaleColumnWidthToFitWidget(this.colInfos, this.getWidth());

                this.dropShadowDiv.style.display = "none";
                this.enableSmoothScroll = false;
                this.scrollerConfig.hScroll = false;

                this.leftWidth = this.getWidth();
                this.rightWidth = 0;
                this.leftChart.style.width = this.getWidth() + 'px';
            } else {
                
                if (this.attrColumnCount >= 0) {
                    
                    var spaceCol = {order: "",
                        type: DROP_SHADOW,
                        title: "",
                        titleAlign: textAlign.center,
                        colWidth: this.dropShadowWidth,
                        padding: {},
                        headerCssClass: this.headerCssClass,
                        valueCssClass: "",
                        colIdx: this.colInfos.length};
                    this.colInfos.splice(this.attrColumnCount, 0, spaceCol);
                    this.rightWidth += this.dropShadowWidth;
                }

                
                var requiredSpace = this.leftWidth + maxMetricWidth + this.dropShadowWidth;
                if (this.getWidth() < requiredSpace) {
                    var rightContainWidth = Math.min(maxMetricWidth + this.dropShadowWidth, 0.75 * this.getWidth());
                    this.leftWidth = this.getWidth() - rightContainWidth;

                    
                    var attrWidth = this.treeColumnIdx > -1 ? (this.leftWidth - TRIANGLE_WIDTH) / (this.attrColumnCount - 1) : this.leftWidth / this.attrColumnCount;
                    for (var i = 0; i < this.attrColumnCount; i++) {
                        colInfos[i].colWidth = colInfos[i].type == TREE_TRIANGLE ? TRIANGLE_WIDTH : attrWidth;
                    }

                }

                this.dropShadowDiv.style.display = "block";
                this.scrollerConfig.hScroll = true;

                this.leftChart.style.width = this.leftWidth + 'px';
                this.rightChart.style.width = this.rightWidth + 'px';
                this.itemsContainerNode.style.width = ( this.getWidth() - this.leftWidth ) + 'px';
                this.itemsContainerNode.style.left = this.leftWidth + 'px';
            }

            for (var i = 0; i < this.colInfos.length; i++) {
                
                this.colInfos[i].colIdx = i;

                if (this.colInfos[i].type == TREE_TRIANGLE) {
                    this.treeColumnIdx = i;
                }
            }

        } else {
            
            var colLen = colInfos.length;

            if (this.otherProps.mpColumnWidths.length > 0) {
                
                scaleColumnWidthToFitWidget(this.colInfos, width);
            } else {
                if (this.treeColumnIdx > -1) {
                    colLen--;
                    width -= TRIANGLE_WIDTH;
                }
                var chWidth = Math.round(width / colLen);
                for (var i = 0; i < colInfos.length; i++) {
                    if (colInfos[i].type == TREE_TRIANGLE) {
                        colInfos[i].colWidth = TRIANGLE_WIDTH;
                    } else {
                        colInfos[i].colWidth = chWidth;
                    }

                }
            }
        }

    }

    
    function buildColInfos(metricColIdx) {
        var m = this.model,
            rows = m.gts.row,
            cols = m.gts.col,
            mes = cols[metricColIdx].es,
            propValue = m.vp ? m.vp : {},
            width = this.getWidth(),
            otherProps = this.otherProps;

        otherProps.mpColumnWidths = propValue.cw ? propValue.cw.split(",") :
            (propValue.tcw ? propValue.tcw.split(",") : [] );

        var columnWidths = otherProps.mpColumnWidths;
        
        if (columnWidths.length != order.length) {
            columnWidths = [];
            otherProps.mpColumnWidths = [];
        }

        this.colInfos = [];

        this.showGauge = false;
        for (var i = 0; i < order.length; i++) {
            if (order[i] == "GaugeChart") {
                
                
                this.showGauge = true;
            }
        }

        for (var i = 0, colInfoIdx = 0; i < order.length; i++) {
            var orderID = order[i];

            var colInfo = {order: orderID,
                colWidth: 0,
                padding: {},
                headerCssClass: " ",
                valueCssClass: " "};

            if (orderID == "LineChart") {
                colInfo.type = CHART;
                colInfo.title = this.sparklineProps.mstrHeader;
                colInfo.titleAlign = textAlign.center;
                colInfo.padding.l = Math.round(3 * zf);
                colInfo.padding.r = Math.round(3 * zf);
            } else if (orderID == "BarChart") {
                colInfo.type = CHART;
                colInfo.title = this.barProps.mstrHeader;
                colInfo.titleAlign = textAlign.center;
                colInfo.padding.l = Math.round(3 * zf);
                colInfo.padding.r = Math.round(3 * zf);
            } else if (orderID == "GaugeChart") {
                colInfo.type = CHART;
                colInfo.title = this.bulletProps.mstrHeader;
                colInfo.titleAlign = textAlign.center;
                colInfo.padding.l = Math.round(3 * zf);
                colInfo.padding.r = Math.round(3 * zf);
            } else if (orderID == 'Metric') {
                if (otherProps.mbHideTextColumns) {
                    
                    
                    this.treeColumnIdx = -1;
                    continue;
                }
                colInfo.type = METRIC_NAME;
                colInfo.title = mstrmojo.desc(1158, 'Metrics');
                colInfo.titleAlign = textAlign.left;
                colInfo.valueCssClass += " " + this.valueCssClass;
                if (cols[metricColIdx].lm && cols[metricColIdx].lm.length > 0) {
                    colInfo.lm = cols[metricColIdx];
                    linkCount++;
                }
            } else if (orderID != parseInt(orderID)) {
                
                if (otherProps.mbHideTextColumns) {
                    
                    
                    this.treeColumnIdx = -1;
                    continue;
                }

                
                
                colInfo.associateAttr = [];

                if (this.isTreeMode) {
                    
                    
                    this.treeColumnIdx = colInfoIdx;
                    this.colInfos[colInfoIdx] = {order: orderID,
                        type: TREE_TRIANGLE,
                        title: "",
                        titleAlign: textAlign.center,
                        colWidth: 0,
                        padding: {},
                        headerCssClass: this.headerCssClass,
                        valueCssClass: "",
                        colIdx: this.treeColumnIdx};
                    

                    colInfo.associateAttr.push(colInfoIdx);

                    colInfoIdx++;
                }
                colInfo.type = ATTR_NAME;
                colInfo.title = ID_NAME[orderID];
                colInfo.titleAlign = textAlign.left;
                colInfo.valueCssClass += " " + this.valueCssClass;

                for (var j = 0; j < rows.length; j++) {
                    if (orderID.split(":")[0] == rows[j].id) {
                        

                        if (otherProps.mbInheritFromGridGraph && rows[j].cni !== undefined && m.css.length > rows[j].cni) {
                            colInfo.titleAlign = m.css[rows[j].cni].n;
                        }

                        var isFirstAttrForm = (orderID == rows[j].id + ":" + rows[j].fid);

                        if (isFirstAttrForm) {
                            
                            attrCount++;
                        }

                        if (rows[j].lm && rows[j].lm.length > 0 && rows[j].lm[0].links) {
                            colInfo.lm = rows[j];
                            if (isFirstAttrForm) {
                                linkCount++;
                            }

                        }

                        
                        var fs = rows[j].fs;
                        for (var q = 0; q < fs.length; q++) {
                            var attrID = rows[j].id + ":" + fs[q].id;
                            if (attrID == orderID) {
                                
                                continue;
                            } else {
                                
                                
                                for (var n = 0; n < order.length; n++) {
                                    if (order[n] == attrID) {
                                        colInfo.associateAttr.push(n);
                                        break;
                                    }
                                }
                            }
                        }
                        break;
                    }
                }
            } else {
                
                colInfo.type = METRIC_VALUE;
                var index = parseInt(orderID);
                if (index >= mes.length) {
                    continue;
                }
                if (otherProps.mbInheritFromGridGraph && mes[index].cni !== undefined && m.css.length > mes[index].cni) {
                    colInfo.titleAlign = m.css[mes[index].cni].n;
                } else {
                    colInfo.titleAlign = textAlign.right; 
                }
                if (orderID == "0") {
                    if (this.sparklineProps.mstrAssMetric) {
                        
                        colInfo.title = this.sparklineProps.mstrAssMetric;
                    } else if (this.isKPI) {
                        colInfo.title = "";
                    } else {
                        colInfo.title = mes[index].n;
                    }
                } else if (orderID == "2") {
                    if (this.bulletProps.mstrAssMetric) {
                        
                        colInfo.title = this.bulletProps.mstrAssMetric;
                    } else if (this.isKPI && this.showGauge) {
                        colInfo.title = "";
                    } else {
                        colInfo.title = mes[index].n;
                    }
                } else {
                    colInfo.title = mes[index].n;
                }
                if (cols[metricColIdx].lm[index].links) {
                    colInfo.lm = cols[metricColIdx];
                    linkCount++;
                }

            }

            colInfo.valueCssClass += " microchart-table-text " + colInfo.titleAlign;
            colInfo.headerCssClass += " microchart-table-text " + colInfo.titleAlign + " " + this.headerCssClass;

            if (columnWidths.length > 0) {
                colInfo.colWidth = parseFloat(columnWidths[i]);
            }
            colInfo.colIdx = colInfoIdx;
            this.colInfos[colInfoIdx++] = colInfo;
        }

        if (order.length == 0) {
            colInfos[0].title = rows[0].n;
            for (var i = 1; i < rows.length - GFL; i++) {
                colInfos[i].title = rows[i].n;
            }
        }

        
        if (this.enableSmoothScroll) {
            var belongToLeft = function (type) {
                switch (type) {
                case ATTR_NAME:
                    return -1;
                case TREE_TRIANGLE:
                    return -1;
                case METRIC_NAME:
                    return -1;
                default:
                    return 1;
                }
            }

            var sortFunc = function (colInfo1, colInfo2) {
                if (belongToLeft(colInfo1.type) * belongToLeft(colInfo2.type) > 0) {
                    
                    return colInfo1.colIdx < colInfo2.colIdx ? -1 : 1;
                } else {
                    return belongToLeft(colInfo1.type);
                }
            }

            this.colInfos.sort(sortFunc);

            for (var i = 0; i < this.colInfos.length; i++) {
                if (belongToLeft(this.colInfos[i].type) > 0) {
                    
                    this.attrColumnCount = i;
                    break;
                }
            }

        }

    }

    function convertDataToModels() {
        init(this);

        var m = this.model,
            cols = m.gts.col,
            metricL = m.gts.col[0].es.length,
            rows = m.gts.row,
            rowL = rows.length,
            rl = m.gvs.items.length,
            propValue = m.vp ? m.vp : {};

        if (rowL === 0 || metricL === 0 || cols.length > 1) {
            var errmsg = "The widget requires at least two attributes on row axis and one metrics in column axis OR exactly one attribute on row axis and at least one metric on column axis for KPI List mode.";
            m.err = mstrmojo.desc(8424, errmsg);
            return;
        }

        
        if (this.isTreeMode) {
            var row = this.model.gts.row;
            if (row.length < 3) {
                this.isTreeMode = false;
            }

        }

        var len = rows.length;
        var gfid = rows[len - 1].id;
        len = len - 2;
        while (len >= 0) {
            if (gfid == rows[len].id) {
                GFL++;
                len--;
            } else {
                break;
            }
        }

        if (rowL <= GFL) {
            this.isKPI = true;
        }
        for (var i = 0; i < rows.length; i++) {
            if (rows[i].otp == 1) {
                
                rows[i].otp = -1;
                while (++i < rows.length && rows[i].otp == 1) {
                    rows[i].id += ":CG";
                    rows[i].n = " ";
                    rows[i].otp = -1;
                }
            }
        }

        for (var i = 0; i < rows.length; i++) {
            if (rows[i].fs && rows[i].fs.length > 0) {
                for (var q = 0; q < rows[i].fs.length; q++) {
                    
                    if (q == 0) {
                        ID_NAME[rows[i].id + ":" + rows[i].fs[q].id] = rows[i].n;
                    } else {
                        ID_NAME[rows[i].id + ":" + rows[i].fs[q].id] = " ";
                    }
                }
            }
            if (rows[i].fid && rows[i].fid.length > 0) {
                
                
                
                var headerTitle;
                headerTitle = rows[i].n; 
                ID_NAME[rows[i].id] = headerTitle;
                ID_NAME[rows[i].id + ":" + rows[i].fid] = headerTitle;
            } else {
                ID_NAME[rows[i].id] = rows[i].n;
            }
        }

        
        var metricIdx = -1;
        for (var i = 0; i < cols.length; i++) {
            if (cols[i].n = "Metrics") {
                metricIdx = i;
                var mes = cols[i].es;
                for (var j = 0; j < mes.length; j++) {
                    ID_NAME[mes[j].oid] = mes[j].n;
                    METRIC_INDEX[mes[j].n] = j;
                    METRIC_INDEX[mes[j].oid] = j;
                    METRICS[j] = mes[j].n;
                }
            }
        }

        var orderValid = true;
        if (!propValue.co && !propValue.tco) {
            orderValid = false;
        } else {
            order = propValue.tco ? propValue.tco.split(",") : propValue.co.split(",");
            orderValid = processAndCheckOrderValid.call(this);
            if (!orderValid) {
                
                propValue.cw = null;
                propValue.tcw = null;
            }
        }

        if (!orderValid) {
            order = [];

            if (!this.isKPI) {
                createNonKPIDefaultCol.call(this);
            } else {
                createKPIDefaultCol.call(this);

            }
        }

        var otherProps = this.otherProps;
        
        

        if (otherProps.mpSortKey && otherProps.mpSortKey.length > 0) {
            var tempSortKey = "";
            for (var i = 0; i < otherProps.mpSortKey.length; i++) {
                if (otherProps.mpSortKey[i] == '_') {
                    break;
                }
                tempSortKey += otherProps.mpSortKey[i];
            }

            var mIdx = METRIC_INDEX[tempSortKey];
            if (mIdx >= 0) {
                
                otherProps.mpSortKey = mIdx
            } else {
                
                for (var id in ID_NAME) {
                    if (ID_NAME[id] == tempSortKey) {
                        otherProps.mpSortKey = id;
                        break;
                    }
                }

                if (!ID_NAME[otherProps.mpSortKey]) {
                    
                    otherProps.mpSortKey = null;
                }
            }
        } else {
            otherProps.mpSortKey = null;
        }

        
        
        if (otherProps.mbInheritFromGridGraph && (this.theme == CUSTOM_DARK_THEME || this.theme == CUSTOM_LIGHT_THEME)) {
            try {
                var headerIndex = m.headercni ? m.headercni : 0;
                var valueIndex = m.valuecni ? m.valuecni : (m.css.length - 1);

                var getCssClass = function (name) {
                    if (name) {
                        
                        return name;
                    }

                    return "";

                }

                this.headerCssClass = getCssClass(m.css[headerIndex].n);
                this.valueCssClass = getCssClass(m.css[valueIndex].n);

                
                if (this.valueCssClass && this.valueCssClass.length > 0) {
                    var textSpan = this.textSpan;
                    textSpan.className = this.valueCssClass;
                    textSpan.style.font = "";

                    this.fontSize = mstrmojo.css.getStyleValue(textSpan, 'fontSize');

                }

                
                var fontHeight = this.getTextHeight("a", this.valueCssClass, true);
                if (fontHeight > otherProps.mRowHeight) {
                    otherProps.mRowHeight = fontHeight;
                }
            } catch (err) {
                
            }
        }

        
        var applyLocale = function (proOwner, proName, dftStr, hasBracket, descID) {
            var compareStr = dftStr;
            var returnStr;
            if (hasBracket) {
                compareStr = "[" + dftStr + "]";
            }

            if (proOwner[proName] === compareStr) {
                
                returnStr = mstrmojo.desc(descID, dftStr);
                if (hasBracket) {
                    returnStr = "[" + returnStr + "]";
                }
                proOwner[proName] = returnStr;
            }
        };

        buildColInfos.call(this, metricIdx);

        if (!this.isKPI) {
            convertAttributeDrivenData(this);
        } else {

            convert(this);
        }

        
        var kpi = otherProps.mnMetricsPerKPI;
        var m = this.model;

        if (this.isKPI && metricL < kpi) {
            var errmsg = "Metric per KPI should be at least 1 or less than or equal to the total number of Metrics in the widget";
            m.err = errmsg;
            return;
        }

        if (models.length == 0) {
            var errmsg = "No data returned for this view, this might be because the applied filter excludes all data";
            m.err = errmsg;
            return;
        }

        this.buildRows();

        updateColumnWidth.call(this);

        this.showMinLabel = bulletShowMinLabel.call(this);

    }

    
    function processAndCheckOrderValid() {

        for (var i = 0; i < order.length; i++) {
            if (order[i] == "LineChart" || order[i] == "BarChart"
                || order[i] == "GaugeChart" || order[i] == "Metric") {
                
                continue;
            }
            if (order[i].length < 3) {
                return false;
            }
            var tstStr = order[i];
            var len = tstStr.length;

            if (tstStr[len - 2] == '|') {
                order[i] = tstStr = tstStr.substring(0, len - 2);
            }
            if (!ID_NAME[tstStr]) {
                return false;
            } else if (METRIC_INDEX[tstStr] !== undefined) {
                
                order[i] = METRIC_INDEX[tstStr] + "";
            } else if (this.isKPI) {
                order[i] = "0";
            }
        }

        if (this.enableSmoothScroll) {
            return false;
        }

        var m = this.model,
            metricES = m.gts.col[0].es;
        var columnIDs = [],
            cIDs = [];
        if (this.isTreeMode) {
            columnIDs = this.otherProps.mpColumnIDsInTreeMode;
            if (columnIDs.length == 1) {
                return false;
            }

            for (var i = 0; i < metricES.length; i++) {
                var metricID = metricES[i].oid;
                cIDs.push(metricID);
            }
        } else {
            
            columnIDs = this.otherProps.mpColumnIDs;
            if (this.isKPI) {
                if (columnIDs.length <= 1) {
                    
                    
                    return false;
                }

                cIDs.push("Metric");
                var metricPerKPI = this.otherProps.mnMetricsPerKPI;
                if (metricPerKPI > 2) {
                    for (var i = 0; i < metricPerKPI; i++) {
                        if (i % metricPerKPI <= 1) {
                            
                            continue;
                        }
                        var metricID = metricES[i].oid;
                        cIDs.push(metricID);
                    }
                }

            } else {
                if (columnIDs.length == 1) {
                    return false;
                }
                var rows = m.gts.row,
                    attrCnt = rows.length - 1,
                    rowHeaderCnt = 0;

                for (var i = 0; i < attrCnt; i++) {
                    var attr = rows[i],
                        attrFormCnt = attr.fs && attr.fs.length;
                    cIDs.push(attr.id);

                    for (var j = 1; j < attrFormCnt; j++) {
                        cIDs.push(attr.fs[j].id);
                    }
                    rowHeaderCnt += attrFormCnt;
                }

                for (var i = 0; i < metricES.length; i++) {
                    var metricID = metricES[i].oid;
                    cIDs.push(metricID);
                }

            }

        }

        if (cIDs.length != columnIDs.length) {
            return false;
        }
        for (var i = 0; i < cIDs.length; i++) {
            var metricID = cIDs[i];
            if (mstrmojo.array.indexOf(columnIDs, metricID) == -1) {
                
                return false;
            }
        }

        return true;
    }

    function createKPIDefaultCol() {
        var ind = 0;
        var otherProps = this.otherProps,
            sparklineProps = this.sparklineProps,
            barProps = this.barProps,
            bulletProps = this.bulletProps;

        order[ind++] = "Metric";
        var kpi = otherProps.mnMetricsPerKPI;
        if (isNaN(kpi)) {
            kpi = 1;
        }
        var firstChartShow = false;
        if (sparklineProps.mbShow) {
            firstChartShow = true;
            order[ind++] = "LineChart";
        }
        if (barProps.mbShow) {
            firstChartShow = true;
            order[ind++] = "BarChart";
        }
        if ((!firstChartShow && otherProps.mbShowForHiddenGraphs)
            || (firstChartShow && sparklineProps.mbAssMetric)) {
            
            
            order[ind++] = "0";
        }

        if (kpi >= 7) {
            if (bulletProps.mbShow) {
                if (bulletProps.mbAssMetric) {
                    order[ind++] = "2";
                }
                order[ind++] = "GaugeChart";
            } else if (otherProps.mbShowForHiddenGraphs) {
                for (var i = 3; i <= kpi && i <= 7; i++) {
                    order[ind++] = "" + (i - 1);
                }
            }
            for (var i = 8; i <= kpi; i++) {
                order[ind++] = "" + (i - 1);
            }
        } else {
            for (var i = 3; i <= kpi; i++) {
                order[ind++] = "" + (i - 1);
            }
        }
    }

    function createNonKPIDefaultCol() {
        var ind = 0;
        var m = this.model,
            rows = m.gts.row,
            cols = m.gts.col;
        var mtrcNum = 0;

        if (this.isTreeMode) {
            order[ind++] = rows[0].id;
        } else {

            for (var i = 0; i < rows.length - GFL; i++) {
                if (rows[i].fs && rows[i].fs.length > 0) {
                    for (var q = 0; q < rows[i].fs.length; q++) {
                        order[ind++] = rows[i].id + ":" + rows[i].fs[q].id;
                    }
                } else {
                    if (rows[i].fid && rows[i].fid.length > 0) {
                        order[ind++] = rows[i].id + ":" + rows[i].fid;
                    } else {
                        order[ind++] = rows[i].id;
                    }
                }
            }
        }

        for (var i = 0; i < cols.length; i++) {
            if (cols[i].n = "Metrics") {
                mtrcNum = cols[i].es.length;
            }
        }

        var firstChartShow = false;
        if (this.sparklineProps.mbShow) {
            firstChartShow = true;
            order[ind++] = "LineChart";
        }
        if (this.barProps.mbShow) {
            firstChartShow = true;
            order[ind++] = "BarChart";
        }
        if ((!firstChartShow && this.otherProps.mbShowForHiddenGraphs)
            || (firstChartShow && this.sparklineProps.mbAssMetric)) {
            
            
            order[ind++] = "0";
        }

        if (mtrcNum >= 7) {
            if (this.bulletProps.mbShow) {
                if (this.bulletProps.mbAssMetric) {
                    order[ind++] = "2";
                }
                order[ind++] = "GaugeChart";
            } else if (this.otherProps.mbShowForHiddenGraphs) {
                for (var i = 3; i <= 7 && i <= mtrcNum; i++) {
                    order[ind++] = "" + (i - 1);
                }
            }
            for (var i = 8; i <= mtrcNum; i++) {
                order[ind++] = "" + (i - 1);
            }
        } else {
            for (var i = 3; i <= mtrcNum; i++) {
                order[ind++] = "" + (i - 1);
            }
        }
    }

    function convertAttributeDrivenData(w) {
        var m = w.model,
            metricES = m.gts.col[0].es,
            rows = m.gts.row,
            gvsRows = m.gvs.items,
            rl = m.gvs.items.length,
            rhs = m.ghs.rhs.items;

        var rowsLen = rows.length;
        
        var lai = rows.length - GFL;
        
        var slai = lai - 1;

        var idxPos = 0;
        w.attrMapIdx = []; 
        
        var attrMapIdx = w.attrMapIdx;
        for (var q = 0; q < rowsLen; q++) {
            attrMapIdx[q] = idxPos;
            if (!rows[q].fs || rows[q].fs.length == 0) {
                idxPos++;
            } else {
                idxPos += rows[q].fs.length;
            }
        }

        
        attrMapIdx[rowsLen] = idxPos;

        var attrName = rows[lai].dn || rows[lai].n;

        var fnCopyArray = function (src, isIdx) {
            var dest = [];
            for (var i = 0; i < src.length; i++) {
                dest[i] = src[i];
            }
            return dest;
        };

        
        w.ctlMatrix = {};
        w.isAllAttrSelectable = true;
        for (var i = 0; i < lai; i++) {
            var attribute = rows[i];
            if (!attribute.sc || !attribute.sc.tks || attribute.sc.tks == "") {
                w.isAllAttrSelectable = false;
                continue;
            }

            w.ctlMatrix[attribute.id] = {
                es: attribute.es,
                sc: attribute.sc,
                map: [],
                selectedIdx: {},
                colIdx: w.getColIdx(attribute.id)
            };

            
            if (attribute.sc.all && attribute.sc.allSelected) {
                w.ctlMatrix[attribute.id].selectedIdx["-1"] = true;
            }
        }

        
        var AttrIndexes = [];
        var i = 0, j = 0;
        var template = [];
        var tempLen = 0;
        for (i = 0; i < rhs.length; i++) {
            if (i === 0) {
                
                AttrIndexes[0] = [];
                for (j = 0; j < rhs[i].items.length; j++) {
                    AttrIndexes[0][j] = rhs[0].items[j].idx;
                    if (AttrIndexes[0][j] < 0 && rows[j].otp == -1) {
                        
                        AttrIndexes[0][j] = rows[j].es.length + AttrIndexes[0][j - 1];
                    }
                    
                    if (rhs[0].items[j].cet) {
                        var id = rhs[0].items[j].cet;
                        if (order[j] == id + ":CG") {
                            
                            id += ":CG";
                        }
                        var controlMatrix = w.ctlMatrix[id];
                        if (controlMatrix && !controlMatrix.selectedIdx[-1]) {
                            
                            controlMatrix.selectedIdx[AttrIndexes[0][j]] = true;
                        }
                    }
                }
                template = fnCopyArray(AttrIndexes[0]);
                tempLen = template.length;
                continue;
            }
            var rhsRow = rhs[i].items;
            var rhsRowLen = rhsRow.length;
            for (j = 1; j <= rhsRowLen; j++) {
                template[tempLen - j] = rhsRow[rhsRowLen - j].idx;

                if (template[tempLen - j] < 0) {
                    
                    var k = 0;
                    for (; k < attrMapIdx.length; k++) {
                        if (tempLen - j < attrMapIdx[k]) {
                            break;
                        }
                    }
                    template[tempLen - j] = rows[k - 1].es.length + rhsRow[rhsRowLen - j - 1].idx;
                }
                if (rhsRow[rhsRowLen - j].cet) {
                    var id = rhsRow[rhsRowLen - j].cet;
                    if (order[rhsRowLen - j] == id + ":CG") {
                        
                        id += ":CG";
                    }
                    var controlMatrix = w.ctlMatrix[id];
                    if (controlMatrix) {
                        delete controlMatrix.selectedIdx[-1];
                        controlMatrix.selectedIdx[template[tempLen - j]] = true;
                    }
                }
            }
            AttrIndexes[i] = fnCopyArray(template);
        }

        var fnBEL = function (index) {
            var elms = {};
            var ind = 0;
            for (var i = 0; i < rows.length - GFL; i++) {
                var fL = rows[i].fs.length;
                if (fL < 1) {
                    fL = 1;
                }
                var attId = rows[i].id;
                if (AttrIndexes[index][ind] < 0) {
                    elms[attId] = "";
                } else {
                    elms[attId] = rows[i].es[AttrIndexes[index][ind]];
                }

                if (elms[attId] == undefined) {
                    elms[attId] = {n: ""};
                }

                var fidId = rows[i].fid;
                if (fidId && fidId.length > 0) {
                    elms[attId + ":" + fidId] = rows[i].es[AttrIndexes[index][ind]];
                }
                for (var j = 0; j < fL; j++) {
                    var formId = "";
                    if (rows[i].fs && rows[i].fs[j]) {
                        formId = rows[i].fs[j].id;
                    }
                    if (formId && formId.length > 0) {
                        var afID = attId + ":" + formId;
                        elms[afID] = rows[i].es[AttrIndexes[index][ind]];
                    }
                    ind++;
                }
            }

            return elms;
        };

        var s = {
            v: [],
            rv: [],
            thClr: [],
            hi: [ 0 ]
        };
        var referValue = [];
        var sortValue = 0;
        var attrElems = null;
        var ch = [
            {
                items: [
                    {
                        n: metricES[0].n
                    }
                ]
            }
        ];

        var c = [],
            baseRow = [],
            j = 0, si = 0,
            isTotal = false,
            compareResult = false;

        function indexChanged(baseRow, newRow) {
            
            if (baseRow.length != newRow.length) {
                return true;
            }
            var endIndex = attrMapIdx[lai] - 1;
            if (endIndex >= baseRow.length) {
                endIndex = baseRow.length - 1;
            }
            for (var i = endIndex; i >= 0; i--) {
                
                if (baseRow[i] != newRow[i]) {
                    return true;
                }
            }
            return false;
        }

        for (var i = 0; i <= rl; i++) {
            if (i === 0) {
                baseRow = AttrIndexes[i];
            } else if ((compareResult = (i === rl || indexChanged(baseRow,
                AttrIndexes[i])))
                || isTotal) {
                if (isTotal && !compareResult) {
                    
                    
                } else {
                    
                    for (var x = 0; x < lai; x++) {
                        var controlMatrix = w.ctlMatrix[rows[x].id];
                        if (controlMatrix) {
                            controlMatrix.map[si] = AttrIndexes[i - 1][x];
                        }
                    }
                    models[si] = {
                        sortV: sortValue,
                        isTotal: isTotal,
                        refv: referValue,
                        elms: attrElems,
                        tr: s.v[s.v.length - 1],
                        model: {
                            categories: {
                                items: c,
                                tn: attrName
                            },
                            mtrcs: {
                                items: METRICS
                            },
                            colHeaders: ch,
                            series: [ s ],
                            rowHeaders: [
                                {
                                    n: rows[lai].n
                                }
                            ]
                        }
                    };
                    si++;
                    if (i === rl) {
                        break; 
                    }
                }
                
                s = {
                    v: [],
                    rv: [],
                    thClr: [],
                    hi: [ 0 ]
                };
                referValue = [];

                c = [];

                baseRow = AttrIndexes[i];
                j = 0;
                isTotal = false;
            }

            var otherProps = w.otherProps;

            
            
            
            for (var p = 0; p < gvsRows[i].items.length; p++) {
                if (!referValue[p]) {
                    referValue[p] = {};
                }
                referValue[p] = gvsRows[i].items[p];
            }

            attrElems = fnBEL(i);

            if (otherProps.mpSortKey != null) {
                var sortByAttr = ( otherProps.mpSortKey != parseInt(otherProps.mpSortKey) );
                if (sortByAttr) {
                    sortValue = attrElems[otherProps.mpSortKey].n;
                } else {
                    
                    sortValue = parseFloat(referValue[otherProps.mpSortKey].rv);
                }

            }

            if (!w.isTreeMode) { 
                
                
                
                var isSubTotal = function (attr) {
                    return (attr.id && attr.id.substring(0, 1) === "D")
                        || (attr.id === undefined && attr.n === "Total")
                }
                var attrSlai = rows[slai].es[AttrIndexes[i][attrMapIdx[slai]]];
                if (attrSlai && isSubTotal(attrSlai)) {
                    
                    isTotal = true;
                    continue;
                }

                var attr = rows[lai].es[AttrIndexes[i][attrMapIdx[lai]]];
                if (attr && isSubTotal(attr)) {
                    
                    
                    continue;
                }
            }

            var attrElement = "";
            var attIdxPos = attrMapIdx[lai];
            var thisAtt = null;
            var thisAttFormLen = 1;
            try {
                for (var p = 0; p < GFL; p++) {
                    thisAtt = rows[lai + p];
                    if (thisAtt.fs && thisAtt.fs.length > 0) {
                        
                        thisAttFormLen = thisAtt.fs.length;
                    } else {
                        thisAttFormLen = 1;
                    }
                    for (var pp = 0; pp < thisAttFormLen; pp++) {
                        attrElement += " " + thisAtt.es[AttrIndexes[i][attIdxPos]].n;
                        attIdxPos++;
                    }
                }
            } catch (err) {
                
            }

            c[j] = attrElement;

            var item = gvsRows[i].items[0];
            s.v[j] = item.v;
            s.rv[j] = item.rv;

            var th = m.th && m.th['0'];
            var ti = item.ti;
            
            if (ti != undefined && item.ty == 2 && th[ti].cni != undefined && otherProps.mbInheritFromGridGraph) {
                this.textSpan.className = m.css[th[ti].cni].n;
                var compStyle = mstrmojo.css.getComputedStyle(this.textSpan);
                s.thClr[j] = compStyle.backgroundColor;
                if (s.thClr[j] == "rgba(0, 0, 0, 0)") {
                    s.thClr[j] = null;
                }
            } else {
                s.thClr[j] = null;
            }

            j++;
        }

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        

        

        if (!w.isTreeMode && otherProps.mpSortKey != null) {
            var rowCount = models.length;
            for (var i = 0; i < rowCount; i++) {
                for (var j = 0; j < rowCount - 1; j++) {
                    if ((otherProps.mbSortDescend && models[j].sortV < models[j + 1].sortV)
                        || (!otherProps.mbSortDescend && models[j].sortV > models[j + 1].sortV)) {
                        var temp = models[j];
                        models[j] = models[j + 1];
                        models[j + 1] = temp;
                    }
                }
            }
        }

        if (w.isTreeMode) {
            
            convertDataToTreeModels.call(w, AttrIndexes);

        }

    }

    function convert(w) {
        var m = w.model,
            rows = m.gts.row,
            cols = m.gts.col,
            cs = rows[rows.length - 1].es,
            sn = cols[0].es,
            idxItems = m.ghs.rhs.items,
            csl = idxItems.length,
            v = m.gvs.items,
            ch = [];

        for (var i = 0; i < sn.length; i++) {
            if (!ch[0]) {
                ch[0] = {
                    items: []
                };
            }
            ch[0].items[i] = [
                {
                    n: sn[i].n
                }
            ];
        }

        var vl = v[0].items.length;

        var series = [];
        var c = [];
        var attrName = m.gts.row[0].dn || m.gts.row[0].n;

        var referValue = [];
        var kpi = w.otherProps.mnMetricsPerKPI;
        if (isNaN(kpi)) {
            kpi = 1;
        }
        var sNum = 0;
        var metrixIdxArray = [];
        for (var i = 0; i + kpi <= vl; i = i + kpi) {
            var fv = [];
            var rv = [];
            series[sNum] = {
                v: fv,
                rv: rv,
                hi: [ 0 ]
            };
            var refV = [];
            referValue[sNum] = {
                refv: refV
            };
            for (var j = 0; j < kpi; j++) {
                referValue[sNum].refv[j] = v[csl - 1].items[i + j];
            }
            metrixIdxArray[sNum] = i;
            sNum++;
        }

        for (var i = 0; i < csl; i++) {
            var idxItemsItems = idxItems[i].items;
            
            var idx = idxItemsItems[idxItemsItems.length - 1].idx;
            if (isNaN(idx)) {
                console.log("idx is not a number!" + idx);
                
                c[i] = cs[i].n;
            } else {
                if (idx < 0) {
                    c[i] = "";
                } else {
                    c[i] = cs[idx].n;
                }
                
                for (var k = 2; k <= idxItemsItems.length && k <= rows.length; k++) {
                    
                    var anotherIdx = idxItemsItems[idxItemsItems.length - k].idx;
                    if (!isNaN(anotherIdx)) {
                        
                        c[i] = rows[rows.length - k].es[anotherIdx].n + " " + c[i];
                    }
                }

            }
            var ind = 0;
            for (var j = 0; j + kpi <= vl; j = j + kpi) {
                series[ind].v[i] = v[i].items[j].v;
                series[ind].rv[i] = v[i].items[j].rv;
                ind++;
            }
        }

        var sl = series.length;
        for (var i = 0; i < sl; i++) {
            var elmsValue = {};
            elmsValue[m.gts.row[0].id] = ch[0].items[i * kpi][0];
            if (m.gts.row[0].fid) {
                elmsValue[m.gts.row[0].id + ":" + m.gts.row[0].fid] = ch[0].items[i * kpi][0];
            }
            elmsValue["Metric"] = ch[0].items[i * kpi][0];
            models[i] = {
                refv: referValue[i].refv,
                elms: elmsValue,
                tr: series[i].v[series[i].v.length - 1],
                model: {
                    categories: {
                        items: c,
                        tn: attrName
                    },
                    mtrcs: {
                        items: METRICS
                    },
                    series: [ series[i] ],
                    colHeaders: [
                        {
                            items: ch[0].items[i]
                        }
                    ],
                    rowHeaders: [
                        {
                            n: rows[0].n
                        }
                    ]
                },
                metricIdx: metrixIdxArray[i]
            };
        }
    }

    function bulletShowMinLabel() {
        var showMinLabel = false;
        var otherProps = this.otherProps;
        if (this.showGauge) {
            var minValue = this.bulletProps.mfMinValue;
            var count = models.length;
            for (var i = 0; i < count; i++) {
                var v = models[i].refv[2];
                if (v && v.rv < minValue) {
                    showMinLabel = true;
                    otherProps.mRowHeight = otherProps.mRowHeight > 36 ? otherProps.mRowHeight : 36;
                    break;
                }

            }

        }

        return showMinLabel;
    }

    function getFirstRowUnderDockedHeader(yPos) {
        var scl = this.getChartWithScrollBar()._scroller;
        var y = yPos || scl && scl.origin && scl.origin.y;
        var rowOffsetHeight = this.rowOffsetHeight;

        var rowIdx = this.startCnt + parseInt(y / rowOffsetHeight) + this.dockedHeaderRows.length;
        var rowPast = y % rowOffsetHeight;

        var rowInfo = getRowAtIdx.call(this, rowIdx);

        return{rowInfo: rowInfo, treeNode: rowInfo.treeNode, pastOffset: rowPast, rowIdx: rowIdx};
    }

    function getRowAtIdx(rowIdx) {
        if (rowIdx < 0) {
            rowIdx = 0;
        }
        var maxRowIdx = this.rows.length - 1;
        if (rowIdx > maxRowIdx) {
            rowIdx = maxRowIdx;
        }

        return this.rows[rowIdx];
    }

    
    function getTreeNodeRows(allExpand, rowCnt) {
        var preOrderTreeNodeQueue = [];
        var treeNode = null;
        var rows = [];

        
        var treeNodeList = this.tree.childrenTreeNodeList;
        var childrenCount = treeNodeList.length;
        for (var i = childrenCount - 1; i >= 0; i--) {
            preOrderTreeNodeQueue.push(treeNodeList[i]);
        }

        var rowCount = 0;
        
        while (preOrderTreeNodeQueue.length > 0) {
            treeNode = preOrderTreeNodeQueue.pop();
            var row = {treeNode: treeNode,
                model: treeNode.model,
                rowIdx: rowCount,
                selected: treeNode.selected,
                rowRef: {}};
            rows.push(row);
            if (!allExpand) {
                treeNode.rowIdx = rowCount++;
            }

            if (rowCnt && rowCount >= rowCnt) {
                break;
            }
            if (treeNode.needExpand || allExpand) {
                treeNodeList = treeNode.childrenTreeNodeList;
                childrenCount = treeNodeList.length;
                for (var i = childrenCount - 1; i >= 0; i--) {
                    preOrderTreeNodeQueue.push(treeNodeList[i]);
                }
            }
        }

        return rows;

    }

    function getLowestLevelOnScreen() {
        var scl = this.getChartWithScrollBar()._scroller;
        var y = scl && scl.origin && scl.origin.y;
        var rowOffsetHeight = this.rowOffsetHeight;

        var firstRowIdx = this.startCnt + parseInt(y / rowOffsetHeight);
        var chartHeight = Math.min(this.chartTableMaxHeight, parseInt(this._leftChart.itemsContainerNode.style.height));
        var lastRowIdx = this.startCnt + parseInt((y + chartHeight) / rowOffsetHeight);

        if (firstRowIdx < 0) {
            firstRowIdx = 0;
        }
        if (lastRowIdx >= this.rows.length) {
            lastRowIdx = this.rows.length - 1;
        }

        var lowestLevel = -1;
        for (var i = firstRowIdx; i <= lastRowIdx; i++) {
            var currLevel = this.rows[i].treeNode.level;
            if (currLevel > lowestLevel) {
                lowestLevel = currLevel;
            }
        }

        return lowestLevel;
    }

    function removeChildren(container) {
        var count = container && container.childNodes && container.childNodes.length;
        for (var i = 0; i < count; ++i) {
            container.removeChild(container.firstChild);
        }

    }

    function hasScrollDownPast(yPos) {
        return yPos < 0;
    }

    function expandOrCollapseTreeAndSetScrlPos(levelToExpand, anchorRowTreeNode, anchorRowIdxOnScrn) {

        if (this.expandToLevel == levelToExpand) {
            
            return;
        }

        setNeedExpandToLevel(this.tree, levelToExpand);

        this.expandToLevel = levelToExpand;

        this.rowsNeedRebuild = true;

        this.reRenderChartWithAnchor(anchorRowTreeNode, anchorRowIdxOnScrn);

        setChartTableHeight.call(this);

        this.reBuildDH(levelToExpand);

    }

    function expandTreeNodeAndSetScrlPos(rowInfo, rowType) {
        var treeNode = rowInfo.treeNode;

        treeNode.needExpand = true;

        this.expandToLevel = -1;

        var scl = this.getChartWithScrollBar()._scroller;

        var currRowIdx = rowInfo.rowIdx;

        this.reRenderChart(scl.origin);

        setChartTableHeight.call(this);

        if (currRowIdx == this.startCnt + parseInt(scl.origin.y / this.rowOffsetHeight) + this.dockedHeaderRows.length) {
            

            var rowIdxList = [];
            var currRowTreeNode = rowInfo.treeNode;
            while (currRowTreeNode.needExpand) {
                
                
                rowIdxList.push(currRowIdx);
                currRowTreeNode = getRowAtIdx.call(this, ++currRowIdx).treeNode;
            }
            this.addRowsToDH(rowIdxList);

            
        }

        
        var rowOffsetHeight = this.rowOffsetHeight;
        var lastRowOnScrnIdx = this.startCnt + Math.round((scl.origin.y + this.chartTableHeight) / rowOffsetHeight) - 1;
        if (currRowIdx == lastRowOnScrnIdx) {
            var scroller = scl;
            var maxYPos = Math.min(scl.origin.y + 2 * rowOffsetHeight, scl.offset.y.end);
            scl.origin.y = maxYPos;

            $D.translate(scroller.scrollEl, -scroller.origin.x, -scroller.origin.y, 0, scroller.transform, scroller.useTranslate3d);

            

            this.onScrollMoved({y: maxYPos});
        }

    }

    function getIdxByRowIdx(rows, targetIdx) {
        var rowCount = rows.length;
        for (var i = 0; i < rowCount; i++) {
            var rowInfoDH = rows[i];
            if (rowInfoDH.rowIdx == targetIdx) {
                return i;
            }
        }
        return -1;
    }

    function collapseTreeNodeAndSetScrlPos(rowInfo, rowType) {
        var treeNode = rowInfo.treeNode;
        treeNode.needExpand = false;

        this.expandToLevel = -1;

        var scl = this.getChartWithScrollBar()._scroller;

        if (rowType == DOCKED_HEADER) {

            var adjustOffset = 0;
            
            var rowCount = this.dockedHeaderRows.length;
            var dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderRows, rowInfo.rowIdx);

            if (dockedHeaderIdx >= 0) {
                this.removeRowsFromDH(rowCount - dockedHeaderIdx);
                
                this.removeChildrenForDHReplaceTable();
                this.dockedHeaderStatus = NO_REPLACE;

            } else {
                
                dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderReplaceRows, rowInfo.rowIdx);

                if (dockedHeaderIdx < 0) {
                    
                    return;
                }
                dockedHeaderIdx += rowCount;
                adjustOffset = scl.origin.y % this.rowOffsetHeight;
                this.removeChildrenForDHReplaceTable();
                this.dockedHeaderStatus = NO_REPLACE;
                
            }

            var rowCount = this.startCnt + parseInt(scl.origin.y / this.rowOffsetHeight) + dockedHeaderIdx - rowInfo.rowIdx;
            this.reRenderChart(scl.origin, rowCount, adjustOffset);
        } else if (rowType == OTHER_ROW) {

            this.reRenderChart(scl.origin);
        }

        setChartTableHeight.call(this);

    }

    var hideTooltipGlobal = function () {
        if (this.tooltip.style["display"] === "block") {
            var highLightCav = document.getElementById("highLightCav"
                + this.domNode.id);
            if (highLightCav) {
                highLightCav.id = "";
                
                
                var context = highLightCav.getContext('2d');
                context.clearRect(0, 0, highLightCav.width, highLightCav.height);
            }
            
            this.tooltip.style.display = "none";
            this.tooltipShow = false;

            if (this._touchListener) {
                var touchManager = mstrmojo.touchManager;
                touchManager.detachEventListener(this._touchListener);
                delete this._touchListener;
            }

        }
    };

    function setChartTableHeight() {
        if (!this._leftChart) {
            return;
        }

        var chartTableOffsetHeight = (this.otherProps.mbHideTextColumns && this.enableSmoothScroll) ? this._rightChart.chartTableOffsetHeight : this._leftChart.chartTableOffsetHeight;
        var headerTableOffsetHeight = (this.otherProps.mbHideTextColumns && this.enableSmoothScroll) ? this._rightChart.headerTableOffsetHeight : this._leftChart.headerTableOffsetHeight;

        var chartTableHeight = 0;
        if (chartTableOffsetHeight >= this.chartTableMaxHeight) {
            chartTableHeight = this.chartTableMaxHeight;
        } else {
            chartTableHeight = chartTableOffsetHeight;
        }

        this._leftChart.itemsContainerNode.style.height = chartTableHeight + "px";
        if (this._rightChart) {
            this._rightChart.itemsContainerNode.style.height = chartTableHeight + "px";
        }

        this.legend.style.top = (headerTableOffsetHeight + chartTableHeight) + "px";
        this.dropShadowDiv.style.height = (headerTableOffsetHeight + chartTableHeight) + "px";

        this.indicatorEl.parentNode.style.top = headerTableOffsetHeight + "px";
        this.indicatorEl.parentNode.style.height = chartTableHeight + "px";

        this.chartTableHeight = chartTableHeight;

        
        
        var scl = this.getChartWithScrollBar()._scroller;
        var yPos = scl.origin.y;
        var maxYPos = chartTableOffsetHeight - chartTableHeight + 2;
        if (yPos > maxYPos) {
            if (scl.vScroll) {
                scl.origin.y = maxYPos;
                this._leftChart.scrollTo(scl.origin);
                if (this._rightChart) {
                    this._rightChart.scrollTo(scl.origin);
                }

                var rowOffsetHeight = this.rowOffsetHeight;

                while ((yPos = yPos - rowOffsetHeight) > maxYPos) {
                    this.updateDockedHeadersByOneRow(yPos, true);
                }
                this.updateDockedHeadersByOneRow(maxYPos);

                this.firstRowIdxOnScrn = parseInt(this.startCnt + scl.origin.y / rowOffsetHeight);
            } else {
                scl.origin.y = 0;
                this._leftChart.scrollTo(scl.origin);
                if (this._rightChart) {
                    this._rightChart.scrollTo(scl.origin);
                }
                this.firstRowIdxOnScrn = parseInt(this.startCnt + scl.origin.y / rowOffsetHeight)
            }

        }

        this.updateWindowRatio();
        this.updateScrollBarPosition();
    }

    function setScrollerPosition(scrollTo) {

        var scl = this._scroller,
            icn = this.rightChart,
            offsetEnd = this.rightChart.offsetWidth - ( this.getWidth() - this.leftWidth );

        scl.origin = {
            x: scrollTo && scrollTo.x || 0,
            y: scrollTo && scrollTo.y || 0
        };

        scl.showScrollbars = true;
        scl.hScroll = (offsetEnd !== 0 && scl.noHScroll !== true) || this.scrollPast;

        if (scl.hScroll) {

            scl.offset = {
                x: {
                    start: 0,
                    end: offsetEnd
                },
                scrollPast: this.scrollPast
            };
        }

        this.utils.translateCSS(-scl.origin.x, -scl.origin.y, false, icn);
    }

    mstrmojo.VisMicroChart = mstrmojo.declare(

        mstrmojo.Vis,

        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        {

            scriptClass: 'mstrmojo.VisMicroChart',

            utils: mstrmojo.VisChartUtils,

            scrollerConfig: {
                bounces: false,
                showScrollbars: true,
                vScroll: false,
                hScroll: true,
                useTranslate3d: false
            },

            scrollPast: false,

            legendHeight: 30,

            
            selectedStyle: "background-color:#015DE6;color:#FFFFFF;",

            

            selectedClass: "",

            isAllAttrSelectable: false,

            
            prevSelected: {
                mrow: -2,
                mcol: -1
            },

            rows: [],

            dockedHeaderRows: [],

            dockedHeaderReplaceRows: [],

            rowsReusePool: [],

            unselectedRemainCells: [],

            isTreeMode: false,

            isKPI: false,

            showMinLabel: false,

            rowsNeedRebuild: true,

            lastScrollPosition: {y: 0},

            
            startCnt: -1,

            endCnt: -1,

            
            firstRowIdxOnScrn: 0,

            pageSize: 10,

            mcStatus: null,

            
            fontSize: '10pt',

            headerCssClass: '',

            valueCssClass: '',

            
            enableSmoothScroll: false,

            metricColumnsSpacing: NORMAL,

            attrColumnCount: 0,

            dropShadowWidth: 7,

            markupString: '<div id="{@id}-microchart" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};left:{@left};top:{@top};z-index:{@zIndex};position:absolute" '
                + ' mstrAttach:mousedown,mouseup,mousemove,click >'
                +
                '<div id="{@id}-microchart-left" style="width:{@leftWidth+"px"};height:{@height};left:0px;right:0px;position:absolute;z-index:1;" > </div>'
                +
                '<div id="{@id}-microchart-smoothscroll-container" class="mstrmojo-Chart {@cssClass}" style="width:{@rightWidth+"px"};height:{@height};left:{@leftWidth+"px"};top:0;position:absolute;overflow:hidden;">'
                + '<div id="{@id}-microchart-right" style="width:{@rightWidth};position:absolute;" > </div>'
                + '<div id="{@id}-drop-shadow-ss" style="position:absolute;left:0px;width:{@dropShadowWidth+"px"}" > </div>'
                + '</div>'
                +
                '<div style="display:none;position:absolute;right:0;z-index:5;height:{@legendHeight + "px"};width:{@width};border:none;background:transparent;text-decoration:none;" class="microchart-lengend-text">'
                + '<div style="position:absolute;right:0;top:0;padding-bottom:7px">'
                + '<div style="float:left;padding-top:7px;">'
                + '<div class="microchart-legend-band" ></div>'
                + '<div style="float:right;margin-right:10px;margin-left:10px;">Low</div>'
                + '</div>'
                + '<div style="float:left;padding-top:7px;">'
                + '<div class="microchart-legend-band"></div>'
                + '<div style="float:right;margin-right:10px;margin-left:10px;">Mid</div>'
                + '</div>'
                + '<div style="float:left;padding-top:7px;">'
                + '<div class="microchart-legend-band"></div>'
                + '<div style="float:right;margin-right:10px;margin-left:10px;">High</div>'
                + '</div>'
                + '</div>'
                + '</div>'
                +
                '<span id="textSpan" style="z-index:-10;visibility:hidden;-webkit-text-size-adjust: none;"></span>'
                +
                '<div id="{@id}-loading-msg" class="mstrmojo-loading-msg" style="display:none;z-index:10"></div>'
                +
                '<canvas id="textCanvas" width="900" height="500" style="z-index:-11;visibility:hidden;-webkit-text-size-adjust: none;"></canvas>'
                +
                '<div id="{@id}-tooltip" class="mstrmojo-MicroChart-tooltip" style="z-index:10;opacity: 0.9;"></div>'
                +
                '<div id="{@id}-text-tooltip" class="mstrmojo-Chart-tooltip timeseries-legend-tooltip" style="z-index:10"></div>'
                +
                '<div id="{@id}-errMsg" class="mstrmojo-message" style="width:{@width};height:{@height};top:0px;left:0px;position:absolute; display:none; z-index:30;"><div style="width:{@width};position:absolute;top:50%;text-align:center"></div></div>'
                +
                '<div id="{@id}-indicatorEl-container"  style="width:{@width};height:{@height};top:0px;left:0px;position:absolute;z-index:-5"><div></div></div>'
                +
                '</div>',

            markupSlots: {
                leftChart: function () {
                    return this.domNode.childNodes[0];
                },

                rightChart: function () {
                    return this.domNode.childNodes[1].firstChild;
                },

                dropShadowDiv: function () {
                    return this.domNode.childNodes[1].childNodes[1];
                },

                itemsContainerNode: function () {
                    return this.domNode.childNodes[1];
                },

                textSpan: function () {
                    return this.domNode.childNodes[3];
                },

                loadingMsg: function () {
                    return this.domNode.childNodes[4];
                },

                textCanvas: function () {
                    return this.domNode.childNodes[5];
                },

                tooltip: function () {
                    return this.domNode.childNodes[6];
                },

                textTooltip: function () {
                    return this.domNode.childNodes[7];
                },

                
                errorMsg: function () {
                    return this.domNode.childNodes[8];
                },

                indicatorEl: function () {
                    return this.domNode.childNodes[9].firstChild;
                },

                legend: function () {
                    return this.domNode.childNodes[2];
                },

                legendLow: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[0];
                },

                legendLowFont: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[0].childNodes[1];
                },

                legendLowBand: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[0].childNodes[0];
                },

                legendMid: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[1];
                },

                legendMidFont: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[1].childNodes[1];
                },

                legendMidBand: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[1].childNodes[0];
                },

                legendHigh: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[2];
                },

                legendHighFont: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[2].childNodes[1];
                },

                legendHighBand: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[2].childNodes[0];
                }
            },

            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            

            renderErrorMessage: function renderErrorMessage(msg) {
                var contentDiv = this.errorMsg.firstChild;
                contentDiv.innerHTML = msg; 
                this.errorMsg.style.display = 'block';
                var contentHeight = contentDiv.offsetHeight;
                contentDiv.style.marginTop = -0.5 * contentHeight;
            },

            
            getTextWidthByCanvas: function gtwCvs(text, elem, withPadding) {
                var canvas = this.textCanvas;

                var context = canvas.getContext('2d');

                var computedStyle = mstrmojo.css.getComputedStyle(elem);
                var fontStyle = computedStyle.fontStyle + " "
                    + computedStyle.fontWeight + " "
                    + computedStyle.fontSize + "/"
                    + computedStyle.fontVariant
                    + " " + computedStyle.fontFamily;

                context.font = fontStyle;

                context.textAlign = 'center';
                context.fillStyle = 'blue';

                
                var metrics = context.measureText(text);

                var result = metrics.width;

                if (withPadding) {
                    var addPadding = function (padding) {
                        if (computedStyle[padding]) {
                            result += parseInt(computedStyle[padding]);
                        }
                    }

                    addPadding("paddingLeft");
                    addPadding("paddingRight");
                }

                return result;
            },

            getTextWidth: function gtw(str, className, fontName, fontSize, fontSizeUnit, bold, withoutPadding) {
                var selfTextSpan = this.textSpan;
                if (selfTextSpan.className !== className || "") {
                    selfTextSpan.className = className || "";
                }
                if (selfTextSpan.style.fontFamily !== fontName || "") {
                    selfTextSpan.style.fontFamily = fontName || "";
                }

                var fsUnit = fontSizeUnit || "pt"

                if (fontSize) {
                    selfTextSpan.style.fontSize = fontSize + fsUnit;
                } else {
                    selfTextSpan.style.fontSize = '';
                }

                if (bold) {
                    if (selfTextSpan.style.fontWeight !== 'bold') {
                        selfTextSpan.style.fontWeight = 'bold';
                    }
                } else {
                    if (selfTextSpan.style.fontWeight !== '') {
                        selfTextSpan.style.fontWeight = '';
                    }
                }
                if (withoutPadding) {
                    selfTextSpan.style.padding = "0px 0px";
                } else {
                    selfTextSpan.style.padding = "";
                }

                selfTextSpan.innerHTML = str;
                var ret = selfTextSpan.offsetWidth;
                return ret;
            },

            getTextHeight: function gth(str, className, bold, fontFamily, fontSize) {
                
                this.textSpan.style.fontFamily = fontFamily || "";
                this.textSpan.style.fontSize = fontSize || "";
                if (bold) {
                    this.textSpan.style.fontWeight = 'bold';
                } else {
                    this.textSpan.style.fontWeight = '';
                }
                
                this.textSpan.className = className;
                
                this.textSpan.innerHTML = str;

                return this.textSpan.offsetHeight;
            },

            
            removeMCStatus: function removeMCStatus() {
                this.mcStatus = null;
                if (this.controller && this.controller.view && this.controller.view.model) {
                    this.controller.view.model.mcStatus = null;
                }
            },

            restoreMCStatus: function restoreMCStatus() {
                
                if (this.isTreeMode && this.mcStatus && this.mcStatus.currSelectedObj && this.mcStatus.currSelectedObj.length > 0) {
                    this.lastSelectedObj = $HASH.clone(this.currSelectedObj);

                }
                if (this.mcStatus && this.mcStatus.startCnt != undefined && this.mcStatus.endCnt != undefined) {
                    this.startCnt = this.mcStatus.startCnt;
                    this.firstRowIdxOnScrn = this.mcStatus.firstRowIdxOnScrn;

                    var minRowCntToCoverScreen = Math.max(this.mcStatus.endCnt - this.mcStatus.firstRowIdxOnScrn, this.minPageSize);
                    this.endCnt = Math.min(this.mcStatus.firstRowIdxOnScrn + minRowCntToCoverScreen, this.rows.length);
                }

                if (this.isTreeMode && this.mcStatus) {
                    this.replacingStartRowIdx = this.mcStatus.replacingStartRowIdx;
                    this.needReplaceCount = this.mcStatus.needReplaceCount;
                    this.lastFirstRowIdxOnScrn = this.mcStatus.lastFirstRowIdxOnScrn;
                    this.dockedHeaderStatus = this.mcStatus.dockedHeaderStatus;
                    this.lastScrollPosition = this.mcStatus.lastScrollPosition;
                }
            },

            storeMCStatus: function storeMCStatus(noNeedToStoreScrollInfo) {
                this.mcStatus = {};
                if (this.isTreeMode) {
                    this.mcStatus.expandToLevel = this.expandToLevel || -1;
                    this.mcStatus.expandedEntryArray = [];
                    if (this.mcStatus.expandToLevel < 0) {
                        
                        this.addTreeNodeToExpanedEntry(this.tree.childrenTreeNodeList, []);
                    }

                    this.mcStatus.currSelectedObj = [];

                    
                    for (var i = 0; i < this.currSelectedObj.length; i++) {
                        
                        
                        var treeNode = this.currSelectedObj[i];
                        this.mcStatus.currSelectedObj[i] = treeNode && treeNode.id;
                    }

                    
                    if (!noNeedToStoreScrollInfo) {
                        this.mcStatus.dHRowIdxList = [];
                        var dHRows = this.dockedHeaderRows;
                        for (var i = 0; i < dHRows.length; i++) {
                            this.mcStatus.dHRowIdxList.push(dHRows[i].rowIdx);
                        }
                        this.mcStatus.dHReplaceRowIdxList = [];
                        var dHRows = this.dockedHeaderReplaceRows;
                        for (var i = 0; i < dHRows.length; i++) {
                            this.mcStatus.dHReplaceRowIdxList.push(dHRows[i].rowIdx);
                        }

                        this.mcStatus.replacingStartRowIdx = this.replacingStartRowIdx;
                        this.mcStatus.needReplaceCount = this.needReplaceCount;
                        this.mcStatus.lastFirstRowIdxOnScrn = this.lastFirstRowIdxOnScrn;
                        this.mcStatus.dockedHeaderStatus = this.dockedHeaderStatus;
                        this.mcStatus.lastScrollPosition = this.lastScrollPosition;
                    }

                }

                if (!noNeedToStoreScrollInfo) {
                    this.mcStatus.startCnt = this.startCnt;
                    this.mcStatus.endCnt = this.endCnt;
                    this.mcStatus.firstRowIdxOnScrn = this.firstRowIdxOnScrn;
                    var chart = this.getChartWithScrollBar()
                    this.mcStatus.scrollTo = chart && chart._scroller.origin || {x: 0, y: 0};
                }

                if (this.enableSmoothScroll && this._scroller && this._scroller.origin) {
                    
                    this.mcStatus.hScrollPos = this._scroller.origin.x / this.rightWidth;
                }

                
                if (this.controller && this.controller.view && this.controller.view.model) {
                    this.controller.view.model.mcStatus = this.mcStatus;
                }

            },

            addTreeNodeToExpanedEntry: function addExpanedEntry(treeNodeList, parentEntry) {
                var expEntryArray = this.mcStatus.expandedEntryArray;
                var treeNodeCount = treeNodeList.length;
                for (var i = 0; i < treeNodeCount; i++) {
                    var treeNode = treeNodeList[i];
                    if (treeNode.needExpand) {
                        
                        var expandedEntry = $HASH.clone(parentEntry)
                        expandedEntry.push({element: treeNode.id});
                        expEntryArray.push(expandedEntry);
                        
                        this.addTreeNodeToExpanedEntry(treeNode.childrenTreeNodeList, expandedEntry);
                    }
                }

            },

            unrender: function unrender(ignoreDom, noNeedToStoreScrollInfo) {
                console.log("in unrender");
                if (!this.mcStatus) {
                    
                    
                    this.storeMCStatus(noNeedToStoreScrollInfo);
                }

                this.destroyChartWidget();
                if (this._super) {
                    this._super(ignoreDom);
                }
            },

            
            refresh: function refresh() {
                this.unrender(null, true);
                this.render();
            },

            initScroller: function initScroller(scroller) {
                if (this._super) {
                    this._super(scroller);
                }

                if (this.enableSmoothScroll) {
                    
                    
                    this._scrollDoneListener = this._scroller.attachEventListener('scrollDone', this.id, function () {
                        this.updateScrollBarPosition();
                        var scrl = this._scroller;
                        if (scrl) {
                            scrl.toggleScrollBars(false);
                        }

                    });

                }

            },

            updateScrollBarPosition: function updateScrollBarPosition() {
                var scroller = this._rightChart && this._rightChart._scroller;
                var scrollBar = scroller && scroller._scrollBarEls && scroller._scrollBarEls.y;

                if (scrollBar) {
                    scrollBar.style.left = (this._scroller.origin.x + this.getWidth() - this.leftWidth - 9) + "px";
                }

                scroller = this._scroller;
                scrollBar = scroller && scroller._scrollBarEls && scroller._scrollBarEls.x;

                if (scrollBar) {
                    scrollBar.style.top = (this.chartTableHeight + this._leftChart.headerTableOffsetHeight - 9) + "px";
                }
            },

            onScrollDone: function onScrollDone(evt) {
                var scrl = this.getChartWithScrollBar()._scroller;
                scrl.toggleScrollBars(false);
                if (this.partialRender) {
                    this.firstRowIdxOnScrn = parseInt(this.startCnt + evt.y / this.rowOffsetHeight);
                    if ((this.firstRowIdxOnScrn - this.startCnt <= this.pageSize && this.firstRowIdxOnScrn >= this.pageSize)
                        || this.endCnt - 1 - this.firstRowIdxOnScrn <= this.pageSize && this.endCnt != this.rows.length) {
                        
                        this.reRenderChartWhenScrollDone(scrl.origin);
                        setChartTableHeight.call(this);
                    }
                }
            },

            onScrollMoved: function onScrollMoved(evt) {
                hideTooltipGlobal.call(this);
                if (this.isTreeMode) {
                    
                    if (hasScrollDownPast(evt.y)) {
                        this._leftChart.hideDockedHeader();
                        if (this._rightChart) {
                            this._rightChart.hideDockedHeader();
                        }
                    } else {
                        this._leftChart.showDockedHeader();
                        if (this._rightChart) {
                            this._rightChart.showDockedHeader();
                        }
                    }

                    var rowOffsetHeight = this.rowOffsetHeight;
                    this.firstRowIdxOnScrn = this.startCnt + parseInt(evt.y / rowOffsetHeight);

                    var currPos = evt.y;
                    var lastPos = this.lastScrollPosition.y;
                    if (lastPos > currPos) {
                        while ((lastPos -= rowOffsetHeight) > currPos) {
                            this.updateDockedHeadersByOneRow(lastPos, true);
                        }
                        this.updateDockedHeadersByOneRow(currPos);
                    } else {
                        while ((lastPos += rowOffsetHeight) < currPos) {
                            this.updateDockedHeadersByOneRow(lastPos, true);
                        }
                        this.updateDockedHeadersByOneRow(currPos);
                    }

                    
                }
            },

            initDockedHeaders: function initDockedHeaders() {
                this._leftChart.initDHs();
                if (this._rightChart) {
                    this._rightChart.initDHs();
                }

                this.clearDockedHeader();

                var rowIdx = 0;
                var rowIdxList = [];

                var currRow = getRowAtIdx.call(this, rowIdx);
                while (currRow && currRow.treeNode.needExpand) {
                    rowIdxList.push(rowIdx);
                    currRow = getRowAtIdx.call(this, ++rowIdx);
                }

                this.addRowsToDH(rowIdxList);

                
                this.lastFirstRowIdxOnScrn = rowIdx;
                this.lastScrollPosition = {x: 0, y: 0};
                this.dockedHeaderStatus = NO_REPLACE;
            },

            clearDockedHeader: function clearDockedHeader() {
                this.removeRowsFromDH(this.dockedHeaderRows.length);
                this.removeChildrenForDHReplaceTable();
            },

            reBuildDH: function reBuildDH(level) {
                this.clearDockedHeader();

                var rows = this.rows;
                var rowIdxToCheck = this.firstRowIdxOnScrn + level;
                if (rowIdxToCheck < 0 || rowIdxToCheck >= rows.length) {
                    return;
                }
                var treeNodeToCheck = rows[rowIdxToCheck].treeNode;

                if (treeNodeToCheck.level > level) {
                    var rowIdxList = [];
                    for (var i = 0; i <= level; i++) {
                        var treeNode = getParentTreeNodeAtLevel(this.tree, treeNodeToCheck.treePath, i);
                        rowIdxList.push(treeNode.rowIdx);
                    }
                    this.addRowsToDH(rowIdxList);
                } else if (treeNodeToCheck.level == level) {
                    var rowIdxList = [];
                    for (var i = 0; i < level; i++) {
                        var treeNode = getParentTreeNodeAtLevel(this.tree, treeNodeToCheck.treePath, i);
                        rowIdxList.push(treeNode.rowIdx);
                    }
                    rowIdxList.push(treeNodeToCheck.rowIdx);
                    this.addRowsToDH(rowIdxList);
                } else if (treeNodeToCheck.level < level) {
                    var preSiblingTreeNode = getPreSiblingTreeNode(this.tree, treeNodeToCheck.treePath);
                    while (!preSiblingTreeNode) {
                        rowIdxToCheck--;
                        var treeNodeToCheck = rows[rowIdxToCheck].treeNode;
                        preSiblingTreeNode = getPreSiblingTreeNode(this.tree, treeNodeToCheck.treePath);
                    }
                    var rowIdxList = [];
                    for (var i = 0; i < treeNodeToCheck.level; i++) {
                        var treeNode = getParentTreeNodeAtLevel(this.tree, treeNodeToCheck.treePath, i);
                        rowIdxList.push(treeNode.rowIdx);
                    }
                    rowIdxList.push(preSiblingTreeNode.rowIdx);

                    var dHCount = treeNodeToCheck.rowIdx - this.firstRowIdxOnScrn;
                    rowIdxToCheck--;
                    var treeNodeToCheck = rows[rowIdxToCheck].treeNode;
                    for (var i = rowIdxList.length; i < dHCount; i++) {
                        var treeNode = getParentTreeNodeAtLevel(this.tree, treeNodeToCheck.treePath, i);
                        rowIdxList.push(treeNode.rowIdx);
                    }
                    this.addRowsToDH(rowIdxList);
                }

                this.dockedHeaderStatus = NO_REPLACE;
            },

            updateDockedHeadersByOneRow: function updateDHBOR(yPos, onlyUpdateStatus) {
                var scroller = this.getChartWithScrollBar()._scroller;
                if (!scroller.vScroll || yPos > scroller.offset.y.end || yPos < 0) {
                    
                    return;
                }

                var lastDockedHeaderRow;

                var currFirstRow = getFirstRowUnderDockedHeader.call(this, yPos);

                this.firstRowIdxOnScrn = currFirstRow.rowIdx - this.dockedHeaderRows.length;
                

                if (this.dockedHeaderStatus == IN_REPLACE) {
                    var hasReplacedRowCount = this.firstRowIdxOnScrn - this.replacingStartRowIdx;
                    if (hasReplacedRowCount >= 0) {
                        if (hasReplacedRowCount < this.needReplaceCount) {
                            lastDockedHeaderRow = this.dockedHeaderRows[this.dockedHeaderRows.length - 1];
                            if (this.firstRowIdxOnScrn > this.lastFirstRowIdxOnScrn) {
                                

                                
                                this.removeChildrenForDHReplaceTable();
                                this.shiftDockedHeaderWithRow(0, onlyUpdateStatus);

                                if (lastDockedHeaderRow) {
                                    this.removeRowsFromDH(1, true);
                                }
                            } else if (this.firstRowIdxOnScrn < this.lastFirstRowIdxOnScrn) {
                                
                                
                                this.dockedHeaderStatus = NO_REPLACE;

                                this.moveRowFromDHRplcTableToDH();

                                
                                currFirstRow = getFirstRowUnderDockedHeader.call(this, yPos);

                            }
                            this.shiftDockedHeaderWithRow(-currFirstRow.pastOffset, onlyUpdateStatus);
                        } else {
                            
                            this.dockedHeaderStatus = NO_REPLACE;

                            
                            this.removeChildrenForDHReplaceTable();
                            this.shiftDockedHeaderWithRow(0, onlyUpdateStatus);

                            
                            currFirstRow = getFirstRowUnderDockedHeader.call(this, yPos);

                        }
                    } else {
                        
                        this.dockedHeaderStatus = NO_REPLACE;

                        
                        this.moveRowFromDHRplcTableToDH();

                        
                        currFirstRow = getFirstRowUnderDockedHeader.call(this, yPos);

                    }

                }

                if (this.dockedHeaderStatus == NO_REPLACE && currFirstRow.treeNode) {
                    var currLevel = currFirstRow.treeNode.level;
                    lastDockedHeaderRow = this.dockedHeaderRows[this.dockedHeaderRows.length - 1];
                    var lastLevel = lastDockedHeaderRow ? lastDockedHeaderRow.treeNode.level : -1;
                    if (yPos > this.lastScrollPosition.y) {
                        
                        if (currLevel <= lastLevel) {
                            
                            if (lastDockedHeaderRow) {
                                this.removeRowsFromDH(1, true);
                            }
                            this.replacingRowTreeNode = currFirstRow.treeNode;
                            this.replacingStartRowIdx = this.firstRowIdxOnScrn;
                            this.needReplaceCount = lastLevel - currLevel + 1;
                            this.dockedHeaderStatus = IN_REPLACE;
                            
                            this.shiftDockedHeaderWithRow(-currFirstRow.pastOffset, onlyUpdateStatus);
                        } else if (currLevel > lastLevel) {
                            var currRowIdx = currFirstRow.rowIdx;
                            var rowIdxList = [];
                            var currRowTreeNode = currFirstRow.treeNode;
                            while (currRowTreeNode.needExpand) {
                                
                                
                                rowIdxList.push(currRowIdx);
                                
                                currRowTreeNode = getRowAtIdx.call(this, ++currRowIdx).treeNode;
                            }
                            this.addRowsToDH(rowIdxList);

                            

                        }
                    } else if (yPos < this.lastScrollPosition.y) {
                        
                        if (currLevel == lastLevel) {

                            var addedTreeNode = currFirstRow.treeNode.preSibling;
                            var currRowIdx = currFirstRow.rowIdx;
                            var rowCount = 0;
                            while (!addedTreeNode) {
                                
                                rowCount++;
                                
                                currFirstRow = getRowAtIdx.call(this, --currRowIdx);
                                addedTreeNode = currFirstRow && currFirstRow.treeNode.preSibling;
                            }
                            this.removeRowsFromDH(rowCount);

                            
                            lastDockedHeaderRow = this.dockedHeaderRows[this.dockedHeaderRows.length - 1];
                            if (lastDockedHeaderRow) {
                                this.removeRowsFromDH(1);
                            }

                            if (addedTreeNode.needExpand) {
                                var rowIdxList = [addedTreeNode.rowIdx];
                                this.addRowsToDH(rowIdxList, true);
                            } else {
                                
                            }

                            this.replacingStartRowIdx = this.firstRowIdxOnScrn;
                            this.replacingRowTreeNode = addedTreeNode;

                            this.needReplaceCount = 1;
                            this.dockedHeaderStatus = IN_REPLACE;
                            var pastOffset = yPos % this.rowOffsetHeight;
                            
                            this.shiftDockedHeaderWithRow(-pastOffset, onlyUpdateStatus);

                        } else if (currLevel > lastLevel + 1) {
                            var addedTreeNode = getParentTreeNodeAtLevel(this.tree, currFirstRow.treeNode.treePath, lastLevel + 1);

                            var rowIdxList = [addedTreeNode.rowIdx];
                            this.addRowsToDH(rowIdxList, true);

                            this.replacingStartRowIdx = this.firstRowIdxOnScrn;
                            this.replacingRowTreeNode = addedTreeNode;
                            this.needReplaceCount = currLevel - lastLevel - 1;
                            this.dockedHeaderStatus = IN_REPLACE;
                            
                            this.shiftDockedHeaderWithRow(-currFirstRow.pastOffset, onlyUpdateStatus);
                        }

                    }
                }
                this.lastScrollPosition.y = yPos;
                this.lastFirstRowIdxOnScrn = this.firstRowIdxOnScrn;
            },

            checkParentBeforeAddToDH: function checkParentBeforeAddToDH(addedRowIdx) {
                var rowInfo = this.rows[addedRowIdx];
                var treeNode = rowInfo && rowInfo.treeNode;

                var rowCount = this.dockedHeaderRows.length;
                if (rowCount != treeNode.level) {
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                }

            },

            addRowsToDH: function addRowsToDH(rowIdxList, toDHReplacingTable) {
                var rows = this.rows;
                var rowCount = rowIdxList.length;
                if (rowCount <= 0) {
                    return;
                }

                var addTo = null;
                if (toDHReplacingTable) {
                    addTo = this.dockedHeaderReplaceRows;
                } else {
                    addTo = this.dockedHeaderRows;
                    
                }

                for (var i = 0; i < rowCount; i++) {
                    var rowIdx = rowIdxList[i];
                    var rowInfo = rows[rowIdx];
                    addTo.push({rowIdx: rowIdx, treeNode: rowInfo.treeNode, rowRef: this.popFromReusePool()});
                }

                this._leftChart.addRowsToDH(rowCount, toDHReplacingTable);
                if (this._rightChart) {
                    this._rightChart.addRowsToDH(rowCount, toDHReplacingTable);
                }
            },

            removeRowsFromDH: function removeRowsFromDH(rowCount, moveToReplacingTable) {
                
                if (this._leftChart) {
                    this._leftChart.removeRowsFromDH(rowCount, moveToReplacingTable);
                }

                if (this._rightChart) {
                    this._rightChart.removeRowsFromDH(rowCount, moveToReplacingTable);
                }

                if (rowCount > this.dockedHeaderRows.length) {
                    
                    rowCount = this.dockedHeaderRows.length;
                }
                
                for (; rowCount > 0; rowCount--) {
                    var row = this.dockedHeaderRows.pop();
                    if (!moveToReplacingTable) {
                        this.pushRowRefToReusePool(row);
                    } else {
                        
                        this.dockedHeaderReplaceRows.push(row);
                    }

                }
            },

            moveRowFromDHRplcTableToDH: function moveRowFromDHRplcTableToDH() {
                this._leftChart.moveRowFromDHRplcTableToDH();
                if (this._rightChart) {
                    this._rightChart.moveRowFromDHRplcTableToDH();
                }
                this.shiftDockedHeaderWithRow(0);
                
                var row = this.dockedHeaderReplaceRows.pop();
                
                
                
                
                if (row) {
                    this.dockedHeaderRows.push(row);
                }

                

                
            },

            removeChildrenForDHReplaceTable: function removeChildrenForDHReplaceTable() {
                if (this._leftChart) {
                    this._leftChart.removeChildrenForDHReplaceTable();
                }
                if (this._rightChart) {
                    this._rightChart.removeChildrenForDHReplaceTable();
                }

                var rowCount = this.dockedHeaderReplaceRows.length;
                for (; rowCount > 0; rowCount--) {
                    var row = this.dockedHeaderReplaceRows.pop();
                    this.pushRowRefToReusePool(row);
                }
            },

            pushRowRefToReusePool: function pushRowRefToReusePool(row) {
                if (!row) {
                    return;
                }
                var rowRef = row.rowRef;
                this.rowsReusePool.push(rowRef);
                row.rowRef = {};
            },

            shiftDockedHeaderWithRow: function shiftDockedHeaderWithRow(pastOffset, onlyUpdateStatus) {

                if (onlyUpdateStatus) {
                    return;
                }
                if (this._leftChart) {
                    this.utils.translateCSS(0, pastOffset, 0, this._leftChart.dockedHeaderReplaceDiv.firstChild);
                }
                if (this._rightChart) {
                    this.utils.translateCSS(0, pastOffset, 0, this._rightChart.dockedHeaderReplaceDiv.firstChild);
                }

            },

            init: function init(props) {
                this._super(props);
            },

            initFromVisProps: function (vp) {
                initProp.call(this);
                var propValue = vp ? vp : {},
                    sparklineProps = this.sparklineProps,
                    barProps = this.barProps,
                    bulletProps = this.bulletProps,
                    otherProps = this.otherProps;

                this.isTreeMode = getBoolValue(propValue.itd);

                if (propValue.lsh) {
                    sparklineProps.mbShow = (propValue.lsh === "true");
                }
                if (propValue.lap) {
                    sparklineProps.mbAllPoints = (propValue.lap === "true");
                }
                if (propValue.lep) {
                    sparklineProps.mbEndPoints = (propValue.lep === "true");
                }
                if (propValue.lrl) {
                    sparklineProps.mbRefLine = (propValue.lrl === "true");
                }
                if (propValue.lra) {
                    sparklineProps.mbRefArea = (propValue.lra === "true");
                }
                if (propValue.lmsh) {
                    sparklineProps.mbAssMetric = (propValue.lmsh === "true");
                }
                if (propValue.let) {
                    sparklineProps.mbShowTooltip = (propValue.let === "true");
                }
                if (propValue.llsc) {
                    sparklineProps.mwSeriesLineCol = convertToColor(propValue.llsc);
                }
                if (propValue.lrlc) {
                    sparklineProps.mwRefLineCol = convertToColor(propValue.lrlc);
                }
                if (propValue.lrac) {
                    sparklineProps.mwRefAreaCol = convertToColor(propValue.lrac);
                }
                if (propValue.lh) {
                    sparklineProps.mstrHeader = propValue.lh;
                }
                if (propValue.lam) {
                    sparklineProps.mstrAssMetric = propValue.lam;
                }

                if (propValue.bsg) {
                    barProps.mbShow = (propValue.bsg === "true");
                }
                if (propValue.bl) {
                    barProps.mbShowLegend = (propValue.bl === "true");
                }
                if (propValue.brl) {
                    barProps.mbRefLine = (propValue.brl === "true");
                }
                if (propValue.bet) {
                    barProps.mbShowTooltip = (propValue.bet === "true");
                }
                if (propValue.bpv) {
                    barProps.mwPosCol = convertToColor(propValue.bpv);
                }
                if (propValue.bnv) {
                    barProps.mwNegCol = convertToColor(propValue.bnv);
                }
                if (propValue.brlc) {
                    barProps.mwRefLineCol = convertToColor(propValue.brlc);
                }
                if (propValue.bh) {
                    barProps.mstrHeader = propValue.bh;
                }

                if (propValue.gsh) {
                    bulletProps.mbShow = (propValue.gsh === "true");
                }
                if (propValue.grl) {
                    bulletProps.mbRefLine = (propValue.grl === "true");
                }
                if (propValue.gra) {
                    bulletProps.mbRefBands = (propValue.gra === "true");
                }
                if (propValue.gl) {
                    bulletProps.mbShowLegend = (propValue.gl === "true");
                }
                if (propValue.gmsh) {
                    bulletProps.mbAssMetric = (propValue.gmsh === "true");
                }
                if (propValue.gia) {
                    bulletProps.mbInvertAxis = (propValue.gia === "true");
                }
                if (propValue.get) {
                    bulletProps.mbShowTooltip = (propValue.get === "true");
                }
                if (propValue.gmm) {
                    bulletProps.mfMinValue = parseFloat(propValue.gmm);
                }

                if (propValue.ggc) {
                    bulletProps.mwPosCol = convertToColor(propValue.ggc);
                }
                if (propValue.gnv) {
                    bulletProps.mwNegCol = convertToColor(propValue.gnv);
                }
                if (propValue.grlc) {
                    bulletProps.mwRefLineCol = convertToColor(propValue.grlc);
                }
                if (propValue.gpc) {
                    bulletProps.mwBand1 = convertToColor(propValue.gpc);
                }
                if (propValue.grc) {
                    bulletProps.mwBand2 = convertToColor(propValue.grc);
                }
                if (propValue.gsc) {
                    bulletProps.mwBand3 = convertToColor(propValue.gsc);
                }
                if (propValue.gh) {
                    bulletProps.mstrHeader = propValue.gh;
                }
                if (propValue.gtam) {
                    bulletProps.mstrAssMetric = propValue.gtam;
                }
                if (propValue.glt) {
                    bulletProps.mstrBand1 = propValue.glt;
                }
                if (propValue.gmt) {
                    bulletProps.mstrBand2 = propValue.gmt;
                }
                if (propValue.ght) {
                    bulletProps.mstrBand3 = propValue.ght;
                }

                
                
                
                if (propValue.wa) {
                    var value = parseFloat(propValue.wa);
                    if (propValue.wa.indexOf("%")) {
                        value /= 100; 
                    }
                    otherProps.mfBkgOpacity = value;
                }
                if (propValue.metkpi) {
                    otherProps.mnMetricsPerKPI = parseInt(propValue.metkpi);
                }
                if (propValue.hch) {
                    otherProps.mbHideColHeaders = (propValue.hch === "true");
                }
                if (propValue.htc) {
                    otherProps.mbHideTextColumns = (propValue.htc === "true");
                }
                if (propValue.ll) {
                    otherProps.mbLockLayout = (propValue.ll === "true");
                }
                if (propValue.gam) {
                    otherProps.mbShowForHiddenGraphs = (propValue.gam === "true");
                }
                if (propValue.igf) {
                    otherProps.mbInheritFromGridGraph = (propValue.igf === "true");
                }
                if (propValue.scm) {
                    otherProps.mbInSingleColumnMode = (propValue.scm === "true");
                }
                if (propValue.cid) {
                    otherProps.mpColumnIDs = propValue.cid.split(",");
                }
                if (propValue.tcid) {
                    otherProps.mpColumnIDsInTreeMode = propValue.tcid.split(",");
                }
                
                
                
                if (propValue.co) {
                    otherProps.mpColumnPositions = propValue.co.split(",");
                }
                if (propValue.sc) {
                    otherProps.mpSortKey = propValue.sc;
                }
                if (propValue.so) {
                    otherProps.mbSortDescend = (propValue.so !== "false");
                }

                if (propValue.rh) {
                    otherProps.mRowHeight = parseFloat(propValue.rh);
                }

                
                otherProps.mRowHeight = otherProps.mRowHeight > 27 ? otherProps.mRowHeight : 27;

                setDimensionWithDPI.call(this);

            },

            preBuildRendering: function preBR() {
                console.log("in preb in MC");
                if (this._super) {
                    this._super();
                }

                var m = this.model;

                if (!m) {
                    m.err = mstrmojo.desc(8426, 'No model provided');
                    return;
                }

                
                this.isAndroidTab = $D.isAndroid ? !!mstrApp.isTablet() : false;

                this.isAndroidPhone = $D.isAndroid && !this.isAndroidTab;

                var propValue = m.vp || {};

                var isReport = this.controller && (this.controller instanceof mstrmojo.android.controllers.XtabController);
                var fullScreen = this.isFullScreenWidget || isReport;
                
                this.enableSmoothScroll = ( this.isAndroidPhone && fullScreen) ? true : getBoolValue(propValue.ss);

                

                if (propValue.mcs) {
                    this.metricColumnsSpacing = parseInt(propValue.mcs);
                } else {
                    this.metricColumnsSpacing = this.isAndroidPhone ? (mstrApp.isLandscape() ? NORMAL : COMPACT) : -1;
                }

                if (this.enableSmoothScroll) {
                    this.leftWidth = this.getWidth() / 3;
                    this.rightWidth = this.getWidth() / 3 * 2;
                } else {
                    this.leftWidth = this.getWidth();
                    this.rightWidth = 0;
                    this.scrollerConfig.hScroll = false;
                }
            },

            buildRendering: function () {
                var that = this;
                var backup = mstrmojo.string.apply;
                mstrmojo.string.apply = function (tmpl, obj) {
                    if (!tmpl) {
                        return "";
                    }
                    return tmpl.replace(/\{([^\}]+)\}/gm,
                        function tokenRepl(token, prop) {
                            var s = token.replace(/@/g, 'that.');
                            var res = eval(s);
                            return res === undefined ? '' : res;
                        }
                    );
                };

                if (this._super) {
                    this._super();
                }

                mstrmojo.string.apply = backup;
            },

            
            buildRows: function buildRows() {
                if (this.rowsNeedRebuild) {
                    if (this.isTreeMode) {
                        
                        this.rows = getTreeNodeRows.call(this);
                    } else {
                        buildNonTreeRows.call(this);
                    }

                    this.rowsNeedRebuild = false;
                }
            },

            pushToReusePool: function pushToReusePool(beginCnt, endCnt) {
                var bCnt = beginCnt != undefined ? beginCnt : this.startCnt;
                var eCnt = endCnt != undefined ? endCnt : this.endCnt;

                var rowInfo = null;
                for (var i = bCnt; i < eCnt; i++) {
                    rowInfo = this.rows[i];
                    this.rowsReusePool.push(rowInfo.rowRef);
                    rowInfo.rowRef = {};
                }
            },

            popFromReusePool: function popFromReusePool() {
                var rowRef = this.rowsReusePool.pop();
                return rowRef || {};
            },

            
            reRenderChart: function reRenderChart(scrollTo, rowCount, adjustOffsetY) {

                this.pushToReusePool();

                this.buildRows();

                var rowOffsetHeight = this.rowOffsetHeight;

                if (!rowCount) {
                    rowCount = 0;
                }

                this.firstRowIdxOnScrn = parseInt(this.startCnt + scrollTo.y / rowOffsetHeight) - rowCount;
                this.getCurrRenderRowCount();

                if (adjustOffsetY == undefined) {
                    adjustOffsetY = scrollTo.y % rowOffsetHeight;
                }
                scrollTo.y = (this.firstRowIdxOnScrn - this.startCnt) * rowOffsetHeight + adjustOffsetY;

                
                this.lastScrollPosition.y = scrollTo.y;
                this.lastFirstRowIdxOnScrn = this.firstRowIdxOnScrn;

                
                var rows = this.rows;
                for (var i = this.startCnt; i < this.endCnt; i++) {
                    rows[i].rowRef = this.popFromReusePool();
                }

                if (!this.enableSmoothScroll) {
                    this._leftChart.reRenderRows(scrollTo);
                } else {
                    this._leftChart.reRenderRows(scrollTo);
                    this._rightChart.reRenderRows(scrollTo);
                }
            },

            reRenderChartWhenScrollDone: function reRenderChartwsd(scrollTo) {

                var oldStartCnt = this.startCnt;
                var oldEndCnt = this.endCnt;

                var rowOffsetHeight = this.rowOffsetHeight;
                this.firstRowIdxOnScrn = parseInt(this.startCnt + scrollTo.y / rowOffsetHeight);
                this.getCurrRenderRowCount();

                var firstRowToRemove, lastRowToRemove, firstRowToRender, lastRowToRender;
                if (this.startCnt < oldEndCnt && this.startCnt > oldStartCnt) {
                    firstRowToRemove = oldStartCnt;
                    lastRowToRemove = this.startCnt;
                    firstRowRemain = this.startCnt;
                    lastRowRemain = oldEndCnt;
                    firstRowToRender = oldEndCnt;
                    lastRowToRender = this.endCnt;

                } else if (oldStartCnt < this.endCnt && oldStartCnt > this.startCnt) {
                    firstRowToRemove = this.endCnt;
                    lastRowToRemove = oldEndCnt;
                    firstRowRemain = oldStartCnt;
                    lastRowRemain = this.endCnt;
                    firstRowToRender = this.startCnt;
                    lastRowToRender = oldStartCnt;
                } else {
                    firstRowToRemove = oldStartCnt;
                    lastRowToRemove = oldEndCnt;
                    firstRowRemain = 0;
                    lastRowRemain = 0;
                    firstRowToRender = this.startCnt;
                    lastRowToRender = this.endCnt;
                }

                
                
                
                

                this.pushToReusePool(firstRowToRemove, lastRowToRemove);

                scrollTo.y = (this.firstRowIdxOnScrn - this.startCnt) * rowOffsetHeight + scrollTo.y % rowOffsetHeight;

                
                this.lastScrollPosition.y = scrollTo.y;
                this.lastFirstRowIdxOnScrn = this.firstRowIdxOnScrn;

                
                var rows = this.rows;
                for (var i = firstRowToRender; i < lastRowToRender; i++) {
                    rows[i].rowRef = this.popFromReusePool();
                }

                if (!this.enableSmoothScroll) {
                    this._leftChart.reRenderRows(scrollTo, firstRowRemain, lastRowRemain, firstRowToRender, lastRowToRender);
                } else {
                    this._leftChart.reRenderRows(scrollTo, firstRowRemain, lastRowRemain, firstRowToRender, lastRowToRender);
                    this._rightChart.reRenderRows(scrollTo, firstRowRemain, lastRowRemain, firstRowToRender, lastRowToRender);
                }
            },

            reRenderChartWithAnchor: function reRenderChartWithAnchor(anchorRowTreeNode, anchorRowIdxOnScrn) {

                this.pushToReusePool();

                this.buildRows();

                var rowOffsetHeight = this.rowOffsetHeight;

                var anchorRowIdx = -1;
                for (var i = 0; i < this.rows.length; i++) {
                    if (this.rows[i].treeNode.treePath == anchorRowTreeNode.treePath) {
                        anchorRowIdx = i;
                        break;
                    }
                }

                this.firstRowIdxOnScrn = anchorRowIdx - anchorRowIdxOnScrn;
                if (this.firstRowIdxOnScrn < 0) {
                    this.firstRowIdxOnScrn = 0;
                }

                this.getCurrRenderRowCount();

                scrollTo.y = (this.firstRowIdxOnScrn - this.startCnt) * rowOffsetHeight;

                
                this.lastScrollPosition.y = scrollTo.y;
                this.lastFirstRowIdxOnScrn = this.firstRowIdxOnScrn;

                
                var rows = this.rows;
                for (var i = this.startCnt; i < this.endCnt; i++) {
                    rows[i].rowRef = this.popFromReusePool();
                }

                if (!this.enableSmoothScroll) {
                    this._leftChart.reRenderRows(scrollTo);
                } else {
                    this._leftChart.reRenderRows(scrollTo);
                    this._rightChart.reRenderRows(scrollTo);
                }
            },

            supportsIncFetch: false,

            pageSize: 0,

            getCurrRenderRowCount: function getCRRC() {

                var maxRenderRowCount = this.pageSize * PAGE_COUNT;

                if (this.rows.length <= maxRenderRowCount) {
                    this.partialRender = false;
                    this.startCnt = 0;
                    this.endCnt = this.rows.length;
                } else {
                    this.partialRender = true;
                    this.startCnt = Math.round(this.firstRowIdxOnScrn - this.pageSize * (PAGE_COUNT - 1) / 2)
                    if (this.startCnt < 0) {
                        this.startCnt = 0;
                    }
                    this.endCnt = this.startCnt + maxRenderRowCount;
                    if (this.endCnt > this.rows.length) {
                        this.endCnt = this.rows.length;
                    }
                }
                
            },

            getChartWithScrollBar: function () {
                if (this.enableSmoothScroll) {
                    return this._rightChart;
                } else {
                    return this._leftChart;
                }
            },

            updateWindowRatio: function updateWindowRatio() {
                
                var chart = this.getChartWithScrollBar(),
                    scroller = chart._scroller;

                scroller.chartTableRenderRatio = (this.endCnt - this.startCnt) / this.rows.length;
                scroller.topUnRenderedRatio = this.startCnt / this.rows.length;
                
                chart.updateScroller();

            },

            initValues: function initValues() {
                
                
                

                this.prevSelected = {
                    mrow: -2,
                    mcol: -1
                };

                if (this.isTreeMode) {
                    initTree.call(this);
                }

                this.treeColumnIdx = -1;

                
                this.minPageSize = Math.ceil((this.getHeight() / this.otherProps.mRowHeight) * 3 / PAGE_COUNT);
                this.pageSize = this.minPageSize;

                this.rowsNeedRebuild = true;
                this.rows = [];
                this.dockedHeaderRows = [];
                this.dockedHeaderReplaceRows = [];
                this.rowsReusePool = [];
                this.unselectedRemainCells = [];

                this.errorMsg.style.display = 'none';

                
                
                
                
                
            },

            postBuildRendering: function postBR() {

                var me = this,
                    model = me.model;
                var err = model.err || model.eg;

                if (err) {
                    me.renderErrorMessage(err);
                    return;
                }

                if (me.controller && me.controller.view && me.controller.view.model) {
                    if (!me.mcStatus && me.controller.view.model.mcStatus) {
                        
                        me.mcStatus = me.controller.view.model.mcStatus;
                    }
                }

                me.initValues();

                me.highlightEntireRow = me.isTreeMode || me.isAllAttrSelectable;

                getUITheme.call(me);

                convertDataToModels.call(me);

                if (me.otherProps.mbInheritFromGridGraph) {
                    me.selectedClass = "sc_" + me.model.k; 
                } else {
                    me.selectedClass = "";
                }

                err = model.err || model.eg;

                if (err) {
                    me.renderErrorMessage(err);
                    return;
                }

                if (this._super) {
                    this._super();
                }

                
                me.renderLegend();

                me.getCurrRenderRowCount();

                me.restoreMCStatus();

                if (!me.enableSmoothScroll) {
                    me.itemsContainerNode.style.display = 'none';
                    var props = {
                        placeholder: me.leftChart,
                        colInfos: me.colInfos,
                        theme: me.theme,
                        isTreeMode: me.isTreeMode,
                        showMinLabel: me.showMinLabel,
                        width: me.leftWidth + "px",
                        height: (me.getHeight() - me.legendHeight) + "px",
                        textSpan: me.textSpan,
                        textCanvas: me.textCanvas,
                        headerCssClass: me.headerCssClass,
                        valueCssClass: me.valueCssClass,
                        isAndroidTab: me.isAndroidTab,
                        widget: me,
                        treeColumnIdx: me.treeColumnIdx,
                        backgroundColor: me.backgroundColor,
                        domRefName: LEFT_CHART_ROW,
                        showScrollbars: true
                    };
                    var w = new mstrmojo.VisMicroChartTable(props);
                    w.render();
                    me._leftChart = w;
                    w.parent = me;

                    me.replaceScrollerUpdate(w);
                } else {
                    var props = {
                        placeholder: me.leftChart,
                        colInfos: me.colInfos.slice(0, this.attrColumnCount),
                        theme: me.theme,
                        isTreeMode: me.isTreeMode,
                        showMinLabel: me.showMinLabel,
                        width: me.leftWidth + "px",
                        height: (me.getHeight() - me.legendHeight) + "px",
                        textSpan: me.textSpan,
                        textCanvas: me.textCanvas,
                        headerCssClass: me.headerCssClass,
                        valueCssClass: me.valueCssClass,
                        isAndroidTab: me.isAndroidTab,
                        widget: me,
                        treeColumnIdx: me.treeColumnIdx,
                        backgroundColor: me.backgroundColor,
                        domRefName: LEFT_CHART_ROW,
                        showScrollbars: false,
                        zIndex: 1
                    };
                    var w = new mstrmojo.VisMicroChartTable(props);
                    w.render();
                    me._leftChart = w;
                    w.parent = me;
                    me.leftChart = w.domNode;

                    

                    var props = {
                        placeholder: me.rightChart,
                        colInfos: me.colInfos.slice(this.attrColumnCount),
                        theme: me.theme,
                        isTreeMode: me.isTreeMode,
                        showMinLabel: me.showMinLabel,
                        width: me.rightWidth + "px",
                        height: (me.getHeight() - me.legendHeight) + "px",
                        textSpan: me.textSpan,
                        textCanvas: me.textCanvas,
                        headerCssClass: me.headerCssClass,
                        valueCssClass: me.valueCssClass,
                        isAndroidTab: me.isAndroidTab,
                        widget: me,
                        treeColumnIdx: me.treeColumnIdx,
                        backgroundColor: me.backgroundColor,
                        domRefName: RIGHT_CHART_ROW,
                        showScrollbars: true
                    };
                    var w2 = new mstrmojo.VisMicroChartTable(props);
                    w2.render();
                    me._rightChart = w2;
                    w2.parent = me;
                    me.rightChart = w2.domNode;

                    me.replaceScrollerUpdate(w2);

                    if (this.theme == DEFAULT_LIGHT_THEME || this.theme == CUSTOM_LIGHT_THEME) {
                        me.dropShadowDiv.style.backgroundImage = "-webkit-gradient(linear, left top, right top, color-stop(0, rgba(0,0,0,0.25)), color-stop(1, rgba(0,0,0,0)))";
                    } else {
                        me.dropShadowDiv.style.backgroundImage = "-webkit-gradient(linear, left top, right top, color-stop(0, rgba(0,0,0,0.5)), color-stop(1, rgba(0,0,0,0)))";
                    }

                    w2.addSyncScroller(w);
                    w.addSyncScroller(w2);

                    me.scrollerConfig.scrollEl = me.rightChart;
                    me.updateScroller();

                    var scrollTo = null;
                    if (this.mcStatus && this.mcStatus.hScrollPos != undefined) {
                        var xPos = Math.min(this.mcStatus.hScrollPos * this.rightWidth, this.rightWidth + this.leftWidth - this.getWidth());
                        scrollTo = this._scroller.origin = {
                            x: xPos,
                            y: 0
                        }
                    }
                    setScrollerPosition.call(me, scrollTo);

                    
                    var headerHeight = Math.max(me._leftChart.headerTableOffsetHeight, me._rightChart.headerTableOffsetHeight);
                    me._leftChart.headerTable.style.height = headerHeight + "px";
                    me._rightChart.headerTable.style.height = headerHeight + "px";
                    me._leftChart.updateHeaderTableOffsetH();
                    me._rightChart.updateHeaderTableOffsetH();

                }
                me.rowOffsetHeight = (me.otherProps.mbHideTextColumns && this.enableSmoothScroll) ? w2.rowOffsetHeight : w.rowOffsetHeight;

                if (me.isTreeMode) {
                    if (me.mcStatus && me.mcStatus.dHRowIdxList) {
                        
                        me._leftChart.initDHs();
                        if (me._rightChart) {
                            me._rightChart.initDHs();
                        }
                        me.addRowsToDH(me.mcStatus.dHRowIdxList);
                        if (me.mcStatus.dHReplaceRowIdxList.length > 0) {
                            me.addRowsToDH(me.mcStatus.dHReplaceRowIdxList, true);
                            var pastOffset = me.mcStatus.scrollTo.y % me.rowOffsetHeight;
                            
                            me.shiftDockedHeaderWithRow(-pastOffset);
                        }

                    } else {
                        me.initDockedHeaders();
                    }
                }

                
                me.removeMCStatus();

                me.getDefaultHighlightRow();
                me.updateSelectedStatus(me.tree);
                me.updateHighlightForCurrRenderRows();

                me.chartTableMaxHeight = me.getHeight() - me._leftChart.headerTableOffsetHeight;
                if (me.legendDis) {
                    me.chartTableMaxHeight -= me.legendHeight;
                }

                
                
                me.pageSize = Math.max(Math.min(parseInt(me.chartTableMaxHeight / me.rowOffsetHeight) + 1, 20), me.minPageSize);
                setChartTableHeight.call(me);

                
                var xtabModel = me.xtabModel,
                    docModel = (xtabModel && xtabModel.docModel);
                if (docModel) {
                    me._infoWClosedListener = me.xtabModel.docModel.attachEventListener('infoWindowClosed', this.id, function (evt) {
                        var infoWindowK = evt.psKey;
                        
                        if (!me.hasNonifwTarget && me.selectorTargets && me.selectorTargets[infoWindowK]) {

                            window.setTimeout(function () {
                                if (me.isTreeMode) {
                                    var treeNode = me.lastSelectedObj[me.lastSelectedObj.length - 1];
                                    if(treeNode && treeNode.treePath){
                                        
                                        me.closedIfwAttr = treeNode.treePath;
                                        me.currSelectedObj = [];
                                        
                                        me.updateSelectedStatus(me.tree);
                                        me.updateHighlightForCurrRenderRows();
                                        me.lastSelectedObj = [];
                                    }
                                } else {
                                    if (me.isAllAttrSelectable) {
                                        
                                        me.closedIfwAttr = me.prevSelected.mrow;

                                        me.clearPreHighlightRowStatus();
                                        
                                        me.updateUnselectedRemainCells();

                                        
                                        me.updateSelectedStatus(me.tree);
                                        me.updateHighlightForCurrRenderRows();
                                    } else {
                                        var mcol = me.prevSelected && me.prevSelected.mcol;
                                        var id = me.colInfos[mcol] && me.colInfos[mcol].order;
                                        id = id.split(":")[0];

                                        
                                        me.closedIfwAttr = id;

                                        var ctlMatrix = me.ctlMatrix[id];
                                        var ctlMatrixCG = me.ctlMatrix[id + ":CG"];
                                        var selectedIdxBackup = ctlMatrix.selectedIdx;
                                        var selectedIdxCGBackup = ctlMatrixCG && ctlMatrixCG.selectedIdx;
                                        ctlMatrix.selectedIdx = {};
                                        if (ctlMatrixCG) {
                                            ctlMatrixCG.selectedIdx = {};
                                        }

                                        
                                        me.updateSelectedStatus();
                                        me.updateHighlightForCurrRenderRows();

                                        ctlMatrix.selectedIdx = selectedIdxBackup;
                                        if (ctlMatrixCG) {
                                            ctlMatrixCG.selectedIdx = selectedIdxCGBackup;
                                        }
                                    }

                                }
                            }, 10);

                        }
                    });
                }

                this.renderTextTooltip();

                
                
            },

            renderTextTooltip: function renderTextTooltip() {
                
                var props = {
                    placeholder: this.textTooltip,
                    boundary: this.domNode
                };
                this._textTooltip = new mstrmojo.VisTextTooltip(props);
                this._textTooltip.render();

                this._textTooltip.toggle(false);
            },

            
            replaceScrollerUpdate: function replaceScrollerUpdate(chartTable) {

                chartTable._scroller.updateScrollBars = function updateScrollBars(viewportCoords, scrollBarContainerElement) {
                    var scrollEl = this.scrollEl;

                    
                    if (!this.showScrollbars || !scrollEl) {
                        
                        return;
                    }

                    var bars = this._scrollBarEls;

                    var chartTableRenderRatio = this.chartTableRenderRatio || 1;
                    var topUnRenderedRatio = this.topUnRenderedRatio || 0;

                    
                    if (!bars) {
                        var me = this;
                        bars = this._scrollBarEls = {
                            x: 'hScroll',
                            y: 'vScroll'
                        };

                        
                        $forEachHash(bars, function (scroll, axis) {
                            
                            if (me[scroll]) {
                                
                                var bar = document.createElement('div');
                                bar.className = 'mstrmojo-touch-scrollBar ' + axis + 'Axis';

                                
                                (scrollBarContainerElement || scrollEl.parentNode).appendChild(bar);
                                bars[axis] = bar;
                            } else {
                                
                                delete bars[axis];
                            }
                        });
                    }

                    
                    if (!viewportCoords) {
                        
                        var parentNode = this.scrollEl.parentNode;
                        viewportCoords = {
                            top: 0,
                            right: parentNode.clientWidth,
                            bottom: parentNode.clientHeight,
                            left: 0
                        };
                    }

                    
                    var offset = 9,
                        scrollBarCoords = {
                            x: {
                                left: viewportCoords.left,
                                top: viewportCoords.bottom - offset,
                                x: viewportCoords.right - viewportCoords.left,
                                d: 'Width'
                            },
                            y: {
                                left: viewportCoords.right - offset,
                                top: viewportCoords.top,
                                x: viewportCoords.bottom - viewportCoords.top,
                                d: 'Height'
                            }
                        };

                    var me = this;
                    
                    $forEachHash(bars, function (bar, axis) {
                        var barStyle = bar.style,
                            coords = scrollBarCoords[axis],
                            dimension = coords.d,
                            parentNode = bar.parentNode,
                            x = coords.x;

                        
                        var left = coords.left,
                            top = coords.top + x * topUnRenderedRatio,
                            ratio = x / scrollEl['offset' + dimension] * chartTableRenderRatio,
                            length = Math.min(Math.round(x * ratio), x);

                        
                        bar.baseLeft = left;
                        bar.baseTop = top;
                        bar.ratio = ratio;
                        bar.viewportSize = $M.round(x * chartTableRenderRatio);
                        bar.length = length;

                        
                        barStyle.left = left + 'px';
                        barStyle.top = top + 'px';
                        barStyle[dimension.toLowerCase()] = length + 'px';

                        var isX = (axis === 'x'),
                            direction = isX ? 'hScroll' : 'vScroll';
                        if (me[direction]) {
                            
                            var origin = me.origin,
                                position = origin && origin[axis] || 0,
                                viewportSize = bar.viewportSize,
                                minScale = 6 / length,
                                minPosition = bar['base' + ((isX) ? 'Left' : 'Top')],
                                maxPosition = minPosition + viewportSize - length,
                                newPosition = $M.round(minPosition + (ratio * position));

                            
                            if (newPosition < minPosition) {
                                newPosition = minPosition - position;
                                length += position;
                            } else if (newPosition > maxPosition) {
                                var delta = (position - me.offset[axis].end) * ratio;
                                newPosition = $M.min(maxPosition + delta, viewportSize + minPosition - 6) - 1;
                                length -= delta;
                            }

                            
                            var v = 0,
                                translate = [v, v, v],
                                scale = [1, 1, 1],
                                idx = (isX) ? 0 : 1;

                            translate[idx] = (newPosition - minPosition);
                            scale[idx] = $M.min($M.max(length / bar.length, minScale), 1);

                            $D.translate(bar, translate[0], translate[1], translate[2], ' scale3d(' + scale.join(',') + ')');
                            

                        }
                    });
                }

            },

            setElementDimension: function setElementDimension(e, width) {
                var paddingWidth = 0;

                var compStyle = mstrmojo.css.getComputedStyle(e);
                if (compStyle.paddingLeft) {
                    paddingWidth += parseFloat(compStyle.paddingLeft);
                }
                if (compStyle.paddingRight) {
                    paddingWidth += parseFloat(compStyle.paddingRight);
                }

                e.style.width = (width - paddingWidth) + 'px';

            },

            setColorByTheme: function setColorByTheme() {
                var bulletProps = this.bulletProps;
                if (this.theme == DEFAULT_DARK_THEME) {
                    this.bandColor1 = "#494949";
                    this.bandColor2 = "#595959";
                    this.bandColor3 = "#727272";

                    this.refLinePosColor = "#FF781D";
                    this.refLineNegColor = "#FF781D";
                    this.refLineWidth = 2;
                    this.blueBarPosColor = "#00BDFF";
                    this.blueBarNegColor = "#00BDFF";
                } else if (this.theme == DEFAULT_LIGHT_THEME) {
                    this.bandColor1 = "#A5A5A5";
                    this.bandColor2 = "#B3B3B3";
                    this.bandColor3 = "#C4C4C4";

                    this.refLinePosColor = "#FF781D";
                    this.refLineNegColor = "#FF781D";
                    this.refLineWidth = 2;
                    this.blueBarPosColor = "#00BDFF";
                    this.blueBarNegColor = "#00BDFF";
                } else {
                    this.bandColor1 = bulletProps.mwBand1 || "#999999";
                    this.bandColor2 = bulletProps.mwBand2 || "#BBBBBB";
                    this.bandColor3 = bulletProps.mwBand3 || "#DEDEDE";

                    this.refLinePosColor = bulletProps.mwRefLineCol;
                    this.refLineNegColor = bulletProps.mwRefLineCol;
                    this.blueBarPosColor = bulletProps.mwPosCol;
                    this.blueBarNegColor = bulletProps.mwNegCol;
                }
            },

            renderLegend: function renderLgd() {
                var bulletProps = this.bulletProps;

                this.setColorByTheme();

                this.legendDis = this.showGauge && this.bulletProps.mbShowLegend;
                if (this.legendDis) {
                    this.legend.className += " " + this.valueCssClass;

                    
                    
                    

                    this.legend.style.display = "block";
                    this.legend.style.fontSize = Math.round(11 * zf) + "pt";
                    this.setElementDimension(this.legend, this.getWidth());

                    if (bulletProps.mstrBand1) {
                        this.legendLowFont.innerHTML = bulletProps.mstrBand1;
                    }
                    this.legendLowBand.style.backgroundColor = this.bandColor1;

                    if (bulletProps.mstrBand2) {
                        this.legendMidFont.innerHTML = bulletProps.mstrBand2;
                    }
                    this.legendMidBand.style.backgroundColor = this.bandColor2;

                    if (bulletProps.mstrBand3) {
                        this.legendHighFont.innerHTML = bulletProps.mstrBand3;
                    }
                    this.legendHighBand.style.backgroundColor = this.bandColor3;

                    var lowWidth = this.legendLow.offsetWidth,
                        midWidth = this.legendMid.offsetWidth,
                        highWidth = this.legendHigh.offsetWidth;

                    if (lowWidth + midWidth + highWidth > this.getWidth()) {
                        
                        if (lowWidth + midWidth > this.getWidth()) {
                            this.legendLow.style.width = this.width;
                            if (midWidth + highWidth > this.getWidth()) {
                                this.legendMid.style.width = this.width;
                                this.legendHigh.style.width = this.width;
                            } else {
                                this.legendMid.style.width = (this.getWidth() - highWidth) + "px";
                            }
                        } else {
                            this.legendLow.style.width = (this.getWidth() - midWidth) + "px";
                            this.legendHigh.style.width = this.width;
                        }
                    }
                    this.legendHeight = this.legend.firstChild.offsetHeight;
                    this.legend.style.height = this.legendHeight + "px";

                } else {
                    this.legend.style.display = "none";
                    this.legendHeight = 0;
                }
            },

            showChartTooltip: function showChartTooltip(touchedChart, touch) {
                var me = this;
                var wasNoTooltip = this.tooltip.style["display"] === "none" || !(this.tooltip.style["display"]);
                touchedChart.showTooltip(touch.pageX, touch.pageY);
                var nowHasTooltip = this.tooltip.style["display"] === "block";
                this.tooltipShow = nowHasTooltip;
                
                if (wasNoTooltip && nowHasTooltip) {
                    var touchManager = mstrmojo.touchManager;
                    this._touchListener = touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                        if (!isTouchedOnWidget.call(me, evt.touch)) {
                            hideTooltipGlobal.call(me, evt.touch); 
                        }
                    });
                }

            },

            touchSelectBegin: function touchSelectBegin(touch) {
                if (touch.evt.ctrlKey) { 
                    this.touchMultiBegin(touch);
                    return;
                }

                var me = this;

                hideTooltipGlobal.call(me);

                var td = mstrmojo.dom.findAncestorByAttr(touch.target, "mcol", true, this.domNode);
                if (td && td.node) {
                    var mrow = td.node.getAttribute("mrow");
                    var mcol = td.node.getAttribute("mcol");

                    if (mrow == -1) {
                        
                        this.showTextTooltip(td.node, mcol, true);

                    } else {
                        var tr = td.node.parentNode;
                        var rowInfo = null;
                        if (tr.getAttribute("rowType") == DOCKED_HEADER) {
                            var dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderRows, mrow);
                            if (dockedHeaderIdx >= 0) {
                                rowInfo = this.dockedHeaderRows[dockedHeaderIdx];
                            } else {
                                dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderReplaceRows, mrow);
                                rowInfo = this.dockedHeaderReplaceRows[dockedHeaderIdx];
                            }
                        } else {
                            rowInfo = this.rows[mrow];
                        }

                        var colInfo = this.colInfos[mcol];
                        if (colInfo.type == CHART) {
                            var touchedChart = rowInfo && rowInfo.rowRef && rowInfo.rowRef[mcol];
                            if (touchedChart) {
                                this.showChartTooltip(touchedChart, touch);
                                this.currSelectedWidget = { mrow: mrow, mcol: mcol };
                            }
                        } else if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_VALUE || colInfo.type == METRIC_NAME) {
                            this.showTextTooltip(td.node, mcol);
                        }
                    }

                }
            },

            showTextTooltip: function showTextTooltip(e, mcol, onHeader) {
                if (onHeader) {
                    var colInfo = this.colInfos[mcol],
                        text = colInfo.title;
                    if (colInfo.titleOverflow && this._textTooltip) {
                        this._textTooltip.updateContent(e, onHeader ? 'title' : 'content', text);

                    }
                } else {
                    var text = e.innerText;
                    var tmpLength = this.getTextWidthByCanvas(text, e, true);
                    if (tmpLength > e.offsetWidth && this._textTooltip) {
                        this._textTooltip.updateContent(e, onHeader ? 'title' : 'content', text);

                    }
                }

            },

            hideTextTooltip: function hideTextTooltip() {
                if (this._textTooltip) {
                    this._textTooltip.toggle(false);
                }
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                if (touch.evt.ctrlKey) {
                    this.touchMultiEnd(touch);
                    return;
                }
                this.currSelectedWidget = null;
                this.hideTextTooltip();
            },

            touchSelectMove: function touchSelectMove(touch) {
                if (touch.evt.ctrlKey) {
                    this.touchMultiMove(touch);
                    return;
                }

                if (!this.currSelectedWidget) {
                    return;
                }

                
                this.tooltip.style.display = "none";

                var target = touch.target;

                var mcol = -1,
                    colInfo = null;

                var targetFound = true;
                var td = mstrmojo.dom.findAncestorByAttr(target, "mcol", true, this.domNode);
                td = td && td.node;
                if (td) {
                    mcol = td.getAttribute("mcol");
                    colInfo = this.colInfos[mcol];
                    
                    if (colInfo.order == "GaugeChart") {
                        
                        
                        targetFound = false;
                    }
                } else {
                    
                    targetFound = false;
                }

                if (targetFound === false) {
                    target = document.elementFromPoint(touch.pageX, touch.pageY);
                    
                    td = mstrmojo.dom.findAncestorByAttr(target, "mcol", true, this.domNode);
                    td = td && td.node;
                    if (!td) {
                        return;
                    }
                    mcol = td.getAttribute("mcol");
                    colInfo = this.colInfos[mcol];
                }

                var mrow = td.getAttribute("mrow");
                var tr = td.parentNode;

                
                var rowInfo = null;
                if (tr.getAttribute("rowType") == DOCKED_HEADER) {
                    var dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderRows, mrow);
                    if (dockedHeaderIdx >= 0) {
                        rowInfo = this.dockedHeaderRows[dockedHeaderIdx];
                    } else {
                        dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderReplaceRows, mrow);
                        rowInfo = this.dockedHeaderReplaceRows[dockedHeaderIdx];
                    }
                } else {
                    rowInfo = this.rows[mrow];
                }

                var touchedChart = rowInfo && rowInfo.rowRef && rowInfo.rowRef[mcol];
                var tooltipShown;
                if (touchedChart) {
                    if (colInfo.order == "LineChart" || colInfo.order == "BarChart") {
                        if (mrow == this.currSelectedWidget.mrow && mcol == this.currSelectedWidget.mcol) {
                            tooltipShown = touchedChart.showTooltip(touch.pageX, touch.pageY);
                            this.currSelectedWidget = { mrow: mrow, mcol: mcol };
                        }
                    } else {
                        if (mcol == this.currSelectedWidget.mcol && mrow != this.currSelectedWidget.mrow) {
                            tooltipShown = touchedChart.showTooltip(touch.pageX, touch.pageY);
                            this.currSelectedWidget = { mrow: mrow, mcol: mcol };
                        }
                    }
                }

                if (tooltipShown) {
                    this.tooltipShow = true;
                }
                console.log("tooltip show:" + this.tooltipShow);
                if (this.tooltipShow) {
                    this.tooltip.style.display = "block";
                }

            },

            touchSwipeBegin: function touchSwipeBegin(touch) {
                hideTooltipGlobal.call(this);
                
                if (isScrollableElementTouched.call(this, touch) && this._super) {
                    this._super(touch);
                } else {
                    this._touchCanceled = true;
                }

            },

            touchSwipeMove: function touchSwipeMove(touch) {
                
                if (!this._touchCanceled && this._super) {
                    this._super(touch);
                }
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                
                if (!this._touchCanceled && this._super) {
                    this._super(touch);
                }
            },

            getColIdx: function getColIdx(order) {
                var colInfos = this.colInfos,
                    colCount = colInfos.length;
                for (var i = 0; i < colCount; i++) {
                    var target = colInfos[i].order.split(":")[0];
                    if (target + ":CG" == colInfos[i].order) {
                        target = target + ":CG";
                    }
                    if (order == target) {
                        return colInfos[i].colIdx || i;
                    }
                }
                return -1;
            },

            buildLeftParent: function buildLeftParent(node, mrow, mcol) {
                var colInfos = this.colInfos,
                    colCount = colInfos.length;

                if (!this.isKPI) {
                    
                    if (mrow == -1) { 
                        var gts = this.model.gts;
                        var metricIndex = mstrmojo.array.find(gts.col, 'n', 'Metrics');
                        node._e = gts.col[metricIndex].es[colInfos[mcol].order] || {id: "", n: ""};
                        node.v = node._e.n;
                    } else {
                        var rows = this.model.gts.row;
                        var currNode = node;

                        for (var i = colCount - 1; i >= 0; i--) {
                            var colInfo = colInfos[i];
                            if (colInfo.type == CHART) {
                                continue;
                            }
                            if (colInfo.type == ATTR_NAME) {
                                var nodeLP = {};
                                var index = mstrmojo.array.find(rows, 'id', colInfo.order.split(":")[0]);
                                nodeLP.titleInfo = rows[index];
                                nodeLP._e = this.rows[mrow].model.elms[colInfo.order] || {id: "", n: ""};
                                nodeLP.v = nodeLP._e.n;
                                nodeLP.axis = ROW_AXIS;

                                currNode._lp = nodeLP;
                                currNode = nodeLP;
                            }
                        }
                    }
                } else {
                    
                    if (mcol == 0) {
                        
                        var gts = this.model.gts;
                        var metricIndex = mstrmojo.array.find(gts.col, 'n', 'Metrics');
                        node._e = gts.col[metricIndex].es[mrow] || {id: "", n: ""};
                        node.v = node._e.n;
                    } else {
                        var rows = this.model.gts.row;
                        var currNode = node;
                        for (var i = 0; i < rows.length; i++) {
                            var nodeLP = {};
                            nodeLP.titleInfo = rows[i];
                            var idx = rows[i].es.length;
                            nodeLP._e = rows[i].es[idx - 1] || {id: "", n: ""};
                            nodeLP.v = nodeLP._e.n;
                            nodeLP.axis = ROW_AXIS;

                            currNode._lp = nodeLP;
                            currNode = nodeLP;
                        }
                    }
                }
            },

            getModelK: function getModelK() {
                var k = this.model && this.model.k;

                return k;
            },

            addSCObjToList: function addSCObjToList(scObjList, rowH, n, id) {
                var scObj = {};
                scObj.sc = rowH.sc;
                scObj.es = n;
                scObj.eid = id;
                scObjList.push(scObj);
            },

            getSelectionObjForTreeMode: function getSelectionObjForTreeMode(touchedObj) {
                var attrIdxArray = this.attrMapIdx;
                var me = this,
                    model = me.model,
                    gts = model.gts,
                    rows = gts.row;

                var scObjList = [];
                var actionType = 0;
                var selectedAll = false;

                var treeNode = touchedObj.treeNode;
                var treePath = treeNode.treePath;
                var treePathArray = treePath.split("_");
                var treeLevel = treePathArray.length - 1;
                var isAttrSelectable = this.isAttrSelectable(treeLevel);

                if (this.closedIfwAttr == treePath) {
                    
                    return null;
                }

                if (isAttrSelectable) {
                    
                    var isTappedNodeSelected = this.lastSelectedObj && this.lastSelectedObj[treeLevel] && (this.lastSelectedObj[treeLevel].treePath == treePath);

                    if (!isTappedNodeSelected) {
                        
                        this.currSelectedObj = this.getSelectedTreeNodeListFromTreePath(treePathArray);

                        var useFirstAttr = false;
                        var parentTreeNode = this.currSelectedObj[treeLevel];
                        for (var i = treeLevel + 1; i < this.lastSelectedObj.length; i++) {
                            var thisLevelSelectable = this.isAttrSelectable(i);
                            var thisLevelSelected = !!this.lastSelectedObj[i];

                            if (!thisLevelSelectable || !thisLevelSelected) {
                                
                                useFirstAttr = true;
                                this.currSelectedObj[i] = null;
                                parentTreeNode = parentTreeNode.childrenTreeNodeList[0];
                                continue;
                            }

                            
                            if (!useFirstAttr) {
                                
                                var attrID = this.lastSelectedObj[i].id;
                                var treeNodeList = parentTreeNode.childrenTreeNodeList;
                                for (var j = 0; j < treeNodeList.length; j++) {
                                    if (attrID == treeNodeList[j].id) {
                                        
                                        this.currSelectedObj[i] = treeNodeList[j];
                                        break;
                                    }
                                }
                                if (j == treeNodeList.length) {
                                    
                                    useFirstAttr = true;
                                }
                            }

                            if (useFirstAttr) {
                                this.currSelectedObj[i] = parentTreeNode.childrenTreeNodeList[0];
                            }

                            
                            parentTreeNode = this.currSelectedObj[i];
                        }

                        selectedAll = false;
                        
                        for (var i = 0; i < this.currSelectedObj.length; i++) {
                            var treeNode = this.currSelectedObj[i];
                            if (treeNode) {
                                var attrIdx = attrIdxArray[i];
                                rowH = rows[attrIdx];

                                this.addSCObjToList(scObjList, rowH, treeNode.n, treeNode.id);
                            } else {
                                
                                continue;
                            }
                        }
                    } else {
                        
                        for (var i = treeLevel; i < this.lastSelectedObj.length; i++) {
                            var treeNode = this.currSelectedObj[i];

                            if (!treeNode) {
                                continue;
                            }

                            var attrIdx = attrIdxArray[i];
                            rowH = rows[attrIdx];

                            var unselectable = rowH.sc && !(rowH.sc.all === "false" || rowH.sc.all === false);

                            if (treeNode && !unselectable) {
                                
                                
                                break;

                            } else {
                                
                                this.addSCObjToList(scObjList, rowH, treeNode.n, "OA:(All)");
                                this.currSelectedObj[i] = null;
                            }
                        }

                        
                        if (i == treeLevel) {
                            return {at: 0};
                        }

                        
                        while (this.currSelectedObj.length > 0 && !this.currSelectedObj[this.currSelectedObj.length - 1]) {
                            this.currSelectedObj.pop();
                        }

                        
                        for (; i < this.currSelectedObj.length; i++) {
                            var treeNode = this.currSelectedObj[i];
                            if (treeNode) {
                                var attrIdx = attrIdxArray[i];
                                rowH = rows[attrIdx];

                                this.addSCObjToList(scObjList, rowH, treeNode.n, treeNode.id);
                            } else {
                                
                                continue;
                            }
                        }
                        
                        
                        
                        

                        selectedAll = true;

                    }
                }

                if (scObjList.length > 0) {
                    actionType = actionType | SELECTOR_ACTION;

                    var hasInfoWOnNode = this.hasInfoWOnNode(rows[attrIdxArray[treeLevel]]);
                    
                    var anchorNode = selectedAll ? null : hasInfoWOnNode ? touchedObj.node : null;

                    return {at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: anchorNode};
                }

                return null;

            },

            
            hasInfoWOnNode: function hasInfoWOnNode(rowH, onlyIfW) {
                var xtabModel = this.xtabModel,
                    docModel = (xtabModel && xtabModel.docModel);
                if (docModel) {
                    var layouts = docModel.defn && docModel.defn.layouts,
                        layout = null;
                    var i;
                    
                    if (layouts) {
                        for (i in layouts) {
                            if (layouts[i].loaded) {
                                layout = layouts[i];
                                break;
                            }
                        }
                    }
                    var units = layout && layout.units;
                    if (units && rowH) {
                        var tksList = rowH.sc.tks.split("\x1E");
                        for (var j = 0; j < tksList.length; j++) {
                            var unit = units[tksList[j]];
                            if (unit) {
                                if (this.isChildOfIfw(units, unit)) {
                                    if (!onlyIfW) {
                                        return true;
                                    }
                                } else {
                                    if (onlyIfW) {
                                        return false;
                                    }
                                }
                            }
                        }

                    }
                }

                return onlyIfW ? true : false;
            },

            getSelectionObjForNonTreeMode: function getSelectionObjForNonTreeMode(touchedObj) {
                var mcol = touchedObj.mcol,
                    mrow = touchedObj.mrow,
                    colInfos = this.colInfos;
                var attrIdxArray = this.attrMapIdx;
                var me = this,
                    model = me.model,
                    gts = model.gts,
                    rows = gts.row;

                var scObjList = [];
                var actionType = 0;
                var selectedAll = false;

                var id = colInfos[mcol].order;

                if (this.isAllAttrSelectable) {
                    

                    
                    
                    
                    

                    id = id.split(":")[0];

                    var hasTapRemainCell = this.updateUnselectedRemainCells({mrow: mrow, mcol: mcol});
                    if (hasTapRemainCell) {
                        return null;
                    }

                    if (mrow == this.prevSelected.mrow) { 
                        
                        if (mrow >= 0) {
                            
                            for (var key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                if (!obj.sc || !obj.sc.tks) { 
                                    continue;
                                }
                                
                                if (obj.sc.all === "false" || obj.sc.all === false) {
                                    var i = 0;
                                    var colInfos = this.colInfos;
                                    var colCount = colInfos.length;
                                    for (; i < colCount; i++) {
                                        if (key == colInfos[i].order.split(":")[0]) {
                                            break;
                                        }
                                    }
                                    this.unselectedRemainCells.push({mrow: mrow, mcol: i});
                                    continue;
                                }

                                var selectedIdx = obj.map[mrow];
                                var elementId = obj.es[selectedIdx].id;
                                if (!elementId || elementId.substring(0, 1) === "D") {
                                    
                                    continue;
                                }
                                ;
                                selectedAll = true;
                                this.addSCObjToList(scObjList, obj, "", "OA:(All)");
                            }
                            if (scObjList.length > 0) {
                                this.clearPreHighlightRowStatus();
                                this.prevSelected = {mrow: -2, mcol: -1};
                                this.updateUnselectedRemainCells();

                                actionType = actionType | SELECTOR_ACTION;
                                
                                var anchorNode = selectedAll ? null : touchedObj.node;
                                return {at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: anchorNode};
                            } else {
                                this.unselectedRemainCells = [];
                            }

                            
                            return {at: actionType};
                        }
                    } else {
                        this.updateUnselectedRemainCells();
                        this.unselectedRemainCells = [];
                    }

                    if (touchedObj.mrow == -1) {
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    } else {
                        if (this.ctlMatrix) {
                            this.clearPreHighlightRowStatus();

                            for (var key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                if (!obj.sc) { 
                                    continue;
                                }
                                if (!obj.sc.tks || (obj.sc.tks == "")) {
                                    
                                    continue;
                                }
                                var selectedIdx = obj.map[mrow];
                                if (obj.es[selectedIdx]) {
                                    var elementId = obj.es[selectedIdx].id;
                                    if (!elementId || elementId.substring(0, 1) === "D") {
                                        
                                        continue;
                                    }
                                    ;

                                    this.addSCObjToList(scObjList, obj, "", elementId);
                                }

                            }
                            if (scObjList.length > 0) {
                                this.rows[mrow].selected[-1] = true;
                                this.prevSelected = {mrow: mrow, mcol: -1};

                                actionType = actionType | SELECTOR_ACTION;
                                
                                var anchorNode = selectedAll ? null : touchedObj.node;
                                return {at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: anchorNode };
                            }
                        }
                    }

                } else {
                    
                    var isCG = false;
                    if (id.indexOf(":CG") === id.length - 3 && id.length >= 3) {
                        isCG = true;
                    }
                    id = id.split(":")[0];

                    
                    
                    
                    

                    if (this.ctlMatrix && this.ctlMatrix[id]) {
                        var ctlMatrix = this.ctlMatrix[id];
                        var ctlMatrixCG = this.ctlMatrix[id + ":CG"];

                        if (ctlMatrix.sc && ctlMatrix.sc.tks != "") {
                            
                            var elementId = "";
                            var isAll = false;

                            if (mrow == -1) {
                                
                                
                                
                                
                                
                                
                                
                                
                            } else {
                                var selectedIdx = ctlMatrix.map[mrow];
                                if (ctlMatrix.es[selectedIdx]) {
                                    elementId = ctlMatrix.es[selectedIdx].id;
                                    if (!elementId || elementId.substring(0, 1) === "D") {
                                        
                                        return;
                                    }
                                }

                                var sameAsLastSelected = function () {
                                    var result = ctlMatrix.selectedIdx[selectedIdx];
                                    if (ctlMatrixCG) {
                                        
                                        if (ctlMatrixCG.selectedIdx[-1]) {
                                            
                                            return result;
                                        } else {
                                            return result && ctlMatrixCG.selectedIdx[ctlMatrixCG.map[mrow]];
                                        }
                                    }
                                    return result;
                                }
                                if (sameAsLastSelected()) {
                                    
                                    var canSelectAll = !(ctlMatrix.sc.all === "false" || ctlMatrix.sc.all === false);
                                    if (canSelectAll) {
                                        elementId = "OA:(All)";
                                        selectedAll = true;
                                        ctlMatrix.selectedIdx = {};
                                        if (ctlMatrixCG) {
                                            ctlMatrixCG.selectedIdx = {};
                                        }
                                        this.prevSelected = {mrow: -2, mcol: -1};
                                    } else {
                                        return null;
                                    }

                                } else {
                                    
                                    ctlMatrix.selectedIdx = {};
                                    ctlMatrix.selectedIdx[selectedIdx] = true;

                                    if (ctlMatrixCG) {
                                        ctlMatrixCG.selectedIdx = {};
                                        if (isCG) {
                                            
                                            
                                            ctlMatrixCG.selectedIdx[ctlMatrixCG.map[mrow]] = true;
                                            if (ctlMatrixCG.map[mrow] < ctlMatrixCG.es.length) {
                                                
                                                elementId = ctlMatrixCG.es[ctlMatrixCG.map[mrow]].id;
                                            }
                                        } else {
                                            
                                            

                                            ctlMatrixCG.selectedIdx[-1] = true;
                                        }
                                    }

                                    
                                    this.prevSelected = {mrow: mrow, mcol: mcol};
                                }
                            }
                            var scObj = {};
                            scObj.sc = ctlMatrix.sc;
                            scObj.eid = elementId;
                            scObjList.push(scObj);
                        }
                    }

                    if (scObjList.length > 0) {
                        actionType = actionType | SELECTOR_ACTION;
                        
                        var anchorNode = selectedAll ? null : touchedObj.node;
                        return {at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: anchorNode};
                    }
                }

                return null;

            },

            getLinkDrillObjForTreeMode: function getLinkDrillObjForTreeMode(touchedObj) {

                var actionType = 0;
                var linkDrillNode = null;

                var model = this.model,
                    gts = model.gts,
                    rowHs = gts.row;
                var mcol = touchedObj.mcol,
                    mrow = touchedObj.mrow,
                    colInfos = this.colInfos;

                var treeNode = touchedObj.treeNode;
                var treePath = treeNode.treePath;
                var treePathArray = treePath.split("_");
                var treeLevel = treePathArray.length - 1;
                var attrIdxArray = this.attrMapIdx;

                
                var id = null;
                var colInfo = colInfos[mcol];
                var colType = colInfo && colInfo.type;
                if (colType == ATTR_NAME) {
                    if (mrow == -1) {
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    } else {
                        
                        var rowH = rowHs[attrIdxArray[treeLevel]];
                        if (rowH.lm && rowH.lm[0] && rowH.lm[0].links) {
                            linkDrillNode = {};
                            linkDrillNode.titleInfo = rowH;
                            var treeNode = getTreeNode(this.tree, treePath);
                            linkDrillNode._e = treeNode.es[0] || {n: "", id: ""};
                            linkDrillNode.v = linkDrillNode._e.n;
                        }
                    }

                } else if (colType == METRIC_VALUE) {
                    if (colInfo.lm) {
                        

                        id = colInfo.order;
                        
                        var mix = parseInt(id); 

                        var metricH = gts.col[0];

                        if (metricH) {
                            
                            linkDrillNode = {};
                            linkDrillNode.mix = mix;
                            linkDrillNode.titleInfo = metricH;

                            if (mrow == -1) {
                                
                                linkDrillNode._e = metricH.es[mix] || {n: "", id: ""};
                                linkDrillNode.v = linkDrillNode._e.n;
                            } else {
                                
                                
                                var currNode = linkDrillNode;
                                var treeNode = this.tree;
                                for (var i = 0; i < treePathArray.length; i++) {
                                    var idx = treePathArray[i];
                                    treeNode = treeNode.childrenTreeNodeList[idx];

                                    var attrIdx = attrIdxArray[i];
                                    rowH = rowHs[attrIdx];

                                    var nodeLP = {};
                                    nodeLP.titleInfo = rowH;
                                    nodeLP._e = treeNode.es[0] || {n: "", id: ""};
                                    nodeLP.v = nodeLP._e.n;

                                    currNode._lp = nodeLP;
                                    currNode.axis = ROW_AXIS;
                                    currNode = nodeLP;
                                }
                            }
                        }
                    }

                }

                if (linkDrillNode) {
                    this.highlightEntireRow = false;
                    actionType = actionType | HYPERLINK_ACTION;
                    return {at: actionType, k: this.getModelK(), node: linkDrillNode};
                }
            },

            getLinkDrillObjForNonTreeMode: function getLinkDrillObjForNonTreeMode(touchedObj) {
                var actionType = 0;

                var model = this.model,
                    gts = model.gts,
                    rowHs = gts.row;
                var mcol = touchedObj.mcol,
                    mrow = touchedObj.mrow,
                    colInfos = this.colInfos;

                var node = touchedObj.node, titleInfo;
                this.highlightEntireRow = false;
                var attrIdxArray = this.attrMapIdx;
                var colInfo = colInfos[mcol];

                if (!this.isKPI) {
                    
                    if (linkCount === 1 && attrCount === 1 && mrow != -1) {
                        
                        for (var key in colInfos) {
                            var colInf = colInfos[key];
                            if (colInf.lm && colInf.type == ATTR_NAME) {
                                
                                
                                this.highlightEntireRow = true;
                                var titleInfo = colInf.lm;
                                actionType = titleInfo && titleInfo.at || HYPERLINK_ACTION;
                                node._e = this.rows[mrow].model.elms[colInf.order] || { id: "", n: "" };
                                node.v = node._e.n;
                                break;
                            }
                        }

                    }

                    if (!this.highlightEntireRow) {

                        if (colInfo.type == CHART) {
                            return null;
                        }

                        var titleInfo = colInfo.lm;
                        if (titleInfo) {
                            actionType = titleInfo && titleInfo.at;

                            if (colInfo.type == ATTR_NAME) {
                                
                                if (mrow === -1) { 
                                    
                                    node._e = {};
                                    node._e.onTitle = true;
                                    node._e.id = titleInfo.id;
                                    node._e.n = titleInfo.n;
                                    node.v = titleInfo.n;
                                } else { 
                                    node._e = this.rows[mrow].model.elms[colInfo.order] || { id: "", n: "" };
                                    node.v = node._e.n;
                                }
                            } else if (colInfo.type == METRIC_VALUE) { 
                                node.mix = colInfo.order;
                                node.axis = ROW_AXIS;

                                this.buildLeftParent(node, mrow, mcol);
                                actionType = this.rows[mrow == -1 ? 0 : mrow].model.refv[colInfo.order].at || HYPERLINK_ACTION;
                            }
                        }
                    }
                } else {
                    
                    if (colInfo.type == CHART) {
                        return null;
                    }
                    var titleInfo = colInfo.lm;
                    var metricIdx = this.rows[mrow].model.metricIdx;
                    if (titleInfo && titleInfo.lm && titleInfo.lm[metricIdx] && titleInfo.lm[metricIdx].links) {

                        node.mix = "" + metricIdx;
                        node.axis = ROW_AXIS;

                        this.buildLeftParent(node, metricIdx, mcol);
                        actionType = this.rows[mrow].model.refv[0].at || HYPERLINK_ACTION;
                    } else {
                        titleInfo = null;
                    }

                }

                if (titleInfo) {
                    node.titleInfo = titleInfo;
                    actionType = actionType | HYPERLINK_ACTION;

                    return {at: actionType, mcol: mcol, mrow: mrow, k: this.getModelK(), node: node};
                }

                return null;
            },

            getActionObj: function getActionObj(touchedObj) {
                var actionObjList = [];

                if (touchedObj.mrow == -1) {
                    
                    return null;
                }

                var actionObj = null;

                
                if (this.isTreeMode) {
                    actionObj = this.getSelectionObjForTreeMode(touchedObj);
                } else {
                    actionObj = this.getSelectionObjForNonTreeMode(touchedObj);
                }

                if (actionObj) {
                    actionObjList.push(actionObj);
                    return actionObjList;
                } else {
                    
                    if (this.isTreeMode) {
                        actionObj = this.getLinkDrillObjForTreeMode(touchedObj);
                    } else {
                        actionObj = this.getLinkDrillObjForNonTreeMode(touchedObj);
                    }
                    actionObjList.push(actionObj);
                }
                return actionObjList;
            },

            
            getDefaultHighlightRow: function getDHR() {
                var attrIdxArray = this.attrMapIdx;
                var rows = this.model.gts.row;

                if (!this.isTreeMode) {

                    if (this.isAllAttrSelectable) {
                        
                        

                        var isAllSelected = false;
                        var resultSet = null,
                            controlMatrix = null;
                        var hasOnlyIfwTarget = true;
                        var colInfos = this.colInfos,
                            colCount = colInfos.length;

                        for (var i = 0; i < colCount; i++) {
                            var colInfo = colInfos[i],
                                id = colInfo.order;
                            var trueId = id.split(":")[0];
                            if (id != trueId + ":CG") {
                                
                                id = trueId;
                            }
                            controlMatrix = this.ctlMatrix[id];
                            if (controlMatrix) {
                                if (!this.hasInfoWOnNode(controlMatrix, true)) {
                                    hasOnlyIfwTarget = false;
                                }
                                
                                
                                if (controlMatrix.selectedIdx[-1]) {
                                    
                                    isAllSelected = true;
                                    this.prevSelected = {
                                        mrow: -1,
                                        mcol: i
                                    };
                                    
                                } else {
                                    colInfo.selected = false;
                                }

                                if (!isAllSelected) {
                                    if (!resultSet) {
                                        
                                        resultSet = {};
                                        for (var j = 0; j < controlMatrix.map.length; j++) {
                                            if (controlMatrix.selectedIdx[controlMatrix.map[j]]) {
                                                resultSet[j] = true;
                                            }
                                            ;
                                        }
                                        ;
                                    } else { 
                                        for (var j in resultSet) {
                                            if (!controlMatrix.selectedIdx[controlMatrix.map[j]]) { 
                                                delete resultSet[j];
                                            }
                                            ;
                                        }
                                        ;
                                    }
                                    ;
                                }
                                ;
                            }
                        }

                        if (hasOnlyIfwTarget) {
                            
                            for (key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                obj.selectedIdx = {};
                            }
                        }
                        if (hasOnlyIfwTarget || isAllSelected || !resultSet || Object.keys(resultSet).length !== 1) {
                            
                        } else {
                            console.log("xiawang: The selected row is:" + JSON.stringify(resultSet));
                            var selectedRow = parseInt(Object.keys(resultSet)[0]);
                            this.prevSelected = {
                                mrow: selectedRow,
                                mcol: -1
                            };

                            if (this.rows[selectedRow]) {
                                this.rows[selectedRow].selected[-1] = true;
                            }

                            
                            for (key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                obj.selectedIdx = {};
                            }
                        }
                    } else {
                        
                        var hasOnlyIfwTarget = true;
                        for (key in this.ctlMatrix) {
                            var controlMatrix = this.ctlMatrix[key];
                            var checkThisAttr = false;
                            for (var sIdx in controlMatrix.selectedIdx) {
                                checkThisAttr = true;
                            }
                            if (checkThisAttr && !this.hasInfoWOnNode(controlMatrix, true)) {
                                hasOnlyIfwTarget = false;
                                break;
                            }
                        }

                        if (hasOnlyIfwTarget) {
                            
                            for (key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                obj.selectedIdx = {};
                            }
                        }
                    }

                } else {
                    
                    
                    if (this.currSelectedObj && this.currSelectedObj.length <= 0) {
                        var resultSet = null,
                            controlMatrix = null;

                        this.currSelectedObj = [];

                        var findTreeNodeByAttrElemIdx = function (treeNodeList, attrElemIdx) {
                            var treeNodeCount = treeNodeList.length;
                            for (var i = 0; i < treeNodeCount; i++) {
                                var treeNode = treeNodeList[i];
                                if (treeNode.attrElemIdx == attrElemIdx) {
                                    return treeNode;
                                }
                            }
                            return null;
                        };

                        var me = this;

                        var findCurrSelectedObjByAttrElemIdx = function (tree, level) {
                            var id = me.attrIDArray[level];
                            controlMatrix = me.ctlMatrix[id];

                            var treeNodeList = tree.childrenTreeNodeList;
                            var treeNodeCount = treeNodeList.length;
                            if (treeNodeCount <= 0) {
                                return;
                            }

                            var treeNode = null;
                            if (controlMatrix) {
                                for (var key in controlMatrix.selectedIdx) {
                                    treeNode = findTreeNodeByAttrElemIdx(treeNodeList, key);
                                }

                                if (treeNode) {
                                    me.currSelectedObj[level] = treeNode;
                                    findCurrSelectedObjByAttrElemIdx(treeNode, level + 1);

                                    return true;
                                }

                            } else {
                                
                                me.currSelectedObj[level] = null;
                                for (var i = 0; i < treeNodeCount; i++) {
                                    var find = findCurrSelectedObjByAttrElemIdx(treeNodeList[i], level + 1);
                                    if (find) {
                                        return true;
                                    }
                                }

                            }

                            return false;

                        };

                        findCurrSelectedObjByAttrElemIdx(this.tree, 0);

                        
                        while (this.currSelectedObj.length > 0 && !this.currSelectedObj[this.currSelectedObj.length - 1]) {
                            this.currSelectedObj.pop();
                        }

                        
                        var hasOnlyIfwTarget = true;
                        for (var i = 0; i < this.currSelectedObj.length; i++) {
                            var treeNode = this.currSelectedObj[i];
                            if (treeNode) {
                                var attrIdx = attrIdxArray[i];
                                rowH = rows[attrIdx];
                                if (!this.hasInfoWOnNode(rowH, true)) {
                                    hasOnlyIfwTarget = false;
                                    break;
                                }
                            } else {
                                
                                continue;
                            }
                        }
                        if (hasOnlyIfwTarget) {
                            this.currSelectedObj = [];
                        }

                        this.lastSelectedObj = $HASH.clone(this.currSelectedObj);
                        return;

                    }
                }
            },

            
            updateSelectedStatus: function updateSS(tree) {
                if (this.isTreeMode) {
                    this.updateTreeSelection(tree);
                } else if (!this.isAllAttrSelectable || this.unselectedRemainCells.length > 0) {

                    if (!this.ctlMatrix) {
                        return;
                    }
                    
                    var update = function (key) {
                        var pureId = key.split(":")[0],
                            ctlMatrix = this.ctlMatrix[pureId],
                            ctlMatrixCG = this.ctlMatrix[pureId + ":CG"];

                        
                        
                        var colInfos = this.colInfos,
                            selectedIdx = ctlMatrix.selectedIdx,
                            colIdx = ctlMatrix.colIdx;
                        
                        
                        
                        
                        
                        
                        

                        
                        if (ctlMatrixCG && !ctlMatrixCG.selectedIdx[-1]) {
                            
                            
                            
                            ctlMatrix = ctlMatrixCG;
                        }
                        var map = ctlMatrix.map,
                            rows = this.rows,
                            rowCount = rows.length,
                            selectedIdx = ctlMatrix.selectedIdx,
                            colIdx = this.ctlMatrix[key].colIdx,
                            assAttr = colInfos[colIdx].associateAttr;

                        for (var i = 0; i < rowCount; i++) {
                            var rowInfo = rows[i];
                            if (selectedIdx[map[i]]) {
                                rowInfo.selected[colIdx] = true;
                                
                                for (var idx in assAttr) {
                                    rowInfo.selected[assAttr[idx]] = true;
                                }
                            } else {
                                rowInfo.selected[colIdx] = false;
                                for (var idx in assAttr) {
                                    rowInfo.selected[assAttr[idx]] = false;
                                }
                            }
                        }
                    }

                    for (var key in this.ctlMatrix) {

                        update.call(this, key);
                    }
                }

            },

            hasOnlyInfoWindowTarget: function hasOnlyInfoWindowTarget() {

            },

            performAction: function performAction(actionObjList) {
                this.hasNonifwTarget = this.hasNoninfowindowTarget(actionObjList[0]);

                if (this._super) {
                    this._super(actionObjList);
                }

            },

            
            clearPreHighlightRowStatus: function clearPreHighlightRowStatus(pass) {
                var mrow = this.prevSelected.mrow,
                    mcol = this.prevSelected.mcol;

                if (mrow == -2) {
                    
                    return;
                }
                if (mcol == -1) {
                    
                    this.rows[mrow].selected[-1] = false;
                } else {
                    
                    if (mrow == -1) {
                        
                        for (var i = 0; i < this.colInfos.length; i++) {
                            var colInfo = this.colInfos[i];
                            if (colInfo.selected) {
                                colInfo.selected = false;
                            }
                        }
                        
                    } else {
                        this.rows[mrow].selected[mcol] = false;
                    }

                }

            },

            updateUnselectedRemainCells: function uurc(tappedCell) {
                var hasTapRemainCell = false;

                for (var i = this.unselectedRemainCells.length - 1; i >= 0; i--) {
                    cell = this.unselectedRemainCells[i];

                    var id = order[cell.mcol];

                    var isCG = false;
                    if (id.indexOf(":CG") === id.length - 3
                        && id.length >= 3) {
                        isCG = true;
                    } else {
                        id = id.split(":")[0];
                    }

                    var obj = this.ctlMatrix[id];
                    
                    var anotherObj = undefined;
                    if (isCG) {
                        anotherObj = this.ctlMatrix[id.split(":")[0]];
                    } else {
                        anotherObj = this.ctlMatrix[id + ":CG"];
                    }
                    if (obj.sc && obj.sc.tks != "") {

                        if (anotherObj && !anotherObj.sc) {
                            anotherObj = undefined;
                        }

                        var selectedIdx = obj.map[cell.mrow];
                        elementId = obj.es[selectedIdx].id;
                        if (!elementId || elementId.substring(0, 1) === "D") {
                            
                            
                            continue;
                        } else {
                            if (obj.selectedIdx[selectedIdx]) {
                                if (tappedCell) {
                                    if (cell.mcol == tappedCell.mcol) {
                                        
                                        var tappedID = order[cell.mcol].split(":")[0];
                                        var tappedCtlMatrix = this.ctlMatrix[tappedID];
                                        var tappedIdx = tappedCtlMatrix.sc && tappedCtlMatrix.map[tappedCell.mrow];
                                        if (tappedIdx == selectedIdx) {
                                            hasTapRemainCell = true;
                                        }
                                    }
                                    continue;

                                }
                                
                                obj.selectedIdx = {};

                            } else {
                                obj.selectedIdx = {};
                                
                                obj.selectedIdx[selectedIdx] = true;
                                if (anotherObj) {
                                    if (elementId.indexOf("BE") === 0 || elementId.indexOf("Z") === 0) {
                                        
                                    } else {
                                        
                                        anotherObj.selectedIdx = {};
                                        anotherObj.selectedIdx[selectedIdx] = true;
                                    }
                                }
                            }

                        }
                    }

                }

                return hasTapRemainCell;

            },

            highlightCellsByRowInfo: function highlightCellsByRowInfo(rowInfo) {
                var rowRef = rowInfo.rowRef;
                if (!rowRef) {
                    return;
                }

                var trL = rowRef[LEFT_CHART_ROW];
                var trR = rowRef[RIGHT_CHART_ROW];

                var tdsL = trL && trL.childNodes;
                var tdsR = trR && trR.childNodes;
                var tdsLLen = tdsL && tdsL.length || 0,
                    tdsRLen = tdsR && tdsR.length || 0;

                var colCount = tdsLLen + tdsRLen;

                for (var i = 0; i < colCount; i++) {
                    var td = i < tdsLLen ? tdsL[i] : tdsR[i - tdsLLen];
                    if (rowInfo.selected[i]) {
                        this.highlightCell(td);
                    } else {
                        this.unHighlightCell(td);
                    }
                }
            },

            setSelectedStyle: function setSelectedStyle(level) {
                if (level == 0) {
                    this.selectedStyle = "background-color:#015DE6;color:#FFFFFF;";
                } else if (level == 1) {
                    this.selectedStyle = "background-color:rgba(1,93,230, 0.7);color:#FFFFFF;";
                } else {
                    this.selectedStyle = "background-color:rgba(1,93,230, 0.5);color:#FFFFFF;";
                }

            },

            highlightTreeArrow: function highlightTreeArrow(rowInfo) {
                if (this.treeColumnIdx > -1 && this._leftChart) {
                    this._leftChart.setTreeArrow(rowInfo, 'white');
                }
            },

            unHighlightTreeArrow: function unHighlightTreeArrow(rowInfo) {
                if (this.treeColumnIdx > -1 && this._leftChart) {
                    this._leftChart.setTreeArrow(rowInfo);
                }
            },

            highlightCell: function highlightCell(td, isHeaderTable) {
                
                if (isHeaderTable) {
                    setNodeCssText(td, TH_SELECTED_CSS + this.selectedStyle);
                } else {
                    setNodeCssText(td, TD_SELECTED_CSS + this.selectedStyle);
                }
                if (this.selectedClass && this.selectedClass.length > 0) {
                    $CSS.addClass(td, this.selectedClass);
                }

            },

            unHighlightCell: function unHighlightCell(td, isHeaderTable) {
                
                if (isHeaderTable) {
                    setNodeCssText(td, DEFAULT_TH_CSS);
                } else {
                    setNodeCssText(td, DEFAULT_TD_CSS);
                }
                if (this.selectedClass && this.selectedClass.length > 0) {
                    $CSS.removeClass(td, this.selectedClass);
                }
            },

            highlightForLD: function highlightForLD(mrow, mcol, node) {
                if (this.highlightEntireRow && !this.isTreeMode) {
                    this.highlightRowByRowInfo(this.rows[mrow]);
                } else {
                    if (node) {
                        this.highlightCell(node);
                    }

                    var colInfo = this.colInfos[mcol],
                        aAttr = colInfo.associateAttr;
                    var siblings = node.parentNode.childNodes;
                    for (var idx in aAttr) {
                        this.highlightCell(siblings[aAttr[idx]]);

                        if (this.treeColumnIdx == idx) {
                            this.highlightTreeArrow(this.rows[mrow]);
                        }
                    }
                }

            },

            highlightRowByRowInfo: function highlightRowByRowInfo(rowInfo) {
                var rowRef = rowInfo.rowRef;
                if (!rowRef) {
                    return;
                }
                var level = rowInfo.treeNode ? rowInfo.treeNode.level : 0;
                this.setSelectedStyle(level);
                if (rowRef[LEFT_CHART_ROW]) {
                    this.highlightRow(rowRef[LEFT_CHART_ROW]);
                }
                if (rowRef[RIGHT_CHART_ROW]) {
                    this.highlightRow(rowRef[RIGHT_CHART_ROW]);
                }

                
                this.highlightTreeArrow(rowInfo);

            },

            highlightRow: function highlightRow(tr) {
                var tds = tr.childNodes;
                for (var i = 0; i < tds.length; i++) {
                    
                    setNodeCssText(tds[i], TD_SELECTED_CSS + this.selectedStyle);

                    if (this.selectedClass && this.selectedClass.length > 0) {
                        $CSS.addClass(tds[i], this.selectedClass);
                    }
                }
            },

            unHighlightRowByRowInfo: function unHighlightRowByRowInfo(rowInfo) {
                var rowRef = rowInfo.rowRef;
                if (!rowRef) {
                    return;
                }
                if (rowRef[LEFT_CHART_ROW]) {
                    this.unHighlightRow(rowRef[LEFT_CHART_ROW]);
                }
                if (rowRef[RIGHT_CHART_ROW]) {
                    this.unHighlightRow(rowRef[RIGHT_CHART_ROW]);
                }

                
                this.unHighlightTreeArrow(rowInfo);

            },

            unHighlightRow: function unHighlightRow(tr) {
                var tds = tr.childNodes;
                for (var i = 0; i < tds.length; i++) {
                    
                    setNodeCssText(tds[i], DEFAULT_TD_CSS);
                    if (this.selectedClass && this.selectedClass.length > 0) {
                        $CSS.removeClass(tds[i], this.selectedClass);
                    }
                }
            },

            
            isAttrSelectable: function isAttrSelectable(treeLevel) {
                var attrID = this.attrIDArray[treeLevel];
                var ctlMatrix = this.ctlMatrix[attrID];
                if (ctlMatrix) {
                    return true;
                }
                return false;
            },

            
            updateTreeSelection: function updateTreeSelection(tree) {
                
                this.selectOrClearTreeNodes(tree, true, 0);
                
                this.selectOrClearTreeNodes(tree, false, 0);
            },

            findTheTreeNodeWithSameID: function findTheTreeNodeWithSameID(treeNodeList, id) {
                var treeNodeCount = treeNodeList.length;
                for (var i = 0; i < treeNodeCount; i++) {
                    var treeNode = treeNodeList[i];
                    if (treeNode.id == id) {
                        return treeNode;
                    }
                }
                return null;
            },

            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            

            selectOrClearTreeNodes: function selectOrClearTreeNodes(treeNode, clear, treeLevel) {
                if (!treeNode) {
                    return;
                }
                if (clear && this.lastSelectedObj.length <= treeLevel) {
                    
                    return;
                }
                if (!clear && this.currSelectedObj.length <= treeLevel) {
                    
                    return;
                }

                var tappedTreeNode = null;

                if (clear) {
                    tappedTreeNode = this.lastSelectedObj[treeLevel];
                } else {
                    tappedTreeNode = this.currSelectedObj[treeLevel];
                }

                var treeNodeList = treeNode.childrenTreeNodeList,
                    treeNodeCount = treeNodeList.length;

                if (tappedTreeNode) {

                    treeNode = this.findTheTreeNodeWithSameID(treeNodeList, tappedTreeNode.id);

                    if (treeNode) {
                        
                        treeNode.selected = clear ? false : true;
                        this.selectOrClearTreeNodes(treeNode, clear, treeLevel + 1);
                    }
                } else {
                    for (var i = 0; i < treeNodeCount; i++) {
                        this.selectOrClearTreeNodes(treeNodeList[i], clear, treeLevel + 1);
                    }
                }

            },

            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            

            updateHighlightForCurrRenderRows: function updateHighlightForCurrRenderRows() {
                
                var rows = this.rows;
                var rowCount = rows.length,
                    rowInfo = null;
                for (var i = this.startCnt; i < this.endCnt; i++) {
                    rowInfo = rows[i];
                    if (this.isTreeMode) {
                        
                        if (rowInfo.treeNode.selected) {
                            this.highlightRowByRowInfo(rowInfo);
                        } else {
                            this.unHighlightRowByRowInfo(rowInfo);
                        }
                    } else {
                        
                        if (this.isAllAttrSelectable) {
                            if (rowInfo.selected[-1]) {
                                
                                this.highlightRowByRowInfo(rowInfo);
                            } else {
                                this.unHighlightRowByRowInfo(rowInfo);
                            }
                        } else {
                            this.highlightCellsByRowInfo(rowInfo);
                        }

                        if (this.unselectedRemainCells.length > 0) {
                            this.highlightCellsByRowInfo(rowInfo);
                        }
                    }
                }

                if (this.isTreeMode) {
                    
                    rows = this.dockedHeaderRows;
                    rowCount = rows.length;
                    for (var i = 0; i < rowCount; i++) {
                        rowInfo = rows[i];
                        if (rowInfo.treeNode.selected) {
                            this.highlightRowByRowInfo(rowInfo);
                        } else {
                            this.unHighlightRowByRowInfo(rowInfo);
                        }
                    }
                    rows = this.dockedHeaderReplaceRows;
                    rowCount = rows.length;
                    for (var i = 0; i < rowCount; i++) {
                        rowInfo = rows[i];
                        if (rowInfo.treeNode.selected) {
                            this.highlightRowByRowInfo(rowInfo);
                        } else {
                            this.unHighlightRowByRowInfo(rowInfo);
                        }
                    }
                }

            },

            
            getSelectedTreeNodeListFromTreePath: function getSelectedTreeNodeListFromTreePath(treePathArray) {
                if (!treePathArray) {
                    return [];
                }
                var treeNodeList = [];
                var treeNode = this.tree;
                for (var i = 0; i < treePathArray.length; i++) {
                    var treeNodeIdx = treePathArray[i];
                    treeNode = treeNode.childrenTreeNodeList[treeNodeIdx];
                    if (!treeNode) {
                        break;
                    }
                    if (this.isAttrSelectable(i)) {
                        treeNodeList[i] = treeNode;
                    } else {
                        treeNodeList[i] = null;
                    }

                }
                return treeNodeList;
            },

            multiTap: true,

            touchTap: function (touch) {
                var widget = this;

                if (widget.tooltip.style["display"] === "block") {
                    hideTooltipGlobal.call(this);
                    return;
                }

                var td = mstrmojo.dom.findAncestorByAttr(touch.target, "mcol", true, this.domNode);
                if (!td) {
                    this._leftChart.dockedHeaderReplaceDiv.style.display = 'none';
                    touch.target = document.elementFromPoint(touch.pageX, touch.pageY);
                    td = mstrmojo.dom.findAncestorByAttr(touch.target, "mcol", true, this.domNode);
                    this._leftChart.dockedHeaderReplaceDiv.style.display = '';
                }
                if (td && td.node) {
                    
                    var mrow = parseInt(td.node.getAttribute("mrow"));
                    var mcol = parseInt(td.node.getAttribute("mcol"));

                    if (mrow == -1) {
                        
                        
                        return;
                    }

                    if (this.isTreeMode) {

                        if (mrow >= 0) {
                            
                            var rowInfo = this.rows[mrow];
                            var treeNode = rowInfo && rowInfo.treeNode;
                            if (touch.count == 2 || ( touch.count == 1 && mcol == this.treeColumnIdx)) {
                                

                                
                                if (!treeNode.isLeaf) {

                                    this.rowsNeedRebuild = true;

                                    var rowType = td.node.parentNode.getAttribute("rowType");

                                    if (treeNode.needExpand) {
                                        
                                        collapseTreeNodeAndSetScrlPos.call(this, rowInfo, rowType);
                                    } else {
                                        
                                        expandTreeNodeAndSetScrlPos.call(this, rowInfo, rowType);
                                    }
                                }
                                return;
                            }
                        }

                        
                        var touchedObj = {node: td.node, treeNode: treeNode, mcol: mcol, mrow: mrow};
                        var actionObjList = this.getActionObj(touchedObj);
                        var actionObj = actionObjList && actionObjList[0];
                        if (actionObj) {

                            if (actionObj.at & SELECTOR_ACTION) {
                                

                                
                                var doHighlight = !(this.isAndroidPhone && actionObj.anchor);
                                if (doHighlight) {
                                    this.updateSelectedStatus(this.tree);
                                    this.updateHighlightForCurrRenderRows();

                                    this.lastSelectedObj = $HASH.clone(this.currSelectedObj);
                                }

                            } else if (actionObj.at & HYPERLINK_ACTION) {
                                
                                this.highlightForLD(mrow, mcol, td.node);
                            }

                            this.performAction(actionObjList);
                            
                            return;
                        }

                    } else {
                        
                        var actionObjList = this.getActionObj({mcol: mcol, mrow: mrow, node: td.node});
                        var actionObj = actionObjList && actionObjList[0];
                        if (actionObj) {

                            if (actionObj.at & SELECTOR_ACTION) {
                                
                                var doHighlight = !(this.isAndroidPhone && actionObj.anchor);
                                if (doHighlight) {
                                    this.updateSelectedStatus();
                                    this.updateHighlightForCurrRenderRows();
                                }

                            } else if (actionObj.at & HYPERLINK_ACTION) {
                                this.highlightForLD(mrow, mcol, td.node);
                            }

                            this.performAction(actionObjList);
                            return;
                        }

                    }

                    
                    var me = this;
                    var tr = td.node.parentNode;
                    var rowInfo = null;
                    if (tr.getAttribute("rowType") == DOCKED_HEADER) {
                        var dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderRows, mrow);
                        if (dockedHeaderIdx >= 0) {
                            rowInfo = this.dockedHeaderRows[dockedHeaderIdx];
                        } else {
                            dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderReplaceRows, mrow);
                            rowInfo = this.dockedHeaderReplaceRows[dockedHeaderIdx];
                        }
                    } else {
                        rowInfo = this.rows[mrow];
                    }

                    var touchedChart = rowInfo && rowInfo.rowRef && rowInfo.rowRef[mcol];
                    if (touchedChart) {
                        this.showChartTooltip(touchedChart, touch);
                    }

                }

            },

            
            shouldTouchBubble: function shouldTouchBubble(touch) {
                var isVertical = touch.isVertical;
                return isVertical ? this._super(touch) : this.enableSmoothScroll && isScrollableElementTouched.call(this, touch) ? false : true;
            },
            
            
            
            
            
            
            
            

            multiTouch: true,

            touchMultiBegin: function (touch) {
                
                
                
                
                hideTooltipGlobal.call(this);
                this.initTouchObj = touch;
                var touch1;
                var touch2;
                if (touch.evt.touches
                    && touch.evt.touches.length == 2) {
                    touch1 = touch.evt.touches[0];
                    touch2 = touch.evt.touches[1];
                } else {
                    touch1 = touch;
                    touch2 = {
                        pageX: 100,
                        pageY: 100,
                        target: touch.target
                    };
                }
                var xDiff = touch1.pageX - touch2.pageX;
                var yDiff = touch1.pageY - touch2.pageY;
                this.initDiffDiff = xDiff * xDiff + yDiff * yDiff;

                this.relScaleFactor = 1;

                var td1 = mstrmojo.dom.findAncestorByAttr(touch1.target, "mrow", true, this.domNode);
                var td2 = mstrmojo.dom.findAncestorByAttr(touch2.target, "mrow", true, this.domNode);
                if (td1 && td1.value && td2 && td2.value) {
                    this.centerRowIdx = Math.round(( parseInt(td1.value) + parseInt(td2.value) ) / 2);
                } else {
                    this.centerRowIdx = this.firstRowIdxOnScrn;
                }

                
                
                
            },

            touchMultiMove: function (touch) {
                
                
                
                var touch1;
                var touch2;
                if (touch.evt.touches
                    && touch.evt.touches.length == 2) {
                    touch1 = touch.evt.touches[0];
                    touch2 = touch.evt.touches[1];
                } else {
                    touch1 = touch;
                    touch2 = {
                        pageX: 100,
                        pageY: 100
                    };
                }
                var xDiff = touch1.pageX - touch2.pageX;
                var yDiff = touch1.pageY - touch2.pageY;
                this.curDiffDiff = xDiff * xDiff + yDiff * yDiff;
            },

            touchMultiEnd: function (touch) {
                if (this.isTreeMode) {
                    if (this.curDiffDiff > this.initDiffDiff) {
                        this.onPinchOpen();
                    } else if (this.curDiffDiff < this.initDiffDiff) {
                        this.onPinchClose();
                    }
                }

            },

            onPinchOpen: function onPinchOpen() {
                var currLowestLevel = getLowestLevelOnScreen.call(this);
                var levelToExpand = currLowestLevel;
                if (levelToExpand >= this.maxTreeLevel) {
                    
                    levelToExpand = this.maxTreeLevel - 1;
                }

                var anchorRowTreeNode = this.rows[this.centerRowIdx].treeNode;
                var anchorRowIdxOnScrn = this.centerRowIdx - this.firstRowIdxOnScrn;

                expandOrCollapseTreeAndSetScrlPos.call(this, levelToExpand, anchorRowTreeNode, anchorRowIdxOnScrn);
            },

            onPinchClose: function onPinchClose() {
                var currLowestLevel = getLowestLevelOnScreen.call(this);
                var levelToExpand = currLowestLevel - 2;
                if (levelToExpand < -1) {
                    
                    
                    levelToExpand = -1;
                }

                var anchorRowTreeNode = this.rows[this.centerRowIdx].treeNode;

                if (anchorRowTreeNode.level > levelToExpand + 1) {
                    
                    anchorRowTreeNode = getParentTreeNodeAtLevel(this.tree, anchorRowTreeNode.treePath, levelToExpand + 1);
                }
                var anchorRowIdxOnScrn = this.centerRowIdx - this.firstRowIdxOnScrn;

                expandOrCollapseTreeAndSetScrlPos.call(this, levelToExpand, anchorRowTreeNode, anchorRowIdxOnScrn);

            },

            
            destroyChartWidget: function destroyChartWidget() {

                if (this.rows && this.rows.length > 0 && this.rowsReusePool) {
                    this.pushToReusePool();
                }

                if (this.dockedHeaderRows && this.dockedHeaderReplaceRows) {
                    this.clearDockedHeader();
                }

                if (this.rowsReusePool && this.rowsReusePool.length > 0) {
                    var rows = this.rowsReusePool,
                        rowCount = rows.length,
                        colInfos = this.colInfos,
                        colCount = colInfos.length;

                    for (var i = 0; i < rowCount; i++) {
                        var rowRef = rows[i];

                        if (rowRef[LEFT_CHART_ROW]) {
                            delete rowRef[LEFT_CHART_ROW];
                        }
                        if (rowRef[RIGHT_CHART_ROW]) {
                            delete rowRef[RIGHT_CHART_ROW];
                        }

                        for (var j = 0; j < colCount; j++) {
                            var w = rowRef[colInfos[j].colIdx];
                            if (w && w.destroy) {
                                w.destroy();
                                delete rowRef[colInfos[j].colIdx];
                            }
                        }
                    }
                    this.rowsReusePool = [];
                }

            },

            destroy: function destroy() {
                console.log("in destroy");
                
                var listener = this._touchListener;
                if (listener) {
                    
                    mstrmojo.touchManager.detachEventListener(listener);
                    delete this._touchListener;
                }

                if (this._infoWClosedListener) {
                    mstrmojo.touchManager.detachEventListener(this._infoWClosedListener);
                    delete this._infoWClosedListener;
                }

                this.destroyChartWidget();

                if (this._leftChart) {
                    this._leftChart.destroy();
                    delete this._leftChart;
                }

                if (this._rightChart) {
                    this._rightChart.destroy();
                    delete this._rightChart;
                }

                if (this.rows) {
                    delete this.rows;
                }

                if (this.rowsReusePool) {
                    delete this.rowsReusePool;
                }

                if (this.selectorTargets) {
                    delete this.selectorTargets;
                }

                this._super();
            }



        });

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.DocSelectorViewFactory",
                         "mstrmojo.android.DropDownList",
                         "mstrmojo.android.selectors.CheckList",
                         "mstrmojo.android.selectors.ListBox",
                         "mstrmojo.android.selectors.LinkBar",
                         "mstrmojo.android.selectors.ButtonBar",
                         "mstrmojo.android.selectors.Slider",
                         "mstrmojo.array");

    var $STYLES = mstrmojo.DocSelectorViewFactory.STYLES;

    
    var widgetMap = {};
    widgetMap[$STYLES.RADIO] = 'CheckList';
    widgetMap[$STYLES.CHECKBOX] = 'CheckList';
    widgetMap[$STYLES.LIST] = 'ListBox';
    widgetMap[$STYLES.LINK] = 'LinkBar';
    widgetMap[$STYLES.BUTTON] = 'ButtonBar';
    widgetMap[$STYLES.SCROLLER] = 'Slider';
    
    widgetMap['9'] = 'LinkBar';

    
    mstrmojo.android.DocSelectorViewFactory = mstrmojo.declare(

        mstrmojo.DocSelectorViewFactory,

        null,

        
        {
            scriptClass: 'mstrmojo.android.DocSelectorViewFactory',

            isSelectorSupported: function isSelectorSupported(selectorContainer) {
                
                var defn = selectorContainer.node.defn;

                
                if (defn.ct === "3") {
                    
                    var targetKey = selectorContainer.tks;
                    if (targetKey && selectorContainer.defn.dk) {
                        
                        selectorContainer.model.getLayoutUnitDefn(targetKey, defn._lkz).dk = true;

                        
                        return false;
                    }
                }

                
                return true;
            },

            
            newPulldown: function newPulldown(selectorContainer) {
                return new mstrmojo.android.DropDownList({
                    name: selectorContainer.node.defn.n,
                    postvalueChange: function () {
                    	
                    	if (!selectorContainer._inSyncPhase) {
                    		selectorContainer.showInfoWin();
                    		
                    		selectorContainer.selectorControlChange(this);
                    	}
                    }
                });
            },

            updateControlStyles: function updateControlStyles(selectorContainer) {
                var fmts = selectorContainer.getFormats(),
                    selectorStyle = selectorContainer.style,
                    ctrl = selectorContainer.children && selectorContainer.children[0];

                if (!ctrl) {
                    return;
                }

                
                if (fmts) {

                    
                    var height = fmts.height,
                        width = fmts.width;

                    
                    if (height !== undefined) {
                        
                        ctrl.height = height;
                    }

                    
                    if (width !== undefined) {
                        
                        ctrl.width = width;
                    }

                    
                    if (selectorStyle === $STYLES.LINK) {
                        
                        var selectedColor = selectorContainer.defn.ssc;
                        if (selectedColor) {
                            
                            ctrl.selColor = selectedColor;
                        }
                    }
                }

                this._super(selectorContainer);
            },

            attachTargetListeners: function attachTargetListeners(selectorContainer) {
                this._super(selectorContainer);

                
                if (selectorContainer.defn.ct === '3' && this.isSelectorSupported(selectorContainer)) {
                    
                    if (!selectorContainer._panelEvtListener) {
                        
                        var panelStack = selectorContainer.model.getUnitInstance(selectorContainer.tks, 1);
                        if (panelStack) {
                            
                            selectorContainer._panelEvtListener = panelStack.attachEventListener('panelSelected', selectorContainer.id, function (evt) {
                                
                                this._inSyncPhase = true;

                                
                                this.content.singleSelectByField(evt.key, 'v');

                                
                                this._inSyncPhase = false;
                            });
                        }
                    }
                }
            },

            getSelectorClass: function getSelectorClass(selectorStyle, isHoriz) {
                
                var cls = widgetMap[selectorStyle];
                return (cls && 'android.selectors.' + cls) || this._super(selectorStyle, isHoriz);
            },
            
            getSelectorCtrlConfig: function getSelectorCtrlConfig(selectorContainer, selectorStyle, defn, elements) {
            	
            	if ( selectorStyle === 9 ) {
            		if ( elements && elements.length === 0) {
	            		elements.push({
	            			n: "(All)",
	            			t: 14,
	            			v: "u;"
	            		});
                	}
            		
            		selectorContainer.style = selectorStyle = $STYLES.LINK;
            	}
            	return this._super(selectorContainer, selectorStyle, defn, elements);
            }            
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo.DocSelectorViewFactory",
                         "mstrmojo.css",
                         "mstrmojo.dom",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo.elementHelper");


    var $ARR = mstrmojo.array,
        $HASH = mstrmojo.hash,
        $D = mstrmojo.dom,
        STYLES = mstrmojo.DocSelectorViewFactory.STYLES,
        ELEM_ALL_ID = mstrmojo.DocSelectorViewFactory.ELEM_ALL,
        _EH = mstrmojo.elementHelper;

    var _ST_UC_ON_DS = mstrmojo.DocSelectorViewFactory.UC_ON_DS;

    
    function getEvent() {
        return {
            type: parseInt(this.type, 10),
            src: this.k,
            ck: this.ck,
            ctlKey: this.ckey,      
            tks: this.tks,
            include: this.include,
            disablePU: (parseInt(this.defn.subTp, 10) === _ST_UC_ON_DS)  
        };
    }

    
    mstrmojo.DocSelector = mstrmojo.declare(

        mstrmojo.Container,


        [mstrmojo._Formattable, mstrmojo._IsSelectorTarget],

        
        {
            scriptClass: 'mstrmojo.DocSelector',

            markupString: '<div id="{@id}" class="mstrmojo-DocSelector {@extCls}" title="{@tooltip}" style="{@domNodeCssText}">' +
                                '<div class="filter" style="{@filterNodeCssText}"></div>' +
                                '<div class="wait" style="display:none;z-index:100; position:absolute; top:0px; left:0px; width:100%; height:100%"></div>' +
                                '<div class="content" style="{@contentNodeCssText}"></div>' +
                    '</div>',

            markupSlots: {
                filterNode: function () { return this.domNode.firstChild; },
                contentNode: function () { return this.domNode.lastChild; },
                dimNode: function () { return this.domNode.lastChild; },           
                containerNode: function () { return this.domNode.lastChild; },
                scrollboxNode: function () { return this.domNode.lastChild; },
                wIconNode: function () { return this.domNode.childNodes[1]; }
            },

            markupMethods: {
                onincludeChange: function () { mstrmojo.css.toggleClass(this.domNode, 'strikeout', !this.include); },
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod,
                onwaitChange: function () { this.wIconNode.style.display = ((this.wait) ? 'block' : 'none'); }
            },

            
            formatHandlers: {
                domNode: [ 'F', 'text-align', 'vertical-align', 'line-height', 'z-index', 'top', 'left' ],
                contentNode: [ 'width', 'B', 'P' ],
                filterNode: [ 'height', 'width', 'B', 'P', 'fx', 'background-color' ],
                item: [ 'color', 'font', 'text-decoration', 'text-align', 'line-height' ]
            },

            
            ckey: null,

            
            ck: null,

            
            tks: null,

            
            style: 0,

            
            selIdx: null,

            
            extCls: '',

            
            bGetElems: false,

            
            init: function init(props) {
                this._super(props);

                
                
                var s = this.node.defn.style;
                this.spm = (s === STYLES.METRIC_QUAL || s === STYLES.METRIC_SLIDER);
            },

            
            initControlInfo: function initControlInfo() {

                var node = this.node,
                    data = node.data,
                    defn = node.defn,
                    elements = data.elms,
                    currentSelections = data.ces,
                    style = defn.style;

                
                var defnProps = [ 'include', 'ckey', 'ck', 'tks', 'style', 'multi', 'showall' ];

                
                
                
                if (!this.bGetElems && parseInt(defn.subTp, 10) === _ST_UC_ON_DS && style !== STYLES.SEARCH_BOX) {
                    this._fetchAllElems();
                    elements = data.elms; 
                }

                
                if (style === STYLES.METRIC_QUAL || style === STYLES.METRIC_SLIDER) {
                    
                    defnProps = defnProps.concat([ 'srcid', 'srct' ]);

                    
                    this.qua = data.qt;
                    this.dt = data.dt;
                }

                
                this.type = defn.ct;

                
                var fmts = defn.fmts;
                if (fmts) {
                    var w = fmts.width;
                    if (!w || parseInt(w, 10) <= 0) {
                        
                        fmts.width = '95px';
                    }
                }

                
                $HASH.copyProps(defnProps, defn, this);

                
                var selectedIndices = this.selIdx = {},
                    multi = defn.multi;

                
                
























                
                if (this.include && multi && $ARR.find(currentSelections, 'v', ELEM_ALL_ID) > -1) {
                    
                    currentSelections = elements;
                }

                
                if (currentSelections) {
                    
                    $ARR.forEach(elements, function (el, idx) {
                        
                        if ($ARR.find(currentSelections, 'v', el.v) >= 0) {
                            
                            selectedIndices[idx] = true;
                        }
                    });
                }

            },

            
            resetFormatHandlers: function resetFormatHandlers() {
                this.formatHandlers = {
                    contentNode: [ 'RW' ]
                };
            },

            
            selectorControlChange: function selectorControlChange(widget) {
                
                var rEvt = getEvent.call(this),
                    elementSeparator = '\u001E',
                    elementIDs = [],
                    style = this.style,
                    showElementCount = this.defn.sec,
                    i;

                switch (style) {
                case STYLES.PULLDOWN:
                    var value = widget.value,
                        n = null;

                    if (widget.selectNode) {
                        var sn = widget.selectNode;
                        n = sn.options[sn.selectedIndex].text;
                    }


                    
                    rEvt.eid = value;
                    if (parseInt(rEvt.type, 10) === 1 && n !== null) {
                        rEvt.eid = rEvt.eid + ';' + n;   
                    }

                    
                    this.defn.set('cek', value);

                    
                    this.currSelValue = value;


                    if (showElementCount) {
                        
                        this.parent.set('count', _EH.buildElemsCountStr([value], this.node.data.elms));
                    }

                    break;

                case STYLES.SEARCH_BOX:
                    
                    $ARR.forEach(widget.items, function (item) {
                        
                        elementIDs.push(item.v + ';' + item.n);
                    });

                    
                    if (!elementIDs.length && this.showall) {
                        
                        elementIDs.push('u;');
                    }

                    
                    rEvt.eid = elementIDs.join(elementSeparator);

                    
                    if (showElementCount) {
                        
                        this.parent.set('count', _EH.buildElemsCountStr(elementIDs, this.node.data.elms));
                    }
                    break;

                case STYLES.METRIC_QUAL:
                case STYLES.METRIC_SLIDER:
                    if(this.srcid === undefined) {
                        return; 
                    }
                    var cs = [];

                    
                    $ARR.forEach(widget.cs, function (item) {
                        
                        cs.push(item.v);

                        if (rEvt.dtp === undefined) {
                            rEvt.dtp = item.dtp;
                        }
                    });

                    
                    if (cs.length) {
                        
                        rEvt.cs = cs.join(elementSeparator);
                    }

                    
                    var fInfo = mstrmojo.MCSUtil.getFuncInfo(widget.opId, widget.qua);
                    rEvt.f = widget.f = fInfo.f;
                    rEvt.ft = widget.ft = fInfo.ft;

                    
                    rEvt.include = widget.include = this.include;

                    
                    rEvt.ckey = this.ckey;
                    rEvt.srcid = this.srcid;
                    rEvt.srct = this.srct;

                    rEvt.unset = widget.unSet;
                    rEvt.onlyInclude = widget.onlyInclude;
                    rEvt.changeQual = widget.changeQual;
                    rEvt.qt = widget.qua;

                    
                    this.node.defn.set("cek", {
                        id: this.id,
                        f: widget.f,
                        ft: widget.ft,
                        cs: widget.cs,
                        qua: widget.qua,
                        include: widget.include
                    });
                    break;

                default:
                    var node = this.node,
                        elements = node.data.elms,
                        indices = widget.selectedIndices,
                        allIdx = widget.allIdx,
                        isAll = !!indices[allIdx],
                        eidts = [],     
                        inc = this.include;

                    
                    if (isAll) {
                        
                        elementIDs = [ elements[allIdx].v ];
                        eidts = [ elements[allIdx].v ];

                    } else {
                        if (indices[allIdx]) {
                            indices[allIdx] = false;
                        }

                        
                        var keyArr = $HASH.keyarray(indices, true).sort($ARR.numSorter),
                            sortedIndices  = {};

                        for (i in keyArr) {
                            sortedIndices[keyArr[i]] = indices[keyArr[i]];
                        }
                        indices = sortedIndices;

                        
                        $HASH.forEach(indices, function (item, idx) {
                            
                            if (item) {
                                
                                elementIDs.push(elements[idx].v);
                                eidts.push(elements[idx].v + ';' + elements[idx].n);
                            }
                        });
                    }

                    
                    rEvt.eid = ((parseInt(rEvt.type, 10) === 1) ? eidts : elementIDs).join(elementSeparator);

                    
                    var pos = mstrmojo.dom.position(widget.domNode, true);
                    if (pos) {
                        
                        rEvt.left = pos.x;
                        rEvt.top = pos.y;
                    }

                    
                    if (isAll && this.multi && inc) {
                        
                        $ARR.forEach(elements, function (elem) {
                            var v = elem.v;

                            
                            if (elementIDs[0] !== v) {
                                
                                elementIDs.push(v);
                            }
                        });
                    }

                    
                    node.defn.set('cek', elementIDs);

                    if (showElementCount && style !== STYLES.SCROLLER) {
                        
                        this.parent.set('count', _EH.buildElemsCountStr(elementIDs, elements));

                    }
                    break;
                }

                
                var me = this;
                window.setTimeout(function () {
                    me.slice(rEvt);
                }, 0);
            },

            showInfoWin: function showInfoWin(anchor) {
            	var m = this.model,
            		ifws = m.getTargetInfoWin(this.tks);

            	if (ifws && ifws.length) {
            		var horiz = this.defn.horiz,
            			actualAnchor = anchor || this.contentNode,
            			aPos = $D.position(actualAnchor), 
            			sPos = $D.position(this.contentNode), 
            			
            			
            			position = (horiz || this.defn.style == STYLES.SCROLLER) ? null : {x : sPos.x, y : aPos.y, w : sPos.w, h : aPos.h};


        			for (var i = 0;i < ifws.length; i++) {

            			m.showInfoWin(ifws[i],
            						  actualAnchor,
            						  horiz ? 'v' : 'h', false, $HASH.copy(position));
            		}
            	}
            },

            
            preBuildRendering: function preBuildRendering() {
                var ret = true,
                    style = this.node.defn.style,
                    formatHandlers = $HASH.clone(this.formatHandlers),
                    contentNodeHandler = formatHandlers.contentNode;

                
                
                
                
                if (contentNodeHandler) {
                    if ((style === STYLES.RADIO || style === STYLES.CHECKBOX) && formatHandlers.filterNode) {
                        contentNodeHandler.push('fx');
                        contentNodeHandler.push('background-color');

                        delete formatHandlers.filterNode;
                    }

                    if (style === STYLES.LIST) {
                        delete contentNodeHandler.height;
                    }

                    if (style === STYLES.SEARCH_BOX) {
                        
                        var domHandler = formatHandlers.domNode;

                        $ARR.removeItem(domHandler, 'color');

                        var idx = $ARR.indexOf(domHandler, 'F');
                        if (idx > -1) {
                            $ARR.removeIndices(domHandler, idx, 1);
                            domHandler.push('font');
                        }
                    }
                }

                
                this.formatHandlers = formatHandlers;

                
                ret = this._super();

                
                this.builder.selectorFactory.updateControlStyles(this);

                return ret;
            },

            
            postBuildRendering: function postBuildRendering() {
                var style = this.node.defn.style,
                    filterNodeStyle = this.filterNode.style,
                    contentNode = this.contentNode,
                    defn = this.node.defn;

                this._super();

                if (this.formatHandlers.filterNode) {
                    
                    var f = this.getFormats();

                    if (!f.width) {
                        filterNodeStyle.width = contentNode.clientWidth + 'px';
                    }

                    if (!f.height) {
                        filterNodeStyle.height = contentNode.clientHeight + 'px';
                        if (style === STYLES.METRIC_QUAL || style === STYLES.METRIC_SLIDER) {
                            this.updateHeight();
                        }
                    } else {
                        
                        if (style === STYLES.METRIC_QUAL) {
                            contentNode.style.height = f.height;
                        }
                    }

                } else {
                    
                    filterNodeStyle.display = 'none';
                }

                if (this.isInFilterPanel() && !this.isHorizFP()) {
                    this.domNode.style.width = this.contentNode.style.width = '100%';
                    if (this.formatHandlers.filterNode) {
                        this.filterNode.style.width = this.contentNode.style.width = '100%';
                    }
                    this.set('visible', parseInt(defn.ds, 10) === 0); 
                }

                
                this.model.attachEventListener('CGBMapChange', this.id, 'onCGBMapChange');

                
                this.builder.selectorFactory.attachTargetListeners(this);

                if($D.isAndroid && style === STYLES.SCROLLER) {
                    contentNode.style.overflow = 'visible';
                }

                return true;
            },

            _fetchAllElems: function _fetchAllElems() {
                var defn = this.node.defn,
                    data = this.node.data;

                var taskParams = {
                    taskId: 'browseElements',
                    styleName: 'MojoAttributeStyle',
                    attributeID: defn.srcid || '',
                    dataSourcesXML: defn.dsrc || '',
                    browseFlags: 1
                };

                var me = this,
                    callbacks = {
                        success: function (res) {
                            me.bGetElems = true;
                            me.set('wait', false);

                            if (res && res.es) {
                                data.elms = (defn.srcid) ? _EH.buildElemsTerseID(res.es, defn.srcid, true) : res.es;

                                var parent = me.parent,
                                    grandParent = parent && parent.parent;

                                if (data.ces && data.elms && data.elms.length > 0 && parent) {
                                    parent.set('count', _EH.buildElemsCountStr(data.ces, data.elms));
                                }

                                if (me.hasRendered) {
                                    me.refresh();
                                    if (me.isInFilterPanel()) {
                                        if (parent && parent.defn.ttl) { 
                                            parent.updateContentHeight();
                                        }
                                        if (grandParent && grandParent.refreshFP) {   
                                            grandParent.refreshFP();
                                        }
                                    }
                                }
                            }
                        },
                        failure: function (res) {
                            mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
                        }
                    };

                this.set('wait', true);
                mstrmojo.xhr.request('POST', mstrConfig.taskURL, callbacks, taskParams, false, null, true);
            },

            
            updateHeight: function updateHeight() {
                this.contentNode.style.height = this.filterNode.style.height = this.content.getClientHeight() + 'px';

                var parent = this.parent;
                if (parent && (parent.defn.ttl !== undefined) &&
                		parent.updateContentHeight) {   
                    parent.updateContentHeight();
                }
            },

            
            onCGBMapChange: function onCGBMapChange(evt) {
                
                var cgbMap = evt.cgbMap;
                if (!cgbMap) {
                    return;
                }

                
                var tks = this.tks;

                
                $HASH.forEach(this.defn.cgb, function (key) {
                    
                    var targetKey = cgbMap[key];
                    if (targetKey && tks.indexOf(targetKey) < 0) {
                        
                        tks += '\u001E' + targetKey;
                    }
                });

                
                this.tks = tks;
            },

            
            update: function update(node) {
                
                this.node = node;

                var defn = this.node.defn,
                    style = defn.style,
                    elements = this.node.data.elms,
                    parent = this.parent,
                    isScroller = (style === STYLES.SCROLLER);

                
                if (isScroller && defn.multi) {
                    
                    var allIdx = $ARR.find(elements, 'v', ELEM_ALL_ID);
                    if (allIdx > -1) {
                        $ARR.removeIndices(elements, allIdx, 1);
                    }
                }

                
                if (defn.sec && !isScroller && !defn.sos) {
                    var ces = node.data.ces;
                    
                    if (parent && parent.count) {
                        
                        if (ces && elements && elements.length) {
                            
                            parent.set('count', _EH.buildElemsCountStr(ces, elements));
                        }
                    }
                }

                
                this.initControlInfo();

                
                var widget = this.content = this.builder.selectorFactory.newSelector(this);

                
                if (!widget) {
                    
                    this.set('visible', false);
                }
            },

            
            onincludeChange: function onincludeChange(evt) {
                this.node.defn.include = this.include = evt.value;

                if (this.style !== STYLES.METRIC_SLIDER) {
                    this.include = evt.value;

                    
                    var rEvt = getEvent.call(this);
                    rEvt.ckey = this.ckey;
                    this.slice(rEvt);
                }
            },

            
            slice: function slice(rEvt) {
                var m = this.model;
                if (this.isInFilterPanel()) {
                    var fp = this.getFilterPanel();
                    if (fp && !fp.defn.cas) {  
                        fp.bufferSlice(rEvt);
                        return;
                    }
                }

                m.slice(rEvt);
            },

            onquaChange: function onquaChange(evt) {
                this.node.data.qt = evt.value;
            },

            isInFilterPanel: function isInFilterPanel() {
                var parent = this.parent;
                return (parent && parent.isInFilterPanel && parent.isInFilterPanel()) || false;
            },

            isHorizFP: function isHorizFP() {
                var parent = this.parent;
                return (parent && parent.isHorizFP && parent.isHorizFP()) || false;
            },

            getFilterPanel: function getFilterPanel() {
                var parent = this.parent;
                return (parent && parent.getFilterPanel && parent.getFilterPanel()) || null;
            }

        }
    );

    
    if (!mstrmojo.dom.isIE) {
        
        var formatHandlers = mstrmojo.DocSelector.prototype.formatHandlers;
        formatHandlers.contentNode = formatHandlers.filterNode;
        delete formatHandlers.filterNode;
    }

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.android.controllers.RootController",
                         "mstrmojo.android.controllers.FolderController",
                         "mstrmojo.android.controllers.ProjectsController",
                         "mstrmojo.android.controllers.SubscriptionsController",
                         "mstrmojo.android.controllers.XtabController",
                         "mstrmojo.android.controllers.DocumentController",
                         "mstrmojo.android.controllers.GraphController",
                         "mstrmojo.android.controllers.PromptsController",
                         "mstrmojo.android.controllers.PropertiesController",
                         "mstrmojo.android.controllers.SettingsController",
                         "mstrmojo.android.controllers.TransactionNotificationController");

    
    mstrmojo.android.factories.ControllerFactory = mstrmojo.declare(

        mstrmojo.Obj,

        null,

        
        {
            scriptClass: 'mstrmojo.android.factories.ControllerFactory',

            
            newRootController: function newRootController(params) {
                return new mstrmojo.android.controllers.RootController(params);
            },

            
            newFolderController: function newFolderController(params) {
                return new mstrmojo.android.controllers.FolderController(params);
            },

            
            newProjectsController: function newProjectsController(params) {
                return new mstrmojo.android.controllers.ProjectsController(params);
            },

            
            newSubscriptionsController: function newSubscriptionsController(params) {
                return new mstrmojo.android.controllers.SubscriptionsController(params);
            },

            
            newXtabController: function newXtabController(params) {
                return new mstrmojo.android.controllers.XtabController(params);
            },

            
            newDocumentController: function newDocumentController(params) {
                return new mstrmojo.android.controllers.DocumentController(params);
            },

            
            newGraphController: function newGraphController(params) {
                return new mstrmojo.android.controllers.GraphController(params);
            },

            
            newPromptsController: function newPromptsController(params) {
                return new mstrmojo.android.controllers.PromptsController(params);
            },

            
            newPropertiesController: function newPropertiesController(params) {
                return new mstrmojo.android.controllers.PropertiesController(params);
            },

            
            newSettingsController: function newSettingsController(params) {
                return new mstrmojo.android.controllers.SettingsController(params);
            },

            
            newTransactionsController: function newTransactionsController(params) {
                return new mstrmojo.android.controllers.TransactionNotificationController(params);
            },

            
            newController: function newController(type, params) {
                var ctrl = this['new' + type + 'Controller'](params);
                ctrl.type = type;
                return ctrl;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.factories.ControllerFactory",
                         "mstrmojo.android.large.controllers.RootController",
                         "mstrmojo.android.large.controllers.BrowserController",
                         "mstrmojo.android.large.controllers.HomeScreenController");

    
    mstrmojo.android.large.factories.ControllerFactory = mstrmojo.declare(

        mstrmojo.android.factories.ControllerFactory,

        null,

        
        {
            scriptClass: 'mstrmojo.android.large.factories.ControllerFactory',

            
            newRootController: function newRootController(params) {
                return new mstrmojo.android.large.controllers.RootController(params);
            },

            
            newBrowserController: function newBrowserController(params) {
                return new mstrmojo.android.large.controllers.BrowserController(params);
            },
            
            
            newHomeScreenController: function newHomeScreenController(params) {
                return new mstrmojo.android.large.controllers.HomeScreenController(params);
            } 
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocSelector",
                         "mstrmojo.Button",
                         "mstrmojo.base64",
                         "mstrmojo.Dialog");

    mstrmojo.requiresDescs(1442, 2140, 5369, 8233, 8232, 8313, 8322);

    var SUBMIT = 8,
        RECALCULATE = 16,
        DISCARD = 4,
        
        DISPLAY_MSG = 1,


        REEXECUTE_DOCUMENT = 8,
        EXECUTE_OBJECT = 16,
        FORCE_LIVE_EXECUTION = 0x10000000,
        INVALID_CLIENT_CACHE = 0x20000000,
        AUTO_ANSWER_PROMPT = 0x40000000,
        useMojoDialog = window.mstrConfig && !window.mstrConfig.simpleDialog,
        SUBMIT_ERROR_VALIDATION_FAILURE = 0x800424E3,
        SUBMIT_ERROR_NO_CHANGE = 0x800424E4;

    var $NIB = mstrmojo.Button.newInteractiveButton;
   
    function confirmMsg(msg, okFn, cancelFn, okText, cancelText) {
        if (useMojoDialog) {
            var buttons = [$NIB(
                    okText || mstrmojo.desc(1442),
                    okFn || null,
                    null
                ), $NIB(
                    cancelText || mstrmojo.desc(2140),
                    cancelFn || null,
                    null
                )];
            
            mstrmojo.confirm(msg, mstrApp.useBinaryFormat ? buttons.reverse() : buttons);
        } else {
            
            if (mstrmojo.confirm(msg)) {
                if (okFn) {
                    okFn();
                }
            } else if (cancelFn) {
                cancelFn();
            }
        }
    }

    function alertMsg(msg, okFn) {
        if (useMojoDialog) {
            mstrmojo.alert(msg, okFn);
        } else {
            mstrmojo.alert(msg);
            if (okFn) {
                okFn();
            }
        }
    }

    
    mstrmojo.DocActionSelector = mstrmojo.declare(

        mstrmojo.DocSelector,

        null,

        
        {
            scriptClass: 'mstrmojo.DocActionSelector',

            extCls: 'mstrmojo-ActionSelector',

            
            type: SUBMIT,

            
            targets: null,

            initControlInfo: function initControlInfo() {
                var defn = this.node.defn;
                this.aa = parseInt(defn.aa, 10);
                this.dpTxt = defn.dpTxt || {8: mstrmojo.desc(5369), 4: mstrmojo.desc(8233), 16: mstrmojo.desc(8232)}[this.aa] || '';
                this.dpCfm = defn.dpCfm;
                this.sac = parseInt(defn.sac, 10);
                this.msg = defn.msg;
                this.rsid = defn.rsid;
                this.rst = defn.rst;

                this.node.data.elms = [{
                    n: this.dpTxt,
                    v: this.dpTxt
                }];

                this._super();
            },

            selectorControlChange: function selectorControlChange(w) {
                
                
                
                
                if (w.selectedIndex !== 0) {
                    return;
                }
                this.executeAction();
                w.select([]);
            },

            executeAction: function executeAction() {
                var aa = this.aa,
                    me = this;

                if (aa === SUBMIT) {
                    if (this.dpCfm) {
                        confirmMsg(mstrmojo.desc(8313), function () {
                            me.onControllerCheck();
                        });
                    } else {
                        me.onControllerCheck();
                    }
                } else if (aa === DISCARD) {
                    if (this.dpCfm) {
                        confirmMsg(mstrmojo.desc(8322), function () {
                            me.onDiscard();
                        });
                    } else {
                        me.onDiscard();
                    }
                } else {
                    this.onRecalculate();
                }
            },

            onControllerCheck: function onControllerCheck() {
                
                this.onCommit();
            },

            
            onCommit: function onCommit() {
                var me = this,
                    md = this.model,
                    ctl = me.controller,
                    useBinaryMode = mstrApp.useBinaryFormat;

                
                if (!useBinaryMode && !this.validateRequiredObjects()) {
                    alertMsg(mstrmojo.desc(9200)); 
                    return;
                }

                
                var executeActions = function (res) {
                    if ((me.sac & INVALID_CLIENT_CACHE) > 0) {
                        ctl.invalidClientCache();
                    }

                    if ((me.sac & EXECUTE_OBJECT) > 0) {
                        var params = {
                            did: me.rsid,
                            objType: me.rst,
                            forceExec: (me.sac & FORCE_LIVE_EXECUTION) > 0
                        };

                        if ((me.sac & AUTO_ANSWER_PROMPT) > 0) {
                            params.linkAnswers = '<hl mid="' + md.mid + '" srct="2" aopam="1"><prms></prms></hl>';
                        }

                        ctl.onExecuteNewObject(me, params);

                    } else if ((me.sac & REEXECUTE_DOCUMENT) > 0) {
                        ctl.onReExecute(me);

                    } else {
                    	
                        if (mstrApp.isMobile) {
                            
                            ctl.generateActionToolbar();
                        }
                    	
                        
                        md.transactionUpdate(res);
                    }
                };

                
                mstrmojo.mask.show('Running');
                
                md.sendTransactionActions(this.ck, SUBMIT, md.newCallback({
                    success: function (res) {
                        
                        mstrmojo.mask.hide();
                    	
                        
                        if(md.txrcd || res.offln) {
                            ctl.offlineTransactionsSubmitted(me.ck);
                        }
                        
                        if (res.offln) {
                            if(useBinaryMode && !me.networkToastShowed) {
                                me.networkToastShowed = true;
                                mstrmojo.toast(mstrmojo.desc(9258, 'No Network Connectivity') + '. ' + mstrmojo.desc(9259, 'Transaction will be submitted when connectivity is resumed.'));
                            }
                            md.transactionUpdate(res);
                        } else {
                            
                            if ((me.sac & DISPLAY_MSG) > 0 && me.msg) {
                                
                            	if (useBinaryMode) {
                                    mstrmojo.toast(me.msg);
                                    
                                    window.setTimeout(function () {
                                        executeActions(res);
                                    }, 100);
                                } else {
                                    alertMsg(me.msg, function () {
                                        executeActions(res);
                                    });
                                }
                            } else {
                                executeActions(res);
                            }
                        }
                    },

                    failure: function (res) {
                        var alertDialog = mstrmojo.all.mojoAlertx9;
                        if (alertDialog) {
                            alertDialog.destroy();
                        }
                        
                        mstrmojo.mask.hide();
                    	
                        
                        if(md.txrcd) {
                            ctl.offlineTransactionsSubmitted(me.ck);
                        }
                        
                        var errCode = 0x100000000 + parseInt(res.code, 10);
                        if (errCode === SUBMIT_ERROR_VALIDATION_FAILURE) {
                            
                            if (useBinaryMode) {
                                me.validateRequiredObjects();
                            }
                            alertMsg(mstrmojo.desc(9200, 'You have some required inputs that are not modified.'));

                        } else if (errCode === SUBMIT_ERROR_NO_CHANGE) {
                            var msg = mstrmojo.desc(9201, "You haven't made any changes to submit.");
                            if (useBinaryMode) {
                                mstrmojo.toast(msg);
                            } else {
                                alertMsg(msg);
                            }

                        } else {
                            
                            alertMsg(mstrmojo.base64.decodeHttpHeader(res.message), function () {
                                
                                if (!useBinaryMode) {
                                    me.controller.onReExecute(me, true);
                                }
                            });
                        }
                    }
                }));
            },

            
            onDiscard: function onDiscard() {
                var me = this,
                    md = this.model,
                    ctl = me.controller;

                md.txDiscardTargets = this.getTxTargets();

                md.sendTransactionActions(this.ck, DISCARD, {
                    success: function (res) {
                        md.transactionUpdate(res);
                        ctl.transactionDiscarded(me.ck);
                    },

                    
                    complete: function () {
                        delete md.txDiscardTargets;
                        
                        
                        if (mstrApp.isMobile) {
                            
                            ctl.generateActionToolbar();
                        }
                    }
                });
            },

            
            onRecalculate: function onRecalculate() {
                this.model.sendTransactionActions(this.ck, RECALCULATE);
            },

            
            getTxTargets: function getTxTargets() {
                var keys = this.tks.split('\u001E'),
                    i,
                    len,
                    key,
                    wid,
                    w,
                    j,
                    res = {};

                for (i = 0, len = keys.length; i < len; i++) {
                    
                    key = keys[i];

                    
                    wid = 1;

                    do {
                        
                        w = this.model.getUnitInstance(key, wid++);
                        
                        if (w && w.checkRequiredObjects) {
                            if (w.isPanelStack) {
                                
                                for (j in w.txWidgets) {
                                    res[w.txWidgets[j].id] = 1;
                                }
                            } else { 
                                res[w.id] = 1;
                            }
                        } else {
                            break;
                        }
                    } while (true);
                }
                return res;
            },

            
            validateRequiredObjects: function validateRequiredObjects() {
                var flag = true,
                    id;

                for (id in this.getTxTargets()) {
                    flag = mstrmojo.all[id].checkRequiredObjects() && flag;
                }

                return flag;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DynamicClassFactory",
                         "mstrmojo._CanSupportTransaction",
                         "mstrmojo._IsEditableXtab",
                         "mstrmojo.AndroidInteractiveGridXtab",
                         "mstrmojo.DocXtabModel",
                         "mstrmojo.DocInteractiveGridXtab",
                         "mstrmojo.AndroidVisTimeSeries",
                         "mstrmojo.DocVisTimeSeries",
                         "mstrmojo.VisMicroChart",
                         "mstrmojo.maps.AndroidRptMap",
                         "mstrmojo.maps.AndroidMapModel",
                         "mstrmojo.maps.AndroidDocMap",
                         "mstrmojo.ImageCarousel",
                         "mstrmojo.PhotoUploader",
                         "mstrmojo.AndroidVisMap",
                         "mstrmojo.VisHeatMap");

    var VIS_LIST = {'AndroidImageMapStyle':{'s':'ImageMapVisualizationDataStyle','c':'AndroidVisMap'},'MicroChartsVisualizationStyle':{'s':'MicroChartVisualizationDataStyle','c':'VisMicroChart'},'TimeSeriesAjaxVisualizationStyle':{'dc':'DocVisTimeSeries','s':'TimeSeriesVisualizationDataStyle','c':'AndroidVisTimeSeries'},'ImageViewerVisualizationStyle':{'s':'VisualizationDataStyle','c':'ImageCarousel'},'AndroidPhotoUploaderStyle':{'s':'VisualizationDataStyle','c':'PhotoUploader'},'HeatMapVisualizationStyle':{'s':'HeatMapVisualizationDataStyle','c':'VisHeatMap'},'AndroidMapStyle':{'dc':'maps.AndroidDocMap','s':'MapVisualizationDataStyle','c':'maps.AndroidRptMap','m':'maps.AndroidMapModel'},'InteractiveGridAjaxVisualizationStyle':{'dc':'DocInteractiveGridXtab','s':'InteractiveGridDataStyle','c':'AndroidInteractiveGridXtab','m':'DocXtabModel'}};

    mstrmojo.AndroidVisList = mstrmojo.provide(

        'mstrmojo.AndroidVisList',

        {
            getVis: function getVis(styleName) {
                return VIS_LIST[styleName] || null;
            },

            getVisClass: function getVisClass(cls, defn) {
                
                if (defn.txi && defn.t === 115) {
                    cls = mstrmojo.DynamicClassFactory.newComponent(cls, [ mstrmojo._CanSupportTransaction, mstrmojo._IsEditableXtab ]);
                }

                return cls;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.EnumRWUnitType",
                         "mstrmojo.DocLayout",
                         "mstrmojo.DocLayoutHoriz",
                         "mstrmojo.DocSection",
                         "mstrmojo.DocSubsection",
                         "mstrmojo.DocTextfield",
                         "mstrmojo.DocXtabModel",
                         "mstrmojo.DocVisModel",
                         "mstrmojo.XtabBase",
                         "mstrmojo.DocPortlet",
                         "mstrmojo.DocResizablePortlet",
                         "mstrmojo.DocXtabGraph",                        
                         "mstrmojo.DocGridGraph",
                         "mstrmojo.DocLine",
                         "mstrmojo.DocImage",
                         "mstrmojo.DocHTMLContainer",
                         "mstrmojo.DocRectangle",
                         "mstrmojo.DocRoundRectangle",
                         "mstrmojo.DocPanel",
                         "mstrmojo.DocSelector",
                         "mstrmojo.DocActionSelector",
                         "mstrmojo._HasDocLink",
                         "mstrmojo.DocVisualization",
                         "mstrmojo.DynamicClassFactory",
                         "mstrmojo._Formattable",
                         "mstrmojo._IsDocXtab",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo.DocInfoWindow",
                         "mstrmojo._CanSupportTransaction",
                         "mstrmojo._IsEditableXtab",
                         "mstrmojo._IsEditableTextfield",
                         "mstrmojo.DocSelectorViewFactory",
                         "mstrmojo._HasHoverButton",
                         "mstrmojo.hash");

    var $HASH = mstrmojo.hash;

    
    var en = mstrmojo.EnumRWUnitType,
        clsMap = {};

    clsMap[en.LAYOUT] = {n: "Layout"};
    clsMap[en.HEADER] =
        clsMap[en.FOOTER] =
        clsMap[en.PAGEHEADER] =
        clsMap[en.PAGEFOOTER] =
        clsMap[en.DETAILS] =        { n: "Section", scriptClass: "mstrmojo.DocSection" };
    clsMap[en.SUBSECTION] =         { n: "SubSection", scriptClass: "mstrmojo.DocSubsection" };
    clsMap[en.TEXTFIELD] =          { n: "Textfield", scriptClass: "mstrmojo.DocTextfield" };
    clsMap[en.GRID] =               { n: "Xtab", scriptClass: "mstrmojo.DocXtab" };
    clsMap[en.GRAPH] =              { n: "XtabGraph", scriptClass: "mstrmojo.DocXtabGraph" };
    clsMap[en.GRIDGRAPH] =          { n: "GridGraph", scriptClass: "mstrmojo.DocGridGraph" };
    clsMap[en.SELECTOR] =           { n: "Selector", scriptClass: "mstrmojo.DocSelector" };
    clsMap[en.LINE] =               { n: "Line", scriptClass: "mstrmojo.DocLine" };
    clsMap[en.IMAGE] =              { n: "Image", scriptClass: "mstrmojo.DocImage" };
    clsMap[en.HTMLCONTAINER] =      { n: "HTMLContainer", scriptClass: "mstrmojo.HTMLContainer" };
    clsMap[en.RECTANGLE] =          { n: "Rectangle", scriptClass: "mstrmojo.DocRectangle" };
    clsMap[en.ROUNDEDRECTANGLE] =   { n: "RoundedRectangle", scriptClass: "mstrmojo.DocRoundRectangle" };
    clsMap[en.PANEL] =              { n: "Panel", scriptClass: "mstrmojo.DocPanel" };
    clsMap[en.VISUALIZATION] =      { n: "Visualization", scriptClass: "mstrmojo.DocVisualization" };
    clsMap[en.MOJOVISUALIZATION] =   {n: "MojoVisualization"};

    
    var linkClsMap = {};

    var $CFC = mstrmojo.DynamicClassFactory.newComponent;

    var _EH = mstrmojo.elementHelper;

    
    function getPortletButtonHandler(action) {
        return function () {
            return this.parent.parent['on' + action]();
        };
    }

    
    var fMx = getPortletButtonHandler('maximize'),
        
        fRs = getPortletButtonHandler('restore'),
        
        fMn = getPortletButtonHandler('minimize'),
        
        fCo = getPortletButtonHandler('collapse'),
        
        fEx = getPortletButtonHandler('expand');

    
    mstrmojo.DocXtab = $CFC(mstrmojo.XtabBase, [mstrmojo._Formattable, mstrmojo._IsDocXtab], {
        scriptClass: 'mstrmojo.DocXtab'
    });

    
    var getPopupDelegate = function (widget, openMenu) {
        var w = widget && widget.parent;
        while (w) {
            if (w[openMenu]) {
                return w;
            }
            w = w.parent;
        }
        return null;
    };

    
    function createResizeButton(t, c, fn, bds, cds) {
        return mstrmojo.Button.newIconButton(t, c, fn, null, {
            ds: bds,
            visible: (cds !== bds)
        });
    }

    
    function getLinkDrillingClass(clazz, type, useHover) {
        var className = clsMap[type].n + (useHover ? 'Hover' : ''),
            Cls = linkClsMap[className];

        
        if (!Cls) {
            
            Cls = linkClsMap[className] = $CFC(clazz, [ mstrmojo._HasDocLink ].concat(this.getLinkDrillMixins(useHover)));
        }

        
        return Cls;
    }


    
    mstrmojo.DocBuilder = mstrmojo.declare(
        
        mstrmojo.Obj,

        
        null,

        
        {
            
            scriptClass: "mstrmojo.DocBuilder",

            
            visList: null,

            destroy: function destroy() {
                var selectorFactory = this.selectorFactory;
                if (selectorFactory) {
                    selectorFactory.destroy();
                }

                this._super();
            },

            
            classMap: clsMap,

            
            build: function build(nodes, model) {
                var arr = [],
                    mthMap = this.classMap,
                    len = ((nodes && nodes.length) || 0),
                    i;

                for (i = 0; i < len; i++) {
                    
                    var node = nodes[i],
                        nodeDefn = node && node.defn,
                        nodeData = node && node.data,
                        t = (nodeDefn && nodeDefn.t) || mstrmojo.EnumRWUnitType.LAYOUT,       
                        config = mthMap[t];                                                   

                    
                    var isDocButton = (t === en.TEXTFIELD && ((nodeDefn && nodeDefn.dpst)));
                    if (isDocButton) {
                        
                        config = mthMap[t + 'B'];
                    }

                    
                    var fn = (config && config.n) ? 'new' + config.n : '',
                        w;

                    
                    if (this[fn]) {
                        
                        w = this[fn](model, node);

                    } else if (config && config.scriptClass) {

                        
                        var Cls = config.cls;
                        if (!Cls) {
                            
                            Cls = $HASH.walk(config.scriptClass, window);
                        }

                        
                        if (t === en.TEXTFIELD || t === en.IMAGE) {

                            
                            var dataDlRef = nodeData.dl,
                                defnDlRef = nodeDefn.dl,
                                hasLinks = (dataDlRef && dataDlRef.items && dataDlRef.items.length) || (defnDlRef && defnDlRef.items && defnDlRef.items.length > 0);

                            
                            if (hasLinks || nodeData.url || nodeDefn.url || nodeDefn.ifw) {
                                
                                
                                Cls = getLinkDrillingClass.call(this, Cls, t + (isDocButton ? "B" : ""), hasLinks);

                            } else if ((t === en.TEXTFIELD) && nodeDefn.txi) {
                                Cls = $CFC(Cls, [ mstrmojo._CanSupportTransaction, mstrmojo._IsEditableTextfield ]);

                            }
                        }

                        
                        if (Cls) {
                            
                            

                            
                            w = new Cls({
                                id: node.id,
                                node: node,
                                controller: this.parent.controller,
                                model: model
                            });
                        }
                    }

                    
                    if (w) {
                        
                        w.k = node.k;
                        w.formatResolver = model.formatResolver;
                        w.builder = this;
                        w.tooltip = nodeData.tooltip || nodeDefn.tooltip || '';

                        
                        if (!w.defn) {
                            
                            w.defn = nodeDefn;
                        }

                        w.disposables.push(w.defn);

                        
                        if (w.update) {
                            w.update(node);
                        }

                        
                        if ((nodeDefn.ttl !== undefined && t !== en.PANEL) || nodeDefn.qsm) {
                            w = this.createPortlet(t, node, w);
                        }

                        arr.push(w);
                    }
                }
                return arr;
            },

            
            createPortlet: function createPortlet(t, node, w) {
                var defn = node.defn,
                    ds = defn.ds,
                    resizable = (defn.iifp || !(t === en.PANELSTACK || (defn.ttl === undefined && defn.qsm) || t === en.SELECTOR)),
                    hasGraph = (t === en.GRAPH || t === en.GRIDGRAPH),
                    children = [],
                    $NIB = mstrmojo.Button.newIconButton,
                    leftToolbarNodeCssClass = '',
                    toolbarNodeCssClass = '',
                    buttonbarNodeClass = '',
                    isExportGrid = (t === en.GRID || hasGraph || t === en.VISUALIZATION) && parseInt(defn.eo, 10) !== 2,
                    toolbarNode = [],
                    tbCssClass = 'mstrmojo-oivmSprite ',
                    hasTitlebarMenuButton = false; 

                
                if (defn.qsm) {
                    leftToolbarNodeCssClass = 'qks';

                    
                    var fnQuickSwitchBtn = function (title, css, qsm) {
                        return $NIB(title, tbCssClass + css, function () {
                            return this.parent.parent.content.quickSwitch();
                        }, {
                            visible: 'this.parent.parent.defn.qsm !== this.qsm'
                        }, {
                            qsm : qsm
                        });
                    };

                    
                    children.push({
                        scriptClass: 'mstrmojo.ToolBar',
                        slot: 'leftToolbarNode',
                        alias: 'leftToolbar',
                        cssClass: (!resizable) ? 'grouped' : '',
                        children: [ fnQuickSwitchBtn(mstrmojo.desc(3547, 'View: Grid'), 'tbGrid', 1), fnQuickSwitchBtn(mstrmojo.desc(3548, 'View: Graph'), 'tbGraph', 2) ]
                    });
                }

                if (isExportGrid) {
                    var tb = this.getPortletExportGridToolbar(w.k);
                    if (tb) {
                        toolbarNodeCssClass = tb.css;

                        toolbarNode = tb.node;

                        children.push(toolbarNode);
                    }
                }

                
                if (resizable) {
                    if (defn.iifp) {
                        leftToolbarNodeCssClass = 'wrap';

                        
                        children.push({
                            scriptClass: 'mstrmojo.ToolBar',
                            slot: 'leftToolbarNode',
                            alias: 'leftToolbar',
                            children: [ createResizeButton(mstrmojo.desc(8973, 'Collapse'), 'co', fCo, 1, ds),
                                        createResizeButton(mstrmojo.desc(8972, 'Expand'), 'ex', fEx, 0, ds) ]
                        });
                    } else {
                        var btns = [ createResizeButton(mstrmojo.desc(4539, 'Minimize'), 'mn', fMn, 1, ds),
                                     createResizeButton(mstrmojo.desc(4540, 'Restore'), 'rs', fRs, 0, ds),
                                     createResizeButton(mstrmojo.desc(4541, 'Maximize'), 'mx', fMx, 2, ds) ];

                        if (isExportGrid) {
                            toolbarNode.children = (toolbarNode.children || []).concat(btns);

                        } else {
                            toolbarNodeCssClass = 'resize';

                            
                            children.push({
                                scriptClass: 'mstrmojo.ToolBar',
                                slot: 'toolbarNode',
                                alias: 'rightToolbar',
                                children: btns
                            });
                        }
                    }
                }

                
                w.slot = 'contentNode';
                w.alias = 'content';
                w.title = defn.ttl || '';

                
                if (defn.sec) {
                    
                    if (defn.style !== mstrmojo.DocSelectorViewFactory.STYLES.SCROLLER && !defn.sos) {
                        var nodeData = node.data,
                            es = nodeData.elms,
                            ces = nodeData.ces;

                        
                        if (ces && es && es.length) {
                            
                            w.count = _EH.buildElemsCountStr(ces, es);
                        }
                    }
                }

                
                children.push(w);

                
                if (t === en.PANELSTACK) {
                    var fnNewNavButton = function (title, css, binding, dir) {
                            return $NIB(title, tbCssClass + css, function () {
                                
                                return this.parent.parent.content.switchToPanel(dir);
                            }, {
                                enabled: 'this.parent.parent.' + binding
                            });
                        },
                        rTb = [],
                        lTb = [],
                        hasPanelNav = !!node.sw,
                        isInfoWindow = !!defn.ifw,
                        isFilterPanel = !!defn.ifp;

                    if (hasPanelNav) {
                        
                        lTb.push(fnNewNavButton(mstrmojo.desc(1058, 'Previous'), 'tbPrev', 'prevEnabled', -1));   

                        
                        rTb.push(fnNewNavButton(mstrmojo.desc(2917, 'Next'), 'tbNext', 'nextEnabled', 1));   
                    }

                    
                    if (isInfoWindow) {
                        
                        rTb.push($NIB(mstrmojo.desc(2102, 'Close'), tbCssClass + 'mstrmojo-DocInfoWindow-close', function () {
                            this.parent.parent.parent.close();
                        }));
                    }

                    if (isFilterPanel) { 
                        buttonbarNodeClass = 'ifp';

                        children.push({
                            scriptClass: 'mstrmojo.HBox',
                            slot: 'buttonbarNode',
                            alias: 'buttonbar',
                            cssClass: 'buttonBox',
                            children: [{
                                scriptClass: 'mstrmojo.Button',
                                alias: 'applyNow',
                                title: mstrmojo.desc(2164, 'Apply'),
                                text: mstrmojo.desc(2164, 'Apply'),
                                cssClass: 'mstrmojo-FilterPanel-Btn apply',
                                bindings: {
                                    visible: function () {
                                        return !defn.cas;
                                    },
                                    enabled: function () {
                                        return this.parent.parent.applyEnabled;
                                    }
                                },
                                onclick: function onclick() {
                                    if (w && w.applyBufferedSlices) {
                                        w.applyBufferedSlices();
                                    }
                                }
                            }]
                        });

                        rTb.push({
                            scriptClass: 'mstrmojo.Button',
                            cssClass: 'mstrmojo-oivmSprite tbDown',
                            alias: 'btnMenu',
                            onclick: function onclick() {
                                this.openPopupMenu();
                            },
                            openPopupMenu: function () {
                                var dl = getPopupDelegate(this, 'openPopupMenu');
                                if (dl) {
                                    dl.openPopupMenu('mstrmojo.FilterPanelMenu', {
                                        openerButton: this,
                                        fps: w,
                                        cmPos: this.cmPos
                                    });
                                }
                            }
                        });
                        hasTitlebarMenuButton = true;
                    }

                    
                    if (isInfoWindow || isFilterPanel) {
                        var boxCss = [];
                        if (hasPanelNav) {
                            boxCss[0] = 'pst-l';
                        }

                        if (isFilterPanel) {
                            boxCss.push('ifp');
                        }

                        lTb.push({
                            scriptClass: 'mstrmojo.Box',
                            cssClass: boxCss.join(' ')
                        });
                    }

                    if (isInfoWindow || hasPanelNav || isFilterPanel) {
                        var ifwCss = isInfoWindow ? 'ifw ' : '',
                            ifpCss = isFilterPanel ? 'ifp ' : '',
                            casCss = !defn.cas ? 'cas ' : '';

                        toolbarNodeCssClass = (hasPanelNav ? 'pst-r ' : '') + ifwCss + ifpCss + casCss;
                        leftToolbarNodeCssClass = (hasPanelNav ? 'pst-l ' : '') + ifwCss + ifpCss + casCss;
                        children.push({
                            scriptClass: 'mstrmojo.ToolBar',
                            slot: 'leftToolbarNode',
                            alias: 'leftToolbar',
                            children: lTb
                        });
                        children.push({
                            scriptClass: 'mstrmojo.ToolBar',
                            slot: 'toolbarNode',
                            alias: 'rightToolbar',
                            children: rTb
                        });
                    }
                }

                
                if (t === en.SELECTOR && w.spm) { 
                    toolbarNodeCssClass = 'spm';

                    
                    children.push({
                        scriptClass: 'mstrmojo.ToolBar',
                        slot: 'toolbarNode',   
                        alias: 'rightToolbar',
                        children: [{
                            scriptClass: 'mstrmojo.Button',
                            cssClass: 'mstrmojo-oivmSprite tbDown',
                            alias: 'btnMenu',
                            onclick: function onclick() {
                                this.openPopupMenu();
                            },
                            openPopupMenu: function () {
                                var dl = getPopupDelegate(this, 'openPopupMenu');
                                if (dl) {
                                    dl.openPopupMenu('mstrmojo.SelectorMenu', {
                                        openerButton: this,
                                        selector: w,
                                        cmPos: this.cmPos
                                    });
                                }
                            }
                        }]
                    });
                    hasTitlebarMenuButton = true;
                }

                
                var Cls = 'Doc' + (resizable ? 'Resizable' : '') + 'Portlet',
                    props = {
                        defn: w.defn,
                        model: w.model,
                        children: children,
                        title: w.title,
                        count: w.count,
                        floatingTitle: (defn.ttl === undefined && defn.qsm),
                        leftToolbarNodeClass: leftToolbarNodeCssClass,
                        loadDataOnResize: hasGraph,
                        toolbarNodeClass: toolbarNodeCssClass,
                        buttonbarNodeClass: buttonbarNodeClass,
                        attachContextMenuEvent: hasTitlebarMenuButton
                    };

                if (t === en.PANELSTACK) {
                    props.bindings = {
                        title: 'this.children[0].title' 
                    };

                    
                    
                    
                    if (node.sw) {
                        props.bindings.prevEnabled = function () {
                            return this.children[0].hasPreviousPanel;
                        };
                        props.bindings.nextEnabled = function () {
                            return this.children[0].hasNextPanel;
                        };
                    }

                    
                    if (defn.ifp) {
                        props.bindings.applyEnabled = function () {
                            return this.children[0].applyEnabled;
                        };
                    }
                }

                return new mstrmojo[Cls](props);
            },

            getPortletExportGridToolbar: mstrmojo.emptyFn,

            
            getLayoutViewerClass: function getLayoutViewerClass(node) {
                return mstrmojo.DocLayoutViewer;
            },

            
            newLayout: function newLayout(model, node) {

                
                var chs = [],
                    nodeData = node.data,
                    nodeDefn = node.defn,
                    LayoutViewerCls = this.getLayoutViewerClass(node),
                    dlv = new LayoutViewerCls({
                        n: nodeDefn.title,    
                        model: model,
                        node: node,
                        controller: this.parent.controller,
                        tbc: nodeDefn.tbc,
                        slot: 'containerNode',
                        visible: false,        
                        ifs: nodeData.ifs,    
                        gb: nodeData.gbys     
                    });

                
                var defn = dlv.defn = $HASH.copy(nodeDefn);
                defn.fmts = $HASH.copy(nodeDefn.fmts);

                



                var fnHeaders = function (headers, slot) {
                    var cnt = headers.length;
                    if (cnt) {
                        var h, f;
                        for (h = 0; h < cnt; h++) {
                            f = this.build([headers[h]], model)[0];
                            f.slot = slot;
                            chs.push(f);
                        }
                    }
                };

                fnHeaders.call(this, model.getFixedHeaders(node), 'fixedHeaderNode');

                
                var LayoutCls = mstrmojo['DocLayout' + ((nodeDefn.horiz) ? 'Horiz' : '')];

                
                chs.push(new LayoutCls({
                    slot: "layout",
                    id: node.id,
                    k: node.k,
                    minHeight: nodeData.mh,
                    formatResolver: model.formatResolver,
                    rules: nodeDefn.rules,
                    builder: this,
                    node: node,
                    defn: nodeDefn,
                    model: model
                }));

                
                fnHeaders.call(this, model.getFixedFooters(node), 'fixedFooterNode');

                
                dlv.addChildren(chs);

                return dlv;
            },

            newSection: function (model, node) {
                
                var cls = (node.defn.horiz && node.data.subsections.length > 1) ? 'DocSectionHoriz' : 'DocSection';
                return new mstrmojo[cls]({
                    id: node.id,
                    node: node,
                    model: model
                });
            },

            newHTMLContainer: function (model, node) {
                
                var cls = (node.defn.ht === 0) ? 'DocHTMLContainer' : 'DocTextfield';
                return new mstrmojo[cls]({
                    id: node.id,
                    node: node,
                    model: model
                });
            },

            adjustMojoVisualizationClass: function adjustMojoVisualizationClass(className) {
                
                return className;
            },

            newMojoVisualization: function (model, node) {
                var visList = this.visList,
                    nodeData = node.data,
                    visInfo = visList.getVis(nodeData.visName);

                
                if (!visInfo) {
                    
                    var className = nodeData.className;
                    if (!className) {
                        
                        return this.newXtab(model, node);
                    }

                    
                    visInfo = {
                        dc: className
                    };
                }

                
                var viewClassName = (visInfo.dc !== undefined) ? visInfo.dc : visInfo.c;

                
                viewClassName = this.adjustMojoVisualizationClass(viewClassName);

                
                mstrmojo.requiresCls('mstrmojo.' + viewClassName);

                var ViewClass = $HASH.walk(viewClassName, mstrmojo),                 
                    ModelClass = $HASH.walk(visInfo.m || "DocVisModel", mstrmojo);  

                
                if (!ViewClass || !ModelClass) {
                    throw new Error('Missing visualization class.');
                }

                
                ViewClass = visList.getVisClass(ViewClass, node.defn);

                
                var vis = new ViewClass($HASH.copy(nodeData.extProps, {
                    id: node.id,
                    node: node,
                    n: node.defn.title,    
                    controller: this.parent.controller,
                    gb: nodeData.gbys                       
                }));

                
                vis.setModel(new ModelClass({
                    xtab: vis,
                    controller: this.parent.controller,
                    docModel: model
                }));

                
                vis.model.set('data', nodeData);

                
                
                
                if (!!node.data.sdp) {
                    var sdpKey;
                    for (sdpKey in node.data.sdp) {
                        node.data.sdp[sdpKey].defn = {}; 
                        var obj = this.newXtab(model, node.data.sdp[sdpKey]);

                        
                        obj.setModel(new ModelClass({
                            xtab: obj,
                            controller: this.parent.controller,
                            docModel: model,
                            data: node.data.sdp[sdpKey]
                        }));
                        obj.k = sdpKey; 
                    }
                }

                
                return vis;
            },

            newInfoWindow: function newInfoWindow(cfg) {
                return new mstrmojo.DocInfoWindow(cfg);
            },

            newRoundedRectangle: function newRoundedRectangle(model, node) {
                var $D = mstrmojo.dom,
                    cls = ($D.supports($D.cssFeatures.ROUND_CORNERS)) ? 'DocRectangle' : 'DocRoundRectangle';

                return new mstrmojo[cls]({
                    id: node.id,
                    node: node,
                    model: model
                });
            },

            newSelector: function newSelector(model, node) {
                var cls = (node.defn.ct === '4' ? 'DocActionSelector' : 'DocSelector');
                return new mstrmojo[cls]({
                    id: node.id,
                    node: node,
                    controller: this.parent.controller,
                    model: model
                });
            },

            newXtab: function newXtab(model, node) {
                var txi = node.defn.txi, xtab,
                    Cls = mstrmojo.DocXtab;

                if (txi) {
                    Cls = $CFC(mstrmojo.DocXtab, [ mstrmojo._CanSupportTransaction, mstrmojo._IsEditableXtab ], {
                        scriptClass: 'mstrmojo.DocXtab'
                    });
                }

                xtab = new Cls({
                    id: node.id,
                    node: node,
                    controller: this.parent.controller
                });

                xtab.model = new mstrmojo.DocXtabModel({
                    xtab: xtab,
                    docModel: model
                });

                return xtab;
            },

            getLinkDrillMixins: function getLinkDrillMixins(useHover) {
                return useHover ? [ mstrmojo._HasHoverButton ] : [];
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.DocBuilder",
                         "mstrmojo.MobileDocLayoutViewer",
                         "mstrmojo.MobileDocXtabGraph",
                         "mstrmojo._XtabSeamlessIncrementalFetch",
                         "mstrmojo._HasScrollbox",
                         "mstrmojo.MobileXtab",
                         "mstrmojo.graph.MobileDocXtabCanvasGraph",
                         "mstrmojo.DynamicClassFactory",
                         "mstrmojo.android.DocSelectorViewFactory",
                         "mstrmojo.android.DocPanelStack",
                         "mstrmojo.android.AndroidDocPanel",
                         "mstrmojo.android.ui.DocButton",
                         "mstrmojo.android.HTMLContainer",
                         "mstrmojo._HasRelativeUrls",
                         "mstrmojo._Formattable",
                         "mstrmojo._IsDocXtab",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo._IsInteractiveGrid",
                         "mstrmojo.android.AndroidDICConfig",
                         "mstrmojo.AndroidVisList",
                         "mstrmojo.array",
                         "mstrmojo.hash",
                         "mstrmojo.maps.AndroidDocMap",
                         "mstrmojo.maps.MapInfoWindowLayoutViewer",
                         "mstrmojo.android.ui._IsTouchLink",
                         "mstrmojo._HasDrillLinks");


    var $CFC = mstrmojo.DynamicClassFactory.newComponent,
        $HRU = mstrmojo._HasRelativeUrls,
        $FREE = mstrmojo.Obj.free,
        $EN = mstrmojo.EnumRWUnitType,
        $ARR = mstrmojo.array,
        $HASH = mstrmojo.hash;

    
    mstrmojo.DocXtab = $CFC(mstrmojo.MobileXtab, [ mstrmojo._Formattable, mstrmojo._IsSelectorTarget, mstrmojo._IsDocXtab ], {
        scriptClass: 'mstrmojo.DocXtab',
        
        scrollerConfig: {
            scrollPast: false
        }
    });

    
    var mapSuperPkg = (!!mstrMobileApp && !!mstrMobileApp.useNativeMap && mstrMobileApp.useNativeMap()) ? 'androidmap' : 'jsmap';
    mstrmojo.maps.AndroidDocLayoutMap = $CFC(mstrmojo.maps[mapSuperPkg].AndroidDocMap, null, {
        scriptClass: 'mstrmojo.maps.AndroidDocLayoutMap'
    });

    
    mstrmojo.MobileDocImage = $CFC(mstrmojo.DocImage, [ $HRU ], {
        scriptClass: 'mstrmojo.MobileDocImage',
        relativeUrls: [ 'v' ]
    });

    mstrmojo.MobileDocHTMLContainer = $CFC(mstrmojo.DocHTMLContainer, [ $HRU ], {
        scriptClass: 'mstrmojo.MobileDocHTMLContainer',
        relativeUrls: [ 'v' ]
    });

    
    var fh = mstrmojo.DocLayout.prototype.formatHandlers.domNode;
    $ARR.removeItem(fh, 'border');
    $ARR.removeItem(fh, 'background-color');

    
    mstrmojo.MobileDocBuilder = mstrmojo.declare(
        
        mstrmojo.DocBuilder,

        
        null,

        
        {
            scriptClass: "mstrmojo.MobileDocBuilder",

            init: function init(props) {
                this._super(props);

                if (!this.destroyObjects) {
                    this.destroyObjects = [];
                }

                
                this.selectorFactory = new mstrmojo.android.DocSelectorViewFactory();

                var clsMap = this.classMap;

                
                clsMap[$EN.GRAPH] = (mstrApp.onMobileDevice() && mstrApp.useBinaryFormat) ? {
                    n: 'graph.MobileDocXtabCanvasGraph',
                    scriptClass: 'mstrmojo.graph.MobileDocXtabCanvasGraph'
                } : {
                    n: 'MobileDocXtabGraph',
                    scriptClass: 'mstrmojo.MobileDocXtabGraph'
                };

                
                clsMap[$EN.IMAGE] = {
                    n: 'MobileDocImage',
                    scriptClass: 'mstrmojo.MobileDocImage'
                };

                
                clsMap[$EN.PANELSTACK] = {
                    n: 'PanelStack',
                    scriptClass: 'mstrmojo.android.DocPanelStack'
                };

                
                clsMap[$EN.PANEL] = {
                    n: 'Panel',
                    scriptClass: 'mstrmojo.android.AndroidDocPanel'
                };

                
                clsMap[$EN.TEXTFIELD + 'B'] = {
                    n: 'Button',
                    scriptClass: 'mstrmojo.android.ui.DocButton'
                };
            },

            visList: mstrmojo.AndroidVisList,

            
            getLayoutViewerClass: function getLayoutViewerClass(node) {
                
                if (node.defn.iw) {
                    
                    var className = 'MapInfoWindowLayoutViewer';

                    
                    if (mstrApp.onMobileDevice()) {
                        
                        className = 'Mobile' + className;
                    }

                    
                    return mstrmojo.maps[className];
                }

                
                return mstrmojo.MobileDocLayoutViewer;
            },

            
            newLayout: function newLayout(model, node) {
                var vis = node.defn.visName;

                
                if (vis) {
                    
                    var groupByInfo = node.data.gbys;

                    
                    
                    
                    var layoutModel = model,
                        layoutNode = $HASH.clone(node);

                    
                    var visGrid = mstrmojo.Vis.getVisGrid(model, node, node.defn.visGK);
                    if (visGrid) {
                        node.data = visGrid.data;

                        if (node.defn.vp && Object.keys(node.defn.vp).length > 0) { 
                            visGrid.data.vp = node.defn.vp;
                        }

                        
                        node.data.layoutModel = layoutModel;
                        node.data.layoutNode = layoutNode;

                        
                        node.data.gbys = groupByInfo;
                    }

                    
                    node.defn = model.makeObservable(node.defn);

                    this.destroyObjects.push(node.defn);

                    
                    var visObj = this.visList.getVis(vis),
                        viewClassName = (visObj.dc !== undefined) ? visObj.dc : visObj.c,
                        xtab,
                        xtabModel;

                    
                    
                    
                    try {

                        
                        if (/AndroidDocMap/.test(viewClassName)) {
                            
                            viewClassName = 'maps.AndroidDocLayoutMap';
                        }

                        var ViewClass = $HASH.walk(viewClassName, mstrmojo),                
                            ModelClass = $HASH.walk(visObj.m || "DocVisModel", mstrmojo),  
                            controller = this.parent.controller;                            

                        
                        xtab = new ViewClass({
                            id: (visGrid && visGrid.id) || node.id,
                            node: node,
                            n: node.defn.title,             
                            controller: controller,
                            gb: node.data.gbys,             
                            isFullScreenWidget: true        
                        });

                        
                        xtabModel = new ModelClass({
                            xtab: xtab,
                            controller: controller,
                            docModel: model
                        });

                        
                        xtab.setModel(xtabModel);

                    } catch (e) {
                        
                        xtab = $FREE(xtab);
                        xtabModel = $FREE(xtabModel);

                        throw e;
                    }

                    return xtab;
                }

                return this._super(model, node);
            },

            
            newHTMLContainer: function (model, node) {
                
                var clsName = (node.defn.ht === 0) ? 'MobileDocHTMLContainer' : 'android.HTMLContainer',
                    Cls = mstrmojo.hash.walk(clsName, mstrmojo);

                
                return new Cls({
                    id: node.id,
                    node: node,
                    model: model
                });
            },

            getLinkDrillMixins: function getLinkDrillMixins(useHover) {
                
                return [ mstrmojo.android.ui._IsTouchLink, mstrmojo._HasDrillLinks ];
            },

            createPortlet: function createPortlet(t, node, w) {
                
                if (node.defn.ifw) {
                    
                    var selPanelKey = w.selectedKey,
                        selPanelDef = (w.model.getUnitDefinitions(selPanelKey) || {})[selPanelKey],
                        selPanelTitle = selPanelDef && selPanelDef.ttl;

                    w.defn.ttl = ((w.titleSrc === w.TTL_SRC_PANEL) ? selPanelTitle : w.defn.ttl) || '';

                    if (!mstrApp.isTablet()) {
                        
                        w.title = w.defn.ttl;

                        
                        return w;
                    }
                }

                return this._super(t, node, w);
            },

            destroy: function destroy() {
                var destroyObjects = this.destroyObjects,
                    i;
                if (destroyObjects) {
                    for (i = 0; i < destroyObjects.length; i++) {
                        if (destroyObjects[i].destroy) {
                            destroyObjects[i].destroy();
                        }
                    }
                }
                this._super();
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.android.ui.RootView",
                         "mstrmojo.android.ui.ViewSwitcher",
                         "mstrmojo.android.ui.ActionBar",
                         "mstrmojo.android.ui.FolderView",
                         "mstrmojo.android.ui.ResultSetView",
                         "mstrmojo.android.ui.DocumentView",
                         "mstrmojo.graph.MobileXtabCanvasGraph",
                         "mstrmojo.android.ui.PromptsView",
                         "mstrmojo.android.ui.PropertiesView",
                         "mstrmojo.android.ui.SettingsView",
                         "mstrmojo.AndroidXtabStandalone",
                         "mstrmojo.MobileDocBuilder",
                         "mstrmojo.MobileGraph",
                         "mstrmojo.hash",
                         "mstrmojo.android.ui.NoProjectsView");

    
    mstrmojo.android.factories.ViewFactory = mstrmojo.declare(

        mstrmojo.Obj,

        null,

        
        {
            scriptClass: 'mstrmojo.android.factories.ViewFactory',

            
            newRootView: function newRootView(params) {
                return new mstrmojo.android.ui.RootView(params);
            },

            
            newActionBarView: function newActionBarView(params) {
                return new mstrmojo.android.ui.ActionBar(params);
            },

            
            newSwitcherView: function newSwitcherView(params) {
                return new mstrmojo.android.ui.ViewSwitcher(params);
            },

            
            newFolderView: function newFolderView(params) {
                return new mstrmojo.android.ui.FolderView(params);
            },

            
            newResultSetView: function newResultSetView(params) {
                return new mstrmojo.android.ui.ResultSetView(params);
            },

            
            newXtabView: function newXtabView(params) {
                var viz = params.viz,
                    clazz = mstrmojo.hash.walk( (viz) ? viz.c : 'AndroidXtabStandalone', mstrmojo );
                return new clazz(params);
            },

            
            newDocumentView: function newDocumentView(params) {
                var doc = new mstrmojo.android.ui.DocumentView(mstrmojo.hash.copy(params, {
                    cssClass: 'mstrmojo-DocumentView'
                }));

                
                doc.builder = new mstrmojo.MobileDocBuilder({
                    parent: doc
                });

                return doc;
            },

            
            newGraphView: function newGraphView(params) {
                var Clazz = (mstrApp.onMobileDevice() && mstrApp.useBinaryFormat) ? mstrmojo.graph.MobileXtabCanvasGraph : mstrmojo.MobileGraph;
                return new Clazz(params);
            },

            
            newPromptsView: function newPromptsView(params) {
                return new mstrmojo.android.ui.PromptsView(params);
            },

            
            newPropertiesView: function newPropertiesView(params) {
                return new mstrmojo.android.ui.PropertiesView(params);
            },

            
            newSettingsView: function newSettingsView(params) {
                return new mstrmojo.android.ui.SettingsView(params);
            },

            
            newCalendarDialogView: mstrmojo.emptyFn,

            
            newNoProjectsView: function newNoProjectsView(params) {
                return new mstrmojo.android.ui.NoProjectsView(params);
            },

            
            newHeatMapEditorView: function (params) {
                return new mstrmojo.VisHeatMapPopup(params);
            },

            
            newView: function newView(type, params) {
                return this['new' + type + 'View'](params);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.factories.ViewFactory",
                         "mstrmojo.android.large.ui.ActionBar",
                         "mstrmojo.android.large.ui.BrowserView",
                         "mstrmojo.android.large.ui.SettingsView",
                         "mstrmojo.android.large.ui.PromptsView",
                         "mstrmojo.android.large.ui.ResultSetView",
                         "mstrmojo.android.large.ui.TransactionView",
                         "mstrmojo.android.large.ui.TxEditDoc",
                         "mstrmojo.android.large.ui.TxTypeList",
                         "mstrmojo.android.large.ui.CalendarDialog");

    
    mstrmojo.android.large.factories.ViewFactory = mstrmojo.declare(

        mstrmojo.android.factories.ViewFactory,

        null,

        
        {
            scriptClass: 'mstrmojo.android.large.factories.ViewFactory',

            
            newActionBarView: function newActionBarView(params) {
                return new mstrmojo.android.large.ui.ActionBar(params);
            },

            
            newBrowserView: function newBrowserView(params) {
                return new mstrmojo.android.large.ui.BrowserView(params);
            },

            
            newSettingsView: function newSettingsView(params) {
                return new mstrmojo.android.large.ui.SettingsView(params);
            },

            
            newPromptsView: function newPromptsView(params) {
                return new mstrmojo.android.large.ui.PromptsView(params);
            },

            
            newResultSetView: function newResultSetView(params) {
                return new mstrmojo.android.large.ui.ResultSetView(params);
            },
            
            
            newTransactionsView: function newTransactionsView(params) {
                return new mstrmojo.android.large.ui.TransactionView(params);
            }, 
            
            
            newTransactionsEditDocView: function newTransactionsEditDocView(params) {
                return new mstrmojo.android.large.ui.TxEditDoc(params);
            },
            
            
            newTransactionsTypeListView: function newTransactionsTypeListView(params) {
                return new mstrmojo.android.large.ui.TxTypeList(params);
            },
            
            
            newCalendarDialogView: function newCalendarDialogView(params) {
                return new mstrmojo.android.large.ui.CalendarDialog(params);
            }
        }
    );
}());
