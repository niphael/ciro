/**
 * @namespace The global namespace for all project mojo objects and classes.
 */
var xmjd = mstrmojo && mstrmojo.descriptors;

var mstrmojo = {


    /**
     * <p>Descriptor store. </p>
     *
     * <p>This is a hash map keyed by descriptor key, and value is the localized string for the descriptor.</p>
     */
    descriptors: xmjd || {},

    /**
     * <p>Information about MSTR metadata.</p>
     * @type Object
     */
    meta: {
        TP: "t",     // the key for a web object's type
        STP: "st"    // the key for a web object's sub-type
    },

    emptyFn: function () {},

    /**
     * <p>Get tick count in milliseconds</p>
     * @returns number of milliseconds since beginning of epoch
     * @type Integer
     */
    now: function now() {
        return new Date().getTime();
    },

    /**
     * <p>If true, indicates that the mstrmojo namespace spans multiple frames/windows.</p>
     *
     * @type Boolean
     */
    usesFrames: false
};


//packages declarations
mstrmojo.gmaps = {};

(function () {
    var $mojo = mstrmojo;

    /**
     * <p>Reference to the global context object, typically same as "window" in browsers, may be different
     * in other environments like Adobe AIR.</p>
     * @fieldOf mstrmojo
     * @type Object
     */
    $mojo.global = (function () {
        var f = function () {
            return this;
        };
        return f.call(null);
    }());

    /**
     * <p>Stubs to be overridden by debug.js augmentation.
     */
    $mojo.dbg = $mojo.emptyFn;
    $mojo.dbg_stack = $mojo.emptyFn;
    $mojo.dbg_xhr = $mojo.emptyFn;
    $mojo.dbg_profile = $mojo.emptyFn;


    /**
     * sub packages.
     */
    $mojo.platform = {};
    $mojo.prompt = {};
    $mojo.settings = {};
    $mojo.ui = {};
    $mojo.ACL = {};
    $mojo.storage = {};
    $mojo.utils = {};
    $mojo.maps = {};
    $mojo.maps.androidmap = {};
    $mojo.maps.jsmap = {};
    $mojo.graph = {};
    $mojo.IPA = {};
    $mojo.ME = {};
    $mojo.Architect = {};
    $mojo.plugins = {};
    $mojo.gmaps = {};
    $mojo.DI = {};
    $mojo.qb = {};
    $mojo.WH = {};
    $mojo.txEditor = {};

    // Express mode specific libraries.
    $mojo.express = {
        ui: {}
    };

    // Android specific libraries.
    $mojo.android = {
        controllers: {},
        factories: {},
        inputControls: {},
        large: {
            controllers: {},
            factories: {},
            ui: {}
        },
        medium: {
            controllers: {},
            factories: {},
            ui: {}
        },
        selectors: {},
        ui: {}
    };

    // iPhone specific libraries.
    $mojo.iphone = {};

    // Windows Phone specific libraries.
    $mojo.winphone = {};

    // MSTRWeb JUILS based code.
    $mojo.mstr = {};


    /**
     * <p>Alerts an error message to the user when errors are encountered.</p>
     *
     * @param {HTMLError} e The error object.
     */
    $mojo.err = function err(e) {
        // Default message
        var s = e.name + ': "' + e.message + '"';

        if ($mojo.debug) {
            if (e.fileName) {
                s += ' at\n    ' + e.fileName;
            }
            if (e.hasOwnProperty('lineNumber')) {
                s += ': ' + e.lineNumber;
            } else if (e.hasOwnProperty('line') && e.sourceURL) { //for webkit
                var a = e.sourceURL.split('/');
                s += '(' + a[a.length > 1 ? a.length - 1 : 0] + ':' + e.line + ')';
            }
        }

        // If console is available then output there as well.
        this.dbg(s);
 //       this.dbg_stack();

        // Display to user.
        if ($mojo.Dialog) {
            $mojo.alert(e.message, null, e.name);
        } else {
            window.alert(s);
        }
    };

    /**
     * Displays a simple confirm message using the window.confirm method.
     *
     * @param {String} msg The message to display.
     *
     * @returns True is use pressed Ok button.
     */
    $mojo.confirm = function confirm(msg) {
        return window.confirm(msg);
    };

    /**
     * Displays a simple message to the user with a single 'Ok' button.
     *
     * @param {String} msg The message to display.
     */
    $mojo.alert = function alrt(msg) {
        window.alert(msg);
    };

    /**
     * <p>Used to determine if the current browser can parse a function's body text.</p>
     *
     * @private
     */
    var canParseFuncs = !!(/return true/.test(function () {
        return true;
    }));

    /**
     * <p>Similar to {@link mstrmojo.hash.copy} in that it copies all of the members of a given source hash to another given destination hash, except that
     * it does NOT overwrite existing Functions in the destination.</p>
     *
     * <p>When there is a name collision between 2 functions, the destination receives a newly created wrapper function which
     * allows the overwriting function to call the pre-existing function with the reserved call "this._super()".</p>
     *
     * @param {Object} src The source object whose properties/values should be copied.
     * @param {Object} [dest] An optional hash to receive the copied properties/values.  If this parameter is undefined, an empty hash will be used.
     *
     * @returns {Object} The modified destination hash.
     */
    $mojo.mixin = function mixin(src, dest) {
        if (src) {
            dest = dest || {};
            var funcCallsSuper = /this\.\_super/;

            /**
             * Utility function for adding _super functionality to methods.
             *
             * @param {Function} overwriting
             * @param {Function} inher
             *
             * @inner
             */
            var fnWrapMethod = function (overwriting, inher) {
                return function superwrap() {
                    var tmp = this._super;
                    this._super = inher;
                    var ret = overwriting.apply(this, arguments || []);
                    this._super = tmp;
                    return ret;
                };
            };

            // Optimization: temporarily remove the optional reserved "__onmixin__" property.
            var fnOnMixin = src.__onmixin__;
            if (fnOnMixin) {
                delete src.__onmixin__;
            }

            var n;
            for (n in src) {
                // Are we overwriting a function with a function? And if so, does the
                // overwriting function call "this._super"?
                if ((typeof src[n]  === 'function') && (!canParseFuncs || funcCallsSuper.test(src[n]))) {
                    // Yes, we are subclassing a method with a new method that uses the
                    // "this._super" reserved keyword call to invoke the inherited method.  To support
                    // the reserved keyword, create a wrapper function which encapsulates both the
                    // overwriting method and the inherited method.
                    // Do this even if there is no this._super defined, because the wrapper is
                    // needed to reset this._super back to null; otherwise this._super would get
                    // stuck pointing at the bottom of the inheritance chain, causing an infinite loop there.
                    // For example, suppose the mixin has a method M that checks:
                    // "if (this._super) this._super()"
                    // If the base has no such method M, this._super is null.  So far so good. But now
                    // suppose second mixin is applied on top of the first, and the second mixin does
                    // have an overwriting method named M too, which calls "this._super()".
                    // A wrapper is made around the second M, setting this._super to the first M.
                    // Now after the first M is called, we must reset this._super to null, otherwise,
                    // the "if (this._super)" check in first M [see above] will return true, triggering
                    // an infinite loop!  So who will reset this._super to null when first M is called?
                    // Answer: the wrapper to the first M method, which we create here because even though
                    // first M has no super, its code still references this._super, and that's what matters.
                    dest[n] = fnWrapMethod(src[n], dest[n]);
                } else {
                    // We are not subclassing a method; just do a simple overwrite.
                    dest[n] = src[n];
                }
            }

            // Cleanup optimization.
            if (fnOnMixin) {
                src.__onmixin__ = fnOnMixin;
            }
        }
        return dest;
    };
}());

(function () {

    /**
     * <p>The XMLHTTPRequest object used to load files. Instantiated on-demand.</p>
     * @private
     */
    var _xhr;

    /**
     * <p>Hash of FQCNs that are requested to load but fail.</p>
     *
     * <p>The hash is keyed by FQCN strings; each has value is a Boolean (true).</p>
     */
    var _missing = {};

    var _G = mstrmojo.global,
        _app = _G.mstrApp || {},
        _jsRoot = _app.jsRoot || "../javascript/",
        _jsMojoRoot = _app.jsMojoRoot || "../javascript/mojo/js/source/",
        _isIE = !!document.all;     // Don't use mstrmojo.dom here. Avoid dependencies on utilities.

    /**
     * <p>Computes the relative path of the JavaScript file for the given FQCN.</p>
     *
     * <p>Examples:</p>
     * <ol>
     * <li>"Class1" is mapped to "<mstrApp.jsRoot>Class1.js"</li>
     * <li>"pkg.Class1" is mapped to "<mstrApp.jsRoot>pkg/Class1.js"</li>
     * <li>"mstrmojo.Class1" is mapped to "<mstrApp.jsMojoRoot>Class1.js"</li>
     * <li>"mstrmojo.pkg.Class1" is mapped to "<mstrApp.jsMojoRoot>pkg/Class1.js"</li>
     * </ol>
     *
     * <p>If "mstrApp" is undefined, then the default roots are used:</p>
     * <ol>
     * <li>jsRoot = "../javascript/"</li>
     * <li>jsMojoRoot = "../javascript/mojo/js/source/"</li>
     * </ol>
     *
     * @param {String} fqcn The name of the class to be mapped to a file.
     * @returns {String} The file relative path + name.
     */
    function _fqcn2File(fqcn) {
        if (fqcn.match(/^mstrmojo\.plugins\./)) {
            var pluginName = fqcn.substring(17, fqcn.indexOf(".", 17));
            fqcn = '../plugins/' + pluginName + '/javascript/' + _jsMojoRoot + fqcn.replace("mstrmojo.plugins." + pluginName + '.', "").replace(/\./gm, '/');
        } else if (fqcn.match(/^mstrmojo\./)) {
            fqcn = _jsMojoRoot + fqcn.replace("mstrmojo.", "").replace(/\./gm, '/');
        } else {
            fqcn = _jsRoot + fqcn.replace(/\./gm, '/');
        }
        return fqcn + '.js';
    }

    function _getXHR() {
        // Instantiate XMLHTTPRequest using browser-specific techniques.
        // For IE, use new ActiveXObject(); for Mozilla, new XMLHttpRequest().
        _xhr = self.XMLHttpRequest ? new XMLHttpRequest() : (self.ActiveXObject ? new ActiveXObject("Microsoft.XMLHTTP") : null);
    }
    /**
     * <p>Loads contents of given file into a string using synchronous
     * XMLHTTPRequest GET call.</p>
     *
     * @param {String} file The path + name of the file to load.
     * @returns {String} The file contents as a string, if successful; null otherwise.
     */
    function _syncGet(file) {
        var result = null;

        if (!_xhr) {
            _getXHR();
        }
        if (_xhr) {
            try {
                // Do a synchronous GET call to fetch the file.
                _xhr.open("GET", file, false);
                _xhr.send(null);
                // Retrieve responseText. If successful, status will be 200 (HTTP) or 0 (file://).
                result = _xhr.responseText || null;
            } catch (localerr) {}

            // Minor hack: For Mozilla, do an abort() afterwards to avoid errors.
            // TO DO: investigate why without abort() we get errors on subsequent calls here.
            if (!_isIE && _xhr.abort) {
                _xhr.abort();
            }

        }
        return result;
    }

    /**
     * <p>Encodes parameters for XHR transport.</p>
     *
     * @param {Object} params A hash containing parameter names and values.
     * @returns {String} The encoded parameter string.
     *
     * @type String
     * @returns A URL of encoded parameters.
     *
     * @private
     */
    function encodeParams(params) {
        var x = -1,
            url = [],
            p;

        if (params) {
            for (p in params) {
                url[++x] = p + '=' + encodeURIComponent(params[p]);
            }
        }

        return url.join('&');
    }

    /**
     * <p>Builds up the url with parameters is method == 'GET'.</p>
     *
     * @param {String} method The method for the xhr ('GET' or 'POST').
     * @param {String} baseUrl The url used for both GET and POST (excludes parameters in GET case).
     * @param {Object} [params] The parameters for this request.
     *
     * @type String
     * @returns The url built from the baseUrl and params.
     *
     * @private
     *
     */
    function appendUrlParams(method, baseUrl, params) {
        if (method !== 'GET' || !params) {
            return baseUrl;
        }

        return baseUrl + '?' + encodeParams(params);
    }

    function _syncXHR(method, baseUrl, params) {
        var result = null;

        // Make sure it's uppercase for comparisons.
        method = method.toUpperCase();
        if (!_xhr) {
            _getXHR();
        }
        if (_xhr) {
            try {
                var config = mstrConfig,
                    m = null;

                if (window.microstrategy !== undefined && microstrategy) {
                    m = microstrategy;
                }

                // Set default values.
                params.taskContentType = params.taskContentType || 'json';
                params.taskEnv = 'xhr';
                params.xts = mstrmojo.now();

                params = mstrmojo.addCSRFTokenToTaskParams(params);

                //persisted task params
                var ptp = (config && config.persistTaskParams) || (m && m.persistParams);
                if (ptp) {
                    mstrmojo.requiresCls("mstrmojo.hash");
                    mstrmojo.hash.copy(ptp, params);
                }

                _xhr.open(method, appendUrlParams(method, baseUrl, params), false);

                if (method !== 'POST') {
                    params = null;
                } else {
                    params = encodeParams(params);
                    _xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                }

                _xhr.send(params);
                // Retrieve responseText. If successful, status will be 200 (HTTP) or 0 (file://).
                result = _xhr.responseText || null;
            } catch (localerr) {
                window.console.log(localerr);
            }
        }
        return result;
    }
    /**
     * <p>Loads a given javascript file path synchronously via XmlHttpRequest, then tests if load succeeded by
     * performing a null-check on a given expression.</p>
     *
     * @param {String} file Path + name of the file to load (example: "/javascript/foo.js").
     * @param {String} [nullCheck] JavaScript expression for null-check after the file is loaded.
     * @returns {Boolean} true if the given file is loaded successfully and, optionally, if the given
     * expression does not evaluate to null after the file is loaded; false otherwise.
     */
    function _jsGet(file, nullCheck) {
        var js = _syncGet(file);
        if (js) {
            try {
                eval(js);

                return nullCheck ?
                        !!eval(nullCheck) :
                        true;
            } catch (localerr) {
                window.alert('JavaScript compile error:\n\nFile: ' + file + '\n\nError: ' + localerr.message);
            }
        }
        return false;
    }

    /**
     * <p>Loads script files for javascript objects.</p>
     *
     * @class
     * @static
     */
    mstrmojo.loader = {
        /**
         * <p>Hash of FQCNs that are successfully loaded.</p>
         *
         * <p>The hash is keyed by FQCN strings; each has value is a Boolean (true).</p>
         */
        loaded: {
            mstrmojo: true,
            "mstrmojo.loader": true
        },

        /**
         * <p>Determines if a given JavaScript class is currently loaded.</p>
         *
         * <p>This method tries to evaluate the FQCN into an object. If the evaluation results
         * in a non-null object, the class is considered loaded.  If this method determines that the given FQCN is loaded,
         * it will ensure that the FQCN is recorded in a local hash of loaded classes for future reference.</p>
         *
         * @param {String} fqcn The fully qualified class name of the JavaScript class.
         * @returns {Boolean} true if the given FQCN evaluates to a non-null result; false otherwise.
         */
        isLoaded: function isLd(fqcn) {
            var o;
            try {
                o = eval(fqcn);
            } catch (localerr) {}
            if (o) {
                this.loaded[fqcn] = true;
            }
            return !!o;
        },

        /**
         * Attempts to load a named JavaScript class, if not loaded already.
         */
        load: function ld(fqcn) {
            // Have we tried and failed before?
            if (_missing[fqcn]) {
                return false;
            }
            // Have we succeeded before? Or perhaps it's already loaded?
            if (this.loaded[fqcn] || this.isLoaded(fqcn)) {
                return true;
            }
            // No luck so far. Try to load it for the first time.
            if (_jsGet(_fqcn2File(fqcn), fqcn)) {
                this.loaded[fqcn] = true;
                return true;
            }

            _missing[fqcn] = true;
            return false;
        }
    };

    var _L = mstrmojo.loader,
        _LL = _L.loaded;

    /**
     * <p>Cache of arguments passed into loader.requires method. Used to avoid duplicate loads.</p>
     * @private
     */
    var _reqCache = {};

    /**
     * <p>Ensures that the given fully qualified class names are loaded, as well as the
     * package prefixes of those names. Attempts to load any which are not already loaded, in the given order.</p>
     *
     * <p>This method takes a variable number of input parameters. Each parameter is assumed to be a
     * fully qualified class name (String).</p>
     *
     * @returns {Boolean} true, so that calls can be AND'ed with subsequent operations, for example: "mstrmojo.requiresCls('X') && X.foo()"
     */
    mstrmojo.requiresCls = function reqCls() {
        // Create an array of input strings.
        var as = arguments,
            ns = [],
            len = as.length,
            i;

        // Walk the given FQCN strings...
        for (i = 0; i < len; i++) {

            // Optimization: Have we received this argument before? or preloaded it? If so, skip it.
            var n = as[i];
            if (!n || _LL[n] || _reqCache[n] || _missing[n]) {
                continue;
            }

            if (!n.match(/^mstrmojo\.plugins\./)) {
                // If the argument has package prefixes, first add packages to array of inputs.
                var ps = n.split('.'),
                    klen = ps.length,
                    k;

                for (k = 1; k < klen; k++) {
                    var s = ps.slice(0, k).join('.');
                    if (!_reqCache[s]) {
                        ns.push(s);
                        _reqCache[s] = true;
                    }
                }
            }
            // After package prefixes (if any), add the FQCN to array of inputs.
            ns.push(n);
            _reqCache[n] = true;
        }
        // Now load all the inputs.
        var jlen = ns.length,
            j;
        for (j = 0; j < jlen; j++) {
            if (!_L.load(ns[j])) {
                window.alert('Warning: Javascript class not found:\n' + ns[j]);
                break;
            }
        }
        return true;
    };

    // =============================== loading descriptors =============================
    var _D = mstrmojo.descriptors,
        _dPrefix = 'mstrWeb.';

    /**
     * Merge the descriptors information from input into descriptor store.
     *
     * @param ds {Object} This object contains the descriptor information retrieved from task call.
     * @private
     */
    function populateDescriptors(ds) {
        if (ds) {
            var dlen = ds.length,
                di;
            for (di = 0; di < dlen; di++) {
                var d = ds[di];
                _D[d.key] = d.v;
            }
        }
    }

    mstrmojo.populateDescriptors = populateDescriptors;

    // When this file is loaded, try to merge the pre-loaded descriptor information into descriptor store
    if (window.mstrConfig !== undefined) {
        populateDescriptors(mstrConfig.mstrDescs && mstrConfig.mstrDescs.descriptors);

    // Remove the descriptors loaded into the page...
        mstrConfig.mstrDescs = null;
    }
    if (typeof mstrApp != 'undefined') {
        populateDescriptors(mstrApp.mstrDescs && mstrApp.mstrDescs.descriptors);
    }

    // #694796. merge pre-loaded descriptors
    if (typeof mstrApp != 'undefined') {
        populateDescriptors(mstrApp.mstrDescs && mstrApp.mstrDescs.descriptors);
    }

    /**
     * helper method.
     * @private
     */
    var _reqDesc = function (prefix, ids) {
        // Create an array of input strings.
        var as = ids,
            ns = [],
            len = as.length,
            i;

        for (i = 0; i < len; i++) {
            var k = as[i];
            if (k && !(_D.hasOwnProperty(prefix + k))) {
                ns.push(k);
            }
        }
        if (ns.length > 0) {
            var response = _syncXHR('POST', (window.mstrConfig && mstrConfig.taskURL) || 'taskProc', {
                taskId: 'getDescriptors',
                keys: ns.join(','),
                prefix: prefix
            });

            if (response) {
                var r = eval('(' + response + ')');
                populateDescriptors(r && r.descriptors);
            }
        }
    };

    /**
     * Ensure the required descriptors exist in descriptor store. If any descriptor is missing from the store,
     * this method will make XHR call to load it before returning.
     *
     * <p>This method takes a variable number of input parameters.
     * The first parameter is for the prefix for every key. Each parameter, except the first one, is assumed to be a
     * descriptor id (number).</p>
     */
    mstrmojo.requiresDescsWPrefix = function reqDescP(prefix) {
        var p = prefix,
            args = [].slice.call(arguments);

        args[0] = null;
        _reqDesc(p, args);
    };

    /**
     * <p>Ensure the required descriptors exist in descriptor store.</p>
     * If any descriptor is missing from the store, this method will make XHR call to load it before return.
     *
     * <p>This method takes a variable number of input parameters. Each parameter is assumed to be a
     * descriptor id (number). This method assumes that 'mstrWeb.' is the prefix for each key.</p>
     */
    mstrmojo.requiresDescs = function reqDesc() {
        // if we are not on a mobile device, then request the descriptors via XHR.
        // On a mobile device, it is assumed that the descriptors have been preloaded.
        if (window.mstrConfig !== undefined && !mstrConfig.onMobileDevice) {
            _reqDesc(_dPrefix, arguments);
        }
    };

    /**
     * <p>Returns the localized string for the descriptor key.</p>
     * This method assume the 'mstrWeb.' as the prefix. So, it will look up the descriptor by key 'mstrWeb.' + key.
     *
     * @param descID {Number} the key for the descriptor. It assumes the prefix for the key is 'mstrWeb.'.
     * @param defText {String} The text to use for the descriptor if it cannot be loaded.
     */
    mstrmojo.desc = function desc(descID, defText) {
        // Is the descID parameter a non-null value?
        if (descID !== null && descID !== undefined) {
            // Load the descriptor remotely if it is not found in the local store...
            mstrmojo.requiresDescs(descID);

            // Was it found?
            if (_D.hasOwnProperty(_dPrefix + descID)) {
                return _D[_dPrefix + descID];
            }

            // Give a meaningful string if omitted...
            defText = defText || "No string descriptor found for descID=" + descID;
        }

        // "Decorate" the default text...
        var decDefText = "[" + defText + "]";

        // Put the replacement text in the array so it doesn't get continually loaded from the Web Server...
        _D[_dPrefix + descID] = decDefText;

        return decDefText;
    };

    /**
     * <p>Returns the localized string for the descriptor key.</p>
     * This method will lookup the descriptor whose key prefix + key.
     *
     * @param prefix {String} the prefix for the key.
     * @param descID {Number} the key for the descriptor. It assumes the prefix for the key is 'mstrWeb.'.
     * @param defText {String} The text to use for the descriptor if it cannot be loaded.
     */
    mstrmojo.descP = function descP(prefix, descID, defText) {
        // Load the descriptor remotely if it is not found in the local store...
        mstrmojo.requiresDescsWPrefix(prefix, descID);

        // Was it found?
        if (_D.hasOwnProperty(prefix + descID)) {
            return _D[prefix + descID];
        }

        // Give a meaningful string if omitted...
        defText = defText || "No string descriptor found for descID=" + descID;

        // "Decorate" the default text...
        var decDefText = "*" + defText + "*";

        // Put the replacement text in the array so it doesn't get continually loaded from the Web Server...
        _D[prefix + descID] = decDefText;

        return decDefText;
    };

    // =================== End of descriptors ============================

    /**
     * Records a given static class as loaded under a given fully qualified class name.
     *
     * @param {String} fqcn The fully qualified class name.
     * @param {Object} cls The static class object.
     * @returns {Object} The same static class object.
     */
    mstrmojo.provide = function prv(fqcn, cls) {
        _LL[fqcn] = !!cls;
        return cls;
    };

       //TQMS : 536567
    /**
     * This method will mark the given fqcn to reload again when the mstrmojo.requiresCls used
     * the normal behaviour of mstrmojo.requireCls is to not load the class if it is reloaded
     * to force reload a class, the user can call this method passing the fully qualified class name
     *
     * @param (String) fqcn fully qualified class name that should be reloaded during its next call to mstrmojo.requiresCls
     * @param (Boolean) reload flag that tells whether to reload.
     *                  true means reload
     *                  false means do not reload which is the default behaviour of mstrmojo.requiresCls
     */
    mstrmojo.invalidateCls = function rel(fqcn) {
        _reqCache[fqcn] = false;
        _LL[fqcn] = false;

        eval(fqcn + " = null");
    };

    var mx = mstrmojo.mixin;

    /**
     * Creates a javascript custom class with the given superclass, mixins, and instance properties/methods.
     *
     * @param {Function} SuperCls The constructor of the superclass for the class to be declared. If missing, Object is implied.
     * @param {Object[]} mixins An optional array of "mixins" to be applied to the new custom class. A "mixin" is a hashtable of
     * properties and/or methods; if given, these will be applied to the constructor's prototype.
     * @param {Object} config A hashtable of functions, keyed by name. The functions are assumed to be instance methods;
     * they are applied to the constructor's prototype.
     *
     * @returns The class constructor.
     */
    mstrmojo.declare = function dcl(SuperCls, mixins, config) {
        /**
         * Create a constructor for our custom class.  The constructor doesn't do much itself, it just calls
         * the class's instance method "init" (if any).  The one other job of the constructor is to check if the
         * input param tells it to skip the "init" call; this is useful when defining a subclass, because in
         * that scenario we want to skip the init call.
         *
         * @param {Object} [props={}] Optional instance properties.
         * @inner
         */
        function constr(props) {
            if ((!props || !props.dontInit) && this.init) {
                this.init(props);
            }
        }

        // If superclass is given, set the constructor's prototype to an instance of it.  This allows
        // every instance of our constructor to inherit all the superclass' instance methods/props.  However,
        // this also means that all instances of our constructor will inherit the "constructor" property
        // from that superclass instance; the superclass instance's "constructor" property is the superclass constructor.
        // That's not right for us; we want all instances of our constructor to have their "constructor" property
        // point back to our constructor (of course).  To fix that, simply manually reset the constructor's prototype's
        // "constructor" back to our constructor.
        if (SuperCls) {
            constr.prototype = new SuperCls({dontInit: true});
            constr.prototype.constructor = constr;
        }

        var proto = constr.prototype;

        // Apply all the mixin methods to the constructor's prototype.
        var cnt = (mixins && mixins.length) || 0,
            i;
        for (i = 0; i < cnt; i++) {
            mx(mixins[i], proto);
        }

        // Apply all the instance methods to the constructor's prototype.
        if (config) {
            mx(config, proto);
            if (config.scriptClass) {
                _LL[config.scriptClass] = true;
            }
        }

        return constr;
    };

    /**
     * Finds an ancestor widget (via 'parent' chain) by searching for the prescence of a particular field or method.
     *
     * @param {mstrmojo.Widget} src The {@link mstrmojo.Widget} to begin searching from.
     * @param {String} property The name of the field or method to search for.
     * @param {*} [value=null] An optional property value to match against.
     * @param {mstrmojo.Container} [limitClass=null] An optional constructor to be used to limit the search.  If at any time this search encounters an instance of this passed constructor
     *                                               the search will halt and null will be returned.
     *
     * @type mstrmojo.Container
     * @returns The found instance of {@link mstrmojo.Container}, or null if not found.
     * @static
     */
    mstrmojo.findAncestor = function findAncestor(src, property, value, limitClass) {
        var ancestor = src && src.parent;
        while (ancestor && (!limitClass || !(ancestor instanceof limitClass))) {
            var targetProperty = ancestor[property];
            if (targetProperty !== undefined) {
                if (value !== undefined && value !== null) {
                    if (targetProperty === value) {
                        return ancestor;
                    }
                } else {
                    return ancestor;
                }
            }

            ancestor = ancestor.parent;
        }

        return null;
    };

    /**
     * Check a given mojo widget to see whether it is a descandant of another mojo widget.
     * @param {mstrmojo.Widget} parent The container widget.
     * @param {mstrmojo.Widget} child The candidate descendant widget.
     * @returns True if child widget is a descendant of parent widget, otherwise, false
     */
    mstrmojo.isDescendant = function isDescendant(parent, child) {
        var ancestor;

        if(!child || !parent) {
            return false;
        }
        ancestor = child.parent;
        //loop through the ancestor of child widget
        while(ancestor) {
            //if found a match, end the loop and return true
            if(ancestor === parent) {
                return true;
            }
            //otherwise, look for its parent
            ancestor = ancestor.parent;
        }
        return false;
    };

    /**
     * Get CSRF token
     * @param {*} [url=null] the url where the token is to be added to. It would not append if it points to a different Web application
     * @returns {string} the csrf token
     */
    mstrmojo.getCSRFToken = function getVRN(url) {
        var tkn = null;

        try {
            if (url) { // if a URL is provided we first check if we should add the token
                if (url.indexOf('validateRandNum=') >= 0) { // token already there?
                    return tkn;
                }

                var curURL = window.location.href;
                var servletName = window.mstrApp && mstrApp.name,
                    taskProcName = window.mstrConfig.taskURL && mstrConfig.taskURL,
                    isSameWebApp = (url.indexOf(servletName) === 0 || //mstrWeb
                        url.indexOf('./' + servletName) === 0 || // ./mstrWeb
                        url.indexOf(taskProcName) === 0 || //taskProc
                        url.indexOf('./' + taskProcName) === 0 || // ./taskProc
                        url.indexOf(curURL) === 0 || // http://localhost:8080/MicroStrategy/servlet/mstrWeb
                        ((curURL.indexOf('?') > 0) && (url.indexOf(curURL.substring(0, curURL.indexOf('?'))) === 0))); // http://localhost:8080/MicroStrategy/servlet/mstrWeb?a=1&b=2
                if (!isSameWebApp) { // links to external websites do not need the token
                    return tkn;
                }
            }
            if (window.mstrApp && mstrApp.validateRandNum) {
                tkn = mstrApp.validateRandNum;
            } else if (window.mstrConfig && mstrConfig.validateRandNum) {
                tkn = mstrConfig.validateRandNum;
            } else if (window.microstrategy !== undefined && microstrategy && microstrategy.validateRandNum) {
                tkn = microstrategy.validateRandNum;
            }
        } catch (err) {
            //ignore
        }
        return tkn;
    };

    /**
     * Adds the CSRF token to a URL if needed
     * @param {String} url the url to add the token to
     * @returns {String} url with appended token if needed
     */
    mstrmojo.addCSRFTokenToURL = function addCSRFTknToURL(url) {
        if (!url) {
            return '';
        }
        var tkn = mstrmojo.getCSRFToken(url);
        if (tkn && tkn.length > 0) {
            if (url.indexOf('?') > 0) {
                url += "&";
            } else {
                url += "?";
            }
            url += "validateRandNum=" + tkn;
        }
        return url;
    };

    /**
     * Adds the CSRF token to task params if needed
     * @param {Object} params the task params collection
     * @returns {Object} params the task params collection
     */
    mstrmojo.addCSRFTokenToTaskParams = function addCSRFTknToTaskParams(params) {
        if (params) {
            var tkn = mstrmojo.getCSRFToken();
            if (tkn && tkn.length > 0) {
                params.validateRandNum = tkn;
            }
        }
        return params;
    };

    /**
     * <p>Returns a new instance as described by the configuration.</p>
     *
     * @param {Object} config The configuration for the requested instance (must include a valid scriptClass property).
     *
     * @return mstrmojo.Obj
     */
    mstrmojo.getInstance = function getInstance(config) {
        var Clazz = mstrmojo.hash.walk(config.scriptClass, window);
        if (Clazz) {
            return new Clazz(config);
        }

        return null;
    };

}());
/**
 * _IsGraphDataService.js
 * @author Jamshed Ghazi
 * Copyright 2012 MicroStrategy Incorporated. All rights reserved.
 *
 * @fileoverview <p>Mixin that provide the task calls shared between Report and Document Graphs.</p>
 * @version 1.0
 */
(function(){


	mstrmojo._IsGraphDataService = mstrmojo.provide(
			"mstrmojo._IsGraphDataService",

			/**
			 * @lends mstrmojo._IsGraphDataService
			 */
			{
				handleUserSingleTap: function handleUserSingleTap(sliceID, nodekey, x, y, selectable, callback) {
					if(mstrApp.onMobileDevice()) {
						mstrApp.serverRequest({
							taskId: 'handleUserSingleTap',
							sliceID: sliceID,
							nodekey: nodekey,
							x: x,
							y: y,
							selectable: selectable
						}, callback);
					}
				}

			});
}());
(function(){
    //This class is borrowed from http://www.webtoolkit.info/javascript-base64.html
    
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    
    var $SFCC = String.fromCharCode;
    
    function _utf8_encode(string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";
     
        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);
            if (c < 128) {
                utftext += $SFCC(c);
            }else if((c > 127) && (c < 2048)) {
                utftext += $SFCC((c >> 6) | 192);
                utftext += $SFCC((c & 63) | 128);
            }else {
                utftext += $SFCC((c >> 12) | 224);
                utftext += $SFCC(((c >> 6) & 63) | 128);
                utftext += $SFCC((c & 63) | 128);
            }
         }
        return utftext;
    }
     
    function _utf8_decode(utftext) {
        var string = "",
            i = 0,
            c = 0, c1 = 0, c2 = 0;
        
        while ( i < utftext.length ) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
                string += $SFCC(c);
                i++;
            }else if((c > 191) && (c < 224)) {
                c1 = utftext.charCodeAt(i+1);
                string += $SFCC(((c & 31) << 6) | (c1 & 63));
                i += 2;
            }else {
                c1 = utftext.charCodeAt(i+1);
                c2 = utftext.charCodeAt(i+2);
                string += $SFCC(((c & 15) << 12) | ((c1 & 63) << 6) | (c2 & 63));
                i += 3;
            }
        }
        return string;
    }
    
    mstrmojo.base64 = mstrmojo.provide(
        "mstrmojo.base64",
        /**
         * @lends mstrmojo.base64
         */
        {
            /**
             * <p> Decode the Base64-encoded response header whose value are in the following format: "=?UTF-8?B?EncodedText?=" </p>
             * 
             * @param {String} value The value of a response header.
             * @returns {String} The decoded response header.
             */
            decodeHttpHeader: function(value){
                var rEncoded = /\=\?UTF-8\?B\?(.+?)\?\=/g;
                if (value && value.indexOf("=?UTF-8?B?") === 0){
                    var decMsg = "", result;
                    while ((result = rEncoded.exec(value)) !== null){
                        decMsg += mstrmojo.base64.decode(result[1]);
                    }
                    return decMsg;
                }
                return value;
            },
            
            /**
             * Use Base64 to encode a string input. 
             * @param {String} input A string value.
             * @type String
             * @return The Base64 encoded string
             */
            encode: function (input) {
                var output = "";
                var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
                var i = 0;
                
                input = _utf8_encode(input);
                while (i < input.length) {
                    chr1 = input.charCodeAt(i++);
                    chr2 = input.charCodeAt(i++);
                    chr3 = input.charCodeAt(i++);
    
                    enc1 = chr1 >> 2;
                    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                    enc4 = chr3 & 63;
    
                    if (isNaN(chr2)) {
                        enc3 = enc4 = 64;
                    } else if (isNaN(chr3)) {
                        enc4 = 64;
                    }
             
                    output += _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
             
                }
                return output;
            },
            
            /**
             * Decode a Base64 encoded string. 
             * @param {String} input A Base64 encoded string value.
             * @type String
             * @return The decoded string
             */
            decode: function (input) {
                var output = "", i = 0;
                var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
                
                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                while (i < input.length) {
                    enc1 = _keyStr.indexOf(input.charAt(i++));
                    enc2 = _keyStr.indexOf(input.charAt(i++));
                    enc3 = _keyStr.indexOf(input.charAt(i++));
                    enc4 = _keyStr.indexOf(input.charAt(i++));
    
                    chr1 = (enc1 << 2) | (enc2 >> 4);
                    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                    chr3 = ((enc3 & 3) << 6) | enc4;
                    
                    output += $SFCC(chr1);
                    
                    if (enc3 != 64) {
                        output += $SFCC(chr2);
                    }
                    if (enc4 != 64) {
                        output += $SFCC(chr3);
                    }
                }
                output = _utf8_decode(output);
                return output;
            }
        }
    ); //end provide()
})();
(function() {
    /**
     * A class to simulate Java StringBuffer class.
     * 
     * @class
     */
    mstrmojo.StringBuffer = mstrmojo.declare(
        null, 
        null,
        /**
         * @lends mstrmojo.StringBuffer.prototype
         */
        {
            scriptClass: 'mstrmojo.StringBuffer',
            
            /**
             * Appends new string into buffer.
             * 
             * @param txt The string to be appended.
             * @return current StringBuffer, so append() can be chained in usage. For example, sb.append('text:').append('3');
             */
            append: function append(txt) {
                if (!this.buf) {
                    this.reset();
                }
                this.buf[++this.len] = txt;
                return this; 
            },
            
            /**
             * Resets current string buffer, which will lose all previous content.
             */
            reset: function reset() {
                this.buf = [];
                this.len = -1;
            }
        }
    );

    /**
     * Returns the string representation of this string buffer.
     */    
    mstrmojo.StringBuffer.prototype.toString = function(sep) {
        var buf = this.buf;
        return (buf && buf.join(sep || '')) || '';         
    }
})();
(function(){

    /**
     * Internal regular expression used to match dynamic tokens in a string template. 
     * @private
     */     
    var _reTOKENS = /\{\@([^\}]+)\}/gm,
        _reLT = /\</gm,
        _reGT = /\>/gm,
        _reNEm = /\S/,
        _regSpecials = ['$','^','=','!',':',
                    '/', '.', '*', '+', '?', '|',
                    '(', ')', '[', ']', '{', '}', '\\'
                  ],
        _reRegEsc = new RegExp(
                '(\\' + _regSpecials.join('|\\') + ')', 'g'
        ),
        _xmlRep = {
                    '&': { k: '&(?!#?\\w+;)', v: '&amp;'},
                    '<'            : '&lt;',
                    '>'            : '&gt;',
                    'u0009'        : '&#x09;',  // tab
                    '\n'           : '&#x0A;',  // line feed
                    '\r'           : '&#x0D;',  // carriage return
                    '"'            : '&quot;'
                    },
       _htmlRep = {
                    '&': { k: '&(?!#?\\w+;)', v: '&amp;'},
                    '<'            : '&lt;',
                    '>'            : '&gt;', 
                    ' '            : '&nbsp;',
                    '\n'           : '<br/>',  // line feed
                    '\r'           : '&nbsp;&nbsp;&nbsp;&nbsp;',  // carriage return  
                    '\''           : '&#039;',
                    '"'            : '&quot;'                    
                    },
       _htmlDecodeRep = {
                    '&amp;'         :'&',
                    '&lt;'		    : '<',
                    '&gt;'          : '>',
                    '&nbsp;'        : ' ',
                    '<br/>'         : '\n',  // line feed
                    '&nbsp;&nbsp;&nbsp;&nbsp;'  : '\r',  // carriage return
                    '&#039;'        : '\'',
                    '&quot;'        : '"'
    };

    /**
     * Internal method to determine the object type.
     * It will return primitive type as of built-in typeof returns.
     * It will return "array" for built-in JavaScript Array and mstrmojo.Arr.
     * It will return "object" for other
     */
    var _typeOf = function (v) {
        if (v == null) {
            return 'null';
        }
        var t = typeof(v);
        if (t != 'object') {
            return t;
        } else {
            if (v.length === undefined) {
                return 'object';
            } else {
                return 'array';
            }
        }
    };
    
    var parseUriOptions = {
        strictMode: false,
        
        key: [ 'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor' ],
        
        q: {
            name: 'queryKey',
            parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        
        parser: {
            strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
            loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
    };        
    
	/**
	 * A static utility class for string operations.
	 * 
	 * @class
	 */
	mstrmojo.string = mstrmojo.provide(
	        
	   "mstrmojo.string",
	   
	   /**
	    * @lends mstrmojo.string
	    */
	   {

		/**
		 * Performs multiple replacement operations on a single string.
		 * 
		 * @param {String} s The string whose values should be replaced.
		 * @param {Object} hash A hash whose property names represent the strings that should be replaced and values represent the strings that should replace them.
		 * 
		 * @returns String
		 */
		multiReplace: function multiReplace(s, hash) {
			if (!s) {
				return '';
			}
			
			var keys = [];
			for (var k in hash) {
			    keys.push(k.k || k); // if has a key defined explicitly, using it
			}
			
			return s.replace(new RegExp(keys.join('|'), 'g'), function ($0) {
				var v = hash[$0];
                return v.v || v;           // return value, if it is defined explicitly
			});
		},
			
		/**
		 * Removes white space from beginning & end of a given string.
		 */		
		trim: function trim(/*String*/ s) {
			return (s && s.replace)? s.replace(/^\s+/, "").replace(/\s+$/, ""):s;
		},

        /**
         * Shortens the supplied text to the supplied length and adds HTML ellipsis (if needed).
         *
         * @param {String} text Header text item.
         * @param {Integer} length The length the text should be shortened to.
         *
         * @returns {String} Modified text.
         */
        ellipsize: function ellipsize(text, length) {
            // Shorten and trim string.
            var shortText = this.trim(text.substr(0, (length || 1) - 1));
    
            // Is shortened string NOT equal to original string?
            if (shortText !== text) {
                // Add ellipsis.
                shortText += '&hellip;';
            }

            return shortText;
        },

        /**
         * Check whether a string is empty
         */
        isEmpty: function isEmpty(v){
            return (v == null) || !(_reNEm.test(v)); // Boolean
        }, 

        regEscape : function regEscape(text){
            return text.replace(_reRegEsc, '\\$1');
        },
        
		/**
		 * Creates an encoded attribute string for an XML element for the value passed.
		 * 
		 * @param {String} v The value of the attribute.
		 * 
		 * @returns {String} The encoded string that can be used as XML attribute.
		 */
		encodeXMLAttribute : function(v) {
			return mstrmojo.string.multiReplace(v, _xmlRep);
		},
		
		encodeHtmlString: function(v) {
	        return mstrmojo.string.multiReplace(v, _htmlRep);
		},
		
		//TQMS 589864
		decodeHtmlString: function(v) {
	        return mstrmojo.string.multiReplace(v, _htmlDecodeRep);
		},
		
		/**
		 * <p>Replace angles brackets in a given string with the HTML equivalents "&lt;" and "&gt;".</p>
         *
		 * <p>Used as a faster substitute for multiReplace.</p>
		 * @param {String} s String to be encoded.
		 * @return {String} The encoded result; if null was provided, null is returned.
		 */
		htmlAngles: function(s){
		  s = String(s);
		  if (s != null) {    // if is not null and not undefined
		      return s.replace(_reLT, '&lt;').replace(_reGT, '&gt;');
		  }
		  return s;
		  
		},
		
        /**
         * <p>Applies a given template string to a given object.</p>
         *
         * <p>This method replaces tokens in the given template with actual property values values from the given 
         * object. The token syntax is assumed to be "{@<prop>}" where <prop> is the name of a property. If the
         * property value is null, the token is replaced by an empty string.</p>
         *
         * @param {String} tmpl The template to be applied.
         * @param {Object} obj The object to which the template is applied.
         *
         * @returns {String} The new string without tokens.
         */
        apply: function apl(tmpl, obj) {
            if (!tmpl) {
                return "";
            }
            return tmpl.replace(
                                _reTOKENS,
                                function tokenRepl(token, prop) {
                                        return (prop in obj && obj[prop] !== null) ? obj[prop] : "";
                                }
                    );
        },
        /**
         * Converts JSON object into its XML representation.
         * 
         * Primitive type of data will be serialized as attribute of the xml node;
         * Object type of data will be serialized as a child node of the current node, with node name the same as the property name;
         * Array type of data will be serialized as a child node of the current node, with the node name the same as the property name,
         * and each item in the array will be serialzied as a child node of the array node, with the node name determined by config.getArrItemName. 
         * 
         * @param (String) nodeName the name of the root node of the XML string
         * @param (Array|Object) jsons An array of JSON objects or a single JSON object. 
         *          When it is an array, the properties of each JSON object will be serialized as root node's attribute or child node.
         * @param (Object) config A config object to help customizing serializing. It can have following properties:
         *          getArrItemName(n,v,i): when an array is encountered, each item in the array will be serialized into a child node. 
         *                                  But what to be used as child node name will be determined by the return value of this function.
         *                                  parameter 'n' is the name of the array property; parameter 'v' is the array; parameter 'i' is the index of the current item.
         *          isSerializable(nodeName, jsons): before json2xml serialize for any property of current node, it will refer to this method to 
         *                                  check whether serialization in json2xml should be performed. If this method returns boolean "true", the regular 
         *                                  serialization will keep going. If this method return boolean 'false', then serialization of this property will be skipped.
         *                                  If an object is returned, then the string value of its 'att' property will be put in as xml attribute for current node,  
         *                                  and the string value of its 'child' property will be put as child node of current node.
         *                                  So, by using this method, caller can customize json2xml to skip serialization of certain nodes, or customize certain node's serialization result.  
         *          convertBoolean: when serialzing boolean properties whether to convert them to integers (-1/0) or not. Default to true
         */
        json2xml: function(/*String*/nodeName, /*Array|Object*/jsons, /*Object*/config){
            if (!(jsons instanceof Array)){
                jsons = [jsons];
            }
           
            var serial = config && config.isSerializable,
                convertBoolean = (config.convertBoolean === false)? false:true;
            
            // serialize jsons
            var att= [],    // array of all attributes for this xml node
                ch = [],    // array of all child nodes for this xml node
                n,          // name of the property
                v,          // value of the property
                t;          // type of the property value
            // loop through all json objects
            for (var ji = 0, jlen = jsons.length; ji < jlen; ji ++) {
                var json = jsons[ji];
                // loop through each property
                for (n in json){
                    // config may have customized serialization for certain node
                    if (serial) {
                        var ret = serial(n, jsons, ji);
                        if (ret !== true){
                            if (ret === false) {    // returned boolean 'false'
                                continue; // skip current property.
                            } else {
                                if (ret.att){       // returned object contains attribute xml
                                    att.push(ret.att);
                                }
                                if (ret.child){     // returned object contains child xml
                                    ch.push(ret.child);
                                }
                                continue;
                            }
                        }
                        // returned true, then keep going with regular serialization
                    }                
                    v = json[n];
                    t = _typeOf(v);
                    switch(t) {
                        case 'array':
                            ch.push('<' + n + '>');     // node for array
                            // loop through each array item
                            for (var i = 0, len = v.length; i < len; i ++){
                                var cn = config.getArrItemName(n,v,i) || i; // child name
                                ch.push(this.json2xml(cn, v[i], config));   // node for each array item
                            }
                            ch.push('</' + n + '>'); // close the array node
                            break;
                        case 'object':
                            ch.push(this.json2xml(n, v, config));
                            break;
                        case 'string':
                            att.push(n + '="' + mstrmojo.string.encodeXMLAttribute(v) + '"'); 
                            break;
                        case 'boolean':
                            att.push(n + '="' + ((convertBoolean)? (v ? '-1': '0'):v) + '"'); 
                            break;
                        case 'null': 
                            if (!config.skipNull) {
                                att.push(n + '="' + config.nullValue + '"');
                            }
                            break;
                        default:
                            att.push(n + '="' + v + '"'); 
                            break;
                    }
                } // end of looping through each property
            } // end of looping through each json objects
            return '<' + nodeName + ' ' + att.join(' ') + '>' + ch.join('') + '</' + nodeName + '>';
        },
        
        escape4HTMLText: function escape4HTMLText(v) {
            if (!v || !v.replace) {
                return v;
            }
            var QUOTE = /\"/gm;
            var QUOTE_ENCODED = '&quot;';
            var AMP = /\&/gm;
            var AMP_ENCODED = '&amp;';
            var LESSTHAN = /\</gm;
            var LESSTHAN_ENCODED = '&lt;';
            var GREATERTHAN = /\>/gm;
            var GREATERTHAN_ENCODED = '&gt;';
            return v.replace(AMP, AMP_ENCODED
                                ).replace(QUOTE, QUOTE_ENCODED
                                ).replace(LESSTHAN, LESSTHAN_ENCODED
                                ).replace(GREATERTHAN, GREATERTHAN_ENCODED);
        },
        
        /**
         * <p>Parses a URI into an object containing it's component parts.</p>
         * 
         * <p>Ported from Steven Levithan's parseURI 1.2.2</p>
         * 
         * <ul>
         *  <li>parseUri 1.2.2</li>
         *  <li>(c) Steven Levithan &lt;stevenlevithan.com&gt;</li>
         *  <li>MIT License</li>
         * </ul>
         * 
         * @param {String} uri The URI to parse.
         * @param {Object} [options] Optional parsing options (will default to standard options).
         * 
         * @returns Object
         * 
         */
        parseUri: function (str, options) {
            options = options || parseUriOptions;
            
            var m = options.parser[((options.strictMode) ? 'strict' : 'loose')].exec(str),
                uri = {},
                i = 14;
            
            while (i--) {
                uri[options.key[i]] = m[i] || '';
            }
            
            uri[options.q.name] = {};
            uri[options.key[12]].replace(options.q.parser, function ($0, $1, $2) {
                if ($1) {
                    uri[options.q.name][$1] = $2;
                }
            });
            
            return uri;
        }

	});
	
})();
(function() {
    mstrmojo._HasTooltip = mstrmojo.provide(
            'mstrmojo._HasTooltip',
            {

            /**
             * <p>The tooltip for this widget.</p>
             * 
             * @type String
             */
            tooltip: '',
            
            /**
             * <p>The rich tooltip for this widget. </p>
             * 
             * It can be a string or a JSON object. If it is a JSON object, it can include the following information:
             *     <ul>
             *         <li>content - the content to put into the rich tooltip. It can be HTML code.</li>
             *         <li>cssClass - the css class to be used for the tooltip</li>
             *         <li>top/left - the position of the tooltip </li>
             *     </ul>
             * If it is a string, then the string will be used as content, and rich tooltip will use its default implemenation 
             * for positioning and css class.
             * 
             * @type String|Object
             */
            richTooltip: null,
            /**
             * <p>The flag to control whether to use the rich tooltip.</p>
             * 
             * When this flag is set to true, then rich tooltip will be used. 
             * If richTooltip is defined, then it will be used. If richTooltip is not defined, then tooltip will be used.
             * 
             * @type Boolean
             */
            useRichTooltip: false,
            /**
             * The node which will listen to mouseover/out event for rich tooltip feature. If this node is null, then the domNode will be used.
             */
            tooltipNode: null,
            /**
             * attaches event listener for onmouseover and onmouseout event for tooltip
             * 
             * @ignore
             */
            postBuildRendering: function() {
                var ret;
                if (this._super) {
                    ret = this._super();
                }
                    
                if (this.useRichTooltip){
                    var d = this.tooltipNode || this.domNode,
                        dom = mstrmojo.dom,
                        ttl = d && d.getAttribute('title');
                    // remove the 'title' on domNode if there is any
                    if (ttl) {
                        d.setAttribute('title', '');
                    }
                    // attach event listeners
                    if (!this._ontooltipover){
                        var id = this.id;
                        this._ontooltipover = function(e) {
                            var me = mstrmojo.all[id];
                            me.showTooltip(e, self);
                        };
                        this._ontooltipout = function(e) {
                            var me = mstrmojo.all[id];
                            me.hideTooltip(e, self);
                        };
                    }
                    dom.attachEvent(d, 'mouseover', this._ontooltipover);
                    dom.attachEvent(d, 'mouseout', this._ontooltipout);
                }
                return ret;
            },
            /**
             * <p>Call back funtion for onmouseover to show rich tooltip.</p>
             */
            showTooltip: function(e, win) {
                mstrmojo.requiresCls("mstrmojo.tooltip");
                mstrmojo.tooltip.open(this, e, win);
            },
            /**
             * <p>Call back function for onmouseout to hide rich tooltip.</p>
             */
            hideTooltip: function(e, win) {
                mstrmojo.requiresCls("mstrmojo.tooltip");
                mstrmojo.tooltip.close();
            },
            /**
             * When unrender, we need to detach the event listerners we attached to DOM node.
             */
            unrender: function(ignoreDom) {
                var d = this.tooltipNode || this.domNode,
                dom = mstrmojo.dom;
                
                if (d && this._ontooltipover){
                    dom.detachEvent(d, 'mouseover', this._ontooltipover);
                }
                if (d && this._ontooltipout) {
                    dom.detachEvent(d, 'mouseout', this._ontooltipout);
                }
                if (this._super) {
                    this._super(ignoreDom);
                }
                
            }
    });
})();
(function () {
    
    /**
     * <p>Returns the value of the requested dimension (in pixels).</p>
     * 
     * <p>For performance, attempts to avoid measuring DOM and instead attempts to use formatting properties; only 
     * measures DOM if no dimension formatting property found.  Supports only formatting properties that are in pixels.</p>
     * 
     * @param {String} d The dimension to measure in initial capital form (Height or Width).
     * @param {mstrmojo.DocSubsection} w The instance of {@link mstrmojo.Widget} to measure.
     * 
     * @returns {Integer} The outer dimension (height or width) of this subsection (in pixels).
     * 
     * TODO: support for other units (inches, percent, auto).
     */
    function measureDimension(d, w) {
        // If no domNode (hasn't rendered) return 0.
        if (!w.domNode) {
            return 0;
        }
        
        // Create a variable to hold the cache name for this dimension.
        var cn = '_fixed' + d;
        
        // If the value is already cached, then return the cache.
        if (w[cn]) {
            return w[cn];
        }
        
        // Get the formatting properties.
        var f = w.getFormats();
        
        // Get the property name for this dimension.
        var p = d.toLowerCase();
        
        // Is the property in the formats?
        if (f && p in f) {
            // Get the value.
            var v = f[p];
            
            // Is it not a %?
            if (v.charAt(v.length - 1) !== '%') {
                // Parse it.
                var px = parseInt(v, 10);
                
                // Is it a number?
                if (!isNaN(px)) {
                    w[cn] = px;
                    return px;
                }
            }
        }
        
        // Measure the value (but don't set cache).
        return (w.domNode['client' + d] || 0);
    }    

    /**
     * <p>A mixin for {@link mstrmojo.Widget}s that can contain Report Services objects (text field, image, line, cross-tab) within them.</p>
     * 
     * <p>This mixin decorates the existing component with extra functionality to return it's height and width.</p>
     * 
     * @class
     * @public
     */
    mstrmojo._ContainsDocObjects =
    /**
     * @lends mstrmojo._ContainsDocObjects#
     */
    {
        /**
         * <p>Returns the inner height of this widgets domNode (in pixels).</p>
         *  
         * @returns Integer 
         */
        height: function height() {
            return measureDimension('Height', this);
        },
        
        /**
         * <p>Returns the inner width of this widgets domNode (in pixels).</p>
         * 
         * @returns Integer 
         */
        width: function width() {
            return measureDimension('Width', this);
        },
        
        /**
         * Calculates the max z-index value from all mstrmojo.DocSubsection children.
         * 
         * @returns Integer
         */
        getMaxZIndex: function getMaxZIndex() {
            var mx = 0;
            mstrmojo.array.forEach(this.children, function (c) {
                mx = Math.max(mx, c.getFormats()['z-index']);
            });
            
            return mx;
        }
    };
})();
(function () {
    
    /**
     * Returns the sum of the supplied dimension for all children.
     * 
     *  @param {HTMLElement} node The dom node for this widget.
     *  @param {String} dim The name of the method to call on the child for this dimension.
     *  @param {mstrmojo.Widget[]} ch The array of child widgets.
     *  
     *  @return Integer
     *  @private
     */
    
    function measureDimension(node, dim, ch) {
        var x = 0,
            i = 0,
            len = (ch && ch.length) || 0;
        
        // If there is no dom node then return 0.
        if (!node || !ch) {
            return x;
        }
        
        // Step through the children and ask each for it's dimension value.
        for (; i < len; i++) {
            x += ch[i][dim]();
        }
        
        // Return the sum.
        return x;
    }
    
    /**
     * @private
     */
    function resolveChildrenToMeasure(ch, count) {
        if (count === undefined || isNaN(count)) {
            return ch;
        }
        
        // TQMS #501685: Guard against undefined children.
        return (ch && [ ch[count - 1] ]);
    }

    /**
     * <p>A mixin for measuring the dimensions of child components.</p>
     * 
     * @class
     * @public
     */
    mstrmojo._CanMeasureChildren = 
        /**
         * @lends mstrmojo._CanMeasureChildren#
         */
        {
            
            /**
             * Returns the sum of the heights of the children of this widget.
             * @param Integer [count=all] An optional number of children to include in the sum.  If omitted, all children will be included.
             * 
             * @returns Integer
             */
            height: function height(count) {
                return measureDimension(this.domNode, 'height', resolveChildrenToMeasure(this.children, count));
            },
            
            /**
             * Returns the sum of the widths of the children of this widget.
             * @param Integer [count=all] An optional number of children to include in the sum.  If omitted, all children will be included.
             * 
             * @returns Integer
             */
            width: function width(count) {
                return measureDimension(this.domNode, 'width', resolveChildrenToMeasure(this.children, count));
            }
            
        };
    
}());
(function(){
    
    /**
     * Static class with utility functions to evaluate or reformat urls. 
     */
    mstrmojo.url = mstrmojo.provide(
    "mstrmojo.url", 
    {
        /**
         * Decides whether the url is an absoluate URL or not
         * @param {String} url the URL string
         * @returns {Boolean} True if the url contains http|ftp|file at the beginning
         */
        isAbsoluteURL: function(url) {
            return /^(http|https|ftp|file):\/\//i.test(url);
        },    
        
        /**
         * Convert the input URL to an absolute URL. If the input URL is already an absolute URL, returns itself.
         * Otherwise, convert the URL into absolute URL. If based url is not presented, insert 'http://' at the beginning of the input URL.
         * @param {String} url The relative URL path
         * @param {String} [baseUrl] The optional base url to convert an relative url to absolute
         * Returns {String} Converted absolute url path  
         */
        getAbsoluteURL: function(url, baseUrl) {
            if(this.isAbsoluteURL(url)) {
                return url;
            } else {
                if(baseUrl) {
                    return baseUrl + (/\/$/.test(baseUrl) ? '' : '/') + url;
                } else {
                    return 'http://' + url;
                }
            }
        }
    });
})();
(function() {
    mstrmojo.BarcodeReader = mstrmojo.provide(
        'mstrmojo.BarcodeReader',
        {
            /**
             * Call backs registered for the pending location request.
             */
            _callback: null,
            _callbackId: 0,
            
            /**
             * Method for JavaScript client to start barcode reading activity
             * 
             */
            readBarcodes: function readBarcodes(params, callback, name, selectedPrompts, displayKeypadView) {
                this._callbackId++;
                var id = '' + this._callbackId;
                this._callback = callback;
                var callbackStr = 'mstrmojo.BarcodeReader.onBarcodeResult';
                if ( params ) {
                    params.blockBegin = 0;
                    params.blockCount = -1;
                    params.serverUrl = mstrApp.getConfiguration().getTaskUrlByProject(mstrApp.getCurrentProjectId());
                    params.sessionState = mstrApp.getSessionState();
                }
               
                mstrMobileApp.readBarcodes(id, name, (params && JSON.stringify(params)) || null, (selectedPrompts && JSON.stringify(selectedPrompts)) || null, displayKeypadView || null, callbackStr);
            },
            
            onBarcodeResult: function onBarcodeResult(id, resCode, value) {
                //Ignore old calls;
                var callback = this._callback;
                if ( id != this._callbackId || (! callback)) {
                    return;
                }
                delete this._callback;
                if ( resCode == -1 ) { //Success
                    callback.success(value);
                } else if ( resCode != 0 ) {//Cancelled
                    callback.failure(value || 'Error reading bare code.');
                }
            }
        }
    );
    //checkLoadingStatus(mstrmojo.BarcodeReader, {});

})();
(function() {
    
    /**
     * <p>A mixin for Report Services with url properties on Mobile devices..</p>
     * 
     * @class
     * @public
     */
    mstrmojo._HasRelativeUrls = 
        /**
         * @lends mstrmojo._HasRelativeUrls#
         */
        {
            _mixinName: 'mstrmojo._HasRelativeUrls', 
            
            /**
             * An array of property names whose values contain URLs.
             * 
             * @type String[]
             */
            relativeUrls: [], 
            
            /**
             * Override to add host URL to the properties in the relativeUrls collection.
             * 
             *  @ignore
             */
            update: function update(node) {
                this._super(node);
                
                var me = this,
                    doc = me.builder.parent,
                    hostUrl = mstrApp.getConfiguration().getHostUrlByProject(mstrApp.getCurrentProjectId());

                // Iterate the collection of URLs to change.
                mstrmojo.array.forEach(this.relativeUrls, function (p) {
                    // Grab the value of this URL property.
                    var url = me[p];
                    
                    // Do we have a URL and does it NOT contain a protocol?
                    if (url && (url.indexOf('://') === -1 && url.indexOf('data:') !== 0)) {
                        // Add the hostUrl value.
                        me[p] = hostUrl + url;
                    }
                });
            }
                
        };
    
})();
(function(){

    /**
     * A utility class to hold common box model operations.
     * 
     * @class
     */
    mstrmojo.boxmodel =
        /**
         * @lends mstrmojo.boxmodel
         */
        {
            /**
             * Do the ranges intersect?
             * 
             */
    		rangeIntersect:	function rangeInt(/*Integer*/ top1, /*Integer*/ bot1, /*Integer*/ top2, /*Integer*/ bot2) {
    	            if (top1 < top2) {
    	            	return top2 <= bot1;
    	            } else if (top1 > top2) {
    	            	return top1 <= bot2;
    	            } else {
    	            	return true;
    	            }
    		},
    		
    		/**
    		 * Converts pixel units to inches.
    		 * 
    		 * @param {mstrmojo.DocModel} di A mstrmojo.DocModel which has properties for zoom factor (zf) and DPI (dpi).
    		 * @param {String|Integer} v The pixel value. 
    		 */
    		px2Inches: function px2Inches(di, v) {
    			// Convert to an integer.
    			v = parseInt(v, 10);
    			
    			// Divide by zoom and dpi (limit to 4 decimals).
    			return parseFloat((v / di.zf / di.dpi).toFixed(4), 10);
    		},
    		
            /**
             * Measures the offsetLeft and offsetTop of one DOM node relative to another.
             */
    		offset: function offst(/*DomNode*/ el, /*DomNode?*/ elLimit) {
    		    var org = el,
    		    	x = 0,
                    y = 0;
                while (el) {
                    x += el.offsetLeft;
                    y += el.offsetTop;
                    el = el.offsetParent;
                    if (el === elLimit) break;
                }
                // Now loop through the ancestors of the element, looking for any that have scrollTop/Left set.
                // Subtract these scrolling values from the total offset. However, we must be sure to stop the loop
                // before we reach document.body, or we'll take document scrolling into account 
                // and end up converting our offset ot winodw coordinates.
                // TQMS 716812 Zhang, Hongchao 20130201
                for (e = org && org.parentNode; e && e != elLimit; e = e.parentNode){
                	if (e.scrollTop) y -= e.scrollTop;
                	if (e.scrollLeft) x -= e.scrollLeft;
                }
                return {left: x, top: y};
    		},
    		
    		/**
    		 * Converts em to pixels. 
    		 * @params {DOMNode} dom The dom node where the relative unit value associated. 
    		 * @params {String} v The em valus string.
    		 * @returns v in pixels
    		 */
    		convert2px: function convert2px(/*DomNode*/dom, /*value*/v) {
    			//check whether the value is already px
    	        if (!/px$/.test(v)) {
    	            var img = document.createElement('img'), pl;
    	            img.style.zIndex = -1;
    	            img.style.left = v;
    	            
    	            dom.appendChild(img);
    	            
    	            //get the pixel value
    	            pl = img.style.pixelLeft;
    	            dom.removeChild(img);
    	            
    	            return pl + 'px';
    	        } else {
    	        	return v;
    	        }
    		}
    	};
})();
(function () {
    /**
     * <p>Determines whether or not to render a section.</p>
     *
     * <p>Section is rendered only if its top y coordinate is above the viewport's bottom and one of the following conditions is met:</p>
     *
     * <ol>
     *     <li>the section is vertical, or</li>
     *     <li>it is a left-most horiz section, or</li>
     *     <li>t is a horiz section directly to the left of the viewport (meaning, its x coordinate is left of the viewport's right edge, and its vertical range intersects the viewport's vertical range).</li>
     * </ol>
     *
     * @param {Integer} x
     * @param {Integer} y
     * @param {Integer} left
     * @param {Integer} right
     * @param {Integer} top
     * @param {Integer} bottom
     * @param {Boolean} orH True if the section is a horizontal section.
     *
     * @private
     * @ignore
     */
    function _shouldRenderSec(x, y, left, right, top, bottom, orH) {
        if (y > bottom) {
            return false;
        }
        return (!orH) ||
            (x === 0) ||
            // TO DO: how can we tell if the section's vertical range intersects the viewport?
            // Do we know the section's height?
            // For now, hack: we assume its height is at most the height of the viewport.
            ((x < right) && (y >= top - (bottom - top)));
    }

    /**
     * <p>Determines whether or not to render a subsection.</p>
     *
     * <p>Subsection is rendered only if its top y coordinate is above the viewport's bottom and one of the following conditions is met:</p>
     * <ol>
     *     <li>the section is vertical, or</li>
     *     <li>it is a horiz section directly to the left of the viewport (meaning, its x coordinate is left of the viewport's right edge, and its vertical range intersects the viewport's vertical range).</li>
     * </ol>
     *
     * @param {mstrmojo.Subsection}
     * @param {Integer} x
     * @param {Integer} y
     * @param {Integer} left
     * @param {Integer} right
     * @param {Integer} top
     * @param {Integer} bottom
     * @param {Boolean} orH True if the section is a horizontal section.
     *
     * @private
     * @ignore
     */
    function _shouldRenderSub(ss, x, y, left, right, top, bottom, orH) {
        if (y > bottom) {
            return false;
        }

        // TO DO: when the subsection height is auto (canShrink/Grow), how can we tell if the vertical range intersects?
        return (!orH) || ((x < right) && (y >= top - ss.height()));
    }

    /**
     * <p>Instructs a given widget (either a section or subsection) to render itself.</p>
     *
     * <p>The widget's renderMode is set to "scroll" before rendering. If requested, the widget is then asked
     * to build its children (without rendering them).  The numChildrenRendered property of the widget and its given parent are updated.</p>
     *
     * @param {mstrmojo.Widget} w The mstrmojo.Widget to render.
     * @param {mstrmojo.Container} parent The widgets parent.
     * @param {Boolean) bBuildCh
     */
    function _fireRender(w, parent, bBuildCh) {
        // By setting the renderMode to 'scroll' we are telling it not to render its children yet.
        w.renderMode = "scroll";
        w.render();
        w.numChildrenRendered = 0;
        parent.numChildrenRendered++;

        // Should we build the widget children, and are children NOT already built?
        if (bBuildCh && !w.builtChildren) {
            w.buildChildren();
        }
    }

    /**
     * Checks if we want to use the scroll buffer while incrementally rendering the document.
     *
     * @return (Integer) Zero for initial rendering and for subsequent scroll renderings - use the defined scroll buffer;
     */
    function getScrollBuffer() {
        return this.useScrollBuffer ? this.scrollBuffer : 0;
    }

    /**
     * <p>A mixin for rendering children as the document is scrolled horizontally and/or vertically.</p>
     *
     * @class
     * @public
     */
    mstrmojo._CanRenderDocOnScroll = mstrmojo.provide(
        "mstrmojo._CanRenderDocOnScroll",
        {
            _mixinName: 'mstrmojo._CanRenderDocOnScroll',

            /**
             * Sets the widget renderMode to "scroll".
             * @type String
             * @ignore
             */
            renderMode: 'scroll',

            /**
             * The scroll buffer allows a buffer of objects to be rendered past the bottom of the scroll position. This allows for content to be pre-rendered as the document is scrolled.
             */
            scrollBuffer: 0,

            /**
             * <p>For non-null renderMode, suppresses the {@link mstrmojo._HasBuilder} code that auto-builds all of a widget's
             * children after that widget is rendered.</p>
             *
             * @ignore
             */
            postBuildRendering: function postBuildRendering() {
                if (this.renderMode === null) {
                    return this._super();
                } else {
                    this.renderChildren();
                    return true;
                }
            },

            /**
             * <p>For non-null renderMode, suppresses the code that auto-renders a child when it is added to this widget.</p>
             *
             * @ignore
             */
            childRenderOnAddCheck: function (children) {
                if (this.renderMode === null) {
                    return this._super(children);
                } else {
                    return false;
                }
            },

            /**
             * <p>Extends the inherited "renderChildren" method to enable this mixin's on-demand rendering system when renderMode is not null.</p>
             *
             * <p>Searches for a scrollbox in this container (or an ancestor thereof) to drive the rendering.
             * If not found, ignores renderMode and defaults to inherited rendering behavior; otherwise if
             * scrollbox found, renders a first block of children and then (possibly) kicks off a thread to
             * handle pending children (if any).</p>
             *
             * @ignore
             */
            renderChildren: function renderChildren() {

                var own;

                if (this.renderMode === "scroll") {
                    // This renderMode requires a scrollbox to drive the rendering. The scrollbox could
                    // belong to this widget, or an ancestor thereof.  Find it.
                    var anc = this;
                    while (anc) {
                        if (anc.scrollboxNode && (anc.scrollboxWidthFixed || anc.scrollboxHeightFixed) && anc.connectScrollbox) {
                            own = anc;
                            break;
                        }
                        anc = anc.parent;
                    }
                }

                // If rendering on scroll is turned off, or we don't have a scrollbox to drive the rendering,
                // then we must fall back to the inherited default rendering behavior.
                if ((this.renderMode !== "scroll") || !own) {
                    this._super();
                    return;
                }

                if (this.containerNode) {
                    // We have a scrollbox to drive this rendering, and we have a slot for rendering children.
                    // Wire up its scroll events to our onscroll handler.
                    this.scrollboxOwner = own;
                    own.connectScrollbox(this);

                    // Record how many children we have.
                    this.numChildrenRendered = 0;
                    var len = this.numChildren;
                    if (len === undefined) {
                        // Ask the model for the total count of children to be built.
                        this.numChildren = len = this._getModelChildNodes(this.node, false, 0, 0, true).total;
                    }

                    // Performance optimization: Keep track of how many sections & subsections have not
                    // been rendered yet.
                    this.sectionsToRender = len;
                    this.subsectionsToRender = 0;

                    // If we have children (either already built or not), let's start rendering them.
                    if (len) {
                        this._startSubsectionThread(false);
                    }
                }
                if (this.resizeOrReposition) {
                    this.resizeOrReposition();
                }
            },

            /**
             * <p>This handler is notified whenever a scroll event is heard from the scrollbox DOM node that is
             * driving this on-demand rendering.</p>
             *
             * <p>It responds by triggering on-demand rendering, if it is not already in progress.</p>
             */
            onscroll: function onscroll() {
                if (!this.renderingSubsections) {
                    //Set a flag to render up to the extra scroll buffer.
                    this.useScrollBuffer = true;

                    this._startSubsectionThread(true);
                }
            },

            /**
             * <p>Fires intervals for rendering.</p>
             *
             * @private
             */
            _startSubsectionThread: function _stSbsThd(/*Boolean*/ bPauseBeforeCtls) {
                // Reference to this for inner functions.
                var me = this;

                // Utility function for clearing an interval or timeout (including the property that contains the handle).
                var fnClearIntv = function (n, bIsTimeout) {
                    if (me[n]) {
                        if (bIsTimeout) {
                            self.clearTimeout(me[n]);
                        } else {
                            self.clearInterval(me[n]);
                        }
                        delete me[n];
                    }
                };

                // Post-processing to be done after the subsections interval has completed.
                // This function will trigger the rendering of the controls within the viewport.
                var fnCleanUp = function (/*Boolean*/ bPause) {
                    me.renderingSubsections = false;
                    var fn = function () {
                            fnClearIntv('renderCtlsTimer');
                            me.showRenderStatus(false);
                            me.renderCtrlsInViewport();
                            //TQMS 490160 For touch scrollers we need to update scroller after incremental rendering as real document size
                            //can change
                            me.raiseEvent({name: 'afterScroll'});
                            me = null;
                        };
                    if (bPause) {
                        me.renderCtlsTimer = self.setTimeout(
                            fn,
                            me.scrollboxOwner.scrollInterval + 1
                        );
                    } else {
                        fn();
                    }
                };

                // If a previous interval or timeout was in progress, kill it first.
                fnClearIntv('renderSubsTimer');
                fnClearIntv('renderCtlsTimer', true);

                this.renderingSubsections = true;

                // Performance optimization: if all sections and subsections are rendered,
                // don't bother walking them; just process the controls.
                if ((this.sectionsToRender || this.subsectionsToRender) && !this._renderSubsectionsToScroll()) {
                    this.showRenderStatus(true);
                    this.renderSubsTimer = self.setInterval(
                        function () {
                            if (me._renderSubsectionsToScroll()) {
                                fnClearIntv('renderSubsTimer');
                                fnCleanUp(bPauseBeforeCtls);
                            } else {
                                me.showRenderStatus(true);
                            }
                        },
                        this.scrollboxOwner.scrollInterval
                    );
                } else {

                    fnCleanUp(bPauseBeforeCtls);
                }
            },

            /**
             * <p>Toggles a GUI to indicate progress of rendering.</p>
             *
             * <p>This implemented by calling a method of the parent, which actually owns the status GUI.  This method simply
             * passes along status data to that GUI in the parent (if any).</p>
             *
             * @param {Boolean} show Whether to show the rendering status message.
             * @param {String} msg The message to display.  Note: this message will be overridden with rendering progress if 'show' parameter was true.
             */
            showRenderStatus: function shwRndrSts(show, msg) {
                var p = this.parent;
                if (!p || !p.showStatus) {
                    return;
                }

                var txt = msg,
                    per;
                if (show) {
                    // Show render status indicator (if any).
                    var num = this.numChildrenRendered,
                        tot = this.numChildren;

                    per = tot && parseInt(100 * num / tot, 10);
                    txt = "*Rendering section " + num + " of " + tot + ".*";    // TODO: Need descriptor.
                }
                p.showStatus(show, txt, per);
            },

            /**
             * <p>Steps through sections and subsections and renders them if they are visible within the scrollbox.</p>
             *
             * @type Boolean
             * @private
             * @returns True if all subsections above (or to the left) of the scroll bottom (or right) are rendered.
             */
            _renderSubsectionsToScroll: function rndSubs2Scll() {
                var own = this.scrollboxOwner,
                    top = own.scrollboxTop,
                    left = own.scrollboxLeft,
                    bottom = own.scrollboxBottom + getScrollBuffer.call(this),
                    right = own.scrollboxRight,
                    height = bottom - top,
                    x = 0,
                    y = 0,
                    yStart = null,
                    yStop = null,
                    forcedH, sidx;

                // Utility that records the y coordinate we started rendering at.
                function _updateStart() {
                    yStart = y;
                    yStop = yStart + height;
                }

                var secsCount = this.numChildren,
                    secs = this.children || [],
                    model = this.model,
                    node = this.node,
                    orH = false;        // Boolean to indicate if the current section is horizontal.

                // Step through all sections.
                for (sidx = 0; sidx < secsCount; sidx++) {

                    // Inspect the next section.
                    var sec = secs[sidx];
                    if (!sec) {
                        // The next section has not been built yet; build it now.
                        sec = this.addChildren(this.builder.build(
                            this._getModelChildNodes(node, false, sidx, 1, true).nodes,
                            model
                        ))[0];
                        // Refresh handle to children array in case the addChildren() call reset the object reference.
                        secs = this.children || [];
                    }

                    // Cache the old orientation.
                    var orWas = orH;

                    // Is it a horizontal section?
                    orH = !!sec.defn.horiz;

                    //Forcing the render of a new horizontal group if the section is marked as the
                    //begining of an horizontal section and it is not the first section.
                    forcedH = (sidx > 0 && sec.node.data.bh);

                    // Is it the first vertical section following a group of horiz sections?
                    //Or is it a new group of horizontal sections after another horizontal section?
                    if ((!orH && orWas) || (forcedH && orWas)) {
                        // Reset the horizontal coordinate.
                        x = 0;

                        // Increment the y coordinate by the previous section's height.
                        y += secs[sidx - 1].height();

                        // Should we stop rendering now?
                        if (y > bottom) {
                            // We've reached the bottom of the viewport, so our walk is done.
                            return true;

                        } else if ((yStop !== null) && (y > yStop)) {
                            // We haven't reached the bottom of the viewport, so our walk is not done,
                            // but we've reached our rendering limit, so we must abort and exit incomplete.
                            return false;
                        }
                    }

                    // It's not below the viewport. Is it not rendered yet?
                    if (!sec.hasRendered) {
                        // Should we render it now?
                        if (!_shouldRenderSec(x, y, left, right, top, bottom, orH)) {
                            // We should not render.  Skip or abort walk altogether?
                            if (orH) {
                                // Section is horiz, so continue to next section (which may be vertical or horiz).
                                continue;
                            } else {
                                // Section is vert, so we are done walking.
                                return true;
                            }
                        }

                        this._renderSection(sec, sidx);

                        this.sectionsToRender--;
                        this.subsectionsToRender += (sec.children && sec.children.length) || 0;

                        // If this is our first render, record the y coordinate we began rendering at.
                        if (yStart === null) {
                            _updateStart();
                        }
                    }

                    // Section has been rendered. Walk the section's subsections.
                    var ssch = sec.children || [],
                        ss = null,
                        ssidx, sslen;

                    for (ssidx = 0, sslen = ssch.length; ssidx < sslen; ssidx++) {
                        // Cache the subsection.
                        ss = ssch[ssidx];
                        // Is the subsection not yet rendered?
                        if (!ss.hasRendered) {
                            if (!_shouldRenderSub(ss, x, y, left, right, top, bottom, orH)) {
                                // Should not render it.  Skip remaining subsections in this section, or abort walk altogether?
                                if (orH) {
                                    // Horiz subsection. Stop walking subsections, move on to next section (possibly vertical).
                                    break;
                                } else {
                                    // Vert subsection. We are done with our walk.
                                    return true;
                                }
                            }
                            // Render the subsection now.
                            _fireRender(ss, sec);
                            this.subsectionsToRender--;
                            // If this is our first render, record the y coordinate we began rendering at.
                            if (yStart === null) {
                                _updateStart();
                            }
                        }
                        // Subsection is rendered.
                        // Increment our coordinate by the subsection's size,
                        // and check if we should continue rendering.
                        if (orH) {
                            x += ss.width();
                            // If we've reached the right edge of the viewport, stop walking these subsections
                            // and continue to the next section (which may be vertical).
                            if (x > right) {
                                break;
                            }
                        } else {
                            y += ss.height();
                            // Should we stop rendering now?
                            if (y > bottom) {
                                // We've reached the bottom of the viewport, so our walk is done.
                                return true;
                            } else if ((yStop !== null) && (y > yStop)) {
                                // We haven't reached the bottom of the viewport, so our walk is not done,
                                // but we've reached our rendering limit, so we must abort and exit incomplete.
                                return false;
                            }
                        }
                    }    // end for-loop walk of subsections
                } // end for-loop walk for sections

                // We've finished our walk, we are done for these viewport coordinates.
                return true;
            },

            _renderSection: function _renderSection(sec, sidx) {
                // Render the section now, and ask it to build (but not render) its children so we can inspect their sizes.
                _fireRender(sec, this, true);
            },

            /**
             * Returns children nodes from model. Default would return all child nodes.
             */
            _getModelChildNodes: function (node, isPartial, start, count, includeTotal) {
                return this.model.getChildren(node, isPartial, start, count, includeTotal);
            },
            /**
             * Renders any controls inside subsections that are within the current viewport that haven't rendered yet.
             *
             */
            renderCtrlsInViewport: function rnCtlsInVw() {
                var own = this.scrollboxOwner,
                    top = own.scrollboxTop,
                    left = own.scrollboxLeft,
                    bottom = own.scrollboxBottom + getScrollBuffer.call(this),
                    right = own.scrollboxRight,
                    x = 0,
                    y = 0,
                    orH = false,
                    secs = this.children || [],
                    orWas,
                    forcedH, sidx, secCount;

                /**
                 * Utility function for updating height or width.
                 *
                 * @param {mstrmojo.Subsection} ss The subsection to be measured.
                 *
                 * @inner
                 * @ignore
                 */
                var fnIncSize = function (ss) {
                    if (orH) {
                        x += ss.width();
                    } else {
                        y += ss.height();
                    }
                };

                /**
                 * Determines if the given control intersects with the part of the subsection that is visible in the viewport.
                 *
                 * @param {Integer} s The beginning point of the subsection (left or top).
                 * @param {String} cx The start point of the control in pixels (left or top).
                 * @param {String} cs The size of the control in pixels (height or width).
                 * @param {Integer} vs The start point of the view port (left or top).
                 * @param {Integer} ve The ending point of the view port (right or bottom).
                 *
                 * @inner
                 * @ignore
                 * @refactoring This function assumes the controls values are in pixels.  We need to look into supporting inches.
                 */
                var fnCtlInt = function (s, cx, cs, vs, ve) {
                    // Convert control properties to integers.
                    cx = parseInt(cx, 10) || 0;
                    cs = parseInt(cs, 10);

                    return (isNaN(cs)) ? (s + cx <= ve) : mstrmojo.boxmodel.rangeIntersect(s + cx, s + cx + cs, vs, ve);
                };

                // Walk the subsections, looking for those within the vertical scroll range of the viewport.
                for (sidx = 0, secCount = (secs && secs.length) || 0; sidx < secCount; sidx++) {
                    var sec = secs[sidx];
                    // Cache the old orientation.
                    orWas = orH;

                    // Is it a horizontal section?
                    orH = !!sec.defn.horiz;

                    //Forcing the render of a new horizontal group if the section is marked as the
                    //begining of an horizontal section and it is not the first section.
                    forcedH = (sidx > 0 && sec.node.data.bh);

                    // Is it the first vertical section following a group of horiz sections?
                    //Or is it a new group of horizontal sections after another horizontal section?
                    if ((!orH && orWas) || (forcedH && orWas)) {
                        // Reset the horizontal coordinate.
                        x = 0;
                        // Increment the y coordinate by the previous section's height.
                        y += secs[sidx - 1].height();
                        // Should we stop rendering now?
                        if (y > bottom) {
                            // We've reached the bottom of the viewport, so our walk is done.
                            return;
                        }
                    }

                    // Is this section rendered? If not, assume it is beyond the viewport.
                    if (!sec.hasRendered) {
                        if (!orH) {
                            return;    // Vertical. Must be too low; we are done rendering.
                        } else {
                            continue;    // Horizontal. Must be too far right; continue on to next section.
                        }
                    }
                    // Section is rendered. Is this a vertical section?
                    var subs = sec.children,
                        ssCount = (subs && subs.length) || 0,
                        ssidx,
                        ss;

                    //  Walk across the subsections, checking each's vertical & horiz range.
                    for (ssidx = 0; ssidx < ssCount; ssidx++) {
                        ss = subs[ssidx];
                        if (!ss.hasRendered) {
                            break;    // Must be beyond range; move on to next section.
                        }

                        // Have all the controls been rendered yet?
                        if (ss.builtChildren && (ss.numChildrenRendered === ((ss.children && ss.children.length) || 0))) {
                            // All children rendered.  Increment move on to next subsection.
                            fnIncSize(ss);

                        } else {
                            // Does the subsection intersect the viewport's range?
                            if ((y + ss.height() >= top) && (!orH || (x + ss.width() >= left))) {

                                // If the subsection's children have not been built yet, built them now.
                                var chdn = ss.children,
                                    chLen = (chdn && chdn.length) || 0;

                                if (!chLen && !ss.builtChildren) {
                                    ss.buildChildren();
                                    chdn = ss.children;    // Reset children collection...
                                    chLen = (chdn && chdn.length) || 0; // and length.
                                }

                                // Collection of children that are being rendered now.
                                var rc = [],
                                    i;

                                // Walk the children, searching for unrendered controls that intersect the viewport.
                                for (i = 0; i < chLen; i++) {
                                    var c = chdn[i];
                                    if (c.hasRendered) {
                                        continue;
                                    }

                                    var cf = c.getFormats() || {};
                                    // Does the control intersect both horizontally and vertically?
                                    if (fnCtlInt(y, cf.top, cf.height, top, bottom) && fnCtlInt(x, cf.left, cf.width, left, right)) {
                                        c.render();
                                        rc.push(c);
                                    }
                                }

                                // Tell the subsection to do CanGrow/CanShrink for the rendered controls.
                                ss.performCanGrowCanShrink(rc, true);
                            }

                            // Increment x coord and move on to next subsection.
                            fnIncSize(ss);
                        }

                        if ((orH && x > right) || (!orH && y > bottom)) {
                            break;    // Too far; move on to next section.
                        }
                    }
                }
            },

            /**
             * Extends the inherited method in order to disconnect from the scrollbox that
             * was connected in the renderChildren method.
             */
            unrender: function unrdr(ignoreDom) {
                var own = this.scrollboxOwner;
                if (own) {
                    own.disconnectScrollbox(this);
                }
                this._super(ignoreDom);
            }
        }
    );
}());
(function(){

    var DEFAULT_COLOR = "#000000";
        
    /**
     * A utility class for color conversion.
     * 
     * @class
     */
    mstrmojo.color = mstrmojo.provide(
        "mstrmojo.color",
        
        /**
         * @lends mstrmojo.color
         */
        {
            
             
            hexChars: '0123456789ABCDEF',

            /**
             * Converts a decimal value to a hexidecimal value.
             * @param {Integer} n The decimal value.
             * @type String
             * @return The hexidecimal value (without the hash).
             */
            toHex: function C_toHex(n) {
                n = n || 0;
                n = Math.max(Math.min(isNaN(n) ? 0 : parseInt(n, 10), 255), 0);
        
                return this.hexChars.charAt((n - n % 16) / 16)
                        + this.hexChars.charAt(n % 16);
            },

            toDec: function C_toDec(h) {
                return this.hexChars.indexOf(h.toUpperCase());
            },

            /**
             * Converts Mozilla's color string 'rgb(0, 120, 255)' to an Integer array of red, green and blue. 
             * @param {String} color The Mozilla color string to convert.
             * @type Integer[]
             * @return An Integer array of red, green and blue values.
             */
            rgbStr2rgb: function C_rgbStr2rgb(color) {
                var rgb = [ 0, 0, 0 ];
                color = color.replace(/ /g, ''); //get rid of the possible blank space
                var i = color.indexOf('rgb');
                if (i >= 0) {
                    color = color.substring(i + 4, color.length - 1);
                    rgb = color.split(',');
                }
                return rgb;
            },

            /**
             * Converts an RGB color string value like 'rgb(0, 120, 255)' to a hexidecimal color string value.
             * @param {String} color The RBG color value.
             * @type String
             * @return The hexidecimal color value.
             */
            rgbStr2hex: function C_rgbStr2hex(color) {
                //only when color is in rgb(r,g,b) format
                if (color.indexOf('rgb') >= 0) {
                    var rgb = this.rgbStr2rgb(color);
                    return "#" + this.rgb2hex(rgb[0], rgb[1], rgb[2]);
                }
                return color;
            },

            rgb2hex: function C_rgb2hex(r, g, b) {
                return this.toHex(r) + this.toHex(g)
                        + this.toHex(b);
            },

            rgb2hsv: function C_rgb2hsv(r, g, b) {
                var rgb = [ r, g, b ];
                rgb.sort( function(a, b) {
                    return a - b;
                });
        
                var h, s, v = 0;
                var min = rgb[0];
                var max = rgb[2];
        
                v = max / 255.0;
                s = (max != 0) ? (parseFloat(max) - parseFloat(min)) / parseFloat(max)
                        : 0;
        
                if (s == 0) {
                    h = 0;
                } else {
                    var d = max - min;
                    var red = (max - r) / d;
                    var green = (max - g) / d;
                    var blue = (max - b) / d;
        
                    if (r == max)
                        h = blue - green;
                    else if (g == max)
                        h = 2.0 + red - blue;
                    else
                        h = 4.0 + green - red;
        
                    h = h / 6.0;
                    if (h < 0)
                        h = h + 1.0;
                }
        
                return [ Math.round(h * 360), Math.round(s * 100), Math.round(v * 100) ];
            },

            hex2rgb: function C_hex2rgb(s) {
                var color = (s.charAt(0) == '#') ? s.substr(1) : s;
                var l = color.length !== 3;
                var rgb = [ 0, 0, 0 ];
                if (l) {
                    rgb[0] = (this.toDec(color.substr(0, 1)) * 16)
                            + (this.toDec(color.substr(1, 1)));
                    rgb[1] = (this.toDec(color.substr(2, 1)) * 16)
                            + (this.toDec(color.substr(3, 1)));
                    rgb[2] = (this.toDec(color.substr(4, 1)) * 16)
                            + (this.toDec(color.substr(5, 1)));
                } else {
                    rgb[0] = (this.toDec(color.substr(0, 1)) * 16)
        	            + (this.toDec(color.substr(0, 1)));
                    rgb[1] = (this.toDec(color.substr(1, 1)) * 16)
                	    + (this.toDec(color.substr(1, 1)));
                    rgb[2] = (this.toDec(color.substr(2, 1)) * 16)
        		    + (this.toDec(color.substr(2, 1)));
	     }        
                return rgb;
            },

            hex2hsv: function (s) {
                var rgb = this.hex2rgb(s);
                return this.rgb2hsv(rgb[0], rgb[1], rgb[2]);
            },

            hsv2rgb: function (h, s, v) {
                h = h / 360;
                s = s / 100;
                v = v / 100;
        
                var r, g, b;
                if (s == 0) {
                    r = v * 255;
                    g = v * 255;
                    b = v * 255;
                } else {
                    var th = h * 6;
                    if (th == 6)
                        th = 0;
        
                    var i = Math.floor(th);
                    var p = v * (1 - s);
                    var q = v * (1 - s * (th - i));
                    var t = v * (1 - s * (1 - (th - i)));
        
                    var tr, tg, tb;
        
                    switch (i) {
                    case 0:
                        tr = v;
                        tg = t;
                        tb = p;
                        break;
        
                    case 1:
                        tr = q;
                        tg = v;
                        tb = p;
                        break;
        
                    case 2:
                        tr = p;
                        tg = v;
                        tb = t;
                        break;
        
                    case 3:
                        tr = p;
                        tg = q;
                        tb = v;
                        break;
        
                    case 4:
                        tr = t;
                        tg = p;
                        tb = v;
                        break;
        
                    default:
                        tr = v;
                        tg = p;
                        tb = q;
                        break;
                    }
        
                    r = tr * 255;
                    g = tg * 255;
                    b = tb * 255;
                }
                return [ Math.round(r), Math.round(g), Math.round(b) ];
        
            },

            hsv2hex: function (h, s, v) {
                var rgb = this.hsv2rgb(h, s, v);
                return this.rgb2hex(rgb[0], rgb[1], rgb[2]);
            },
            
            getContrastingColor : function C_getContrastingColor(hex, colors) {
                var rgb = this.hex2rgb(hex);
                return (((rgb[0] * 299) + (rgb[1] * 587) + (rgb[2] * 114)) / 1000 < 125) ? colors[0] : colors[1];
            },
            
            getHighlightColor: function C_getHighlightColor(rgb, moreDim) {
                var r, g, b, luminosity,
                    refRGB = this.hex2rgb(!moreDim ? '#FFCE7F' : '#EFE6D8'),
                    R1 = parseInt(rgb[0], 10),
                    G1 = parseInt(rgb[1], 10),
                    B1 = parseInt(rgb[2], 10),
                    R2 = parseInt(refRGB[0], 10),
                    G2 = parseInt(refRGB[1], 10),
                    B2 = parseInt(refRGB[2], 10);
                
                    r = (R1 * R2) / 255;
                    g = (G1 * G2) / 255;
                    b = (B1 * B2) / 255;
                    
                    luminosity = R1 * 0.3 + G1 * 0.59 + B1 * 0.11;
                    if (luminosity < 85) {
                        r = r + (63 * (85 - luminosity) / 85); 
                        r = r > 255 ? 255 : r;
                        g = g + (63 * (85 - luminosity) / 85); 
                        g = g > 255 ? 255 : g;
                        b = b + (63 * (85 - luminosity) / 85); 
                        b = b > 255 ? 255 : b;
                    }

                return "#" + this.rgb2hex(Math.round(r), Math.round(g), Math.round(b));
            },
            
            /**
             * Calculates the light color component for 3d borders.
             * @param {Integer[]} rgbColor An array of rgb component colors.
             * @param Integer luminosityColor The luminosity value for the supplied color.
             * @type String
             * @return The hexidecimal value for the light color component.
             * @refactoring This method is only called twice and it's always in conjunction with handed into {@link calculateLuminosity} and {@link calculateDarkColor}.  We should refactor 
             *      all three methods into one and move it to mstr.utils.Color.
             */
            get3DBorderColor: function C_get3DBorderColor(bgRGB, stroke) {
                var lum = parseInt(bgRGB[0],10) * 0.3 + parseInt(bgRGB[1],10) * 0.59
                    + parseInt(bgRGB[2],10) * 0.11;

                var r = parseInt(bgRGB[0],10);
                var g = parseInt(bgRGB[1],10);
                var b = parseInt(bgRGB[2],10);

                switch (stroke) {
                case 'light': //light border color
                    if (lum > 150) {
                        r = r * 0.9;
                        g = g * 0.9;
                        b = b * 0.9;
                    } else {
                        r = r * 0.6 + 102;
                        g = g * 0.6 + 102;
                        b = b * 0.6 + 102;
                    }
                    break;
                case 'dark': //dark border color
                    if (lum > 10) {
                        r = r * 0.4;
                        g = g * 0.4;
                        b = b * 0.4;
                    } else {
                        r = r * 0.8 + 30;
                        g = g * 0.8 + 30;
                        b = b * 0.8 + 30;
                    }
                }

                return "#" + this.rgb2hex(Math.round(r), Math.round(g), Math.round(b));
            },
            
            
            /**
             * <p>Convert Hex color into VB style Decimal required by backend.</p>
             * <li> - first convert #RRGGBB into #BBGGRR </li>
             * <li> - second convert BBGGRR into decimal </Li>
             * 
             * @param {String} v Hex color
             */
            encodeColor: function (v, d) { 
                    if (d != undefined && (v == null || v.length == 0 || v == 'undefined')) {
                        v = d;
                    }
                    if (v == 'transparent') {
                        return -1;
                    } else if (v == -2) {
                        return -2;
                    } else {
                        //remove prefix
                        if (v.substring(0,1) == '#') {
                            v = v.substring(1);
                        }
                        
                        //switch RR with BB and get the decimal value
                        return parseInt(v.substring(4) + v.substring(2,4) + v.substring(0,2), 16); 
                    }
            },
            
            /**
             * <p>Convert VB color from backend into RGB </p> 
             * <pre>
             *   Here is the spec for color in CSS2
             *      EM { color: #f00 }              // #rgb 
             *      EM { color: #ff0000 }           // #rrggbb 
             *      EM { color: rgb(255,0,0) }      // integer range 0 - 255 
             *      EM { color: rgb(100%, 0%, 0%) } // float range 0.0% - 100.0% 
             *   so we have this function to transform the color to #rrggbb style.
             *   current assumption is backend will give me a hexadecimal representation of the color
             *   in VB color in BBGGRR format in hexadecimal, and the value we get from backend is in decimal,
             *   so this function will convert decimal VB color to CSS2 color.
             *   anything wrong in converting, return black color "000000".
             * </p>       
             * @param {Integer} vbColor VB style color value in decimal.
             * @return {String} RGB color
             */
            decodeColor: function(vbColor) {
                var color = parseInt(vbColor, 10);
                
                if (color == 0) {
                    return  DEFAULT_COLOR;
                } 

                //get rgb color in decimal
                var rgb = 0x1000000 + (color & 0xff) * 0x10000 + (color & 0xff00) + (color & 0xff0000) / 0x10000;
                
                //convert to Hex string
                return '#' + rgb.toString(16).substring(1).toUpperCase();
            }
            
        }
    ); //end provide()

 })();
mstrmojo.android.EnumMenuOptions = mstrmojo.provide(
    "mstrmojo.android.EnumMenuOptions",

    {
        // Default menu options must be bitwise
        HOME: 1,
        SETTINGS: 2,
        HELP: 4,
        LEARN: 8,

        ALL: 255,    // constant that contains all default menu options enabled

        // End defalt menu options

        // Other options don't need to be bitwise but they must not contains default option bits
        // i.e. the last two digits must always be "00"
        
        REFRESH:               0x0100,
        FULL_SCREEN:           0x0200,
        GROUP_BY:              0x0300,
        PAGE_BY:               0x0400,
        REPROMPT:              0x0500,
        DELETE:                0x0600,
        SEARCH:                0x0700,
        SCAN:                  0x0800,
        MAP_ROADMAP:           0x0900,
        MAP_SAT:               0x0A00,
        MAP_HYBRID:            0x0B00,
        MAP_TERRAIN:           0x0C00,
        DOC_LAYOUTS:           0x0D00,
        TRANSACTIONS_QUEUE:    0x0E00,
        ADD_SERVER:            0x0F00,
        ADD_PROJECT:           0x1000,
        ABOUT:                 0x1100,
        SHARE:                 0x1200,
        ABOUT_RESULTSET:       0x1300,
        ANNOTATION:			   0x1400
    }
);
(function() {
    
    /**
     * <p>A mixin for widgets that contain a widget with a scrollbox.</p>
     * 
     * @class
     * @public
     */
    mstrmojo._IsSelectorTarget = 
        /**
         * @lends mstrmojo._IsSelectorTarget#
         */
        {
            _mixinName: 'mstrmojo._IsSelectorTarget', 
            
            /**
             * Notifies the parent widget that this widget is dirty (or clean) due to a slice operation.
             * 
             * @param {Boolean} isDirty Indicates whether this widget is dirty (true) or clean (false).
             */
            setDirty: function setDirty(isDirty) {
                // If isDirty then add this key to the parents collection of dirty keys, otherwise, remove it.
                var mth = ((isDirty) ? 'add' : 'remove') + 'DirtyKey';
                if (this.parent && this.parent[mth]) {
                    this.parent[mth](this.k);
                }
            }
                
        };
    
})();
(function(){
    
    /**
     * <p>Static class with helper methods for using hash objects.</p>
     * 
     * @class
     */
    mstrmojo.hash = mstrmojo.provide(
    "mstrmojo.hash",
    {
        /**
         * <p>Copies all of the members of a given source hash to another given destination hash.</p>
         * 
         * <p>Any existing members in the destination whose names conflict will be overwritten.</p>
         * 
         * @param {Object} src The source object whose properties/values should be copied.
         * @param {Object} [dest] An optional hash to receive the copied properties/values.  If this parameter is undefined, an empty hash will be used. 
         * 
         * @returns {Object} The modified destination hash.
         */
        copy: function copy(src, dest) {
            if (src) {
                dest = dest || {};

                for (var n in src) {
                    dest[n] = src[n];
                }
            }
            return dest;
        },

        /**
         * <p>Copies an enumerated list of members of a given source hash to another given destination hash.</p>
         *
         * <p>Any existing members in the destination whose names conflict will be overwritten.  Only overwrites the value if the property is present in the source hash.</p>
         * 
         * @param {String[]} ns An array of property names to be copied.
         * @param {Object} src The hash from which the property values should be copied.
         * @param {Objecct} [dest={}] An optional hash to which the property values should be copied.  If this parameter is undefined, an empty hash will be used. 
         * 
         * @returns Object The modified destination hash.
         */
        copyProps: function copyProps(ns, src, dest) {
            // If dest is not there create one.
            dest = dest || {};
            
            if (src) {
                // Iterate properties.
                for (var i = 0, len = (ns && ns.length) || 0; i < len; i++) {
                    var n = ns[i];
                    // Does the property exist in the source hash?
                    if (n in src) {
                        // Overwrite the property value in the destination hash.
                        dest[n] = src[n];
                    }
                }
            }
            return dest;
        },
        
        /**
         * <p>Iterates the supplied hash and calls the supplied function once for each item in the hash.</p>
         * 
         * <p>The function is passed three parameters:</p>
         * 
         * <ol>
         *  <li>The member value</li>
         *  <li>The member key</li>
         *  <li>The hash itself</li>
         * </ol>

         * @param {Object} hash The hash to be iterated.
         * @param {Function} f The function to be run for each iteration.
         * @param {Object} [scope=f] An optional scope for the passed function.
         */
        forEach: function forEach(hash, f, scope) {
            if (hash) {
                for (var key in hash) {
                    if (scope) {
                        if (f.call(scope, hash[key], key, hash) === false) {
                            break;
                        }
                    } else {
                        if (f(hash[key], key, hash) === false) {
                            break;
                        }
                    }
                }
            }
        },
        
        /**
         * <p>Walks a given path of property names, starting with a context object.  If no context is given, the global context is assumed.</p>
         * 
         * @param {String} path The path to be walked.
         * @param {Object} context The object to be walked.
         * 
         * @returns {Object} The resolved path within the supplied context.
         */
        walk: function walk(path, context) {
            if (!context) {
                context = mstrmojo.global;
            }
            var parts = path.split('.');
            if (parts.length == 1) {
                return context[path];
            }
            for (var i=0, len=parts && parts.length || 0; i<len; i++) {
                context = context[parts[i]];
                if (!context) {
                    break;
                }
            }
            return context;
        },
        
        /**
         * <p>Returns true if a given hash either:</p>
         * 
         *  <ol>
         *      <li>is null or</li>
         *      <li>has no non-null property values.</li>
         *  </ol>
         *  
         *  @param {Object} hash The hash object to evaluate.
         *  
         *  @return {Boolean}
         */
        isEmpty: function(/*Object?*/ hash) {
            if (!hash) {
                return true;
            }
            for (var k in hash) {
                if (hash[k] != null) {  // is not null and not undefined
                    return false;
                }
            }
            return true;
        },
        
        /**
         * <p>Removes all the properties of a given hashtable.</p>
         * @param {Object} h The hashtable.
         * @return {Object} The given hashtable.
         */
        clear: function clr(h){
            if (h) {
                for (var k in h){
                    delete h[k];
                }
            }
            return h;
        },
        
        /**
         * <p>Returns any (the first) property value encountered in a given hash if any; <i>undefined</i> otherwise.</p>
         *  
         * <p>Similar in concept to reading the first item in an array, however no order is guaranteed for a hash's properties.</p>
         * 
         * @param {Object} hash The hash to examine.
         * @param {Boolean} keyOrValue Whether to look for the key (true) or the value (undefined|false).
         * 
         * @returns {String|Integer|Object} Either the key, the value or <i>undefined</i>.
         */
        any: function(/*Object?*/ hash, /*Boolean?*/ keyOrValue) {
            if (hash) {
                for (var k in hash) {
                    return keyOrValue ? k : hash[k];
                }
            }
            return undefined;
        },

        /**
         * <p>Creates a deep clone of a given hash (or array), meaning that any contained hash object (or arrays) are also cloned.</p>
         * 
         * @param {Object|Array} obj The object (or array) to be cloned.
         * 
         * @returns {Object|Array} The cloned object (or array).
         */
        clone: function cln(obj) {
            if (!obj) {
                return null;
            }
            
            var c;
            if (obj.constructor === Array) {
                // An array can be duplicated by concat, but that's only a shallow clone.
                c = obj.concat();
                // Check if we need to clone the array items too.
                var first = c[0];
                if (first && typeof(first) === 'object') {
                    for (var i=0, len=c.length; i<len; i++){
                        c[i] = this.clone(obj[i]);
                    }
                }
            } else {
                // Assume its a hash.
                c = {};
                for (var k in obj) {
                    var v = obj[k];
                    // Check if we have a subobject/subarray to clone.
                    if (v && typeof(v) == 'object') {
                        // Nested object/array, clone recursively.
                        c[k] = this.clone(v);
                    } else {
                        // Scalar, just copy by value.
                        c[k] = v;
                    }
                }
            }
            return c;
        },
        
        /**
         * <p>Clones an array.</p>
         * 
         * @param {Array} The array to clone.
         * 
         * @returns {Array} The cloned array.
         */
        cloneArray: function clnArr(/*Array*/ arr) {
            var arr2 = [];
            for (var i=0, len=(arr&&arr.length)||0; i<len; i++) {
                arr2[i] = this.clone(arr[i]);
            }
            return arr2;
        },

        /**
         * Generates an array of the keys in a given hash.
         * @param {Object} h The hash whose keys are to be inspected.
         * @param {Boolean} [nums] If true, the values are treated as numbers for comparison.
         * @returns {Array} The array of hash keys.
         */
        keyarray: function kyarr(h, nums) {
            var arr = [];
            if (h) {
                for (var k in h) {
                    arr.push(nums ? Number(k) : k);
                }
            }
            return arr;
        },
        
        /**
         * Generates an array of the values in a given hash.
         * @param {Object} h The hash whose values are to be inspected.
         * @returns {Array} The array of hash values.
         */
        valarray: function varr(h){
            var arr = [];
            if (h) {
                for (var k in h) {
                    arr.push(h[k]);
                }
            }
            return arr;
        },
        /**
         * Returns whether the two hashes are the same.
         */
        equals: function eq(h1, h2) {
            // check null, equals when either both not null or both null
            var _H = mstrmojo.hash,
                _rslt = h1 && h2 || (!h1 && !h2 && (h1 === h2));
            // for not null
            if (_rslt && h1) {
                // check constructor
                _rslt = (h1.constructor === h2.constructor);
                if (_rslt) {
                    // array type
                    if (h1.constructor === Array) {
                        var len = h1.length;
                        // check length
                        _rslt = (len === h2.length);
                        // for same length and has items
                        if (_rslt && len){
                            // check each individual item
                            for (var i = 0; i < len; i ++) {
                                _rslt = _rslt && _H.equals(h1[i], h2[i]);
                            }
                        }
                    // object type
                    } else if (typeof (h1) === 'object'){
                        // check keys
                        var h1k = _H.keyarray(h1),
                            h2k = _H.keyarray(h2);
                        _rslt = h1k.length === h2k.length;
                        if (_rslt){
                            for (var p in h1){
                                _rslt = _rslt && (_H.equals(h1[p], h2[p]));
                            }
                        }
                    // primitive type    
                    } else {
                        _rslt = (h1 === h2);
                    }
                }
            }
            return _rslt;
        },
        /**
         * Traverse a json object and transform any of its Object property into an array
         * if it has a boolean property called "isArray" with value = true. It also assumes that this 
         * Object property has another property called "length" indicating the length of the array. 
         * @param {Object} o The hash to be transformed.
         * @return {Object} The object after being transformed. 
         */
        obj2array: function(o){
           for(var n in o){
              var p = o[n];
              if(p && typeof(p) == 'object'){
                  o[n] = this.obj2array(p);
              } 
           }
           if('isArray' in o && (o.isArray === true)){
               var r = [];
               for(var i=0,len=o.length;i<len;i++){
                   r.push(o[i]);   
               }
               return r;
           } else {
               return o;   
           }
        },
        
        
        /**
         * Returns the smallest value in a given hash.
         * @param {Object} h The hash to be inspected.
         * @param {Boolean} [vals] If true, the hash values are inspected; otherwise, the hash keys are.
         * @param {Boolean} [nums] If true, hash entries are treated as numbers for comparison.
         */
        min: function min(h, vals, nums){
            var m;
            if (h) {
                for (var k in h){
                    var v = vals ? h[k] : k;
                    if (nums) {
                        v = Number(v);
                    }
                    if ((m == null)||(v < m)){
                        m = v;
                    }
                }
            }
            return m;
        },
        
        /**
         * <p>Converts a given hash into an instance of a given javascript class.</p>
         *
         * <p>This method is typically used to make a native javascript Object into an observable object.
         * Unlike using a class constructor, this call enhances the given object rather than creating a new object.</p>
         *
         * @param {Object} h The object (hash) to be converted.
         * @param {Object} c The constructor for the class to which the given object will be converted.
         * @param {Object} [props] Hash of properties to apply to the resulting class instance. Only used if the instance has an "init" method,
         * in which case the hash is passed in as a single argument to that method.
         * @returns {Object} The same object passed in.
         * @static
         */
        make: function mk(h, c, props) {
            if (!h || !c) {
                return null;
            }
            if (h.attachEventListener) {
                // Object is already observable. Don't try to re-register it.
                return h;
            }
            if (c.makeObservable) {
                h = c.makeObservable(h, props) || h;
            } else {
                this.copy(c.prototype, h);
                if (h.init) {
                    h = h.init(props) || h;
                }
            }
            return h;
        }
    });
    
})();
(function () {

    var $MATH = Math;

    /**
     * Private utility that return a native DOM event object.  Used to get a handle
     * to the event while encapsulating cross-browser differences.
     */
    function _evt(hWin, e) {
        return e || (hWin || window).event;
    }

    /**
     * @private
     * @ignore
     */
    var isIE = !!document.all,
        ua = navigator.userAgent,
        isFF = !isIE && !!ua.match(/Firefox/),
        bv = 0,
        isAndroid = !!ua.match(/Android/),
        isIPad = !!ua.match(/iPad/),
        tch = !!document.createTouch || isAndroid,
        isPlayBook = !!ua.match(/PlayBook/),
        isWinPhone = !!ua.match(/Windows Phone/),
        isIE10 = isIE && !!ua.match(/MSIE 10/),
        isIEW3C = !isIE && !!ua.match(/Trident.*rv/),
        isDXIE = isIE && !isIE10,
        CSS3_PREFIX = isFF ? '-moz-' :
                             isIE ? '' : '-webkit-',
        CSS3_TRANSFORM_PREFIX = isFF ? 'Moz' :
                                       isIE10 ? '' :
                                                isIE ? 'ms' : 'webkit',
        CSS3_T_INITIAL = (isIE10 ? 't' : 'T'),
        CSS3_TRANSITION = CSS3_TRANSFORM_PREFIX + CSS3_T_INITIAL + 'ransition', // IE9: N/A, IE10: transition, Chrome: webkitTransition, Moz: transition or MozTransransition
        CSS3_TRANSFORM = buildCSS3Transform(),
        CSS3_TRANSITION_PROPERTY = buildCSS3TransitionProperty(),
        CSS3_TRANSITION_DURATION = buildCSS3TransitionDuration(),
        CSS3_TRANSITION_END = buildCSS3TransitionEnd(),   
        CSS3_BOXSHADOW = buildCSS3BoxShadow();
        
    function buildCSS3Transform(){
        
        /*
            IE9: msTransform
            IE10: transform
            Chrome: webkitTransform
            Moz: transform or MozTransform
        */

        return CSS3_TRANSFORM_PREFIX + CSS3_T_INITIAL + 'ransform';
    }
    
    function buildCSS3TransitionProperty(){
        
        /*
            IE9: N/A
            IE10: transitionProperty
            Chrome: webkitTransitionProperty
            Moz: transitionProperty or MozTransransitionProperty
        */

        return CSS3_TRANSITION + 'Property';
    }     
    
    function buildCSS3TransitionDuration(){
        
        /*
            IE9: N/A
            IE10: transitionDuration
            Chrome: webkitTransitionDuration
            Moz: transitionDuration/MozTransitionDuration
        */

        return CSS3_TRANSITION + 'Duration';
    }
    
    function buildCSS3TransitionEnd(){
        
        /*
            IE9: N/A
            IE10: transitionend
            Chrome: webkitTransitionEnd
            Moz: transitionend
        */
        
        return (isIE10 || isFF) ? 'transitionend' :  'webkitTransitionEnd';
    }   
    

    function buildCSS3BoxShadow(){
        
        /*
            IE9: N/A
            IE10: BoxShadow
            Chrome: webkitBoxShadow
            Moz: MozBoxShadow
        */
        
        return CSS3_TRANSFORM_PREFIX + 'BoxShadow';
    }    
    

    /**
     * Private function for extracting the Firefox browser version number.
     *
     * @private
     * @ignore
     */
    function getBrowserVersion() {
        // Have we cached the browser version already?
        if (!bv && isFF) {
            // If not, we only need this for Firefox.
            // Retrieve the Firefox version number from the user agent.
            var nav = ua.match(/.*Firefox\/([\d|\.]*).*/);
            // Did we find it?
            if (nav) {
                // Store this in the browser version and return it.
                bv = parseFloat(nav[1], 10);
            }
        }

        return bv;
    }

    function _docScroll() {
        var x = 0,
            y = 0,
            w = window,
            d = document,
            b = d.body,
            de = d.documentElement;
        if (typeof w.pageYOffset == 'number') {
            y = w.pageYOffset;
            x = w.pageXOffset;
        } else if (b && (b.scrollLeft || b.scrollTop)) {
            y = b.scrollTop;
            x = b.scrollLeft;
        } else if (de && (de.scrollLeft || de.scrollTop)) {
            y = de.scrollTop;
            x = de.scrollLeft;
        }
        return {
            x: x,
            y: y
        };
    }

    function setTranslateValue(num) {

        //Validate for null or undefined
        num = num || 0;

        //Convert to string
        num = String(num);

        return ((num.indexOf("%", 0)) != -1) ? num : (num + 'px');
    }

    function createTransformationString(x, y, z, use3d, translateString) {

        if (!mstrmojo.dom.isWinPhone) {
            use3d = (use3d || false || this.isHWAccelerated);
        } else {
            use3d = false;
        }

        var translateOpen = translateString + (use3d ? '3d' : '') + '(',
            translateClose = use3d ? (',' + z + ')') : ')';

        return translateOpen + x + ',' + y + translateClose;
    }
    
    var TOP = 1, 
        BOTTOM = 2,
        CENTER = 3,
        LEFT = 4,
        RIGHT = 5;
    
    /**
     * Align DOM node to the position on the window
     * @param {HTMLElement} e The dom node that needs alignment
     * @param {Integer} h Horizontal alignment flag, can be LEFT, CENTER, or RIGHT
     * @param {Integer} v Vertical alignment flag, can be TOP, CENTER, or BOTTOM
     */
    function alignDOM(e, h, v) {
        var es = e.style,
            eds = es.display,
            wdim = this.windowDim(),
            ds = _docScroll();
        
        //display before reading clientWidth/height
        es.display = 'block';
        
        var hpos = wdim.w - e.clientWidth,
            vpos = wdim.h - e.clientHeight,
            hm = {
                4: 0, /*left*/
                5: hpos, /*right*/
                3: hpos/2 /*center*/
            },
            vm = {
                1: 0, /*top*/
                3: vpos/2, /*center*/
                2: vpos /*bottom*/
            };
        
        es.left = hm[h] + ds.x + 'px';
        es.top = vm[v] + ds.y + 'px';
        es.display = eds;
    }

    mstrmojo.Enum_Keys = {
        // summary:
        //      Definitions for common key values
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        CTRL: 17,
        ESCAPE: 27,
        SPACE: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT_ARROW: 37,
        UP_ARROW: 38,
        RIGHT_ARROW: 39,
        DOWN_ARROW: 40,
        INSERT: 45,
        DELETE: 46
    };

    mstrmojo.dom = mstrmojo.provide(
        "mstrmojo.dom",
        {
            userAgent: ua,

            isIE: isIE,

            isIE6: isIE && !!ua.match(/MSIE 6/),
            isIE7: isIE && !!ua.match(/MSIE 7/),
            isIE8: isIE && !!ua.match(/MSIE 8/),
            isIE9: isIE && !!ua.match(/MSIE 9/),
            isIE10: isIE10,
            isIEW3C: isIEW3C,
            isNSIE: isIE && !isIE10, //Non Standards IE
            isDXIE: isDXIE,

            isFF: isFF,

            isWK: !!ua.match(/AppleWebKit/),

            isSafari: !!ua.match(/Safari/) && !ua.match(/Chrome/),

            isHWAccelerated: !isAndroid,

            isAndroid: isAndroid,

            isIPad: isIPad,

            isPlayBook: isPlayBook,

            isWinPhone: isWinPhone,

            supportsTouches: tch,

            TOUCHSTART: tch ? 'touchstart' : 'mousedown',
            TOUCHMOVE: tch ? 'touchmove' : 'mousemove',
            TOUCHEND: tch ? 'touchend' : 'mouseup',
            TOUCHCANCEL: tch ? 'touchcancel' : '',
            RESIZE: tch ? 'orientationchange' : 'resize',

            CSS3_PREFIX: CSS3_PREFIX, 
            CSS3_BOXSHADOW: CSS3_BOXSHADOW,
            CSS3_TRANSFORM: CSS3_TRANSFORM,
            CSS3_TRANSITION: CSS3_TRANSITION,
            CSS3_TRANSITION_PROPERTY: CSS3_TRANSITION_PROPERTY,
            CSS3_TRANSITION_DURATION: CSS3_TRANSITION_DURATION,
            CSS3_TRANSITION_END: CSS3_TRANSITION_END,
                    
            cssFeatures: {
                GRADIENTS: 'gd',
                ROUND_CORNERS: 'rc',
                TEXT_ROTATION: 'tr',
                DROP_SHADOW: 'sh'
            },

            /**
             * Determines if the users browser supports a particular feature.
             *
             * @param {String} f The feature to check using the constants defined on this object.
             *
             * @returns Boolean
             */
            supports: function supports(f) {
                var ffVer = this.isFF && getBrowserVersion();
                switch (f) {
                case this.cssFeatures.GRADIENTS:
                    return (this.isIE || this.isIEW3C || this.isWK || ffVer >= 3.6 || this.isWinPhone);

                case this.cssFeatures.ROUND_CORNERS:
                    return (this.isWK || this.isFF || this.isWinPhone || this.isIE10);

                case this.cssFeatures.TEXT_ROTATION:
                case this.cssFeatures.DROP_SHADOW:
                    return (this.isIE || this.isWK || ffVer >= 3.5 || this.isWinPhone || this.isIE10 || this.isIEW3C);
                }

                return false;
            },

            /**
             * Replaces one Dom node in a DOM Doc with another.
             */
            replace: function dom_repl(/*DomNode*/ target, /*DomNode*/ replacement) {
                if (!target || !replacement) {
                    return;
                }

                var p = target.parentNode;
                if (p) {
                    p.replaceChild(replacement, target);
                }
            },

            /**
             * Cross-browser wrapper for DOM2's addEventListener method, which in IE is called attachEvent.
             *
             * @param {HTMLElement} el The HTMLElement to attach an event listener to.
             * @param {String} eventName The name of event to listen for.
             * @param {Function} f The function to execute when the event occurs.
             * @param {Boolean} [phase=false] The event phase to capture (false for bubbles, true for capture).
             */
            attachEvent: function dom_attch(el, eventName, f, phase) {
                if (el.addEventListener) {
                    return el.addEventListener(eventName, f, !!phase);
                } else {
                    return el.attachEvent("on"+eventName, f);
                }
            },
    
            /**
             * Cross-browser wrapper for DOM2's removeEventListener method, which in IE is called detachEvent.
             *
             * @param {HTMLElement} el The HTMLElement to attach an event listener to.
             * @param {String} eventName The name of event to listen for.
             * @param {Function} f The function to execute when the event occurs.
             * @param {Boolean} [phase=false] The event phase to capture (false for bubbles, true for capture).
             */
            detachEvent: function dom_detach(/*DomNode*/ el, /*String*/ eventName, /*Function*/ f, phase) {
                if (!el) {
                    return;
                }
    
                if (el.removeEventListener) {
                    el.removeEventListener(eventName, f, !!phase);
                } else {
                    el.detachEvent("on" + eventName, f);
                }
            },
    
            attachOneTimeEvent: function attachOneTimeEvent(el, eventName, f, phase) {
                // Create wrapper function so we can detach later.
                var fn = function(evt) {
                    // Call supplied function.
                    f(evt);
    
                    // Detach event.
                    mstrmojo.dom.detachEvent(this, eventName, fn, phase);
                };
    
                // Attach event.
                this.attachEvent(el, eventName, fn, phase);
    
                // Kill 'el' reference to avoid memory leaks.
                el = null;
    
                return fn;
            },
    
            /**
             * captures and processes a DOM event; usually called from event handler attached to DOM element.
             * event is passed to the object in the mstrmojo.all collection referenced by the id parameter.
             */
            captureDomEvent: function captureDomEvent(id, type, hWin, e, config) {
                var x = mstrmojo.all[id];
                if (x) {
                    x.captureDomEvent(type, hWin, e, config);
                }
            },
    
    
            /**
             * This method uses the Webkit's transform property to translate a DOM node. Based on whether the browser has been HW accelerated,
             * the method decides whether to use 'translate' or 'translate3d'.
             *
             * @param (HTMLElement) el The HTML DOM element that needs to be translated
             * @param (Integer) x The number of pixels (or percentage) to be moved along the x axis
             * @param (Integer) y The number of pixels (or percentage) to be moved along the y axis
             * @param (Integer) z The number of pixels (or percentage) to be moved along the z axis
             * @param (String) extra Optional parameter: Any other extra CSS transform properties.
             * @param (Boolean) useTranslate3d Optional parameter helps in overriding the default device/browser behavior in using
             *                  webkitTransforms
             */
            translate: function translate(el, x, y, z, extra, useTranslate3d) {
                extra = (extra && ' ' + extra) || '';
    
                el.style[((mstrmojo.dom.isWinPhone || mstrmojo.dom.isIE9 || mstrmojo.dom.isIE10) ? 'ms' : 'webkit') + 'Transform'] = this.createTranslateString(x, y, z, useTranslate3d) + extra;
            },
    
    
            createTranslateString: function createTranslateString(x, y, z, useTranslate3d) {
    
                //Set the property to fit the transform string.
                x = setTranslateValue(x);
                y = setTranslateValue(y);
                z = setTranslateValue(z);
    
                return createTransformationString(x, y, z, useTranslate3d, 'translate');
            },
    
            createScaleString: function createScaleString(x, y, z, useScale3d) {
    
                //Set the property to fit the transform string.
                x = x || 0;
                y = y || 0;
                z = z || 0;
    
                return createTransformationString(x, y, z, useScale3d, 'scale');
            },
    
            /**
             * Number of milliseconds that an event is buffered by attachBufferedEvent methods.
             */
            _bufferSize: 200,
    
            /**
             * A lookup hash of buffer DOM attachments (plus timeout ids, listeners, etc) keyed by "<nodeid>-<event name>".
             */
            _bufferConnects: {},
    
            /**
             * Warning: this method assumes a single namespace for all node ids. Need to enhance it to support
             * nodes from different frames/windows with the same id.
             * Warning: this method assumes the given node has an id. That's done for performance reasons; it allows
             * us to cache info by node id in a hash; otherwise, we'd have to cache the node handle, which could be
             * risky for memory leaks, and would require using a cache array instead of hash, which would mean
             * slower performance for cache lookups.
             * Warning: buffered events will callback the given function with no arguments, so only use for
             * specific cases when your callback doen't need the native DOM event object (because it will be long gone).
             */
            attachBufferedEvent: function dom_attchbuf(/*DomNode*/ el, /*String*/ eventName, /*Function*/ f, /*Integer?*/ bufferSize) {
    
                var key = el.id+"-"+eventName,
                    info = this._bufferConnects[key];
                if (!info) {
                    info = this._bufferConnects[key] = {
                        elId: el.id,
                        eventName: eventName,
                        timer: null,
                        bufferSize: bufferSize,
                        listeners: [],
                        callback:     function(e) {
                                        mstrmojo.dom._callback(e, mstrmojo.global, key);
                                        return true;
                                    }
                    };
                    this.attachEvent(el, eventName, info.callback);
                }
                info.listeners.push(f);
            },
    
            _callback: function dom_callback(/*DomEvent?*/ e, /*DomWindow*/ hWin, /*String*/ key) {
                // TO DO: does this actually get called correctly with the right hWin? Test in IE.
                if (!e) {
                    e = hWin.event;
                }
                var info = this._bufferConnects[key],
                    timer = info && info.timer;
                if (info && !timer) {
                    var ms = (info.bufferSize === null) ? this._bufferSize : info.bufferSize;
    
                    if (info.bufferSize) {
                        info.timer = hWin.setTimeout(
                                        function() {mstrmojo.dom.updateBuffers(key);},
                                        ms
                                   );
                    } else {
                        // instant callback.
                        mstrmojo.dom.updateBuffers(key);
                    }
                }
            },
    
            updateBuffers: function dom_updateBuffers(/*String*/ key) {
                var info = this._bufferConnects[key],
                    ls = info && info.listeners;
                for (var i=0, len=ls && ls.length || 0; i<len; i++) {
                    ls[i]();
                }
                if (info && info.timer) {
                    delete info.timer;
                }
            },
    
            detachBufferedEvent: function dom_dtchbuf(/*DomNode*/ el, /*String*/ eventName, /*Function*/ f) {
                if (!el) {
                    return;
                }
    
                var key = el.id+"-"+eventName,
                    info = this._bufferConnects[key],
                    ls = info && info.listeners,
                    len = (ls && ls.length) || 0;
                if (len) {
                    for (var i=len-1; i>-1; i--) {
                        if (ls[i] == f) {
                            ls.splice(i,1);
                        }
                    }
                    // if no listeners left, detach the callback and
                    // remove its entry in our lookup so we can reconnect in the future if needed.
                    if (!ls.length) {
                        this.detachEvent(el, eventName, info.callback);
                        delete this._bufferConnects[key];
                        if (info.timer) {
                            mstrmojo.global.clearTimeout(info.timer);
                        }
                    }
                }
            },
    
            /**
             * Returns the target DOM node of a given DOM event.
             */
            eventTarget: function evtTgt(/*DomWindow?*/ hWin, /*DomEvent?*/ e) {
                e = _evt(hWin, e);
                return e.target || e.srcElement;
            },
    
            /**
             * Returns true if the CTRL key was pressed during given DOM event.
             */
            ctrlKey: function ctrl(/*DomWindow?*/ hWin, /*DomEvent?*/ e) {
                return _evt(hWin, e).ctrlKey;
            },
    
            /**
             * Returns true if the SHIFT key was pressed during given DOM event.
             */
            shiftKey: function shift(/*DomWindow?*/ hWin, /*DomEvent?*/ e) {
                return _evt(hWin, e).shiftKey;
            },
            
            /**
             * Returns mouse button of event, 1 for left-click, 2 for right (middle is considered as left)
             */
            getButton: function getButton(/*DomWindow?*/ hWin, /*DomEvent?*/ e) {
                return ((_evt(hWin, e)).button == 2) ? 2 : 1;    // IE, Firefox, Chrome all treat right button as 2
            },
    
            getMousePosition: function getMousePosition(e, hWin) {
                hWin = hWin || window;
    
                var x, y;
                if (mstrmojo.dom.isIE) {
                    e = e || hWin.event;
                    // In IE, clientX and clientY are relative to the current scroll position, not to the document.
                    var d = document,
                        b = d.body,
                        de = d.documentElement;
                    x = e.clientX + b.scrollLeft + (de.scrollLeft || 0);
                    y = e.clientY + b.scrollTop + (de.scrollTop || 0);
                } else {
                    // In other browsers, pageX & pageY are relative to the document, independent of the scroll position.
                    x = e.pageX;
                    y = e.pageY;
                }
    
                return { "x" : x, "y" : y };
            },
    
            /**
             * Return the position and size of a dom node.
             * The position is relative to its owner document, if includeScroll = true.
             * Otherwise, relative to its client view port.
             * TO-DO: Consider move it to boxmodel.js.
             */
            position: function(el, includeScroll) {
                var p = {
                    x: 0,
                    y: 0
                };
    
                // Does the browser support getBoundingClientRect?
                if (el && el.getBoundingClientRect) {
                    try {
                        // IE throws error if one of el's parents is removed from page and el becomes an orphan
                        p = el.getBoundingClientRect();
                    } catch (e) {
                        p = {
                            left: 0,
                            top: 0,
                            right: 0,
                            bottom: 0,
                            height: 0,
                            width: 0
                        };
                    }
    
                    // Change to x, y, w and h;
                   p = {
                       x: p.left,
                       y: p.top,
                       w: p.right - p.left,
                       h: p.bottom - p.top
                   };
    
                   // Is this IE7 and below?
                   if (this.isIE6 || this.isIE7) {
                       // Does the element have an owner document?
                       var ownerDocument = el.ownerDocument;
                       if (ownerDocument) {
                           // Adjust top and left.
                           var de = ownerDocument.documentElement,
                               deo = de.getBoundingClientRect();
                           p.x -= deo.left;
                           p.y -= deo.top;
                       }
                   }
                }
    
                // Should we adjust for scroll?
                if (includeScroll) {
                    var ds = _docScroll();
                    p.x += ds.x;
                    p.y += ds.y;
                }
    
                return p;
            },
    
            /**
             * Measures the delta position of one DOM node relative to another.
             * Note: compared to offset, this one consider scroll.
             * TO-DO: Consider move it to boxmodel.js.
             */
            delta: function delta(/*DomNode*/ el, /*DomNode?*/ elLimit) {
                elLimit = elLimit || document.body;
                var pe = this.position(el),
                    pr = this.position(elLimit);
    
                return {x: Math.round(pe.x - pr.x), y: Math.round(pe.y - pr.y)};
            },
    
            /**
             * Calculate the dimension of browser window.
             */
            windowDim: function _winDim() {
                var w = 0,
                    h = 0,
                    win = window,
                    d = document,
                    de = d.documentElement,
                    db = d.body;
                if (typeof(win.innerWidth) == 'number') {
                  w = win.innerWidth;
                  h = win.innerHeight;
                } else if (de  && (de.clientWidth || de.clientHeight)) {
                  w = de.clientWidth;
                  h = de.clientHeight;
                } else if (db && (db.clientWidth || db.clientHeight)) {
                  w = db.clientWidth;
                  h = db.clientHeight;
                }
                return {w:w,h:h};
            },
    
            /**
             * Position an element to the center of browser window.
             */
            center: function center(e) {
                alignDOM.call(this, e, CENTER, CENTER);
            },
            
            /**
             * Position an element to the bottom center of browser window.
             */
            bottomCenter: function bottomCenter(e) {
                alignDOM.call(this, e, CENTER, BOTTOM);
            },
    
            /**
             * Removes the native text highlight that browsers tend to do whenever
             * end-users do a SHIFT+click or CTRL+click.
             */
            clearBrowserHighlights: function clrHiLits(/*DomWindow?*/ hWin) {
                hWin = hWin || self;
                if (isIE) {
                    var doc = hWin.document,
                        sel = doc && doc.selection,
                        em = sel && sel.empty;
                    if (em) {
                        try {
                            sel.empty();
                        } catch(ex) {
                            // TQMS# 337503: It seems that for an unknown reason the empty property sometimes can generate Runtime error, so swallow any errors.
                        }
                    }
                }
                else {
                    var gs = hWin.getSelection,
                        s = gs && hWin.getSelection();
                    if (s && !s.isCollapsed) {
                        if (s.empty) {
                            s.empty();
                        } else if (s.removeAllRanges) {
                            s.removeAllRanges();
                        }
                    }
                }
            },
    
            /**
             * Searches for an ancestor of a given DOM node with a given HTML attribute.
             * The attribute value may be any non-null value.   If a boolean flag is true,
             * the given DOM node is included in the search along with its ancestors.
             * If a limit node is given, the search stops when that limit is encountered (and
             * the limit itself is not tested).
             */
            findAncestorByAttr: function fndAncAttr(/*DomNode*/ el, /*String*/ attr, /*Boolean*/ inclusive, /*DomNode?*/ elLimit) {
                var node = inclusive ? el : el && el.parentNode;
                while (node && (node != elLimit)) {
                    var v = node.getAttribute && node.getAttribute(attr);
                    if (v != null) {
                        return {
                                node: node,
                                value: v
                        };
                    }
                    node = node.parentNode;
                }
                return null;
            },
    
            /**
             * Searches for an ancestor of a given DOM node with a given node name.
             * The attribute value may be any non-null value.   If a boolean flag is true,
             * the given DOM node is included in the search along with its ancestors.
             * If a limit node is given, the search stops when that limit is encountered (and
             * the limit itself is not tested).
             */
            findAncestorByName: function fndAncNm(/*DomNode*/ el, /*String*/ nodeName, /*Boolean*/ inclusive, /*DomNode?*/ elLimit) {
                nodeName = nodeName && nodeName.toLowerCase();
                var node = inclusive ? el : el && el.parentNode;
                while (node && (node != elLimit)) {
                    var n = node.nodeName;
                    if (n && (n.toLowerCase() == nodeName)) {
                        return node;
                    }
                    node = node.parentNode;
                }
                return null;
            },
    
            /**
             * Returns true if a given DOM node is an ancestor of another given node.
             * If a boolean flag is true, the latter node is included in the search.
             * If a limit node is given, the search stops when that limit is encountered (and
             * the limit itself is not tested).
             */
            contains: function cntns(/*DomNode*/ elP, /*DomNode*/ elC, /*Boolean*/ inclusive, /*DomNode?*/ elLimit) {
                var node = elC;
    
                // Should we exclude the elC?
                if (!inclusive) {
                    // Start the search with the parent of elC.
                    node = node.parentNode;
                }
    
                while (node) {
                    // Is this node the target node?
                    if (node == elP) {
                        return true;
                    }
    
                    // Is the node the limit?
                    if (node === elLimit) {
                        break;
                    }
    
                    // Check the parent.
                    node = node.parentNode;
                }
    
                return false;
            },
    
            preventDefault: function prvDft(hWin, e) {
                if (!e) {
                    e = hWin.event;
                }
                if (e.preventDefault) {
                    e.preventDefault();
                }else{
                    e.returnValue = false;
                }
            },
    
            stopPropogation: function stpPrg(hWin, e) {
                if (!e) {
                    e = hWin.event;
                }
                if (e.stopPropogation) {
                    e.stopPropogation();
                } else {
                    e.cancelBubble = true;
                }
            },
    
            firstTouch: function fstTch(hWin, e) {
                return e && e.touches && e.touches.length ? e.touches[0] : (e || hWin.event);
            },
    
            firstChangedTouch: function fstChTch(hWin, e) {
                return e && e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : (e || hWin.event);
            },
    
            isLandscape: function isLandscape() {
                return !this.supportsTouches || (Math.abs(window.orientation) === 90);
            },
    
            /**
             * <p>Finds the corresponding widget for a given DOM node.</p>
             *
             * <p>Searches the DOM node and its ancestors for an mstrmojoId expando property, which is assumed to
             * be set in the domNode of every widget to the widget's id.</p>
             *
             * @param {DomNode} el The DOM node.
             * @returns {mstrmojo.Widget} The corresponding widget, if any; null otherwise.
             */
            findWidget: function(el) {
                while (el) {
                    var id = el.mstrmojoId;
                    if (id != null) {
                        return mstrmojo.all[id];
                    }
                    el = el.parentNode;
                }
                return null;
            },
    
            /**
             * Move caret to the specified position
             * @param {DOMNode} el DOMNode to move its caret, like <INPUT>, <TextArea>
             * @param {Integer} pos  The number of charater of the node's text content from the beginning
             */
            setCaret: function (el, pos) {
                if (el.setSelectionRange) {
                    el.focus();
                    el.setSelectionRange(pos, pos);
                }
                else if (el.createTextRange) { //IE7,8
                    var tr = el.createTextRange();
                    tr.move("character", pos);
                    tr.select();
                }
            }

    });
    /**
     * utilities which provide the functions for querying window and document geometry.
     */
    var G = mstrmojo.dom,
        w = window,
        d = document,
        de = d && d.documentElement,
        b = d && d.body ;
    /**
     * getWindowX/Y(): return the position of hte window on the screen.
     */
//    if (w.screenLeft) { // IE and others
//        G.getWindowX = function() { return w.screenLeft;};
//        G.getWindowY = function() { return w.screenTop;};
//    } else if (w.screenX) { // Firefox and others
//        G.getWindowX = function() { return w.screenX;};
//        G.getWindowY = function() { return w.screenY;};
//    }
    /**
     * getViewportWidth/Height(): return the size of the browser viewport area.
     * getHorizontal/VerticalScroll(): return the position of the horizontal/vertical scrollbar
     */
    if (w.innerWidth) { // All brosers but IE
//        G.getViewportWidth = function() { return w.innerWidth;};
//        G.getViewportHeight = function() { return w.innerHeight;};
        G.getHorizontalScroll = function() { return w.pageXOffset;};
        G.getVerticalScroll = function() { return w.pageYOffset;};
    } else if (de && de.clientWidth) {
    // for IE 6 when there is a DOCTYPE
//        G.getViewportWidth = function() { return de.clientWidth;};
//        G.getViewportHeight = function() { return de.clientHeight;};
        G.getHorizontalScroll = function() { return de.scrollLeft;};
        G.getVerticalScroll = function() { return de.scrollTop;};
    } else if (b.clientWidth) {
    // for IE 4, IE 5 and IE 6 without DOCTYPE
//        G.getViewportWidth = function() { return b.clientWidth;};
//        G.getViewportHeight = function() { return b.clientHeight;};
        G.getHorizontalScroll = function() { return b.scrollLeft;};
        G.getVerticalScroll = function() { return b.scrollTop;};
    }
    /**
     * getDocumentWidth/Height(): return the size of the document.
     */
//    if (de && de.scrollWidth) {
//        G.getDocumentWidth = function() { return de.scrollWidth;};
//        G.getDocumentHeight = function() { return de.scrollHeight;};
//    } else if (b.scrollWidth) {
//        G.getDocumentWidth = function() { return b.scrollWidth;};
//        G.getDocumentHeight = function() { return b.scrollHeight;};
//    }

})();
mstrmojo._ShowsStatus = mstrmojo.provide(
"mstrmojo._ShowsStatus",
{
    /**
     * Utility method on show the status bar while rendering children of a container. This implementation is abstract to some extent since it 
     * relies on the specific container implementations (that want to show status bar) to provide the client side layout currently. Towards that it therefore expects
     * the following rendering markup slots to be defined 
     * [1] _STATUS - slot for status bar. 
     * [2] _STATUS_TXT - slot for status bar text
     * [3] _STATUS_BAR - slot for status bar length
     * 
     * See markupString and markupSlot of Xtab.js & DocLayoutViewer.js for usage. 
     * 
     * ToDo - While we are reusing the status bar through the implementation below, we are still not reusing the HTML template (markup string & slots).  
     */
    showStatus: function shwSts(/*Boolean*/ show, /*String*/ txt, /*Integer*/ perc) {
        // Show render status indicator (if any).
        var el = this._STATUS;
        
        if (!this.hasRendered || !el) {
            return;
        }
        
        if (!show) {
            // Hide render status indicator (if any).
            if (this.showingStatus) {
                el.style.display = 'none';
            }
        } else {
            if (el) {
                // Set caption text.
                var zz = this._STATUS_TXT && (this._STATUS_TXT.innerHTML = txt || '');

                // Set progress bar length.
                zz = this._STATUS_BAR && (this._STATUS_BAR.style.width = (perc || 0) + '%');
                
                // optimization. We position the status bar only the first time. 
                if(!this.isStatusBarPositioned) {
                    el.style.top = Math.max((this.scrollboxHeight || 0) - 50, 12) + 'px';
                    this.isStatusBarPositioned = true;
                }

                if (!this.showingStatus) {
                    el.style.display = 'block';
                }
                
            }
        }
        // Record our new state.
        this.showingStatus = show;
    },
    
     updateStatus: function updSts(/*String*/ txt, /*Integer*/ perc) {
        this.showStatus(this.showingStatus, txt, perc);
    }
});
mstrmojo.DynamicClassFactory = {
	newComponent: function (comp, mixins, props) {
        var name = comp.prototype.scriptClass.replace(/^mstrmojo./, ''); // remove the front mstrmojo package name
        for (var i = 0, cnt = mixins && mixins.length || 0; i < cnt; i++) {
        	if (!mixins[i]._mixinName){
        		alert("Need mixin have '_mixinName' to be used in DynamicClassFactory");
        		return null;
        	}
        	name += '_' + mixins[i]._mixinName.replace(/^mstrmojo./, ''); // remove the front mstrmojo package name
        }

        var f = mstrmojo[name];
        if (!f) {
             f = mstrmojo.declare(comp, mixins, props);
             mstrmojo[name] = f;
        }
        return f;
    }
};

(function(){

    /**
     * Public lookup of registered objects, keyed by id.
     * @type Object
     * @static
     */
    mstrmojo.all = {};
    
    var _A = mstrmojo.all;
    
    /**
     * <p>A counter used for auto-generated ids (see _freeId private function).</p>
     * @type Integer
     * @private
     */
    var _freeIdCounter = 0;

    /**
     * <p>Returns an auto-generated id that is currently unused in the mstrmojo.all collection.</p>
     *
     * <p>The id will following the syntax "mstr#" where "#" is an integer.</p>
     *
     * @returns {String} The auto-generated id.
     * @private
     */
    function _freeId() {
        for (;_freeIdCounter++;) {
            if (!_A["mstr" + _freeIdCounter]) {
                break;
            }
        }
        return "mstr" + _freeIdCounter;
    }
    
    /**
     * <p>Manages a lookup of objects.</p>
     *
     * @class
     */
    mstrmojo.registry = mstrmojo.provide(
    "mstrmojo.registry",
    /**
     * @lends mstrmojo.registry
     */
    {
        /**
         * <p>Adds an object to the lookup.</p>
         *
         * <p>The object must have a non-null "id" property, and that id must not already be used in the lookup; 
         * otherwise, throws an error.</p>
         * 
         * @param {Object} obj The object to be added to the lookup.
         */
        add: function add(obj) {
            if (!obj) {
                return;
            }
            // If we don't have an id (null|undefined), get an auto-generated one, so we can be looked up by id later.
            var id = obj.id;
            if (id == null) {   // if id is null OR undefined
                id = _freeId();
                obj.id = id;
            } else if (_A[id]) {
                throw new Error("Tried to register 2 objects with same id: " + id);
            }
            _A[id] = obj;
        },
        
        /**
         * <p>Removes a given object from the lookup.</p>
         *
         * @param {Object} obj The object to be removed from the lookup.
         */
        remove: function rmv(obj) {
            if (obj && obj.id != null) {    // if id is not null and not undefined
                delete _A[obj.id];
            }
        },

        /**
         * Dumps the ID and, if possible, scriptClass properties of all objects in mstrmojo.all to console
         */
                
        dumpAll: function() {
            for(var o in _A ) {
                if ( _A[o].id != null ) {
                    mstrmojo.dbg(_A[o].id + "(" + (_A[o].scriptClass || "[unknown class]") + ")");
                } 
            }
        },
                        
        /**
         * <p>Attempts to convert a given object reference into an instance of a javascript class.</p>
         *
         * <p>The object reference may be either of the following:</p>
         * <ol>
         * <li>a fully qualified class name (String); or</li>
         * <li>a hashtable of properties, which includes a "scriptClass" property; or</li>
         * <li>an instance of a javascript class.</li>
         * </ol>
         *
         * <p>In case #1, the FQCN is loaded (if needed) and evaluated. If the evaluated result
         * is a Function, it is assumed to be a constructor and then used to instantiate a
         * return value. Otherwise if the evaluated result is an object, then the object is
         * used for either cases #2 (for a native object) or #3 (for an instance of a javascript class).</p>
         *
         * <p>In case (2), the hashtable's scriptClass property determines what constructor
         * is called to instantiate a javascript class.  The hashtable is passed into the
         * constructor call. If no scriptClass property is defined, the hashtable is returned.</p> 
         *
         * <p>In case (3), the given instance is returned.</p>
         *
         * @param {String|Object} config The object reference to be evaluated. 
         * @param {Object} [flags] Hashtable of flags to customize this function call's behavior.
         * @param {Boolean} flags.skipLoadChecks=false If true, this method will skip calling mstrmojo.requiresCls before evaluating an FQCN string.
         * @param {Boolean} flags.dontInst=false If true, when this method evaluates a reference as a Function, it will return that Function; 
         * otherwise, this method assumes the Function is a constructor and calls the Function to create a new object instance.
         * @param {Boolean} flags.clone=false If true, when this method evaluates a reference as a hashtable of properties, it will pass in
         * a clone of the hashtable, rather than the hashtable itself, to a class constructor.
         *
         * @returns {Object} The object to which the reference evaluates to, if successful; null otherwise.
         */
        ref: function ref(config, flags){
            if (!config) {
                return null;
            }
            if (!flags) {
                flags = {};
            }
            var C = config;
            while(C) {
                switch(typeof(C)) {
                    case "string":
                        // An FQCN. Load and evaluate it.
                        if (flags.skipLoadChecks !== true) {
                            mstrmojo.requiresCls(config);
                        }
                        C = eval(C);
                        break;
                    case "function":                        
                        // A constructor. Call it, unless explicitly asked not to.
                        return (flags.dontInst !== true) ? new C() : C;
                    case "object":
                        if (C.constructor === Object) {
                            // A hashtable of properties; try to convert to script class instance.
                            var sc = C.scriptClass;
                            if (sc) {
                                // Script class FQCN is specified; load and evaluate it.
                                if (flags.skipLoadChecks !== true) {
                                    mstrmojo.requiresCls(sc);
                                }
                                var cls = eval(sc);
                                if (cls) {
                                    // Got the constructor; call it.
                                    return new cls((flags.clone === true) ? 
                                                    mstrmojo.hash.clone(C) : 
                                                    C);
                                }
                                // Couldn't load the constructor; failed.
                                return null;
                            } else {
                                // Script class FQCN not specified; return the hashtable.
                                return C;
                            }
                        } else {
                            // A javascript custom class instance.                        
                            return C;
                        }
                        break;
                    default:
                        return null;
                }
            }
        }
    });

    /**
     * <p>Shortcut to mstrmojo.registry.ref method, for convenience.</p>
     * @type Function
     */
    mstrmojo.insert = mstrmojo.registry.ref;
    
})();
/**
 * Singleton for adjusting layout configurations for consumers of the _HasLayout mixin based on DPI.
 *
 * @public
 */
mstrmojo.DPIManager = {

    /**
     * Collection of constructors to be modified.
     *
     * @private
     */
    classes: [],

    /**
     * Registers a class that should be updated for DPI settings.
     *
     * @param {mstrmojo.Widget} clz The widget constructor to be modified.
     * @param {String} dimension The layout dimension to modify (h for height, w for width).
     * @param {String} slot The slot to modify.
     * @param {Object} dpiValues An object with a property for each possible DPI with the correct value for that DPI.
     */
    registerClass: function registerClass(clz, dimension, slot, dpiValues) {
        // Add this class to the classes collection.
        this.classes.push({
            c: clz,
            d: dimension,
            s: slot,
            v: dpiValues
        });
    },

    /**
     * Modifies previously registered classes.
     */
    setDPI: function () {
        // Get device DPI.
        var dpi = mstrMobileApp.getDeviceDPI();

        // Iterate registered classes.
        mstrmojo.array.forEach(this.classes, function (clz) {
            // Store DPI value on layout config.
            clz.c.prototype.layoutConfig[clz.d][clz.s] = clz.v[dpi] + 'px';
        });

        // Reset collection of classes.
        this.classes = [];
    }
};

(function () {

    /**
     * <p>Calculates and returns the new height (or width) for the child.</p>
     *
     * <p>NOTE: Children in auto slots and percentage slots (if onlyPercentageSlots == true) will return the value from their height or width property.</p>
     *
     * @param {mstrmojo.Widget} child The child whose dimension should be calculated.
     * @param {String} dimension The dimension to calculate, either 'h' or 'w'.
     * @param {Boolean} onlyPercentageSlots True if the dimensions should be calculated for only percentage slots.
     *
     * @return String The value for the indicated dimension (in pixels or 'auto').
     */
    function calcChildDimension(child, dimension, onlyPercentageSlots) {
        var dim = this._layoutWidgets[dimension],
            slot = child.slot,
            fixedSlots = dim.f,
            percentageSlots = dim.p,
            isFixed = (fixedSlots && fixedSlots[slot] !== undefined),
            isPercent = (percentageSlots && percentageSlots[slot] !== undefined);

        // Does this child have a fixed or percentage slot, or only a percentage slot if onlyPercentageSlot is true?
        if (slot && ((!onlyPercentageSlots && isFixed) || isPercent)) {
            // Return the calculated size of this widget (either fixed or a percentage of the available height).
            return isFixed ? fixedSlots[slot] : (dim.x * parseInt(percentageSlots[slot], 10) / 100) + 'px';
        }

        return child[(dimension === 'h') ? 'height' : 'width'];
    }

    /**
     * Applies the height and width to the child.
     *
     * @param {mstrmojo.Widget} child The child widget whose dimensions will be set.
     * @param {String} h The height of the child (in pixels, e.g. '31px').
     * @param {String} h The width of the child (in pixels, e.g. '31px').
     *
     */
    function applyChildDimensions(child, h, w) {
        // Does the child wish to ignore layout?
        if (child.ignoreLayout) {
            // Nothing to do.
            return;
        }

        // Does the child have a setDimensions method?
        if (child.setDimensions) {
            // Use it.
            child.setDimensions(h, w);
        } else {
            // Child doesn't have a setDimensions method so use "set" method.
            if (child.set) {
                child.set('height', h);
                child.set('width', w);
            }
        }
    }

    /**
     * Applies calculated dimensions to slots, as well as their children
     *
     * @param {Boolean} onlyPercentageSlots True if dimensions should be applied to percentage slots only, False to apply to both percentage and fixed slots.
     *
     * @private
     */
    function applyDimensions(onlyPercentageSlots) {
        var ch = this.children,
            i,
            len;

        // Iterate children again.
        for (i = 0, len = (ch && ch.length) || 0; i < len; i++) {
            var child = ch[i],
                slot = child.slot;

            // Do we have a slot?
            if (slot) {
                // Get child sizes.
                var h = calcChildDimension.call(this, child, 'h', onlyPercentageSlots),
                    w = calcChildDimension.call(this, child, 'w', onlyPercentageSlots);

                // Apply intial slot dimensions.
                this.setSlotDimensions(slot, h, w);

                // Apply the sizes.
                applyChildDimensions(child, h, w);

                // Calculate child sizes again?
                var zh = calcChildDimension.call(this, child, 'h', onlyPercentageSlots),
                    zw = calcChildDimension.call(this, child, 'w', onlyPercentageSlots);

                // Did either dimension change?  This should only happen if auto slot to repaints when it (or a siblings) dimensions are applied.
                if (zh !== h || zw !== w) {
                    // Apply new sizes.
                    applyChildDimensions(child, zh, zw);
                }

                // Set the dimension on the slot (using new dimensions in case they changed).
                this.setSlotDimensions(slot, zh, zw);
            }
        }

        // Call the afterLayout handler.
        this.afterLayout();
    }

    /**
     * Adjusts the size of any percentage slots in the supplied container to account for newly rendered auto slots.
     *
     * @param {mstrmojo.Widget} child The newly rendered child.
     * @param {Object} lw The layout widget properties created during calculateDimension.
     * @param {String} d The dimension, either height or width.
     *
     * @private
     */
    function adjustDimension(child, lw, d) {
        // Which slot?
        var slot = child.slot,
            autoSlots = lw && lw.a;

        // Is this NOT an 'auto' slot?
        if (!autoSlots || autoSlots[slot] === undefined) {
            // No, then return.
            return;
        }

        // Measure the height of the newly rendered slot.
        var x = this[slot]['offset' + d],
            size = autoSlots[slot];

        // Is the new height the same as the old height?
        if (x === size) {
            // No changes.
            return;
        }

        // Adjust the current dimension size by the delta of the old height and the new height.
        lw.x -= (x - size);

        // Store the new height.
        autoSlots[slot] = x;
    }

    /**
     * <p>Adjusts the layout to account for newly rendered children.</p>
     *
     * @param {mstrmojo.Event} evt The "childrenRendered" event.
     *
     * @private
     */
    function adjustLayout(evt) {
        // Call the beforeLayout handler.
        this.beforeLayout();

        var lw = this._layoutWidgets,
            child = evt.src;

        // Calculate adjusted dimensions for the newly rendered child.
        adjustDimension.call(this, child, lw.h, 'Height');
        adjustDimension.call(this, child, lw.w, 'Width');

        // Apply the dimensions.
        applyDimensions.call(this, true);
    }

    /**
     * Calculates and returns the dimensions for the containers slots and child widgets.
     *
     * @param {Object} dimensionConfig The layout config for this dimension.
     * @param {String} dimension The dimension to calculate, either 'Height' or 'Width' (case sensitive).
     *
     * @private
     * @returns {Object} An object with the following properties:
     * <dl>
     *  <dt>f</dt>
     *  <dd>An object containing fixed slots and their current size value.</dd>
     *  <dt>p</dt>
     *  <dd>An object containing percentage slots and their current size value.</dd>
     *  <dt>a</dt>
     *  <dd>An object containing auto slots and their current size value (zero since they haven't been measured yet).</dd>
     *  <dt>x</dt>
     *  <dd>The current size of this widget that will be devoted to percentage slots.</dd>
     * </dl>
     */
    function calculateDimension(dimensionConfig, dimension) {
        // Do we NOT have layout in this dimension?
        if (!dimensionConfig) {
            // Nothing to do.
            return null;
        }

        var ch = this.children,
            lcDimension = dimension.toLowerCase(),
            widgetDimensionValue = parseInt(this[lcDimension], 10),                     // The total size of this widget dimension (height or width).
            fixedSlots,
            percentageSlots,
            autoSlots,
            autoSlotValues,
            i,
            len,
            child,
            v,
            slot;

        // Step through all slots in the layoutConfig dimension.
        for (slot in dimensionConfig) {

            // The value for this slot.
            v = dimensionConfig[slot];

            // Is the value fixed for this slot?
            if (v.match(/px$/)) {
                // Reduce the total size by the amount of this slots fixed size.
                widgetDimensionValue -= parseInt(v, 10);

                // Store this slot as fixed.
                fixedSlots = fixedSlots || {};
                fixedSlots[slot] = v;

            // Is the value a percentage for this slot?
            } else if (v.match(/\%$/)) {
                // Store this slot as a percentage.
                percentageSlots = percentageSlots || {};
                percentageSlots[slot] = v;

            // Otherwise, it's an auto value.
            } else {
                autoSlots = autoSlots || {};
                autoSlots[slot] = v;
            }
        }

        // Where both auto and percentage slots found?
        if (autoSlots && percentageSlots) {

            // Iterate the children.
            for (i = 0, len = (ch && ch.length) || 0; i < len; i++) {
                child = ch[i];
                slot = child.slot;

                // Does this child have an auto slot and is it not ignoring layout?
                if (child.slot && autoSlots[slot] && !child.ignoreLayout) {

                    autoSlotValues = autoSlotValues || {};

                    // Has it rendered?
                    if (child.hasRendered) {
                        autoSlotValues[slot] = this[child.slot]['offset' + dimension];

                        // Reduce the measured height by the offsetHeight of the slot.
                        widgetDimensionValue -= autoSlotValues[slot];

                    } else {
                        // Cache the slot of this widget for later measurement.
                        autoSlotValues[slot] = 0;

                        // Add event listener to hear when this component is done rendering.
                        child.attachEventListener((child instanceof mstrmojo.Container) ? 'childrenRendered' : 'renderComplete', this.id, adjustLayout);
                    }
                }
            }
        }

        // Return measurements.
        return {
            f: fixedSlots,
            p: percentageSlots,
            a: autoSlotValues,
            x: widgetDimensionValue
        };
    }

    /**
     * <p>A mixin for applying "layout" to a widget.</p>
     *
     * @class
     * @public
     */
    mstrmojo._HasLayout =
        /**
         * @lends mstrmojo._HasLayout#
         */
        {
            _mixinName: 'mstrmojo._HasLayout',

            /**
             * The inner height of the entire widget.
             *
             * @type String
             * @default auto
             */
            height: 'auto',

            /**
             * The inner width of the entire widget.
             *
             * @type String
             * @default auto
             */
            width: 'auto',

            /**
             * A custom hook that will be called before the widget is laid out.
             */
            beforeLayout: mstrmojo.emptyFn,

            /**
             * A custom hook that will be called after the widget is laid out.
             */
            afterLayout: mstrmojo.emptyFn,

            /**
             * <p>The configuration object for the layout of this component.</p>
             *
             * <p>This object has two optional properties: h (for height) and w (for width).  The values of these properties are an Object with any number of properties.  Each
             * property name corresponds to a slot within the component and it's value can either be fixed (in pixels), a percentage or auto.</p>
             *
             * <p>For example:</p>
             *
             * <pre>{
             *         h: {
             *             top: '31px',
             *             containerNode: '100%',
             *             bottom: 'auto'
             *         }
             * }</pre>
             *
             * <p>This configuration would set the top slot to have a height of 31 pixels, the bottom slot would be auto (or fit to content), and the containerNode height would
             * expand to occupy whatever space is not occupied by the top and bottom.  <b>NOTE:</b> To do this, the bottom slot would be measured after it's children render and the height
             * of the container node would be adjusted by the measured height of the bottom slot.</p>
             *
             * @type Object
             */
            layoutConfig: null,

            init: function init(props) {
                this._super(props);

                // Clone the layout config so all instances won't share the same layout config.
                this.layoutConfig = mstrmojo.hash.clone(this.layoutConfig);
            },

            preBuildRendering: function preBuildRendering() {
                var cssText = this.cssText || '';

                var height = this.height;
                if (height && height !== 'auto') {
                    cssText += 'height:' + this.height + ';';
                }

                var width = this.width;
                if (width && width !== 'auto') {
                    cssText += 'width:' + this.width + ';';
                }

                this.cssText = cssText;

                return (this._super) ? this._super() : true;
            },

            postBuildRendering: function postBuildRendering() {
                // Layout all child components.
                this.doLayout();

                return this._super();
            },

            /**
             * Lays out the children and slots of this widget.
             *
             */
            doLayout: function doLayout() {
                // Do we have a layout config?
                var lc = this.layoutConfig;
                if (!lc) {
                    return;
                }

                // Call the beforeLayout handler.
                this.beforeLayout();

                // Initialize the _layoutWidgets collection.
                this._layoutWidgets = {
                    h: calculateDimension.call(this, lc.h, 'Height'),
                    w: calculateDimension.call(this, lc.w, 'Width')
                };

                // Apply the dimensions.
                applyDimensions.call(this, false);
            },

            /**
             * Overridden to call use setDimensions for resizing.
             *
             * @see mstrmojo._FillsBrowser
             *
             * @ignore
             */
            browserResized: function browserResized(size) {
                this.setDimensions(size.h, size.w);
                return true;
            },

            /**
             * Sets the width of the domNode and then calls doLayout.
             *
             */
            onwidthChange: function widthChg() {
                var dn = this.domNode;
                if (!dn || !this.layoutConfig) {
                    return;
                }

                dn.style.width = this.width;
                this.doLayout();
            },

            /**
             * Sets the height of the domNode and then calls doLayout.
             */
            onheightChange: function heightChg() {
                var dn = this.domNode;
                if (!dn || !this.layoutConfig) {
                    return;
                }

                dn.style.height = this.height;
                this.doLayout();
            },

            /**
             * <p>This method will adjust the layout dimensions of the parent.</p>
             *
             * <p>This method will NOT reapply the dimensions.  This method is intended to be used during layout when the application of dimension values to this child
             * require that the parent's slot values be adjusted.  Use with care.</p>
             *
             */
            adjustParentDimensions: function adjustParentDimensions() {
                var p = this.parent,
                    lw = p && p._layoutWidgets;

                // Does the parent have widgets to be layed out.
                if (lw) {
                    // Adjust the parents dimensions.
                    adjustDimension.call(p, this, lw.h, 'Height');
                    adjustDimension.call(p, this, lw.w, 'Width');
                }
            },

            /**
             * Changes the widget dimensions and calls doLayout.
             *
             * @param {String} h The height of the widget in pixels, e.g. '31px'.
             * @param {String} w The width of the widget in pixels, e.g. '31px'.
             *
             * @returns {Boolean} True if either dimension changed, False if neither did.
             */
            setDimensions: function setDimensions(h, w) {
                if (this.height !== h || this.width !== w) {
                    // Set new dimensions.
                    this.height = h;
                    this.width = w;

                    // Resize dom node.
                    var dn = this.domNode;
                    if (dn) {
                        dn.style.height = h;
                        dn.style.width = w;

                        // Layout children.
                        this.doLayout();
                    }

                    return true;
                }

                return false;
            },

            /**
             * Sets the height and width for the supplied slot.
             *
             * @param {String} slot The name of the slot whose dimension should be set.
             * @param {String} h The new height value in pixels, e.g. '31px'.
             * @param {String} w The new width value in pixels, e.g. '31px'.
             */
            setSlotDimensions: function setSlotDimensions(slot, h, w) {
                // Does the slot not have a style collection?
                var sl = this[slot] && this[slot].style;
                if (!sl) {
                    // Nothing to do.
                    return;
                }

                // Is the height defined (IE compatible required check) and does the height NOT match the current height?
                if (h !== undefined && sl.height !== h) {
                    // Apply the height.
                    sl.height = h;
                }

                // Is the width defined (IE compatible required check) and does the width NOT match the current width?
                if (w !== undefined && sl.width !== w) {
                    // Apply the width.
                    sl.width = w;
                }
            }

        };

    /**
     * Static method to get slot size once the device DIP is used to change the layout config height/width
     */
    mstrmojo._HasLayout.getSlotSize = function getSlotSize(constructor, slot) {
        var layoutCfg = constructor && constructor.prototype.layoutConfig;
        if (layoutCfg) {
            var h = layoutCfg.h,
                w = layoutCfg.w;

            return {
                h: (h && h[slot]) || undefined,
                w: (w && w[slot]) || undefined
            };
        }

        return null;
    };

}());
(function () {
    
    /**
     * A utility class for working with arrays.
     * 
     * @class
     */
    mstrmojo.array = mstrmojo.provide(
        "mstrmojo.array",
        /**
         * @lends mstrmojo.array
         */
        {
            
            /**
             * Searches a given array for a given item.
             * 
             * @param {Any[]} arr The array to search.
             * @param {Any} item The item to search for.
             * 
             * @return The index of the item if found; -1 otherwise.
             */
            indexOf: function indexOf(arr, item) {
                var i = 0,
                    len = (arr && arr.length)  || 0;
                
                for (; i < len; i++) {
                    if (arr[i] == item) {
                        return i;
                    }
                }
                return -1;
            },
            
            /**
             * Searches a given array for given set of items.
             * 
             * @return {Object} The search results object, with the following properties:
             * <ul>
             * <li>"indices": an array of indices, one for each given item (null, if not found);</li>
             * <li>"count": the number of items found, possibly 0;</li>
             * <li>"map": a mapping of each found item, keyed by its index in "items" param, to the index where it was found
             * in the "arr" param.</li>
             * </ul>
             */
            indexOfMulti: function idxOf(/*Array*/ arr, /*Array*/ items) {
                if (!items) {
                    return {indices: null, map: {}, count: 0};
                }
                var len = items.length,
                    idxs = new Array(len),
                    map = {},
                    c = 0;
                for (var i=0, j=(arr&&arr.length)||0; i<j; i++){
                    var a = arr[i];
                    for (var k = 0; k<len; k++) {
                        if (items[k] === a){
                            idxs[k] = i;
                            map[k] = i;
                            c++;
                            break;  // Assumes item won't be repeat in items
                        }
                    }
                }
                return {indices: idxs, map: map, count: c}; 
            },
            
            /**
             * Calls a given function once per each item in a given array,
             * passing into that function 3 arguments: the item value, the
             * item index, and the array itself.
             * 
             * @param {Array} arr The Array to be iterated.
             * @param {Function} f The function to be run for each iteration.  The function will accept three parameters (value, index, arr) and if it explicitly returns false the 
             *        iteration will be canceled.
             * @param {Object} [scope=f] An optional scope for the passed function.
             */
            forEach: function forEach(arr, f, scope) {
                for (var i = 0, len = (arr && arr.length) || 0; i < len; i++) {
                    if (scope) {
                        if (f.call(scope, arr[i], i, arr) === false) {
                            break;
                        }
                    } else {
                        if (f(arr[i], i, arr) === false) {
                            break;
                        }
                    }
                }
            },
            
            /**
             * <p>Returns the subset of a given array.</p>
             * 
             * <p>The items of the subset are determined by a given filter function. The function receives
             * each item as the sole argument to the function, and those items
             * for whom the function returns truthy are included in the subset.</p>
             */
            filter: function filter(/*Array*/ arr, /*Function*/ f, /*Object?*/ config) {
                var result = [],
                    n = 0;
                for (var i=0, len=arr && arr.length || 0; i < len; i++) {
                    if (f(arr[i])) {
                        result[n] = arr[i];
                        n++;
                        if (config && config.max && (n >= config.max)) {
                            break;
                        }
                    }
                }
                return result;
            },
            
            /**
             * Returns the index of the first item in a given array whose given
             * property name matches a given value.  This is a faster alternative to
             * using filter() for a simple property-value search.
             */
            find: function find(/*Array*/ arr, /*String*/ n, /*Any*/ v) {
                for (var i=0, len=arr && arr.length || 0; i < len; i++) {
                    var obj = arr[i];
                    if (obj && obj[n] == v) {
                        return i;
                    }
                }
                return -1;
            },
            
            /**
             * Binary search for an array item via comparison of a property.
             * Assumes the array is sorted (ascending) via the given property's value.
             * @param {Array} arr Array of items to be searched.
             * @param {Object} item Item whose property value is to be matched.
             * @param {String} p Name of property whose value is to be matched.
             * @param {Integer} [len] Length of given array; can be supplied as a performance optimization.
             */
            findBin: function fBin(/*Array*/ arr, /*Object*/ item, /*String*/ p, /*Integer?*/ len) {
                var h = len ? len : arr.length, // high
                    l = -1,         // low
                    m,              // medium
                    v = item[p];    // value
                while (h-l > 1) {
                    if (arr[m = h+l >> 1][p] < v) { // a+b >> 1 is shortcut for parseInt((a+b)/2,10)
                        l = m;
                    } else {
                        h = m;
                    }
                }
                return arr[h][p] === v ? h : -1;
            },

            /**
             * Searches the provided array for an item that has a property p with a specified value.  The array must be
             * sorted in ascending order by the property p otherwise the results are undefined.  Both the property values
             * and the test value are assumed to be strings. The search is case INSENSITIVE.
             * The comparison of item property value against the test value is limited to the length on the test value.
             * If no match is found, this method returns the index into the array where an object with property p == test value
             * should be inserted to keep the array sorted.
             * @param {Array} o Array to search
             * @param {String} v Value to search for in the array items property p
             * @param {String} p Name of property to use in comparisons
             * @returns Index of matching string or place to insert object with test value.
             * @type Integer
             */
            
            search: function search(o,v,p) {
                var h = o.length,
                    l = -1,
                    m,
                    val = v.toUpperCase(),
                    len = v.length;
                    
                while(h - l > 1)
                    if(o[m = h + l >> 1][p].substr(0,len).toUpperCase() < val) l = m;
                    else h = m;
                return h;
            },

            /**
             * Searches a given array for items which match a given set of items on a given property.
             * 
             * @param {Array} arr The items to be searched.
             * @param {String} n The property name which will be used to match items.
             * @param {Array} items The items to be searched for.
             * @return {Object} The search results object, with the following properties:
             * <ul>
             * <li>"indices": an array of indices, one for each given item (null, if not found);</li>
             * <li>"count": the number of items found, possibly 0;</li>
             * <li>"map": a mapping of each found item, keyed by its index in "items" param, to the index where it was found
             * in the "arr" param.</li>
             * </ul>
             */
            findMulti: function idxOf(/*Array*/ arr, /*String*/ n, /*Array*/ items) {
                if (!items) {
                    return {indices: null, map: {}, count: 0};
                }
                var len = items.length,
                    idxs = [], // new Array(len), can not create fixed length array, since the items may have item not in the arr range.
                    map = {},
                    c = 0;
                for (var i=0, j=(arr&&arr.length)||0; i<j; i++){
                    var a = arr[i][n];
                    for (var k = 0; k<len; k++) {
                        if (items[k][n] === a){
                            idxs[k] = i;
                            map[k] = i;
                            c++;
                            break;  // Assumes item won't be repeat in items
                        }
                    }
                }
                return {indices: idxs, map: map, count: c}; 
            },
            
            /**
             * Removes a given item from a given array, if found.
             */
            removeItem: function rmI(/*Array*/ arr, /*Any*/ item) {
                var i = this.indexOf(arr, item);
                if (i >-1) {
                    this.removeIndices(arr, i, 1);
                }
                return i;
            },
            
            /**
             * Searches a given array for items which match a given set of items on a given property, and
             * removes any of the matches found.
             * 
             * @param {Array} arr The items to be searched.
             * @param {String} n The property name which will be used to match items.
             * @param {Array} items The items to be searched for.
             */
            removeItems: function rmIts(arr, n, items){
                var ret = this.findMulti(arr, n, items);
                if (ret.count) {
                    // Sort the indices in ascending order, slice off the nulls (i.e., the not found).
                    var idxs = ret.indices.concat().sort(this.numSorter).slice(0, ret.count);
                    for (var i=idxs.length-1; i>-1; i--) {
                        // TO DO: optimize this function to do splices in ranges, not individual items.
                        arr.splice(idxs[i], 1);
                    }
                }
            },
            
            /**
             * Comparison function for sorting number data types. Used with Array.prototype.sort.
             */
            numSorter: function ns(a,b) {
                return Number(a)-Number(b);
            },

            stringSorter: function ss(a,b){
                var A = a.toLowerCase();
                var B = b.toLowerCase();
                if (A < B){
                   return -1;
                }else if (A > B){
                  return  1;
                }else{
                  return 0;
                }
            },
            
            /**
             * Removes a given range of indices from a given array.
             * 
             * @param start The starting index (0-based) of the indices to be removed.
             * @param count The number of indices to be removed.
             */
            removeIndices: function removeIds(/*Array*/ arr, /*Integer*/ start, /*Integer*/ count) {
                arr.splice(start, count);
            },
            
            /**
             * Inserts a given array of items into a given array at a given index.
             * 
             * @param {Array} [arr] The array to be inserted into; if missing, a new array is created.
             * @param {Integer} idx The index at which to insert the new items.
             * @param {Array} items The items to be inserted.
             * @returns {Array} The array after insertion.
             */
            insert: function inst(arr, idx, items) {
                if (!arr) {
                    arr = [];
                }
                if (idx == null){
                    idx = arr.length;
                }
                Array.prototype.splice.apply(arr, [idx, 0].concat(items));
                return arr;
            },
            
            /**
             * <p>Creates a hashtable of booleans from the contents of a given array.</p>
             *
             * <p>The array values are used as the hash keys; the hash values are all set to true.</p>
             *
             * @param {Array} arr The array from which to read the hash keys.
             * @returns {Object} The new hashtable.
             */
            hash: function hs(arr) {
                var h = {};
                for (var i=0, len=(arr&&arr.length)||0; i<len; i++) {
                    h[arr[i]] = true;
                }
                return h;
            },
            
            /**
             * Returns a list of the items at the given indices of an array.
             * @param {Array} arr The array whose items are to be read.
             * @param {Array} idxs The list of indices at which the array will be read. If null, null is returned. If empty, an empty array is returned.
             * @return {Array} The subset of array items at the requested indices; possibly empty or null.
             */
            get: function gt(arr, idxs){
                if (!idxs) {
                    return null;
                }
                var ret = [];
                for (var i=0, len=idxs.length; i<len; i++) {
                    ret[i] = arr[idxs[i]];
                }
                return ret;
            },

            /**
             * This function do a deep sort on array of array of objects based on a sortable object property.
             * 
             * The object in the innermost array could have depth 2 or higher.
             * 
             * @param (Array) arr Array to sort 
             * @param (String) prop Property to sort on
             * @param {Integer} idx Index of the property in the object (0-based).
             * 
             * var data = [ //all rows
                  [ //row 1
                      { //col 1
                        text: 'r1 text 1',//text to display
                        icon: 'r1 icon 1'
                      },
                      { //col 2
                        text: 'r1 text 2',//text to display
                        icon: 'icon 2'
                      },
        
                      { //col 3
                        text: 'r1 text 3',//text to display
                        icon: 'icon 3'
                      }
         
                  ],//end row1
        
                [ //row 2
         
                      { //col 1
                        text: 'r2 text 1',//text to display
                        icon: 'r2 icon 1'
                      },
                      { //col 2
                        text: 'r2 text 2',//text to display
                        icon: 'r2 icon 2'
                      },
        
                      { //col 3
                        text: 'r2 text 3',//text to display
                        icon: ' r2 icon 3'
                      }
        
         
                  ], //end row2
                [ //row 3
         
                      { //col 1
                        text: 'ar3 text 1',//text to display
                        icon: 'r3 icon 1'
                      },
                      { //col 2
                        text: 'r3 text 2',//text to display
                        icon: 'r3 icon 2'
                      },
        
                      { //col 3
                        text: 'r3 text 3',//text to display
                        icon: ' r3 icon 3'
                      }
        
         
                  ]//end row3
                ];
             
                Usage: Sort on 'text' whose index is 0 in the sample data 'col' object.
                        deepSort(data, 'text', 0, true);
                 */
            deepSortArr: function deepSortArr(/*Array*/arr, /*String*/prop, /*Integer*/ idx, /*Boolean*/asc) {
                return arr.sort(function(a, b){
                    return (!asc ? (a[idx][prop] <= b[idx][prop]) : (a[idx][prop] > b[idx][prop])) ? -1 : 1;
                    }
                );
            }

        });
    
})();
mstrmojo.EnumReadystate = {
    IDLE: 1,
    WAITING: 3,
    ERROR: 4,
    SUCCESS: 5,
    CANCELLED: 6,
    TIMEOUT: 7
};
(function() {
	var cachedCalls = [];
	function cacheCall (func, args) {
		cachedCalls.push({n: func, args: args});
	}
	function checkLoadingStatus (geo, func, args) {
		var ok = false;
		switch (geo._loadingStatus) {
		case 0: // not loaded
			if (google && google.maps && google.maps.Geocoder) {
				// already exists, may from static loading.
				geo._loadingStatus = 2;
				ok = true;
			} else {
				cacheCall(func, args);
				geo._loadScript();
			}
			break;
		case 1: 
			cacheCall(func, args);
			break;
		case 2:
			ok = true;
			break;
		}
		return ok;
	}
	mstrmojo.GeoLocation = mstrmojo.provide(
		'mstrmojo.GeoLocation',
		{
			/**
			 * Most recent value for the altitude
			 */
			_altitude: null,
			/**
			 * most recent value for the latitude
			 */ 
			_latitude: null,
			/**
			 * Most recent value for the longitude
			 */
			_longitude: null,
			/**
			 * Call backs registered for the pending location request.
			 */
			_callbacks: [],
			_getPos: function(){
				if (mstrMobileApp && mstrMobileApp.getGeoLocation){
					mstrmojo.GeoLocation._getPos = function() {
						mstrMobileApp.getGeoLocation('mstrmojo.GeoLocation.updateLocation');
					};
				} else if (navigator && navigator.geolocation) {
					mstrmojo.GeoLocation._getPos = function() {
						navigator.geolocation.getCurrentPosition(
							function(position) {  
								mstrmojo.GeoLocation.updateLocation(position);
							},
							function(error) {
								switch(error.code){
									case error.TIMEOUT :
										alert( "Retrieve Geo Position: Timeout, please try it again " );
										break;
									case error.PERMISSION_DENIED :
										alert( "Retrieve Geo Position: Permission to use location service has been denied " );
										break;
									case error.POSITION_UNAVAILABLE : 
										alert( "Retrieve Geo Position: Position unavaiable " );
										break;
								}
								mstrmojo.GeoLocation.updateLocation(error);
							},
							//TQMS 581960. Added timeout.
							{maximumAge:10000, timeout:10000}
						);
					};
				} else {
					mstrmojo.GeoLocation._getPos = function() {
						alert("no available Geo Location service");
					};
				}
				mstrmojo.GeoLocation._getPos();
			},
			/**
			 * Method for JavaScript client to request for current location service, when request comes back, the call back will be invoked
			 * 
			 * If this is the first request for the location, a device based location service will be invoked to get current location.
			 * If when this method is called, there is already a pending request for the device, 
			 * then it will not launch another request for the device, this method will simply add itself
			 * into the callbacks query and listening for the upcoming data.
			 */
			getCurrentLocation: function(callbacks){
				// queue call backs
				this._callbacks.push(callbacks);
				if (!this._pending) {
					this._pending = true;
					this._getPos();
				}
			},
			/**
			 * Method for device native code to call after it finds the location.
			 * 
			 */
			updateLocation: function(info){
				var me = mstrmojo.GeoLocation;
                var i,cbs;
//				var s = 'updateLocation --';
//				for (var n in info){
//					s += (n + ':' + info[n] + ',');
//				}
//				alert (s);
				var p = info && info.coords;
				var e = info && info.err;
				if (p){
					// update object
					me._latitude = p.latitude;
					me._longitude = p.longitude;
					
					// invoke call backs
                    cbs = me._callbacks;
                    
                    for (i = 0; i < cbs.length; i ++ ){
						cbs[i].success(p.latitude, p.longitude);
					}
				} else if (e){
					// invoke call backs
                    cbs = me._callbacks;
                    for (i = 0; i < cbs.length; i ++ ){
						cbs[i].failure('Error in updating geo location information.'+e);
					}
				} else {
					// invoke call backs
                    cbs = me._callbacks;
                    for (i = 0; i < cbs.length; i ++ ){
						cbs[i].failure('Error in updating geo location information.');
					}
				}				
				// clear call backs
				me._callbacks = [];
				
				// clear flag
				me._pending = false;
			},
			getCurrentAddress: function(callbacks){
				this.getCurrentLocation({
					success: function(la, lo, al){
						mstrmojo.GeoLocation.findAddress(
								{lat: la, lng: lo}, 
								{
									success: callbacks.success && callbacks.success || mstrmojo.emptyFn,
									failure: callbacks.failure && callbacks.failure || mstrmojo.emptyFn 
							
								}
						);
					}, 
					failure: callbacks.failure && callbacks.failure || mstrmojo.emptyFn
				});
			},
            count:null,
            cbs:null,
            getUniqId:function getUniqId() {
                var c;
                if (!this.count) {
                    c = this.count = 1;
                } else {
                    c = this.count++;
                }
                return "fa"+c;
            },
            findAddress: function findAddress(latlng, callbacks) {
            	if (!mstrMobileApp || !mstrMobileApp.useNativeMap || !mstrMobileApp.useNativeMap()) {
            		this.findAddressUsingJsAPI(latlng,callbacks);
            	} else {
            		this.findAddressUsingNativeAPI(latlng,callbacks);
                }
            },
            findAddressUsingJsAPI:function findAddressUsingJsAPI(latlng,callbacks) {
            	if (checkLoadingStatus(this, 'findAddress', [latlng, callbacks])) {
			    	var geocoder = new google.maps.Geocoder();          
			    	geocoder.geocode(
			    			{location:new google.maps.LatLng(latlng.lat, latlng.lng)}, 
			    			function(results, status) {            
			    				if (status == google.maps.GeocoderStatus.OK && results[0]) {
			    					callbacks.success(results);
			    				} else {
			    					callbacks.failure(results, status);
			    				}
			    			}
			    	);        
				}
            },
            findAddressUsingNativeAPI:function findAddressUsingNativeAPI(latlng,callbacks) {
                var id = this.getUniqId();
                if (this.cbs == null) {
                	this.cbs = {};
                }
                this.cbs[id] = function(result) {
                    if (result.status == "OK") {
                        callbacks.success(result.results);
                    } else {
                        callbacks.failure(result.results, result.status);
                    }
                };
                mstrMobileApp.findAddress(latlng.lat,latlng.lng,'mstrmojo.GeoLocation.findAddressCallback',id);
            },
            findAddressCallback : function findAddressCallback(res,status,id) {
            	this.cbs[id].apply(mstrmojo.GeoLocation,[res]);
            },
		    
		    // dynamic loading Google map API script part
			_loadingStatus: 0,	// 0 for not loaded, 1 for loading, 2 for loaded
			
			_loadScriptCallBack: function _loadScriptCallBack() { 
				this._loadingStatus = 2;
				
				// any call before loading, need to perform now
				for (var i = 0; i < cachedCalls.length; i ++) {
					var c = cachedCalls[i];
					mstrmojo.GeoLocation[c.n].apply(mstrmojo.GeoLocation, c.args);
				}
			}, 
			_loadScript: function _loadScript() {
				this._loadingStatus = 1;
				var script = document.createElement("script"); 
				script.type = "text/javascript"; 
				script.src = "http://maps.google.com/maps/api/js?sensor=false&callback=mstrmojo.GeoLocation._loadScriptCallBack"; 
				document.body.appendChild(script); 
			}
			
		}
	);
	//checkLoadingStatus(mstrmojo.GeoLocation, {});

})();
/**
 * <p>Enables an object to load javascript methods at run-time.</p>
 *
 * @class
 * @public
 */

mstrmojo.LoadedExternalJSURLs = {};

function LoadScriptsExternalJSCallback()
{
	
    //since we processed this url, remove it from the array
    mstrmojo.LoadedExternalJSURLs[mstrmojo._LoadsScript.esScripts.splice(0, 1)[0].url] = true;
	//now load the remaining urls 
	mstrmojo._LoadsScript.requiresExternalScripts(mstrmojo._LoadsScript.esScripts,
                                                  mstrmojo._LoadsScript.callback,
												  mstrmojo._LoadsScript.esScritsContext
												  );
    
	mstrmojo._LoadsScript.ExternalJSCallbackIsBusy = false;
}

mstrmojo._LoadsScript = mstrmojo.provide(
"mstrmojo._LoadsScript",
/**
 * @lends mstrmojo._LoadsScript#
 */
{
    /**
     * @ignore
     */
    _meta_usesSuper: false,

	/**
	 * <p>Ensures that the script for a given method is loaded into this object.</p>
	 *
	 * <p>If this object's property with the given method name points to a function, we assume
	 * that function is the desired method.  Otherwise, we assume we must load a mixin that
	 * implements the method.  The FQCN from the mixin is a string that is assumed to be declared
	 * either:
	 * <ul>
	 * <li>under the method name; or</li>
	 * <li>under the "this.methods" hash, keyed by the method name; or</li>
	 * <li>under the "this.methods" hash, keyed by "*" (meaning, a default mixin for all methods).</li>
	 * </ul>
	 * </p>
     * 
     * @param {String} n The name of the method to be loaded.
     * @returns {Boolean} true if the method is now successfully loaded in this object.
	 */
	requiresMethod: function rqMth(/*String*/ n) {
		if (!n) {
            return;
        }
		
		// Do we have a function for this method?
		if (typeof(this[n]) === "function") {
            return true;
        } else {
			// Try to load the method. We need the FQCN of the mixin that impls the method.
			var fqcn = this[n] || (this.methods && (this.methods[n] || this.methods["*"]));
			if (typeof(fqcn) === "string") {
				this.requiresCls(fqcn);	
				return typeof(this[n]) === "function";
			}
			return false;					
		}
	},

			/**
			 * Loads the requested mixins (if not already loaded), mixes them into the
			 * prototype of this widget's constructor, and then fires given callback.
			 */
			requiresCls: function req(/*Array*/ mixins, /*Function?*/ callback) {
				// TO DO: implement this using async XHR.
				if (mixins) {
					if (typeof(mixins) == "string") {
						mixins = [mixins];
					}
					// XHR get any of the mixins that are not loaded in-memory yet.
					mstrmojo.requiresCls.apply(mstrmojo, mixins);
					// Mix these into the constructor's prototype. Record the mixins
					// we do in a class-level hash, so we don't redo them again later.
					var p = this.constructor.prototype,
						pm = p.mixins;
					if (!pm) {
						p.mixins = {};
						pm = p.mixins;
					}
					var mx = mstrmojo.mixin;
					for (var i=0, len=mixins.length; i<len; i++) {
						var fqcn = mixins[i];
						if (!pm[fqcn]) {
							var m = eval(mixins[i]);
							mx(m, p);
							pm[fqcn] = true;
							// After each mixin, call the mixin's __onmixin__ method (if any) on ourselves.
							if (m.__onmixin__) {
								m.__onmixin__.apply(this, []);
							}
						}
					}
					if (callback) {
						callback.apply(this, []);						
					}
				}
			},
			
			/**
			 * Loads the contributor object identified in the given property. If loaded successfully, 
			 * stores a reference to it in the given property and sets its parent to this widget; otherwise, 
			 * if not loaded successfully, replaces the property value with null.
			 */
			requiresContrib: function reqCb(/*String*/ propName, /*Boolean?*/ bForceStartup) {
				var fqcn = this[propName];
				if (fqcn) {
					var c,
						firstTime = false;
					if (typeof(fqcn) == 'string') {
						c = mstrmojo.registry.ref(fqcn);
						this[propName] = c;
						firstTime = true;
					} else {
						c = fqcn;	// Assume its the contributor object itself.
					}
					// Set the parent and call startup. We do this the first time we initialize
					// the contributor, and additionally if a flag tells us to do it subsequent times.
					if (c && (firstTime || bForceStartup)) {
						c.parent = this;
						if (c.startup) {
							c.startup();
						}
					}
					return c;
				}
				return null;
			},
					
			/**
			 * 
			 * Load the external java scripts synchronously
			 * 
			 */
             requiresExternalScripts : function requiresES(esScripts, callback, context)
			 {
			 	
			 	if(esScripts && esScripts instanceof Array)
				{
					   if (esScripts.length == 0) { //this could be case when user provided only one url and has a call back					   	   
						   
						   callback && callback.call(context);
						   
						   return;
					   } 		
				        
							   
					   //check if the next script to be loaded is in the loaded cache, then skip this one
					   if(esScripts[0].forceReload && esScripts[0].forceReload == false && mstrmojo.LoadedExternalJSURLs [esScripts[0].url])
					   {
					   	
					   	 esScripts.splice(0, 1); //remove this from the array and start loading the remaining urls
					   							 
					   	 return this.requiresExternalScripts(esScripts, callback, context);
					   }
				
					  	var script = document.createElement("script"), isIE = !!document.all;
					  						  	
					  	script.type = "text/javascript";
					  	script.src = esScripts[0].url;
						
						if (!esScripts[0].callbackParamName) {
							if (isIE) {
								//IE: handle <script> Tag state change event:
								script.onreadystatechange = function(){
									//when IE finishes loading/parsing current <script>, continue next
									
									if (script.readyState == "loaded" || script.readyState == "complete") {
										script.onreadystatechange = null; //avoid handling twice
										//load the next script if any here
										if (esScripts.length > 1) {
											//remove the first element which is processed
											
											mstrmojo.LoadedExternalJSURLs [esScripts.splice(0, 1)[0].url] = true;
											mstrmojo._LoadsScript.requiresExternalScripts(esScripts, callback);
										}
										else 
											if (esScripts.length == 1) {
												
											mstrmojo.LoadedExternalJSURLs [esScripts[0].url] = true;
												//call the callback function if any
												if (callback) {										
													callback.call(context);
												}
											}
									}
								}
							}
							else { // for FireFox, safari etc
								script.onload = function(){
								
									script.onload = null; //avoid handling twice
									//load the next script if any here
									if (esScripts.length > 1) {
										//remove the first element which is processed
										 
										mstrmojo.LoadedExternalJSURLs [esScripts.splice(0, 1)[0].url] = true;									
										mstrmojo._LoadsScript.requiresExternalScripts(esScripts, callback);
									}
									else 
										if (esScripts.length == 1) {
												mstrmojo.LoadedExternalJSURLs [esScripts[0].url] = true;
												//call the callback function if any
												if (callback) {										
													callback.call(context);
												}
											
										}
								}
							}
						} //end of if callback param check
						else{
							if(esScripts[0].callbackParamName.length != 0){ //if we have a callback request parameter name then use it
								//check if already someone else is using the global callback method. If yes, then we have to wait for sometime and check back
								if(mstrmojo._LoadsScript.ExternalJSCallbackIsBusy &&
								   mstrmojo._LoadsScript.ExternalJSCallbackIsBusy == true)
								{								
									   var that = this;
                                       window.setTimeout(function()
									                     {           
                                                            that.requiresExternalScripts(esScripts, callback, context);
                                                         }
                                                         ,500);
						               return;
								}
								//indicate the global flag that the callback function is busy
                                mstrmojo._LoadsScript.ExternalJSCallbackIsBusy = true;
								
								//remove the first element which is processed                                
                                script.src += "&" + esScripts[0].callbackParamName + "=LoadScriptsExternalJSCallback" ;
						        
						
								mstrmojo._LoadsScript.esScripts = esScripts;
								mstrmojo._LoadsScript.callback = callback;
								mstrmojo._LoadsScript.esScritsContext = context;
															 
                            }
						}
						
						document.getElementsByTagName("head")[0].appendChild(script);
				}
			 }

});
/**
 * Enumeration for the types of objects in an RW Document.
 * TO DO: lookup real enumerated values from Java source code.
 */
mstrmojo.EnumRWUnitType = {
	LAYOUT: 0,			//was: 1
	HEADER: 2,
	FOOTER: 3,
	SUBSECTION: 4,		//was: 3
	DETAILS: 5,
	PAGEHEADER: 6,
	PAGEFOOTER: 7,
	PANELSTACK: 8,
	PANEL: 9,

    
    // type*10 + displayMode
	GRID: 521,
	GRAPH: 522,
	GRIDGRAPH: 527,
    
	RECTANGLE: 101,
	IMAGE: 102,
	LINE: 105,
	TEXTFIELD: 106,
	HTMLCONTAINER: 107,
	SELECTOR: 111,
    ROUNDEDRECTANGLE: 112,
	VISUALIZATION: 114,
	MOJOVISUALIZATION: 115
};
(function(){
    /**
     * <p>Static class with helper methods for using Function objects.</p>
     * 
     * @class
     */
    mstrmojo.func = mstrmojo.provide(
            
        "mstrmojo.func",
       
        {
            /**
             * <p>Utility function for combining multiple function calls.</p>
             * 
             * @param {Function[]} fn An array of functions to call.
             * 
             * @returns {Function} The wrapper function that will call each of the supplied functions in the order they appear in the <strong>fn</strong> parameter.
             */
            composite: function c(fn) {
                // Is the 'fn' parameter invalid?
                if (!fn || !fn.length) {
                    // Return an empty function
                    return function(){};
                }
        
                return function() {
                    for (var i = 0, len = fn.length; i < len; i++) {
                        fn[i].apply(this, arguments);
                    }
                };
           },
           
           /**
            * @param Object source
            * @param Object [destination]
            * 
            * @returns A new composite object of the source and destination.
            */
           wrapMethods: function wrapMethods(source, destination) {
               // Initialze callback (in case it was null).
               destination = destination || {};

               // Iterate the source object and wrap existing methods (if present in destination) or
               // add source method if not present in destination.
               mstrmojo.hash.forEach(source, function(fn, fnName) {
                   destination[fnName] = (fnName in destination && typeof(fn) == 'function') ? mstrmojo.func.composite( [ fn, destination[fnName] ]) : fn;
               });
               
               return destination;
           }, 
           
           addMethods: function addMethods(source, destination) {
               // Initialze callback (in case it was null).
               destination = destination || {};

               // Iterate the source object and wrap existing methods (if present in destination) or
               // add source method if not present in destination.
               mstrmojo.hash.forEach(source, function(fn, fnName) {
                   if ( ! (fnName in destination) && typeof(fn) == 'function') {
                       destination[fnName] = fn;
                   }
               });
               
               return destination;
           }           
           
        });
})();
(function(){

    /**
     * Mixin to make any Widget a popup that can be opened or closed.
     * 
     * @class
     * @public
     */    
    mstrmojo._IsPopup = {
    
        /**
         * Is set to true at run-time when open() is called; reset to false when close() is called.
         * 
         * @type Boolean
         */
        visible: false,
        
        /**
         * Handle back to the widget that called this popup's open(). Set at run-time in open(). Reset to null when close() is called.
         * 
         * @type mstrmojo.Widget
         */
        opener: null,
        
        /**
         * Customizable event handlers, called when open() is called.
         * 
         * @type Function
         */
        onOpen: null,

        /**
         * Customizable event handlers, called when close() is called.
         * 
         * @type Function
         */
        onClose: null,
        
        /**
         * <p>Opens this popup, meaning makes it visible, calling its render() method if not already rendered.</p>
         * 
         * <p>The given opener is set as the popup's current "opener" property.  An optional set of properties
         * can be passed in the optional "config" argument; if given, these properties are set on the popup before
         * it is made visible.</p>
         * 
         * @param {mstrmojo.Widget} opener The widget that opened this popup.
         * @param {Object} config
         */
        open: function open(/*Widget*/ opener, /*Object?*/ config) {
            // Apply config props, if any. This will be done with a custom method, if the popup defines one;
            // otherwise, it is done by just setting properties.
            if (this.updatePopupConfig) {
                this.updatePopupConfig(config, opener);
            } else     if (config) {
                for (var k in config) {
                    this.set(k, config[k]);
                }
            }
            // Update the opener. Do this before rendering, because setting the opener may cause
            // the contents to update themselves, and it's more efficient to avoid re-rendering DOM updates.
            this.set('opener', opener);
            if (!this.hasRendered) {
                this.render();
            }
            
            // Customization hook.
            if (this.nudge) {
                this.domNode.style.top = '-10000px';
            }
            
            // Ready to show to the end-user.
            this.set('visible', true);
            
            // Customization hook for positioning the popup.
            if (this.nudge) {
                this.nudge();
            }
            
            // Customization hook.
            if (this.onOpen) {
                this.onOpen();
            }
        },
        
        /**
         * <p>Closes this popup, making it invisible.</p>
         * 
         * <p>The "opener" property is reset to null.</p>
         * @param {Object} config Optional configuration settings that will be passed along to the onClose handler (if any).
         */
        close: function cls(config) {
            // Customization hook; execute it before we lose the handle to opener.
            if (this.onClose) {
                this.onClose(config);
            }

            this.set('visible', false);
            this.set('opener', null);
        }
    };
    
})();
(function () {

    /**
     * <p>A mixin for creating the drillLinkItems collection.<p>
     *
     * @class
     * @public
     */
    mstrmojo._HasDrillLinks = mstrmojo.provide(
        'mstrmojo._HasDrillLinks',

        /**
         * @lends mstrmojo._HasDrillLinks.prototype
         */
        {
        	_mixinName: 'mstrmojo._HasDrillLinks',
        	
            update: function update(node) {
                this._super(node);

                var fdl = node.defn.dl,
                    ddl = node.data.dl,
                    dliRef = this.drillLinkItems = ((fdl && fdl.items) || []).concat((ddl && ddl.items) || []).sort(function (a, b) {
                        return a.index - b.index;
                    }),
                    i;

                // TQMS #433815: need to remove the duplicate links. This is also part of the fix for 428594
                // which might introduce additional links.
                for (i = dliRef.length - 1; i >= 0; i--) {
                    if (i && dliRef[i].index === dliRef[i - 1].index) {
                        dliRef.splice(i, 1);
                    }
                }

                if (fdl && fdl.target) {
                    for (i = 0; i < dliRef.length; i++) {
                        dliRef[i].target = fdl.target;
                    }
                }
            }
        }
    );
}());
(function() {

	var DefaultColor = {
			Min: 0xf23225,
			Max: 0x16b932,
			//Invalid: 0xf5f5f7
			Invalid: 0x000000,
            NoColorMetric: 0xf5f5f7
		};
	var BandDirection = {
			LeftToRight: 0,
			RightToLeft: 1,
			Center: 2,
			None: 3
		};

	function getColorInRange(i, s, e){
		if(i < 0 || i > 1){
			return 0x000000;
		}
		var range = 256,
			index = i*range,
			r, g, b,
			sR = s>>16,
			eR = e>>16,
			sG = (s&0xff00)>>8,
			eG = (e&0xff00)>>8,
			sB = (s&0x00ff),
			eB = (e&0x00ff);
		r = sR+Math.floor((index*(eR-sR)/range));
		g = sG+Math.floor((index*(eG-sG)/range));
		b = sB+Math.floor((index*(eB-sB)/range));
		return	b + (g<<8) + (r<<16);
	}

	function darkerHex(h, p){
		var r = h>>16,
			g = (h&0x00ff00)>>8,
			b = (h&0x0000ff);

		r = Math.floor((1-p)*r);
		g = Math.floor((1-p)*g);
		b = Math.floor((1-p)*b);
		return b + (g<<8) + (r<<16);
	}


	function convertBlendToBand(bl){
		var ba = [],
			blc, bac,
			dp = bl.dp,
			l = dp.length,
			blp, bln;
		if(bl == null || bl.length == 0) return [];
		for(var i = 0; i < l; i++){
			bac = {};
			var blp, bap;
			if(i > 0){
				blp = blc;
				blc = bln;
			}
			else{
				blc = dp[i];
			}
			if(i < l - 1){
				bln = dp[i+1];
			}
			bac.sv = (i==0)?blc.v:(blp.v+blc.v)/2;
			bac.ev = (i==l-1)?blc.v:(bln.v+blc.v)/2;
			bac.c = blc.c;
			bac.d = (i==0)?BandDirection.LeftToRight:(i==l-1?BandDirection.RightToLeft:BandDirection.Center);
			ba[i] = bac;
		}
		return ba;
	}

	function convertBandToBlend(ba){
		var bl = [],
			blc, bac,
			dp = ba.dp,
			l = dp.length;
		if(ba == null || ba.length == 0) return [];
		for(var i = 0; i < l; i++){
			blc = {};
			bac = dp[i];
			var s = bac.s,
				e = bac.e;
			blc.c = bac.c;
			switch (bac.d) {

				case BandDirection.LeftToRight:
					blc.v = bac.s;
					break;
				case BandDirection.RightToLeft:
					blc.v = bac.e;
				case BandDirection.Center:
				case BandDirection.None:
				default:
					var avg = (bac.s + bac.e)/2;
					blc.v = avg;
					break;
			}
			bl[i] = blc;
		}
		return bl;
	}


	function getBlendFillInfo(min, max){
		var colors = [],
			alphas = [],
			ratios = [];
		if(this.min == this.max || isNaN(min) || isNaN(max) || min == max){
			colors[0] = getBlendColor.call(this, min);
			colors[1] = getBlendColor.call(this, max);
			alphas[0] = 1;
			alphas[1] = 1;
			ratios[0] = 0;
			ratios[1] = 1;
		}else if (this.min < this.max){
			var c,
				dp = this.blend.dp,
				l = dp.length,
				index = 0;
			colors[index] = getBlendColor.call(this, min);
			alphas[index] = 1;
			ratios[index] = 0;
			index ++;
			for(var i = 0; i < l; i++){
				c = dp[i];
				if(c.v >= min && c.v <= max){
					colors[index] = c.c;
					alphas[index] = 1;
					ratios[index] = (c.v-min)/(max-min);
					index++;
				}
			}
			colors[index] = getBlendColor.call(this, max);
			alphas[index] = 1;
			ratios[index] = 1;
		}
		return {c:colors, a:alphas, r:ratios};
	}
	function getBandFillInfo(min, max){
		var colors = [],
			alphas = [],
			ratios = [];
		if(this.min == this.max || isNaN(min) || isNaN(max) || min == max){
			colors[0] = getBandColor.call(this, min);
			colors[1] = getBandColor.call(this, max);
			alphas[0] = 1;
			alphas[1] = 1;
			ratios[0] = 0;
			ratios[1] = 1;
		}else if (this.min < this.max){
			var dp = this.band.dp,
				l = dp.length,
				a = 0.4,
				c, co, dc,
				index = 0;
			if(min < 0){
				colors[index] = getBandColor(min);
				alphas[index] = 1;
				ratios[index] = 0;
				index++;
				if(max < 1){
					colors[index] = getBandColor(max);
					alphas[index] = 1;
					ratios[index] = 1;
					index ++;
				}
			}
			for(var i = 0; i < l; i++){
				c = dp[i];
				if(c.s > max || c.e < min){
					continue;
				}
				co = c.c;
				dc = darkerHex(co, a);
				var sv = Math.max(c.s, min),
					ev = Math.min(c.e, max);

				if(ev != sv){
					switch (c.d) {
						case BandDirection.LeftToRight:
						case BandDirection.RightToLeft:
						case BandDirection.Center:
							if(sv == c.s){
								colors[index] = (c.d!=BandDirection.LeftToRight) ? dc : co;
							}else{
								colors[index] = getBandColor.call(this, sv);
							}
							ratios[index] = (sv-min)/(max-min);
							alphas[index] = 1;
							index++;
							if(c.d == BandDirection.Center){
								var avg = (c.s+c.e)/2;
								if(avg > sv && avg < ev){
									colors[index] = co;
									ratios[index] = (avg-min)/(max-min);
									alphas[index] = 1;
									index++;
								}
							}

							if(ev == c.e){
								colors[index] = (c.d!=BandDirection.RightToLeft) ? dc : co;
							}else{
								colors[index] = getBandColor.call(this, ev);
							}
							ratios[index] = (ev-min)/(max-min);
							alphas[index] = 1;
							index++;
							break;
						case BandDirection.None:
						default:
							colors[index] = co;
							ratios[index] = (sv-min)/(max-min);
							alphas[index] = 1;
							index++;
							colors[index] = co;
							ratios[index] = (ev-min)/(max-min);
							alphas[index] = 1;
							index++;
							break;
					}
				}
			}
			if(max > 1){
				if(min > 1){
					colors[index] = getBandColor.call(this, min);
					ratios[index] = 0;
					alphas[index] = 1;
					index++;
				}
				colors[index] = getBandColor.call(this, max);
				ratios[index] = 1;
				alphas[index] = 1;
			}

		}
		return {c:colors, a:alphas, r:ratios};
	}


	function getBandColorFromData(v, d){
		var r = 0.4,
			dc = darkerHex(d.c, r),
			mv, p;
		switch(d.d){
			case BandDirection.LeftToRight:
				if(v < d.s)	return d.c;
				if(v > d.e) return dc;
				if(d.s == d.e) return getColorInRange(0.5, d.c, dc);
				p = (v-d.s)/(d.e-d.s);
				return getColorInRange(p, d.c, dc);
			case BandDirection.RightToLeft:
				if(v < d.s)	return dc;
				if(v > d.e)	return d.c;
				if(d.s == d.e) return getColorInRange(0.5, dc, d.c);
				p = (v-d.s)/(d.e-d.s);
				return getColorInRange(p, dc, d.c);
			case BandDirection.Center:
				mv = (d.s+d.e)/2;
				if(v < d.s || v > d.e) return dc;
				if(d.s == d.e) return dc;
				if(v <= mv) {
					p = (v-d.s)/(mv-d.s);
					return getColorInRange(p, dc, d.c);
				}
				p = (v-mv)/(d.e-mv);
				return getColorInRange(p, d.c, dc);
			case BandDirection.None:
			default:
				return d.c;
		}
	}
	function getBlendColor(v){
		if(isNaN(v)){
			return DefaultColor.Invalid;
		}
		if(this.max == this.min){
			return this.blendEqualColor;
		}
		var dp = this.blend.dp,
			l = dp.length;
		if(!this.valid){
			var s = dp[0],
				e = dp[l-1];
			if(v < this.min){
				return s.c;
			}
			return e.c;
		}
		var i, c = dp[0],
			sv = c.v,
			sc = c.c,
			ev, ec;
		for(i = 1; i < l; i++){
			c = dp[i];
			if(c.v >= v) break;
			sv = c.v;
			sc = c.c;
		}
		i = Math.min(i, l-1);
		c = dp[i];
		ev = c.v;
		ec = c.c;
		if(v < sv) return sc;
		if(v > ev) return ec;
		if(sv == ev) return getColorInRange(0.5, sc, ec);
		//if(this.isColorBanding){
				//var p = (v-dp[0].v)/(dp[l-1].v-dp[0].v);
				//return getColorInRange(p,dp[0].c,dp[l-1].c);
		//}
		//else{

		var p = (v-sv)/(ev-sv);
		return getColorInRange(p, sc, ec);
		//}

	}

	function getBandColor(v){
		if(isNaN(v)) return DefaultColor.Invalid;
		if(this.min == this.max) return this.bandEqualColor;
		var dp = this.band.dp,
			l = dp.length;
		if(!this.valid){
			var s = dp[0],
				e = dp[l-1];
			if(v < this.min){
				return getBandColorFromData(e.s, s);
			}else{
				return getBandColorFromData(e.e, e);
			}
		}
		for(var i = 0; i < l; i++){
			c = dp[i];
            if(c.s === c.e) {
                continue;
            }
			if(c.s <= v && v <= c.e){
				return getBandColorFromData(v, c);
			}
		}
	}



	function createDefaultBlendDataProvider(min, max){
		this.blend.dp = [];
		var dp = this.blend.dp,
			bc;// blend color
		bc = {};
		bc.c = min;//color
		bc.v = 0;//value
		dp[0] = bc;

		bc = {};
		bc.c = max;//direction
		bc.v = 1;//start color
		dp[1] = bc;
	}

	function createDefaultBandDataProvider(min, max){
		this.band.dp = [];
		var dp = this.band.dp,
			bc;// band color
		bc = {};
		bc.d = BandDirection.LeftToRight;//direction
		bc.s = 0;//start color
		bc.e = 0.5;//end color
		bc.c = min;//color
		dp[0] = bc;

		bc = {};
		bc.d = BandDirection.LeftToRight;
		bc.s = 0.5;
		bc.e = 1;
		bc.c = max;
		dp[1] = bc;
	}
	function createBlendTooltipInfo(c, w, d){
		var ar = [],
			sx = 0,
			sv, ev,
			min = this.min,
			max = this.max,
			tc = d.legendTickCount,
			rt = {}, //region
			co,
			valid = !isNaN(this.min) && !isNaN(this.max);

		if(this.min >= this.max || this.blend.dp.length <= 2){
			var f = (max-min)/tc;
			for(var i = 0; i < c; i++){
				rt = {x:sx, w:Math.floor(w/tc)};
				sx += rt.w;
				if(valid){
					sv = min + i*f;
					ev = sv + f;
					co = this.getColor((sv+ev)/2);
				}else{
					sv = "Null";
					ev = "Null";
					co = 0x000000; //black
				}
				ar.push({r:rt, c:co, sv:sv, ev:ev});
			}
		}else{
			var dp = this.blend.dp,
				l = dp.length;
			for(var i = 0; i < l; i++){
				var item = dp[i],
					p, n;
				if(i == 0){
					sv = min;
				}else{
					p = dp[i-1];
					sv = min + (max-min)*(item.v+p.v)/2;
				}
				if(i == l-1){
					ev = max;
				}else{
					n = dp[i+1];
					ev = min + (max-min)*(item.v+n.v)/2;
				}
				rt = {x:sx, w:Math.floor(w*(ev-sv)/(max-min))};
				sx += rt.w;
				if(valid){
					co = this.getColor((sv+ev)/2);
				}else{
					sv = "Null";
					ev = "Null";
					co = 0x000000; //black
				}
				ar.push({r:rt, c:co, sv:sv, ev:ev});
			}
		}
		this.tooltipInfo = ar;
	}
	function createBandTooltipInfo(c, w, d){
		var ar = [],
			sx = 0,
			sv, ev,
			min = this.min,
			max = this.max,
			tc = d.legendTickCount,
			rt = {}, //region
			co,
			st, // string
			valid = !isNaN(this.min) && !isNaN(this.max);
		if(this.min >= this.max){
			for(var i = 0; i < c; i++){
				rt = {x:sx, w:Math.floor(w/tc)};
				st += rt.w;
				if(valid){
					st = sv + " < " + ms + " < " + ev;
					co = this.getColor(min);
				}else{
					sv = "Null";
					ev = "Null";
					co = 0x000000; // black
				}
				ar.push({r:rt, c:co, sv:sv, ev:ev});
			}
		}else{
            var imax, imin;
            if(this.isFixedColorBanding) {
                imax = this.initMax;
                imin = this.initMin;
            } else {
                imax = max;
                imin = min;
            }
			var dp = this.band.dp,
				l = dp.length;
			if(l <= 2){
				for(var i = 0; i < l; i++){
					var item = dp[i];
					if(i == 0){
						sv = imin;
					}else{
						sv = imin + (imax-imin)*item.s;
					}
					if(i == l-1){
						ev = imax;
					}else{
						ev = imin + (imax-imin)*item.e;
					}
                    if(sv < min) {
                        sv = min;
                    }
                    if(ev > max) {
                        ev = max;
                    }
                    if(sv > ev && ev >= max) {
                        sv = max;
                        ev = max;
                    } else if(ev < sv && sv <= min) {
                        sv = min;
                        ev = min;
                    }
					rt = {x:sx, w:Math.floor(w*(ev-sv)/(max-min)/2)};
					sx += rt.w;
					if(valid){
						ev = (sv+ev)/2;
						co = this.getColor((sv+ev)/2);
					}else{
						sv = "Null";
						ev = "Null";
						co = 0x000000; // black
					}
					ar.push({r:rt, c:co, sv:sv, ev:ev});

					sx += rt.w;
					var bw = w*(ev-sv)/(max-min)/2;
					rt = {x:sx, w:Math.ceil(bw)};
					if(i > 0){
						var pr = ar[ar.length-1].r;
						if(rt.x < pr.x + pr.w+1){
							pr.w = rt.x - pr.x;
						}
					}
					sx += Math.floor(bw);
					if(valid){
						sv = (sv+ev)/2;
						co = this.getColor((sv+ev)/2);
					}else{
						sv = "Null";
						ev = "Null";
						co = 0x000000; // black
					}
					ar.push({r:rt, c:co, sv:sv, ev:ev});
				}
			}
			else{
				for(var i = 0; i < l; i++){
					var item = dp[i];
					if(i == 0){
						sv = d.props.legendAsc ? imin : imax;
					}else{
						sv = d.props.legendAsc ? imin + (imax-imin)*item.s
								: imax + (imin-imax)*item.s;
					}
					if(i == l-1){
						ev = d.props.legendAsc ? imax : imin;
					}else{
						ev = d.props.legendAsc ? imin + (imax-imin)*item.e
								: imax + (imin-imax)*item.e;
					}
                    if(sv < min) {
                        sv = min;
                    }
                    if(ev > max) {
                        ev = max;
                    }
                    if(sv > ev && ev >= max) {
                        sv = max;
                        ev = max;
                    } else if(ev < sv && sv <= min) {
                        sv = min;
                        ev = min;
                    }
					var bw = w*(ev-sv)/(max-min);

					rt = {x:sx, w:Math.ceil(bw)};
					if(i > 0){
						var pr = ar[ar.length-1].r;
						if(rt.x < pr.x + pr.w+1){
							pr.w = rt.x - pr.x;
						}
					}
					if(i == l - 1){
						rt.w = w - sx;
					}
					sx += Math.floor(bw);
					var sign = d.props.legendAsc ? " < " : " > ";
					if(valid){
						co = this.getColor((sv+ev)/2);
					}else{
						sv = "Null";
						ev = "Null";
						co = 0x000000; // black
					}
					if(sign){
						ar.push({r:rt, c:co, sv:sv, ev:ev});
					}else{
						ar.push({r:rt, c:co, sv:sv, ev:ev, sign:">"});
					}

				}
			}
		}
		this.tooltipInfo = ar;
	}
	mstrmojo.VisHeatMapColorTheme = {
		newInstance:function(){
			return {
				initialize : function prepareData(){
					this.blend = {};
					this.band = {};
					this.valid = true;
					this.blendEqualColor = 0;
					this.bandEqualColor = 0;
					this.isBlend = true;
					this.setDefaultDataProvider();
					this.checkMinMax();
				},


				getGradientFillInfo: function getGradientFillInfo(min, max){
					var tmin, tmax;
					if(isNaN(min) || isNaN(max)){
						if(this.isBlend){
							return getBlendFillInfo.call(this, min, max);
						}else{
							return getBandFillInfo.call(this, min, max);
						}
					}
					if(this.min == this.max){
						if(min < this.min){
							tmin = 0;
						}else{
							tmin = 1;
						}
						if(max < this.max){
							tmax = 0;
						}else{
							tmax = 1;
						}
					}else{
						if(this.isFixedColorBanding){
								var d = this.initMax - this.initMin;
								tmin = (min-this.initMin)/d;
								tmax = (max-this.initMin)/d;
						}
						else{
								var d = this.max-this.min;
								tmin = (min-this.min)/d;
								tmax = (max-this.min)/d;
						}
					}
					if(this.isBlend){
						return getBlendFillInfo.call(this, tmin, tmax);
					}else{
						return getBandFillInfo.call(this, tmin, tmax);
					}
				},

				checkMinMax: function checkValid(){
					var cmin = this.min,
						cmax = this.max;
					if(cmin > cmax){
						this.valid = false;
					}else if(cmin == cmax){
						cmin = cmax = 1; // workaround to get the correct color
						var dp = this.blend.dp,
							l = dp.length,
							c,
							index;

						for(var i = l - 1; i >= 0; i--){
							c = dp[i];
							if(i == l - 1 && c.v <= cmin){
								this.blendEqualColor = c.c;
								break;
							}
							if(i == 0 && c.c >= cmin){
								this.blendEqualColor = c.c;
								break;
							}
							if(i > 0 && c.c >= cmin){
								var pc = dp[i-1];
								if(pc.c < cmin){
									index = (cmin-pc.v)/(c.v-pc.v);
									this.blendEqualColor = getColorInRange(index, pc.c, c.c);
									break;
								}
							}
						}
						dp = this.band.dp;
						l = dp.length;
						for(var i = 0; i < l; i++){
							c = dp[i];
							if((i == 0 && c.s >= cmin)
								||(i == l - 1 && c.e <= cmin)
								||(c.s <= cmin && c.e >= cmin)){
								this.bandEqualColor = c.c;
								break;
							}
						}
					}
					//if(this.isFixedColorBanding){
						//var fixedBandingString = this.convertFixedValueToBlendString(this.fixedBandingArray,{max:cmax,min:cmin});
						//this.createDataProviderFromString(fixedBandingString,"");
//
					//}
				},

				setDefaultDataProvider: function setDefaultData(){
					createDefaultBlendDataProvider.call(this, DefaultColor.Min, DefaultColor.Max);
					createDefaultBandDataProvider.call(this, DefaultColor.Min, DefaultColor.Max);
					this.useDefault = true;
				},
				getColor: function getColorForValue(v){
                    if(this.hasNoColorMetric)
                            return DefaultColor.NoColorMetric;
					var value = NaN;
					if(isNaN(v)) value == 0;
					else if(this.min == this.max){
						value = v < this.min ? 0 : 1;
					}else{
						if(this.isFixedColorBanding)
							value = (v-this.initMin)/(this.initMax-this.initMin);
						else
							value = (v-this.min)/(this.max-this.min);
					}
					if(this.isBlend){
						return getBlendColor.call(this, value);
					}else{
						return getBandColor.call(this, value);
					}
				},

				isBrightColor: function isBrightColor(c){
					var r = c>>16,
						g = (c&0x00ff00)>>8,
						b = (c&0x0000ff),
						bright = (r*299+g*587+b*114)/1000;
					if(bright>150) return true;
					return false;
				},
				getContrastColor: function getContrastColor(c){
					if(this.isBrightColor(c)){
						return 0x000000;//black
					}
					return 0xffffff;//white
				},
				//t: tick count, w: legend width, d: widget delegate
				createTooltipInfo: function createTooltipInfo (t, w, d){
					var count = 0;
					if(this.min >= this.max){
						count = 1;
					}else {
						var l;
						if(this.isBlend){
							l = this.blend.dp.length;
							count = (l <= 2) ? 5 : l;
						}else{
							l = this.band.dp.length;
							count = (l <= 2) ? 4 : l;
						}
					}
					if(this.isBlend){
						createBlendTooltipInfo.call(this, count, w, d);
					}else{
						createBandTooltipInfo.call(this, count, w, d);
					}
				},

				getTooltipInfo: function getTooltip(v){
					var t = this.tooltipInfo;
					for(var i = 0; i < t.length; i++){
						var item = t[i],
							rect = item.r;
						if(v >= rect.x && v < rect.x + rect.w){
							return i;
						}
					}
					return i-1;
				},

				getMaxMinByMetricID: function(model,id){
						var col = model.gts.col,
						len = col.length,
						i = 0,
						index = null
						range = {min:null,max:null};

						for(i = 0; i < len && index == null; i++){
							var es = col[i].es,
								lenes = es.length,
								j;
							for(j = 0; j < lenes; j++){
								if(es[j].oid == id){
									index = j;
									break;
								}
							}
						}
						if(index == null)
							return range;
						var gvs = model.gvs.items,
							len = gvs.length;
						for(i = 0; i < len; i++){
							var value = parseFloat(gvs[i].items[index].rv);
							if(range.min == null)
								range.min = value;
							if(range.max == null)
								range.max = value;
							if(range.min > value)
								range.min = value;
							if(range.max < value)
								range.max = value;
						}
						return range;
				},
				convertFixedValueToBlendString: function(fixedBandingArray,range){
						var convertedBlend = "";
						if(fixedBandingArray.length%2 == 0){
								var length = fixedBandingArray.length,
								min = range.min,
								max = range.max,
								i = 0;

								//blendArray[0] = 0;
								//blendArray[length-2] = 1;
								//blendArray[0] = min;
								//blendArray[length-2] = max;
								var delta = max - min;
								convertedBlend = '0,'+fixedBandingArray[1];
								for(i = 2; i < length-2; i += 2){
										var value = parseInt(fixedBandingArray[i]);
										if(value < min || value > max)
												continue;
										else{
												var colorIndex = (value-min)/delta;
												convertedBlend += ',' + colorIndex + ',' + fixedBandingArray[i+1];
										}
								}
								convertedBlend += ',1,' + fixedBandingArray[length-1];

								//for(i = 0; i < length; i++){
								//if(i != length-1)
								//convertedBlend += blendArray[i] + ',';
						//else
								//convertedBlend += blendArray[i];
								//}
						}
						return convertedBlend;
				},

                convertFixedValueToBandString: function(string, range) {
                        var a = string.split(','),
                            len = a.length,
                            i,
                            d = range.max - range.min;
                        var ret = '';
                        if(len % 4 === 0) {
                            for(i = 0; i < len; i+=4){
                                var j = 0;
                                for(j = 0; j < 2; j++) {
                                    var v,
                                        str = a[i + j];
                                    if(str === 'min') {
                                        v = range.min;
                                    } else if(str === 'max') {
                                        v = range.max;
                                    } else {
                                        v = parseFloat(a[i + j]);
                                    }
                                    if(!isNaN(v)) {
                                        a[i + j] = String((v - range.min) / d);
                                    } else {
                                        console.log('warning: invalid band string. In heatmap color theme');
                                    }
                                }
                            }
                            for(i = 0; i < len; i++) {
                                ret += (a[i] + ',');
                            }
                            ret = ret.substring(0, ret.length - 1);
                        } else {
                            console.log('warning: Invalid band color string. In heatmap color theme');
                        }
                        return ret;
                },

				convertAbsoluteToBlend: function(heatMap,propValue){
						this.useDefault = false;
						this.isColorBanding = true;
						var abs = propValue.abs.replace(/&quot;/g, '"')
												.replace(/&gt;/g, '>')
												.replace(/&lt;/g, '<')
												.replace(/&amp;/g, '&');
						abs = (new window.DOMParser()).parseFromString(abs,"text/xml");
						var absM = abs.getElementsByTagName('m')[0];
						//absM = abs.firstChild.firstElementChild;
						heatMap.absoluteColorID = absM.getAttribute('id');
						this.isFixedColorBanding = true;
						this.fixedBandingArray= absM.getAttribute('bl').split(',');
						var	range;
						//if(isNaN(this.min) || isNaN(this.max))
						//	heatMap.setShow();
						//
						// we need to exclude the deleted rectangles first
						if(!isNaN(this.min) && !isNaN(this.max))
							range = {max: this.max, min: this.min};
						else{
								range = this.getMaxMinByMetricID(heatMap.model,heatMap.absoluteColorID);
								this.max = range.max;
								this.min = range.min;
						}
						if(isNaN(this.initMax) || isNaN(this.initMin)){
								range = this.getMaxMinByMetricID(heatMap.model,heatMap.absoluteColorID);
								this.max = range.max;
								this.min = range.min;
								this.initMax = range.max;
								this.initMin = range.min;
						}
						//if(range.min == null || range.max == null)
								//return ;
						//propValue.bandColors = absM.getAttribute('ba');
                        propValue.bandColors = this.convertFixedValueToBandString(absM.getAttribute('ba'), range);
						propValue.gradientColors = this.convertFixedValueToBlendString(this.fixedBandingArray,range);
				},


				createDataProviderFromString: function createDataProvider(bl, ba){
					var arr = bl.split(','),
						i = 0,
						dp;
					this.blend.dp = [];
					this.useDefault = false;
					dp = this.blend.dp;
					if(arr.length % 2 == 0){
						while(i < arr.length){
							var c = {};
							c.v = parseFloat(arr[i]);
							i++;
							c.c = parseInt(arr[i]);
							i++;
							dp[dp.length] = c;
						}
					}
					i = 0;
					arr = ba.split(',');
					this.band.dp = [];
					dp = this.band.dp;
					if(arr.length % 4 == 0){
						while(i < arr.length){
							var c = {};
							c.s = parseFloat(arr[i]);
							i++;
							c.e = parseFloat(arr[i]);
							i++;
							c.c = parseInt(arr[i]);
							i++;
							var str = arr[i];
							switch(str){
								case "leftToRight":
									c.d = BandDirection.LeftToRight;
									break;
								case "rightToLeft":
									c.d = BandDirection.RightToLeft;
									break;
								case "center":
									c.d = BandDirection.Center;
									break;
								default:
									c.d = BandDirection.None;
							}
							i++;
							dp[dp.length] = c;
						}
					}
				}
			};
		}
	}

})();

(function () {

    mstrmojo.requiresCls("mstrmojo._HasDrillLinks",
                         "mstrmojo.registry",
                         "mstrmojo.hash",
                         "mstrmojo.dom");

    var $DOM = mstrmojo.dom;

    // Private method walks the ancestors of the given widget to
    // search for the container in which the Menu is located.
    /**
     * Walks the ancestors of a given {@link mstrmojo.Widget} to search for the container in which the Menu is located.
     * 
     * @param {mstrmojo.Widget} widget The widget to search.
     * 
     * @private
     */
    function getPopupDelegate(widget) {
        var w = widget;
        while (w) {
            if (w.openDrillLinkMenu) {
                return w;
            }
            w = w.parent;
        }

        return null;
    }


    /**
     * <p>A mixin for instances of {@link mstrmojo.DocTextfield} and {@link mstrmojo.DocImage}
     * that have Drill Links.</p>
     * 
     * <p>This mixin adds a button to TextFields and Images that have Drill Links.</p>
     *
     * @class
     * @extends mstrmojo._HasDrillLinks
     * 
     * @public
     */
    mstrmojo._HasHoverButton = mstrmojo.provide(
        'mstrmojo._HasHoverButton',

        /**
         * @lends mstrmojo._HasHoverButton#
         */
        mstrmojo.hash.copy(mstrmojo._HasDrillLinks, {
            /**
             * The name to identify this mixin. Required by {@link mstrmojo.DynamicClassFactory}.
             */
            _mixinName: 'mstrmojo._HasHoverButton',

            buttonNodeMarkup: '<div class="mstrmojo-LinkInfo-buttonNode"></div>',

            init: function init(p) {
                this._super(p);

                this.markupSlots.buttonNode = function () { return this.domNode.lastChild; };
            },

            postBuildRendering: function pstBldRnd() {
                if (!this.hoverBtn) {
                    this.addChildren(mstrmojo.registry.ref({
                        scriptClass: "mstrmojo.Button",
                        slot: "buttonNode",
                        alias: "hoverBtn",

                        onclick: function onclick() {
                            this.openPopup();
                        },

                        openPopup: function openPopup() {
                            var dl = getPopupDelegate(this);
                            if (dl) {
                                dl.openDrillLinkMenu({
                                    openerButton: this,
                                    drillLinkItems: this.parent.drillLinkItems,
                                    cmPos: this.cmPos
                                });
                            }
                        },

                        closePopup: function closePopup() {
                            var dl = getPopupDelegate(this);
                            if (dl) {
                                dl.closeDrillLinkMenu();
                            }
                        }

                    }));
                }

                var ret = this._super();

                // Attach contextmenu event.
                var id = this.id;
                $DOM.attachEvent(this.domNode, 'contextmenu', function (e) {
                    mstrmojo.all[id].oncontextmenu(e, self);
                });

                return ret;
            },

            /**
             * Handle rightclick to open context menu popup.
             * 
             * @param {DOMEvent} e The HTML DOM Event object.
             * @param {HTMLElement} hWin The DomWindow.
             * 
             */
            oncontextmenu: function (e, hWin) {
                var btn = this.hoverBtn;
                btn.cmPos = $DOM.getMousePosition(e, hWin);
                btn.openPopup();
                btn.cmPos = null;

                $DOM.preventDefault(hWin, e);
            }
        })
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.func",
                         "mstrmojo.hash");
    
	var $WRAP = mstrmojo.func.wrapMethods;
	function wrapCallback(callback, argv, method, idx, me) {
		return $WRAP({
            success: function (res) {
                if (mstrMobileApp && mstrMobileApp.sendCallback) {
                    mstrMobileApp.sendCallback('success', argv.target, JSON.stringify(argv.memo), JSON.stringify(res));
                }
            },
            complete: function () {
                if (mstrMobileApp && mstrMobileApp.sendCallback) {
                    mstrMobileApp.sendCallback('complete', argv.target, JSON.stringify(argv.memo));
                }        
                me.removeCallback(method, idx);
            },
            failure: function (res) {
                if (mstrMobileApp && mstrMobileApp.sendCallback) {
                    mstrMobileApp.sendCallback('failure', argv.target, JSON.stringify(argv.memo), JSON.stringify(res));
                }                            
            }
        }, callback);
	}
	
    mstrmojo._CanProxyCallback = mstrmojo.provide(
            
        'mstrmojo._CanProxyCallback', 
        
        {    
            _mixinName: "mstrmojo._CanProxyCallback",
            
            callbacks: null,
            
            isCallbackReceiver: false,
            
            newCallback: function newCallback(props) {
                //TQMS 670114, use just one webview to show map's info window, so we disabled the callback forwarding feature
                //TODO: remove the file completely and modify other JS files
                return props;
                //
                var cbs = this.callbacks,
                    cb = mstrmojo.hash.copy(props), //set proxy flag so that we know the callback needs to be proxyed
                    idx = (props.index !== undefined) ? String(props.index) : 'index',
                    args = arguments.callee.caller.arguments,
                    argv,
                    i,
                    len,
                    method = props.method || 'anonymous';
                if (!cbs) {
                    cbs = this.callbacks = {};
                }
                
                if (!cbs[method]) {
                    cbs[method] = {};
                } 
                
                //Is the caller a callback proxy receiver?
                if (!this.isCallbackReceiver) {
                    for (i = 0, len = args.length; i < len; i++) {
                        argv = args[i];
                        if (argv && argv.target) {
                            cb = wrapCallback(cb, argv, method, idx, this);
                            break;
                        }
                    }
                }
                
                //if there is no doc model method is provided, we set the memo to the callback object proxy property
                if (!props.method) {
                	cb.proxy = this.getCallbackMemo();
                }
                
                cbs[method][idx] = cb;
                return cb;                
            },
            
            anonymous: function (params, callback, config, argv) {
                if (!this.isCallbackReceiver) {
	            	callback = wrapCallback(callback, argv, 'anonymous', 'index', this);	            	
	            	mstrApp.serverRequest(params, callback, config);
            	}
            },
            
            getCallback: function getCallback(method, index) {
                var idx = index || 'index',
                    cbs = this.callbacks;
                return cbs && cbs[method] && cbs[method][idx];
            },
            
            removeCallback: function removeCallback(method, index) {
                var idx = index || 'index',
                    cbs = this.callbacks;
                if (cbs && cbs[method]) {
                    delete cbs[method][idx];
                    if (mstrmojo.hash.isEmpty(cbs[method])) {
                        delete cbs[method];
                    }
                }
            },

            getCallbackMemo: function getCallbackMemo(method, index) {
                return {
                    target: 'mstrmojo.all["' + this.id + '"].receiveCallback',
                    memo: {
                        method: method || 'anonymous',
                        index: index || 'index'
                    }
                };
            },
            
            receiveCallback: function receiveCallback(fn, memo, res) {
                var method = memo.method,
                    idx = memo.index,
                    cb = this.getCallback(method, idx);
                
                if (cb && fn && cb[fn]) {
                    cb[fn](res);
                }
            }
        }
    );
    
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.EnumReadystate");

    var $READYSTATE = mstrmojo.EnumReadystate;

    /**
     * The number of milliseconds to delay the wait icon.
     *
     * @private
     * @ignore
     */
    var DELAY = 1200;

    /**
     * Hides or Shows the wait icon.
     *
     * @param {Boolean} v True to display wait icon, False to hide it.
     * @param {HTMLElement} [w] The element to hide/show.  If undefined, the function will exit.
     *
     * @private
     * @ignore
     */
    var fnToggle = function (v, w) {
        if (w) {
            w.style.display = (v) ? 'block' : 'none';
        }
    };

    /**
     * <p>A mixin for {@link mstrmojo.Container}s that wish to contain a progress/wait icon.</p>
     *
     * @class
     * @public
     */
    mstrmojo._HasWaitIcon =
        /**
         * @lends mstrmojo._HasWaitIcon#
         */
        {
            /**
             * Holds a handle to the wait icon timeout.
             *
             * @private
             */
            waitHandle: null,

            /**
             * Extends the postBuildRendering method so that, after rendering, this widget will listens for
             * readyState changes and displays/hides the wait icon as needed.
             *
             * @see mstrmojo.Model
             * @ignore
             */
            postBuildRendering: function pstBldRndr() {
                // Attach an event listener to hear when the readyState of the definition node changes.
                if (!this._rsl) {
                    var id = this.id;
                    this._rsl = this.defn.attachEventListener('readyStateChange', id, function (evt) {
                        // Has the widget NOT been rendered?
                        if (!this.hasRendered) {
                            // TQMS #541318: Exit, since we don't need to show any state
                            return;
                        }

                        switch (evt.value) {
                        case $READYSTATE.WAITING:
                            // Do we not already have a wait icon?
                            if (!this.waitIcon) {
                                // Create the element.
                                var icon = document.createElement('div');
                                icon.className = 'mojo-overlay-wait'; // use 'mojo-inline-wait for single icon at 15.15 with no overlay.

                                // Add divs to hold overlay and centered icon.
                                icon.innerHTML = '<div class="overlay"></div><div class="icon"></div>';

                                // Append to widget DOM node.
                                this.domNode.appendChild(icon);

                                // Stick it in a slot so it will be cleaned up later.
                                this.addSlots({
                                    waitIcon: icon
                                });
                            }

                            // Cache the wait icon.
                            var wi = this.waitIcon;

                            // Should we delay the appearance of the wait icon?
                            if (DELAY) {
                                // Set handle to timeout function.
                                this.waitHandle = window.setTimeout(function () {
                                    // Clear the timeout handle.
                                    if (mstrmojo.all[id]) {
                                        mstrmojo.all[id].waitHandle = null;
                                    }

                                    // Display the wait icon.
                                    fnToggle(true, wi);
                                }, DELAY);

                            } else {
                                // Display the wait icon immediately.
                                fnToggle(true, wi);

                            }
                            break;

                        case $READYSTATE.IDLE:
                            // Do we have a handle to a timeout used to display the delayed wait icon?
                            if (this.waitHandle) {
                                // Clear timeout and handle.
                                window.clearTimeout(this.waitHandle);
                                this.waitHandle = null;
                            }

                            // Hide the wait icon.
                            fnToggle(false, this.waitIcon);
                            break;
                        }
                    });
                }

                return this._super();
            }
        };
}());
(function(){
    mstrmojo.requiresCls("mstrmojo.array");
    
    mstrmojo.requiresDescs(4891);
    var _A = mstrmojo.array,
        ELEM_ALL_ID = 'u;',
        ELEM_DUMMY_ID = '-1';
    
    /**
     * A utility class for working with Element ID formatting
     * 
     * @class
     */
    mstrmojo.elementHelper = mstrmojo.provide(
        "mstrmojo.elementHelper",
        {
            
            /**
             * With browseElements task, we get the elements terse id with format of "hxxx;;display name",
             * here we need to reconstruct it to the format of "hxxx;<att_id>;display name".
             * And if the delDT is set to true, it means we don't need the display name. Just build it as "hxxx;<att_id>"
             * @param elems
             * @param attrId
             * @param delDT
             * @return
             */
            buildElemsTerseID: function buildElemsTerseID(elems, attrId, delDN) {
                var item;
                for (var i in elems) {
                    item = elems[i];
                    if (item.v) {
                        var vs = item.v.split(';');
                        if (vs && vs.length > 1) {
                            vs[1] = attrId;
                            
                            //delete the display name part, if the delete flag is set to true
                            if (delDN && vs.length > 2) {
                                vs.pop();
                            }
                            item.v = vs.join(';');
                        }
                    }
                }
                
                return elems;
            },
            /**
             * Compute the element selected count out of the total count for given number
             * @param ces current selected elements
             * @param elems the total elements
             * @return (sc of tc) or (tc) if sc == tc
             */
            buildElemsCountStr: function buildElemsCountStr(ces, elems) {
                if (!ces || !ces.length || !elems || !elems.length) {
                    return '';
                }
                
                var sc = ces.length, 
                    tc = elems.length;
                
                // Remove the all item from count
                if (_A.find(elems, 'v', ELEM_ALL_ID) > -1) {
                    tc -= 1;
                }
                // Remove the dummy item from count
                if (_A.find(elems, 'v', ELEM_DUMMY_ID) > -1) {
                    tc -= 1; 
                }
                
                // Consider user select All item
                if (_A.find(ces, 'v', ELEM_ALL_ID) > -1 || _A.indexOf(ces, ELEM_ALL_ID) > -1) {
                    sc = tc;
                }
                
                // Builde the string
                if (sc >= tc) {
                    return '(' + tc + ')';
                } else {
                	// #560790. use descriptor instead of hard coded string
                    return mstrmojo.desc('4891').replace('##', sc).replace('###', tc);
                }
            }               
        });
})();
/**
 * _MobileGraphAreaHelper.js
 * @author Jamshed Ghazi
 * Copyright 2011 MicroStrategy Incorporated. All rights reserved.
 *
 * @fileoverview <p>Mixin that provides all the code to find areas with respect to current points.</p>
 * @version 1.0
 */
(function () {

    mstrmojo.requiresCls("mstrmojo.array");

    var MAX_TOOLTIPS = 10, //For now support maximum of 10 tooltips.
        TOOLTIP_PADDING = 20,
        tooltipPositionChanged = false,
        rightTooltipPositionChanged = false,
        maxAreasToShow = MAX_TOOLTIPS,
        tooltipsToPosition = [],
        $ARR = mstrmojo.array,
        hasLargeTooltip = false,    // to record if any tooltip does not fit either at left or right of the marker
        TOOLTIP_PADDING_LEFT_RIGHT, // left and right side padding for tooltips
        topTitleHeight;


    /**
     * Area Shape enumerations.
     */
    var AreaShapePolygon = 6,
        AreaShapeRectangle = 7,
        AreaShapeCircle = 100,
        AreaShapeRingSector = 101,
        AreaShapeNormalSector = 102,
        AreaShapeCylinder = 103;

    function drawPoly(ctx, pointsArray, clr) {
        // init start values need to close polygon at this point most probably ????
        var startX = pointsArray[0],
            startY = pointsArray[1],
            j;

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        for (j = 2; j < pointsArray.length - 1; j = j + 2) {
            ctx.lineTo(pointsArray[j], pointsArray[j + 1]);
        }
        ctx.lineTo(startX, startY); // close the poly

        // set the fill color
        ctx.fillStyle = clr;

        ctx.stroke();

        ctx.fill();
    }

    function drawRectangle(ctx, pointsArray, clr) {
        var x = pointsArray[0],
            y = pointsArray[1],
            width = pointsArray[2] - x,
            height = pointsArray[3] - y;

        ctx.fillStyle = clr;

        ctx.strokeRect(x, y, width, height);
        ctx.fillRect(x, y, width, height);
    }

    function drawRingSector(ctx, pointsArray, clr) {
        var centerX = pointsArray[0],
            centerY = pointsArray[1],
            innerRadius = pointsArray[2],
            outerRadius = pointsArray[3],
            startAngle = pointsArray[4],
            endAngle = pointsArray[5];

        ctx.beginPath();
        //mpCanvas->AddArc(irCenter.x, irCenter.y, iOutRadius, iStartAngle, iEndAngle, false);
        ctx.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);
        //LineTo(irCenter.x + iInRadius * std::cos(iEndAngle), irCenter.y + iInRadius * std::sin(iEndAngle));
        ctx.lineTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));
        //mpCanvas->AddArc(irCenter.x, irCenter.y, iInRadius, iEndAngle, iStartAngle, true);
        ctx.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);

        ctx.closePath();

        // set the fill color
        ctx.fillStyle = clr;
        ctx.stroke();
        ctx.fill();

    }

    function drawNormalSector(ctx, pointsArray, clr) {
        var centerX = pointsArray[0],
            centerY = pointsArray[1],
            radius = pointsArray[2],
            startAngle = pointsArray[3],
            endAngle = pointsArray[4],
            scale = pointsArray[5];
        ctx.scale(1, scale);
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);
        ctx.lineTo(centerX, centerY);
        ctx.arc(centerX, centerY, 0, endAngle, startAngle, true);
        ctx.closePath();
        
        // set the fill color
        ctx.fillStyle = clr;
        ctx.stroke();
        ctx.fill();
        ctx.scale(1, 1/scale);
    }

    function drawCylinder(ctx, pointsArray, clr) {
        var centerX = pointsArray[0],
            centerY = pointsArray[1],
            radius = pointsArray[2],
            startAngle = pointsArray[3],
            endAngle = pointsArray[4],
            depth = pointsArray[5],
            scale = pointsArray[6];
        ctx.scale(1, scale);
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);
        ctx.lineTo(centerX+radius*Math.cos(endAngle), centerY+radius*Math.sin(endAngle)-depth);
        ctx.arc(centerX, centerY - depth, radius, endAngle, startAngle, true);
        ctx.closePath();
        
        // set the fill color
        ctx.fillStyle = clr;
        ctx.stroke();
        ctx.fill();
        ctx.scale(1, 1/scale);
    }
    
    function drawCircle(ctx, pointsArray, clr) {
        // set the fill color
        ctx.fillStyle = clr;
        ctx.beginPath();
        ctx.arc(pointsArray[0], pointsArray[1], pointsArray[2], 0, Math.PI * 2, true);
        ctx.stroke();
        ctx.fill();
    }

    function sortAreaElements(a, b) {
        return a.Point.X - b.Point.X;
    }

    function setTooltipInfo(area, ep, tooltipPosition) {
        var tooltip = this.tooltipArr[tooltipPosition],
            ttl = area.Text,
            borderColor = area.SC,
            style = tooltip.style,
            zoom = (this.model.zf || 1),
            deviceDPI = mstrMobileApp.getDeviceDPI() / 160,
            padding = 2 * deviceDPI,
            tooltipMaxWidth = mstrApp.getScreenDimensions().w - (TOOLTIP_PADDING_LEFT_RIGHT * 2); // max width of the tooptip should not exeed screen dimension - left right padding
            

        // #715530 on tablets with greater dpi need to make the font size of tooltip bigger according to the Device DPI ratio
        if (mstrApp.isTablet()) {            
            zoom = (zoom * deviceDPI) + 'em';
        } else if (mstrMobileApp.getDeviceDPI() > 240) {  // #565170 on phone with greater dpi need to make the font size of tooltip bigger
            zoom = (zoom * 1.5) + 'em';
        } else {
            zoom += 'em';
        }

        // update font-size for zoom
        var cssText = 'font-size:' + zoom + ';';

        //update padding for the text
        cssText += 'padding:' +  padding + 'px;';
        
        // update the max width of the tooltip
        cssText += 'maxWidth:' + tooltipMaxWidth + 'px;';

            // if area has color property set the border color of tooltip to be the same
        if (borderColor) { // #502810
            cssText += 'border-color:#' + borderColor;
        }

        tooltip.innerHTML = ttl;
        style.cssText = cssText;

        style.display = 'block';

        //display the tooltip
        var top = 0,
            left = 0;

        var offsetHeight = tooltip.offsetHeight,
            offsetWidth = tooltip.offsetWidth;

        // adjust 6 to show on side
        top = ep.y - offsetHeight - 6;
        left = ep.x - offsetWidth - 6; // always set the postion to show at left

        tooltipsToPosition.push({
            x: area.Point.X,
            y: area.Point.Y,
            clr: borderColor || '#000000',
            top: top,
            left: left,
            width: offsetWidth,
            height: offsetHeight
        });
    }

    function setSingleTooltipPosition(graph, tooltip, posElement) {
        // Only one tooltip only adjust for left or right if tooltip goes out of area
        var left = posElement.left,
            top = Math.max(posElement.top, topTitleHeight + TOOLTIP_PADDING) // #633360 need to show the tooltip always.
            width = posElement.width,
            style = tooltip.style,
            newLeft = left + width + 12;

        // make sure that tooltip can display properly on right side
        if (newLeft + width <= mstrApp.getScreenDimensions().w) {
            left = newLeft;
        } else if(left < 0) {  // if left is out of screen bring it inside the screen
            left = TOOLTIP_PADDING_LEFT_RIGHT;
        }

        style.left = left + 'px';
        style.top = top + 'px';

        graph.showAreaMarker(posElement.x, posElement.y, posElement.clr);
    }

    function positionLeftColumnTooltip(graph, position) {
        var posElement = tooltipsToPosition[position],
            tooltipArr = graph.tooltipArr,
            style = tooltipArr[position].style,
            left = posElement.left,
            top = posElement.top,
            width = posElement.width,
            height = posElement.height,
            screenWidth = mstrApp.getScreenDimensions().w,
            i,
            newLeft;

        if (position > 0) {
            // push all the previous tooltips down with the current tooltip height + padding
            var prevPosElem = tooltipsToPosition[position - 1],
                prevTop = prevPosElem.top,
                prevLeft = prevPosElem.left,
                prevRight = prevLeft + prevPosElem.width,
                currRight = prevLeft + width,
                prevTooltip;

            left = prevLeft;
            //check if it is not right aligned align right
            if (currRight > prevRight) {
                left -= (currRight - prevRight);
            } else if (currRight < prevRight) {
                left += (prevRight - currRight);
            }

            if (left < 0) {
            	// check if tooltip will not fit on the right side mark it as large tooltip and set the position to left edge.
                if ((width * 2 ) + 12 > screenWidth) {
                	tooltipPositionChanged = false; // since we have big tooltip even if we have any tooltip with position changed does not count anymore
                    hasLargeTooltip = true;
                    left = TOOLTIP_PADDING_LEFT_RIGHT;
                    
                    // now change the left position of all previous tooltips
                    for(i = 0; i < position; i++) {
                    	prevTooltip = tooltipArr[i];
                        prevPosElem = tooltipsToPosition[i];
                        newLeft = left + width - prevPosElem.width;
                        prevPosElem.left = newLeft;
                        prevTooltip.style.left = left + width - prevPosElem.width + 'px'; 
                    }
                    
                } else {
                    // since left is less than 0 need to reposition the left side tooltips to the right
                    tooltipPositionChanged = true;
                }
            }

            // first check if we have enough space to put the new tooltip on top without moving the others down
            top = prevTop - TOOLTIP_PADDING - height;

            // if top tooltip is out of the screen or overlapping the titile bar than start pushing all previous tooltips
            if (top < topTitleHeight) {

            	var pushHeight =  Math.abs(top) + topTitleHeight + TOOLTIP_PADDING;

                for (i = 0; i < position; i++) {
                    prevTooltip = tooltipArr[i];
                    prevPosElem = tooltipsToPosition[i];
                    prevTop = prevPosElem.top + pushHeight;

                    // record the new top position and set it on tooltip
                    prevPosElem.top = prevTop;
                    prevTooltip.style.top = prevTop + 'px';
                }
                top += pushHeight;
            }
        } else {
            
            if (left < 0) {
                
                // check if tooltip will not fit on the right side mark it as large tooltip and set the position to left edge.
                if ((width * 2 ) + 12 > screenWidth) {
                    hasLargeTooltip = true;
                    left = TOOLTIP_PADDING_LEFT_RIGHT;
                } else {
                    // since left is less than 0 need to reposition the left side tooltips to the right
                    tooltipPositionChanged = true;
                }
            }
            //if tooltip will show partially show it full instead
            if (top < topTitleHeight) {
                top = topTitleHeight + TOOLTIP_PADDING;
            }
        }

        // only set the new position if position is not changed
        if (!tooltipPositionChanged) {
            style.left = left + 'px';
            // reset the pos element left to the new ones
            posElement.left = left;
        }

        style.top = top + 'px';

        // reset the pos element top to the new ones
        posElement.top = top;

        graph.showAreaMarker(posElement.x, posElement.y, posElement.clr);
    }

    function positionRightColumnTooltip(graph, position, adjustCount, left) {
        var style = graph.tooltipArr[position].style,
            posElement = tooltipsToPosition[position],
            top = tooltipsToPosition[position - adjustCount].top,
            width = posElement.width;

        if (left + width > mstrApp.getScreenDimensions().w) {
            rightTooltipPositionChanged = true;
            style.display = 'none'; //  hide the tooltip this might not show up
            return;
        }

        style.left = left + 'px';
        style.top = top + 'px';

        graph.showAreaMarker(posElement.x, posElement.y, posElement.clr);
    }

    function setMultiTooltipPositions(graph) {
        var tooltipsSize = tooltipsToPosition.length,
            tooltipArr = graph.tooltipArr,
            halfTooltipsSize = Math.ceil(tooltipsSize / 2),
            i = 0,
            adjustCount = 1,
            maxColTooltipSize = Math.min(tooltipsSize, MAX_TOOLTIPS / 2),
            screenWidth = mstrApp.getScreenDimensions().w,
            posElement,
            left,
            currTooltip;

        // stack half tooltips to the left column
        for (i = 0; i < halfTooltipsSize; i++) {
            positionLeftColumnTooltip(graph, i);
        }

        // if one of the tooltip does not fit on the left side or one of the tooltip is too Large set rest of the tooltips
        if (tooltipPositionChanged || hasLargeTooltip) {
            //First put any more tooltips on the left side if we can
            for (i; i < maxColTooltipSize; i++) {
                positionLeftColumnTooltip(graph, i);
            }

            if(!hasLargeTooltip) {
            	var j = i - 1,
            	    rightMostPosition = 0,
            	    tempPosition = 0,
            	    biggestPosElement,
            	    currentPosElementWidth;
            	posElement = tooltipsToPosition[j];
            	left = posElement.left + posElement.width + 12;  // this is our left for all the tooltips if they can fit on right side.

            	for (j = i - 1; j >= 0; j--) {
            		currTooltip = tooltipArr[j];
            		currentPosElementWidth = tooltipsToPosition[j].width;
            		// make sure the tooltip will fit in the desired space
            		if(left + currentPosElementWidth > screenWidth) {
            			tempPosition = TOOLTIP_PADDING_LEFT_RIGHT +  currentPosElementWidth;
            			if(tempPosition > rightMostPosition) {
            				rightMostPositon = tempPosition;
            				biggestPosElement = tooltipsToPosition[j];
            			}
            		}
            		currTooltip.style.left = left + 'px';
            	}
            	
            	// now align all tooltips to the right most element as desired
            	if(rightMostPosition > 0) {
            		for(j = 0; j < i; j++) {
            			currTooltip = tooltipArr[j];
            			currTooltip.style.left = (TOOLTIP_PADDING_LEFT_RIGHT + biggestPosElement.width -  tooltipsToPosition[j].width) + 'px';
            		}
            	}
            }
        } else {
            // stack remaining tooltips to the right column
            posElement = tooltipsToPosition[tooltipsSize - 1];
            left = posElement.left + posElement.width + 12;  // Right most position for right side tooltips

            for (i; i < tooltipsSize; i++) {
                positionRightColumnTooltip(graph, i, adjustCount, left);
                adjustCount += 2; // increment adjust count by 2
                if (rightTooltipPositionChanged) {
                    break;
                }
            }

            // If right tooltip position is changed and we still have space on the left col put them on left column top
            if (rightTooltipPositionChanged && i <= maxColTooltipSize) {
                for (i = halfTooltipsSize; i < tooltipsSize; i++) {
                    positionLeftColumnTooltip(graph, i);
                    tooltipArr[i].style.display = 'block';
                }
            }
        }
    }

    function setTooltipPositions() {
        var me = this,
            numTooltips = tooltipsToPosition.length;

        if (numTooltips === 0) {
            return; // nothing to position
        }

        topTitleHeight = mstrApp.rootView.getTitleHeight();  // set the titile height so that the tooltip won't overlap it

        if (numTooltips === 1) {
            setSingleTooltipPosition(me, me.tooltipArr[0], tooltipsToPosition[0]);
        } else {
            setMultiTooltipPositions(me);
        }

    }

    function drawShape(shapeType, ctx, coords, color) {
        switch (shapeType) {
        case AreaShapeRectangle:
            drawRectangle(ctx, coords, color);
            break;

        case AreaShapeCircle:
            drawCircle(ctx, coords, color);
            break;
        case AreaShapeRingSector:
            drawRingSector(ctx, coords, color);
            break;
        case AreaShapeNormalSector:
            drawNormalSector(ctx, coords, color);
            break;
        case AreaShapeCylinder:
            drawCylinder(ctx, coords, color);
            break;
        default:
            drawPoly(ctx, coords, color);
        }
    }

    /*** A mixin to add canvas graph rendering abilities to normal image graph widgets.
     *
     * @class
     * @public
     */
    mstrmojo.graph._MobileGraphAreaHelper = mstrmojo.provide(
        "mstrmojo.graph._MobileGraphAreaHelper",

        /**
         * @lends mstrmojo.graph._MobileGraphAreaHelper
         */
        {

            highlightArea: function highlightArea(animationCanvas, areas) {
                var me = this,
                    ctx = animationCanvas.getContext('2d'),
                    color = 'rgba(255, 255, 255, 0.5)';

                // clear canvas
                me.clearHighlightArea(animationCanvas);

                // re-render area with white border and half transparency
                ctx.strokeStyle = "#FFFFFF";

                $ARR.forEach(areas, function (area) {
                    drawShape(area.Shape, ctx, area.Coords, color);
                });

            },

            highlightAreaInInit: function highlightAreaInInit(animationCanvas, selected) {
                var ctx = animationCanvas.getContext('2d'),
                    allAreas = this.graphData.Areas,
                    color = 'rgba(255, 255, 255, 0.5)';

                // clear canvas
                ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);

                // re-render area with white border and half transparency
                ctx.strokeStyle = "#FFFFFF";

                var numAreas = allAreas.length,
                    DssGraphRiser = 286,
                    DssGraphDataMarker = 259,
                    DssGraphPieSlice = 341;

                var numOfSelected = selected.length / 2,
                    j,
                    i;
                for (i = 0; i < numAreas; i++) {
                    var area = allAreas[i],
                        areaOID = parseInt(area.OID, 10);

                    if (areaOID !== DssGraphRiser && areaOID !== DssGraphDataMarker && areaOID !== DssGraphPieSlice) {
                        continue;
                    }

                    if (area.SID < 0 || area.GID < 0) {
                        continue;
                    }
                    for (j = 0; j < numOfSelected; j++) {
                        if (area.SID !== selected[2 * j] || area.GID !== selected[2 * j + 1]) {
                            continue;
                        }

                        drawShape(area.Shape, ctx, area.Coords, color);
                    }

                }
            },

            clearHighlightArea: function clearHighlightArea(animationCanvas) {
                if (animationCanvas) {
                    var ctx = animationCanvas.getContext('2d');
                    ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
                    animationCanvas.width = animationCanvas.width;  // #690447 just a hack since the clear rectangle was not clearing the init highlighted area
                }
            },

            showAreaMarker: function showAreaMarker(x, y, clr) {
                if (x >= 0 && y >= 0) {

                    var ctx = this.highlightNode.getContext('2d');

                    ctx.save();
                    ctx.fillStyle = '#FFFFFF'; // white background for outer circle
                    ctx.strokeStyle = clr || '#000000';
                    ctx.lineWidth = 2;

                    // draw the outer circle
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2, true);
                    ctx.stroke();
                    ctx.fill();

                    // draw the inner circle
                    ctx.fillStyle = clr || '#000000';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2, true);
                    ctx.stroke();
                    ctx.fill();


                    ctx.restore();
                }

            },

            displayTooltips: function displayTooltips(areas, adjustX, adjustY) {
                // sort the areas so that areas are from left to right in order
                areas.sort(sortAreaElements);

                var tooltipArr = this.tooltipArr,
                    i;

                tooltipPositionChanged = false;
                rightTooltipPositionChanged = false;
                tooltipsToPosition = [];
                this.clearHighlightArea(this.highlightNode);

                //For now we will have 10 tooltips later we can change that behavior.
                if (!tooltipArr) {
                    TOOLTIP_PADDING_LEFT_RIGHT = 8 * (mstrMobileApp.getDeviceDPI() / 160); // adjust the left and right padding size according to the dpi

                    tooltipArr = [];
                    for (i = 0; i < MAX_TOOLTIPS; i++) {
                        var divEl = document.createElement('div');

                        divEl.id = 'mstrmojo-mobileGraph-tooltip';
                        divEl.className = mstrmojo.GraphBase.tooltipCLS;
                        document.body.appendChild(divEl);
                        tooltipArr[i] = divEl;
                    }
                    this.tooltipArr = tooltipArr;
                }

                maxAreasToShow = Math.min(areas.length, MAX_TOOLTIPS);

                var touchManager = mstrmojo.touchManager;

                if (maxAreasToShow === 0 && this._touchListener) {
                    //detachEventListener
                    touchManager.detachEventListener(this._touchListener);
                    delete this._touchListener;
                } else if (maxAreasToShow > 0 && !this._touchListener) {
                    this._touchListener = touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                    	// TQMS 690543: Do not hide tooltips when user taps on the toolbar button or menu, so that 
                    	// user can take screenshot of the tooltips.
                    	var sourceWidget = mstrmojo.all[evt.srcId];
                    	
                    	if (!(sourceWidget instanceof mstrmojo.android.ui.ActionToolbarButtons 
                    			|| sourceWidget instanceof mstrmojo.android.ui.Menu)) {
	                    	this.displayTooltips([], 0, 0);   // hide the tooltips
	                    }
                    });
                }

                var area = null,
                    ep = {},
                    style;

                hasLargeTooltip = false; // reset that all tooltips fit in the given area
                
                // make sure all tooltips are hidden
                for (i = 0; i < MAX_TOOLTIPS; i++) {
                    style = tooltipArr[i].style;
                    style.left = -9999; // just to make sure it will not display until we set the left and top property
                    style.display = 'none';
                }

                // set the initial tooltip info and position of all elements
                for (i = 0; i < maxAreasToShow; i++) {
                    area = areas[i];
                    ep.x = area.Point.X + adjustX;
                    ep.y = area.Point.Y + adjustY;
                    //set tooltip information
                    setTooltipInfo.call(this, area, ep, i);
                }

                //position the tooltips
                setTooltipPositions.call(this);

                // # 515196 in ics devices tooltips do not show in first touch force repaint is required
                window.setTimeout(function () {
                    mstrMobileApp.forceRepaint();
                }, 0);
            },

            destroy: function dst(skipCleanup) {
                // Iterate mobile tooltips.
                $ARR.forEach(this.tooltipArr, function (tooltip) {
                    // Remove from document.
                    document.body.removeChild(tooltip);
                });

                delete this.tooltipArr;

                if (this._super) {
                    this._super(skipCleanup);
                }
            }
        }
    );

}());
(function () { 

    mstrmojo.requiresCls("mstrmojo.array");
    
    var $ARR = mstrmojo.array,
        $HASH = mstrmojo.hash;
    
    /*
        Adds the given indices to the selectedIndices of the given widget.  Raises no events. Returns an array of the
        indices that were actually added (possibly empty).
     */ 
    function _add(/*Widget*/ me, /*Array*/ idxs) {
        
        // do we have any indexes to add?
        if ( !idxs ) {
            return;
        }
        
        var added = [],
            sel = me.selectedIndices,
            allIdx = me.allIdx,
            noneIdx = me.noneIdx,
            inc = me.parent && me.parent.include;

        // if we selecting nothing
        if(me.multiSelect && (noneIdx > -1) && ($ARR.indexOf(idxs, noneIdx) > -1)) {
            return added;
        }
        
        // add ALL
        var i, len,
            items = me.items,
            idf = me.itemIdField,
            selectedItems = me.selectedItems,
            item;
        //If we selecting all
        if (me.multiSelect && (allIdx > -1) && ($ARR.indexOf(idxs, me.allIdx) > -1)) {
            for (i = 0, len=items.length; i < len; i++) {
                if (!sel[i]){
                    added.push(i);
                    sel[i] = true;
                    me.selectedIndex = i;
                    me.selectedItem = items[i];
                }
            }
        } else {
            for (i=0, len=idxs.length; i<len; i++) {
                var idx = idxs[i];
                if (!sel[idx]){
                    sel[idx] = true;
                    added.push(idx);
                    me.selectedIndex = idx;
                    item = me.selectedItem = items[idx];
                    if ( selectedItems ) {
                        selectedItems[item[idf]] = item;
                    }
                }
            }
        }
        return added;
    }
        
    /*
        Removes all selectedIndices from given widget.  Raises no events. Returns an array of the
        indices that were actually removed (possibly empty).
     */ 
    function _rmvAll(/*Widget*/ me) {
        var rmv = [],
            sel = me.selectedIndices,
            selectedItems = me.selectedItems;
        for (var i in sel) {
            delete sel[i];
            rmv.push(parseInt(i, 10));    // convert string keys to integers
        }
        me.selectedIndex = -1;
        me.selectedItem = null;
        if ( selectedItems ) {
            me.selectedItems = {};
        }
        return rmv;
    }
    
    /*
        Removes the given indices from the selectedIndices of the given widget.  Raises no events. Returns an array of the
        indices that were actually removed (possibly empty).
     */ 
    function _rmv(/*Widget*/ me, /*Array*/ idxs) {
        // do we have any indexes to remove?
        if ( !idxs ) {
            return;
        }
        
        var removed = [],
            sel = me.selectedIndices,
            arrIdx = $ARR.indexOf,
            allIdx = me.allIdx,
            noneIdx = me.noneIdx,
            idf = me.itemIdField,
            selectedItems = me.selectedItems;
                
        // remove ALL
        if (me.multiSelect && (((allIdx > -1) && (arrIdx(idxs, allIdx) > -1)) || ((noneIdx > -1) && (arrIdx(idxs, noneIdx) > -1)))) {
            return _rmvAll(me);
        }
        
        // remove non-ALL
        // if ALL is currently selected, we need to remove it when any other one removed
        if (idxs.length > 0 && sel[allIdx]) {
            if (arrIdx(idxs, allIdx) < 0) {
                idxs.push(allIdx);
            }
        }
        for (var i=0, len=idxs.length; i<len; i++) {
            var idx = idxs[i];
            if (sel[idx]){
                delete sel[idx];
                removed.push(idx);
                if ( selectedItems ) {
                    delete selectedItems[me.items[idx][idf]];
                }
                if (me.selectedIndex == idx) {
                    me.selectedIndex = -1;
                    me.selectedItem = null;
                }
            }
        }
        return removed;
    }
    
    /* Utility method: raises an event after the selectedIndices hash has been modified. */
    function _raise(/*Widget*/ me, /*Array?*/ added, /*Array?*/ removed, /*Array?*/ idxs) {
        if (me.raiseEvent) {
        	
        	// raise the 'select' event even if no selection was changed
        	me.raiseEvent({
        		name: 'select',
        		idxs: idxs || []
        	});
        	
            if ((added && added.length) || (removed && removed.length)) {
                try {
                    me.raiseEvent({
                        name: 'selectionChange',
                        added: added,
                        removed: removed
                    });
                } catch (ex) {
                    //There's been an error, undo previous action
                    _rmv(me, added);
                    _add(me, removed);
                    
                    throw ex;
                }
        	}
        }
    }
    
    function indexOf(me, item) {
        if ( item == null ) {
            return -1;
        }
        var isObject = typeof(item) == 'object',
            idf = me.itemIdField;
        if (isObject && idf != null) {
            return $ARR.find(me.items, idf, item[idf]);
        } else  {
            return $ARR.indexOf(me.items, item);
        }
    } 
    
    /**
     *  _ListSelections is a mixin to mix into Model or its subclass. 
     *  It keeps the collection of selected indices among actions.
     */    
    mstrmojo._ListSelections = {

            multiSelect: false,
            
            allIdx : -1,
            /**
             * Array of data items to be displayed. We assume the array's contents are static; to modify the displayed list,
             * the entire widget must be re-rendered.
             */
            items: null,
            /**
             * Hashtable of selected indices, possibly empty.  Key = a selected index, value[key] = true if index selected.
             */
            selectedIndices: null,
            
            /**
             * The last index that was added to the selectedIndices. If none, -1.
             */
            selectedIndex: -1,

            /**
             * Metadata for "selectedIndices" property. Identifies the event which is raised when the property value is changed.
             */
            selectedIndices_bindEvents: "selectionChange",
            selectedIndex_bindEvents: "selectionChange",
            
            /**
             * The the item at the current selectedIndex.
             */
            selectedItem: null,
            /**
             * Metadata for "selectedItem" property. Identifies the event which is raised when the property value is changed.
             */
            selectedItem_bindEvts: "selectionChange",
            

            /**
             * Indicates that the list allows adding selected items that are not currently present in the items collection.
             */
            allowUnlistedValues: true,
            
            /**
             * A collection of selected items. 
             * We need to maintain a separate collection of selected items only if the list supports incremental fetch.
             * We can support a separate collection of selected items only if items have ID field.
             */
            selectedItems: null,

            /**
             * Whether the list support incremental fetch.
             * 
             * @type Boolean
             * @default false
             */
            supportsIncFetch: false,
            
            /**
             * Extends inherited init method in order to initialize the selectedIndices collection.
             */
            init: function(/*Object?*/ props) {
                this._super(props);
                //We need to maintain a separate collection of selected items only if the list supports incremental fetch.
                //We can support a separate collection of selected items only if items have IF field.
                if ( this.supportsIncFetch && this.itemIdField ) {
                    this.selectedItems = {};
                }
                if ( ! this.items ) {
                    this.items = [];
                }
                if (!this.selectedIndices) {
                    this.selectedIndices = {};
                    if (this.selectedIndex>-1) {
                        this._set_selectedIndex("selectedIndex", this.selectedIndex, true);
                    } else if (this.selectedItem) {
                        this._set_selectedItem("selectedItem", this.selectedItem, true);
                    }
                }
            },
            
            /**
             * Adds new items to the list.
             * @param {any} items an array of items or a single item
             */
            addItems: function addItems(newItems) {
                if ( ! newItems  ) {
                    return;
                }
                if (newItems.constructor != Array) {
                    newItems = [newItems];
                }
                var items = this.items,
                    start = this.items.length,
                    selectedItems = this.selectedItems,
                    newSelected = [], // whether any newly added item should already be selected
                    end; 
                
                items = this.items = items.concat(newItems); // concat returns a new array
                end = items.length;

                //If any of added items are already selected we need to add them
                //to slectedIndexes
                if ( selectedItems ) {
                    var selectedIndices = this.selectedIndices,
                        idf = this.itemIdField,
                        i, item;
                    for ( i = start; i < items.length; i++ ) {
                        item = items[i];
                        if ( selectedItems[item[idf]] ) {
                            newSelected.push(i);
                        } 
                    }
                }
                
                if (newSelected && newSelected.length) { // selectedIndexes got update needs to notify any listener
                    _add(this, newSelected); // update selectedIndices and raise event
                }
                //Rerender
                if ( end > start) {
                    this.itemsContainerNode.innerHTML += this._buildItemsMarkup(start, end - 1).join('');
                }
            },
            
            /**
             * Adds new selected items.
             * @param {any} items an array of items or a single item
             */
            addSelectedItems: function addSelectedItems(newSelections) {
                this.selectItems(newSelections, false);
            },
            /**
             * Sets new selected items (clearing old selected items).
             * @param {any} items an array of items or a single item
             */
            setSelectedItems: function setSelectedItems(newSelections) {
                this.selectItems(newSelections, true);
            },
            
            /**
             * Selects list items.
             * @param {any} items an array of items or a single item
             * @param {boolean} clearPrevSelections if this flag is true previous selections will be
             *                                      cleared before setting new ones
             */
            selectItems: function selectItems(newSelections, clearPrevSelections) {
                if ( ! newSelections ) {
                    return;
                }
                if (newSelections.constructor != Array) {
                    newSelections = [newSelections];
                }

                var me = this;
                
                //Reset selected items
                if ( clearPrevSelections && me.selectedItems ) {
                    me.selectedItems = {};
                }
                
                var selectedItems = me.selectedItems,
                    idf = me.itemIdField,
                    item, idx, i,
                    addedItems = [], //A collection of items that must be added to the items collection
                    addedIdx = me.items.length, //An index of the last added item
                    newSelectedIndices = [], //A collection of new selected indexes
                    allowUnlistedValues = me.allowUnlistedValues;
                
                for ( i = 0; i < newSelections.length; i++ ) {
                    item = newSelections[i];
                    idx = indexOf(this, item);
                    
                    //If the item is not present in the list
                    if (idx === -1 ) {
                        //and we don't maintain a separate collection of selected items
                        if ( selectedItems === null ) {
                            //and we are allowed to add missing items to the list
                            if ( allowUnlistedValues) {
                                //Remember that we need to add this item to the list
                                addedItems.push(v);
                                idx = addedIdx++;
                            }
                        } else {
                            //If we maintain a separate list of selected items then we just
                            //add the item to it
                            selectedItems[item[idf]] = item;
                        }
                    } 
                    //If selected item is present in the items list
                    //remember it's index
                    if ( idx !== -1) {
                        newSelectedIndices.push(idx);
                    }
                }
                
                //Add items to the list if any
                if ( addedItems.length > 0 ) {
                    me.addItems(addedItems);
                }
                
                //Modify selectedIndexes
                if ( newSelectedIndices.length > 0 ) {
                    if ( clearPrevSelections ) {
                        me.select(newSelectedIndices);
                    } else {
                        me.addSelect(newSelectedIndices);
                    }
                }
            },

            unselectItems: function selectItems(items) {
                if ( ! items ) {
                    return;
                }
                if (items.constructor != Array) {
                    items = [items];
                }

                var me = this,
                    selectedItems = me.selectedItems,
                    unselectedIndices = [],
                    idf = me.itemIdField,
                    item, idx, i;
                if ( selectedItems === null ) {
                    return;
                }
                for ( i = 0; i < items.length; i++ ) {
                    item = items[i];
                    //TQMS 522453. We need to delete it from selected items here because the item
                    //may be missing from the elements list due to incremental fetch.
                    if ( selectedItems ) {
                        delete selectedItems[item[idf]];
                    }

                    idx = indexOf(this, item);
                    
                    if ( idx !== -1) {
                        unselectedIndices.push(idx);
                    }
                }
                //Modify selectedIndexes
                if ( unselectedIndices.length > 0 ) {
                    me.removeSelect(unselectedIndices);
                }
            },
            
            /**
             * Returns an array of selected items
             */
            getSelectedItems: function getSelectedItems() {
                //If we maintain a list of selected items then use it.
                //Otherwise use the selected indices
                if ( this.selectedItems != null ) {
                    return $HASH.valarray(this.selectedItems);
                } else {
                    return $ARR.get(this.items, $HASH.keyarray(this.selectedIndices, true));
                }
            },
            
            /**
             * Selects the item at the given index.
             * 
             * @param {Integer} idx The index of the item to select.
             * @param {Boolean} suppressEvt Whether to silently update the selections or not.
             * 
             */
            singleSelect: function(idx, suppressEvt){
                if (idx !== -1) {
                    this.select([idx], suppressEvt);
                }
            },
            
            /**
             * Select the item with the given value.
             * 
             * @param {String|Number} value The value to select.
             * @param {String} fieldName The name of the item field to match with the given value.
             * @param {Boolean} suppressEvt Whether to silently update the selections or not.
             */
            singleSelectByField: function singleSelectByField(value, fieldName, suppressEvt) {
                this.singleSelect($ARR.find(this.items, fieldName, value), suppressEvt);
            },
            
            /**
             * Used for CTRL+click. If the given index is selected, unselects it; otherwise, selects it.
             * Raises "selectionChange" event.
             */
            toggleSelect: function(/*Integer*/ idx) {
                var add, rmv;
                if (this.selectedIndices[idx]) { 
                    rmv = _rmv(this, [idx]);
                } else {
                    add = _add(this, [idx]);
                }
                _raise(this, add, rmv, [idx]);
            },
            // shift+click
            rangeSelect: function(idx) {
                 // to do later
            },
            
            select: function (idxs, /*Boolean?*/ bSuppressEvt){
                if (idxs == null) return;
                if (idxs.constructor != Array) {
                    idxs = [idxs];
                }

                var rmv = _rmvAll(this),
                    add = _add(this, idxs),
                    i = rmv.length - 1;

                // Do we not allow reselection?
                if (this.selectionPolicy !== 'reselect') {
                    // Iterate removed.
                    for (; i >= 0 ; i--) {
                        // Is the added element in the remove collection?
                        var ind = $ARR.indexOf(add, rmv[i]);
                        if (ind > -1){ 
                            // Remove from both.
                            rmv.splice(i, 1);
                            add.splice(ind, 1);
                        }
                    }
                }
                
                // Should we NOT suppress this event?
                if (!bSuppressEvt) {
                    // Raise the event.
                    _raise(this, add, rmv, idxs);
                }
            },
            /**
             * Removes all indices from the selectedIndices collection (if any). Raises "selectionChange"
             * event if collection was modified.
             */
            clearSelect: function(/*Boolean?*/ bSuppressEvt){
                var ret = _rmvAll(this);
                if (bSuppressEvt !== true) {
                    _raise(this, null, ret, []);
                }
            }, 
            /**
             * Adds the given indices to the selectedIndices collection (if not already there).  Raises "selectionChange"
             * event if collection was modified.
             */
            addSelect: function(/*Array|Integer*/ idxs, /*Boolean?*/ bSuppressEvt) {
                if (idxs == null) {
                    return;
                }
                if (idxs.constructor != Array) {
                    idxs = [idxs];
                }
                var ret = _add(this, idxs);
                
                var rmv = null,
                    noneIdx = this.noneIdx;
                // check if the not select all selector is selected,  if true than remove all idxs
                if(this.multiSelect && (noneIdx > -1 && $ARR.indexOf(idxs, noneIdx) > -1)) {
                    rmv = _rmv(this,idxs);
                }
                
                if (bSuppressEvt !== true) {
                    _raise(this, ret, rmv, idxs);
                }
            },
            /**
             * Removes the given indices from the selectedIndices collection (if already there). Raises "selectionChange"
             * event if collection was modified.
             */
            removeSelect: function(/*Array|Integer*/ idxs) {
                if (idxs == null) {
                    return;
                }
                if (idxs.constructor != Array) {
                    idxs = [idxs];
                }
                 _raise(this, null, _rmv(this, idxs), idxs);
            },
            
            /**
             * Custom setter for selectedIndices. Avoids resetting the object reference, and instead updates the existing
             * hashtable and raises an event.
             */
            _set_selectedIndices: function(n, v, /*Boolean? */ bSuppressEvt) {
                var me = this, 
                    sel = me.selectedIndices;
                
                //Reset selected items collection.
                if ( me.selectedItems ) {
                    me.selectedItems = {};
                }
                var sel = me.selectedIndices;
                if (sel == v) {
                    return false;
                }

                if (!sel) {
                    sel = {};
                    me.selectedIndices = sel;
                }
                
                if (!v) {
                    v = {};
                }
                
                // Remove the current selections which are not in the new selections.
                var sidx = me.selectedIndex,
                    rmv = [],
                    idx;
                for (idx in sel) {
                    if (!v[idx]) {
                        idx = parseInt(idx,10);
                        delete sel[idx];
                        rmv.push(idx);
                        if (sidx == idx) {
                            me.selectedIndex = -1;
                            me.selectedItem = null;
                        }
                    }
                }
                // Add the new selections which are not already in the current selections.
                var add = [],
                    itms = me.items,
                    idf = me.itemIdField,
                    item;
                for (idx in v) {
                    if (!sel[idx]) {
                        idx = parseInt(idx,10);
                        sel[idx] = true;
                        add.push(idx);
                        me.selectedIndex = idx;
                        item = me.selectedItem = itms[idx];
                        if ( me.selectedItems ) {
                            me.selectedItems[item[idf]] = item;
                        }
                    }
                }
                // Raise event if collection as modified.
                if (bSuppressEvt !== true) {
                	var idxs = [];
                	for (idx in v) {
                		if (sel[idx]) {
                			idx = parseInt(idx, 10);
                			idxs.push(idx);
                		}
                	}
                    _raise(me, add, rmv, idxs);
                }

                return (add.length || rmv.length);    // True if selections modified; false otherwise.
            },
            
            /**
             * Custom setter for selectedIndex. Leverages setter for selectedIndices to keep that property synchronized.
             */
            _set_selectedIndex: function(n, v, /*Boolean?*/ bSuppressEvt){
                var idxs = {};
                if (v >-1) {
                    idxs[v] = true;
                }
                return this._set_selectedIndices("selectedIndices", idxs, bSuppressEvt);
            },
            
            /**
             * Custom setter for selectedItem. Leverages setter for selectedIndex to keep that property synchronized.
             * Supports values which are either objects or scalars. If an object is given, and itemIdField is defined, then
             * the given item's itemIdField property is compared to the itemIdField properties
             * of the list's items. If no match is found, the selected index is set to -1 UNLESS the "allowUnlistedValues" property is true.
             * If allowUnlistedValues is true and no match is found, the given item is appended to the items list and selected.
             */
            _set_selectedItem: function(n, v, /*Boolean?*/ bSuppressEvt){
                
                // Find the index corresponding to the given item.
                var idx = indexOf(this, v);
                if ((idx === -1) && (v != null) && this.allowUnlistedValues && this.items) {
                    // We couldn't find the given item in items, but we are allowed to add it.
                    // Note: we reset the "items" array by reference, rather than appending to the
                    // existing array, because we want to raise a "itemsChange" event that will repaint the list.
                    this.set('items', this.items.concat(v));
                    idx = this.items.length - 1;
                }
                return this._set_selectedIndex("selectedIndex", idx, bSuppressEvt);
            }
            
        };
})();

(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.array");

    /**
     * <p>Hashtable of subscriptions with callbacks to method names, keyed by publisher ID.</p>
     *
     * <p>The "subs" hashtable maps a publisher ID to the event names for which that publisher has subscriptions.
     * The event names are stored in a hashtable, which is keyed by event name.  That event hashtable, in turn,
     * maps an event name to the listener IDs for that event.  Each listener ID represents an object which wishes to
     * be notified when that given event name is published by the given publisher ID.  The list of listener IDs is
     * a hashtable as well, keyed by listener ID, where key value is a list of callbacks to that listener.  Generally,
     * a listener maybe ask for multiple callbacks, each of which may be either a method name or a Function object.
     * This hashtable stores these callbacks in an object with properties "methods" and "functions".
     * Note that an empty listener ID ("") is used to store callbacks to global methods.</p>
     *
     * <p>In summary, the hashtable's internal structures look like this:</p>
     * <pre>
     * subs[publisherId][evtName][listenerId] = {
     *  methods: {
     *    "methodName1": true,
     *    "methodName2": true,
     *    ..
     *  },
     *  functions: [
     *    Function1,
     *    Function2,
     *    ..
     *  ]
     * }
     * </pre>
     *
     * @type Object
     * @private
     * @static
     */
    var _subs = {};

    /**
     * A map of listeners so that we can release subscriptions when a listening instance is destroyed.
     *
     * @type Object
     * @private
     * @static
     */
    var _listenerMap = {};

    /**
     * <p>A publish-and-subscribe system for broadcasting events to observable objects in a mojo application.</p>
     *
     * @class
     */
    mstrmojo.publisher = mstrmojo.provide(
        "mstrmojo.publisher",

        /**
         * @lends mstrmojo.publisher#
         */
        {
            /**
             * <p>Notifies subscribers of an event occurrence.</p>
             *
             * <p>All subscribers to that object's event will receive the data via whatever callback they used to subscribe.</p>
             *
             * @param {String} id The ID of the object that is publishing this event.
             * @param {String} type The name of the event to publish.
             * @param {Object} data The event occurrence information.
             */
            publish: function pub(id, type, data) {
                // Retrieve the hash of listener ids for this publisher + event combo.
                var ls = _subs[id] && _subs[id][type],
                    lid;
                if (!ls) {
                    return;
                }

                // Notify the listeners.
                for (lid in ls) {
                    // Get a handle to the listener, if any.
                    var l = null;
                    if (lid) {
                        l = mstrmojo.all[lid];
                        //A safty check for the case when the same listener was added several times.
                        //The optimization in the clearSubscriptions - using the listener to source map
                        //doesn't remove a listener if it was added more then once. This code will clean
                        //such orphan subscriptions.
                        if (!l) {
                            delete ls[lid];
                            continue;
                        }
                    }
                    // Call the methods subscribed on that listener.
                    var ns = ls[lid].methods;
                    if (ns) {
                        // If we have a listener object, call its method.
                        // Without a listener, use the global context.
                        var ctxt = l || mstrmojo.global,
                            n;
                        for (n in ns) {
                            if (ctxt[n]) {
                                ctxt[n](data);
                            }
                        }
                    }
                    // Call the Functions subscribed on that listener.
                    // Notify them in reverse order in case some callback deletes a callback.
                    // Also do a null check on ls[lid] because method callbacks above may have
                    // removed it from the listener hash.
                    var fs = ls[lid] && ls[lid].functions,
                        flen = (fs && fs.length) || 0;
                    if (flen) {
                        var i;
                        if (l) {
                            // If we have a listener object, apply the Function to it.
                            for (i = flen - 1; i > -1; i--) {
                                if (fs[i]) {
                                    fs[i].apply(l, [data]);
                                }
                            }
                        } else {
                            // Without a listener object, just call the Function directly.
                            // We avoid using apply() here for performance.
                            for (i = flen - 1; i > -1; i--) {
                                if (fs[i]) {
                                    fs[i](data);
                                }
                            }
                        }
                    }

                }
            },

            /**
             * <p>Requests that an object be notified of a future event in another object.</p>
             *
             * @param {String} id The ID of the object that will do the publishing.
             * @param {String} type The type of the event that will be listened for.
             * @param {Function|String} callback Either a Function, or the name of a listener method, to call when the event is published.
             * @param {String} [listener] ID of the listener to be notified when the given event is published. If missing, the global context is assumed to be the listener.
             *
             * @returns {Object} A newly generated identifier (Object) for this subscription, which can then be used to call unsubscribe() later.
             */
            subscribe: function sub(id, type, callback, listener) {

                // Validate publisher's hash.
                var s = _subs[id];
                if (!s) {
                    s = {};
                    _subs[id] = s;
                }

                // Validate publisher's event's hash.
                var e = s[type];
                if (!e) {
                    e = {};
                    s[type] = e;
                }

                // Validate publisher's event's listener's hash.
                var l = e[listener || ""];
                if (!l) {
                    l = {};
                    e[listener || ""] = l;
                }

                // Record the callback under either "methods" or "functions", depending on type.
                if (typeof callback  === "function") {
                    var fs = l.functions;
                    if (!fs) {
                        fs = [];
                        l.functions = fs;
                    }
                    fs.push(callback);
                } else {
                    // Assume callback is a String; a method name.
                    var ms = l.methods;
                    if (!ms) {
                        ms = {};
                        l.methods = ms;
                    }
                    ms[callback] = true;
                }

                // Performance optimization: To enable a reverse lookup, record a map from listener to publisher.
                var lmap = _listenerMap,
                    pmap = lmap[listener || ""];
                if (!pmap) {
                    pmap = {};
                    lmap[listener || ""] = pmap;
                }
                var emap = pmap[id];
                if (!emap) {
                    emap = {};
                    pmap[id] = emap;
                }
                emap[type] = true;


                // Return a handle to this subscription to use for unsubscribing later.
                return {
                    id: id,
                    type: type,
                    callback: callback,
                    listener: listener,
                    clear: function () {
                        mstrmojo.publisher.unsubscribe(this);
                    }
                };
            },

            /**
             * <p>Cancels a subscription created by calling the subscribe() method.</p>
             *
             * @param {Object} sub The subscription object provided by the subscribe() call.
             */
            unsubscribe: function unsub(sub) {
                var s = _subs[sub.id],
                    e = s && s[sub.type],
                    l = e && e[sub.listener || ""];
                if (!l) {
                    return;
                }

                var A = mstrmojo.array,
                    H = mstrmojo.hash,
                    tp = typeof sub.callback,
                    cleanupListener = false;
                if (tp === "function") {
                    // Remove the callback from the functions array.
                    var fs = l.functions;
                    if (fs) {
                        A.removeItem(fs, sub.callback);
                        if (!fs.length) {
                            // If array now empty, remove it.
                            delete l.functions;
                            // If no callbacks remain, remove listener id.
                            if (H.isEmpty(l.methods)) {
                                cleanupListener = true;
                            }
                        }
                    }
                } else {
                    // Remove the callback from the methods hash.
                    var ms = l.methods;
                    if (ms) {
                        delete ms[sub.callback];
                        if (H.isEmpty(ms)) {
                            // If the hash is now empty, remove it.
                            delete l.methods;
                            // If no callbacks remain, remove listener id.
                            if (!l.functions || !l.functions.length) {
                                cleanupListener = true;
                            }
                        }
                    }
                }
                // Did we remove the final callback from the listener?
                if (cleanupListener) {
                    // Yes, now remove the listener id from the listeners hash.
                    delete e[sub.listener || ""];
                    // And if there are no more listeners for this event...
                    if (H.isEmpty(e)) {
                        // Remove the listeners hash entirely for this event.
                        delete s[sub.type];
                    }
                }
            },

            /**
             * <p>Determines if a specified object hasany listeners subscribed for a given event.</p>
             *
             * @param {String} id The ID of the publishing object.
             * @param {String} type The name of the event.
             *
             * @returns {Boolean} true if the object has at least one listener; false otherwise.
             */
            hasSubs: function hasSubs(id, type) {
                var s = _subs[id],
                    evt = s && s[type];

                return !!evt;
            },

            /**
             * Clear all subscriptions for listeners of the component as well as any subscriptions the component has for other objects.
             *
             * @param {String} listener The id of the component whose subscriptions should be cleared.
             */
            clearSubscriptions: function clr(listener) {
                if (!listener) {
                    listener = "";
                }
                var sbs = _subs,
                    _H = mstrmojo.hash,
                    id;

                // Do we have anybody listening to this object?
                if (sbs[listener]) {
                    // Delete the subscriptions to this object.
                    delete sbs[listener];
                }

                // Is this object listening to anybody else?
                var pmap = _listenerMap[listener];
                if (pmap) {
                    // Walk the event providers...
                    for (id in pmap) {
                        var es = sbs[id],
                            emap = pmap[id],
                            e;
                        if (!es) {
                            continue;
                        }
                        // Walk the event names...
                        for (e in emap) {
                            // Remove this listener from that event.
                            var ls = es[e];
                            if (!ls) {
                                continue;
                            }
                            delete ls[listener];
                            // If there are no remaining listeners for that event...
                            if (_H.isEmpty(ls)) {
                                // ...remove the listeners hash for that event entirely.
                                delete es[e];
                            }
                        }
                    }
                }
            }
        }
    );

    mstrmojo.publisher.NO_SRC = "NO_SRC";
    mstrmojo.publisher.CONNECTIVITY_CHANGED_EVENT = "CONNECTIVITY_CHANGED";
    mstrmojo.publisher.RECONCILE_END_EVENT = "RECONCILE_END";

}());
(function(){
    
    mstrmojo.requiresCls("mstrmojo.array");
    
    /**
     * Returns a hidden input.
     * 
     * @param {HTMLDocument} doc The parent document of the target form.
     * @param {String} n The name of the field.
     * @param {String} v The value of the field.
     * 
     * @returns HTMLElement
     * @private
     */
    function createInput(doc, n, v) {
        var el = doc.createElement('input');
        el.name = n;
        el.type = 'hidden'; //#435303 - FF4 issue - this should go before setting el.value; or call el.setAttribute(); otherwise, el.value will be lost. 
        el.value = v;

        return el;
    }
    
    /**
     * Appends URL values as hidden inputs to the supplied form.
     * 
     * @param {HTMLElement} oForm The form that will receive the new hidden inputs.
     * @param {String} URL The URL with the parameters and values to be added to the form.
     * 
     * @type Boolean
     * @return false
     */
    function _addURLAsHiddenInputsToForm(oForm, URL){
        URL = URL.substring(URL.indexOf("?") + 1,URL.length);
        var URLParameters = URL.split("&"),
            parameterName = "",
            parameterValue = "";

        //Replace ALL + characters with space. The reason for that is the unescape function does not take care of this conversion.
        //That function just converts all strings of format %HH to the character value of the HH hex value
        //Our URL encoding codes spaces to + characters. Hence we have to reverse that effect over here.
        var myRegExp = /\+/g;

        for (var i = 0, cnt = URLParameters.length; i < cnt; i++) {
            var p = URLParameters[i].split("=");
            parameterName = p[0];
            parameterValue = p[1];

            if (parameterValue) {
                parameterValue = decodeURIComponent(parameterValue.replace(myRegExp, ' '));
            }

            var oNewItem = document.createElement("INPUT");
            oNewItem.type="HIDDEN";
            oNewItem.name = parameterName;
            oNewItem.value = parameterValue;

            oForm.appendChild(oNewItem);
        }
        return false;
    }

    /**
     * Static class for building and submitting dynamic forms.
     * 
     * @class
     */
    mstrmojo.form = {
            
        /**
         * Creates a dynamic FORM element and inserts it into the body of the document.
         * 
         * @param {String} sAction The url of the form which may contain parameters.
         * 
         * @type HTMLElement
         * @return The newly created and inserted form.
         */
        createDynamicForm:function createDynamicForm(sAction) {
            var oNewForm = document.createElement("FORM") ,
                hasParameters = sAction.indexOf('?') > 0;

            oNewForm.name = "dynamic_form";
            oNewForm.method = "POST";

            var formAction =  ((hasParameters) ? sAction.substring(0, sAction.indexOf('?')) : sAction);

            //Remove request parameters if any and add them as hidden inputs:
            oNewForm.action = formAction;

            // Does the action have parameters?
            if (hasParameters) {
                // Add the parameters to the form.
                _addURLAsHiddenInputsToForm(oNewForm, sAction);
            }

            //insert the new form after the last form in the list of forms on the document
            document.body.appendChild(oNewForm);

            return oNewForm;
        },
        
        /**
         * <p>Submits an HTTP request via an HTML form.</p>
         * 
         * <p>The form is dynamically created, populated with the given params (if any), added to DOM, submitted, and then removed from DOM.</p>
         * 
         * @param {Object} params The parameters to be added to the form as hidden inputs.
         * @param {String} [action=mstrApp.name|mstrWeb] The value for the action attribute of the dynamic form.
         * @param {String} [method=GET] The value for the method attribute of the dynamic form.
         * @param {String} [target] The target of the form.
         * @param {Object} [config] An optional configuration object.  
         * @param {Object} [addUtxs] An optional flag indicating whether to append unqiue time stamp as part of the action. Default to false in ASP enviornment
         */
        send: function send(params, action, method, target, config, addUxts) {
            // Create the form.
            var doc = ((config && config.hWin) || window).document,
                f = doc.createElement('form'),
                app = mstrApp;
            
            // Set the method, defaulting to 'GET'.
            f.method = method || "GET";
            
            // Is the target present?
            if (target) {
                // Add to form.
                f.target = target;
            }
            
            // Set the form action.
            f.action = action || app.name;
            
            //TQMS 411098  Not append timestamp as part of the action as it will break in ASP enviornment
            addUxts = (addUxts !== undefined )? addUxts:!(f.action && f.action.indexOf("aspx") > 0);
            
            // Do we have a sessionId?
            if (app.sessionId) {
                // Add the sessionId to the action.
                f.action += ';jsessionid=' + app.sessionId;
            }

            // we need unique timestamp in the action. 
            // Note - Just creating unique input node (with a timestamp) is not good enough for some browsers e.g. Safari instance within an native application. 
            if (addUxts) { 
                f.action += ';uxts' + mstrmojo.now();
            }
            
            // Add time stamp to avoid caching.
            f.appendChild(createInput(doc, 'xts', mstrmojo.now()));
            
            //Add persist parameters
            for (var key in app.persistTaskParams) {
            	params[key] = app.persistTaskParams[key];
            }
            
            // Do we have servlet state? when lost session, we may need servlet state to recover the server/project info ...
            if (app.servletState && app.name){
            	params[app.name] = app.servletState;
            }

            // Add the parameters
            if (params) {
                // Iterate the parameters.
                for (var n in params) {
                    // Is the value an array?
                    if (params[n].constructor == Array) {
                        // Yes, add multiple fields with the same name.
                        mstrmojo.array.forEach(params[n], function (item) {
                            f.appendChild(createInput(doc, n, item));
                        });
                    } else {
                        // No, just add one field for this value.
                        f.appendChild(createInput(doc, n, params[n]));
                    }
                }
            }
            
            // Append the form to the document.
            doc.body.appendChild(f);

            // Try to submit the form.
            try {
                f.submit();
            } catch (ex) {
                // Failed.  Does the form have a target and did it fail because of the popup blocker?
                if (target && ex.result === 2147500037 && !window.open('', '', 'width=1,height=1,left=0,top=0,scrollbars=no')) {
                    mstrmojo.alert('*This action requires popups to be allowed in the browser.*');    // TODO: Descriptor: 5877
                } else {
                    mstrmojo.err('Form submission failed for an unknown reason.');         // TODO: Descriptor
                }
            }
            
            // Remove the form from the DOM.
            doc.body.removeChild(f);
        }
    };
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.array");

    var $ARR = mstrmojo.array;

    /**
     * <p>A mixin for adding panel stack behaviors.</p>
     *
     * @class
     * @public
     */
    mstrmojo._IsPanelStack = mstrmojo.provide(

        "mstrmojo._IsPanelStack",

        /**
         * @lends mstrmojo._IsPanelStack.prototype
         */
        {
            _mixinName: 'mstrmojo._IsPanelStack',
            
            TTL_SRC_PANEL: 0,

            init: function init(props) {
                this._super(props);

                // Get defnition.
                var defn = this.defn;

                // Do we not have a defn node yet?
                if (!defn) {
                    // Set definition.
                    defn = this.defn = this.node && this.node.defn;

                    // Set title src.
                    this.titleSrc = this.titleSrc || defn.ttlSrc;
                }

                // Set the currently selected panel key (add to definition so all instances of panel stack will be able to listen for changes).
                var key = this.selectedKey = this.defn.selKey = this.node.data.selKey;

                // Initialize selectedIdx to update panel switching toolbar button status.
                this.set('selectedIdx', $ARR.find(this.node.data.panels, 'k', key));

                // Attach an event listener to hear when the selKey property changes.
                defn.attachEventListener('selKeyChange', this.id, function (evt) {
                    this.set('selectedKey', evt.value);
                });
            },

            /**
             * Add overflow to panel formats if present in panel stack formats.
             *
             * @ignore
             */
            addChildren: function addChildren(panels, idx, silent) {
                var fmts = this.getFormats(),
                    overflow = fmts && fmts.overflow;

                if (overflow) {
                    $ARR.forEach(panels, function (panel) {
                        var pnlFmts = panel.getFormats();
                        if (pnlFmts) {
                            pnlFmts.overflow = overflow;
                        }
                    });
                }

                return this._super(panels, idx, silent);
            },

            /**
             * Manually calls refresh on all panels within this panel stack.
             * @see mstrmojo.Widget
             */
            refresh: function refresh() {
                // Have we already rendered?
                if (this.hasRendered) {
                    // TQMS 704365, 711959. 
                    var refreshKey = this.defn.newSelKey || this.selectedKey;
                    
                    // Iterate panels.
                    $ARR.forEach(this.children, function (child) {
                        // Set delayed refresh status.
                        child._delayRefresh = (child.k !== refreshKey);

                        // Should we NOT delay the refresh?
                        if (!child._delayRefresh) {
                            // Refresh.
                            child.refresh();
                        }
                    });
                    
                }
                delete this.defn.newSelKey;
            },

            /**
             * Changes visible panel in panel stack (and updates server).
             *
             * @param {String} key The key of the newly visible panel.
             * @param {Boolean} [hasLoader=false] An optional boolean that is true when the panel has it's own loading message.
             */
            selectPanel: function selectPanel(key, hasLoader) {
                // Is the newly selected panel key different then the currently selected panel?
                if (key !== this.selectedKey) {
                    // Set key change on definition (so all instances here the change).
                    this.defn.set('selKeyChange', key);

                    // Notify the server that the current panel changed.
                    this.model.slice({
                        type: 3,
                        tks: this.k,
                        eid: key,
                        sid: this.node.data.wid,
                        ck: this.k,
                        hasLoader: hasLoader
                    });
                }
            },

            /**
             * Changes the visibility of the child panels based on the selected key.
             *
             * @param {String} evt.value The key of the newly selected panel.
             */
            onselectedKeyChange: function onselKeyChg(evt) {
                var off, on, selectedIdx;

                // Iterate the children
                $ARR.forEach(this.children, function (panel, idx) {
                    var panelKey = panel.k;

                    // Is this the visible panel?
                    if (evt.value === panelKey) {
                        // Cache the on panel and selected index.
                        on = panel;
                        selectedIdx = idx;

                        // Notify the panel that it is now selected.
                        panel.set('selected', true);

                    // Is this the formerly visible panel?
                    } else if (evt.valueWas === panelKey) {
                        // Cache the off panel.
                        off = panel;

                        // Notify the panel that it is no longer selected.
                        panel.set('selected', false);
                    }

                    // Have we found both the "on" and "off" panels?
                    if (on && off) {
                        // Return false to halt interation.
                        return false;
                    }
                });

                // If the panel stack title bar is set to show the current panel, and have a previous title, we need to propagate the panel name to the PanelStack.
                if (this.titleSrc === this.TTL_SRC_PANEL && this.title) {
                    this.set('title', on.title);

                    // We need to update the definition's ttl property because if we want to reopen  the info window - this value will be incorrect.
                    this.defn.ttl = on.title;
                }

                // Update the selected index.
                this.prevSelectIdx = this.selectedIdx;
                this.set('selectedIdx', selectedIdx);

                // Raise an event that the panel is changing.
                this.raiseEvent({
                    name: 'panelSelected',
                    key: on.k
                });

                // Return index and panel instance for both the "on" and "off" panels.
                return {
                    on: on,
                    off: off
                };
            },

            /**
             * Overridden to mark all panels as dirty when the panel stack is dirty.
             *
             * @ignore
             */
            setDirty: function setDirty(isDirty) {
                // Is the panel stack dirty?
                if (isDirty) {
                    // Mark all panels as dirty.
                    this.setDirtyChildren(true);
                }

                this._super(isDirty);
            },

            /**
             * Since the PanelStack was sliced we need to notify any non-visible panels that they are dirty.
             *
             * @param Boolean [includeAll=false] If not true, only hidden children will be marked as dirty.
             *
             */
            setDirtyChildren: function setDirtyChildren(includeAll) {
                // Cache the selected panel key.
                var selectedKey = this.selectedKey;

                // Iterate panels.
                $ARR.forEach(this.children, function (child) {
                    // Remove the dirty key from the selected panel and add the key as dirty to any unselected panel.
                    var key = child.k;
                    child[((includeAll || key !== selectedKey) ? 'add' : 'remove') + 'DirtyKey'](key);
                });
            },

            /**
             * Sets the panel with the supplied key's dirty state to false.
             *
             * @param {String} key The key of the newly clean panel.
             */
            clearDirtyChild: function clearDirtyChild(key) {
                var panels = this.children,
                    panel = panels[$ARR.find(panels, 'k', key)];

                if (panel) {
                    panel.removeDirtyKey(panel.k);
                }
            },
            
            isPanelStack: true,
            
            checkRequiredObjects: function checkRequiredObjects() {
                var txWidgets = this.txWidgets || {}, 
                    i, w, flag = true;

                for (i in txWidgets){
                    // go through all the txWidgets to see if there's any error.
                    flag &= !!txWidgets[i].checkRequiredObjects();
                }
                
                return flag;
            },
            
            /**
             * <p>Updates the current panel index</p>
             * 
             * @param {Integer} dir Direction -1 to switch to previous panel, +1 to switch to the next panel.
             */
            updateSelectedIdx: mstrmojo.emptyFn,
            
            /**
             * <p>Selects the next (or previous) panel based on the value of the dir parameter.</p>
             * 
             * @param {Integer} dir Direction -1 to switch to previous panel, +1 to switch to the next panel. 
             * @param {Integer} selectedIdx Switches the current panel to the selected Idx. This property works exclusively from the dir parameter.
             */
            switchToPanel: function switchToPanel(dir, selectedIdx) {
             // Has the caller specified the selected index? Then, there's no need to find.
                if (selectedIdx !== undefined) {
                    // Updated the selected index of the panel stack.
                    this.set('selectedIdx', selectedIdx);
                } else {
                    // Update the current panel index based on direction.
                    this.updateSelectedIdx(dir);
                }

                // Load new panel
                this.children[this.selectedIdx] && this.selectPanel(this.children[this.selectedIdx].k);
            }
        }
    );
}());
(function(){

	mstrmojo.requiresCls("mstrmojo.array");
	
    /**
     * <p>A mixin for a {@link mstrmojo.Container} that has a builder property.</p>
     * 
     * @class
     * @public
     */
    mstrmojo._HasBuilder = 
        /**
         * @lends mstrmojo._HasBuilder#
         */
        {
            /**
             * Calls the builder to build children before calling renderChildren method.
             * 
             * @returns {Boolean} True
             */
            postBuildRendering: function postBldRndr() {
                if (!this.builtChildren) {
                    this.buildChildren();
                }
                return this._super();
            },

            getChildren: function getChildren(){
                return this.model.getChildren(this.node, false);
            },
            
            /**
             * Asks the model (if any) for a set of nodes that represent this widget's children; then asks
             * the builder (if any) to build widgets corresponding to those nodes; then adds those nodes
             * as children to this widget. Will exit if either builder or model are undefined.
             * @returns {Boolean} true if builder is called; false otherwise.
             */            
            buildChildren: function bldChdn(noAddChildren) {
                if (!this.builder || !this.model) {
                    return false;
                }

                // Clear pre-existing children, if any. Use set() so that Container's
                // custom setter will call removeChild and do cleanup if needed.
                if (this.children && this.children.length) {
                    this.set("children", []);
                }
                
                // Build children widgets.
                var m = this.model,
                    children = this.builder.build(
                        this.getChildren(),
                        m,
                        this.buildConfig
                );
                
                // Should we add the children?
                if (!noAddChildren) {
                    // Do it.
                    this.addChildren(children);
                }
                
                // Record that we've built already, for future reference so a re-render doesn't rebuild needlessly.
                this.builtChildren = true;
                
                // Return the children if we didn't add then already.
                return (noAddChildren) ? children : true;
            }            
    };
    
})();
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.dom",
        "mstrmojo.array",
        "mstrmojo.string");
    
    /**
     * Shortcuts.
     * 
     * @private
     * @ignore
     */
    var $D = mstrmojo.dom,
        $S = mstrmojo.string;

    /**
     * A utility class for browser sniffing.
     * 
     * @class
     */
    mstrmojo.css = mstrmojo.provide(
        "mstrmojo.css",
        /**
         * @lends mstrmojo.css
         */
        {
        
            /**
             * The browser appropriate display property for a table.
             * 
             * @type String
             * @constant
             */
            DISPLAY_TABLE: $D.isNSIE ? 'block' : 'table',
            
            /**
             * The browser appropriate display property for a table cell.
             * 
             * @type String
             * @constant
             */
            DISPLAY_CELL: $D.isNSIE ? 'block' : 'table-cell',

            /**
             * The browser appropriate property for min-height.
             * 
             * @type String
             * @constant
             */
            MINHEIGHT: $D.isIE6 ? 'height' : 'minHeight',
                    
            /**
             * <p>Adds one or more of class names to the class name attribute of the supplied element.</p>
             * 
             * <p>If the class name is already present, it will ignore it.</p>
             * 
             * @param {HTMLElement} el The element to receive the classes.
             * @param {String[]} s Array of one or more classes to add.
             */
            addClass: function addClass(el, s) {
                if (!el) {
                    return;
                }
                
                if (s.constructor !== Array) {
                    s = [ s ];
                }
                var cls = el.className || '',
                    start = ' ' + cls +  ' ',
                    bAdded = false;
                for (var i=0, len=s.length; i<len; i++) {
                    var c = s[i];
                    if (!start.match(new RegExp("\\s" + c + "\\s"))) {
                        cls += ' ' + c;
                        bAdded = true;
                    }
                }
                if (bAdded) {
                    el.className = $S.trim(cls);
                }
            },
            
            /**
             * <p>Removes one or more class names from the class name attribute of the supplied element.</p>
             * 
             * <p>If the class name is not present, it will ignore it.</p>
             * 
             * @param {HTMLElement} el The element whose class name is to be edited.
             * @param {String[]} s Array of one or more classes to remove.
             */
            removeClass: function removeClass(el, s) {
                if (!el) {
                    return;
                }
                
                if (s.constructor !== Array) {
                    s = [ s ];
                }
                var cls = ' ' + (el.className || '') + ' ';
                for (var i=0, len=s.length; i<len; i++) {
                    cls = cls.replace(new RegExp("\\s" + s[i] + "\\s", "g"), " ");
                }
                el.className = $S.trim(cls);
            },
            
            /**
             * <p>Adds classes to the space delimited {@link mstrmojo.Widget.cssClass} property.</p>
             * 
             * <p><strong>NOTE:</strong> This is only effective before rendering.  After rendering the {@link mstrmojo.css.addClass} method should be used.</p>
             * 
             * @param {mstrmojo.Widget} widget The widget whose cssClass property should be changed.
             * @param {String|String[]} classes An array of css class names to add (will also work with a single class name). 
             */
            addWidgetCssClass: function addWidgetCssClass(widget, classes) {
                // Split original class names into an array.
                var origClasses = widget.cssClass,
                    existing = (origClasses && origClasses.split(' ')) || [];
                
                // Is the classes param NOT an array?
                if (classes.constructor !== Array) {
                    // Convert to array.
                    classes = [ classes ];
                }

                // Reset cssClass property to new collection of classes.
                widget.cssClass = existing.concat(classes).join(' ');
            },
            
            /**
             * <p>Adds (or removes) one or more class names from the class name attribute of the supplied element.</p>
             * 
             * <p>If the class name is not present, it will ignore it.</p>
             * 
             * @param {HTMLElement} el The element whose class name is to be edited.
             * @param {String[]} s Array of one or more classes to remove.
             * @param {Boolean} b True if the class names should be added. 
             */
            toggleClass: function toggleClass(el, s, b) {
                if (b) {
                    this.addClass(el, s);
                } else {
                    this.removeClass(el, s);
                }
            },
            
            /**
             * Applies a drop shadow to the supplied element.
             * 
             * @param {HTMLElement} el The HTMLElement that will receive the drop shadow.
             * @param {Integer} xOff The offset x value for the drop shadow.
             * @param {Integer} yOff The offset y value for the drop shadow.
             * @param {Integer} spread The spread value for the drop shadow (does not apply to IE).
             * @param {String} color The hexidecimal color value for the drop shadow (must be full 7 digits for IE).
             * 
             */
            applyShadow: function applyShadow(el, xOff, yOff, spread, color) {
                var s = el.style;
                if ($D.isDXIE) {
                    s.filter += "progid:DXImageTransform.Microsoft.dropshadow(OffX=" + xOff + "px, OffY=" + yOff + "px, Color='" + color + "')";
                } else if ($D.isFF || $D.isWK || $D.isIE10) {
                    s[$D.CSS3_BOXSHADOW] = xOff + 'px ' + yOff + 'px ' + spread + 'px ' + color;
                }
            },
            
            /**
             * Removes any drop shadow from the supplied element.
             * 
             * @param {HTMLElement} el The HTMLElement whose drop shadow should be removed.
             */
            removeShadow: function removeShadow(el) {
                var s = el.style;
                if ($D.isDXIE) {
//                    s.filter += "progid:DXImageTransform.Microsoft.dropshadow(OffX=" + xOff + "px, OffY=" + yOff + "px, Color='" + color + "')";
                } else if ($D.isFF || $D.isWK || $D.isIE10) {
                    s[$D.CSS3_BOXSHADOW] = '';
                }
            },
            
            /**
             * Set opacity value on the given element.
             * NOTE: This method is originated from <code>getFilter</code> and <code>setFilter</code> method in DHTML.js.
             * 
             * @param {HTMLElement} el The target HTMLElement to apply the opacity on.
             * @param {integer} value of opacity(between 0 and 100)
             */
            setOpacity: function setOpacity(el, val) {
                if ($D.isDXIE && !$D.isIE9){
                    var filterText = el.currentStyle.filter; 
                    var filter = null;
                    if (filterText.length > 0 ) {
                        filter = el.filters['DXImageTransform.Microsoft.Alpha'];
                    }
                    
                    if(filter) {
                        filter.opacity = val;
                        filter.enabled = (val != 100);
                    } else if (val < 100){
                        var filterDefinition = 'progid:DXImageTransform.Microsoft.Alpha(Opacity='+val+')';
                        el.style.filter = (filterText?filterText:"") + " " + filterDefinition;
                    }
                }else {
                	//TODO: Add validation for IE10??
                    el.style.opacity = val / 100 - ($D.isIE9 ? 0.00001: 0);
                }
            },
            
            /**
             * Builds an object with the browser specific property css name and value for a gradient.
             * 
             * @param {Integer} t The type of gradient (0 = vertical, 1 = horizontal).
             * @param {String} sc The start color.
             * @param {String} ec The end color.
             * 
             * @returns {Object}
             */
            buildGradient: function buildGradient(t, sc, ec) {
                if ($D.supports($D.cssFeatures.GRADIENTS)) {
                    var rtn = {};
                    
                    if ($D.isDXIE) {
                        rtn.n = 'filter';
                        rtn.v = "progid:DXImageTransform.Microsoft.Gradient(GradientType=" + t + ",StartColorStr='" + sc + "',EndColorStr='" + ec + "')";
                        
                    } else if ($D.isFF) {
                        rtn.n = 'background-image';
                        rtn.v = '-moz-linear-gradient(' + ((t === 0) ? 'top' : 'left') + ',' + sc + ',' + ec + ')';
                        
                    } else if ($D.isWK) {
                        rtn.n = 'background';
                        rtn.v = '-webkit-gradient(linear,' + ((t === 0) ? 'left top, left bottom' : 'left top, right top') + ',from(' + sc + '),to('+ ec + '))';
                    } else if ($D.isIE10 || $D.isIEW3C) {
                        rtn.n = 'background';
                        rtn.v = 'linear-gradient(' + ((t === 0) ? 'to bottom' : 'to right') + ',' + sc + ',' + ec + ')';
                    }
                    return rtn;
                }
                
                return null;
            },
            
            /**
             * Returns a String of browser specific css for rounded corners.
             * 
             * @param {Integer} r The single radius value for all borders.
             * @param {Boolean} t True if the top corners are the only rounded corners. 
             * 
             * @returns {String}
             */
            buildRoundCorners: function buildRoundCorners(r, t) {
                if ($D.supports($D.cssFeatures.ROUND_CORNERS)) {
                    var v = r + 'px';
                    var radiusValue = v + ((t) ? ' ' + v + ' 0 0' : '') + ';';
                    
                    if ($D.isFF) {
                        return '-moz-border-radius:' + radiusValue;
                        
                    } else if ($D.isWinPhone || $D.isIE10) {
                    	return 'border-radius:' + radiusValue;
                    	
                    } else if ($D.isWK) {	
                        // Are all four corners the same?
                        if (!t) {
                            // Send one value.
                            return '-webkit-border-radius:' + v + ';';
                            
                        } else {
                            // Otherwise, send four separate values.
                            var ds = ['left', 'right'],
                                css = [],
                                x = -1;
                            
                            for (var i = 0; i < 2; i++) {
                                css[++x] = '-webkit-border-top-' + ds[i] + '-radius:' + v;    // Top is rounded.
                                css[++x] = '-webkit-border-bottom-' + ds[i] + '-radius:0';    // Bottom is not.
                            }
                            
                            return css.join(';');
                        }
                    }
                }
                
                return '';
            },
            
            /**
             * Converts a css "border-width" or "padding" value to an object with individual border width or padding values in pixels.
             * "border-width" and "padding" have the same format so deal with them the same
             * 
             * @param {String} b The value of the "border-width" or "padding" css property which may have 4, 3, 2 or 1 individual border widths or paddings.
             * @param {Integer} dpi The users DPI settings value.
             * 
             * @returns {Object} An object with 't' (top), 'r' (right), 'b' (bottom), 'l' (left), 'h' (top  + bottom) and 'w' (left + right) properties which contain the 
             *  individual border widths or paddings (in pixels) for the supplied border-width or padding value.
             */
            getBorderWidthsOrPaddings: function getBorderWidthsOrPaddings(b, dpi) {
                // Create empty borders object.
                var o = {
                    t: 0,
                    r: 0,
                    b: 0,
                    l: 0,
                    h: 0,
                    w: 0
                };
                
                // Is b undefined or empty?
                if (!b) {
                    return o;
                }

                // Split border value into components.
                var a = b.split(' '),
                    len = a.length;
                
                // Convert point values to pixels.
                for (var i = 0; i < len; i++) {
                    a[i] = Math.round(dpi * parseFloat(a[i], 10) / 72);
                }
                
                // Normalize the components array so there are always four border width values.
                if (len < 4) {
                    // Is there only one value?
                    if (len === 1) {
                        // Add three duplicated values for right, bottom and left.
                        a[1] = a[2] = a[3] = a[0];
                    } else {
                        // Must be 2 or 3 so left border will match right border.
                        a[3] = a[1];
                        // Are there only two values?
                        if (len === 2) {
                            // Bottom border will match top border.
                            a[2] = a[0];
                        }
                    }
                }
                
                // Configure and return borders object.
                o.t = a[0];
                o.r = a[1];
                o.b = a[2];
                o.l = a[3];
                o.h = o.t + o.b; 
                o.w = o.l + o.r;
                
                return o;
            },
            
            /**
             * Refer to getBorderWidthsOrPaddings
             */
            getBorderWidths: function getBorderWidths(p, dpi) {
                return this.getBorderWidthsOrPaddings(p, dpi);
            },
            
            /**
             * Refer to getBorderWidthsOrPaddings
             */
            getPaddings: function getPaddings(p, dpi) {
                return this.getBorderWidthsOrPaddings(p, dpi);
            },
            
            /**
             * <p>Parks an element to the left of the viewport after it fades out.</p>
             * 
             * @param {HTMLEvent} evt An event with a "target" property that points to the element that has faded.
             * 
             * @returns Boolean True if the element was parked.
             */
            parkAfterFade: function parkAfterFade(evt) {
                // Get the style of the element.
                var elStyle = evt.target.style;

                // Is the element hidden?
                if (elStyle.opacity == 0) {
                    // Park the element off to the left of the viewport so it doesn't mask touch events.
                    elStyle.left = '-10000px';
                    
                    // Restore the opacity after a timeout. (Bugfix - in iPhone we see 2 flashes because 
                    //the opacity changes before the mask has been parked
                    window.setTimeout(function() {
                        elStyle.opacity = 0.99;
                    }, 0);

                    // Return true to indicate that the element was parked.
                    return true;
                }
                
                // Return false to indicate that the element was NOT parked.
                return false;
            },
            
            
            /**
             * return computed style property value for specified CSS property, like 'height', etc
             * @param {HTMLDomNode} el - html element
             * @param {String} prop - css property name 
             * @return {String} css property value
             */
            getStyleValue: function getStyleValue(el, prop) {
                if (el.currentStyle){ //IE
                    prop = prop == 'float' ? 'styleFloat' : prop;
                    value = el.currentStyle[prop];
                }
                else if (document.defaultView && document.defaultView.getComputedStyle){ //FF
                    prop = prop == 'float' ? 'cssFloat' : prop; 
                    var styles = document.defaultView.getComputedStyle(el, null); 
                    value = styles ? styles[prop] : null;
                }
                
                return value;           
            },
            
            /**
             * <p>Returns the computed style of current element.</p>
             * 
             * <p>To use, call this method to retrieve the elements style, then query the result for individual properties.</p>
             * 
             * <pre>
             *     var computedStyle = mstrmojo.css.getComputedStyle(elem),
             *         color = cs.color,
             *         vis = cs.visibility;
             * </pre>
             * 
             * @param {HTMLElement} element The HTMLElement for which to get the computed style.
             * @param {String} [pseudoElement] An optional string specifying the pseudo-element to match.  Must be omitted for regular elements.
             * 
             * @returns CSSStyleDeclaration
             */
            getComputedStyle: function(element, pseudoElement) {
                var fn = (window.getComputedStyle) ? 
                        function (element, pseudoElement) {
                            return window.getComputedStyle(element, pseudoElement || null);
                        } : 
                        function (element) {
                            return element.currentStyle || {};
                        };
                        
                mstrmojo.css.getComputedStyle = fn;
                
                return fn(element, pseudoElement);
            }
            
        });
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.array",
                         "mstrmojo.hash",
                         "mstrmojo.StringBuffer");

    var $D = mstrmojo.dom,
        $H = mstrmojo.hash,
        $A = mstrmojo.array;

    /**
     * Destroys any infoWindows associated with this document.
     *
     * @private
     */
    function destroyInfoWindows() {
        // Iterate infoWindow map and destroy each.
        $H.forEach(this.ifwMap, function (infoWindow) {
            infoWindow.destroy();
        });

        // Reset infoWindow map.
        this.ifwMap = {};
    }

    /**
     * Records all visible info window positions
     */
    function recordInfoWins() {
        var ifwrds = [],
            sellyt = null,
            docScroll = null;
        $H.forEach(this.ifwMap, function (ifw) {
            if (ifw.visible) {
                ifwrds.push({
                    psId: ifw.psId,
                    psKey: ifw.psKey,
                    anchorPos: ifw.anchorPosition || $D.position(ifw.anchor, true),
                    anchorOrn: ifw.anchorOrientation
                });
            }
        });
        
        if (ifwrds.length > 0) {
            sellyt = this.getSelectedLayoutWidget();
            docScroll = sellyt && sellyt.getScrollPos();
        }
        
        return {ifwRecords: ifwrds, docScrollRecord: docScroll};
    }
    
    /**
     * Restores all visible info window after rebuild current layout
     */
    function restoreInfoWins(rd) {
        var ifwrds = (rd && rd.ifwRecords) || [],
            docScroll = rd && rd.docScrollRecord,
            sellyt = this.getSelectedLayoutWidget(),
            me = this,
            fakeAnchor= {};
        
        if (ifwrds.length > 0) {
            if (docScroll && sellyt) {
                sellyt.scrollTo(docScroll);
            }
            
            $A.forEach(ifwrds, function (rd) {
                me.showInfoWindow(rd.psId, rd.psKey, fakeAnchor, null, rd.anchorOrn, rd.anchorPos)
            })
        }
    }

    //destroy/close all the popups
    function destroyPopups() {
        mstrmojo.DICPopup && mstrmojo.DICPopup.cancel && mstrmojo.DICPopup.cancel();
    }
    /**
     * Remove xtab style sheet node from the page
     */
    function clearXtabStyleSheet() {
        // Delete the lingering CSS styles.
        if (this.xtabStyleSheets) {
            var stylesheet, i, parentNode;
            for (i = 0; stylesheet = this.xtabStyleSheets[i]; i++) {
                parentNode = stylesheet.parentNode;
                if (parentNode) {
                    parentNode.removeChild(stylesheet);
                }
            }
        }
    }

    function updateDocGroupBy(layoutKey, gbys) {
    	var layout = this.getLayout(layoutKey),
            docGB = layout.docGroupBy,
            ctrl = this.controller;

    	if (docGB) {
    		docGB.set('data', gbys.groupbys);
    		layout.gb = gbys;
    	}

        if (ctrl.getPageByTree) {  // #762973
            ctrl.getPageByTree(true);
        }
    }

    /**
     * A mixin to add Report Services Document functionality to widgets.
     */
    mstrmojo._IsRwDocument = {

        _mixinName: 'mstrmojo._IsRwDocument',

        /**
         * <p>Updates the style section in the header with the new styles string.</p>
         *
         * <p>If the items in the newStyles objects already exist, the cached xtabStyle replaces the items with the new
         * values in newStyle object. Otherwise, it will append the new style strings in the end.</p>
         *
         * @param {Object} newStyles A JSON object with grid name as the keys and style string as the values.
         */
        updateXtabStyles: function updateXtabStyles(layoutKey, newStyles) {
            var styleSheet = this.xtabStyleSheets && this.xtabStyleSheets[0],
                styleList = this.styleList || {},    // Map object which keeps the style maps for each layout.
                fnAddStyles = function (tgt, src) {  // Helper function to add the style string into map.
                    var srcKey;

                    // Iterate keys in source styles object.
                    for (srcKey in src) {
                        // Retrieve the new css.
                        var newCss = src[srcKey].css || '';

                        // Is the app flag on?
                        if (src[srcKey].app) {
                            // Append the new css.
                            newCss = (tgt[srcKey] || '') + newCss;
                        }

                        // Set combined (or replaced) css on target.
                        tgt[srcKey] = newCss;
                    }

                    return tgt;
                },
                doc = document;

            // Do we not already have existing styles for the current layout?
            if (!styleList[layoutKey]) {
                // Initialize with existing xtab styles.
                styleList[layoutKey] = fnAddStyles({}, this.model.getSelectedXtabStyles(layoutKey));
            }

            // Add new styles to the current styles.
            fnAddStyles(styleList[layoutKey], newStyles);

            // Does the stylesheet element NOT already exist?
            if (!styleSheet) {
                // Append new style element to head.
                this.xtabStyleSheets = [];
                styleSheet = this.xtabStyleSheets[0] = doc.getElementsByTagName('head')[0].appendChild(doc.createElement('style'));
            }

            // Build css text.
            var cssText = new mstrmojo.StringBuffer(),
                tgt,
                css;
            for (tgt in styleList) {
                for (css in styleList[tgt]) {
                    cssText.append(styleList[tgt][css]);
                }
                cssText.append('\n');
            }

            // Convert to string.
            cssText = cssText.toString();

            // Do we have a style sheet and new css text?
            if (styleSheet && cssText) {
                // In some browsers (IE), we need to manipulate the <style>'s "styleSheet" child object;
                // in others, we just manipulate the <style> directly.
                styleSheet = styleSheet.styleSheet || styleSheet;

                // Is this a webkit browser?
                if ($D.isWK) {
                    // Does the stylesheet already have a first child?
                    var firstChild = styleSheet.firstChild;
                    if (firstChild) {
                        // Replace node value with new css.
                        firstChild.nodeValue = cssText;
                    } else {
                        // Append new css as text node.
                        styleSheet.appendChild(doc.createTextNode(cssText));
                    }
                } else if ($D.isIE) {
                    // For IE we use cssText
                    styleSheet.cssText = cssText;
                    
                    // For IE6 to 9,
                    // * All style tags after the first 31 style tags are not applied.
                    // * All style rules after the first 4,095 rules are not applied.
                    // TQMS 794206: Try to apply style rules as many as possible. 
                    var count, lastRule, selectorText, index;
                    for (count = 1; styleSheet.rules.length === 4095 && doc.styleSheets.length < 31; count++) {
                        lastRule = styleSheet.rules[4094];
                        selectorText = new RegExp(lastRule.selectorText, 'i');
                        index = cssText.search(selectorText);
                        if (index === -1) {
                            break;
                        }
                        index = cssText.indexOf('}', index + 1);
                        // Extract style rules that are not applied
                        cssText = cssText.slice(index + 1);
                        if (!this.xtabStyleSheets[count]) {
                            this.xtabStyleSheets[count] = doc.getElementsByTagName('head')[0].appendChild(doc.createElement('style'));
                        }
                        styleSheet = this.xtabStyleSheets[count].styleSheet;
                        styleSheet.cssText = cssText;
                    }
                } else {
                    // For others we replace innerHTML.
                    styleSheet.innerHTML = cssText;
                }
            }

            // Store the style list back on the instance.
            this.styleList = styleList;
        },

        /**
         * Overridden to set the xtab style sheet to the html page
         */
        postBuildRendering: function postBuildRendering() {
            //add the xtab style sheet not back to the header if it was removed before
            if (this.xtabStyleSheets) {
                for (var stylesheet, i = 0; stylesheet = this.xtabStyleSheets[i]; i++) {
                    if (!stylesheet.parentNode) {
                        document.getElementsByTagName('head')[0].appendChild(stylesheet);
                    }
                }
            }
            return this._super();
        },

        /**
         * Overridden to set event listeners on the model to hear when the document model has been updated.
         *
         * @ignore
         */
        buildChildren: function buildChildren(noAddChildren) {
            var rtn;

            try {
                var m = this.model;
                if (m) {
                    var subs = this.buildSubs || {},
                        s = m.id + '-partialUpdate',
                        r = m.id + '-rebuildLayout',
                        u = m.id + '-updateStyles',
                        ifw = m.id + '-showInfoWin',
                        id = this.id;
                    
                    //TQMS#770920, force layouts to be reloaded
                    var me = this,
                        unloadLayoutCache = function() {
                            $A.forEach(me.getLayouts(), function(l) {
                                if (l.k !== m.currlaykey) {
                                    l.defn.loaded = false;
                                }
                            });
                        };

                    // Create subscriptions.
                    if (subs[s] === undefined) {

                        /**
                         * <p>Asks the model for a set of nodes that represent changes in descendant widgets resulting from
                         * some update operation, like a slice.</p>
                         *
                         * <p>This method is responsible for overseeing the update of the descendant widgets; it asks each appropriate
                         * widget to update its changed data and to refresh.</p>
                         *
                         * @param {mstrmojo.Event} evt The partialUpdate event.
                         * @inner
                         */
                        var fnUpdate = function updateDescendants(evt) {
                            var m = this.model,
                                dataCache = m && m.getLayoutDataCache(m.getCurrentLayoutKey()),
                                ids = evt && evt.ids;

                            // Do we have an empty data cache OR do we not have an ids object?
                            if ($H.isEmpty(dataCache) || !ids) {
                                // No, then there is nothing to do.
                                return;
                            }

                            // Iterate layouts.
                            $A.forEach(evt.tree.layouts, function (l) {
                                // Is this the current layout?
                                if (l.k === m.currlaykey) {
                                    // Update xtab styles.
                                    this.updateXtabStyles(l.k, l.xtabStyles);

                                    // #713788. update GroupBys
                                    if (l.gbys) updateDocGroupBy.call(this, l.k, l.gbys);

                                    // Return false so iteration will cease.
                                    return false;
                                }
                            }, this);

                            var $FE = $H.forEach,
                                shouldNotifyScrollListeners = false,
                                ups = {
                                    update: ids.upd,
                                    refresh: ids.tgts,
                                    adjustSectionSize: ids.secs
                                };

                             // Info Window will be opened before partial update
//                            $FE(ids.ifws, function (psId, psKey) {
//                                // TQMS #555940: Invalidate the existing info window so that children can revert there state (to avoid lingering graph images, etc).
//                                this.showInfoWindow(psId, psKey, evt.anchor, true, evt.anchorOrientation);
//                            }, this);

                            // update the info window panel stacks. #769091
                            // #836663. Info Win is opened before partial update
                            $FE(ids.ifws, function (psId, psKey) {
                                var infoWindow = mstrmojo.all[psId + '_ifw'];

                                // Have we already opened the info window?
                                if (infoWindow && infoWindow.visible) {
                                    this.updateInfoWindowPS(psId, psKey);
                                }
                            }, this);

                            // Iterate collection of ids/methods to be called on widgets.
                            $FE(ups, function (col, meth) {
                                // Iterate ids in this collection.
                                $FE(col, function (v, id) {
                                    // Get the widget.
                                    var w = mstrmojo.all[id],
                                        rtn;

                                    // Does the widget have this method?
                                    if (w && w[meth] !== undefined) {
                                        // Call the method, passing in the node from the dataCache.
                                        // XZ: only update needs the cached data as the parameter.
                                        rtn = w[meth](meth === 'update' ? dataCache[id] : null);

                                        //Calculate whether we need to notify the scroll listeners
                                        if (meth === 'adjustSectionSize' && rtn) {
                                            //TQMS 479853/436050:  Need to render the objects that are originally not in the viewport.
                                            shouldNotifyScrollListeners = shouldNotifyScrollListeners || (!!rtn.heightReduced);
                                        }
                                    }
                                }, this);
                            }, this);

                            var selectedLayout = this.getSelectedLayoutWidget();

                            //Notify scroll listeners that they may now be in view and need to be rendered.
                            if (shouldNotifyScrollListeners) {
                                selectedLayout.notifyScrollListeners();
                            }

                            // Auto width units may have rerendered so we call resizeOrReposition to make sure
                            // width of layout is correct.
                            var docLayout = selectedLayout.docLayout;
                            if (docLayout) {
                                docLayout.resizeOrReposition();
                            }
                            
                            //TQMS#770920, force layouts to be reloaded when UConDS
                            if(evt && evt.unloadCache) {
                                unloadLayoutCache();
                            }
                        };

                        subs[s] = m.attachEventListener('partialUpdate', id, fnUpdate);
                    }

                    // Attach an event listener to hear when the document layout should be rebuilt.
                    subs[r] = subs[r] || m.attachEventListener('rebuildLayout', id, function (evt) {
                        var restoreIW = evt && evt.restoreIW,
                            ifwRecords;
                        
                        if (restoreIW) { // #999259. record positions of all visible info windows
                            ifwRecords = recordInfoWins.call(this);
                            this.model.aws = null; // reset auto width widgets collection to null.
                        }
                        
                        //TQMS 518043. The OIVM and Mobile documents us different layouts collections.
                        this.onLayoutRebuilt(this.rebuildLayout(evt.src.currlaykey, this.getLayouts()));
    
                        //TQMS#770920, force layouts to be reloaded when UConDS
                        if (evt && evt.unloadCache) {
                            unloadLayoutCache();
                        }
                        
                        if (restoreIW) { // #999259. restore visible info windows after rebuild layout
                            restoreInfoWins.call(this, ifwRecords);
                        }
                    });

                    // Attach an event listener to hear when the document style is changed.
                    subs[u] = subs[u] || m.attachEventListener('updateStyles', id, function (evt) {
                        this.updateXtabStyles(evt.key, evt.updatedStyles);
                    });

                    subs[ifw] = subs[ifw] || m.attachEventListener('showInfoWin', id, function (evt) {
                        this.showInfoWindow(evt.psId, evt.psKey, evt.anchor, evt.invalidate, evt.anchorOrientation, evt.anchorPosition);
                    });

                    this.updateXtabStyles(m.getCurrentLayoutKey());

                    //attache refresh event listener
                    m.attachEventListener('refresh', this.id, function () {
                        this.refresh();
                    });
                }

                rtn = this._super(noAddChildren);


            } catch (ex) {
                mstrmojo.err(ex);
            }

            return rtn;
        },

        /**
         * Adds a handler to handle the info window once all widgets have been refreshed.
         *
         * @param {String} psId The id of the panel stack.
         * @param {String} psKey The RW unit key of the panel stack.
         */
        updateInfoWindowPS: mstrmojo.emptyFn,

        /**
         * Displays an info window.
         *
         * @param {String} psId The id of the panel stack.
         * @param {String} psKey The RW unit key of the panel stack.
         * @param {HTMLElement} anchor The HTML Element to which the info window should be anchored.
         * @param {Boolean} [invalidate=false] Whether to invalidate the children before opening the info window.
         * @param {String} anchorOrientation
         * @param {Object} anchorPosition
         */
        showInfoWindow: function showInfoWindow(psId, psKey, anchor, invalidate, anchorOrientation, anchorPosition) {
            var model = this.model,
                dataCache = model.getLayoutDataCache(model.getCurrentLayoutKey()),
                builder = this.builder,
                ifwDefn = dataCache[psId] && dataCache[psId].defn,
                infoPlacement = ifwDefn && ifwDefn.iwpl,
                id = psId + "_ifw",
                infoWindow = mstrmojo.all[id],
                domNode = this.domNode,
                ENUM_FIXED_PLACEMENT = mstrmojo.DocInfoWindow.PLACEMENT.FIXED,
                updatePopupPosition = function (infoWindowObj, parentDomNode, layoutNode, left, top) {
                    if (infoPlacement === ENUM_FIXED_PLACEMENT) {
                        if(parentDomNode){
                        var parentPosition = $D.delta(parentDomNode, domNode); // get the position of IW's parent widget

                        // #718591. adjust IW's position according to its container
                        infoWindowObj.popPosition = {
                            left: (parentPosition && parentPosition.x) ? left + parentPosition.x : left,
                            top: (parentPosition && parentPosition.y) ? top + parentPosition.y : top
                        };
                        }else if(layoutNode){
                            infoWindowObj.popPosition = {
                                    left: (layoutNode.scrollboxLeft) ? left - layoutNode.scrollboxLeft : left,
                                    top: (layoutNode.scrollboxTop) ? top - layoutNode.scrollboxTop : top
                                };
                        }else{
                            infoWindowObj.popPosition = {
                                    left: left,
                                    top: top
                                };
                        }
                    }
                };

            var layoutNode = this.getLayout(model.getCurrentLayoutKey());
            // Do we already have an info window widget?
            if (infoWindow) {
                if (invalidate) {
                    // if data is invalidated, refresh Info Win.
                    infoWindow.refresh();
                }

                infoWindow.anchorOrientation = anchorOrientation;
                infoWindow.anchorPosition = anchorPosition;

                // Update the info window popup's position.
                updatePopupPosition(infoWindow, infoWindow._ifwpdn, layoutNode, infoWindow._ifwfl, infoWindow._ifwft);

                // Open info window.
                infoWindow.open(this, {
                    anchor: anchor,
                    boundary: domNode
                });

            } else {
                var cfg = {
                        opener: this,
                        anchor: anchor,
                        anchorOrientation: anchorOrientation,
                        boundary: domNode,
                        parent: this,
                        builder: builder,
                        model: this.model,
                        psKey: psKey,
                        psId: psId,
                        id: id,
                        autoCloses: true,
                        locksHover: true,
                        closeOnClick: false,
                        anchorPosition: anchorPosition
                    };

                if (infoPlacement) {
                    infoPlacement = parseInt(infoPlacement, 10);
                    cfg.placement = infoPlacement;

                    // Are we dealing with a fixed positioned info window.
                    if (infoPlacement === ENUM_FIXED_PLACEMENT) {
                        var formats = ifwDefn.fmts,
                            left = cfg._ifwfl = formats && formats.left && parseInt(formats.left.replace('px', ''), 10), // 'left' value in formats definition
                            top = cfg._ifwft = formats && formats.top && parseInt(formats.top.replace('px', ''), 10),  // 'top' value in formats definition
                            infoWindowParent = dataCache[psId] && dataCache[psId].p,
                            parentObject = infoWindowParent && model.getUnitInstance(infoWindowParent.k, infoWindowParent.wid),
                            parentDomNode = cfg._ifwpdn = parentObject && parentObject.domNode;

                        // Update the info window popup's position.
                        updatePopupPosition(cfg, parentDomNode, layoutNode, left, top);
                    }
                }

                // Create new info window.
                infoWindow = builder.newInfoWindow(cfg);

                // Render info window.
                this.renderInfoWindow(infoWindow);

                // Get info window map (or create if missing) and store new info window in map.
                var infoMap = this.ifwMap = (this.ifwMap || {});
                infoMap[psId] = infoWindow;
            }
        },

        /**
         * This method renders a info window for the RW Document.
         */
        renderInfoWindow: function renderInfoWindow(infoWindow) {
            infoWindow.render();
        },

        _lockInfoWinContainer: function lockInfoWinContainer(config) {
            var ifwm = this.ifwMap,
                k;
            for (k in ifwm) {
                var ifw = ifwm[k],
                    xtab = config.xtab;
                if (ifw && xtab &&
                        $D.contains(ifw.infoNode, xtab.domNode, true, document.body)) {
                    ifw.autoCloseLocked = true;
                    config.onClose = function () {
                        ifw.autoCloseLocked = false;
                    };
                    break;
                }
            }
        },

        /**
         * Overridden to destroy info windows.
         *
         * @ignore
         */
        unrender: function unrender(ignoreDom) {
            // Make sure info windows have been destroyed.
            destroyInfoWindows.call(this);

            this._super(ignoreDom);

            clearXtabStyleSheet.call(this);
        },

        getLayouts: function getLayouts() {
            return this._layouts;
        },

        /**
         * Returns the layout with specified key. If the key is not specified
         * it will return the current layout.
         */
        getLayout: function getLayout(key) {
            key = key || this.model.getCurrentLayoutKey();
            var layouts = this.getLayouts();
            return layouts[$A.find(layouts, 'k', key)];
        },

        getNewLayout: function getNewLayout(params, layouts, isSelected, callback) {
            var me = this,
                model = me.model,
                dataService = model.getDataService(),
                key = params.layoutKey,
                layout = layouts[$A.find(layouts, 'k', key)];  // existing layout

            // Has the newly selected layout NOT been loaded yet or do we want to reload on purpose? #606981 additional check to see if the last orientation is not similar to the current orientation
            if (layout.defn && (params.reload || layout.defn.loaded === false || (model.zt && (window.mstrMobileApp !== undefined) && (layout.defn.lastOrientation !== mstrMobileApp.getOrientation())))) {
                // Replace callback success method.
                var fnSuccess = callback.success;
                callback.success = function (res) {

                    // Replace the data for this new layout.
                    model.replaceLayout(key, res);

                    // Since we just requested this layout from the server the server now thinks it's the current layout so we should update
                    // the current layout key on the model.
                    model.currlaykey = key;

                    // Will the new layout be selected?
                    if (isSelected) {
                        // TQMS 496226: Set the zoom factor value first
                        layout.zf = res.zf;

                        // Select the layout (passing false so the server is not updated).
                        me.selectLayout(layout, false);
                    }


                    var newLayout = me.rebuildLayout(key, layouts);

                    if (me.controller.getPageByTree) {  // #712394
                        me.controller.getPageByTree(true);
                    }

                    // Pass the newly created layout viewer back to the callback.
                    fnSuccess(newLayout);
                };

                // Ask data service to retrieve layout from server.
                dataService.loadDocLayout(params, callback);

            } else {
                // Pass the original layout back to the callback.
                callback.success(layout);

                // Should the new layout be selected?
                if (isSelected) {
                    // Update the server if the new layout is different than the current layout.
                    this.selectLayout(layout, true, {
                        success: function (res) {
                            $H.copyProps(['bs'], res, model);
                        }
                    });
                }

            }
        },

        selectLayout: function selectLayout(layout, updateServer, callback) {
            // Pull the key out of the layout and figure out if it's different then the models current layout key.
            var model = this.model,
                key = layout.k,
                isNewKey = (key !== model.currlaykey);

            // Replace current layout key on the model.
            model.currlaykey = key;

            // Restore the layout state.
            this.restoreLayoutState(layout);

            // Was a server update requested AND did the layout key actually change?
            if (updateServer && isNewKey) {
                // Update the server.
                model.getDataService().setCurrentDocLayout(key, callback);

            // No server update, but do we have a callback complete handler?
            } else if (callback && callback.complete) {
                // Call the callback complete.
                callback.complete();
            }

            // Return the layout.
            return layout;
        },

        /**
         * Destroys the current mstrmojo.DocLayoutViewer and then builds a mstrmojo.DocLayoutViewer for the supplied key.
         *
         *  @param {String} k The key of the layout to create.
         *
         *  @type mstrmojo.DocLayoutViewer
         *  @returns The newly created {@link mstrmojo.DocLayoutViewer} widget.
         *
         *  @private
         */
        rebuildLayout: function rebuildLayout(k, layouts) {
            var model = this.model,
                findLayout = $A.find,
                oldLayout = layouts[findLayout(layouts, "k", k)],
                nodes = model.getChildren(this.node, false);

            var newLayout = nodes[findLayout(nodes, 'k', k)];

            // #606981 set the current orientation to the new layout
            if (window.mstrMobileApp !== undefined) {
                newLayout.defn.lastOrientation = mstrMobileApp.getOrientation();
            }

            // Replace the old child with newly built children nodes.
            var c = this.replaceLayout(oldLayout, newLayout);

            // Update Xtab styles for new layout.
            this.updateXtabStyles(k, model.getSelectedXtabStyles(k));

            // Remove all existing info windows.
            destroyInfoWindows.call(this);

            destroyPopups();
            // Return new DoclayoutViewer.
            return c;
        },



        /**
         * @see mstrmojo.Widget
         */
        destroy: function destroy() {

            // Destroy any info windows when the document is destroyed [TQMS#494881]
            destroyInfoWindows.call(this);

            //Call super to destroy the RW document.
            if (this._super) {
                this._super();
            }

            clearXtabStyleSheet.call(this);
        },

        /**
         * <p>Abstract method to replace one layout with another.</p>
         *
         * <p>Consumers of this mixin will implement this method to decide how they want to replace layout.</p>
         *
         * @param {mstrmojo.DocLayoutViewer} oldLayout The old layout viewer to replace.
         * @param {Object} newLayoutNode The node for creating the new layout viewer.
         *
         * @returns{mstrmojo.DocLayoutViewer} The newly created DocLayoutViewer.
         */
        replaceLayout: mstrmojo.emptyFn,

        /**
         * <p>Abstract method to perform any custom layout state restoration in consumers of this mixin.</p>
         *
         */
        restoreLayoutState: mstrmojo.emptyFn,

        /**
         * Called after the model has requested that the current layout be rebuilt.
         *
         * @param {mstrmojo.DocLayoutViewer} layout The newly rebuild layout viewer.
         */
        onLayoutRebuilt: mstrmojo.emptyFn,

        /**
         * Unloads non-current layouts with the same group by as specified
         */
        unloadGbLayuts: function unloadGbLayuts(groupbyKey) {
            var layouts = this.getLayouts(),
                curLayoutKey = this.model.getCurrentLayoutKey(),
                layout,
                i,
                gb,
                groupbys,
                k,
                gbDssId;

            //First find the changed group by DSS ID
            layout = this.getLayout();
            groupbys = layout.gb && layout.gb.groupbys;
            for (k = 0; k < groupbys.length; k++) {
                gb = groupbys[k];
                if (gb.k === groupbyKey) {
                    gbDssId = gb.unit.target.did;
                    break;
                }
            }

            //Now unload layouts containing group bys with the same DSS ID as changed group by.
            for (i = 0; i < layouts.length; i++) {
                layout = layouts[i];
                if (layout.k === curLayoutKey) {
                    continue;
                }
                groupbys = layout.gb && layout.gb.groupbys;
                if (groupbys && groupbys.length) {
                    for (k = 0; k < groupbys.length; k++) {
                        gb = groupbys[k];
                        if (gb.unit.target.did === gbDssId) {
                            //Instead of physically unloading the layout we simply mark is as not-loaded.
                            //Next time we switch to this layout it will be loaded.
                            layout.defn.loaded = false;
                            break;
                        }
                    }
                }
            }
        }
    };
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.registry", "mstrmojo.hash");
    
    var _loadedCls = false,
        _FQCN = "mstrmojo.Binding",
        _B = "bindings",
        _R = mstrmojo.registry;
    
    /**
     * Disables a given collection of binding objects.
     * @param {Object} bs Hash of binding objects.
     * @private
     */
    function _shutdown(bs) {
        for (var d in bs) {
            var b = bs[d];
            if (b && b.disable) {
                b.destroy();
            }
        }
    }
    
    /**
     * Enables a given collection of either binding objects or references to binding objects.
     * @param {Object} bs Hash of binding objects or references.
     * @param {Object} p The parent object to which these bindings belong.
     * @private
     */
    function _startup(bs, p) {
        // Load the Binding class (one-time only).
        if (!_loadedCls) {
            mstrmojo.requiresCls(_FQCN);
            _loadedCls = true;
        }
        // For each binding config...
        for (var d in bs) {
            var b = bs[d];
            if (b == null) {    // if b is null or undefined
                continue;
            }
            var t = typeof(b);
            // Strings values are shorthand for binding "source" properties;
            // otherwise assume we have an object value. 
            if (t === "string" || t === "function") {
                b = {
                        destination: d,
                        source: b,
                        scriptClass: _FQCN
                    };
            }
            // Before creating the binding, set its parent handle (in case it uses it).
            b.parent = p;
            // Evaluate the binding reference into a binding object and start it up.
            // Optimization: skip class loaded check, because we assume we've already loaded the one binding class above.
            b = _R.ref(b, {skipLoadChecks: true});
            bs[d] = b;
            b.enable();
        }
    }
    
    /**
     * <p>Enables the use of bindings to determine property values on a given object.</p>
     *
     * <p>The object is expected to have a "bindings" property whose value is a hashtable, which is keyed by destination name; 
     * the hash values are configs for instances of Binding objects.</p>
     *
     * @class
     * @public
     */
    mstrmojo._HasBindings = mstrmojo.provide(
    "mstrmojo._HasBindings",
    /**
     * @lends mstrmojo._HasBindings#
     */
    {
        _meta_usesSuper: false,

        /**
         * <p>Hash of bindings defined for this object.</p>
         * 
         * @type {Object}
         */
        //bindings: null,
        
        /**
         * <p>Optional handler called after initialization of bindings.</p>
         *
         * <p>This handler is supported as a customization hook at the end of the binding creation process.
         * If specified, the handler will be called after the instance's bindings have been initialized.
         * If the instance has no bindings, the handler will not be called.</p>
         *
         * @type Function
         */
        //postCreateBindings: null,

        /**
         * <p>Initializes the bindings for properties in this object and its children (if any).</p>
         *
         * <p>This method first inspects this object's "bindings" property. If given, this method creates
         * bindings from that property value. Then this method calls the "initBindings" method of this object's children
         * (if any) regardless of whether or not this object has any bindings.</p>
         */
        initBindings: function inB() {
            this.hasInitBindings = true;

            var bs = mstrmojo.hash.copy(this[_B]);
                
            if (bs) { 
                delete this[_B];
                this._set_bindings(_B, bs, true);
                // Hook for customizations after creating bindings.
                if (this.postCreateBindings) {
                    this.postCreateBindings();        
                }
            }
            
            var ch = this.children;
            if (ch) {
                for (var i=0, len=ch.length; i<len; i++) {
                    var c = ch[i];
                    if (c && c.initBindings) {
                        c.initBindings();
                    }        
                }
            }
        },
        
        destroyBindings: function destB(){
            var bs = this.bindings;
            if (bs) {
                _shutdown(bs);
                delete this.bindings;
            }
        },
        
        /**
         * <p>Custom setter for the "bindings" property value.</p>
         *
         * <p>This method will apply a given hash of bindings to this object.
         * It initializes the values of the bound properties in this object.
         * Any bindings previously in the "bindings" property are removed first.</p>
         *
         * <p>This method inspects the given bindings hash. Each hash key is the
         * name of a bound property; each hash value is either an instance of a Binding object,
         * or a reference to a Binding. A "reference" is either a String (which serves as the
         * source script for a new Binding) or a hashtable of properties for a new Binding, which
         * is resolved via the mstrmojo.registry.ref method.</p>
         *
         * @param {String} [n="bindings"] The property whose value is being set.
         * @param {Object} [v] Hash of either binding objects or references to binding objects.
         * @returns {Boolean} true if the "bindings" hash object was reset; false otherwise.
         */
        _set_bindings: function setB(n, v) {
            var bs = this[_B];
            if (v !== bs){
                if (bs) {
                    _shutdown(bs);
                }
                this[_B] = v;
                if (v) {
                    _startup(v, this);
                }
                return true;
            }
            return false;
        }
    });

})();
(function(){

    mstrmojo.requiresCls("mstrmojo.dom");

	mstrmojo.fx = {enabled: true};
	
	var $DOM = mstrmojo.dom;	

	
	/**
	 * _Effect is an abstract base class for all visual effects.  It implements the machinery for a generic effect,
	 * but omits the "exec()" method which actually applies a change to the GUI.  That method is expected to be implemented
	 * by subclasses of _Effect.
	 */
	mstrmojo.fx._Effect = mstrmojo.declare(
		// superclass
		null,
		// mixins
		null,
		// instance members
		{
			scriptClass: "mstrmojo.fx._Effect",
			
			/**
			 * Length (in millisec) of the entire effect.
			 */
			duration: 500,
			
			/**
			 * Length (in millisec) of pause in between steps of this effect's animation.
			 */
			interval: 50,
			
			/**
			 * Optional delay (in millisec) before effect is started once play() is called.
			 */
			delay: null,
			
			/**
			 * The object to which this effect is applied.
			 */
			target: null,
			
			/**
			 * Optional getter function for "target" property.  If specified, called at start-time (before "preStart").
			 */
			getTarget: null,
			
			/**
			 * Optional handle to the widget whose DOM will be targeted. An alternative to using "target" or "getTarget".
			 * If those 2 properties are omitted and "widget" is provided, the target will be set to a slot in the widget.
			 */
			widget: null,
			
			/**
			 * If "widget" is provided, the name of the widget's slot which will be targeted ("domNode" by default).
			 */
			slot: null,
			
			/**
			 * Optional handler, called before effect is started. For customization.
			 */
			preStart: null,

			/**
			 * Optional handler, called before effect is started. For customization.
			 */
			postStart: null,

			/**
			 * Optional handler, called before effect is started. For customization.
			 */
			onCancel: null,

			/**
			 * Optional handler, called after effect is successfully completed. For customization.
			 */
			onEnd: null,

			/**
			 * If true and the effect is cancelled while playing, the start value of the effect
			 * will be reapplied to the target.
			 */
			revertOnCancel: true,
			
			/**
			 * This boolean gets set to true when play() is called, and to false when
			 * either pause() or cancel() are called, or when the animation's steps are completed.
			 */
			isPlaying: false,
			
			/**
			 * This boolean gets set to true after both (1) play() is called and (2) the start delay
			 * (if any) is over. Gets reset to false after effect ends or is cancelled.
			 */
			started: false,
			
			/**
			 * Applies the given properties to this instance.
			 */
			init: function init(/*Object?*/ props) {
				mstrmojo.hash.copy(props, this);
			},
									
			/**
			 * Plays this effect, beginning with the effect's delay (if any).
			 */
			play: function ply() {
				this.isPlaying = true;
				this.started = false;
				if (this.delay) {
					var me = this;
					this.delayTimer = window.setTimeout(
						function() {
							me._start();
							me = null;
						},  
						this.delay
					);
				} else {
					this._start();
				}
			},
			/**
			 * Prevents the effect from continuing to play any further.
			 */
			pause: function pause() {
				if (this.delayTimer) {
					window.clearTimeout(this.delayTimer);
					delete this.delayTimer;
				}
				if (this.timer) {
					window.clearInterval(this.timer);
					delete this.timer;
				}
				this.isPlaying = false;
			},

			/**
			 * Prevents the effect from continuing to play, optionally re-applies the start value, and
			 * fires the onCancel callback, if any.
			 */
			cancel: function cnl() {
				this.pause();
				if (this.started) {
					if (this.revertOnCancel) {
						this.counter = 0;
						this.exec();
					}
					if (this.onCancel) {
						this.onCancel();
					}
					this.started = false;
				}
			},
						
			/**
			 * Kicks off the application of this effect, possibly after a delay.
			 */
			_start: function start() {
				this.started = true;

				// Call the target getter method, if given.
				this._doTarget();

				// Calculate the # of animation steps required.
				// If duration = 0, do animation in 1 step.
				this.steps = Math.max(
								Math.ceil(this.duration/this.interval), 
								1);
				
				// Validate the ease property; could be a Function or String.
				var ea = this.ease;
				if (typeof(ea) == "string") {
					this.ease = mstrmojo.registry.ref(ea);
				}
				
				// Call any pre-start method from the animation's config.
				if(this._doPreStart() === false) {
				    this.started = false;
				    this.isPlaying = false;
				    return;
				}

				// Start the animation immediately.
				this.counter = 0;
				this.exec();
				this.counter++;

				// Call postStart, if any.
				this._doPostStart();
				
				// Do any steps remain?
				if (this.counter >= this.steps) {
					// No, cleanup.
					this._end();
				} else {
					// Yes, continue animation in a repeating interval.
					var me = this;
					if (this.timer) {
						window.clearInterval(this.timer);
					}
					this.timer = window.setInterval(
							function fxIntvl(){
							    if (me) {
							        me.exec();
							        me.counter++;
							        if (me.counter >= me.steps) {
							            me._end();
							            me = null;
							        }
							    }
							},
							this.interval);
				}
			},

			/**
			 * The method which applies a single step of a given effect.  Intentionally omitted for this
			 * abstract base class; expected to be implemented by subclasses.
			 */			
			exec: null,
			
			/**
			 * Called internally for cleanup after an animation executes all of its steps.
			 */
			_end: function end(){
				// Clear the interval.
				this.pause();
				this.started = false;
				if (this.onEnd) {
					this.onEnd();
				}
			},

            _doTarget: function tgt() {
                // Do we have a target getter?
                if (this.getTarget) {
                    // Assume the getter will return a DOM node.
                    this.target = this.getTarget.apply(this, []);
                } else if (this.widget) {
                    // If we have a widget, target the widget's given slot ("domNode", by default).
                    // Refresh this every time we start, because the slot pointer may have changed (e.g., after a re-render).
                    this.target = this.widget[this.slot || "domNode"];
                } else if (this.target) {
                    // If we do have a target, check if its a widget or DOM node.
                    var t = this.target;
                    if (t && this.slot && t.scriptClass) {
                        var node = t[this.slot];
                        if (node) {
                            this.widget = t;
                            this.target = node;
                        }
                    }
                }
				// Finally, if we don't have a target, just assume it is the domNode of our widget ancestor.
				// Typically, that would be our parent. However, if this effect is used as a child of a Parallel effect,
				// then our parent would be the Parallel effect.  So we want to walk our ancestors until we reach an
				// ancestor with a domNode.
				if (!this.target) {
					var w = this;
					while (w = w.parent) {	// Note: this is an assignment ("="), not a comparison ("==")!
						if (!w || w.domNode){
						  break;
                        }
					}
					if (w) {
						this.widget = w;
						this.target = w[this.slot || "domNode"];
					}
				}
			},

			_doPreStart: function pre(){
				if (this.preStart) {
					 return this.preStart();
				}
			},
			_doPostStart: function post(){
				if (this.postStart) {
					this.postStart();
				}
			}			
		}
	);		

	/**
	 * Utility function used by mstrmojo.fx.Parallel to call methods in all of its children.
	 */
	function _callChildren(me, fName) {
		var arr = me.children;
		for (var i=0, len=(arr&&arr.length) || 0; i<len; i++) {
			arr[i][fName]();
		}
	}
	
	/**
	 * Parallel is essentially a list ("children") of effects which are all played simultaneously when Parallel is played.
	 * Each "child" effect supports its own individual properties, such as "duration", "delay", "preStart", "onEnd", etc.  
	 * Note that "duration" of the Parallel itself is ignored.
	 * Additionally, the Parallel itself supports a "delay" which is applied before any of the children are played.
	 */
	mstrmojo.fx.Parallel = mstrmojo.declare(
		// superclass
		mstrmojo.fx._Effect,
		// mixins
		null,
		// instance members
		{
			scriptClass: "mstrmojo.fx.Parallel",
			
			init: function init(/*Object?*/ props) {
				this._super(props);
				// Inspect our children.  If they are native javascript Objects, try replacing them
				// with newly instantiated javascript classes.
				var ch = this.children;
				mstrmojo.registry.refArray(ch);
				// Set the children's parent pointer.
				for (var i=0, len=(ch&&ch.length)||0; i<len; i++) {
					ch[i].parent = this;
				}
			},
			
			/**
			 * Fires the preStart callback if any, triggers the playing of all the effects in its "children" 
			 * array, and then fires the postStart callback if any.  
			 */
			_start: function start() {
				this.started = true;

				if (this.preStart) {
					this.preStart();
				}

				_callChildren(this, "play");
				
				if (this.postStart) {
					this.postStart();
				}
			},

			/**
			 * Triggers the pause of all the effects in its "children" array.
			 */
			pause: function pause() {
				_callChildren(this, "pause");
			},

			/**
			 * Triggers the cancel of all the effects in its "children" array.
			 */
			cancel: function cnl() {
				_callChildren(this, "cancel");
			}
		}
	);
	
    /**
     * Animates a given property of a given target DOM Node.
     */
    mstrmojo.fx.AnimateProp = mstrmojo.declare(
		// superclass
		mstrmojo.fx._Effect,
		// mixins
		null,
		// instance members
		{
			scriptClass: "mstrmojo.fx.AnimateProp",
			
			/**
			 * Hashtable of style properties animated by this effect.
			 * Keyed by name of the property; value is an object with the following
			 * properties: {start: .., stop: .., suffix: .., ease: ..}.
			 */
			props: null,

			/**
			 * Extends the inherited method in order to validate "ease" property of each
			 * individual property to be animated.
			 */
			_start: function st() {
				// Validate the ease function for each given property. Could be a String that
				// needs to be eval'd into a function.  Do this before calling the inherited method,
				// because that method will perform the first animation step, which will need the ease function.
				var ps = this.props;
				for (var n in ps) {
					var p = ps[n],
						ea = p.ease;
					if (typeof(ea) == "string") {
					    p.ease = mstrmojo.registry.ref(ea, {dontInst: true});
					}
				}
				// Call the inherited method to truly start the animation.
				this._super();

			},
									
			exec: function exec() {
				var ps = this.props;
				for (var n in ps) {
					var p = ps[n],
						v = (p.ease || mstrmojo.ease.sin)(this.counter, p.start, p.stop-p.start, this.steps-1);
					if(p.fn){
					    v = p.fn(v);
					}
					if (p.suffix){
					   v += p.suffix;
                    }
                    var o = p.isStyle === false ? this.target : this.target.style;
                    o[n] = v;
				}
			}
		}
	);
	
	mstrmojo.fx.Typewriter = mstrmojo.declare(
		// superclass
		mstrmojo.fx._Effect,
		// mixins
		null,
		// instance members
		{
			scriptClass: "mstrmojo.fx.Typewriter",
			
			charGroupSize: 1,
			
			/**
			 * This property is used to set the effect's "stop" value if none is provided.
			 * The srcProp is the name of the targeted widget's property from which to read the typewriter text.
			 */
			srcProp: "text",
			
			/**
			 * Extends the inherited method in order to do some additional initialization, and to
			 * support the targetField property.
			 */
			_doPreStart: function () {
				// First call the inherited method to do standard setup.
				this._super();
				
				// Now validate the "stop" property. 
				this._dynStop = false;
				// If it's null, try setting it with the help of the srcProp.
				if (this.stop == null) {    // if null or undefined
					var sp = this.srcProp,
                        st;
					if (sp) {
						var w = this.widget || this.parent;
						st = w && w[sp];
						if ((st != null) && (typeof(st) !== 'string')) {  // if not null and not undefined
							st = String(st);
						}
					}
					this.stop = st;
					this._dynStop = true;
				}
				// If it's still null, use empty string.
				if (this.stop == null) {
					this.stop = "";
				}

				// Prepare the target's innerHTML.				
				var t = this.target,
					ttn = null,
					cgs = 1;

				if (t) {
					t.innerHTML = '';
					ttn = document.createTextNode('');
					t.appendChild(ttn);
					cgs = Math.max(
							Math.floor(this.stop.length / this.steps),
							1);
				}
				this.targetTextNode = ttn;
				this.charGroupSize = cgs;
			},
			
			exec: function() {
				var ttn = this.targetTextNode;
				if (!ttn) {
				    return;
			    }
				
				var v;
				if (this.counter >= this.steps-1) {
					v = this.stop;
				} else if (this.counter === 0) {
					v = '';
				} else {
					v = this.stop.substring(0, this.charGroupSize * this.counter) + '_';
				}
				ttn.nodeValue = v;
			},
			
			_end: function end() {
				this._super();
				if (this._dynStop) {
					this.stop = null;
					delete this._dynStop;
				}
			},
			
			cancel: function cnl() {
				if (this._dynStop) {
					this.stop = null;
					delete this._dynStop;
				}
			}
		}
	);
	
	mstrmojo.requiresCls("mstrmojo.dom");
		
	/**
	 * Animates the opacity of a DOM node.  The target may be specified as either a sDOM node
	 */
	mstrmojo.fx.Fade = mstrmojo.declare(
		// superclass
		mstrmojo.fx._Effect,
		// mixins
		null,
		// instance members
		{
			scriptClass: "mstrmojo.fx.Fade",
			
			/**
			 * "start" and "stop" define a range of values over which this effect will be applied.
			 */
			start: null,
			stop: null,
			
			/**
			 * Optional easing function used to compute in-between values for animation.
			 */
			ease: null,

			/**
			 * Optional suffix to be appended to property values applied by this effect.
			 */
			suffix: null,

			exec: function exec(v) {
				if (v == null) {    // if null or undefined
					v = (this.ease || mstrmojo.ease.sin)(this.counter, this.start, this.stop-this.start, this.steps-1);
				}
				if ($DOM.isIE && !$DOM.isWinPhone) {
					// TO DO: implement opacity via filter
					this.target.style.filter = 'alpha(opacity=' + parseInt(v*100,10) + ')';
					
				} else {
					this.target.style.opacity = v;
				}
			}
		}
	);
	
	/**
	 * A subclass of Fade which fades opacity from 1 to 0, and (optionally) then sets the style.display of target.
	 */
	mstrmojo.fx.FadeOut = mstrmojo.declare(
		// superclass
		mstrmojo.fx.Fade,
		// mixins
		null,
		// instance members
		{
			scriptClass: "mstrmojo.fx.FadeOut",
			
			start: 1,
			stop: 0,
			revertOnCancel: true,
			
			/**
			 * If not null, when the animation is completed the target's style.display will be set to "hidden";
			 * when it is cancelled, if revertOnCancel is true the target's style.display will be set to the cssDisplay value.
			 */
			cssDisplay: 'block',
			
			/**
			 * Extends the inherited method in order to implement the "cssDisplay" feature.
			 */
			_end: function end(){
				if (this.cssDisplay) {
					this.target.style.display = 'none';
					this.exec(this.start);
				}
				this._super();
			},
			
			/**
			 * Extends the inherited method in order to implement the "cssDisplay" feature.
			 */
			cancel: function cnl() {
				if (this.started && this.cssDisplay) {
					this.target.style.display = this.cssDisplay;
				}
				this._super();
			}
		}
	);

	/**
	 * A subclass of Fade which fades opacity from 1 to 0, and (optionally) then sets the style.display of target.
	 */
	mstrmojo.fx.FadeIn = mstrmojo.declare(
		// superclass
		mstrmojo.fx.Fade,
		// mixins
		null,
		// instance members
		{
			scriptClass: "mstrmojo.fx.FadeIn",
			
			start: 0,
			stop: 1,
			revertOnCancel: true,
			
			/**
			 * If not null, when the animation is completed the target's style.display will be set to "hidden";
			 * when it is cancelled, if revertOnCancel is true the target's style.display will be set to the cssDisplay value.
			 */
			cssDisplay: 'block',
			
			/**
			 * Extends the inherited method in order to implement the "cssDisplay" feature.
			 */
			_doPostStart: function postS(){
				if (this.cssDisplay) {
					this.target.style.display = this.cssDisplay;
				}
				this._super();
			},
			
			/**
			 * Extends the inherited method in order to implement the "cssDisplay" feature.
			 */
			cancel: function() {
				if (this.started && this.revertOnCancel && this.cssDisplay) {
					this.target.style.display = 'none';
				}
				this._super();
			}
		}
	);


	function fraction(num, dem, digits) {
		var x = Math.pow(10, digits || 2);
		if (dem) {
			return parseInt(x * num / dem, 10) / x;
		} else {
			return parseInt(x * num,10) / x;
		}
	}
	
	/**
	 * Collection of easing functions, ready to be used with mstrmojo.fx effects.
	 */
	mstrmojo.ease = {
		linear: function ln(t, b, c, d) {
			if (t === d){
				return b+c;
			}else if (t === 0){
				return b;
			}else {
				return b + c * fraction(t, d);
            }
		},
		
		sin: function sin(t, b, c, d) {
			return b + c * Math.sin((Math.PI / 2) * t / d);
		},
		
		cos: function cos(t, b, c, d) {
			return b + c * Math.cos((Math.PI / 2) * (1 - t / d));
		},
		
		sincos: function sincos(t, b, c, d) {
			if (t > d / 2) {
				return b + c * Math.cos((Math.PI / 2) * (1 - t / d));
			} else {
				return b + c * Math.sin((Math.PI / 2) * t / d);
            }
		},
		
		cossin: function cossin(t, b, c, d) {
			if (t > d / 2) {
				return b + c * Math.sin((Math.PI / 2) * t / d);
			} else {
				return b + c * Math.cos((Math.PI / 2) * (1 - t / d));
            }
		},
		
		bounce: function bounce(t, b, c, d) {
			if ((t /= d) < (1 / 2.75)) {
			      return c * (7.5625 * t * t) + b;
			}
			else if (t < (2 / 2.75)) {
			      return c * (7.5625 * (t-=(1.5/2.75)) * t + 0.75) + b;
			}
			else if (t < (2.5 / 2.75)) {
			      return c * (7.5625 * (t-=(2.25/2.75)) * t + 0.9375) + b;
			}
			else {
			      return c * (7.5625 * (t-=(2.625/2.75)) * t + 0.984375) + b;
			}
		},
		
		shake: function shake(t, b, c, d) {
			if (t < d/2) {
				return b + c * fraction(Math.sin(2 * Math.PI * t/8), null, 2) * 2 * t/d;
			} else {
				return b + c * fraction(Math.sin(2 * Math.PI * t/8), null, 2) * 2 *(1-t/d);
//				return b + c * fraction(Math.sin(6 * Math.PI * t/d), null, 2) * 2 *(1-t/d);
			}
		}

	};
	
})();

(function(){

	mstrmojo.requiresCls("mstrmojo.dom");

	/**
	 * Function to validate a listener parameter.
	 * 
	 * @private
	 * @ignore
	 */
	function validateListener(l) {
		return (l && l.id);
	}
	
    /**
     * <p>A mixin for widgets that contain a scrollbox.</p>
     * 
     * @class
     * @public
     */
    mstrmojo._HasScrollbox = 
        /**
         * @lends mstrmojo._HasScrollbox#
         */
        {
            /**
             * Mixin Name
             */
            _mixinName: "mstrmojo._HasScrollbox",
            
            
			/**
			 * A hash of listeners for the scrollbox scroll event.
			 * @type Object
			 */
			scrollListeners: null,   // Warning: do not set to {} here; that will make it class-wide, not instance-wide.
			
			/**
			 * The number of listeners currently listening for the scrollbox scroll event.
			 * @type Integer
			 */
			scrollListenerCount: 0,
			
			/**
			 * Adds the given object as a listener to "scroll" events from the scrollboxNode
			 * of this widget.  The callback is assumed to be the listener's "onscroll" method,
			 * with only a single argument: a handle to this widget instance.
			 */
			connectScrollbox: function cnnScll(/*Object*/ listener) {
				if (!validateListener(listener)) {
					return;
				}
				
				// Add listener to list of previous listeners.
				// Initialize the list if null. 
				var hash = this.scrollListeners,
				    lid = listener.id;
				if (!hash) {
				    hash = {};
				    this.scrollListeners = hash;
				}
				if (!hash[lid]) {
    				hash[lid] = listener;
	       			this.scrollListenerCount++;
    				// If we had no previous listeners, attach a DOM listener to the scrollbox now.
    				if (this.scrollListenerCount == 1) {
    					this._attachScrollDom();
    				}
				}
			},

			disconnectScrollbox: function discnnScll(/*Object*/ listener) {
				if (!validateListener(listener)) {
					return;
				}
				
				// Remove listener from list of listeners.
				var hash = this.scrollListeners,
				    lid = listener.id;
                if (hash != null && lid in hash) {
				    delete this.scrollListeners[lid];
    				this.scrollListenerCount--;
    				// If we have no more listeners, detach DOM listener from the scrollbox for now.
    				if (!this.scrollListenerCount) {
    				    this._detachScrollDom();
    				}
                }
			},
            
			// TO DO: enhancement; if listener doesn't care about horiz-only
			// scrolling, don't notify them of it.
			notifyScrollListeners: function ntfSclls(evt) {
                // Remeasure (and recache) the current scroll position.
                // If it didn't change vertically, don't notify anyone.
			    var p = evt || this.getScrollPos(),
			        top = p.y,
			        left = p.x;
			    
			    this.scrollboxTop = top;
                this.scrollboxLeft = left;
				this.scrollboxRight = left + this.scrollboxWidth;
				this.scrollboxBottom = top + this.scrollboxHeight;
				
				// Notify all listeners via their "onscroll" method.
				var ls = this.scrollListeners;
				for (var id in ls) {
					ls[id].onscroll(this);
				}
			},
			
			getScrollPos: function getScrollPos() {
			    var node = this.scrollboxNode; 
			    return {
			        x: node.scrollLeft,
                    y:  node.scrollTop
			    };
			},
			
			scrollTo: function scrollTo(pos) {
			    var node = this.scrollboxNode;
			    if (node && pos) {
			        node.scrollLeft = pos.x;
			        node.scrollTop = pos.y;
			    }
			},
						
			scrollInterval: 50,

			_attachScrollDom: function attSbxDom() {
				// Do we have a DOM node to attach to?
				var sbn = this.scrollboxNode;
				if (sbn) {
                    // Does browser support touch?
				    var useTouch = this.usesTouches;
				    if (!useTouch) {
	                    // Initialize (or re-use) a callback to ourselves.
	                    if (!this.scrollCallback) {
	                        var id = this.id;
	                        this.scrollCallback = function(){
	                            mstrmojo.all[id].notifyScrollListeners();
	                        };
	                    }

	                    // Attach dom listener on the scroll box.
	                    mstrmojo.dom.attachBufferedEvent(sbn, "scroll", this.scrollCallback, this.scrollInterval);
					}
					    
					
					// Measure and cache the current scroll position.
					// Optimization: the Container using this mixin can skip the
					// measuring step by writing to the cache directly before making this
					// call.  If we support touch then use the value in the pos object.
					if (this.scrollboxTop === null) {
						this.scrollboxTop = (useTouch) ? 0 : sbn.scrollTop;
					}
					if (this.scrollboxLeft === null) {
						this.scrollboxLeft = (useTouch) ? 0 : sbn.scrollLeft;
					}
					
					var fnD = function (d) {
						var css = d.toLowerCase();
						// For performance, try reading the height from style before measuring it.
						// Assumes style is in "px". TO DO: support inches.
						var x = sbn.style[css];
						return (!isNaN(x) && x.charAt(x.length - 1) !== '%') ? parseInt(x, 10) : sbn['client' + d]; 
					};
					
					if (this.scrollboxHeight === null) {
						this.scrollboxHeight = fnD('Height');
					}
					if (this.scrollboxWidth === null) {
						this.scrollboxWidth = fnD('Width');
					}
					
					this.scrollboxBottom = this.scrollboxTop + this.scrollboxHeight;
					this.scrollboxRight = this.scrollboxLeft + this.scrollboxWidth;
					
					this._attachedScrollbox = sbn;
				}
			},
			
            _detachScrollDom: function dtchSbxDm() {
                var as = this._attachedScrollbox;
                if (as && this.scrollCallback) {
                    mstrmojo.dom.detachBufferedEvent(
                        as,
                        "scroll",
                        this.scrollCallback,
                        this.scrollInterval);
                }
                delete this._attachedScrollbox;
            },

            /**
			 * Local caches for the scrollTop and scroll bottom coordinates of the scrollbox which drives this
			 * rendering.  These caches are required by the implementation, but this implementation does not set
			 * the caches, it only reads from them.  The implementation assumes that the writing to caches is done
			 * outside of this mixin.
			 */
			scrollboxTop: null,
			scrollboxLeft: null,
			scrollboxHeight: null,
			scrollboxBottom: null,

			/**
			 * Extends the buildRendering method to add some post-processing for 
			 * pre-existing listeners to this scrollbox.  If the rendering has
			 * caused the scrollboxNode to change reference, then we must detach
			 * all pre-existing listeners from previous scrollbox node to current scrollbox node.
			 */
			buildRendering: function bldRndr() {
				// Do we have a scrollbox attached? If so, detach it because it will be replaced
                // by a new rendering.
				this._detachScrollDom();
				
				// Call the inherited method to render our dom...
				this._super();
				
				// Do we have any pre-existing listeners? If so attach the new scrollbox dom listener.
				if (this.scrollListenerCount) {
					this._attachScrollDom();
				}
			}		
			
			// TO DO: call detachBufferedEvent from a destroy() method.					
	};
	
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom");

    var $DOM = mstrmojo.dom;

    /**
     * Private constants for dynamic height and dynamic width.
     *
     * @private
     * @ignore
     */
    var CGS_HEIGHT = 1,
        CGS_WIDTH = 2;

    /**
     * Determines which directions a container can grow or shrink if the passed child has a dynamic dimension.
     *
     * @param {mstrmojo.Widget[]} children An array of children that will be considered for the can grow/shrink operations.
     *
     * @returns Object An object with 'v' and 'h' properties that indicate if this container can grow or shrink in those directions.
     * @private
     */
    function canGrowOrShrink(children) {
        var defn = this.defn,
            verticalConfig = defn.vc,
            horizontalConfig = defn.hc;

        // Is CanGrow/CanShrink disabled in both directions?
        if (!children || children.length === 0 || (!verticalConfig && !horizontalConfig)) {
            // Nothing to do.
            return {};
        }

        return {
            v: !!verticalConfig,
            h: !!horizontalConfig
        };
    }

    /**
     * Returns the size (from formats) of the container for the given mode.
     *
     * @param {Integer} mode The mode to examine (either CGS_HEIGHT or CGS_WIDTH).
     *
     * @returns Integer
     * @private
     */
    function getInitialSize(mode) {
        return parseInt(this.getFormats()[(mode === CGS_HEIGHT) ? 'height' : 'width'], 10);
    }

    /**
     * Returns the max-height or max-width from the formats if present.
     *
     * @param {Integer} mode The mode to examine (either CGS_HEIGHT or CGS_WIDTH).
     *
     * @returns Integer
     * @private
     */
    function getMaxSize(mode) {
        var maxProperty = this.getFormats()['max-' + ((mode === CGS_HEIGHT) ? 'height' : 'width')];
        return maxProperty && parseInt(maxProperty, 10);
    }

    /**
     * Returns the domNode property from the supplied child provided that it has rendered and is dynamic for the indicated mode.
     *
     * @param {mstrmojo.Widget} child The child to check for a dynamic dimension.
     * @param {Integer} mode The mode to examine (either CGS_HEIGHT or CGS_WIDTH).
     *
     * @returns HTMLElement The domNode for the child if it is dynamic.
     * @private
     */
    function getDynamicChildDomNode(child, mode) {
        // For some widget, domNode does not carry the dimension information.
        // For those cases, a 'dimNode' should be provided to refer to the node which carries the dimension information.
        // Otherwise, use the control's domNode.
        var defn = this.defn,
            childDomNode = child && (child.dimNode || child.domNode),
            dynamicChild = defn.ck && defn.ck[child && (child.k || child.content.k)];

        // Has the child rendered and is it dynamic in this direction?
        if (childDomNode && dynamicChild && (dynamicChild & mode)) {
            // Child is dynamic so return it's domNode.
            return childDomNode;
        }

        // Child is not dynamic so return null.
        return null;
    }

    /**
     * <p>Returns the indicated end point (farthest bottom or right point) for the supplied child.</p>
     *
     * <p>This method will take into consideration whether the child is rotated text.</p>
     *
     * @param {mstrmojo.Widget} child The child whose end point should be calculated.
     * @param {Integer} mode The mode to examine (either CGS_HEIGHT or CGS_WIDTH).
     * @param {HTMLElement} domNode The domNode of the child (or it's container for portals).
     * @param {Integer} [size=null] An optional parameter indicating the fixed size of the child.
     *
     * @returns Integer The calculated end point.
     * @private
     */
    function getChildEndPoint(child, mode, domNode, size) {
        // Calculate starting point.
        var start = parseInt(domNode.style[(mode === CGS_HEIGHT) ? 'top' : 'left'], 10);

        // Is the size fixed?
        if (!!size) {
            // Return start plus fixed size as the end point.
            return start + size;
        }

        // Handling some text rotation scenarios, this should only affect fx.rt (rotated) objects.
        var fx = (child.fmts && child.fmts.fx) || {},
            rotatedMode = (!$DOM.isIE7 && (fx.rt === 1 || fx.rt === 3)) ? ((mode === CGS_HEIGHT) ? CGS_WIDTH : CGS_HEIGHT) : mode,     // r(otated)mode -> swap if the text field is rotated.
            rotatedUCProperty = (rotatedMode === CGS_HEIGHT) ? 'Height' : 'Width';                                                     // r(otated)ucProperty.

        // Adjust for effects on the object, in this case for drop shadow (fx.ds || 0)
        // Compute the end point of the control.  The end point is the top (or left) plus the offestHeight (or offsetWidth).
        // For selectors, we have a dimNode (not sure why) which stores the dimensions of the selector widget. However, that node does not have the top and left values.
        // So, I'm forcing it to always take those values from the domNode. For other widgets, it shouldn't make a difference anyway.
        size = domNode['offset' + rotatedUCProperty] + (fx.ds || 0);

        // Calculate end point.
        var endPoint = start + size;

        // Ugly hack to fix 428944, apparently the problem is that the overflow:hidden of the Xtab-content is making the offsetWidth
        // of the xTab to be just the sum of the borders (around 2 or 4), the offset width of the xTab-content is the one that has the correct
        // offset width, this only happens on IE7 for width another problem is that once the subsection is resized correctly the offsetWidth of
        // the xtab is working fine, so just do this while the offsetWidth of the xtab is less than the contentNode offsetWidth, better ideas
        // will be appreciated.
        if ($DOM.isIE7 && rotatedUCProperty === 'Width' && child instanceof mstrmojo.XtabBase) {
            var childWidth = child.contentNode.offsetWidth;
            if (endPoint < childWidth) {
                endPoint += childWidth;
            }
        }

        return endPoint;
    }

    /**
     * <p>Returns the endPoint if it's larger than the calculated size, respecting the maxSize if present.<p>
     *
     * @param {Integer} endPoint The new endPoint.
     * @param {Integer} calculatedSize The current calculatedSize.
     * @param {Integer} [maxSize=null] An optional parameter specifying the maximum possible size.
     *
     * @returns Integer The new calculated size.
     *
     * @private
     */
    function updateCalculatedSize(endPoint, calculatedSize, maxSize) {
        // Is the end point of the control greater than the current value?
        if (endPoint > calculatedSize) {
            // Is there a maximum?
            if (maxSize) {
                // Set the end point to the minimum of the calculated end point or the maximum.
                endPoint = Math.min(endPoint, maxSize);
            }

            // End point is larger so return that.
            return endPoint;
        }

        return calculatedSize;
    }

    /**
     * Sets the size of the domNode and caches it on the instance in a '_fixed<i>Dimension</i>' property where <i>Dimension</i> is either 'Height' or 'Width', based on the mode.
     *
     * @param {Integer} mode The mode to examine (either CGS_HEIGHT or CGS_WIDTH).
     * @param {Integer} calculatedSize The newly calculatedSize.
     * @param {Boolean} dontShrink In the event we have to recalculate the section size based on a child and that tries to
     *                             reduce the section height, we do not want to shrink the section.
     *
     * @private
     */
    function updateContainerSize(mode, calculatedSize, dontShrink) {
        var containerNode = this.getCanGrowShrinkNode(),
            propertyName = (mode === CGS_HEIGHT) ? 'Height' : 'Width',
            lcPropertyName = propertyName.toLowerCase(),
            currentValue = parseInt(containerNode.style[lcPropertyName], 10);

        // Is the new value different to the currentValue and do we not want to shrink the dimension (because we are incrementally rendering)?
        if (calculatedSize && calculatedSize !== currentValue && !(calculatedSize < currentValue && !!dontShrink)) {
            // Update current value.
            currentValue = calculatedSize;

            // Change the size on the containerNode.
            containerNode.style[lcPropertyName] = currentValue + 'px';

            // Call the custom after hook.
            this.afterCanGrowShrink();
        }

        // Update the cache value to reflect the final value.
        this['_fixed' + propertyName] = currentValue;
    }

    /**
     * Iterates through controls to see if subsection height (or width) should be increased.  If so, it will
     * set the new size only once, after all controls have been iterated.
     *
     * @param {mstrmojo.Widget[]} ctrls The collection of controls to consider in this operation.
     * @param {Integer} mode The mode to examine (either CGS_HEIGHT or CGS_WIDTH).
     * @param {Boolean} dontShrink In the event we have to recalculate the section size based on a child and that tries to
     *                             reduce the section height, we do not want to shrink the section.
     *
     * @private
     */
    function calculateSize(ctrls, mode, dontShrink) {
        var maxSize = getMaxSize.call(this, mode),
            calculatedSize = getInitialSize.call(this, mode),
            len = ctrls.length,
            i;

        // Iterate through all the controls.
        for (i = 0; i < len; i++) {
            var child = ctrls[i],
                childDomNode = getDynamicChildDomNode.call(this, child, mode);

            // Did we NOT get a child DOM node (meaning it's either not rendered or it's not dynamic in this direction)?
            if (!childDomNode) {
                // No child DOM node so skip it.
                continue;
            }

            // Update the running calculated size.
            calculatedSize = updateCalculatedSize(getChildEndPoint.call(this, child, mode, childDomNode), calculatedSize, maxSize);

            // Are we at the containers max size?
            if (calculatedSize === maxSize) {
                // Already as big as we can get so break.
                break;
            }
        }

        // Update the size to calculated value.
        updateContainerSize.call(this, mode, calculatedSize, dontShrink);
    }

    /**
     * Updates a containers height (or width) based of the fixed size of the control..
     *
     * @param {mstrmojo.Widget} child The fixed dimension child.
     * @param {Integer} mode The mode to examine (either CGS_HEIGHT or CGS_WIDTH).
     * @param {Integer} size The fixed size of the {@link mstrmojo.Widget}.
     * @param {Boolean} dontShrink In the event we have to recalculate the section size based on a child and that tries to
     *                             reduce the section height, we do not want to shrink the section.
     *
     * @private
     */
    function calculateFixedSize(child, mode, size, dontShrink) {
        // Did we NOT get a child DOM node (meaning it's either not rendered or it's not dynamic in this direction)?
        var childDomNode = getDynamicChildDomNode.call(this, child, mode);
        if (!childDomNode) {
            // No child DOM node so nothing to do.
            return;
        }

        // Calculate the endPoint for this child.
        var endPoint = getChildEndPoint.call(this, child, mode, childDomNode, size);

        // Update the size to the calculated value.
        updateContainerSize.call(this, mode, updateCalculatedSize(endPoint, getInitialSize.call(this, mode), getMaxSize.call(this, mode)), dontShrink);
    }

    /**
     * <p>A mixin that equips a {@link mstrmojo.Container} with the ability to grow or shrink based on child sizes.
     *
     * @class
     * @public
     */
    mstrmojo._CanGrowOrShrink = mstrmojo.provide(

        "mstrmojo._CanGrowOrShrink",

        /**
         * @lends mstrmojo._CanGrowOrShrink#
         */
        {
            /**
             * Returns the HTMLElement that should be resized.
             *
             * @type HTMLElement
             */
            getCanGrowShrinkNode: function getCanGrowShrinkNode() {
                return this.domNode;
            },

            /**
             * Performs the CanGrow and CanShrink operation based on the passed collection of children.
             *
             * @param {mstrmojo.Widget[]} ch An array of children to be included in the CanGrow and CanShrink calculations.
             * @param {Boolean} dontShrink In the event we have to recalculate the section size based on a child and that tries to
             *                             reduce the section height, we do not want to shrink the section.
             */
            performCanGrowCanShrink: function performCanGrowCanShrink(ch, dontShrink) {
                var config = canGrowOrShrink.call(this, ch);

                // Does this section support vertical CanGrow/CanShrink?
                if (config.v) {
                    // Calculate height.
                    calculateSize.call(this, ch, CGS_HEIGHT, dontShrink);
                }

                // Does this section support horizontal CanGrow/CanShrink?
                if (config.h) {
                    // Calculate width.
                    calculateSize.call(this, ch, CGS_WIDTH, dontShrink);
                }
            },

            /**
             * Performs the CanGrow and CanShrink operation based on a single child that has at least one fixed dimension.
             *
             * @param {mstrmojo.Widget} child The child that has a fixed dimension.
             * @param {String} height The height of the child.
             * @param {String} width The width of the child.
             * @param {Boolean} dontShrink In the event we have to recalculate the section size based on a child and that tries to
             *                             reduce the section height, we do not want to shrink the section.
             */
            fixedSizeCanGrowShrink: function fixedSizeCanGrowShrink(child, height, width, dontShrink) {
                // Can this container shrink or grow?
                var config = canGrowOrShrink.call(this, child && [ child ]);

                // Make sure the values are integers.
                height = parseInt(height, 10);
                width = parseInt(width, 10);

                // Does this section support vertical CanGrow/CanShrink AND is the supplied height valid?
                if (config.v && !isNaN(height)) {
                    // Handle a fixed height.
                    calculateFixedSize.call(this, child, CGS_HEIGHT, height, dontShrink);
                }

                // Does this section support horizontal CanGrow/CanShrink AND is the supplied width valid?
                if (config.h && !isNaN(width)) {
                    // Handle a fixed width.
                    calculateFixedSize.call(this, child, CGS_WIDTH, width, dontShrink);
                }
            },

            /**
             * Customization hook that will be called after the container is resized through can grow or shrink operation.
             */
            afterCanGrowShrink: mstrmojo.emptyFn
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom");

    var $D = mstrmojo.dom;
    
    //The mouse event type to attach to document.body to close popup
    var EVENT_TO_CLOSE = 'mousedown';

    function _attachHotSlot(me) {
        // After rendering, attach event listeners for mouseover/out on the hotSlot.
        var el = me[me.hotSlot || "domNode"];
        if (el) {
            // Define and cache callbacks.
            if (!me._closeCallback) {
                var id = me.id,
                    fnCallback = function (mthName) {
                        return function (e) {
                            var p = mstrmojo.all[id];
                            if (p && !p.ignoreHover) {
                                p['auto' + mthName](e, self);
                            }
                        };
                    };

                // Minor/major cheat: Support for ignoreHover property from _CanLockHover mixin.
                // Ideally, this code shouldn't be aware of that property.
                me._uncloseCallback = fnCallback('Unclose');
                me._closeCallback = fnCallback('Close');
            }
            // Attach callbacks.
            $D.attachEvent(el, "mouseover", me._uncloseCallback);
            $D.attachEvent(el, "mouseout", me._closeCallback);
        }
    }

    function _detachHotSlot(me) {
        if (me._closeCallback) {
            var el = me[me.hotSlot || "domNode"];
            if (el) {
                $D.detachEvent(el, "mouseover", me._uncloseCallback);
                $D.detachEvent(el, "mouseout", me._closeCallback);
            }
        }
    }

    function _toggleLock(me, lock) {
        var w = me;
        while (w) {
            // If w is either a popup or an opener of popups...
            if (w.open || w.openPopup) {
                // Update its "ignoreHover" property.
                if (w.set) {
                    w.set("ignoreHover", lock);
                } else {
                    w.ignoreHover = lock;
                }
            }
            // Keep walking up the chain of ancestors and openers.
            w = w.opener || w.parent;
        }
    }

    function clearLockHoverCallback() {
        var fn = this._lockHoverCallback;
        if (fn) {
            $D.detachEvent(document.body, EVENT_TO_CLOSE, fn, true);
            delete this._lockHoverCallback; //clear lock hover callback so that next time the mouse click event can be attached again
        }

    }

    /**
     * <p>A mixin for popups that enables the popup to close itself when the end-user moves the
     * the mouse away from the popup's DOM.</p>
     *
     * <p>An optional delay can be specified between the mouseout and the call to close the popup.</p>
     *
     * @class
     * @public
     */
    mstrmojo._CanAutoClose = {

        /**
         * <p>If true, this popup will automatically call its own close() when the end-user moves away
         * from its DOM.</p>
         *
         * <p>The specified DOM node can be specified by the "hotSlot" property.</p>
         *
         * @type Boolean
         */
        autoCloses: false,

        /**
         * Delay (in millisec) before the popup closes itself after the mouse moves away.
         *
         * @type Integer
         */
        autoCloseDelay: 100,

        /**
         * If true, when this popup is opened it will tell its opener (and its opener's
         * openers chain) to ignore mouseovers, which otherwise might cause this popup to be auto-closed.
         *
         * @type Boolean
         */
        locksHover: false,

        /**
         * Name of the slot which will trigger an auto-closes when the user moves away from it.
         * If null, "domNode" is assumed.
         *
         * @type String
         */
        hotSlot: null,

        /**
         * <p>If true, this popup will automatically call its own close() when the end-user clicks
         * on the curtainNode.</p>
         *
         * <p>The specified DOM node can be specified by the "curtainNode" property.</p>
         *
         * @type Boolean
         */
        closeOnClick: false,

        /**
         * Name of the slot which will trigger an auto-closes when the user moves away from it.
         * If null, "domNode" is assumed.
         *
         * @type String
         */
        curtainNode: null,

        /**
         * Extends rendering cycle to attach event listeners to the hotSlot.
         *
         * @ignore
         */
        postBuildRendering: function postBuildRendering() {
            this._super();

            if (this.autoCloses) {
                _attachHotSlot(this);
            }

            this.oncloseOnClickChange();

        },

        /**
         * Handler for "autoCloses" property; attaches or detaches event listeners to the DOM as needed.
         */
        onautoClosesChange: function onautoClosesChange() {
            var fn = (this.autoCloses) ? _attachHotSlot : _detachHotSlot;
            fn(this);
        },

        oncloseOnClickChange: function oncloseOnClickChange() {
            if (!this.curtainNode) {
                return;
            }

            var me = this,
                mthName = 'click',
                isTouchApp = (mstrApp && mstrApp.isTouchApp && mstrApp.isTouchApp());

            if (isTouchApp) {
                mthName = 'touchstart';
            }

            $D.attachEvent(me.curtainNode, mthName, function () {
                me.close();
                if (isTouchApp) {
                    mstrmojo.touchManager.notify([]);
                }
            });
        },

        /**
         * Responds to a mouseover by aborting any prior timeout to close this popup.
         */
        autoUnclose: function autUncls() {
            var t = this._autoCloseTimer;
            if (t) {
                self.clearTimeout(t);
                delete this._autoCloseTimer;
            }
        },

        /**
         * <p>Responds to a mouseout by starting a timeout to close this popup.</p>
         *
         * <p>The timeout delay length is determined by the "autoCloseDelay" property; if zero, no timeout is used
         * and the closing is done immediately.</p>
         */
        autoClose: function autCls() {
            if (this.ignoreHover) {
                return;
            }

            // Stop any prior timeout to close the popup.
            if (this._autoCloseTimer) {
                self.clearTimeout(this._autoCloseTimer);
            }

            if (this.opener) {
                if (this.autoCloseDelay) {
                    // If we have a delay, start a timeout.
                    var xid = this.opener.id;
                    this._autoCloseTimer = self.setTimeout(function () {
                        mstrmojo.all[xid].closePopup();
                    }, this.autoCloseDelay);
                } else {
                    // We have no delay, close immediately.
                    this.opener.closePopup();
                }
            }
        },

        /**
         * Detaches DOM events.
         *
         * @param {Boolean} ignoreDom If true we don't need to clear the DOM (meaning it's been done by a parent).
         *
         * @ignore
         */
        destroy: function destroy(ignoreDom) {
            clearLockHoverCallback.call(this);

            this._super(ignoreDom);
        },


        /**
         * Notifies the popup and its opener to ignore mouseover events, and attaches a listener for mousedown
         * anywhere in the document body.
         */
        lockHover: function lockHover() {
            _toggleLock(this, true);

            if (!this._lockHoverCallback) {

                var id = this.id,
                    fn = this._lockHoverCallback = function (evt) {
                       mstrmojo.all[id]._unlockHoverCheck(evt, self);
                    };

                // Minor hack: We want to listen for mousedown events, but NOT including the mousedown event
                // that caused this method to be called (if any). So we record the time for future reference.
                //this._lastAttach = new Date();

                //But the above method comparing time-difference will fail with large amount of data in the popup.
                //Instead we set a flag to ignore the first mousedown bubbled to document.body

                //#768117,768122 - these scenarios use 'click' to open popup so that '_ignoreMousedown' flag wont be cleared
                //as expected by document.body.onmousedown handler right after popup is open.
                //To avoid this, we do two things
                // 1- IE7 and IE8: check 'window.event' type, if it is 'mousedown' event then set up flag '_ignoreMousedown'
                // 2- Other browsers - they support 'capture' mouse event so we attach to 'capture' phase thus document.body.onmousedow
                //    will be invoked to close last opened popup before opening new popup, and avoid accidentally closing the to-be-opened one.    
                if (($D.isIE7 || $D.isIE8 ) && window.event && (window.event.type == EVENT_TO_CLOSE) && this.opener) {
                    //This flag will be cleared immediately by the mousedown handler attached below
                    this.opener._ignoreMousedown = true;
                }
                    
                //IE7/8 - this handler will be fired right after attached to clear the above set flag '_ignoreMousedown'
                $D.attachEvent(document.body, EVENT_TO_CLOSE, fn, true);
            }
        },

        /**
         * Notifies the popup and its opener to stop ignoring mouseovers, and detaches mousedown listener.
         */
        unlockHover: function unlockHover() {
            _toggleLock(this, false);

            clearLockHoverCallback.call(this);
        },

        /**
         * The callback for the document.body.mousedown event.  If the event occurs outside this popup's domNode,
         * the popup closes itself.
         *
         * @param {DOMEvent} e The DOM event associated with the mouseover.
         * @param {HTMLWindow} hWin The current window object.
         */
        _unlockHoverCheck: function _unlockHoverCheck(e, hWin) {
            // Minor hack: Ignore the mousedown if it's the same mousedown which caused lockHover to be
            // called in the first place.
            var opener = this.opener;
            if (/*((new Date()) - this._lastAttach < 50) ||*/ opener && opener._ignoreMousedown) {
                delete opener._ignoreMousedown;
                return;
            }

            if (!$D.contains(this.domNode, $D.eventTarget(hWin, e), true, document.body)) {
                this.close();
            }
        },

        /**
         * <p>Undoes any lingering auto close and (possibly) locks the hover handling.</p>
         *
         * <p>Assumes _IsPopup is mixed in before this mixin.</p>
         *
         * @param {mstrmojo.Widget} opener The widget that opened the popup.
         * @param {Object} config
         *
         * @ignore
         */
        open: function open(opener, config) {
            // Stop any prior timeout to close the popup.
            if (this.autoCloses) {
                this.autoUnclose();
            }

            this._super(opener, config);

            // Do the lock hover AFTER the inherited method has set our opener property.
            if (this.locksHover) {
                this.lockHover();
            }
        },

        /**
         * <p>Implements the "locksHover" property.</p>
         *
         * <p>Assumes _IsPopup is mixed in before this mixin.</p>
         *
         * @ignore
         */
        close: function close(cfg) {
            // Do the unlock hover BEFORE the inherited method has cleared our opener property.
            if (this.locksHover) {
                this.unlockHover();
            }
            this._super(cfg);
        }
    };

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.dom");

    /**
     * String constant for toolbar css 
     */
    var FLOATING_TB_CSS = "mstrmojo-floating-toolbar-lightbox";
    var FLOATING_BAR_CSS = "mstrmojo-floating-toolbar";
    var FLOATING_CELL_CSS = "mstrmojo-floating-toolbar-cell";

    var FIXED_TB_CSS = "mstrmojo-fixed-toolbar-lightbox";
    var FIXED_BAR_CSS = "mstrmojo-fixed-toolbar";
    var FIXED_CELL_CSS = "mstrmojo-fixed-toolbar-cell";    
    
    var CTN_CSS_SUFFIX = " hasToolBar";
    var BTN_CSS_PREFIX = "mstrmojo-Button mstrmojo-InteractiveButton mstrmojo-oivmSprite ";
    var BTN_CNT_CSS = "mstrmojo-Button-text";
        
    var SL = 27; //Space limit between the widget to its container
    
    /**
     * <p>A mixin for {@link mstrmojo.Widget}s that needs floating toolbar.</p>
     * 
     * <p>This mixin would decorate existing component with extra functionality.
     * Implementation detail: The mixin would first obtain a json object from the widget which needs a floating toolbar.
     * Then it creates a floating toolbar with interactive items in it. Once the onclick event is triggered, the toolbar
     * would find the proper widget to invoke a callback method.
     * </p>
     * 
     * @class
     * @public
     */
    mstrmojo._HasToolbar =
    /**
     * @lends mstrmojo._HasToolbar#
     */
    {
        /**
         * the name to identify this mixin. Required by mstrmojo.DynamicClassFactory
         */
        _mixinName: 'mstrmojo._HasToolbar',
        

        /**
         * Creates the toolbar, sets each button, and docks it above the container 
         * @ignore
         */
        postBuildRendering: function TB_postBuildRendering() {        
            this._super();
            
            var tb = this.getToolbarCfg();
            
            // If we don't have the json object for toolbar, or the widget has title bar then we don't do anything. 
            if(!tb || this.defn.ttl) {
                return;
            }
            
            // Create the floating toolbar and attached it to its container
            var cn = this.containerNode;
            if(cn) {                
                // Get the toolbar dom object
                var d = this._createToolbar(FLOATING_BAR_CSS, FLOATING_CELL_CSS);
                
                // Set the css of the toolbar to be floating one
                d.className = FLOATING_TB_CSS;
                // Append the css suffix to the css of the container
                cn.className += CTN_CSS_SUFFIX;
                
                // Insert the dom object before the first child of the container
                cn.insertBefore(d, cn.firstChild);
                
                var dm = this.domNode,
                    ofst = mstrmojo.boxmodel.offset(dm, this.parent && this.parent.domNode); 

                // Creates a floating toolbar. Normally, the toolbar will flow above its container widget. 
                // If the space between the container widget to its outside container is too narrow, smaller than the toolbar height 24, 
                // the toolbar would be shifted a few pixels down in order to get displayed preperly
                if(ofst.top < SL) {
                    d.style.top = (SL - ofst.top) + 'px';
                }
            }
        },
        
                
        /**
         * Creates the toolbar dom object.
         */
        _createToolbar: function TB_addBtns(barCss, btnCss) {            
            var tb = this.getToolbarCfg(),
                me = this,            
                d = document,
                dv = d.createElement('div'),
                tbl = d.createElement('table'),
                tr = d.createElement('tr'),
                td = d.createElement('td');
            
            dv.appendChild(tbl);

            // Creates the toolbar in the table            
            tbl.className = barCss;
            td.className = btnCss;
            tr.appendChild(td);
            tbl.appendChild(tr);
            
            // Go though the toolbarCfg object to create each toolbar item
            
            // Each toolbarCfg item has two properties: css and callback.
            // The css array is used to set the toolbar button outlook. Once the clicking action is
            // executed successfully, the button css will switch to the next one indicating that the 
            // button status is changed.
            
            // The callback string is set to response what action to take when the button is clicked.
            // It will invoke the callback function from the container who creates the toolbarCfg object.
            
            for(var i in tb) {
                var div = d.createElement('div');
                div.className = BTN_CSS_PREFIX + tb[i].css[0];
                
                var cnt = d.createElement('div');
                cnt.className = BTN_CNT_CSS;
                cnt.nodeValue = "&nbsp;";
                
                // Set the div attribute to remember which icon is clicked (ix), and 
                cnt.setAttribute("ix", i);
                
                // for the given icon, which styls (css index) is being used. 
                cnt.setAttribute("cix", 0);

                div.appendChild(cnt);                
                td.appendChild(div);

                div.onclick = function(e) {
                    me.onClick(e);
                };
            }
            
            return dv;

        },
        
        
        /**
         * Creates a fixed toolbar docking inside the give slot. This method should normally be called from title bar. 
         * 
         * @param slot DOMNode
         */
        renderToolbar: function TB_rndToolbar(slot) {
            if(!this.getToolbarCfg()) {
                // return if there is no toolbar cfg object
                return;
            }
            
            var fc = slot.firstChild,
                tb = this._createToolbar(FIXED_BAR_CSS, FIXED_CELL_CSS);
            
            tb.className = FIXED_TB_CSS;
            
            if(fc) {
                slot.insertBefore(tb, fc);
            } else {
                slot.appendChild(tb);
            }
        },
    
        
        /**
         * Handles the case when the toolbar button is clicked. When the button is clicked,
         * we will execute the corresponding callback function on the container widget
         */
        onClick: function TB_clk(/*DomEvent?*/ e, /*DomWindow?*/ hWin) {
            
            var d = mstrmojo.dom,
                b = d.eventTarget(hWin, e),
                cix = b.getAttribute("cix"),
                ix = b.getAttribute("ix");            
            
            var tb = this.toolbarCfg[ix],
                tbFn = tb.callback;
            
            if(tbFn && this[tbFn] && this[tbFn]()) { 
                //we need to cycle thru to the next css
                cix = ++cix % tb.css.length; 
                b.parentNode.className = BTN_CSS_PREFIX + tb.css[cix];
                b.setAttribute("cix", cix);
            }
        }

    };
})();
(function(){

	 mstrmojo.requiresCls("mstrmojo.dom");

	var $DOM = mstrmojo.dom;

	var TEXTMARGIN = 5; //This is to put sapce from left side of chart when drawing label
	/**
     * Variable to control drawing start point arc
     */
	var D_S_P = 1;
	/**
     * Variable to control drawing end point arc
     */
	var D_E_P = 2;
	/**
	 * xiawang: This is used by MicroChart
	 * Variable to control drawing other point art
	 */
	var D_O_P = 4;

	var T_Z_A = 0;

	var needAdjust = true;

	var ZoomFactor = 0;


	/**
	 * Variable that contains total milliseconds in day
	 */
	var millisOnDay = 86400000;

	mstrmojo.VisChartUtils = mstrmojo.provide(
        "mstrmojo.VisChartUtils",
        /**
         * @lends mstrmojo.VisChartUtils
         */
        {
        	getScreenZoomFactor: function getScrnZmFctr(){
        		if(ZoomFactor == 0){
        			if(mstrMobileApp){
        				var dpi = mstrMobileApp.getDeviceDPI();
        				console.log("dpi:"+dpi);
    	        		ZoomFactor = dpi/160;
        			}else{
        				ZoomFactor = 1;
        			}

        		}
        		return ZoomFactor;
        	},

        	changeElementSize: function chngfntsz(el,prop,zf){

        		if(prop == 'fontSize' || prop == 'height' || prop == 'line-height'){
        			var propValue = mstrmojo.css.getStyleValue(el,prop);
	        		var intSize = Math.round(zf*parseInt( propValue ));
	        		//el.style[prop] = ""+ Math.round(zf*intSize)+ size.slice(size.length -2 );

	        		el.style[prop] = intSize + "px";
	        	//	console.log(prop+"change frome: "+size+" to:"+el.style[prop]);
        		}else if(prop == 'font'){
        			var fontSize = mstrmojo.css.getStyleValue(el,'fontSize');
        			var intSize = Math.round(zf*parseInt( fontSize ));
        			var fontWeight = mstrmojo.css.getStyleValue(el,'fontWeight');
        			var fontFamily = mstrmojo.css.getStyleValue(el,'fontFamily');
        			el.style.font = fontWeight+ " "+ intSize+"px " + fontFamily;
        			//	console.log(prop+"change frome: "+size+" to:"+el.style[prop]);
        		}
        	},

        	rgbaStr2rgba: function C_rgbaStr2rgba(color) {
                var rgba = null;
                color = color.replace(/ /g, ''); //get rid of the possible blank space
                var i = color.indexOf('rgba');
                if (i >= 0) {
                    color = color.substring(i + 5, color.length - 1);
                    rgba = color.split(',');
                }
                return rgba;
            },

            /**
             *fills the canvas' base context with the theme color, adds a gloss gradient
             * @param {mstrmojo.VisChart} [widget] a reference to the Chart Widget
             */
            fillBackground: function fllBckgrnd(widget, width, height, context, opacity) {

                //local vars
                var cntx = context || widget.context,
                    wd = width || widget.canvas.width,
                    ht = height || widget.canvas.height,
                    themeColor = widget.themeColor || '#000000', // if theme color was not defined than use black as default
                    gradient = null,
                    opc = opacity || 1;

				if(!cntx){
					//console.log("can't get context! cntx = widget.canvas.getContext('2d')")
					cntx = widget.canvas.getContext('2d');
					if(!cntx){
						//console.log("can't get context for widget:")
						return;
					}
				}
                cntx.save();

                if (widget.noBackground) {
                	// xiawang: if the widget says no background, do nothing
                } else if(!widget.isAndroid && !widget.isTimeSeries) {

                	gradient = cntx.createLinearGradient(0, 0, 0, ht / 2);

                	//set context settings
                	cntx.fillStyle = themeColor;
                	cntx.fillRect(0, 0, wd, ht);

                	//add gloss

                	cntx.globalAlpha = 0.4;

                	gradient.addColorStop(0, '#fff');
                	gradient.addColorStop(0.1, '#fff');
                	gradient.addColorStop(1, themeColor);


                	cntx.fillStyle = gradient;
                	cntx.rect(0, 0, wd, ht / 2);
                	cntx.fill();


                	cntx.globalAlpha = 0.1;
                	cntx.fillStyle = '#fff';
                	cntx.fillRect(0, 0, wd, ht / 2);
                } else if(widget.isTimeSeries) {
                	var formatProp = widget.formatProp;

            		gradient = cntx.createLinearGradient(0, 0, 0, ht);
                	//add gloss
                	cntx.globalAlpha = formatProp.backgroundAlpha;

                	var topGradient = this.rgb2rgbStr(formatProp.backgroundClr, 0.83) || '#2c2c2c';
     			    var bottomGradient = this.rgb2rgbStr(formatProp.backgroundClr) || '#000000';
					gradient.addColorStop(0, topGradient);
                	gradient.addColorStop(1, bottomGradient);
                	cntx.fillStyle = gradient;
                	cntx.rect(0, 0, wd, ht);
                	cntx.fill();

                }else {
                	cntx.globalAlpha = opc;
                	cntx.fillStyle = themeColor;
                	cntx.fillRect(0, 0, wd, ht);
                }

                cntx.restore();

            },

            rgb2rgbStr: function rgb2rgbStr(rgb, opc){
            	var result = '';

            	if(!rgb || rgb.length != 3){
            		return result;
            	}

            	if(opc || opc == 0){
            		result = 'rgba('+ rgb[0] + ','+rgb[1]+','+rgb[2]+','+opc+')';
            	}else{
            		result = 'rgb('+ rgb[0] + ','+rgb[1]+','+rgb[2]+')';
            	}

            	return result;
            },

            /*
             * return a new rgb array, which is calculated by using the opacity and background color white
             * rgb: the rgb color for under the opacity layer
             * rgb2: the rgb color for the opacity layer, default to [255,255,255]
             */
            getRGBWithOpacity: function getRGBWithOpacity(rgb, opacity, rgb2){
            	if(isNaN(opacity)){
            		return;
            	}

            	if(!rgb2){
            		rgb2 = [255, 255, 255];
            	}

            	var resultRGB = [];

            	for(color in rgb){
            		resultRGB[color] = parseInt( rgb[color]*(1 - opacity) + rgb2[color]*opacity );
				}
            	return resultRGB;
            },

            fillMasterChartBackground: function fillMasterChartBackground(widget, topX, topY, width, height, bottomY, context){
				 //local vars
			     var cntx = context || widget.context,
			         wd = width || widget.canvas.width,
			         ht = height || widget.canvas.height,
			         themeColor = widget.themeColor,
			         gradient = null;

			     var formatProp = widget.formatProp;

			    cntx.save();
			    cntx.globalAlpha = formatProp.backgroundAlpha;
			    cntx.fillStyle = this.rgb2rgbStr(formatProp.backgroundClr) || '#000000';
				cntx.fillRect(0, 0, wd, topY);

			    gradient = cntx.createLinearGradient(0, 0, 0, ht/2);
				//topY = Math.floor(topY) < topY ? Math.floor(topY) + 0.5 : topY - 0.5;
//				topY -= 0.5;

				//add gloss
			    var topGradient = this.rgb2rgbStr( this.getRGBWithOpacity(formatProp.backgroundClr, 0.45) ) || '#737373';
			    var bottomGradient = this.rgb2rgbStr( this.getRGBWithOpacity(formatProp.backgroundClr, 0.13) ) || '#222222';
				gradient.addColorStop(0, topGradient);
				gradient.addColorStop(1, bottomGradient);
				cntx.fillStyle = gradient;
				cntx.fillRect(topX, topY, wd, ht/2 );

				cntx.fillStyle = this.rgb2rgbStr(formatProp.backgroundClr) || '#000000';
				cntx.fillRect(topX, topY + ht/2, wd, ht/2 + bottomY);

				//draw the dividing line
				cntx.globalAlpha = 1;
				cntx.strokeStyle = this.rgb2rgbStr ( widget.formatProp.textClr, 0.50 );
				cntx.lineWidth = 1;
				//top dividing line
				var lineY = topY +0.5;
				this.drawLineSet(this, [{
	                x: topX,
	                y: lineY
	            }, {
	                x: topX + wd,
	                y: lineY
	            }], false, cntx);
				//bottom dividing line
				//var lineY = Math.floor(topY+ ht) < topY+ ht ? Math.floor(topY+ ht) + 0.5 : topY+ ht - 0.5;
				lineY = topY + ht - 0.5;
				this.drawLineSet(this, [{
	                x: topX,
	                y: lineY
	            }, {
	                x: topX + wd,
	                y: lineY
	            }], false, cntx);

				cntx.restore();
          },

			/*
			 * Draw a line according to the given array, if the array is too large then make it into N-pass drawing
			 * @param {mstrmojo.VisChart} [widget] a reference to the Chart Widget
			 * @param {Array} [lines] an array of points for the line to draw
			 * @param {Boolean} [fill] indicates whether the line will be a closed polygon
			 * @param {CanvasContext2D} [context] the context object to use
			 * @param {Number} [split] maximal number of points per drawing
			 */
			drawLineSetWithSplit: function(widget, lines, fill, context, split) {
				var n = lines.length, // number of points
					np = Math.ceil(n / split), // number of pass
					start, end;
				for (var i = 0; i < np; i++) {
					start = i * split; // inclusive
					end = Math.min(start + split + 1, n); // exclusive
					this.drawLineSet(widget, lines.slice(start, end), fill, context);
				}
			},

            /**
             * Draws a line given a privided array of points
             * @param {mstrmojo.VisChart} [widget] a reference to the Chart Widget
             * @param {Array} [lines] an array of points for the line to draw
             * @param {Boolean} [fill] indicates whether the line will be a closed polygon
             * @param {CanvasContext2D} [context] the context object to use
             */
			drawLineSet: function drwlnst(widget, lines, fill, context) {

                //local vars
				var cntx = null,
					l = lines.length,
					li = null;

                //local context
                if (context) {
                    cntx = context;
                } else {
                    cntx = widget.context;
                }

            	//TQMS 661017: handle the chart which is composed of single point
            	var lastPoint = null,
            		moveToPoint = false;

                //begin the line, position the first point
				cntx.beginPath();
				var i = 0;
				while(i < l) {
					if(lines[i]) {
						cntx.moveTo(lines[i].x, lines[i].y);
						lastPoint = lines[i];
						moveToPoint = true;
						i++;
						break;
					}

					i++;

				}
				//#494324 If null points are sent do not lineTo next point but move to next point so that line is cut off and
				// not drawn between the points which contains null data in between.
				var skip = false;
				for(;i<l;i++) {
					li = lines[i];
					if(li) { // skip the points that are null
						if(!skip) {
							cntx.lineTo(li.x, li.y);
							moveToPoint = false;
						} else {
							cntx.moveTo(li.x, li.y);
							moveToPoint = true;
							lastPoint = li;
							skip = false;
						}
					} else {
						if(!skip){
							skip = true;
							if(moveToPoint){
									//draw last single point
									cntx.arc(lastPoint.x,lastPoint.y, 1, 0, Math.PI * 2, false);
							}
						}
					}
				}

                //close polygon or open line
				if (fill) {
					cntx.closePath();
					cntx.fill();
				} else {
					cntx.stroke();
				}
			},

			//calculate the highest point in the lines
			getMinYPosition: function getMinYPosition(lines, start, end){
				var i = start,min;
				while(i <= end){
					if(lines[i]){
						min = lines[i].y;
						break;
					}
					i++;
				}
				for(i = start; i <= end;i++){
					if(lines[i]){
						min = Math.min(min,lines[i].y);
					}
				}
				return min;
			},

			drawLineAreaWithSplit: function (widget, lines, start, end, bottomY, rgbClr, context, split) {
				var n = end - start + 1, // number of points
					np = Math.ceil(n / split), // number of pass
					p1, p2;
				for (var i = 0; i < np; i++) {
					p1 = start + i * split; // inclusive
					p2 = Math.min(p1 + split, start + n - 1); // inclusive
					this.drawLineArea(widget, lines, p1, p2, bottomY, rgbClr, context);
				}
			},

			/**
	             * Draws a line given a privided array of points and filled the area below the line
	             * @param {mstrmojo.VisChart} [widget] a reference to the Chart Widget
	             * @param {Array} [lines] an array of points for the line to draw
	             * @param {Boolean} [fill] indicates whether the line will be a closed polygon
	             * @param {CanvasContext2D} [context] the context object to use
	             */
			drawLineArea: function drwlnst(widget,lines, start, end, bottomY, rgbClr, context) {
				//local vars
				var cntx = null,
					l = lines.length,
					li = null,
					startBottomX = 0,
					endBottomX = 0;

		        //local context
		        if (context) {
		            cntx = context;
		        } else {
		            cntx = widget.context;
		        }

		        //TQMS 661017: handle the chart which is composed of single point
            	var lastPoint = null,
            		moveToPoint = false;

		        cntx.save();

		        cntx.lineWidth = 0;
		        //begin the line, position the first point
				cntx.beginPath();
				var i = start, startIndex;
				while(i <= end) {
					if(lines[i]) {
						startBottomX = lines[i].x;
						cntx.moveTo(startBottomX, bottomY);
						lastPoint = lines[i];
						moveToPoint = true;
						break;
					}
					i++;
				}
				startIndex = i;
				//#494324 If null points are sent do not lineTo next point but move to next point so that line is cut off and
				// not drawn between the points which contains null data in between.
				var skip = false;
				for( ;i<=end;i++) {
					li = lines[i];
					if(li) { // skip the points that are null
						if(!skip) {
							cntx.lineTo(li.x, li.y);
							moveToPoint = false;
							endBottomX = li.x;
						} else {

							startBottomX = li.x;
							cntx.moveTo(startBottomX, bottomY);
							if(i+1<=end && lines[i+1]){
								cntx.lineTo(li.x, li.y);
							}
							lastPoint = li;
							skip = false;
							startIndex = i;
						}
					} else {
						if(!skip){
							skip = true;
							if(!moveToPoint){
								cntx.lineTo(endBottomX, bottomY);
								cntx.lineTo(startBottomX, bottomY);
								var MinY = this.getMinYPosition(lines, startIndex, i) || 0;

								var my_gradient  = cntx.createLinearGradient(0,MinY,0,bottomY);
							    my_gradient.addColorStop(1,this.rgb2rgbStr(rgbClr, 0));
							    my_gradient.addColorStop(0,this.rgb2rgbStr(rgbClr, 1));
							    cntx.fillStyle = my_gradient;
							    cntx.globalAlpha = 0.8;
								cntx.fill();
							}
						}
					}
				}

		         //close polygon or open line
		        if(!moveToPoint){
					cntx.lineTo(endBottomX, bottomY);
					cntx.lineTo(startBottomX, bottomY);
					var MinY = this.getMinYPosition(lines, startIndex, end) || 0;
					cntx.closePath();
					var my_gradient  = cntx.createLinearGradient(0,MinY,0,bottomY);
				    my_gradient.addColorStop(1,this.rgb2rgbStr(rgbClr, 0));
				    my_gradient.addColorStop(0,this.rgb2rgbStr(rgbClr, 1));
				    cntx.fillStyle = my_gradient;
				    cntx.globalAlpha = 0.8;
					cntx.fill();
		        }

				cntx.restore();
			},

			/**
			 * Draws a rectangle given the given parameters
			 * @param  {mstrmojo.VisChart} [widget] a reference to the Chart Widget
			 * @param x point on x axes
			 * @param y point on y axes
			 * @param w width of the rectangle
			 * @param h height of the rectangle
			 * @param {Boolean} [fill] indicates whether to just draw empty or filled rectangle.
			 * @param {CanvasContext2D} [context] the context object to use
			 */
			drawRectangle: function drwRect(widget, x, y, w, h, fill, context) {
				var cntx = null;

				//local context
				if (context) {
					cntx = context;
				} else {
					cntx = widget.context;
				}

				if(fill) {
					cntx.fillRect(x,y,w,h);
				} else {
					cntx.strokeRect(x,y,w,h);
				}
			},
			/**
			 * Draws an arc on the given context.  If context is not provided will draw on the base context
			 * @param {mstrmojo.VisChart} [widget] a reference to the Chart Widget
			 * @param x point on x axes
			 * @param y point on y axes
			 * @param radius radius of the arc we want to draw
			 * @param startAngle define the end point of the arc in radians
			 * @param endAngle define the end point of the arc in radians
			 * @param {Boolean} [anticlockwise] whether to draw arc anticlockwise or clockwise
			 * @param {Boolean} [fill] indicates whether to just draw empty or filled arc.
			 * @param {CanvasContext2D} [context] the context object to use
			 */
			drawArc: function drwArc(widget, x, y, radius, startAngle, endAngle, anticlockwise, fill, context) {
				var cntx = null;

				//local context
				if (context) {
					cntx = context;
				} else {
					cntx = widget.context;
				}

				cntx.beginPath();

				cntx.arc(x,y,radius,startAngle,endAngle,anticlockwise);

				if(fill) {
					cntx.fill();
				} else {
					cntx.stroke();
				}

			},

			/**
			 * Draws a rounded rectangle using the current state of the canvas.
			 * If you omit the last three params, it will draw a rectangle
			 * outline with a 5 pixel border radius
			 * @param {CanvasRenderingContext2D} ctx
			 * @param {Number} x The top left x coordinate
			 * @param {Number} y The top left y coordinate
			 * @param {Number} w The width of the rectangle
			 * @param {Number} h The height of the rectangle
			 * @param {Number} r The corner radius. Defaults to 5;
			 * @param {Boolean} fill Whether to fill the rectangle. Defaults to false
			 */
			drawRoundRect: function drawRoundRect(ctx, x, y, w, h, r, fill) {
				//make sure the radius is not to large
				r = Math.min(w/2, h/2, r);

				ctx.beginPath();
				ctx.moveTo(x + r, y);
				ctx.arcTo(x+w, y,   x+w, y+h, r);
				ctx.arcTo(x+w, y+h, x,   y+h, r);
				ctx.arcTo(x,   y+h, x,   y,   r);
				ctx.arcTo(x,   y,   x+w, y,   r);
//				ctx.lineTo(x + width - radius, y);
//				ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
//				ctx.lineTo(x + width, y + height - radius);
//				ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
//				ctx.lineTo(x + radius, y + height);
//				ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
//				ctx.lineTo(x, y + radius);
//				ctx.quadraticCurveTo(x, y, x + radius, y);
				ctx.closePath();

				if (fill) {
					ctx.fill();
				}else{
					ctx.stroke();
				}
			},

			drawHalfRoundedRectangle: function drwHRRect(widget, x, y, w, h, r, fill, context) {
				var cntx = null;

				//local context
				if (context) {
					cntx = context;
				} else {
					cntx = widget.context;
				}

				cntx.beginPath();
				cntx.moveTo(x+w,y);
				cntx.lineTo(x+r,y);
				cntx.arcTo(x,y,x,y+r,r);
				cntx.lineTo(x,y+h-r);
				cntx.arcTo(x,y+h,x+r,y+h,r);
				cntx.lineTo(x+w,y+h);
				if(fill) {
					cntx.fill();
				} else {
					cntx.stroke();
				}
			},

			/**
			 * computes if user wants to draw start or end point or both and draw accordingly.
			 * @param {mstrmojo.VisChart} [widget] a reference to the Chart Widget
			 * @param lines - array containing the x and y points for all the points
			 * @param {CanvasContext2D} [context] the context object to use
			 * @param dp highlight start and end points.
             * 0 - No points
             * 1 - start point only
             * 2 - end point only
             * 3 - start and end points both {default}
             * 4 - draw other points only. other point means non-start and non-end points. added by xiawang
             * 7 - draw all point. added by xiawang
			 */
			drawStartEndPoints: function dsep(widget, lines, context, dp) {
				var l = lines.length;

				var cntx = null,
				r = widget.startEndPointRadius;

				//local context
				if (context) {
					cntx = context;
				} else {
					cntx = widget.context;
				}

				cntx.save();

				var spc = '#f0f43e',
					epc = '#f0f43e',
					opc = '#663300';

				if(widget.startPointColor) {
					spc = widget.startPointColor;
				}

				if(widget.endPointColor) {
					epc = widget.endPointColor;
				} else {
					// if end point is greater green color red otherwise based on y value of line so
					// higher the y smaller the value of y greater the point value.
					var	s = lines[0].y,
					h = lines[l -1].y;
					if( s > h) {
						epc = '#008000';
					} else if( s < h) {
						epc = '#8d1616';
					} else {
						epc = spc;
					}
				}

				if (widget.otherPointColor) {
					opc = widget.otherPointColor;
				}

				if(dp & D_S_P && lines[0]) {
					cntx.strokeStyle = spc;
					cntx.fillStyle = spc;
					// draw only the start point
					this.drawArc(this, lines[0].x, lines[0].y, r, 0, Math.PI * 2, true, true, cntx);
				}

				if(dp & D_E_P && lines[l - 1]) {
					cntx.strokeStyle = epc;
					cntx.fillStyle = epc;
					this.drawArc(this, lines[l - 1].x, lines[l - 1].y, r, 0, Math.PI * 2, true, true, cntx);
				}

				if(dp & D_O_P) {
					cntx.strokeStyle = opc;
					cntx.fillStyle = opc;
					// xiawang: draw other point
					for (var i = 1; i < l -1; i ++) {
						if(lines[i]){
							this.drawArc(this, lines[i].x, lines[i].y, r, 0, Math.PI * 2, true, true, cntx);
						}
					}
				}

				cntx.restore();
			},

            /**
             * returns the color used to draw lines and text. #000 or #fff depending on the theme color
             * @param {mstrmojo.VisChart} [widget] a reference to the Chart Widget
             */
			getColor: function gtclr(w) {
				return (parseInt(w.themeColor.substr(1), 16) > 0x7fffff) ? '#000000' : '#ffffff';
			},

            /**
             * draws an horizontal dotted line across the chart
             * @param {mstrmojo.VisChart} [widget] a reference to the Chart Widget
             * @param {Integer} [y] the y axis coordinate where the line will be drawn
             */
            drawHighlightLine: function drwHghlghtln(w, y) {
				var ctx = w.context,
                    margin = w.margin,
					x1 = margin.l,
					x2 = w.isTimeSeries ? w.chartWidth + margin.l : w.getWidth() - margin.r;

				ctx.save();
                //set the context settings
				ctx.globalAlpha = 1;
				ctx.strokeStyle = this.rgb2rgbStr(w.formatProp.textClr, 0.35)//this.getColor(w);
				ctx.lineWidth = 1;
				ctx.lineCap = 'round';

                //create a dotted line by creating  separate paths
				while (x1 < x2) {
					ctx.beginPath();
					ctx.moveTo(x1, y);
					x1 += 2;
					ctx.lineTo(x1, y);
					ctx.stroke();
					x1 += 3;
				}

				ctx.restore();
			},


            /**
             * adds a data label to the chart on its y axis
             * @param {mstrmojo.VisChart} [widget] a reference to the Chart Widget
             * @param {String} [text] the label's text
             * @param {Integer} [x] the x axis coordinate
             * @param {Integer} [y] the y axis coordinate
             */
			addLabel: function adDtLbl(w, text, x, y, width, rotate, prevLabel) {

				//create an html div node
                var lbl = document.createElement("div");
                lbl.className = 'mstrmojo-Chart-lbl';
                lbl.style.color = this.rgb2rgbStr(w.formatProp.textClr, 0.8);

                lbl.innerHTML = text;

                if (width) {
                    lbl.style.width = width + 'px';
                }
                var node = null;
                var aWidth = 0;
                if(w.isTimeSeries) {
                	if(prevLabel.w >= 0) {
                		node = w.xdiv;
                		aWidth = w.animationCanvas.width;
                	} else {
                		node = w.domNode.getElementsByClassName('mstrmojo-chart-ylbl-div')[0];
                		if(!node) {
                			node = document.createElement("div");
                			node.id = 'mstrmojo-chart-ylbl-div';
                			node.className = 'mstrmojo-chart-ylbl-div';
                	//		node.style.backgroundColor = '#000000';
                	//		node.style.position = 'absolute';
                			w.domNode.appendChild(node);
                		}
                		node.style.width = w.margin.l - 1 + 'px';
                	}
                } else {
                	node = w.domNode;
                	aWidth = w.getWidth();
                }

                //append it to the Chart Widget's dom node
                //w.domNode.appendChild(lbl);
                node.appendChild(lbl);

                var lblTextWidth = lbl.offsetWidth || ( w.getTextWidth && w.getTextWidthByElem(text,lbl) );

                //TODO in case of rotate labels we need to calculate the x axis differently

                //check for labels overlapping for X and Y axis depending of which one is being drawn
                var ht = lbl.offsetHeight || 22*(ZoomFactor || 1); // #498285 make the default height of label a little bigger
                var wd = width || lblTextWidth || 100;

                var X_PAD = w.xLabelPadding/2;
                var Y_PAD = w.yLabelPadding/2;

                /*
                 * remove the x-axis label if it will be cutoff
                 * If the center of the x-axis label is between the left boundary and the y-axis, we will remove this label.
                 */
                 if(prevLabel.w >= 0 && w.isTimeSeries && w._scroller.origin){
                	 var distanceOffOrgin = x - w._scroller.origin.x;
                	 if(distanceOffOrgin <= 0 && (distanceOffOrgin + lblTextWidth/2 > -w.maxYLblWidth)){
                	 	w.needRedrawVerticalLine = true;
                	 	node.removeChild(lbl);
                		return null;
                	 }

                	 var distanceOffLegend = distanceOffOrgin - w.getChartWidthOnScreen();
                	 if( (distanceOffLegend - lblTextWidth/2) <=0  && distanceOffLegend >= 0){
                	 	w.needRedrawVerticalLine = true;
                	 	node.removeChild(lbl);
                		return null;
                	 }
                 }


                if(prevLabel.w >= 0) {
                	x = x - wd /2;
                }

                //check overlap for Y-axis Labels
                if(prevLabel.h >= 0 && ((y >= prevLabel.y - Y_PAD && y <= prevLabel.y + prevLabel.h) ||
                		(y + ht >= prevLabel.y - Y_PAD && y + ht <= prevLabel.y + prevLabel.h) ||
                		(y + ht >= w.canvas.height - w.margin.b) )) {
                	node.removeChild(lbl);
                	return null;
                }

                //check overlap for X-axis Labels
                if(prevLabel.w >= 0 && (((x >= prevLabel.x && x < prevLabel.x + prevLabel.w + X_PAD)) || x < prevLabel.x || x < w.margin.l || x + wd > aWidth)) {
                	node.removeChild(lbl);
                	return null;
                }

                //Now show the label at the correct position
                if(w.isTimeSeries && prevLabel.h >= 0) {
                	node.style.top = (w.margin.t - ht/2) + 'px';
                	//  -1 is to avoid covering the xAxis line which is 2px width
                	node.style.height = (w.canvas.height - w.margin.t - w.margin.b -1 + ht/2) + 'px'; // #493113 do not subtract margin.b to extend the div height to the bottom to hide x-label divs underneath
                	this.translateCSS(x, (y - w.margin.t) + ht/2, rotate, lbl);
                } else {
                	this.translateCSS(x, y, rotate, lbl);
                	lbl.style.maxHeight = ht + 'px'; //#493077 temp fix for label to not show in two lines
                }

                //save the last label drawn positions
                prevLabel.x = x;
                prevLabel.y = y;
                if(prevLabel.h >= 0) {
                	prevLabel.h = ht;
                }
                if(prevLabel.w >= 0){
                	prevLabel.w = wd;
                	lbl.style.textAlign = 'center';
                }

                return lbl;
			},

            /**
             * adds a data label to the chart on its y axis
             * @param {mstrmojo.VisChart} [widget] a reference to the Chart Widget
             * @param {String} [text] the label's text
             * @param {Integer} [y] the y axis coordinate
             */
			addDataLabel: function adDtLbl(w, text, y, prevLabel) {
				var xText = (w.margin.l > w.margin.r) ? TEXTMARGIN : w.getWidth() - w.margin.r + TEXTMARGIN,
                    spaceAvailable = (w.margin.l > w.margin.r) ? w.margin.l : w.margin.r;
                //TODO y - 10 this is used to move the y label up to display
                return this.addLabel(w, text, xText, y - 10, spaceAvailable-TEXTMARGIN*2, false, prevLabel);
			},

			/**
			 * adds translate property to the given div element
			 * @param x point on x-axis
			 * @param y point on y-axis
			 * @param rotate  boolean to simply rotate by 45 degree or no rotation of div
			 * @param lbl  element that need be translated
			 */

			translateCSS: function trnlt(x, y, rotate, lbl) {
			    var value = 'translate(' + x + 'px,' + y + 'px)';
			    if (rotate) {
			        value += ' rotate(45deg)';
			    }

                lbl.style[$DOM.CSS3_TRANSFORM] = value;
			},

			getTouchXYOnWidget: function getTouchXYOnWidget(touchX, touchY, widget){
				var TouchScroller = mstrmojo.TouchScroller,
			 		scrollerOffsets = (TouchScroller && widget.parent && TouchScroller.getScrollPositionTotals(widget.parent)) || { x: 0, y:0}; // for Web visualizations

				touchX = touchX - widget.offsetLeft + scrollerOffsets.x;
				touchY = touchY - widget.offsetTop + scrollerOffsets.y;
				return {touchX:touchX, touchY:touchY};
			},

			//return the y value in the canvas given an x point
		    getYValue: function gyval(widget, point) {
		        var height = widget.canvas.height,
		            margin = widget.margin,
		            mvalues = widget.model.mvalues;
		        return height - margin.b - 4 -((parseFloat(point) - mvalues[0]) * widget.RTY);
		    },

		  //return the y value in the canvas given an x point
		    getMasterYValue: function getMasterYValue(widget, point, mm /*masterMargin*/) {
		        var height = widget.masterCanvas.height,
		            mvalues = widget.model.mvalues;
		        return height - mm.b - 3 - ((parseFloat(point) - mvalues[0]) * widget.MRTY);
		    },

		    // returns the value of closest y point in the series
		    getSeriesIndexAndYValue: function gsiyv(w, rowIdx, touchY) {
		    	var s = w.model.series,
		    	l = s.length,
		    	si = 0;
				y = this.getYValue(w, s[si].rv[rowIdx]) || 0;
		    	var cp = touchY - y < 0 ? - (touchY - y) : touchY - y,
		    			pp = cp;
		    	for(var i = 1; i < l; i++) {
		    		var cy = this.getYValue(w, s[i].rv[rowIdx]) || 0;
		    		cp = touchY - cy < 0 ? - (touchY - cy) : touchY - cy;
		    		if(cp < pp) {
		    			y = cy;
		    			pp = cp;
		    			si = i;
		    		}
		    	}

		    	return {y:y, si:si};
		    },

		    getLabelWidthForMargin: function tsip(w, text) {
		    	var lbl = document.createElement("div");
                lbl.className = 'mstrmojo-Chart-lbl';
                lbl.innerHTML = text;

                //append it to the Chart Widget's dom node
                w.domNode.appendChild(lbl);
                var wd = lbl.offsetWidth || 60;
                w.domNode.removeChild(lbl);
                return wd + TEXTMARGIN * 2;
		    },

			animateLineSet: function anmtHLnSt(w, fromLines, toLines, cfg) {
                var lines = [],
                    x = w.animationContext,
                    l = toLines.length;

                x.clearRect(0, 0, w.getWidth(), w.canvas.height);

                if (!cfg.index) {
                    cfg.index = 0;
                } else if (cfg.index >= cfg.rate) { // last time
                    this.drawLineSet(w, toLines, false, x);
                    w.drawLabels();
                    if(w.isFillLinesArea) {
                    	//fill the Lines area
                    	this.fillLinesArea(w,toLines.slice(0));
                    }
                    if(w.isDrawStartEndPoints) {
                    	this.drawStartEndPoints(w, toLines, x, w.isDrawStartEndPoints);
                    }
                    return;
                }

                for (var i = 0; i < l; i++) {
                    var tli = toLines[i],
                        fli = fromLines[i];
                    lines[i] = {x:(cfg.index * (tli.x - fli.x) / cfg.rate) + fli.x, y:(cfg.index * (tli.y - fli.y) / cfg.rate) + fli.y};
                }

                this.drawLineSet(w, lines, false,  x);

                var me = this;
                cfg.index++;
                window.setTimeout(function() {
                    me.animateLineSet(w, fromLines, toLines,  cfg);
                }, 40);

			},

			//fill in the area below the lines
            fillLinesArea: function flA(w,area) {
				var hgt = w.canvas.height;

				area.push({x:w.getWidth() - w.margin.r, y:hgt - w.margin.b});
				area.push({x:w.margin.l, y:hgt - w.margin.b});

                var fillColor = new Array();
                if(w.fillinColor) {
                	mstrmojo.requiresCls("mstrmojo.color");
                	var g = mstrmojo.color.hex2rgb(w.fillinColor).join(',');
                	fillColor[0] = 'rgba(' +  g + ', 0.8)';
                	fillColor[1] = 'rgba(' +  g + ', 0.2)';
                } else {
                	fillColor = ['rgba(255,128,0,0.8)', 'rgba(255,128,0,0.2)'];
                }

                var ctx = w.animationContext;
                var g = ctx.createLinearGradient(0, 0, 0, hgt);

                g.addColorStop(0, fillColor[0]);
                g.addColorStop(0.75, fillColor[1]);

                ctx.fillStyle = g;
                this.drawLineSet(w, area, true, ctx);
            },

            convertRawValueToMilliseconds: function convertRawValueToMilliseconds(/*String*/val) {
          		var daysSinceJan1st1899_12_30 = Number(val),
            		realVal = daysSinceJan1st1899_12_30 - ((new Date('1/1/1970').getTime() - new Date('12/30/1899').getTime())/millisOnDay) - T_Z_A,
            		dt = new Date(realVal * millisOnDay); // new date with time zone
        		return new Date(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate()).getTime(); //adjust to ignore the time zone difference, but use an absolute UTC time.
        	},

        	/**
			 * get the background color of the nearest ancestor which has "background-color"
			 * @param widget
			 * return the background color if any, or else return null
			 */
        	getAncestorBgColor: function getAncestorBgColor(widget) {
    			var bgColor = null,
    				me = widget,
    				model = me.model,
    				docModel = null;
    			if (me.hasOwnProperty("xtabModel") && me.xtabModel.hasOwnProperty("docModel")) {
    				docModel = me.xtabModel.docModel;
    			}
    			if (docModel && docModel.defn && docModel.defn.layouts && docModel.defn.layouts.length>0) {
    				var layouts = docModel.defn.layouts,
    					layout;
    				var i;
    				// for document which has multiple layouts
    				for(i in layouts) {
    					if (layouts[i].loaded) {
    						layout = layouts[i];
    					}
    				}
    				if (layout && layout.hasOwnProperty("units")) {
    					var units = layout.units;
    					var parent = model.parent;
    					while (parent) {
    						var pk = parent.k || null;
    						if (units[pk] && units[pk].fmts && units[pk].fmts["background-color"]) {
    							bgColor = units[pk].fmts["background-color"];
    							break;
    						} else {
    							parent = parent.parent || null;
    						}
    					}
    					if (!bgColor) {
    						if (layout.fmts && layout.fmts["background-color"]) {
    							bgColor = layout.fmts["background-color"];
    						}
    					}
    				}

    			}

    			return bgColor;

        	},

        	getPointDistanceSquare: function getPointDistSquare(p1 ,p2){
            	return (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y);
            },

            truncateTextToLine: function(elem, span, lineCount){
            	span.className = elem.className;
            	span.style.whiteSpace = "nowrap";
//            	span.style.visibility = "visible";
            	var str = span.innerHTML = elem.innerHTML;
            	var paddingWidth = parseInt(elem.offsetWidth) - parseInt(elem.style.width);
            	var maxWidth = lineCount * parseInt(elem.style.width) + paddingWidth ;

            	var res = str;
            	if(span.offsetWidth > maxWidth){
            		var low = 0,
                    high = str.length - 1;
	                while (low <= high) {
	                    var mid = Math.round((low + high) / 2);
	                    var s0 = str.substr(0, mid+1);
	                    var s1 = str.substr(0, mid+2);
	                    span.innerHTML = s0;
	                    var h0 = span.offsetWidth;
	                    span.innerHTML = s1;
	                    var h1 = span.offsetWidth;

	                    if (h0 <= maxWidth && h1 > maxWidth) {
	                        break;
	                    } else if (h0 > maxWidth) { // still exceeds
	                        high = mid - 1;
	                    } else if (h1 <= maxWidth) {
	                        low = mid + 1;
	                    }
	                }

	                res = str.substr(0, mid+1);
	                if (res.length < str.length) { // for some extreme case, they might be identical.
	                    if (res.charAt(res.length-1) === ' ') { // remove last char if it's ' '
	                        res = res.substr(0, res.length-1);
	                    }
	                    var pos = res.lastIndexOf(' ');
	                    var left = res.length - 1 - pos; // how many characters are there after the last ' '
	                    if (left >= 2 && left <= 8) { // do some wrapping
	                        res = res.substr(0, res.length-left-1) + '...';
	                    } else {
	                        res = res.substr(0, res.length-3) + '...'; // simply remove last 3 characters and append '...'
	                    }
	                }
            	}

            	elem.innerHTML = res;
            },
            getLen:function(text, span, errorAdjust, paddingWidth)
            {
            	span.innerHTML = text;
        		var wiLen = span.offsetWidth + errorAdjust - paddingWidth;
        		return wiLen;
            },

            splitWordIfTooLong: function(wlst, span, availSp, paddingWidth, errorAdjust){
        	//return wlst;
        	var wordsArr = wlst.split(' ');
        	var res = [];
        	var sz = wordsArr.length;
        	var i = 0;
        	var j = 0;
        	for (i = 0; i < sz; i++)
        	{
        		var wd = wordsArr[i];
        		while(true){
        			//span.innerHTML = wd;
        			var wiLen = this.getLen(wd, span, errorAdjust, paddingWidth);//span.offsetWidth + errorAdjust - paddingWidth;
        			if(wiLen > availSp){
        				var clipL = (availSp/wiLen) * wd.length;
        				var intClip = Math.round(clipL);

        				while(intClip > 0){
        					var tpWd = wd.substr(0, intClip);
        					var len1 = this.getLen(tpWd, span, errorAdjust, paddingWidth);
        					if(len1<=availSp){
        						res.push( tpWd );
        						break;
        					}
        					else
        						intClip--;
        				}
        				//wiLen = availSp; // if one word is already larger than the space, clip it.
        				wd = wd.substr(intClip, wd.length - intClip);
        			}
        			else{
        				res.push(wd);
        				break;
        			}
        		}
        	}
        	return res.join(' ');
        },
            truncateTextToLineWithWordWrap: function(elem, span, lineCount){
            	span.className = elem.className;
            	span.style.whiteSpace = "nowrap";
//            	span.style.visibility = "visible";
            	var errorAdjust = 7;
            	//max Width is the available space, span.offsetWidth is the measured width of text
            	var availSp = -1;
            	if(elem.style && elem.style.width && elem.style.width.length > 0){
            		availSp= parseFloat(elem.style.width);
            	}
            	if(availSp < 0)
            		availSp = parseFloat(mstrmojo.css.getComputedStyle(elem).width);

            	var str = elem.innerHTML;
            	var paddingWidth = parseFloat(elem.offsetWidth) - availSp;//parseInt(elem.style.width);
            	//var maxWidth = lineCount * availSp + paddingWidth ;

            	str = this.splitWordIfTooLong( str, span, availSp, paddingWidth, errorAdjust );

            	var wordsArr = str.split(' ');
            	var lenArr = [];
            	var preLenArr = [];
            	var i = 0;
            	var totalLen = 0;
            	var sz = wordsArr.length;
            	span.innerHTML = '&nbsp;';
            	var blankSpaceLen = span.offsetWidth - paddingWidth;
            	preLenArr.push(0);//the len is zero with none words is considered
            	for (i = 0; i < sz; i++)
            	{
            		//span.innerHTML = wordsArr[i];
            		//var wiLen = span.offsetWidth + errorAdjust - paddingWidth;
            		var wiLen = this.getLen(wordsArr[i], span, errorAdjust, paddingWidth);
            		if(wiLen > availSp){
            			var wd = wordsArr[i];
            			var clipL = (availSp/wiLen) * wd.length;
            			wordsArr[i] = wd.substr(0, parseInt(clipL));
            			wiLen = availSp; // if one word is already larger than the space, clip it.
            		}
            		lenArr.push(wiLen);
            		totalLen += wiLen;
            		preLenArr.push(totalLen);
            		if( i !== sz - 1 )
            			totalLen += blankSpaceLen;
            	}
            	//now lets arrange the words for each line
            	var lnS = 0, lnE = 0;//the start and end index for this line
            	var ln = lineCount;
            	for (; lnE < preLenArr.length; )
            	{
            		var len1 = preLenArr[lnE] - preLenArr[lnS];
            		if(lnS > 0 && lnE != lnS)
            			len1 -= blankSpaceLen;
            		var len2 = preLenArr[lnE+1]-preLenArr[lnS];
            		if(lnS > 0 && lnE + 1 != lnS )
            			len2 -= blankSpaceLen;
            		if( len1 <= availSp &&  ((lnE+1 == preLenArr.length) || (len2 > availSp)))
            		{
            			//one line consumed
            			ln --;
            			if( ln == 0 || lnE === sz )
            				break;
            			else
            			{
            				lnS = lnE;
            				lnE++;
            			}
            		}
            		else
            		{
            			lnE++;
            		}
            	}
            	if(lnE > sz)
            		lnE = sz;
            	var lastlineLen = preLenArr[lnE] - preLenArr[lnS];
        		if(lnS > 0 && lnE != lnS)
        			lastlineLen -= blankSpaceLen;

            	var res;
            	if(lnE >= sz && lastlineLen < availSp)//all words can be fit in
            		res = wordsArr.join(' ');
            	else{
            		res = wordsArr.slice(0, lnE).join(' ');
            		//we need to add ...
            		//var lastlineLen = preLenArr[lnE] - preLenArr[lnS];
            		//if(lnS > 0 && lnE != lnS)
            		//	lastlineLen -= blankSpaceLen;

            		//span.innerHTML = '...';
                	//var elipLen = span.offsetWidth + errorAdjust - paddingWidth;
                	var elipLen = this.getLen('...', span, errorAdjust, paddingWidth);

                	if( lastlineLen + elipLen <= availSp)
                		res += '...';
                	else
                	{
                		if (res.charAt(res.length-1) === ' ') { // remove last char if it's ' '
	                        res = res.substr(0, res.length-1);
	                    }
	                    var pos = res.lastIndexOf(' ');
	                    var left = res.length - 1 - pos; // how many characters are there after the last ' '
	                    /*if (left >= 2 && left <= 8) { // do some wrapping
	                        res = res.substr(0, res.length-left-1) + '...';
	                    } else {
	                        res = res.substr(0, res.length-3) + '...'; // simply remove last 3 characters and append '...'
	                    }*/
	                    if( left === 3 )
	                    	res = res.substr(0, res.length-3) + ' ...'; // simply remove last 3 characters and append '...'
	                    else
	                    	res = res.substr(0, res.length-3) + '...';
                	}
            	}
            	elem.innerHTML = res;
            },

            getLen2:function(text, fontStr, txtCvs)
            {
            	var canvas = txtCvs;
				var context = canvas.getContext('2d');
				context.font = fontStr;
				context.textAlign = 'center';
				context.fillStyle = 'blue';
				// get text metrics
				var metrics = context.measureText(text);
				var width = metrics.width;
				return width;
            },

            splitWordIfTooLong2: function(wlst, availSp, fontStyle, txtCvs){
            	//return wlst;
            	var wordsArr = wlst.split(' ');
            	var res = [];
            	var sz = wordsArr.length;
            	var i = 0;
            	var j = 0;
            	for (i = 0; i < sz; i++)
            	{
            		var wd = wordsArr[i];
            		while(true){
            			//span.innerHTML = wd;
            			var wiLen = this.getLen2(wd, fontStyle, txtCvs);//span.offsetWidth + errorAdjust - paddingWidth;
            			if(wiLen > availSp){
            				var clipL = (availSp/wiLen) * wd.length;
            				var intClip = Math.max(Math.round(clipL), 1);//will infinit loop if intClip < 1

            				while(intClip > 0){
            					var tpWd = wd.substr(0, intClip);
            					var len1 = this.getLen2(tpWd, fontStyle, txtCvs);
            					//to avoid infinit loop and constrain that at least one letter
            					if(len1<=availSp ||intClip == 1){
            						res.push( tpWd );
            						break;
            					}
            					else
            						intClip--;
            				}
            				//wiLen = availSp; // if one word is already larger than the space, clip it.
            				wd = wd.substr(intClip, wd.length - intClip);
            			}
            			else{
            				res.push(wd);
            				break;
            			}
            		}
            	}
            	return res.join(' ');
            },

            //We can't get the computedStyle.font on device, but we can get it by construct
            getComputedFontStyle: function getCFontStyle(computedStyle){
                var fontStyle = computedStyle.fontStyle + " "
                    + computedStyle.fontWeight + " "
                    + computedStyle.fontSize + "/"
                    + computedStyle.fontVariant
                    + " " + computedStyle.fontFamily;

                return fontStyle;
            },

            /***
             * truncate a given text to fixed lines. Use word-wrap
             *
             * @param elem the dom elem to truncate
             * @param txtCvs canvas used to measure the width of text
             * @param lineCount the line count to truncate
             *
             * return true if the text can't be fit in the elem
             */
            truncateTextToLineWithWordWrap2: function(elem, txtCvs, lineCount){
            	//max Width is the available space, span.offsetWidth is the measured width of text
            	var availSp = -1;
            	if(elem.style && elem.style.width && elem.style.width.length > 0){
            		var paddingWidth = 0;

					var compStyle = mstrmojo.css.getComputedStyle(elem);
					if( compStyle.paddingLeft ){
						paddingWidth += parseFloat(compStyle.paddingLeft);
					}
					if( compStyle.paddingRight ){
						paddingWidth += parseFloat(compStyle.paddingRight);
					}

					var elemWidth = elem.offsetWidth;
					availSp = elemWidth ? elemWidth - paddingWidth : parseInt(elem.style.width);
            	}
            	if(availSp < 0){
//            		availSp = parseFloat(mstrmojo.css.getComputedStyle(elem).width);
            		elem.innerHTML = "...";
            		return;
            	}

            	var str = elem.innerHTML;
            	var computedStyle = mstrmojo.css.getComputedStyle(elem);
            	var fontStyle = this.getComputedFontStyle(computedStyle);
            	str = this.splitWordIfTooLong2( str, availSp, fontStyle, txtCvs );


            	var wordsArr = str.split(' ');
            	var lenArr = [];
            	var preLenArr = [];
            	var i = 0;
            	var totalLen = 0;
            	var sz = wordsArr.length;
            	//span.innerHTML = '&nbsp;';
            	var blankSpaceLen = this.getLen2(' ', fontStyle, txtCvs);//span.offsetWidth - paddingWidth;
            	preLenArr.push(0);//the len is zero with none words is considered
            	for (i = 0; i < sz; i++)
            	{
            		//span.innerHTML = wordsArr[i];
            		//var wiLen = span.offsetWidth + errorAdjust - paddingWidth;
            		var wiLen = this.getLen2(wordsArr[i], fontStyle, txtCvs);
            		if(wiLen > availSp){
            			var wd = wordsArr[i];
            			var clipL = (availSp/wiLen) * wd.length;
            			wordsArr[i] = wd.substr(0, parseInt(clipL));
            			wiLen = availSp; // if one word is already larger than the space, clip it.
            		}
            		lenArr.push(wiLen);
            		totalLen += wiLen;
            		preLenArr.push(totalLen);
            		if( i !== sz - 1 )
            			totalLen += blankSpaceLen;
            	}
            	//now lets arrange the words for each line
            	var lnS = 0, lnE = 0;//the start and end index for this line
            	var ln = lineCount;
            	for (; lnE < preLenArr.length; )
            	{
            		var len1 = preLenArr[lnE] - preLenArr[lnS];
            		if(lnS > 0 && lnE != lnS)
            			len1 -= blankSpaceLen;
            		var len2 = preLenArr[lnE+1]-preLenArr[lnS];
            		if(lnS > 0 && lnE + 1 != lnS )
            			len2 -= blankSpaceLen;
            		if( len1 <= availSp &&  ((lnE+1 == preLenArr.length) || (len2 > availSp)))
            		{
            			//one line consumed
            			ln --;
            			if( ln == 0 || lnE === sz )
            				break;
            			else
            			{
            				lnS = lnE;
            				lnE++;
            			}
            		}
            		else
            		{
            			lnE++;
            		}
            	}
            	if(lnE > sz)
            		lnE = sz;
            	var lastlineLen = preLenArr[lnE] - preLenArr[lnS];
        		if(lnS > 0 && lnE != lnS)
        			lastlineLen -= blankSpaceLen;

            	var res;
            	if(lnE >= sz && lastlineLen < availSp)//all words can be fit in
            		res = wordsArr.join(' ');
            	else{
            		res = wordsArr.slice(0, lnE).join(' ');
            		//we need to add ...
            		//var lastlineLen = preLenArr[lnE] - preLenArr[lnS];
            		//if(lnS > 0 && lnE != lnS)
            		//	lastlineLen -= blankSpaceLen;

            		//span.innerHTML = '...';
                	//var elipLen = span.offsetWidth + errorAdjust - paddingWidth;
                	var elipLen = this.getLen2('...', fontStyle, txtCvs);

                	if( lastlineLen + elipLen <= availSp)
                		res += '...';
                	else
                	{
                		if (res.charAt(res.length-1) === ' ') { // remove last char if it's ' '
	                        res = res.substr(0, res.length-1);
	                    }
	                    var pos = res.lastIndexOf(' ');
	                    var left = res.length - 1 - pos; // how many characters are there after the last ' '
	                    /*if (left >= 2 && left <= 8) { // do some wrapping
	                        res = res.substr(0, res.length-left-1) + '...';
	                    } else {
	                        res = res.substr(0, res.length-3) + '...'; // simply remove last 3 characters and append '...'
	                    }*/
	                    if( left === 3 )
	                    	res = res.substr(0, res.length-3) + ' ...'; // simply remove last 3 characters and append '...'
	                    else
	                    	res = res.substr(0, res.length-3) + '...';
                	}
            	}
            	elem.innerHTML = res;

                return res.indexOf('...') > -1;
            },



            truncateDivContent: function (str, span, comp) {
				span.innerHTML = str;
                if (span.offsetHeight > comp) { // str causes overflow, need to cut it shorter
                    var low = 0,
                        high = str.length - 1;
                    while (low <= high) {
                        var mid = Math.round((low + high) / 2);
                        var s0 = str.substr(0, mid+1);
                        var s1 = str.substr(0, mid+2);
                        span.innerHTML = s0;
                        var h0 = span.offsetHeight;
                        span.innerHTML = s1;
                        var h1 = span.offsetHeight;

                        if (h0 <= comp && h1 > comp) {
                            break;
                        } else if (h0 > comp) { // still exceeds
                            high = mid - 1;
                        } else if (h1 <= comp) {
                            low = mid + 1;
                        }
                    }

                    var res = str.substr(0, mid+1);
                    if (res.length < str.length) { // for some extreme case, they might be identical.
                        if (res.charAt(res.length-1) === ' ') { // remove last char if it's ' '
                            res = res.substr(0, res.length-1);
                        }
                        var pos = res.lastIndexOf(' ');
                        var left = res.length - 1 - pos; // how many characters are there after the last ' '
                        if (left >= 2 && left <= 8) { // do some wrapping
                            res = res.substr(0, res.length-left-1) + '...';
                        } else {
                            res = res.substr(0, res.length-3) + '...'; // simply remove last 3 characters and append '...'
                        }
                    }
                    return res;
                } else {
					return str;
				}
			}


        });

})();
(function() {
    
    mstrmojo.requiresCls("mstrmojo.dom");
    
    var $D = mstrmojo.dom;
    
    /**
     * The mixin includes the document specific components (e.g. formatHandlers, format applying functions etc) for Xtab
     */
    mstrmojo._IsDocXtab = {
            
        _mixinName: 'mstrmojo._IsDocXtab',            
        
        /**
         * Flag denotes whether the xtab is featured within a document.
         * 
         * @type boolean
         */
        isDocXtab: true,
        
        formatHandlers: {
            // note - we need 'font' for Zoom feature. 
            domNode: [ 'RW', 'T', 'font'],
            msgNode: [ 'height', 'background-color' ],
            viewport: [ 'D', 'background-color', 'B', 'fx' ]
        },
                
        preBuildRendering: function preBuildRendering() {
            
            // Set scrollbox dimensions.
            var f = this.getFormats(),
                cs = '',
                setDim = function setDim(dim) {
                    if(f[dim]) {
                        //Do we already have a dimension set on the widget? use that or else get it from the formatting object.
                        var d = this[dim] || f[dim];
                        
                        //Sync up the dimension property on the widget and the formatting property. 
                        this[dim] = d;
                        
                        //Are we rendering in fullscreen screen mode?
                        if (this.isFullScreenWidget) {
                            f[dim] = d;
                        }
                        
                        //Set the dimension limit on the widget.
                        this[dim + 'Limit'] = parseInt(d, 10);
                    }
                };

            //Initialize the dimensions
            setDim.call(this, 'height');
            setDim.call(this, 'width');
            
            // todo: do we need this? Why not just use scrollBox node format handler?
            // Utility function for calculating a scroll box dimension.
            var fn = function (d, offset) {
                // Get value for passed in dimension.
                var x = f[d];

                // Is this dimension fixed (not auto or %)?
                if (x && x.charAt(x.length - 1) !== '%') {
                    var v = parseInt(x, 10);
                    
                    // Is it a number (not 'auto')?
                    if (!isNaN(v)) {
                        // Subtract the offset.
                        if (offset) {
                            v -= offset;
                        }
                        
                        // NOTE : We tried using max-width and max-height here .... Since grid is rendered incrementally, it causes entire table (including scroller) to jump as you scroll and render cols with larger values. Also, the pageHeight 
                        // calculation is messed up at the bottom of the viewport. 
                        cs += d + ':' + v + 'px;';
                    }
                }

                // ensure that scrollbox is disconnected off the old DOM.
                /*
                if (this.lockHeadersCase) {
                    this.disconnectScrollbox(this);
                }
                */
                
                return null;
            };
            
            // Calculate the scrollbox height.  If the title bar is visible we need to pass the height of the titlebar for the offset.
            fn('height', 0);
            
            // Calculate the scrollbox width.
            fn('width', 0);
            
            this.scrollboxNodeCssText = cs;
            
            return this._super();
        },        
               
        /**
         * The function is called when we resize the portal from the title bar.
         */
        resize: function() {              
            // Clear the format from cache
            this.clearCache();                
            // Get the new format
            var f = this.getFormats(),
                h = parseInt(f.height, 10),
                w = parseInt(f.width, 10);
            if (w > 0 && h > 0) {
                if (!this.visible && this.forcedHidden){
                    this.set('visible', true);
                    this.forcedHidden = false;
                }
                //this.renderPortalState();
                
                // Resize domNodes
                mstrmojo.array.forEach([this.scrollboxNode, this.viewport], function (node) {
                    var nodeStyle = node.style;
                    nodeStyle.height = h + 'px';
                    nodeStyle.width = w + 'px';
                });
                
                // The _HasTitleBar applyWindowSize() has already set the domNode size, we only need to reset the scrollBox node size 
                if (this.scrollboxNode) {
                    
                    this.scrollboxHeightFixed = h && (h !== "auto");

                    // todo1-what if we come here with non-fixed height and width?
                    if (this.scrollboxHeightFixed) {
                        this.scrollboxHeight = parseInt(h, 10); 
                        // Update scrollboxBottom so that the ondemandGrid can have the right viewport size
                        this.scrollboxBottom = this.scrollboxTop + h;
                        // Do we need this? 
                        //this.scrollboxRight = this.scrollboxLeft + w;
                    }                            

                    // If we have any locked headers, wire the scrollboxNode to our onscroll handler.
                    if (this.lockHeadersCase) {
                        this.resizeScrollBox($D.isIE);
                    }
                }                   

                // trigger the onscoll of the zones so that they can render based on the new viewport size. 
                var zs = this.zones;
                if(zs) {
                    if(zs._BL) {
                        zs._BL.onscroll();
                    }
                    if(zs._BR) {
                        zs._BR.onscroll();
                    }
                }
                
                if (!(this.gridData && this.gridData.eg)) {
                    //TQMS 423289: we need to update the xtab._pl if it is resized.
                    this.onGridWidthChanged();
                }
            } else {
                // since portlet will not have overflow: hidden, we need to hide the grid
                if (this.visible) {
                    this.set('visible', false);
                    this.forcedHidden = true;
                }
            }
        },        
                
        /**
         * <p>Clears the formatting cache, unrenders and then renders this control.</p>
         * 
         * <p>Typically called when the formatting properties have changed and you want to re-render the mstrmojo.Xtab.</p>
         */
        renderPortalState: function renderPortalState() {
            this.clearCache();
            this.unrender();
            this.render();
        },        
        
        /**
         * On unrendering the doc Xtab, we need to clear it's formatting cache.
         * 
         * @see mstrmojo._HasMarkup
         */
        unrender: function unrender() {
            //Clear the cache.
            this.clearCache();
            
            //Call super.
            if (this._super) {
                this._super();
            }
        },        
        
        /**
         * Overwrite the default action function from XtabBase, and add setting high light color
         */
        defaultAction: function defaultAction(td, tCell) {
            if (this._super(td, tCell)) {
                var sti = this.model.sti,
                    titleId = sti && sti.titleId,
                    deselectCurrentCell = sti && sti.deselectCurrent,
                    z;
                
                //Remember the current selected td.
                this._currentSelectedTD = deselectCurrentCell ? undefined : td;            
                
                // If the a cell is selected as selector control, the sti is the title id for the column.
                if (titleId) {
                    // Find the right zone to response the click action, highlight selected cell.
                    for (z in this.zones) {
                        var zn = this.zones[z],
                            dn = zn.domNode,
                            fc = dn && dn.firstChild;
                        
                        if (fc && (td.offsetParent === fc || td.offsetParent === dn)) {
                            zn.clearHilites(titleId);
                            if (!deselectCurrentCell) {
                                zn.setHilites(titleId, td);
                            }
                            zn.hiliteKey = titleId; // record in case we need to clear this
                            
                            this.model.sti = null;
                            return true;
                        }
                    }
                }
                
                return true;
            }
            
            return false;
        }        
    };
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.dom");
    
    var $D = mstrmojo.dom,
        $MATH = Math;
    
    var    PLACEMENT_AUTO = 1,
        PLACEMENT_FIXED = 2,
        PLACEMENT_ABOVE = 3,
        PLACEMENT_BELOW = 4,
        PLACEMENT_LEFT = 5,
        PLACEMENT_RIGHT = 6;
        /**
         * Amchors a popup (with dynamic tip) to an HTML Element, intelligently positioning it so it will be visible when the anchor is near an edge.
         */
        function anchorPopup() {
        
            var anchor = this.anchor;
            
            if(!anchor){
                return false;
            }
            
            // make sure tipNode is not hidden.  If hidden the position element gets the wrong dimensions.  Temporarily make it dimension to top.
            var  baseTipCls = this.baseTipClass, 
                tipNode = this[this.tipNodeName];
            tipNode.className = baseTipCls + ' top';
            
            var boundary = this[this.boundaryNodeName],
                popupNode = this[this.popupNodeName],
                editorOffset = this.anchorOffset,
                defaultOrientation = this.anchorOrientation,
                hasScrollbars = this.hasScrollbars(),
                anchorPosition = mstrmojo.hash.copy(this.anchorPosition || $D.position(anchor, true)),
                boundaryPosition = $D.position(boundary, true),
                boundaryRight = boundaryPosition.w,
                boundaryBottom = boundaryPosition.h,
                popWidth = popupNode.offsetWidth,
                popHeight = popupNode.offsetHeight,
                halfPopWidth =  popWidth / 2,
                halfPopHeight = popHeight / 2,
                tipPosition = $D.position(tipNode),
                tipDimensionShort = $MATH.min(tipPosition.h, tipPosition.w),
                tipHalfLong = $MATH.max(tipPosition.h, tipPosition.w) / 2,
                plm = this.placement;
            
            // Should we allow for scrollbars?
            if (hasScrollbars) {
                // Reduce boudary edges by the default scroll bar width.
                boundaryRight -= 15;
                boundaryBottom -= 15;
            }
            
            // Create default values for popup position, tip position and tip css class.
            var popupInsideBoundary = $D.contains(boundary, popupNode), // Whether the popup node is indide the boundary node
                offsetTop = popupInsideBoundary ? 0 : boundaryPosition.y, //top offset, if the popup is rendered inside boundary node, ignore the value, otherwise, account the boundary top offset 
                popLeft = boundaryRight / 2 - halfPopWidth,      // Default to center horizontally.
                popTop = boundaryBottom / 2 - halfPopHeight + offsetTop,     // Default to center vertically,counting the boundary top offset 
                tipLeft = -1000,                                 // Default to tip offscreen.
                tipTop = -1000,                                  // Default to tip offscreen.
                tipClass,
                tipBorderStyles = ['borderBottomColor', 'borderTopColor', 'borderRightColor', 'borderLeftColor'],
                tipStyleIdx = 0;
            
            // Because the anchor position is absolute to document rather than the boundary. So if the popup 
            // is inside the boundary node (so as the anchor), subtract the boundary position from anchor position
            if(popupInsideBoundary) {
                // Reset anchor position to be relative to boundary position.
                anchorPosition.x = anchorPosition.x - boundaryPosition.x;
                anchorPosition.y = anchorPosition.y - boundaryPosition.y;
            }

            var anchorBottom = anchorPosition.y + anchorPosition.h,
                anchorRight = anchorPosition.x + anchorPosition.w,
                fitsRight = ((anchorRight + popWidth) < boundaryRight),
                fitsAbove = anchorPosition.y > popHeight,
                fitsBottom = ((anchorBottom + popHeight) < boundaryBottom),
                fnBounds = function (minVal, maxVal, desiredVal) {                              // Constrains a value to within the given boundaries.
                    return $MATH.min($MATH.max(minVal, desiredVal), $MATH.max(maxVal, 0));
                },
                fnVertFit = function() {
                    // Will the width of the popup fit within the right boundary and will it either fit to the top or bottom of the anchor?
                    if ((anchorPosition.x < boundaryRight) && (fitsBottom || fitsAbove)) {
                        // Calculate the mid width point of the anchor.
                        var anchorMidWidth = anchorPosition.x + (anchorPosition.w / 2),
                            // TQMS 680075: Automatic placement should default to Above. 
                            posBottom = (plm == PLACEMENT_BELOW && fitsBottom) || !fitsAbove;
                        
                        // Should we place it below the anchor?
                        if (posBottom) {
                            // Tip should appear on the top side of the popup and at the bottom edge of the anchor.
                            tipClass = 'top';
                            tipTop = anchorBottom; 
                            tipStyleIdx = 0;
                            
                            // Popup should appear below the tip.
                            popTop = anchorBottom + tipDimensionShort - editorOffset;
                            
                        } else {
                            // Tip should appear on the bottom side of the popup at the top edge of the anchor.
                            tipClass = 'bottom';
                            tipTop = anchorPosition.y - tipDimensionShort;
                            tipStyleIdx = 1;
                            
                            // Popup should appear above the tip.
                            popTop = tipTop - popHeight + editorOffset;
                        }
    
                        // Ideally the popop should appear horizontally centered with the anchor, but bounded by the boundary edges.
                        popLeft = fnBounds(0, boundaryRight - popWidth, anchorMidWidth - halfPopWidth);
    
                        // Ideally the tip should appear horizontally centered within the anchor, but bounded by the popup edges. 
                        tipLeft = fnBounds(anchorPosition.x, anchorRight, anchorMidWidth) - tipHalfLong;
    
                        // We found a vertical fit, so return true.
                        return true; 
                    }
                    
                    // Doesn't fit vertically, so return false.
                    return false;
                },
                fnHorizFit = function() {
                    // Will the height of the popup fit within the bottom boundary and will it either fit to the right or left of the anchor?
                    if ((anchorPosition.y < boundaryBottom) && (fitsRight || anchorPosition.x > popWidth)) {
                        // Calculate the mid height point of the anchor.
                        var anchorMidHeight = anchorPosition.y + (anchorPosition.h / 2),
                            posRight = !(plm == PLACEMENT_LEFT && anchorPosition.x > popWidth) && fitsRight;
                        
                        // Does it fit to the right or the anchor??
                        if (posRight) {
                            // Tip should appear on the left side of the popup at the right edge of the anchor.
                            tipClass = 'left';
                            tipLeft = anchorRight; 
                            tipStyleIdx = 2;
                            
                            // Popup should appear to the right of the tip.
                            popLeft = anchorRight + tipDimensionShort - editorOffset;
                            
                        } else {
                            // Tip should appear on the right side of the popup at the left edge of the anchor.
                            tipClass = 'right';
                            tipLeft = anchorPosition.x - tipDimensionShort;
                            tipStyleIdx = 3;
                            
                            // Popup should appear to the left of the tip.
                            popLeft = tipLeft - popWidth + editorOffset;
                        }
                        
                        // Ideally the popop should appear vertically centered with the anchor, but bounded by the boundary edges.
                        // XZ:considering the case that the curtain might not cover the whole screen, the boundary top should start from boundary top
                        popTop = fnBounds(offsetTop, boundaryBottom - popHeight, anchorMidHeight - halfPopHeight);
                        
                        // Ideally the tip should appear vertically centered within the anchor, but bounded by the popup edges. 
                        tipTop = fnBounds(anchorPosition.y, anchorBottom, anchorMidHeight) - tipHalfLong;
                        
                        // We found a horizontal fit, so return true.
                        return true;
                    }               
                    
                    // Doesn't fit horizontally, so return false.
                    return false;
                },
                testFns = [ fnVertFit, fnHorizFit ],                // Collection of functions to test for fit, default order is vertical orientation first.
                i = 0;
                
            if (plm == PLACEMENT_FIXED) {
                popTop = this.popPosition.top;
                popLeft = this.popPosition.left;
                tipTop = -1000;
                tipLeft = -1000;
                tipClass = null;
            } else {    
                
                // Should we check horizontal orientations first?
                if (plm == PLACEMENT_LEFT || plm == PLACEMENT_RIGHT ||
                        (plm == PLACEMENT_AUTO && defaultOrientation === 'h')) {
                    // Reverse the test functions.
                    testFns.reverse();
                }

                // Iterate test functions.
                for (; i < 2; i++) {
                    // Execute test function.  Did it return true?
                    if (testFns[i]()) {
                        // We've found a fit so stop iteration.
                        break;
                    }
                }
                
                popTop = $MATH.round(popTop);
                popLeft = $MATH.round(popLeft);
                tipTop = $MATH.round(tipTop);
                tipLeft = $MATH.round(tipLeft);
            }
    
            // Add position css class to tip node (default to hidden).
            tipNode.className = baseTipCls + ' ' + (tipClass || 'hidden');
            
            var tipNodeStyle = tipNode.style,
                popupNodeStyle = popupNode.style;
            
            // Position the tip.
            tipNodeStyle.top = tipTop + 'px';
            tipNodeStyle.left = tipLeft + 'px';
            // #709485. use matching color for tip node
            if (this.tipNodeColor) {
                // clear the previous color setting
                mstrmojo.array.forEach(tipBorderStyles, function(s) {
                    tipNodeStyle[s] = '';
                });
                tipNodeStyle[tipBorderStyles[tipStyleIdx]] = this.tipNodeColor;
            }
            
            // Position the popup.
            popupNodeStyle.top = popTop + 'px';
            popupNodeStyle.left = popLeft + 'px';
            
            return true;
        }
    
    /**
     * Mixin to allow a popup or dialog to be anchored.
     * 
     * @class
     * @public
     */    
    mstrmojo._IsAnchorable = {
        
        /**
         * {HTMLElement} anchor The element that anchors the popup.
         * */
        anchor : null,
        
        /**
         * {Object} it takes 4 properties: 'x','y','w','h' which together define a rectangle area that the popup should be anchored at.
         * If its value is null, it'll be calculated by measuring the given anchor element.
         */
        anchorPosition: null,
        
        /**
         * {String} boundaryNodeName, name of the element that comprises the boundary edges for popup display.
         * */
        boundaryNodeName : 'curtainNode',
        
        /**
         * {String} popupNodeName, name of the element to anchor.
         * */
        popupNodeName : 'editorNode',
        
        /**
         * {String} tipNode The element that represents the popup tip (points to the anchor).
         * */
        tipNodeName : 'tipNode',
        
        /**
         * {String} baseTipCls The css class for the tip element (this method will add 'left', 'right', etc. classes to the base class name).
         * */
        baseTipClass : 'mstrmojo-Editor-tip',
        
        /**
         * {Integer} editorOffset The amount to back the editor off the tip so that they line up correctly.
         * */
        anchorOffset : 25,
        
        /**
         * {String} [defaultOrientation=v] The deafult orientation ("v" = vertical, "h" = horizontal) which will be the first position used when trying to fit the popup.
         * */
        anchorOrientation : 'v',
        
        placement: PLACEMENT_AUTO,
        
        popPosition: null,
        
        /**
         * {Function} Return boolean for whether the boundary may contain scroll bars.
         * */
        hasScrollbars : function hasScrollbars(){
            return (!mstrApp.isTouchApp || !mstrApp.isTouchApp());
        },
        
        /**
         * Hook to be called before position the dialog
         * */
        prepareAnchor : mstrmojo.emptyFn,
        
        positionDialog : function positionDialog(){
            this.prepareAnchor();
            if (!anchorPopup.apply(this,[])) {
                // NO, Use default positioning
                if ( typeof this._super === "function" ) {
                    this._super();
                }
            }
        }
    };
    
})();
(function(){

    mstrmojo.requiresCls("mstrmojo.dom");
    
    var _D = mstrmojo.dom,
        _DND,
        _doc = mstrmojo.global.document;
    
    function _onMouseDown(e){        
        _DND.startDragCheck(self, e);
    }
    
    var _av,
        _avin,
        _avCSS = 'mstrmojo-dnd-avatar',
        _avs;
    
    function _updateAvatar(pos, allowDrop, html){
        if (html != null) { // null or undefined means do not update, empty string means set to blank
            _avin.innerHTML = html;         
        }
        _avs.left = pos.x + 'px';
        _avs.top = pos.y + 'px';
    }
    function _showAvatar(html, pos){
        if (!_av) {
            _av = _doc.createElement("div");
            _avs = _av.style;
            _av.className = _avCSS;
            _av.innerHTML = '<div class="'+ _avCSS + '-inner"></div>';
            _avin = _av.firstChild;
            _doc.body.appendChild(_av);
        }
        _updateAvatar(pos, true, html);
        _avs.display = 'block';
    }
    function _hideAvatar(){
        if (_av) {
            _avs.display = 'none';
        }
    }
    
    /**
     * <p>Callback for mousemoves that occur after a mousedown. If sufficient # of mousemoves are
     * captured, a drag is initiated.</p>
     *
     * @param {DomEvent} [e] The mousemove DOM event object; possibly null in some browsers.
     * @private
     */
     function _onMoveDuringCheck(e) {
        var c = ++_DND.ctxt.moveCount;
        if (c >= _DND.minMoves) {
            // Stop checking for a drag; initiate a drag.
            _DND.stopDragCheck(self, e);
            _DND.startDrag(self, e);
        }
    }
    
    /**
     * <p>Callback for mouseup that occurs after a mousedown but before sufficient mousemoves to
     * initiate a drag. Detaches event listeners that were checking for the start of a drag, and
     * clears the context object of the controller.</p>
     *
     * @param {DomEvent} [e] The mouseup DOM event object; possibly null in some browsers.
     * @private
     */
    function _onUpDuringCheck(e) {
        _DND.stopDragCheck(self, e);
    }
    
    /**
     * <p>Callback for mousemove that occurs during a drag.</p>
     * @param {DomEvent} [e] The mouseup DOM event object; possibly null in some browsers.
     * @private
     */
    function _onMoveDuringDrag(e) {
        _DND.onDragMove(self, e);
    }

    /**
     * <p>Callback for mouseup that occurs during a drag, ending it.</p>
     * @param {DomEvent} [e] The mouseup DOM event object; possibly null in some browsers.
     * @private
     */
    function _onUpDuringDrag(e) {
        _DND.stopDrag(self, e);
    }

    /**
     * <p>Captures DOM event info during a drag into the properties of a given hash.</p>
     *
     * <p>The given hash represents the info for either the mousedown, mousemove, or
     * mouseup in a drag. The properties we capture specify what the event target DOM and position were.</p>
     *
     * @param {Object} h The hashtable in which to record event info.
     * @returns {Object} The given hashtable.
     */
    function _capEvtInf(h) {
        if (!h) {
            return;
        }        
        if (!h.hWin) {
            h.hWin = window;
        }
        if (!h.e) {
            h.e = h.hWin.event;
        }

        h.node = _D.eventTarget(h.hWin, h.e);
        h.pos = _D.getMousePosition(h.e, h.hWin);
        
        return h;
    }
    
    /**
     * <p>Given a DOM node, returns the nearest draggable widget that contains that DOM node.</p>
     *
     * <p>Used to determine what widget is being dragged when a mousedown occurs.</p>
     *
     * @param {DomNode} nd The DOM event target node.
     * @returns {mstrmojo.Widget} The corresponding widget, if any; null otherwise.
     */
    function _findDraggable(nd){
        var w = _D.findWidget(nd);
        while (w) {
            if (w.draggable) {
                return w;
            }
            w = w.parent;
        }
        return null;
    }
    
    /**
     * <p>Given a DOM node, returns the nearest widget that contains that DOM node and (1) is a drop zone and 
     * (2) allows a drop with the given dragging context.</p>
     *
     * <p>Used to determine what widget is being dragged when a mousedown occurs.</p>
     *
     * @param {DomNode} nd The DOM event target node.
     * @param {Object} c The dragging context.
     * @returns {mstrmojo.Widget} The corresponding widget, if any; null otherwise.
     */
    function _findDroppable(nd, c){
        var w = _D.findWidget(nd);
        while (w) {
            if (w.dropZone) {
                // Widget is a potential drop zone, check if it allows this drop.
                // TO DO: Before calling its allowDrop, check if widget.cacheAllowDrop is true, which saves us a call.
                if (w.allowDrop && w.allowDrop(c)) {
                    return w;
                }
            }
            w = w.parent;
        }
        return null;
    }
    

    /**
     * The default method applied to a drop zone if that drop zone widget has no ondragenter method.
     * @param {Object} c The dragging context.
     */    
    function _ondragenterDefault(c){
        if (this.set) {
            this.set("allowingDrop", true);
        }
    }

    /**
     * The default method applied to a drop zone if that drop zone widget has no ondragleave method.
     * @param {Object} c The dragging context.
     */    
    function _ondragleaveDefault(c){
        if (this.set) {
            this.set("allowingDrop", false);
        }
    }

    /**
     * The default method applied to a drop zone if that drop zone widget has no ondrop method.
     * @param {Object} c The dragging context.
     */    
    var _ondropDefault = _ondragleaveDefault;

    /**
     * A controller for managing drag-drop events across widgets.
     * @class
     */
    mstrmojo.dnd = mstrmojo.provide(
        "mstrmojo.dnd",
        /**
         * @lends mstrmojo.dnd#
         */
        {
            /**
             * <p>Minimum number of mousemoves required after a mousedown to start a drag.</p>
             * @type Integer
             */
            minMoves: 3,

            /**
             * <p>Attaches mousedown listener to the document in order to start capturing drags.</p>
             */            
            enable: function(){
                if(!mstrmojo.dndEnabled){
                    _D.attachEvent(_doc, "mousedown", _onMouseDown);
                    mstrmojo.dndEnabled = true;
                } 
            },
            
            /**
             * <p>Detaches mousedown listener to the document to stop capturing drags.</p>
             */            
            disable: function(){
                _D.detachEvent(_doc, "mousedown", _onMouseDown);
            },
        
            /**
             * <p>Notifies this controller of a mousedown which may potentially turn into a drag if followed
             * by sufficient number of mousemoves.</p>
             *
             * <p>Attaches listeners for mousemove and mouseup in the document. If enough mousemoves are
             * then heard, the callback initiates a drag.</p>
             *
             * @param {Object} src The info object for the source; stores data about the mousedown of the drag.
             * @param {mstrmojo.Widget} c.widget The widget in which the mousedown originated.
             * @param {Object} [c.data] Any additional information about the data about to be dragged.
             * @param {DomWindow} [c.hWin=window] The DOM window in which the DOM event occurred.
             * @param {DomEvent} [c.e] The original mousedown DOM event (possibly null in some browsers).
             * @param {DomNode} [c.node] The DOM node in which the mousedown originated.
             */
            startDragCheck: function(hWin, e){
                delete this.ctxt;
                                
                var src = _capEvtInf({hWin: hWin, e: e});
                
                this.ctxt = {src: src, moveCount: 0};
                    
                // Do we have some minimum moves threshold?
                if (this.minMoves) {
                    // Attach DOM event listeners to possibly initiate drag soon.
                    _D.attachEvent(_doc, "mousemove", _onMoveDuringCheck);
                    _D.attachEvent(_doc, "mouseup", _onUpDuringCheck);
                } else {
                    // Initiate drag immediately.
                    this.startDrag(hWin, e);
                }
            },

            /**
             * <p>Detaches listeners for mousemove and mouseup in the document that were waiting for
             * sufficient mousemoves after a mousedown to initiate a drag.</p>
             */
            stopDragCheck: function(hWin, e){
                _D.detachEvent(_doc, "mousemove", _onMoveDuringCheck);
                _D.detachEvent(_doc, "mouseup", _onUpDuringCheck);
            },

            /**                        
             * <p>Notifies the widget being dragged that a drag is starting, and attaches listeners for mousemove and
             * mouseup in the document to notify widgets that they are getting dragged-over and dropped-onto.</p>
             */
            startDrag: function(hWin, e){
                // Give this drag context a new id so it can be identified by drop zones.
                var c = this.ctxt;
                c.id = new Date();

                var src = c.src,
                    w = _findDraggable(src.node);
                if (!w) {
                    return;
                }
                
                // Ask the widget for any extra contextual data regarding this drag.
                src.widget = w;
                src.data = w.getDragData && w.getDragData(c);
                
                // Notify the src widget it is getting dragged.
                if (w.ondragstart) {
                    if (w.ondragstart(c) === false) {
                        // Drag was cancelled by the source widget.
                        return;
                    }
                }
                
                // In Firefox, this will stop native browser highlighting of text as we drag.
                // TO DO: IMPORTANT! test in other browsers (Safari, IE, Chrome).
                _D.clearBrowserHighlights();
                _D.preventDefault(self, e);

                _D.attachEvent(_doc, "mousemove", _onMoveDuringDrag);
                _D.attachEvent(_doc, "mouseup", _onUpDuringDrag);
                
                if(w && !w.ownAvatar) {
                    _showAvatar(src.data && src.data.html, src.pos);
                }
            },

            /**                        
             * <p>Detaches listeners for mousemove and mouseup in the document, notifies the widget being dropped upon
             * (if any) and notifies the widget being dragged that a drag is ending.</p>
             * @param {DomNode} hWin The DOM window in which the mouseup occurred.
             * @param {DomNode} [e] The mouseup DOM event (possibly null in some browsers).
             */
            stopDrag: function(hWin, e){                
                // Detach event listeners.
                _D.detachEvent(_doc, "mousemove", _onMoveDuringDrag);
                _D.detachEvent(_doc, "mouseup", _onUpDuringDrag);

                // Compute the targeted widget.
                var c = this.ctxt,
                    ct = _capEvtInf({hWin: hWin, e: e}),
                    w = _findDroppable(ct.node, c);
                ct.widget = w;
                c.tgt = ct;
                
                // If drop is allowed, notify target widget of a drop on it.
                // We do this before calling the drag source widget's
                // ondragend because ondragend might remove the dragged items, which
                // could cause the entire drag target and/or drag source widgets to be
                // removed before we get a chance to do the ondrop!  (For example, in an
                // expression tree, ondragend will remove a node, which in turn consolidates
                // its parent, which could remove in the parent node being removed, as well
                // as some of its ancestors.)
                if (w) {
                    // Call the widget's ondrop, our apply a default ondrop.
                    if (w.ondrop) {
                        w.ondrop(c);
                    } else {
                        _ondropDefault.apply(w, [c]);
                    }
                }

                // Notify source widget that drag is over. 
                var s = c.src.widget;
                if (s && s.ondragend) {
                    s.ondragend(c);
                }

                
                
                if(s && !s.ownAvatar) {
                    _hideAvatar();
                }
            },
            
            /**
             * <p>Notifies drag source and target of a mousemove during a drag.</p>
             * @param {DomNode} hWin The DOM window in which the mousemove occurred.
             * @param {DomNode} [e] The mousemove DOM event (possibly null in some browsers).
             */
            onDragMove: function(hWin, e){
                if (_D.isSafari) {
                    _D.clearBrowserHighlights();
                }

                // Compute the targeted widget.
                var c = this.ctxt,
                    ct = _capEvtInf({hWin: hWin, e: e}),
                    w = _findDroppable(ct.node, c);
                ct.widget = w;      
                                
                // Check if the target has changes since the last time.
                var tWas = c && c.tgt && c.tgt.widget;
                
                c.tgt = ct;
                
                if (tWas !== w) {
                    // Either this is the first drag move, or the target has changed since last drag move.

                    // Call ondragleave on the last target (if possible).
                    if (tWas) {
                        // Call the widget's ondragleave, or if missing, apply a default handler.
                        if (tWas.ondragleave) {
                            tWas.ondragleave(c);
                        } else {
                            _ondragleaveDefault.apply(tWas, [c]);
                        }
                    }
                    
                    // Call ondragenter on the new target (if possible).
                    if (w) {
                        // Call the widget's ondragenter, or if missing, apply a default handler.
                        if (w.ondragenter) {
                            w.ondragenter(c);
                        } else {
                            _ondragenterDefault.apply(w, [c]);
                        }
                    }
                } else if (w) {
                    // Target widget hasn't changed, call its ondragmove.
                    // This allows the target to update its display and decide where exactly a drop is allowed.
                    // TO DO: only call ondragmove if cacheAllowDrop is not exactly true.
                    if (w.ondragover) {
                        w.ondragover(c);
                    }
                } 

                // Let the source know that it is moving.
                var s = c.src.widget;
                if (s && s.ondragmove) {
                    s.ondragmove(c);
                }
                
                if(s && !s.ownAvatar) {
                    _updateAvatar(ct.pos, !!w);                
                }
            }
            
        });
        
    _DND = mstrmojo.dnd;

    // Wire up the document to start listening for drags.    
    _DND.enable();

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.string",
                         "mstrmojo.dom");

    var _S = mstrmojo.string,
        _D = mstrmojo.dom;

    /**
     * An orphaned DOM element used for creating other elements.
     * @private
     * @static
     * @todo Need to add code to set _elCreate to null when window unloads.
     */
    var _elCreate = mstrmojo.useFrames ? null : document.createElement('span');

    var _REG_EXP_EVTS = /\mstrAttach\:([\w\,]+)/g;

    /**
     * <p>Used to determine if mouse event handlers should be rendered and if click event handlers should be replaced with touch start event handlers.</p>
     *
     * @default undefined If undefined at run time this value will be calculated (and then cached for performance).
     * @private
     */
    var isTouchEnabled;

    /**
     * Replaces tokens for event handlers in a given markupString with actual
     * event handler markup.
     *
     * @param {String} The HTML template string with event handler tokens.
     * @returns {String} The HTML string with replaced event handler tokens.
     * @private
     */
    function _replEvts(s) {
        // Have we NOT calculated the isTouchEnabled flag?
        if (isTouchEnabled === undefined) {
            // Ask the Application if it is touch enabled (default to false if no application is found).
            isTouchEnabled = (mstrApp !== undefined && mstrApp.isTouchApp && mstrApp.isTouchApp()) || false;
        }

        return s.replace(_REG_EXP_EVTS, function hRepl(token, es) {
            var arr = es.split(","),
                out = [],
                len = arr.length,
                i;

            for (i = 0; i < len; i++) {
                var e = arr[i];
                if (e) {
                    // Is touch enabled for the application.
                    if (isTouchEnabled) {
                        // Is this a mouse event?
                        if (e.indexOf('mouse') > -1) {
                            // Ignore this event because touch has no equivalent.
                            continue;

                        // Is this a click event?
                        } else if (e === 'click') {
                            // Replace click with touchstart.
                            e = 'touchend';
                        }
                    }

                    // Add event handling markup.
                    out.push('on' + e + '="mstrmojo.dom.captureDomEvent(\'{@id}\',\'' + e + '\', self, event)"');
                }
            }
            return out.join(" ");
        });
    }

    var PRE = 'preBuildRendering',
        BUILD = 'buildRendering',
        POST = 'postBuildRendering';

    /**
     * <p>Creates a DOM node (and its descendants) for a given widget from its "markupString" property.</p>
     *
     * <p>The method accomplishes this by creating a (temporary) &lt;span&gt; container, setting its innerHTML,
     * then removing the resulting firstChild from the &lt;span&gt; container.  The innerHTML is set to the
     * Widget's markup string after some modifications (tokens representing dynamic values in HTML are replaced
     * with actual values).</p>
     *
     * @param {Object} widget The widget whose DOM will be built.
     * @returns {HTMLElement} The newly created HTMLElement.
     * @private
     */
    function _build(widget) {

        var s = widget.markupString;
        // Does the markupString template have abbreviated event handler tokens ("mstrAttach")?
        if (s.match(/mstrAttach:/)) {
            // Yes, replace those tokens with unabbreviated markup.
            s = _replEvts(s);
            // Optimization: If the template is used for all class instances...
            if (widget.markupString === widget.constructor.prototype.markupString) {
                // ...update the template for all instances.
                widget.constructor.prototype.markupString = s;
            }
        }
        var html = _S.apply(s, widget);
        if (html) {
            if (mstrmojo.useFrames) {
                // Optimization: only do doc-check if our app is using frames.
                // Otherwise, assume there is only one global doc object for this code's lifespan.
                var doc = (widget.domNode && widget.domNode.ownerDocument) ||
                            self.document;
                if (!_elCreate || _elCreate.ownerDocument !== doc) {
                    _elCreate = doc.createElement('span');
                }
            }
            _elCreate.innerHTML = html;
            var d = _elCreate.firstChild;
            // Drag-drop manager assumes ever widget.domNode has an mstrmojoId expando property.
            d.mstrmojoId = widget.id;
            return d;
        }
        return null;
    }

    /**
     * Calls the given widget's "markupSlots" methods to retrieve the slot nodes for that widget.
     * @returns A hash (Object) of slot nodes, keyed by slot name.
     * @private
     */
    function _callSlots(widget) {
        // Walk the collection of slot setter functions.
        var ms = widget.markupSlots,
            nodes,
            n;

        if (ms) {
            nodes = {};
            for (n in ms) {
                nodes[n] = ms[n].apply(widget, []);
            }
        }
        return nodes;
    }

    /**
     * A mixin for classes that will be represented with markup in the page.
     * @class
     * @public
     */
    mstrmojo._HasMarkup = mstrmojo.provide(
        "mstrmojo._HasMarkup",
        /**
         * @lends mstrmojo._HasMarkup#
         */
        {
            /**
             * String template that specifies the HTML for this Widget's GUI.
             * @type String
             */
            //markupString: null,

            /**
             * <p>Optional hash of methods that will be fired in response to specific events in this widget.</p>
             *
             * <p>This hash is used for reflecting the widget's state in its markup.  The hash is keyed by the events
             * to be monitored (e.g., "on&lt;eventName&gt;"). The hash values are each a Function that will be executed
             * when that event occurs.</p>
             *
             * <p>When a widget is first rendered, all of its markupMethods are called immediately, to initialize its DOM.</p>
             *
             * <p>One exception is the reserved key "sequence". That optional key's value is an array of key names.
             * This array lists the order in which these markupMethods should be fired. If missing, the order is arbitrary.</p>
             *
             * @type Object
             */
            //markupMethods: null,

            /**
             * <p>A hash of named references to nodes in this widget's markup.</p>
             *
             * @type Object
             */
            //markupSlots: null,

            onRender: mstrmojo.emptyFn,

            onUnRender: mstrmojo.emptyFn,

            /**
             * <p>Manages the rendering of this widget's domNode.</p>
             *
             * <p>The method calls "buildRendering", as well as calls to optional "preBuildRendering" and "postBuildRendering" hooks
             * for customization. If any method returns exactly false, aborts the rendering.</p>
             *
             * @return {Boolean} True if the rendering changed.
             */
            render: function rnd() {
                if ((this[PRE] && this[PRE]() === false) || (this[BUILD]() === false) || (this[POST] && this[POST]() === false)) {
                    return false;
                }

                this.hasRendered = !!this.domNode;

                this.onRender();

                // Is anybody listening for the hasRendered event?
                var evtName = 'renderComplete';
                if (mstrmojo.publisher.hasSubs(this.id, evtName)) {
                    // Raise the event.
                    this.raiseEvent({
                        name: evtName
                    });
                }

                return true;
            },


            buildDom: function buildDom() {
                return _build(this);
            },

            preBuildRendering: mstrmojo.emptyFn,

            /**
             * <p>Builds and sets this.domNode.</p>
             *
             * <p>This method will build this.domNode by applying the HTML markup string in this
             * instance's "markupString" property.</p>
             *
             * @return {Boolean} True.
             */
            buildRendering: function bldRnd() {

                // Build a new DOM node according to this Widget's markupString.
                var dnWas = this.domNode,
                    dn = this.buildDom();

                this.domNode = dn;

                // Hook for customizations immediately after markup generation.
                if (this.postBuildDom) {
                    this.postBuildDom();
                }

                // Clear any old slots from previous renderings.
                if (this.slotNames) {
                    this.removeSlots(this.slotNames);
                }
                // Call all the "markupSlots" getters and record the slots found.
                this.addSlots(_callSlots(this));

                // Call all the "markupMethods", to initial state of this Widget's DOM.
                this.paint();

                // Now that the DOM is ready, we can place it in the HTML page.
                if (dn) {
                    // Our placeholder is either the previous "domNode"...
                    var ph = dnWas;
                    if (!ph) {
                        // ..or if we don't have a previous "domNode", use the "placeholder" property.
                        ph = this.placeholder;
                        if (ph) {
                            // If its a string, assume its a node's id.
                            if (typeof ph === 'string') {
                                ph = document.getElementById(ph);
                            }
                            // Clear the placeholder property after it's been used one time.
                            delete this.placeholder;
                        }
                    }
                    if (ph) {
                        _D.replace(ph, dn);
                    }
                }

                // Optimization: Notify your parent (if any) directly that your domNode has
                // changed.  This used to be done indirectly by having the Container parent
                // listen for the "domNodeChange" event but that leads to thousands of events
                // being raised on page load.
                var fn = "onchildRenderingChange",
                    p = this.parent;
                if (p && p[fn]) {
                    p[fn](this);
                }

                return true;
            },

            postBuildRendering: mstrmojo.emptyFn,

            /**
             * <p>Removes this widget's domNode from the document, resets the widget's "domNode" property to null,
             * clears all of its slots (if any), and resets its "hasRendered" to false.</p>
             *
             * <p>If this widget's hasRendered is false, this method does nothing.</p>
             *
             * @param {Boolean} ignoreDom If true we don't need to remove the domNode from the document (meaning, it's being handled
             * by a parent or ancestor).
             */
            unrender: function unrn(ignoreDom) {
                // If the element is in the DOM then we need to remove it.
                if (this.hasRendered) {
                    if (!ignoreDom) {
                        try {
                            var dn = this.domNode;
                            // if the node has a parent then remove it
                            if (dn.parentNode) {
                                dn.parentNode.removeChild(dn);
                            }
                            // if we are running in IE, wipe out the outerHTML to force IE to release memory
                            if (mstrmojo.dom.isIE && dn.outerHTML !== "undefined") {
                                dn.outerHTML = "";
                            }
                        } catch (ex) {
                          //swallow
                        }
                    }
                    this.domNode = null;
                    this.removeSlots(this.slotNames);
                    this.hasRendered = false;

                    this.onUnRender();
                }
            },

            /**
             * <p>Executes all the given widget's markupMethods to initialize state of the widget's DOM.</p>
             *
             * <p>Typically the markupMethods are called in batch only once per rendering, immediately after the widget's domNode
             * is built. Subsequently, markupMethods are called individually in response to events as they occur.  To allow the
             * methods to distinguish between the first (batch) call and subsequent individual calls, a single optional Boolean param is
             * passed into the methods. This param is set to true only during the initial batch call.</p>
             */
            paint: function pnt() {
                var ms = this.markupMethods;
                if (!ms) {
                    return;
                }
                var me = this,
                    callM = function (n) {
                        var f = ms[n];
                        if (f) {
                            try {
                                f.apply(me, [true]);
                            } catch (localerr) {
                                throw new Error([
                                    "Error in markup method.",
                                    "Widget id: " + me.id,
                                    "Method name: " + n,
                                    "Err: " + localerr.message
                                ].join('\n\n'));
                            }
                        }
                    };
                var s = ms.sequence,
                    len,
                    i,
                    n;

                if (s) {
                    len = s.length || 0;
                    for (i = 0; i < len; i++) {
                        callM(s[i]);
                    }
                } else {
                    for (n in ms) {
                        callM(n);
                    }
                }
            },

            /**
             * <p>Forces a re-render of this widget.</p>
             *
             * <p>If this widget is already rendered, this method unrenders and then re renders it;
             * otherwise, does nothing.</p>
             *
             * <p>When refreshing an orphan, this method temporarily sets the previous domNode as the placeholder
             * for the next domNode, and asks the unrender not to remove that placeholder from the document.
             * This not done for children as they rely on slots rather placeholders.</p>
             *
             * @param {Function} [postUnrender] Callback to be notified after the unrender (if any) but before the re-render.
             */
            refresh: function refresh(postUnrender) {
                if (this.hasRendered) {
                    // Cache handle to the domNode even if we are a child of a container; otherwise
                    // we may lose our place within our siblings that share the same slot.
                    var ph = this.domNode;
                    // When unrendering, dont try to remove domNode from HTML; we need it to
                    // stay put so we can replace it with the new domNode after re-rendering.
                    this.unrender(true);
                    this.placeholder = ph;
                    if (postUnrender) {
                        postUnrender();
                    }
                    this.render();
                }
            },

            /**
             * <p>Extends the set() method from _Observable so that it calls the corresponding markup method for the property, thus updating the DOM.</p>
             *
             * <p>This is done regardless of whether or not an event is published corresponding to the change in property value.</p>
             *
             * <p>If a property named "<n>" is changed, the corresponding markupMethod to call is assumed to be named "on<n>Changed".</p>
             *
             * @param {String} n The name of the property whose value is to be set.
             * @param {Number|String|Object} v The new value.
             *
             * @returns {Object} this
             */
            set: function set(n, v) {
                // We must call the super method first to update the property value,
                // because the markup method will assume the property value has been updated.
                this._super(n, v);

                if (this.domNode) {  //was: this.hasRendered, changed it in order to fire this code in mid-rendering cycle
                    // If an event is published, ideally the markup method should be
                    // done before publishing the event to external listeners so that the DOM
                    // response is immediate, but for now that can't be done, because the
                    // superclass method already took care of the publishing.
                    var ms = this.markupMethods,
                        f = ms && ms["on" + n + "Change"];
                    if (f) {
                        f.apply(this);
                    }
                }
                return this;
            },


            /**
             * <p>A hash of names used for DOM node slots.</p>
             *
             * <p>A "slot" is a DOM node in a Widget's rendering which has some special significance. Such a node would be labeled with a special attribute in the Widget's markup string.
             * This mixin will store a reference to each such dom node as a property of this Widget; the property's name is designed by the "mstrSlot"
             * attribute of the DOM node.  This allows javascript convenient access to meaningful nodes in the DOM rendering beyond just the root "domNode".</p>
             *
             * <p>All slot label names that are found in this Widget's DOM are recorded in an internal hash so the references to those nodes can be destroyed
             * later for garbage collection.<p>
             *
             * @type Object
              */
            slotNames: null,

            /**
             * <p>Given a hash of DOM nodes, keyed by slot name, this method sets properties on this widget that point to the DOM nodes.</p>
             *
             * <p>Each property is named after the slot name.  Additionally, each property name is stored in the widget's internal "this.slotNames" hash for future reference.</p>
             *
             * @param {Object} slots A has of slot names to add.
             */
            addSlots: function addSlots(slots) {
                // Initialize internal hashtable of slot names.
                var ns = this.slotNames,
                    n;

                if (!ns) {
                    ns = {};
                    this.slotNames = ns;
                }

                // Add each given slot to our hashtables.
                for (n in slots) {
                    this[n] = slots[n];
                    ns[n] = true;
                }
            },

            /**
             * <p>Given a hashtable of slot names, removes each slot-named property value from this widget.</p>
             *
             * <p>This method also removes the given slot names from the internal hash of used slot names
             * for this widget (this.slotNames).</p>
             *
             * @param {Object} A hash of slot names to remove, keyed by slot name.
             */
            removeSlots: function rmvSlts(slots) {
                if (slots) {
                    var sns = this.slotNames,
                        n;

                    for (n in slots) {
                        delete this[n];
                        if (sns) {
                            delete sns[n];
                        }
                    }
                }
            },

            /**
             * <p>Generic method to wire up DOM events to widget's handlers.</p>
             *
             * <p>This generic method can be called from any DOM handler in the markup.  It acts as a bridge between the
             * markup's native DOM handler and the widget's handler method for that event. This method synthesizes
             * an object representing the event, and raises that event. If DOM provides an event object, that DOM event object is
             * enclosed in the synthesized object, along with an optional config hash of params.</p>
             *
             * <p>Typical usage: a Widget subclass typically implements the preXXX & postXXX methods, but leaves the
             * onXXX method empty, to be specified by the app developer in the config of the Widget instance.</p>
             *
             * <p>Example:</p>
             * <pre>var myButton = new mstrmojo.Button({onclick: function () {alert("Hello world!")});</pre>
             *
             * @param {String} type The name of the DOM event.
             * @param {DOMWindow} hWin The DOM window in which the event originated.
             * @param {DOMEvent} [e] The DOM event object, if provided by the browser.
             * @param {Object} [config] Hash of configuration settings to be passed along to the widget handler.
             */
            captureDomEvent: function cap(type, hWin, e, config) {
                if (this.enabled !== false) {
                    this.raiseEvent({
                        name: type,
                        hWin: hWin,
                        e: e || hWin.event,
                        config: config
                    });
                }
            },

            /**
             * <p> Method to play an effect expressed by a json object on this widget. </p>
             * TO-DO: where would be the best place to locate this?
             */
            playEffect: function playEffect(n) {
                var fx = this[n];
                if (fx && fx.constructor === Object) {
                    fx = mstrmojo.insert(mstrmojo.hash.clone(fx)); //TO-DO: do we really need to make a copy of fx first?
                    fx.widget = this;
                    this[n] = fx;
                }
                if (fx) {
                    fx.play();
                }
            }
        }
    );
}());
(function() {
    
    mstrmojo.requiresCls("mstrmojo.hash");
    
    var $H = mstrmojo.hash;
    
    /**
     * Minxin for editable grid/textfield.
     */
    mstrmojo._CanSupportTransaction = {
            
        _mixinName: "mstrmojo._CanSupportTransaction",
        
        /**
         * A map object storing all the changes.
         * The key that distinguish the grid data row.
         * The value store is an object with three properties: v for new value, r for raw data, and d for domNode of the target field.  
         */
        updatedCellsMap: null,
                        
        /**
         * Returns the update xml string
         */
        getUpdates: mstrmojo.emptyFn, //should be subclassed
        
        /**
         * Returns the update JSON object
         */
        getUpdateObject: mstrmojo.emptyFn, //should be subclassed

        /**
         * Gets the context properties for the given key
         */
        getKeyContext: mstrmojo.emptyFn, //should be subclassed
        
        /**
         * Refresh the data to enable the changes to the data model.
         * It leave the controller to decide whether to call it.
         */
        autoRefresh: mstrmojo.emptyFn, //should be subclassed
        
        /**
         * open the editor on next editable cell/field
         */
        editNext: mstrmojo.emptyFn,
        
        /**
         * Applies the changes once the data is changed with the input editor.
         * @param {String} k Key of the cell 
         * @param {String} r Original value
         * @param {Object} v {dv: display_value, v: value}  Changed value
         * @param {HTMLElement} [d] container DOM object that holds the data
         * @param {Boolean} [invalid] whether the changed value is invalid or not
         */
        dataChanged: function dataChanged(k, r, v, d) {
            //apply the changes, and check whether we should refresh the data
            var autoRefresh = this.updateValue(k, v);
            //add changes into um
            this.updatedCellsMap[k] = {r: r, v: v};
            
            //notify the controller to send update changes to server
            this.controller.onTransactionUpdates(this, this.getUpdateObject(), autoRefresh);
        },
        
        /**
         * Attaches the onclick listener if the show control by default is enabled.
         */
        postBuildRendering: function pstBldRnd() {
            if(this._super) {
                this._super();
            }
            
            if (!this.txModel){
            	this.txModel = this.model.docModel || this.model;
            }
            
            this.updatedCellsMap = this.updatedCellsMap || {};           
        },

        /**
         * Change the value on the data model. It returns a flag indicating whether we should do auto refresh.
         * The function should be subclassed to apply the view changes and returns the auto refresh boolean value. 
         * @returns Boolean True if the widget needs to call autoRefresh once the changes are submitted. 
         */
        updateValue: function(k, v) {
            if(this.txModel.deltaUpdate) {
                this.txModel.deltaUpdate(this);
            }
            return false;
        },

        /**
         * Get the key value pairs of updated fields.
         * @returns {Array} An array of updated key value pair.
         */
        getUpdatedValues: function() {
            var um = this.updatedCellsMap,
                i, u, vs = [];
            for(i in um) {
                if(um.hasOwnProperty(i)) {
                    u = {};
                    u.v = um[i].v.v;
                    vs.push($H.copy(this.getKeyContext(i), u));
                }
            }
            return vs;
        },        
        
        /**
         * Clear recorded updated fields
         */
        clear: function() {
            this.updatedCellsMap = {};
        },
        
        /**
         * Register the transactable widgets to its ancestor panelstacks
         */
        registerTxWidget: function(){
            function fnRegisterOnPS(w, ps){
                var k = w.node.data.k;
                ps.txWidgets = ps.txWidgets || {};
                ps.txWidgets[k] = w;
                return false;
            }

            var p = this.parent;
            while (p){
                if (p.isPanelStack === true){
                    // register the textfield/xtab to its ancestor panel stacks.
                    fnRegisterOnPS(this, p);
                }
                p = p.parent;
            }
        }
    };
}());

(function(){

    mstrmojo.requiresCls("mstrmojo.hash");
    
    mstrmojo.requiresDescs(3852,3853,3854,3855,3856,3857,3858,3859,3860,3861,3862,3863,
    		1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,
    		9379,9380,9381,9382,9383,9384,9385,
    		6078,7899,7900,7901,6079,6081,6080,6082,7902,7902,6076,6077,7903);
    
    /**
     * A utility class to load locale specific information from web server. 
     * 
     * @class
     */
    mstrmojo.locales = mstrmojo.provide(
        "mstrmojo.locales",
            /**
             * @lends mstrmojo.locales
             */
            {
                /**
                 * Load locale specific information and callback if succeeded. 
                 */
        	    load: function(callback){
                    var me = this;
                    if (this.isLoaded) {
                        callback();
                    } else {
                        mstrmojo.xhr.request('POST', mstrConfig.taskURL, 
                        {
                            success: function(res) {
                                //copy result
                                mstrmojo.hash.copy(mstrmojo.hash.obj2array(res), me);
                                
                                callback();
                                if (mstrmojo.expr) {
                                    mstrmojo.expr.onLocaleUpdated();
                                }
                                mstrmojo.locales.isLoaded = true;
                                
                            },
                            failure: function(res) {
                                alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));//can not use mstrmojo.alert because mstrmojo.Dialog may not be loaded yet.
                            }
                        },
                        // no parameter, load current user's all locale related info 
                        {
                            taskId: 'getLocaleInfo'
                        });
                    }            
                },
                
                isLoaded: false,
                
                "datetime": {
                    "MONTHNAME_SHORT": [
                        mstrmojo.desc(3852, "Jan"),
                        mstrmojo.desc(3853, "Feb"),
                        mstrmojo.desc(3854, "Mar"),
                        mstrmojo.desc(3855, "Apr"),
                        mstrmojo.desc(3856, "May"),
                        mstrmojo.desc(3857, "Jun"),
                        mstrmojo.desc(3858, "Jul"),
                        mstrmojo.desc(3859, "Aug"),
                        mstrmojo.desc(3860, "Sep"),
                        mstrmojo.desc(3861, "Oct"),
                        mstrmojo.desc(3862, "Nov"),
                        mstrmojo.desc(3863, "Dec")
                    ],
                    "MONTHNAME_FULL": [
                        mstrmojo.desc(1956, "January"),
                        mstrmojo.desc(1957, "February"),
                        mstrmojo.desc(1958, "March"),
                        mstrmojo.desc(1959, "April"),
                        mstrmojo.desc(1960, "May"),
                        mstrmojo.desc(1961, "June"),
                        mstrmojo.desc(1962, "July"),
                        mstrmojo.desc(1963, "August"),
                        mstrmojo.desc(1964, "September"),
                        mstrmojo.desc(1965, "October"),
                        mstrmojo.desc(1966, "November"),
                        mstrmojo.desc(1967, "December")
                    ],
                    "dayShortNames": [
                        "S",
                        "M",
                        "T",
                        "W",
                        "T",
                        "F",
                        "S"
                    ],
                    "dayNames": [
                        mstrmojo.desc(9379, "Sunday"),
                        mstrmojo.desc(9380, "Monday"),
                        mstrmojo.desc(9381, "Tuesday"),
                        mstrmojo.desc(9382, "Wednesday"),
                        mstrmojo.desc(9383, "Thursday"),
                        mstrmojo.desc(9384, "Friday"),
                        mstrmojo.desc(9385, "Saturday")
                    ],
                    "DATEINPUTFORMATS": [
                        "M/d/yy",
                        "M/d/yyyy",
                        "MMM d, yy"
                    ],
                    "TIMEINPUTFORMATS": [
                        "h:mm a",
                        "H:mm",
                        "h:mm:ss a",
                        "H:mm:ss",
                        "h:mm:ss a z"
                    ],
                    "DATEOUTPUTFORMAT": "M/d/yyyy",
                    "TIMEOUTPUTFORMAT": "h:mm:ss a",
                    "AM_NAME": "AM",
                    "PM_NAME": "PM",
                    "TWODIGITYEARSTART": "2029"
                },
                "number": {
                    "NUMBERINPUTFORMATS": {
                        "0": "#,##0.###"
                    },
                    "INTEGERINPUTFORMATS": {
                        "0": "#,##0"
                    },
                    "NUMBEROUTPUTFORMAT": "#0.##########",
                    "INTEGEROUTPUTFORMAT": "#0",
                    "DECIMALSEPARATOR": ".",
                    "THOUSANDSEPARATOR": ","
                },
                "expression": {
                    "METRICVALIDATIONLEVEL": "0",
                    "PRESERVEWHITESPACE": false,
                    "Include": [
                        {
                            "did": "1",
                            "n": "Include"
                        },
                        {
                            "did": "2",
                            "n": "Exclude"
                        }
                    ],
                    "BranchQual": [
                        {
                            "did": "19",
                            "n": "AND"
                        },
                        {
                            "did": "20",
                            "n": "OR"
                        },
                        {
                            "did": "21",
                            "n": "NOT"
                        },
                        {
                            "did": "19_21",
                            "n": "AND NOT"
                        },
                        {
                            "did": "20_21",
                            "n": "OR NOT"
                        }
                    ],
                    "RootOperator": [
                        {
                            "did": "19",
                            "n": "All selections"
                        },
                        {
                            "did": "20",
                            "n": "Any selection"
                        }
                    ],
                    "ExprType": [
                        {
                            "did": "2",
                            "n": "Qualify"
                        },
                        {
                            "did": "5",
                            "n": "Select"
                        }
                    ],
                    "DimtyLevels": [
                        {
                            "did": "1",
                            "n": "Default"
                        },
                        {
                            "did": "2",
                            "n": "Metric"
                        },
                        {
                            "did": "3",
                            "n": "Report"
                        }
                    ],
                    "Attribute": [
                        {
                            "did": "1,6",
                            "n": "Equals",
                            "t": 1
                        },
                        {
                            "did": "1,7",
                            "n": "Does not equal",
                            "t": 1
                        },
                        {
                            "did": "1,8",
                            "n": "Greater than",
                            "t": 1
                        },
                        {
                            "did": "1,10",
                            "n": "Greater than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,9",
                            "n": "Less than",
                            "t": 1
                        },
                        {
                            "did": "1,11",
                            "n": "Less than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,17",
                            "n": "Between",
                            "t": 1
                        },
                        {
                            "did": "1,44",
                            "n": "Not between",
                            "t": 1
                        },
                        {
                            "did": "1,76",
                            "n": "Contains",
                            "t": 1
                        },
                        {
                            "did": "1,79",
                            "n": "Does not contain",
                            "t": 1
                        },
                        {
                            "did": "1,77",
                            "n": "Begins with",
                            "t": 1
                        },
                        {
                            "did": "1,80",
                            "n": "Does not begin with",
                            "t": 1
                        },
                        {
                            "did": "1,78",
                            "n": "Ends with",
                            "t": 1
                        },
                        {
                            "did": "1,81",
                            "n": "Does not end with",
                            "t": 1
                        },
                        {
                            "did": "1,18",
                            "n": "Like",
                            "t": 1
                        },
                        {
                            "did": "1,43",
                            "n": "Not Like",
                            "t": 1
                        },
                        {
                            "did": "1,54",
                            "n": "Is Null",
                            "t": 1
                        },
                        {
                            "did": "1,55",
                            "n": "Is Not Null",
                            "t": 1
                        },
                        {
                            "did": "1,22",
                            "n": "In",
                            "t": 1
                        },
                        {
                            "did": "1,57",
                            "n": "Not In",
                            "t": 1
                        }
                    ],
                    "Metric": [
                        {
                            "did": "1,6",
                            "n": "Equals",
                            "t": 1
                        },
                        {
                            "did": "1,7",
                            "n": "Does not equal",
                            "t": 1
                        },
                        {
                            "did": "1,8",
                            "n": "Greater than",
                            "t": 1
                        },
                        {
                            "did": "1,10",
                            "n": "Greater than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,9",
                            "n": "Less than",
                            "t": 1
                        },
                        {
                            "did": "1,11",
                            "n": "Less than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,17",
                            "n": "Between",
                            "t": 1
                        },
                        {
                            "did": "1,44",
                            "n": "Not between",
                            "t": 1
                        },
                        {
                            "did": "1,54",
                            "n": "Is Null",
                            "t": 1
                        },
                        {
                            "did": "1,55",
                            "n": "Is Not Null",
                            "t": 1
                        },
                        {
                            "did": "1,22",
                            "n": "In",
                            "t": 1
                        },
                        {
                            "did": "1,57",
                            "n": "Not In",
                            "t": 1
                        },
                        {
                            "did": "2,1",
                            "n": "Highest",
                            "t": 2
                        },
                        {
                            "did": "2,2",
                            "n": "Lowest",
                            "t": 2
                        },
                        {
                            "did": "3,1",
                            "n": "Highest%",
                            "t": 3
                        },
                        {
                            "did": "3,2",
                            "n": "Lowest%",
                            "t": 3
                        }
                    ],
                    "MDXAttribute": [
                        {
                            "did": "1,6",
                            "n": "Equals",
                            "t": 1
                        },
                        {
                            "did": "1,7",
                            "n": "Does not equal",
                            "t": 1
                        },
                        {
                            "did": "1,8",
                            "n": "Greater than",
                            "t": 1
                        },
                        {
                            "did": "1,10",
                            "n": "Greater than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,9",
                            "n": "Less than",
                            "t": 1
                        },
                        {
                            "did": "1,11",
                            "n": "Less than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,17",
                            "n": "Between",
                            "t": 1
                        },
                        {
                            "did": "1,44",
                            "n": "Not between",
                            "t": 1
                        },
                        {
                            "did": "1,22",
                            "n": "In",
                            "t": 1
                        },
                        {
                            "did": "1,57",
                            "n": "Not In",
                            "t": 1
                        }
                    ],
                    "MDXMetric": [
                        {
                            "did": "1,6",
                            "n": "Equals",
                            "t": 1
                        },
                        {
                            "did": "1,7",
                            "n": "Does not equal",
                            "t": 1
                        },
                        {
                            "did": "1,8",
                            "n": "Greater than",
                            "t": 1
                        },
                        {
                            "did": "1,10",
                            "n": "Greater than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,9",
                            "n": "Less than",
                            "t": 1
                        },
                        {
                            "did": "1,11",
                            "n": "Less than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,17",
                            "n": "Between",
                            "t": 1
                        }
                    ],
                    "SAPAttribute": [
                        {
                            "did": "1,6",
                            "n": "Equals",
                            "t": 1
                        },
                        {
                            "did": "1,7",
                            "n": "Does not equal",
                            "t": 1
                        },
                        {
                            "did": "1,22",
                            "n": "In",
                            "t": 1
                        },
                        {
                            "did": "1,57",
                            "n": "Not In",
                            "t": 1
                        },
                        {
                            "did": "1,8",
                            "n": "Greater than",
                            "t": 1
                        },
                        {
                            "did": "1,10",
                            "n": "Greater than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,9",
                            "n": "Less than",
                            "t": 1
                        },
                        {
                            "did": "1,11",
                            "n": "Less than or equal to",
                            "t": 1
                        },
                        {
                            "did": "1,17",
                            "n": "Between",
                            "t": 1
                        }
                    ],
                    "Element": [
                        {
                            "did": "1,22",
                            "n": "In List",
                            "t": 1
                        },
                        {
                            "did": "1,57",
                            "n": "Not In List",
                            "t": 1
                        }
                    ]
                },
                "validation": {
                        "requiredFieldError": mstrmojo.desc(6078, "This field is required."),
                        "invalidCharError": mstrmojo.desc(7899, "This field contains invalid characters for #."),
                        "invalidDateStringError": mstrmojo.desc(7900, "This field contains invalid date/time string."),
                        "invalidNumericFormatError": mstrmojo.desc(7901, "This field contains numeric value with incorrect format."),
                        "outofRangeError": mstrmojo.desc(6079, "This field should be # between ## and ###."),
                        "noLessMinError": mstrmojo.desc(6081,  "This field should be # greater than or equal to ##."),
                        "noGreaterMaxError": mstrmojo.desc(6080, "This field should be # less than or equal to ###."),
                        "failRegexTestError": mstrmojo.desc(6082, "This field failed regular expression validation."),
                        "invalidValueInListError": mstrmojo.desc(7902, "One of the value (#) in this list is not valid."),
                        "integerDataType": mstrmojo.desc(6076, "an Integer value"),
                        "numericDataType": mstrmojo.desc(6077, "a Number value"),
                        "dateDataType": mstrmojo.desc(7903, "a Date/Time value")    
                },
                'color':{
                    'colors':[{'n':'Black','v':'#000000'},{'n':'Brown','v':'#993300'},{'n':'Olive Green','v':'#333300'},{'n':'Dark Green','v':'#003300'},{'n':'Dark Teal','v':'#003366'},{'n':'Dark Blue','v':'#000080'},{'n':'Indigo','v':'#333399'},{'n':'Grey-80%','v':'#333333'},{'n':'Dark Red','v':'#800000'},{'n':'Orange','v':'#FF6600'},{'n':'Dark Yellow','v':'#808000'},{'n':'Green','v':'#008000'},{'n':'Teal','v':'#008080'},{'n':'Blue','v':'#0000FF'},{'n':'Blue-Grey','v':'#666699'},{'n':'Grey-50%','v':'#808080'},{'n':'Red','v':'#FF0000'},{'n':'Light Orange','v':'#FF9900'},{'n':'Lime','v':'#99CC00'},{'n':'Sea Green','v':'#339966'},{'n':'Aqua','v':'#33CCCC'},{'n':'Light Blue','v':'#3366FF'},{'n':'Violet','v':'#800080'},{'n':'Grey-40%','v':'#969696'},{'n':'Pink','v':'#FF00FF'},{'n':'Gold','v':'#FFCC00'},{'n':'Yellow','v':'#FFFF00'},{'n':'Bright Green','v':'#00FF00'},{'n':'Turquoise','v':'#00FFFF'},{'n':'Sky Blue','v':'#00CCFF'},{'n':'Plum','v':'#993366'},{'n':'Grey-25%','v':'#C0C0C0'},{'n':'Rose','v':'#FF99CC'},{'n':'Tan','v':'#FFCC99'},{'n':'Light Yellow','v':'#FFFF99'},{'n':'Light Green','v':'#CCFFCC'},{'n':'Light Turquoise','v':'#CCFFFF'},{'n':'Pale Blue','v':'#99CCFF'},{'n':'Lavender','v':'#CC99FF'},{'n':'White','v':'#ffffff'}],
                    'userPalette':[{'n':'#F00E0E','v':'#F00E0E'},{'n':'#080000','v':'#080000'},{'n':'#E81A1A','v':'#E81A1A'},{'n':'#6E0909','v':'#6E0909'},{'n':'#4F2828','v':'#4F2828'},{'n':'#141212','v':'#141212'},{'n':'#D60202','v':'#D60202'},{'n':'#C40404','v':'#C40404'}]
                }
                                
        	}
        );
})();
(function(){
	mstrmojo.requiresCls("mstrmojo.hash");
	
    var reCHAIN_THIS = /this\.([\w\.\[\]\'\"\-]+)/m,
        reCHAIN_THIS_TEST = /this\./m,
        reCHAIN_ALL_BRACKET = /mstrmojo\.all\[[\'\"]([\w]+)[\'\"]\]\.([\w\.\[\]\'\"\-]+)/m,
        reCHAIN_ALL_BRACKET_TEST = /mstrmojo\.all\[/m,
        reCHAIN_ALL_DOT = /mstrmojo\.all\.([\w]+)\.([\w\.\[\]\'\"\-]+)/m,
        reCHAIN_ALL_DOT_TEST = /mstrmojo\.all\./m,
        reCvtIdxs = /\[(\d+)\]/g,
        reCvtSingleQts = /\[\'([\w\-]+)\'\]/g,
        reCvtDblQts = /\[\"([\w\-]+)\"\]/g,
        reTruncBrkts = /([\[\]].*)/;

    mstrmojo.Binding = mstrmojo.declare(
        // superclass
        null,
        // mixins
        null,
        // instance members
        {
			scriptClass: "mstrmojo.Binding",
			
            /**
             * Reference to the context object whose property is the destination of this Binding.
             */
            parent: null,
            
            /**
             * String|Function. Javascript to be evaluated to determine a value for this Binding's destination.
             * The script will be evaluated in the context of the Binding's parent.
             */
            source: null,
            
            /**
             * String. Name of the property whose value will be determined by this Binding.
             */
            destination: null,

            /**
             * Records whether or not the binding is attached.
             */
            enabled: false,
            
            /**
             * Optional config for a setter function to set the destination's value. If null, no setter is used; the
             * destination is set directly (e.g., parent[destination] = value). If String, specifies the name of a method
             * of the parent object, which will serve as the setter. If Function, specifies a setter function which will be
             * applied in the parent's context to set the destination.
             */
            setter: "set",
            
            /**
             * <p>Indicates whether or not this binding is currently updating the bound destination.</p>
             *
             * <p>This flag is set to a positive integer while this binding is executing; otherwise it is zero.
             * The specific number is the total count
             * of calls to this.exec() which are currently executing; this count can be > 1 if the binding is designed to
             * cause its own trigger, either directly or indirectly, in a cyclical manner.</p>
             * @type Integer
             */
            executing: 0,
                        
            init: function init(/*Object?*/ props) {
                // Apply the given properties to this instance.
                mstrmojo.hash.copy(props, this);
                
                // Then add ourselves to the registry, so we can be called back by events later.
                mstrmojo.registry.add(this);
            },

            destroy: function dest(){
                // Remove any event communication involving this object (faster than calling disable).
                mstrmojo.publisher.clearSubscriptions(this.id);
                // Remove ourselves from registry.                
                mstrmojo.registry.remove(this);
            },
                        
            /**
             * Executes the source script and stores the resulting value in the destination.
             */
            exec: function exec(){
                this.executing++;
                // Retrieve the source script as a Function object (cache it for later re-use).
                var fn = this._sourceFn;
                if (!fn) {
                    var s = this.source;
                    if (s != null) {
                        if (typeof(s) == "string") {
                            // TO DO: add a "return " at the beginning of the string if all conditions are met:
                            // [1] it has no "return ", and
                            // [2] if there is a semicolon, it is not followed by any chars except possibly blankspace chars.
                            if (!(s.match("return ")) && !(s.match(/\;\s*\S/))) {
                                s = "return " + s;
                            }
                            fn = new Function(s);
                        } else if (typeof(s) == "function") {
                            fn = s;
                        }
                        this._sourceFn = fn;
                    }
                }
                
                // If we have a source script Function, call it to calculate a value. 
                var v, p = this.parent;
                if (fn) {
                    try {
                        v = fn.apply(p, []);
                    } catch(ex) {
                        // Bad binding script. Result value will be undefined.
                    }
                }        
                
                // Update the destination with the new value.
                var st = this.setter,
                    d = this.destination;
                if (st == null) {
                    p[d] = v;
                } else if (typeof(st) == "string") {
                    p[st](d, v);
                } else if (typeof(st) == "function") {
                    st.apply(p, [d,v]);
                }
                this.executing--;
            },
                        
            /**
             * Starts up the binding by executing the source script, updating the destination's value,
             * and attach event listeners for changes in the source's result value.
             */
            enable: function en() {
                if (!this.enabled) {        
                    // Update the destination's value.
                    this.exec();        
                    // Parse the source script, if we haven't already.
                    var chs = this._chains;
                    if (!chs) {
                        this._parseChains();
                        chs = this._chains;
                    }
                    // Attach event listeners to expressions within the source script.
                    for (var k in chs) {
                        this._attachChain(chs[k]);
                    }
                    this.enabled = true;
                }
            },
            
            /**
             * Stops the binding by detaching event listeners for changes in the source's result value.
             */
            disable: function dis() {
                if (this.enabled) {
                    // Detach event listeners, if any.
                    var chs = this._chains;
                    if (chs) {
                        for (var k in chs) {
                            this._detachChain(chs[k]);
                        }                
                    }        
                    this.enabled = false;        
                }
            },

            /**
             * Internal cache of results from parsing the source script.
             */
            _chains: null,

            /**
             * Parses the source script, searching for "chains" of objects that we should attach event listeners to.
             * Examples of a chain:  "this.foo.bar", "mstrmojo.all['foo'].bar.get(..)".
             */
            _parseChains: function() {
                // Init cache.
                this._chains = {};
                var chains = this._chains;

                // Fetch source script as a string.
                var s = this.source;
                if (s && (typeof(s) == "function")) {
                    s = s.toString && s.toString();
                }
                if (!s) {
                    return;
                }
                
                // Helper method for using regular expression to find matches and storing results in cache.
                function _findMatches(/*String*/ str, /*RegExp*/ re, /*Integer*/ hostIdx, /*Integer*/ partsIdx) {
                    var sTemp = str,
                        match;
                
                    while (match = sTemp.match(re)) {    // Note: this is an assignment ("=") and null-check, NOT an equals test ("==")
                        // Found a match.
                        var key = match[0],
                            len = key.length,
                            add = true;
                        
                        // Replace "[##]" with ".#", ['XX'] with .XX, ["XX"] with .XX
                        // Then truncate any remaining bracketed substring.
                        key = key.replace(reCvtIdxs, ".$1"
                                    ).replace(reCvtSingleQts, ".$1"
                                    ).replace(reCvtDblQts, ".$1"
                                    ).replace(reTruncBrkts, '');
                        
                        // Is this match redundant?
                        for (var k in chains) {
                            if (k.substr(0, len) === key) {
                                // The match is a subset of a previous match; skip it.
                                add = false;
                                break;
                            } else if (key.indexOf(k) === 0) {
                                // The match is a superset of a previous match; drop the previous match.
                                delete chains[k];
                            }
                        }
                        if (add) {
                            chains[key] = {
                                host: (hostIdx == null) ? null : match[hostIdx],
                                parts: match[partsIdx].replace(reCvtIdxs, ".$1"
                                        ).replace(reCvtSingleQts, ".$1"
                                        ).replace(reCvtDblQts, ".$1"
                                        ).replace(reTruncBrkts, '').split('.')
                            };
                        }
                        sTemp = sTemp.substr(match.index + len);
                    }
                }                
                
                /*
                We only recognize chains with specific syntax:
                    a) "this.<parts>"
                        where <parts> has only periods and word chars (alphanumerics+underscore). So, not allowed: "(" ,")",":", commas, blanks, etc.
                        Note: We don't check for double-periods ("this.foo..bar"), but of course that will result in a run-time err when exec() is called anyway.
                        Note: We DO allow <parts> to have square brackets ONLY like this "[##]", to support arrays, or like this ['..'] and [".."] to support hyphenated property names.
                */
                if (reCHAIN_THIS_TEST.test(s)) {
                    _findMatches(s, reCHAIN_THIS, null, 1);
                }
                
                /*
                Or in the following syntax:
                    b) "mstrmojo.all['<host>'].<parts>", or
                    c) "mstrmojo.all["<host>"].<parts>"
                        where <host> has only word chars (alphanumerics+underscore).
                */
                if (reCHAIN_ALL_BRACKET_TEST.test(s)) {
                    _findMatches(s, reCHAIN_ALL_BRACKET, 1, 2);
                }
                /* Or in the following syntax:
                	d) "mstrmojo.all.<host>.<parts>"
                		where <host> has only word chars.
                */
                if (reCHAIN_ALL_DOT_TEST.test(s)) {
                    _findMatches(s, reCHAIN_ALL_DOT, 1, 2);
                }
            },

            /**
             * Attaches event listeners to the objects along a given "chain".  The "chain" is an object in this._chains
             * hashtable, which was generated by _parseChains. Optional start index can be given; if missing, 0 is assumed.
             */
             _attachChain: function attCh(/*Object*/ ch, /*Integer?*/ start) {
    
                // Init lookups, if needed.
                 if (!ch.evt2idx) {
                     ch.evt2idx = {};
                 }
                 if (!ch.idx2evt) {
                     ch.idx2evt = [];
                 }
                 var evt2idx = ch.evt2idx,
                     idx2evt = ch.idx2evt,
                     parts = ch.parts;
    
                 // Init starting index, context and property.
                 var idx = (start >= 0) ? start : 0,
                     bId = this.id,
                     reg = mstrmojo.all,
                     ctxt = (start > 0) ?
                                 reg[idx2evt[idx-1].context][parts[idx-1]] :
                                 (ch.host ? reg[ch.host] : this.parent), 
                     prop = parts[idx];
                     
                // Walk the chain...
                var A = mstrmojo.array;                 
                 while (ctxt && prop) {
                     if (ctxt.attachEventListener) {
                         // What events should we listen for?
                         var evts = ctxt[prop+"_bindEvents"] || (prop+"Change");
                         if (typeof(evts) == "string") {
                             evts = [evts];
                         }
                         var subs = [];
                         for (var i = 0, iLen = evts.length; i< iLen; i++) {                           
                             subs[i] = ctxt.attachEventListener(evts[i], bId, "_callback");
                         }
                         
                         // Update the map from event to index.
                         for (var i=0; i<evts.length; i++) {
                             evt2idx[ ctxt.id+"_"+evts[i] ] = idx;
                         }
                         
                         // Update the map from index to event.
                         idx2evt[idx] = {context: ctxt.id, evts: evts, subs: subs};
                     }
                     // Continue to the next item on the chain...
                     ctxt = ctxt[prop];
                     prop = ch.parts[++idx];
                 }
             },
             
            /**
             * Detaches event listeners from the objects along a given "chain".  The "chain" is an object in this._chains
             * hashtable, which was generated by _parseChains. Optional start index can be given; if missing, 0 is assumed.
             */
            _detachChain: function detCh(/*Object*/ ch, /*Integer?*/ start) {

                 var reg = mstrmojo.all,
                     idx2evt = ch.idx2evt,
                     evt2idx = ch.evt2idx,
                     bId = this.id;
    
                 var i = (start > -1) ? start : 0,
                     len = idx2evt.length;
                 if (i < len) {
                     for (; i<len; i++) {
                          
                         var atts = idx2evt[i];
                         if (!atts) {
                             break;
                         }
                         var ctxtid = atts.context,
                             ctxt = reg[ctxtid],
                             evts = atts.evts;
                             
                         // Stop listening for events in this outdated context.
                         if (ctxt && ctxt.detachEventListener) {
                             var s = atts.subs;                                
                             for(var t = 0, tLen = s.length; t < tLen; t++) {                                
                                 ctxt.detachEventListener(s[t]);
                             }
                         }
                         // Update the map from index to event.
                         idx2evt[i] = null;
                         // Update the map from event to index.
                         for (var j=0, jLen=evts.length; j<jLen; j++) {
                             delete evt2idx[ctxtid+"_"+evts[j]];
                         }
                     }
                 }
            },
            
            /**
             * Notifies the Binding that the destination's value needs to be refreshed.  Also responsible for determining
             * whether or not event listeners need to be detached and re-attached.
             */
            _callback: function clbk(/*Event*/ evt) {
                
                // Update the destination's value.
                this.exec();
                
                /*
                // For debugging only:
                var n = evt && evt.name, 
                    cbs = window.cbs;
                if (!cbs) cbs = window.cbs = {};
                
                if (cbs[n]) {
                    cbs[n]++;
                } else {
                    cbs[n] = 1;
                }
                */
                    
                if (!evt || !evt.name || !evt.src) {
                    return;
                }
                
                // Do we have any chains that require updating when this event is heard?
                var k = evt.src.id+"_"+evt.name,
                    chains = this._chains;
                // For each chain...
                for (var c in chains) {
                    // Does this event.src+evt.name combination map to an index in this chain?
                    var ch = chains[c],
                        idx = ch.evt2idx[k];
                    if (idx != null) {
                        // Yes, this chain needs to be detached & re-attached.
                        this._detachChain(ch, idx+1);
                        this._attachChain(ch, idx+1);
                    }
                }

            }
                                    
        }
    );

})();
(function () {
    mstrmojo.requiresCls("mstrmojo.hash");

    var $H = mstrmojo.hash,
        dicPopup = null;
    
    //Internal function to initialize a DIC widget inside the DIC group
    //o: config object
    function _createDICInGroup(o){
        return mstrmojo.DICFactory.createDIC(
                $H.copy({dic: this.dic, owner: this.owner, group: this}, o));
    }
    
    /**
     * <p> A utility factory for creating platform independent data input controls and popup instances. </p> 
     */
    mstrmojo.DICFactory = mstrmojo.provide(
        "mstrmojo.DICFactory",
        {
            /**
             * Creates an instance of data input control object.
             * @param {Object} o The configure object
             * @param {Object} o.dic Data input control configure object
             * @param {Widget} o.opener The opener of the data input control
             * @param {Object} o.value The raw value
             * @param {Object} o.dv the display value
             * @param {String} [o.k] The key from opener to identify the control widget
             * @param {HTMLElement} [o.openerNode] The opener node 
             * @param {Object} [o.props] Other properties initilializing widget 
             * Example dic info
             * {
             *   t: 1,
             *   dm: 1,
             *   wm: 0,
             *   w: 12,
             *   ml: 256,
             *   min: 10,
             *   max: 100,
             *   itv: 10,
             *   vls: [{v: 10}, {v: 20}]
             * }
             * @returns {Object} data input control instance
             */
            createDIC: function(o) {
                var dic = o.dic,
                    Cls = mstrmojo.DICConfig.getDICClass(dic),
                    w; 
                if(Cls) {
                    //if we don't have a key for the dic, we set its opener's id as its key
                    if (o.k === undefined){
                        o.k = o.opener && o.opener.id;
                    }
                    
                    //populate values of the following two properties 
                    o.showByDefault = mstrmojo.DICConfig.showDICByDefault(o.dic, o.openerType);
                    o.hasPreview = mstrmojo.DICConfig.hasDICPreview(o.dic, o.openerType);
                    
                    w = new Cls(o);
                }
                
                return w;
            },
                        
            /**
             * Creates popup instance for data input controls.   
             * @param opener {Object} either xtab or textfield
             * @param dic {Object} the dic widget
             * @returns {Object} Popup instances
             */
            createDICPopup: function(opener, dic) {
                return mstrmojo.DICPopup.getInstance(opener, dic);
            },

            /**
             * Creates a data input control group object for a given group configure object.
             * @param {Object} gco Group configure object.
             * @param {String} gco.gk Group key.
             * @param {Object} gco.dic Data input configure object.
             * @param {Object} gco.opener The owner of the group widget.
             * @returns {mstrmojo.Widget} The instance of a DICGroup widget. 
             */
            createDICGroup: function(gco) {
                var dicGroup = $H.copy(gco, {
                    
                        scriptClass: "mstrmojo.Widget",
                    
                        /**
                         * Widgets map object
                         */
                        widgetsMap: {},
                        
                        /**
                         * Data input configure object
                         */
                        dic: null,
                        
                        /**
                         * The opener (owner) of the DICGroup object (mstrmojo.EditableXtab or mstrmojo.EditabTextfield)
                         */
                        owner: null,
                        
                        /**
                         * The collection of individual DIC configure objects. The configure object is used to create DIC instance
                         */
                        groupMembers: {},

                        postCreate: function(){
                            var dic = this.dic, otp = this.openerType, DC = mstrmojo.DICConfig;
                            this.showByDefault = DC.showDICByDefault(dic, otp);
                            this.hasPreview = DC.hasDICPreview(dic, otp);
                        },
                        
                        /**
                         * Save the DIC config object. 
                         * @param k The unique key of DIC in the group
                         * @param o DIC config
                         */
                        addDIC: function addDIC(k, o) {
                            this.groupMembers[k] = o;
                        },
                        
                        /**
                         * Initialize and render the popup DIC specified by the key.
                         * @param k The unique key of DIC in the group
                         */
                        showPopupDIC: function showPopupDIC(k){
                            if (!this.showByDefault){
                                var w = this.widgetsMap[k],
                                    o = this.groupMembers[k];
                                
                                if (!o){
                                    return;
                                }
                                
                                // if the widget is not initialized yet, create it
                                if (!w){
                                    w = this.widgetsMap[k] = _createDICInGroup.call(this, o);
//                                    o.hasRendered = true; // this is actually not needed
                                }
                                
                                // ask widget to render itself inside the popup
                                w.showInPopup();
                            }
                        },
                        
                        /**
                         * Initialize and render all the inline DIC widgets.
                         */
                        render: function render() {
                            // if the dic is shown by default or it has a "preview" for the popup, render it. 
                            if (this.showByDefault || this.hasPreview){ 
                                var gms = this.groupMembers, me = this, dicWidget;

                                $H.forEach(gms, function (go, k) {
                                    if (!go.hasRendered){
                                        me.widgetsMap[k] = dicWidget = _createDICInGroup.call(me, go);
                                        
                                        // if the dic widget is shown by default, render it and then use it to replace the openerNode 
                                        if (me.showByDefault){
                                            dicWidget.render();
                                        // if the dic widget has preview for the popup, replace the content of openerNode with the preview
                                        }else if (me.hasPreview){
                                            dicWidget.renderPreview();
                                        }
                                        //mark as 'rendered' so that it won't be rendered again
                                        go.hasRendered = true;
                                    }
                                });
                            }
                        },
                        
                        destroy: function destroy() {
                            $H.forEach(this.widgetsMap, function (w) {
                                w.destroy();
                            });
                            this.widgetsMap = {};
                        }
                    });
                
                return mstrmojo.insert(dicGroup);
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.hash");
    
    /**
     * This mixin provides methods for opening and closing a popup widget.
     * 
     * @class
     * @public
     */
    mstrmojo._HasPopup =
    /**
     * @lends mstrmojo._HasPopup#
     */
    {
        
        /**
         * <p>Opens a popup, applying a given (optional) config hashtable of properties.</p>
         * 
         * <p>A reference to the popup is provided, which may be either the ID of a widget, a config for a widget, or a handle to a widget.
         * The widget is assumed to implement the _IsPopup API.</p>
         * 
         * @param {String|Object|Widget} ref
         * @param {Object} [config]
         */
        openPopup: function opP(/*String|Object|Widget*/ ref, /*Object?*/ config) {
            // If the given ref is a string with no periods, it is a property name which
            // holds the popup config.
            var isProp = !!ref && (typeof(ref) === "string") && !ref.match(/\./) && !!this[ref],
                // Resolve the reference to the popup.
                p = mstrmojo.registry.ref(isProp ? this[ref] : ref, true);

            // Did the ref resolve to an object with an open method?
            if (p && p.open) {
                // Dont cache popup handle in this._popup because this widget might support
                // multiple popups.  If we want caching, we have to supply a property name for the ref.
                // The resolve reference to the popup will be cached there.
                if (isProp) {
                    this[ref] = p;
                }
                //push into the disposables array so that the popup would be destroyed when the host widget being destroyed
                this.disposables.push(p);
                // If the popup has a slot, insert the child into the slot.
                var s = p.slot && this[p.slot];
                if (s) {
                    if (p.parent !== this) {
                        // The popup is not our child already.
                        if (this.addChildren) {
                            // We are a container, so add the popup as our child.
                            // That will ensure that its DOM gets inserted into our slot.
                            this.addChildren(p);
                        } else {
                            // We are not a container, so instead just manually insert the popup's
                            // domNode into our slot.  If the popup has no domNode yet, create a placeholder
                            // node for it in our slot.
                            // Warning: Don't call appendChild if the domNode is already in this slot; it
                            // causes repaint issues, such as resetting scrollTop = 0.
                            var skipCheck = false,
                                el = p.domNode || p.placeholder;
                            if (el && typeof(el) === 'string') {
                                el = document.getElementById(el);
                            }
                            if (!el) {
                                skipCheck = true;
                                el = document.createElement('span');
                                p.placeholder = el;                                
                            }
                            if (skipCheck || (el.parentNode !== s)) {
                                s.appendChild(el);
                            }
                        }
                    }
                }
                p.open(this, config);
                this._lastOpened = p;
            }
        },
        
        /**
         * Closes the currently open popup, if any.
         */
        closePopup: function clP() {
            var p = this._lastOpened;
            if (p && p.visible && p.close) {
                p.close();
                delete this._lastOpened;
            }
        }
    };

})();
(function () {
    mstrmojo.requiresCls("mstrmojo.css",
                         "mstrmojo.hash",
                         "mstrmojo.string",
                         "mstrmojo.DICFactory");

    var TX_ELEM_TEXTFIELD = 3,
//        EDIT_ACTION = 32,
//        TEXTAREA = 8,
        FIELDGROUP = 2,
        DATA_DRIVEN_CONTROL = 2,
        $CSS = mstrmojo.css,
        MASK = '********',
        $H = mstrmojo.hash;

    var tf_formatHandlers = null;

    /**
     * Set the dirty flag on the given DOM node by placing a div node (containing the dirty cell flag) in.
     * 
     * @param {HTMLElement} c The given DOM node for setting the dirty flag.
     * @param {HTMLElement} d The container DOM node. 
     */
    function setDirtyFlag(c, d) {
        if (c) {
            // Do we have a dicWidget AND does it have a setDirtyFlag method?
            var dicWidget = this.dicWidget;
            if (dicWidget && dicWidget.setDirtyFlag) {
                // Ask dicWidget to mark as dirty.
                dicWidget.setDirtyFlag(c, d);

            // Is the flag not already present?
            } else if (c.className !== 'flag-container') {
                var f = document.createElement('div');
                f.className = 'flag-container';
                f.style.right = '10px';
                f.innerHTML = '<div class="dirty-cell"/>';
                d.insertBefore(f, c);
            }
        }
    }

    /**
     * <p>A mixin for displaying editable text field. The data input controller is dynamically 
     * associated with the text field according to the text field data type. </p>
     * 
     * <p>The data input widget will get displayed as embedded widget when the show control by default is set to be true.
     * If the show control by default is false, the data input widget will get display as popup widget when user clicks on it. 
     * </p>
     */
    mstrmojo._IsEditableTextfield = {
        _mixinName: "mstrmojo._IsEditableTextfield",

        preBuildRendering: function preBldRnd() {
            if (!this.edb) {
                var d = this.node.data,
                    defn = this.node.defn,
                    di = d.dic || defn.txi.dic,
                    rv = (this.rv === '') ? this.value : this.rv; //TQMS 499163: use the display value if the raw value is empty for static text field.

                //if we configure a password mask for the DIC
                if (di.psw) {
                    this.v = MASK;
                    rv = this.rv = '';
                }

                if (di.ipt === DATA_DRIVEN_CONTROL) {
                    di.vls = this.vls || []; // for the data input control is data driven, assign the vls values from data protion.
                    this.dk = di.k;
                }

                this.req = di.req;
                this.dt = di.dt;

                this.dicWidget = mstrmojo.DICFactory.createDIC({dic: di, owner: this, k: 0, dv: this.value, value: rv, openerType: FIELDGROUP, popupTitle: defn.n});

                if (this.shouldReplaceValueNode()) {
                    //cache the formatHandlers since they are class level property
                    if (!tf_formatHandlers) {
                        tf_formatHandlers = $H.clone(this.formatHandlers);
                    }

                    this.formatHandlers.domNode = ['T', 'z-index', 'D', 'B', 'F', 'P', 'text-align', 'background-color', 'fx', 'white-space', 'overflow'];
                    //do not have value node anymore from the DocTextField class, delete it
                    delete this.formatHandlers.valueNode;
                }
            }

            this.set('cssClass', this.edb ? '' : 'editable-field');

            this._super();
        },

        shouldReplaceValueNode: function shouldReplaceValueNode() {
            return this.dicWidget.showByDefault || this.dicWidget.hasPreview;
        },

        postBuildRendering: function pstBldRnd() {
            this._super();

            if (this.edb) {
                return;
            }

            var w = this.dicWidget,
                text = this.valueNode.innerHTML;

            // TQMS 497975: Editable textfield should not be shrunk if it contains empty string.
            if (mstrmojo.string.isEmpty(text)) {
                this.valueNode.innerHTML = text + '1';
                this.valueNode.style.height = this.valueNode.clientHeight + 'px';
                this.valueNode.innerHTML = text;
            }

            if (w.showByDefault) {
                w.render();
            } else {
                if (w.hasPreview) {
                    // need to replace the value node
                    w.openerNode = this.domNode;
                    //TQMS 503967: While rendering the datetime picker for the first time, we need to use the display value.
                    w.renderPreview(this.value);
                } else {
                    w.openerNode = this.valueNode;
                }

                mstrmojo.dom.attachEvent(w.openerNode, mstrApp.isMobile ? mstrmojo.dom.TOUCHEND : 'click', function () {
                    w.showInPopup();
                });
            }

            //if inline control, we restore the format handlers
            if (this.shouldReplaceValueNode()) {
                $H.copy(tf_formatHandlers, this.formatHandlers);
            }

            this.registerTxWidget();

            // populate a list for the purpose of tab navigation.
            this.addToTraversalList();

            if (this.mdf && this.sci) {
                var domNode = this.domNode;
                setDirtyFlag.call(this, domNode.firstChild, domNode);
            }
        },

        getKeyContext: function getKeyContext() {
            return {
                dt: this.dt || 0,
                k: this.dk || undefined
            };
        },

        getUpdates: function getUpdates() {
            var udv = this.getUpdatedValues()[0],
                k = udv.k ? ('rw_control_key="' + udv.k + '" element_id="' + this.vls[mstrmojo.array.find(this.vls, 'v', udv.v)].eid + '" ') : '';
            return '<rwf rw_tree_type="' + this.tt + '" rw_node_key="' + this.fgk + '" rw_field_key="' + this.k + '" key="' + this.key + '" columns="' + this.cls + '" types="' + TX_ELEM_TEXTFIELD + '" ' + k + 'value="' + mstrmojo.string.encodeXMLAttribute(String(udv.v)) + '" dt="' + udv.dt + '" />';
        },

        updateValue: function updateValue(idx, vo) {
            if (this._super) {
                this._super(idx, vo);
            }

            var t = this.valueNode,
                d = this.domNode,
                w = this.dicWidget,
                v = vo.v,
                dv = vo.dv;

            if (this.rv !== v) {
                if (this.req) {
                    $CSS.removeClass(d, 'required');
                }

                this.rv = v;
                this.v = dv;
                this.mdf = 1;

                if (!w.showByDefault) {
                    if (w.hasPreview) {
                        w.renderPreview();
                    } else {
                        t[t.innerText !== undefined ? 'innerText' : 'textContent'] = this.psw ? MASK : dv;
                    }
                }

                if (this.req) {
                    $CSS.removeClass(d, 'required');
                }

                if (this.sci) {
                    setDirtyFlag.call(this, d.firstChild, d);
                }
            }

            //return whether we need to do auto-refresh
            //as textfield will never do auto-refresh, we always return false here
            return false;
        },

        applyPasswordMask: function applyPasswordMask() {
            this.psw = true;
            this.v = MASK;
            this.rv = '';
        },

        /**
         * Returns the update JSON object for task call
         */
        getUpdateObject: function getUpdateObject() {
            var changedObj = {
                    fieldKey: this.k,
                    wid: this.wid, //to be changed
                    newValue: mstrmojo.string.encodeXMLAttribute(String(this.rv)),
                    dataType: this.dt
                },
                udv = this.getUpdatedValues()[0];

            if (udv.k !== undefined) {
                changedObj.controlKey = udv.k;
                changedObj.elementId = this.vls[mstrmojo.array.find(this.vls, 'v', udv.v)].eid;
            }

            return {
                nodeKey: this.fgk,
                cells: [changedObj],
                retrieveData: false, //for web task
                //TQMS 610777: auto-recalculation is always false for fields on FG.
                autoRefresh: false
            };
        },

        update: function update(node) {
            if (this._super) {
                this._super(node);
            }
            var d = node.data,
                df = node.defn;

            if (d.vls) {
                this.vls = d.vls;
            } else {
                delete this.vls;
            }

            this.cell = node.data;
            //set the value
            this.value = d.v || '';
            //add raw data
            this.rv = (d.rv === undefined) ? this.value : d.rv;
            this.tca = d.tca || 0;
            this.dt = d.dt;
            this.key = d.key || ''; // in Android, we do not really use the value, so set it to be empty string
            this.cls = d.cls || ''; // the same reason above
            this.wid = d.wid;

            this.edb = d.edb;

            //modified?
            this.mdf = d.mdf;
            this.req = d.req;

            //show indicator
            this.sci = df.txi.sci;
            this.tt = df.tt;
            this.fgk = df.fgk;
        },

        /**
         * If the field contains an input control that could be navigated to, we put the field with its dimension info to the list on its parent(panel).
         */
        addToTraversalList: function addToTraversalList() {
            if (mstrmojo.DICConfig.isKeyNavigable(this.dicWidget.dic)) {
                var traversalList = this.parent.traversalList,
                    dom = this.domNode;

                if (!traversalList) {
                    traversalList = this.parent.traversalList = [];
                }

                traversalList.push({
                    x: dom.offsetLeft,
                    y: dom.offsetTop,
                    h: dom.offsetHeight,
                    refField: this
                });
            }
        },

        /**
         * Advance to the next editable cell and open the editor.
         * @return {boolean} true if we found the next field to be edited.
         */
        editNext: function editNext() {
            var traversalList = this.parent.traversalList,
                i,
                len,
                avgHeight,
                sumHeight = 0;

            if (!traversalList) {
                return false;
            }

            // Sort the list when needed. 
            if (!traversalList.isSorted) {

                // calculate the average field height and use it as the row height
                for (i = 0, len = traversalList.length; i < len; i++) {
                    sumHeight += traversalList[i].h;
                }
                avgHeight = sumHeight / len;

                // the traversal order should be row by row. And from left to right on each row.
                traversalList.sort(function (a, b) {
                    // find which row they are on
                    var r1 = Math.floor(a.y / avgHeight),
                        r2 = Math.floor(b.y / avgHeight);

                    if (r1 < r2) { // the smaller row number appears first
                        return -1;
                    }

                    if (r1 > r2) {
                        return 1;
                    }

                    if (a.x < b.x) { // the smaller left coordinate appears first
                        return -1;
                    }

                    if (a.x > b.x) {
                        return 1;
                    }

                    return (a.y < b.y) ? -1 : 1; // the smaller top corrdinate appears first
                });
                // remember this to avoid duplicated sorting
                traversalList.isSorted = true;
            }

            // find the current field
            for (i = 0, len = traversalList.length; i < len; i++) {
                if (traversalList[i].refField.k === this.k) {
                    break;
                }
            }

            if (i < len) {
                do {
                    i++;
                    if (i >= len) {
                        i %= len;
                    }
                    if (i === parseInt(this.k, 10)) {
                        return false;
                    }

                    // find the associated input control 
                    var dicWidget = traversalList[i].refField.dicWidget;
                    if (dicWidget) {
                        if (!dicWidget.showByDefault) {
                            dicWidget.showInPopup();
                        } else {
                            // the navigable IC should always be focusable.
                            dicWidget.focus();
                        }
                        return true;
                    }
                } while (true);
            }
            // It should never reach here.
        },

        /**
         * Validate the textfield itself
         * @return {Boolean} false if the field is required but no modified
         */
        checkRequiredObjects: function checkRequiredObjects() {
            // if required and not modified and enabled editing, return false 
            if (this.req && !this.mdf && !this.edb) {
                $CSS.addClass(this.domNode, 'required');
                return false;
            }
            return true;
        }
    };
}());
(function(){
 
    mstrmojo.requiresCls("mstrmojo.locales", "mstrmojo.string");
    
    var _L = mstrmojo.locales,
        _S = mstrmojo.string,
        _G = window.mstrConfig,
        // Now thousand/decimal separator info is retrieved from the mstrmojo.locales which may be updated dynamically.
        // For example, android app may connect to multiple projects with different locales, mstrmojo.locales will get 
        // updated while user switches among those projects.
        getThousand = function(){ return mstrmojo.locales.number.THOUSANDSEPARATOR;},
        getDecimal = function(){ return mstrmojo.locales.number.DECIMALSEPARATOR;}, 
        _unit = _G.units,
        UNIT = {
            CM: 1,
            IN: 2,
            MM: 3,
            PT: 4,
            PC: 5,
            PX: 6
        },
        CAT = {
            DEFAULT: -2,
            FIXED: 0,
            CURR: 1,
            PERCENT: 4,
            FRACTION : 5,
            SCIENTIFIC: 6,
            GENERAL: 9
        };
  
    
    var DPI_CONVERSION = 96;
    
    String.prototype.reverse = function() {
        var res = "";
        for (var i = this.length; i > 0; --i) {
            res += this.charAt(i - 1);
        }
        return res;
    };    
    
    
    /**
     * mstrmojo.num is a utility class that provides utility functions related to numbers, such as number parsing/formatting. 
     */
    mstrmojo.num = mstrmojo.provide(
            "mstrmojo.num",
            {
                /** 
                 * Check whether a string is an integer in current locale. 
                 * Note that it is different from built-in isNaN function which does not consider locale.  
                 * @param {String} v The string to check against. 
                 */
                isInt: function isInt(v){
                    var thousand = getThousand(),
                        INT_THOUSAND = new RegExp('^(\-)?[0-9]{1,3}(\\' + thousand + '[0-9]{3})*$'),
                        INT_NO_THOUSAND = new RegExp('^(\-)?[0-9]+$');
                    
                    return (String(v).indexOf(thousand) && INT_THOUSAND.test(v)) || INT_NO_THOUSAND.test(v);
                }, 
                
                /**
                 * Check whether a string is a numeric in current locale. 
                 * Note that it is different from built-in isNaN function which does not consider locale.
                 * @param {String} v The string to check against.
                 * @param {Boolean} noDG A flag indicating whether we want to check against too many decimal. 
                 */
                isNumeric: function isNumeric(v,noDG){
                    //TO-DO: need to consider percentage input?                       
                   var decimal = getDecimal(),
                       thousand = getThousand(),
                       NUMERIC_THOUSAND = new RegExp('^(\-)?[0-9]{1,3}(\\' + thousand + '[0-9]{3})*(\\' + decimal + '[0-9]+)?$'),
                       NUMERIC_NO_THOUSAND = new RegExp('^(\-)?[0-9]*(\\' + decimal + ')?[0-9]+$');
                   
                   return (String(v).indexOf(thousand) && NUMERIC_THOUSAND.test(v)) || NUMERIC_NO_THOUSAND.test(v);
                },
                
                /**
                 * A locale-aware version of built-in parseInt function. 
                 * @param {String} v The string to be parsed.
                 * @param {Integer} r The radix, if not specified, 10.
                 */
                parseInteger: function parseInteger(v, r){
                    if(!this.isInt(v)) return Number.NaN;
                    return parseInt(String(v).replace(getThousand(), ''),r);
                },
                
                /**
                 * A locale-aware version of built-in parseFloat function. 
                 * @param {String} v The string to be parsed.
                 */
                parseNumeric: function parseNumeric(v){
                    //TO-DO: need to consider percentage input? 
                    if(!this.isNumeric(v)) return Number.NaN;
                    return parseFloat(String(v).replace(getThousand(),'').replace(getDecimal(), '.'));
                },
                
                /**
                 * Compares a given non-null value with a minimum and maximum. If the value is below the minimum, returns -1.
                 * If the value is above the maximum, returns 1.  Otherwise, returns 0. 
                 * @param {String} v The string to compare.
                 * @param {String} min The minimum value.
                 * @param {String} max The maximum value. 
                 */   
                inNumericRange: function inNumericRange(v,min,max){
                    v = this.parseNumeric(v);
                    max = (max != null) ? this.parseNumeric(String(max)) : Number.NaN;
                    min = (min != null) ? this.parseNumeric(String(min)) : Number.NaN;   
                    if(max != Number.NaN && (v > max || isNaN(v))) return 1;
                    if(min != Number.NaN && (v < min || isNaN(v))) return -1;
                    return 0;
                },
                
                
                /**
                 * <p>Convert a given measurements at given units to US inches.</p>
                 * @param {Integer/String} value Measurement to be converted
                 * @param {Integer} unit Unit code of this given measurement.
                 * @param {Boolean} doNotLocalize Flag to indicate whether to localize the converted value format.
                 * @return {String} Localized value in inches
                 */
                convertToUSUnits: function(value, unit, doNotLocalize) {
                        var __result = value;

                        unit = unit || _unit; //if not provided, use the one in mstrApp.
                        switch (parseInt(unit, 10)) {
                            case UNIT.CM:
                                __result = parseFloat(this.toString(value)) / 2.54 + '';
                                break;
                            case UNIT.MM:
                                __result = parseFloat(this.toString(value)) / 25.4 + '';
                                break;
                            case UNIT.PT:
                                __result = parseFloat(this.toString(value)) / 72 + '';
                                break;
                            case UNIT.PC:
                                __result = parseFloat(this.toString(value)) / 6 + '';
                                break;
                            case UNIT.PX:
                                __result = parseFloat(this.toString(value)) / DPI_CONVERSION + '';
                                break;
                        }
                        
                        return doNotLocalize ? __result : this.toLocaleString(__result);
                    },
                    
                    /**
                     * <p>Convert a given measurements in inches to local units.</p>
                     * @param {Integer/String} value Measurement to be converted
                     * @param {Integer} unit Unit code of this given measurement.
                     * @param {Boolean} doNotLocalize Flag to indicate whether to localize the converted value format.
                     * @return {String} Localized value in inches
                     */
                    convertToLocalUnits: function(value, unit, doNotLocalize) {
                        var __result;

                        unit = unit || _unit; //if not provided, use the one in mstrApp.
                        switch (parseInt(unit, 10)) {
                        case  UNIT.CM:
                            __result = (parseFloat(this.toString(value)) * 2.5400).toFixed(4) + '';
                            break;
                        case UNIT.MM :
                            __result = (parseFloat(this.toString(value)) * 25.4000).toFixed(4) + '';
                            break;
                        case UNIT.PT:
                            __result = (parseFloat(this.toString(value)) * 72.0000).toFixed(4) + '';
                            break;
                        case UNIT.PC:
                            __result = (parseFloat(this.toString(value)) * 6.0000).toFixed(4) + '';
                            break;
                        case UNIT.PX:
                            __result = (parseFloat(this.toString(value)) * DPI_CONVERSION) + '';
                            break;
                        default:
                            __result = parseFloat(this.toString(value)).toFixed(4) + '';
                        }
                        
                        return doNotLocalize ? __result : this.toLocaleString(__result);
                    },

                    /**
                     * <p>Convert measurement from one unit to another <p>
                     * @param {Integer} unitFrom 
                     * @param {Integer} unitTo
                     * @param {Integer/String} value
                     * @return {String} value string in 'To' unit
                     */
                    convertUnits: function(unitFrom, unitTo, value) {
                        return this.convertToLocalUnits(unitTo, this.convertToUSUnits(unitFrom, value, true), true);
                    },
                    
                    /**
                     * <p>returns the localized string representation of a double value.</p> 
                     */
                    toLocaleString: function(value) {
                        return (value + '').replace(".", getDecimal());
                    },
                    
                    /**
                     * <p>returns the string representation of a double value.</p> 
                     */
                    toString: function(value, removeThousandsSeparator) {
                        if (removeThousandsSeparator === true) {
                            var regex = this.getThousandSepRegex();
                            if (regex) {
                             value = String(value).replace(regex,'');
                            }     
                         }
                        return String(value).replace(getDecimal(), ".");
                    },

                    getThousandSepRegex: function() {
                        if (this.thousandSeparatorRegex == null) {
                              this.thousandSeparatorRegex = new RegExp(getThousand().replace(/(\W){1}/g,'\\$1'), 'g');
                        }
                        return this.thousandSeparatorRegex;
                    },
                    
                    /**
                     * Add thousand separator to the integer string
                     * @param {String} val Integer string
                     */
                    addSeparators: function(val, ts) {
                        var _ts = ts;
                        if (ts == '.' || ts == '*' || ts == '\\') { _ts = '\\' + ts;}
                        return val.reverse().replace(/(\d{3})/g, "$1" + ts).reverse().replace(new RegExp('^(-)?'+ _ts), "$1");
                    },
                    
                    /**
                     * <p>Format a number using category and decimal places<p>
                     * @param {EnumGridFormatNumberCategory} category 
                     * @param {Integer} decimalPlaces Decimal places
                     * @param {Integer/String} nm Input number
                     * @param {String} curr Currency symbol
                     * @return {String} formatted value string 
                     */
                    format: function(category, decimalPlaces, curr, nm){
                        var pattern = '',
                        ds = (decimalPlaces > 0)? '.' : '',
                        zeros = [];
                        
                        curr = (curr)? curr: '';
                        
                        for (var i = 0; i < decimalPlaces; i ++) {zeros.push('0');}
                        zeros = zeros.join('');
                        
                        switch(category){
                        case CAT.PERCENT:
                            pattern = '0' + ds + zeros + '%';
                            break;
                        case CAT.SCIENTIFIC:
                            pattern = '0' + ds +zeros + 'E+00';
                            break;
                        default: 
                            pattern = '"' + curr + '"' + '#,##0' + ds +zeros;
                        }
                        return this.formatByMask(pattern, nm);
                    },
                    
                    /**
                     * <p>Format a number using format mask/pattern<p>
                     * @param {String} formatMask Format Mask pattern
                     * @param {Integer/String} nm Input number
                     * @return {String} formatted value string 
                     */
                    formatByMask: function(formatMask,nm){
                        var ptns = String(formatMask).split(';'),
                        result = '',
                        pattern = ptns[0],
                        ph = '\u00A4';
                        
                        if(isNaN(nm)){
                            return nm;
                         }
                        
                        var ePos = pattern.indexOf("E+"),
                            pPos = pattern.indexOf("%"),
                            cs = pattern.match(/\".*\"/),
                            fs = pattern.indexOf("?/?") > -1,
                            cat = (ePos != -1)? CAT.SCIENTIFIC : ( (pPos != -1)? CAT.PERCENT : ((cs)? CAT.CURR : fs ? CAT.FRACTION : CAT.FIXED)),
                            currMask = '',
                            negMask = '',
                            isNeg = false,
                            sNm = new String(nm),
                            nN = parseFloat(nm);
                        
                        //Currency Mask
                        if(cs) {
                            currMask = pattern.replace(/\".*\"/, 
                                    cs[0].substring(1, cs[0].length -1)).replace(pattern.replace(cs[0], ''), ph);
                        }
                        
                        //Negative Mask
                        if(nN<0){
                            sNm = sNm.substring(1, sNm.length);
                            nN = -nN,
                            isNeg = true;
                            if (ptns.length > 1) { 
                                var _ptns1 = ptns[1].replace(/\[.*\]/, ''); //remove color
                                negMask = _ptns1.replace(ptns[0], ph); 
                            }
                        }
                       
                       //Negative
                       var negativeFormat = function(sNm, negMask) {
                           return (negMask)? negMask.replace(ph, sNm) :  '-' + sNm;
                       };
                       
                       if (cat == CAT.FRACTION) {
                           var i, 
                               j, 
                               minIndex, 
                               base = 10, 
                               output, 
                               intPart = 0,
                               v, 
                               currentMin, 
                               temp,
                               sepInt = false,
                               stemp;
                           
                           // do we need to show separate integer part
                           if (formatMask.indexOf("# ") > -1){
                               sepInt = true;
                           }
                           
                           // what is the base
                           for (i=5; i>0; i--){
                               stemp = "/";
                               for (j=0; j<i; j++){
                                   stemp +="?";
                               }
                               if (formatMask.indexOf(stemp) > -1){
                                   for (j=1;j<i;j++){
                                       base *= 10;
                                   }
                                   break;
                               }
                           }

                           if (sepInt){
                               intPart =  Number(Number(nN).toFixed(0));
                               nN -= intPart;
                           }

                           currentMin = base / 2;
                           minIndex = -1;
                           v = nN * base;
                           for (i = base; i>=2; i--){
                               temp = (v * i) / base;
                               temp = temp - Math.floor(temp);
                               temp = temp * base;

                               if (Math.abs(temp - base) < temp){
                                   temp = Math.abs(temp - base);
                               }
                               
                               temp = temp / i;
                               
                               if (temp < currentMin){
                                   currentMin = temp;
                                   minIndex = i;
                               }
                               else if ((temp == currentMin) && (temp == 0)){
                                   currentMin = temp;
                                   minIndex = i;
                               }
                           }

                           output = Math.round(minIndex * v / base);

                           for (i = minIndex; i>=2; i--){
                               if ((output % i == 0) && (minIndex % i == 0)){
                                   output = output / i;
                                   minIndex = minIndex / i;
                                   break;
                               }
                           }

                           if (minIndex == base){
                               minIndex = 1;
                               output = 0;
                           }
                           if (output == 0){
                               minIndex = 1;
                           }
                           if (output == minIndex){
                               if (sepInt){
                                   result = "" + (intPart + 1);
                               }else{
                                   result = "1";
                               }
                           }else if (sepInt && intPart >0){
                               result = intPart + " " + output + "/" + minIndex;
                           }else{
                               result = output + "/" + minIndex;
                           }
                           
                       }else if (cat == CAT.SCIENTIFIC) {//Scientific
                           
                           var exp = Math.floor(Math.log(nN) / Math.LN10),
                           m = nN / Math.pow(10, exp),
                           beStr = pattern.substring(0, ePos),
                           dPos = beStr.indexOf('.');
                           
                           result += Number(m).toFixed((dPos != -1)? beStr.length - dPos - 1 : 0);
                           result = ((isNeg) ? negativeFormat(result, negMask) : result )+ 'E' + ((exp > 0)? '+': '') + exp;
                           
                       } else {
                           if(cat == CAT.PERCENT) {//Percentage
                               pattern=pattern.substring(0,pattern.length - 1);
                               sNm= String(nN * 100);
                           }
                           
                         //tofixed
                           var dPos = pattern.indexOf('.'),//pattern alwasy use '.' as decimal separator no matter what locales is.
                           dp = 0;
                           if (dPos != -1) {
                               var dpS = pattern.substr(dPos + 1 , pattern.length).match(/\d+/);
                               if (dpS && dpS.length > 0) {
                                   dp = dpS[0].length;
                               }
                           }
                           
                           result =  String(Number(parseFloat(sNm).toFixed(dp)));
                           
                           var nn = result.split('.');
                           
                           //Add thousands seperator
                           var tsPos = pattern.match(/#.+##/);
                           if (tsPos !== null) {
                               nn[0] =  this.addSeparators(nn[0], getThousand());
                           }
                               
                            result =  nn.join(getDecimal());
                            
                           //Add Currency symbol
                           if (cat == CAT.CURR) { result = currMask.replace(ph, result); }//Currency
                           
                           //Add Percentage symbol
                           if (cat == CAT.PERCENT) { result += '%'; }//Percentage
                           
                           //Add negative mask
                           if (isNeg) {  
                               result = negativeFormat(result, negMask);
                           }
                       }
                       
                       return result;
                    },
                    
                    /**
                     * generates unique ID of specified length
                     * @param {Integer} keyLen number of digits to return
                     * @returns string of hex digits
                     * @type String
                     */
                    
                     generateUniqueID: function( keyLen ) {
                        var     chars="0123456789ABCDEF".split(''),
                                id = [];                        
                        for (var i = 0; i < keyLen; i++) {
                            id[i] = chars[0 | Math.random()*16];
                        }
                        return id.join('');
                     },
                     /**
                      * Returns the number of digits after decimal point. 
                      * This can be used to solve float number problem. 
                      * For example, 6 * 0.05 = 3.0000000000000004.
                      * but if you do this (6*0.05).toFixed(mstrmojo.num.countOfDecimals(0.05)), it will return 3.00
                      */
                     countOfDecimals: function(v, decimalSep) {
                    	 var sV = String(v);
                    	 return sV.length - (sV.indexOf(decimalSep !== undefined? decimalSep : getDecimal()) + 1); // when index = -1, index + 1 = 0
                     }         
            });

 })();
(function(){
 
    mstrmojo.requiresCls("mstrmojo.locales");
    
    var _DT = function(){return mstrmojo.locales.datetime;},
        $S = mstrmojo.string;

    /**
     * mstrmojo.date is a utility class that provides utility functions related to date/time, such as date parsing/formatting. 
     */
    mstrmojo.date = mstrmojo.provide(
            "mstrmojo.date",
            {
    			monthNumbers : {
					Jan:1,
					Feb:2,
					Mar:3,
					Apr:4,
					May:5,
					Jun:6,
					Jul:7,
					Aug:8,
					Sep:9,
					Oct:10,
					Nov:11,
					Dec:12
				},
				
                REGEXPS: {
                    DATES: {},  // To store regular expressions built from date formats.
                    TIMES: {}   // To store regular expressions built from time formats.
                },
                
                CACHE: {
                    PARSEDATE: {
                        CONTAINS: {},
                        EQUALS: {}
                    },
                    PARSETIME: {
                        CONTAINS: {},
                        EQUALS: {}
                    }
                }, 
                
                /**
                 * Validation method for dates.  Returns true if the given string matches one of MSTR Web's input patterns (or
                 * output pattern) for dates.
                 * If bFormat, the method returns a converted String if there is a match; null otherwise.
                 * Else if bFormat is false, the method instead just returns true|false depending on whether there is a match.
                 * If the optional Boolean param "bContains" is true, then
                 * a string which contains a valid date substring will be considered valid; otherwise
                 * only a string which equals a valid date string will be considered valid.
                */
                isDate: function isDate(/*String*/ s, /*Boolean?*/ bFormat, /*Boolean?*/ bContains) {
                    // Try parsing the string according to our acceptable patterns.
                    var dateInfo = this.parseDate(s, bContains);
                    // If parsing succeeded, and the numbers are in the right range, validation successful.
                    var isValid = !!(dateInfo && this.doesDateExist(dateInfo.month, dateInfo.day, dateInfo.year));
                    if (bFormat) {
                        if (isValid) {
                            var formatted = this.formatDateInfo(dateInfo, _DT().DATEOUTPUTFORMAT);
                            if (bContains) {
                                return {match: dateInfo.match, formatted: formatted};
                            } else {
                                return formatted;
                            }
                        } else {
                            return null;
                        }
            
                    } else {
                        return !!isValid;
                    }
                },
                
                /**
                 * This method applies a format String to a dateInfo object to produce a formatted date String.
                 * The given dateInfo object is assumed to have the following properties:  "month" (1-12),
                 * "day" (Integer), "year" (four digit Integer).  The format String is typically the out format
                 * specified by MSTRWeb server.  In theory, this method should handle any such format String,
                 * but to optimize this implementation, we make certain assumptions about the format String, namely:
                 * the string may contain: "MMMM", "MMM", "MM", "M", "dd", "d", "yyyy", "yy"; all other chars
                 * are taken as literals.
                 */
                formatDateInfo: function formatDateInfo(/*Object*/ dateInfo, /*String*/ format) {
                    if (!format) return '';
                    var day = dateInfo.day,
                        month = dateInfo.month,
                        year = dateInfo.year;
                    
                    var s = format.replace(/dd/g, this.formatInteger(day, 2)
                                    ).replace(/d/g, Number(day)
                                    ).replace(/yyyy/g, Number(year)
                                    ).replace(/yy/g, this.formatInteger(Number(year) % 100, 2)
                                    ).replace(/MMM/g, "~~~~"
                                    ).replace(/MM/g, "@@"
                                    ).replace(/M/g, "^"
                                    ).replace(/MMMM/g, _DT().MONTHNAME_FULL[Number(month) - 1]
                                    ).replace(/\~\~\~\~/g, _DT().MONTHNAME_SHORT[Number(month) - 1]
                                    ).replace(/\@\@/g, this.formatInteger(month, 2)
                                    ).replace(/\^/g, Number(dateInfo.month)
                                    );
                    return s;
                },
                
                
                /**
                 * Parses a given date string to determine the month, day and year values
                 * it represents.  If the optional Boolean param "bContains" is true, then
                 * a string which contains a valid date substring will be considered valid; otherwise
                 * only a string which equals a valid date string will be considered valid.
                 */
                parseDate: function parseDate(/*String*/ s, /*Boolean?*/ bContains, /*String?*/ format) {
                    if (s == null) return false;
                    if (typeof(s) != 'string') s = String(s);
                    s = $S.trim(s);
                    
                    // Check our cache.  The cache is a hashtable; hash key = the given string (trimmed);
                    // hash value = the parse result object (if date found) or a null (if date not found).
                    var cache = this.CACHE.PARSEDATE[bContains ? "CONTAINS" : "EQUALS"],
                        cachedResult = cache[s];
                    if (cachedResult || (cachedResult === null)) return cachedResult;       
                    // Cached result not found.  Must parse date and store parsing result in cache.
                    var parseResult = null;
            
                    // Build an array of all acceptable date formats.
                    var formats;
                    if (format){
                    	formats = [format];
                    }else{
                    	formats = [].concat(_DT().DATEINPUTFORMATS);
                    	formats.unshift(_DT().DATEOUTPUTFORMAT);
                    }
            
                    // Now compare the given string to each acceptable format.
                    for (var i = 0, len = formats.length; i < len; i++) {       
                        // Convert the format to a regular expression for javascript comparison.    
                        var reInfo = this._buildRegExp4DateFormat(formats[i]),
                        // Does the given string match the regular expression?
                            result = reInfo && s.match(bContains ? reInfo.reContains : reInfo.reEquals);
                        if (result) {
                            // Yes, matched. Fetch parts: month, day and year.
                            parseResult = {
                                match: result[0],
                                year: reInfo.yearIndex && this.fourDigitYear(result[reInfo.yearIndex]),
                                day: reInfo.dayIndex && parseInt(Number(result[reInfo.dayIndex])),
                                month: reInfo.monthIndex && this.numericMonth(result[reInfo.monthIndex])
                            };
                            break;
                        }
                    } // end for loop walking the acceptable formats
                    // Store parse result in cache for later re-use.
                    cache[s] = parseResult;
                    return parseResult;
                },
            
                /**
                 * Validation method for times.  Returns true if the given string matches one of MSTR Web's input patterns (or
                 * output pattern) for times.
                 * If bFormat, the method returns a converted String if there is a match; null otherwise.
                 * Else if bFormat is false, the method instead just returns true|false depending on whether there is a match.
                 * If the optional Boolean param "bContains" is true, then
                 * a string which contains a valid time substring will be considered valid; otherwise
                 * only a string which equals a valid time string will be considered valid.
                 */
                isTime: function isTime(/*String*/ s, /*Boolean?*/ bFormat, /*Boolean?*/ bContains) {
                    // Try parsing the string according to our acceptable patterns.
                    var timeInfo = this.parseTime(s, bContains);
                    // If parsing succeeded, and the numbers are in the right range, validation successful.
                    var isValid = !!(timeInfo && this.doesTimeExist(timeInfo.hour, timeInfo.min, timeInfo.sec));
                    if (bFormat) {
                        if (isValid) {
                            var formatted = this.formatTimeInfo(timeInfo, _DT().TIMEOUTPUTFORMAT);
                            if (bContains) {
                                return {match: timeInfo.match, formatted: formatted};
                            } else {
                                return formatted;
                            }
                        } else {
                            return null;
                        }
                    } else {
                        return !!isValid;
                    }
                },
                
                /**
                 * Parses a given time string to determine the hour, minute and second values
                 * it represents.  If the optional Boolean param "bContains" is true, then
                 * a string which contains a valid time substring will be considered valid; otherwise
                 * only a string which equals a valid time string will be considered valid.
                 */
                parseTime: function parseTime(/*String*/ s, /*Boolean?*/ bContains, /*String?*/format) {
                    if (s == null) return false;
                    if (typeof(s) != 'string') s = String(s);
                    s = $S.trim(s);
                    
                    // Check our cache.  The cache is a hashtable; hash key = the given string (trimmed);
                    // hash value = the parse result object (if date found) or a null (if date not found).
                    var cache = this.CACHE.PARSETIME[bContains ? "CONTAINS" : "EQUALS"],
                        cachedResult = cache[s];
                    if (cachedResult || (cachedResult === null)) return cachedResult;       
                    // Cached result not found.  Must parse date and store parsing result in cache.
                    var parseResult = null;
            
                    // Build an array of all acceptable time formats.
                    var formats;
                    if (format){
                    	formats = [format];
                    }else{
                    	formats = [].concat(_DT().TIMEINPUTFORMATS);
                    	formats.unshift(_DT().TIMEOUTPUTFORMAT);
                    }
            
                    // Now compare the given string to each acceptable format.
                    for (var i = 0, len = formats.length; i < len; i++) {       
                        // Convert the format to a regular expression for javascript comparison.    
                        var reInfo = this._buildRegExp4TimeFormat(formats[i]),
                        // Does the given string match the regular expression?
                            result = reInfo && s.match(bContains ? reInfo.reContains : reInfo.reEquals);
                        if (result) {
                            // Yes, matched. Fetch pieces: hour, min, sec, ampm, zone, etc.
                            var ampm = reInfo.ampmIndex && result[reInfo.ampmIndex];
                            parseResult = {
                                match: result[0],
                                // By convention, return a capital Hour (0-23), not a little hour (1-12)
                                hour: reInfo.hourIndex && this.capitalHour(result[reInfo.hourIndex], ampm),
                                min: reInfo.minIndex && parseInt(Number(result[reInfo.minIndex])),
                                sec: reInfo.secIndex && parseInt(Number(result[reInfo.secIndex]))
                            };
                            break;
                        }
                    } // end for loop walking the acceptable formats
                    // Store parse result in cache for later re-use.
                    cache[s] = parseResult;
                    return parseResult;
                },
                
                /**
                 * This method applies a format String to a timeInfo object to produce a formatted time String.
                 * The given timeInfo object is assumed to have the following properties:  "hour" (0-23),
                 * "min" (0-59), "sec" (0-59, possibly missing).  The format String is typically the out format
                 * specified by MSTRWeb server.  In theory, this method should handle any such format String,
                 * but to optimize this implementation, we make certain assumptions about the format String, namely:
                 * the string may contain: "HH", "H", "hh", "h", "mm", "m", "ss", "s", "a"; all other chars
                 * are taken as literals.
                 */
                formatTimeInfo: function formatTimeInfo(/*Object*/ timeInfo, /*String*/ format) {
                    if (!format) return '';
                    var twelveHour = !(Number(timeInfo.hour) % 12) ? 12 : (Number(timeInfo.hour) % 12),
                        s = format.replace(/HH/g, this.formatInteger(timeInfo.hour, 2)
                                    ).replace(/H/g, Number(timeInfo.hour)
                                    ).replace(/hh/g, this.formatInteger(twelveHour, 2)
                                    ).replace(/h/g, twelveHour
                                    ).replace(/mm/g, this.formatInteger(Number(timeInfo.min) || 0, 2)
                                    ).replace(/m/g, Number(timeInfo.min) || 0
                                    ).replace(/ss/g, this.formatInteger(Number(timeInfo.sec) || 0, 2)
                                    ).replace(/s/g, Number(timeInfo.sec) || 0
                                    ).replace(/a/g, (Number(timeInfo.hour) < 12) ? _DT().AM_NAME : _DT().PM_NAME
                                    );
                    return s;
                },

                /**
                 * Returns true if the given time falls within the valid number range of hours, minutes
                 * and seconds.  Seconds are optional, so if omitted, the time can still be considered valid.
                 */
                doesTimeExist: function doesTimeExst(/*Integer*/ capitalHour, /*Integer*/ min, /*Integer?*/ sec) {
                    var h = parseInt(capitalHour);
                    if (h >= 0 && h <= 23) {
                        var m = parseInt(min);
                        if (m >= 0 && m <= 59) {
                            if (!sec) return true;
                            var s = parseInt(sec);
                            if (s >= 0 && s <= 59) return true;
                        }
                    }
                    return false;
                },
                
                
                /**
                 * This method converts a given hour to a capital Hour.  "Capital Hour" means
                 * an integer from 0-23.  The given hour can be either in capital Hour units
                 * or in little hour units (1-12); but if given in little hour units, then the
                 * ampm argument must be set to either "AM" or "PM" or their localized equivalents
                 * (_DT().AM_NAME and _DT().PM_NAME).  The ampm param is case-insensitive.
                 */
                capitalHour: function capitalHour(/*String*/ hour, /*String?*/ ampm) {
                    // Assume that if no am/pm info is given, the hour is a capital Hour,
                    // meaning 0-23.  Otherwise, if am/pm is given, the hour is a little hour,
                    // meaning, 1-12.
                    hour = parseInt(Number(hour));
                    if (ampm && (ampm.match(_DT().AM_NAME) || ampm.match(/AM/i))) {
                        // We have AM info, so hour is a little hour.
                        return hour % 12;
                    } else if (ampm && (ampm.match(_DT().PM_NAME) || ampm.match(/PM/i))) {
                        // We have PM info, so hour is a little hour.
                        return 12 + (hour % 12);
                    } else {
                        // Missing or invalid ampm param.
                        // We don't have am/pm info, so hour is a capital Hour.
                        return hour;
                    }
                },
                
                /**
                 * Validation to check if a given string is either (1) a date only, (2) a time only, or
                 * (3) a date + time.
                 * The bFormat param determines whether this method returns a string (bFormat = true)
                 * or boolean (bFormat = false or missing).
                 */
                isDateAndOrTime: function isDateAndOrTime(/*String*/ s, /*Boolean?*/ bFormat) {
                    return this.isDateTime(s, bFormat)
                            || this.isDate(s, bFormat)
                            || this.isTime(s, bFormat);
                },
                
                /**
                 * Validation method for timestamps. Succeeds if the given string contains a
                 * valid date and a valid time.  Note that if other extraneous chars are also present
                 * in the string along valid date + time substrings, validation still succeeds.
                 * The bFormat param determines whether this method returns a string (bFormat = true)
                 * or boolean (bFormat = false or missing).
                 * If bFormat is true, the method will return the formatted
                 * date and time, if found; null otherwise.  If bFormat is false,
                 * the method will return true if the date and time are found; false otherwise.
                 * If bFormat is true and a match is made, the formatted date + formatted time strings
                 * are concat'd together by a space (in whichever order they were found); other extraneous
                 * pieces of the string are discarded.
                 */
                isDateTime: function isDateTime(/*String*/ s, /*Boolean?*/ bFormat) {
                    // Try to parse the date and time info from the given string.
                    // If parsing succeeded, and the numbers are in the right range, validation successful.
                    var dateTimeInfo = this.parseDateAndOrTime(s),
                        dateInfo = dateTimeInfo && dateTimeInfo.date,
                        timeInfo = dateTimeInfo && dateTimeInfo.time,
                        isValid = !!dateInfo 
                                    && !!timeInfo
                                    && this.doesDateExist(dateInfo.month, dateInfo.day, dateInfo.year)
                                    && this.doesTimeExist(timeInfo.hour, timeInfo.min, timeInfo.sec);
                    // Are we returning a formatted String, or a Boolean?
                    if (bFormat) {
                        // Return formatted Strings concat'd together, if matched; otherwise return null.
                        if (isValid) {
                            // Format the strings and concat. Which came first, date or time?
                            var formattedDate = this.formatDateInfo(dateInfo, _DT().DATEOUTPUTFORMAT),
                                formattedTime = this.formatTimeInfo(timeInfo, _DT().TIMEOUTPUTFORMAT),
                                dateIndex = s.indexOf(dateInfo.match),
                                timeIndex = s.indexOf(timeInfo.match);
                            return (timeIndex < dateIndex) ?
                                    formattedTime + ' ' + formattedDate :
                                    formattedDate + ' ' + formattedTime;
                                
                        } else {
                            return null;
                        }
                    } else {
                        // Return Boolean.
                        return !!isValid;
                    }
                },
                
                

                /**
                 * Parses a given string for date and time substring information.  If both date and time are not
                 * found, parser returns null; otherwise, parser returns a composite object with two properties, "date" and "time", each of
                 * which correspond to the return values from calling the methods "parseDate" and "parseTime" respectively.
                 * If only date info is found, the "time" property is set to null; if only time info is found, the "date" property
                 * is set to null.
                 */
                parseDateAndOrTime: function parseDateAndOrTime(/*String*/ s, /*String?*/ dateFormat, timeFormat) {
                    // First look for a date substring.
                    var dateInfo = this.parseDate(s, true, dateFormat);
                    // Now look for a time substring; search in the string after removing the date (if found), so that we
                    // don't mistake some of the date as part of a time.
                    var sWithoutDate = $S.trim((dateInfo && dateInfo.match) ? 
                                            s.replace(dateInfo.match, "") :
                                            s),
                        timeInfo = this.parseTime(sWithoutDate, false, timeFormat); // by passing false, we are asking for exactly match
                        
                    // If we didn't find a time nor a date, we are done.
                    if (!dateInfo && !timeInfo) {
                        return null;
                    } else {
                        // We found a date or a time, or both. Return the results of both parsings.
                        return {
                            date: dateInfo,
                            time: timeInfo
                            };
                    }
                },
                
                /**
                 * Compares a given value with a minimum and maximum. If the value is below the minimum, returns -1.
                 * If the value is above the maximum, returns 1.  Otherwise, returns 0.  Note that the value, min & max
                 * are all assumed to use the current locale's formats for date & time.
                 */
                inDateTimeRange: function inDateTimeRange(val, min, max) {
                    // Parse the value's date and/or time.
                    var valInfo = this.parseDateAndOrTime(val),
                        valDateInfo = valInfo && valInfo.date,
                        valTimeInfo = valInfo && valInfo.time;
                    // If both date & time failed to parse, exit.
                    if (!valDateInfo && !valTimeInfo) return 0;
                    
                    // Minimum comparison.
                    if (min != null) {
                        // Parse the minimum's date and/or time.
                        var minInfo = this.parseDateAndOrTime(min);
                        // Compare the minimum's date, if any.
                        if (valDateInfo && minInfo && minInfo.date) {
                            var minDiff = this.compareDate(valDateInfo, minInfo.date);
                            if (minDiff < 0) {
                                // The given date is less than the minimum.
                                return -1;
                            } else if (minDiff == 0)  {
                                // The given date is the same as the minimum date.
                                // Compare the minimum's time, if any.
                                if (valTimeInfo && minInfo.time
                                    && (this.compareTime(valTimeInfo, minInfo.time) < 0))
                                {
                                    // The given date's time is less than the minimum.
                                    return -1;
                                } // end if compareTime with minInfo
                            } // end else if minDiff == 0
                        } // end if valDateInfo && minInfo.date
                    } // end if min
            
                    // Maximum comparison.
                    if (max != null) {
                        // Parse the maximum's date and/or time.
                        var maxInfo = this.parseDateAndOrTime(max);
                        // Compare the maximum's date, if any.
                        if (valDateInfo && maxInfo && maxInfo.date) {
                            var maxDiff = this.compareDate(valDateInfo, maxInfo.date);
                            if (maxDiff > 0) {
                                // The given date is greater than the maximum.
                                return 1;
                            } else if (maxDiff == 0) {
                                // The given date is the same as the maximum date.
                                // Compare the maximum's time, if any.
                                if (valTimeInfo && maxInfo.time
                                    && (this.compareTime(valTimeInfo, maxInfo.time) > 0))
                                {
                                    // The given date's time is greater than the maximum.
                                    return 1;
                                } // end if compareTime of max
                            } // end else if maxDiff == 0
                        } // end if valDateInfo && maxInfo.date
                    } // end if max
                    return 0;
                },
                
                
                /**
                 * Compares two non-null localized date strings. If val1 is lesser, returns a negative.
                 * If val1 is greater, returns a postive. Otherwise returns zero.
                 * The caller may also pass in Objects, rather than Strings, for either value, where the
                 * Object passed in the Object returned by calling mstrmojo.date.parseDate(..) with the
                 * localized date string.
                 */ 
                compareDate: function compareDate(/*String|Object*/ val1, /*String|Object*/ val2) {
                    if (val1 == val2) return 0;
                    var date1 = typeof(val1) == 'string' ? this.parseDate(val1) : val1,
                        date2 = typeof(val2) == 'string' ? this.parseDate(val2) : val2;
                    if (!date1) return -1;
                    if (!date2) return 1;
                    return (date1.year - date2.year)
                                || (date1.month - date2.month)
                                || (date1.day - date2.day)
                                || 0;
                },
                
                /**
                 * Compares two non-null localized time strings. If val1 is lesser, returns a negative.
                 * If val1 is greater, returns a postive. Otherwise returns zero.
                 * The caller may also pass in Objects, rather than Strings, for either value, where the
                 * Object passed in the Object returned by calling LocaleParser.parseTime(..) with the
                 * localized time string.
                 */ 
                compareTime: function compareTime(/*String*/ val1, /*String*/ val2) {
                    if (val1 == val2) return 0;
                    var time1 = typeof(val1) == 'string' ? this.parseTime(val1) : val1,
                        time2 = typeof(val2) == 'string' ? this.parseTime(val2) : val2;
                    if (!time1) return -1;
                    if (!time2) return 1;
                    return (time1.hour - time2.hour)
                                || (time1.min - time2.min)
                                || (time1.sec - time2.sec)
                                || 0;
                },
            
                /**
                 * Compares two non-null localized datetime strings. If val1 is lesser, returns a negative.
                 * If val1 is greater, returns a postive. Otherwise returns zero.
                 */ 
                compareDateTime: function compareDateTime(/*String*/ val1, /*String*/ val2) {
                    return this.compareDate(val1, val2) || this.compareTime(val1, val2);
                },
                
                compareDateAndOrTime: function compareDateAndOrTime(/*String*/ val1, /*String*/ val2) {
                	if (val1 == val2) return 0;
                	var dt1 = typeof(val1) == 'string' ? this.parseDateAndOrTime(val1) : val1,
                		dt2 = typeof(val2) == 'string' ? this.parseDateAndOrTime(val2) : val2;
                	
                	if (!dt1) return -1;
                	if (!dt2) return 1;
                		
                	var d1 = dt1.date, d2 = dt2.date, t1 = dt1.time, t2 = dt2.time;
                	return this.compareDate(d1, d2) || this.compareTime(t1, t2); 
                },
                
                /**
                 * Converts a given date format string from MSTRWeb server to a javascript
                 * regular expression that will be used to match that string against a
                 * user-given value.
                 * This method makes many assumptions about the format strings:
                 * 1) The string has chars "M", "d" and "y" (case-sensitive).
                 * 2) The "d"s are grouped together consecutively, as are the "M"s and "y"s.
                 * 3) There are either 1 or 2 "d"s, 1 to 4 "M"s, and either 2 or 4 "y"s.
                 */
                _buildRegExp4DateFormat: function re4DateFmt(/*String*/ formatStr) {
                
                    if (!formatStr) return null;
                    // Lookup local cached result. 
                    var reInfo = this.REGEXPS.DATES[formatStr];
                    if (!reInfo) {
                        // Cache not found, build result and cache it.
                        if (!this.REGEXPS.MONTHNAME_FULL) {
                            this.REGEXPS.MONTHNAME_FULL = _DT().MONTHNAME_FULL.join("|");
                            this.REGEXPS.MONTHNAME_SHORT = _DT().MONTHNAME_SHORT.join("|");
                        }
                        // The result is an object with several properties...
                        reInfo = this.REGEXPS.DATES[formatStr] = {};
                        // The "formatStr" prop has the original format string.
                        reInfo.formatStr = formatStr;
                        // The "re" prop has a regular expression derived from the format string.
                        // This requires several string replacements:
                        // 1) First, we need to escape any string chars which are not:
                        // "M", "d", "y", or white space.
                        // 2) Replace "dd" with 2 digits, to be captured as a whole.
                        // 3) Replace "d" with 1 or 2 digits, to be captured as a whole.
                        // Note that 2 & 3 must be done before the rest, because the digit placeholder
                        // is "\d" in RE syntax, which might be confused with "d" for day in Date syntax.
                        // 4) Replace 4 "y"s with 4 digits, to be captured as a whole.
                        // 5) Replace 2 "y"s with 2 digits, to be captured as a whole.
                        // 6) Replace 4 "M"s with a placeholder for a list of full month names
                        // (this placeholder should avoid "M"s)
                        // 7) Replace 3 "M"s with a placeholder for a list of short month names
                        // (this placeholder should avoid "M"s and should avoid being confused
                        // with the parts of the list of full month names).
                        // 8) Replace 2 "M"s with 2 digits, to be captured as a whole.
                        // 9) Replace "M" with 1 or 2 digits, to be captured as a whole.
                        // 10) Replace the 4 "M"s placeholder with the actual list of full month names.
                        // 11) Replace the 3 "M"s placeholder with the actual list of short month names.
                        var reStr = reInfo.reStr = formatStr.replace(/([^M|d|y|\s])/g, "\\$1"
                                        ).replace(/dd/g, "~~~~" // temporary place holder so the following "d" replacement wont touch "dd"s
                                        ).replace(/d/g, "(\\d{1,2})"
                                        ).replace(/\~\~\~\~/g, "(\\d\\d)"   // replace temporary placeholder for "dd"s
                                        ).replace(/yyyy/g, "(\\d\\d\\d\\d)"
                                        ).replace(/yy/g, "(\\d\\d)"
                                        ).replace(/MMMM/g, "@@@@"
                                        ).replace(/MMM/g, "@@@"
                                        ).replace(/MM/g, "(\\d\\d)"
                                        ).replace(/M/g, "(\\d{1,2})"
                                        ).replace("@@@@","(" + this.REGEXPS.MONTHNAME_FULL + ")"
                                        ).replace("@@@", "(" + this.REGEXPS.MONTHNAME_SHORT + ")");
                        // Now instantiate the reg expr objects and cache them; one object for
                        // an "equals" match, another for a "contains" match.
                        reInfo.reEquals = new RegExp("^" + reStr + "$");
                        reInfo.reContains = new RegExp("^" + reStr + "\\b");
                        // When we apply this reg expr and a match is found, the
                        // results of match() will yield the month, day and year
                        // parts that matched the pattern.  But they'll be sorted in
                        // the order they are found.  So we record their order in order
                        // to identify them later when examining the results of a match.
                        var indices = [
                            {key: "monthIndex", index: formatStr.indexOf("M")},
                            {key: "dayIndex", index: formatStr.indexOf("d")},
                            {key: "yearIndex", index: formatStr.indexOf("y")}
                            ];
                        indices.sort(function(a, b) { return a.index - b.index });
                        var counter = 1;
                        for (var i = 0; i < 3; i++) {
                            reInfo[indices[i].key] = indices[i].index > -1 ?
                                                        counter++ : null;
                        }   
                    }
                    return reInfo;
                },
            
                /**
                 * Converts a given time format string from MSTRWeb server to a javascript
                 * regular expression that will be used to match that string against a
                 * user-given value.
                 * This method makes many assumptions about the format strings:
                 * 1) The string may have chars "H", "h", "m", "s", "a", "z" and "Z" (case-sensitive).
                 * 2) These chars above are grouped together consecutively.
                 * 3) Some chars are assumed to occur a max # of times (e.g., no more than 2 "H"s, "s"s, "m"s, etc).
                 * 4) A single quote (') is used to enclose a set of literal chars.
                 * 5) Two single quotes ('') are used to represent a single quote.
                 */
                _buildRegExp4TimeFormat: function re4TimeFmt(/*String*/ formatStr) {
                
                    if (!formatStr) return null;
                    // Lookup local cached result. 
                    var reInfo = this.REGEXPS.TIMES[formatStr];
                    if (!reInfo) {
                        // Cache not found, build result and cache it.
                        if (!this.REGEXPSTR_AMPM) {
                            
                            this.REGEXPSTR_AMPM = [_DT().AM_NAME, 
                                                _DT().PM_NAME,
                                                String(_DT().AM_NAME).toLowerCase(),
                                                String(_DT().PM_NAME).toLowerCase()
                                                ].join("|");
                        }
                        // The result is an object with several properties...
                        reInfo = this.REGEXPS.TIMES[formatStr] = {};
                        // The "formatStr" prop has the original format string.
                        reInfo.formatStr = formatStr;
                        // The "re" prop has a regular expression derived from the format string.
                        // This requires several string replacements:
                        // 1) First, we temporarily replace every double-single-quote with
                        // a placeholder so it will be ignored in the next step.
                        var reStr = formatStr.replace(/\'\'/g, '"');
                        // 2) Next, we temporarily remove every literal that is enclosed
                        // in single quotes, so it won't be modified by the following steps.
                        // We'll reinsert these literals back in after those steps are done.
                        var literals = reStr.match(/\'(.+?)\'/g);
                        reStr.replace(/\'(.+?)\'/g, '*');
                        // 3) we need to escape any string chars which are not:
                        // "H", "h", "m", "s", "z", "Z", "a", or white space.
                        // 4) Replace these special chars with correct placeholders.
                        reStr = reStr.replace(/([^H|h|m|s|z|Z|a|\s])/g, "\\$1"
                                        ).replace(/HH|hh/g, "(\\d\\d)"
                                        ).replace(/H|h/g, "(\\d{1,2})"
                                        ).replace(/mm/g, "(\\d\\d)"
                                        ).replace(/m/g, "(\\d{1,2})"
                                        ).replace(/ss/g, "(\\d\\d)"
                                        ).replace(/s/g, "(\\d{1,2})"
                                        ).replace(/a/gi, "(" + this.REGEXPSTR_AMPM + ")"
                                        ).replace(/z|Z/g, "(.+?)");
                        // 5) Now we are ready to reinsert our literals back in.
                        for (var i = 1, len = literals && literals.length || 0; i < len; i++) {
                            reStr = reStr.replace(/\*/, literals[i]);
                        }
                        // 6) And we can undo our first step; replacing the double single quotes.
                        reStr = reStr.replace(/\"/g, "'");
                        
                        // Now instantiate the reg expr object and cache it.
                        // Now instantiate the reg expr objects and cache them; one object for
                        // an "equals" match, another for a "contains" match.
                        reInfo.reEquals = new RegExp("^" + reStr + "$");
                        reInfo.reContains = new RegExp(reStr);
                        // When we apply this reg expr and a match is found, the
                        // results of match() will yield the month, day and year
                        // parts that matched the pattern.  But they'll be sorted in
                        // the order they are found.  So we record their order in order
                        // to identify them later when examining the results of a match.
                        var indices = [
                            {key: "hourIndex", index: formatStr.search(/h|H/)},
                            {key: "minIndex", index: formatStr.indexOf("m")},
                            {key: "secIndex", index: formatStr.indexOf("s")},
                            {key: "ampmIndex", index: formatStr.indexOf("a")},
                            {key: "zoneIndex", index: formatStr.search(/z|Z/)}
                            ];
                        indices.sort(function(a, b) { return a.index - b.index });
                        var counter = 1;
                        for (var i = 0; i < 5; i++) {
                            reInfo[indices[i].key] = indices[i].index > -1 ? 
                                                        counter++ : null;
                        }   
                    }
                    return reInfo;
                },
                
                /**
                 * Returns true if the given date is an actual day on the calendar.
                 * For example February 30th of any year would return false.
                 */
                doesDateExist: function doesDateExist(/*Integer*/ month, /*Integer*/ day, /*Integer*/ year) {
                    var dt = new Date(year, month - 1, day);

                    return year == dt.getFullYear() &&
                           month == dt.getMonth() + 1 &&
                           day == dt.getDate();
                },
            
                /**
                 * Given a year integer that is between 0 and 99 inclusive,
                 * this method will return a corresponding 4-digit year.
                 */
                fourDigitYear: function fourDigitYear(/*String|Integer*/ year) {
                    year = parseInt(Number(year));
                    if (!isNaN(year)) {
                        var twoDigitStart = (_DT().TWODIGITYEARSTART  % 100) || 0;   
                        if (year >= 0 && year <= twoDigitStart) 
                            year = 2000 + year; 
                        else if (year > twoDigitStart && year < 100)
                            year = 1900 + year;
                    }
                    return year;
                },
                
                /**
                 * Returns the 1-based (NOT 0-based) index of a given month name.  If not found, returns 0.
                 * The name is searched for in the list of localized month names/abbrevs.
                 */
                numericMonth: function numMonth(/*String|Number*/ month) {
                    // Were we given an integer (either as a String or a Number)? Then no work required.
                    var monthInt = parseInt(Number(month)),
                        _A = mstrmojo.array;
                    if (!isNaN(monthInt)) return monthInt;
                    
                    // We were given a non-integer string. Must be a month name (long or short).
                    // Search for it in our list of month names.
                    var len = month && month.length || 0,
                        index = -1;
                    if (len) {
                        // If the name is 3 chars long or shorter, start by looking in the abbreviations.
                        if (len <= 3) {
                            index = _A.indexOf(_DT().MONTHNAME_SHORT, month);
                        }
                        // If still not found, look for it in the full month names list.
                        if (index == -1) {
                            index = _A.indexOf(_DT().MONTHNAME_FULL, month);
                        }
                    }
                    return index + 1;
                },
                
                /**
                 * This method converts a given integer into a string whose length is at least
                 * equal to the given minimum length.  For example, if the integer 5 is passed
                 * in with a given min length = 2, then this method returns "05".
                 */
                formatInteger: function fmtInt(/*Integer*/ num, /*Integer*/ minLen) {
                    var s = String(num),
                        missing = Math.max(minLen - s.length, 0);
                    if (missing > 0) {
                        var arr = [s];
                        for (var i = 1; i <= missing; i++) {
                            arr.push("0");
                        }
                        s = arr.reverse().join('');
                    }
                    return s;
                },
                
                /**
                 * This method returns the first Date of a given month. 
                 */
                getFirstDateOfMonth: function(y,m){
                    return new Date(y, m-1, 1);
                },
                
                /**
                 * This method returns the Date object given values for various part of a Date object. 
                 */
                getDateObject: function(y,m,d,hh,mm,ss){
                    y = y || 0;
                    m = m || 1;
                    d = d || 1;
                    hh = hh || 0;
                    mm = mm || 0;
                    ss = ss || 0;
                    return new Date(y,m-1,d,hh,mm,ss);
                },
                
                /**
                 * This method returns a native Date object based on a date info object.
                 */
                getDateFromDateInfo: function (dateInfo) {
                    return this.getDateObject(
                                dateInfo.date && dateInfo.date.year,
                                dateInfo.date && dateInfo.date.month,
                                dateInfo.date && dateInfo.date.day,
                                dateInfo.time && dateInfo.time.hour,
                                dateInfo.time && dateInfo.time.min,
                                dateInfo.time && dateInfo.time.sec
                            );
                },
                
                /**
                 * This method returns a json given a Date object.  
                 */
                getDateJson: function(date){
                    return {year:date.getFullYear(),month:date.getMonth() + 1,day:date.getDate(),
                            hour:date.getHours(),min:date.getMinutes(),sec:date.getSeconds()};
                },
                
                /**
                 * This method checks whether a year is a leap or not. 
                 */
                isLeapYear: function(y) {
                    return !(y%400) || (!(y%4) && !!(y%100));
                },
                
                /**
                 * This method returns the number of days in a given month. 
                 */
                getDaysOfMonth: function(y,m){
                    var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                    if(m == 2 && this.isLeapYear(y)){ return 29; } 
                    return days[m - 1];     
                },
                
                /**
                 * This method returns a previous month of a given month. 
                 */
                getPreMonth: function(y,m) {
                    if(m === 1) return {y:y-1, m:12};
                    return {y:y,m:m-1};
                },
                
                /**
                 * This method returns a next month of a given month. 
                 */
                getNextMonth: function(y,m){
                    if(m === 12) return {y:y+1,m:1};
                    return {y:y,m:m+1};
                }              
                
            });

 })();
(function() {

    mstrmojo.requiresCls("mstrmojo.array", "mstrmojo.locales");

    var _A = mstrmojo.array, MTP = mstrmojo.meta.TP, H = mstrmojo.hash, 
    _ET = {
        ANDOR : 14,
        MQ : 10,
        MC : 12,
        AQ : 2,
        AL : 6,
        AC : 9,
        AE : 5,
        F : 13,
        R : 21,
        B : 20,
        XML : 1
    }, _ETvals = {};
    for ( var k in _ET) {
        _ETvals[_ET[k]] = true;
    }

    /**
     * <p>
     * Maps expression type to a ConditionModel property that specifies the
     * expression target (if any).
     * </p>
     * 
     * @private
     */
    var ET2TGT = {};
    ET2TGT[_ET.AQ] = 'a';
    ET2TGT[_ET.AL] = 'a';    
    ET2TGT[_ET.AC] = 'a';
    ET2TGT[_ET.AE] = 'a';
    ET2TGT[_ET.MQ] = 'm';
    ET2TGT[_ET.MC] = 'm';
    ET2TGT[_ET.F] = 'f';
    ET2TGT[_ET.R] = 'r';
    ET2TGT[_ET.XML] = 'p';

    /**
     * <p>
     * Maps expression type to a list of relevant ConditionModel properties.
     * </p>
     * 
     * @private
     */
    var ET2C = {};
    ET2C[_ET.MQ] = [ 'not', 'm', 'fn', 'fnt', 'cs', 'dmy' ];
    ET2C[_ET.MC] = [ 'not', 'm', 'fn', 'fnt', 'm2', 'm3', 'p', 'dmy' ]; 
    ET2C[_ET.AE] = [ 'not', 'a', 'fn', 'es', 'a2', 'fm2', 'p']; 
    ET2C[_ET.AQ] = [ 'not', 'a', 'fm', 'fn', 'cs'];
    ET2C[_ET.AL] = [ 'not', 'a', 'fm', 'fn', 'cs'];    
    ET2C[_ET.AC] = [ 'not', 'a', 'fm', 'a2', 'fm2', 'a3', 'fm3', 'fn', 'cs'];
    ET2C[_ET.R] = [ 'not', 'r' ];
    ET2C[_ET.F] = [ 'not', 'f' ];
    ET2C[_ET.XML] = [ 'not', 'n', 'p' ]; // only prompt in generic type is editable

    /**
     * <p>
     * Maps expression type to an mstrmojo.expr property that specifies the
     * function lookup array.
     * </p>
     * 
     * @private
     */

    var _ET2FNS = {};
    _ET2FNS[_ET.MQ] = "METRIC_FNS";
    _ET2FNS[_ET.MC] = "METRIC_FNS";
    _ET2FNS[_ET.AQ] = "FORM_FNS";
    _ET2FNS[_ET.AL] = "FORM_FNS";    
    _ET2FNS[_ET.AC] = "FORM_FNS";
    _ET2FNS[_ET.AE] = "ELEM_FNS";

    var _TP = {
        FILTER : 1,
        REPORT : 3,        
        METRIC : 4,
        FOLDER : 8,        
        PROMPT : 10,
        FUNCTION: 11,
        ATTR : 12,
        FACT: 13,
        DIM:14,
        FORM : 21,
        ROLE: 43 //transformation
    }, _STP = {
        FILTER : 256,
        CUSTOMGROUP : 257,
        PROMPT : 2560,
        PROMPT_BOOLEAN : 2561,
        PROMPT_LONG : 2562,
        PROMPT_STRING : 2563,
        PROMPT_DOUBLE : 2564,
        PROMPT_DATE : 2565,
        PROMPT_OBJECTS : 2566,
        PROMPT_ELEMENTS : 2567,
        PROMPT_EXPRESSION : 2568,
        PROMPT_EXPRESSION_DRAFT : 2569,
        PROMPT_DIMTY : 2570,
        PROMPT_BIGDECIMAL : 2571,
        REPORT_GRID : 768,
        REPORT_GRAPH : 769,
        REPORT_ENGINE : 770,
        REPORT_TEXT : 771,
        REPORT_DATAMART : 772,
        REPORT_BASE : 773,
        REPORT_GRIDGRAPH : 774,
        REPORT_NONINTERACTIVE : 775,
        REPORT_CUBE : 776
    }, OBJKEY2TP = {
        a : _TP.ATTR,
        a2 : _TP.ATTR,
        m : _TP.METRIC,
        m2 : _TP.METRIC,
        r : _TP.REPORT,
        f : _TP.FILTER,
        p : _TP.PROMPT
    };

    /**
     * <p>
     * Maps expression type to allowed target types.
     * </p>
     * 
     * @private
     */
    var ET2TP = {};
    ET2TP[_ET.MQ] = _TP.METRIC;
    ET2TP[_ET.MC] = _TP.METRIC;
    ET2TP[_ET.AQ] = _TP.ATTR;
    ET2TP[_ET.AL] = _TP.ATTR;    
    ET2TP[_ET.AC] = _TP.ATTR;
    ET2TP[_ET.AE] = _TP.ATTR;
    ET2TP[_ET.F] = _TP.FILTER;
    ET2TP[_ET.R] = _TP.REPORT;

    // NOTE, can not pre-process anything in locales here, 
    // since at this time, locales may still have pre-set default values,
    // we only can keep the reference, later locales maybe updated by task to have real
    // locale related strings.
    var _funcTrans = function(funs){
            var len = funs.length,
            r = {};
            for (var i = 0; i < len; i ++){
                var f = funs[i];
                r[f.did] = f.n;
            }
            return r;
        },
        _tpTrans = function(funs){
            var len = funs.length;
            for (var i = 0; i < len; i ++){
                var fun = funs[i];
                if ('tp' in fun) {
                    fun.t = fun.tp;
                }
            }
            return funs;
        },
        _fnTrans = function(funs, t){
            var len = funs.length;
            for (var i = 0; i < len; i ++){
                var fun = funs[i];
                if ('tp' in fun) {
                    if (t) {
                        fun.t = t;
                    } else {
                        delete fun.t;
                    }
                }
            }
            return funs;
        },
        _arrRep = function(funs, desc){
            if (!desc) {
                desc = [];
            }
            // clean
            desc.length = 0;
            for (var i = 0, len = funs.length; i < len; i ++){
                desc[i] = funs [i];
            }
            return desc;
        },
        FORM_PROHIBITED = {
            0: [ // DTP.NUM
                 {
                     'did' :'1,76'
                 }, {
                     'did' :'1,79'
                 }, {
                     'did' :'1,77'
                 }, {
                     'did' :'1,80'
                 }, {
                     'did' :'1,78'
                 }, {
                     'did' :'1,81'
                 }, {
                     'did' :'1,18'
                 }, {
                     'did' :'1,43'
                 } ],
            1: [ // DTP.CHAR
                 {
                     'did' :'2,1'
                 }, {
                     'did' :'2,2'
                 }, {
                     'did' :'3,1'
                 }, {
                     'did' :'3,2'
                 }]
            // 2: Date is FORM_PROHIBITED['2'] = FORM_PROHIBITED[0].concat(FORM_PROHIBITED[1]) 
        };
        METRIC_PROHIBITED = {
                0:[
                       {
                           'did':'1,22'
                       },{
                            'did':'1,57'
                        }
                  ]
        };
       

    /**
     * <p>
     * Utility of functions related to filter expressions.
     * </p>
     * 
     * @class
     */
    mstrmojo.expr = mstrmojo.provide("mstrmojo.expr",
    /**
     * @lends mstrmojo.expr#
     */
    {
        /**
         * <p>
         * Enumeration of expression types.
         * </p>
         * 
         * @type String
         */
        ET : _ET,

        ETs : _ETvals,

        ET2TGT : ET2TGT,

        ET2COND : ET2C,

        ET2TP : ET2TP,

        /**
         * Enumeration of function ids (Integers).
         * 
         * @type Object
         */
        FN : {
            EQUAL: 6,
            NOT_EQUAL: 7,
            GREATER: 8,
            LESS: 9,
            GREATER_EQUAL: 10,
            LESS_EQUAL: 11,
            IN_LIST : 22,
            NOT_IN_LIST : 57,
            BETWEEN : 17,
            NOT_BETWEEN : 44,
            IS_NULL : 54,
            IS_NOT_NULL : 55,
            AND : 19,
            OR : 20,
            NOT : 21
        },

        /**
         * Enumeration of function types (Integers).
         * 
         * @type Object
         */
        FNT : {
            DEF : 1,
            RANK : 2,
            PER : 3
        },

        /**
         * Delimiter used in function keys to separate function type and id.
         * 
         * @type String
         */
        FN_SEP : ",",

        /**
         * <p>
         * Enumeration of object types (Integers).
         * </p>
         * 
         * @type Object
         */
        TP : _TP,

        /**
         * <p>
         * Enumeration of object sub-types (Integers).
         * </p>
         * 
         * @type Object
         */
        STP : _STP,

        /**
         * <p>
         * Enumeration of metric dimensionality unit types (Integers).
         * </p>
         * 
         * @type Object
         */
        DMY_TP : {
            ATTR : -1,
            DIM : -2
        },

        /**
         * <p>
         * Enumeration of data types (Integers).
         * </p>
         * 
         * @type Object
         */
        DTP : {
            UNKNOWN : -1,
            INTEGER : 1,
            UNSIGNED : 2,
            NUMERIC : 3,
            DECIMAL : 4,
            REAL : 5,
            DOUBLE : 6,
            FLOAT : 7,
            CHAR : 8,
            VARCHAR : 9,
            LONGVARCHAR : 10,
            BINARY : 11,
            VARBIN : 12,
            LONGVARBIN : 13,
            DATE : 14,
            TIME : 15,
            TIMESTAMP : 16,
            SHORT : 21,
            LONG : 22,
            MBCHAR : 23,
            BOOLEAN : 24,
            PATTERN : 25,
            BIGDECIMAL : 30
        },

        /**
         * <p>
         * The default metric data type.
         * </p>
         * 
         * @type Integer
         */
        METRIC_DTP : 3, // TO DO: move to mstrmojo.locales?

        /**
         * <p>
         * Enumeration of function data types (Integers).
         * </p>
         * 
         * @type Object
         */
        FN_DTP : {
            NUM : 0,
            CHAR : 1,
            DATE : 2
        },

        /**
         * <Mapping of data types to prompt object sub types.
         * </p>
         * 
         * @type Object
         */
        DTP2PROMPT_STP : {
            "-1" : _STP.PROMPT,
            1 : _STP.PROMPT_LONG,
            2 : _STP.PROMPT_LONG,
            3 : _STP.PROMPT_LONG,
            4 : _STP.PROMPT_DOUBLE,
            5 : _STP.PROMPT_DOUBLE,
            6 : _STP.PROMPT_DOUBLE,
            7 : _STP.PROMPT_DOUBLE,
            8 : _STP.PROMPT_STRING,
            9 : _STP.PROMPT_STRING,
            10 : _STP.PROMPT_STRING,
            14 : _STP.PROMPT_DATE,
            15 : _STP.PROMPT_DATE,
            16 : _STP.PROMPT_DATE,
            21 : _STP.PROMPT_LONG,
            22 : _STP.PROMPT_LONG,
            23 : _STP.PROMPT_STRING,
            24 : _STP.PROMPT_BOOLEAN,
            30 : _STP.PROMPT_BIGDECIMAL
        },

        /**
         * <Mapping of data types to function data types.
         * </p>
         * 
         * @type Object
         */
        DTP2FN_DTP : {
            "-1" : 0,
            1 : 0,
            2 : 0,
            3 : 0,
            4 : 0,
            5 : 0,
            6 : 0,
            7 : 0,
            8 : 1,
            9 : 1,
            10 : 1,
            11 : 0,
            12 : 0,
            13 : 0,
            14 : 0, // was: 2; temp: use numeric functions for date forms,
            15 : 0, // was: 2; temp: use numeric functions for date forms,
            16 : 0, // was: 2; temp: use numeric functions for date forms,
            21 : 0,
            22 : 0,
            23 : 1,
            24 : 0,
            25 : 1,
            30 : 0
        },
        /**
         * <p>
         * Computes the number of constants supported by a given function.
         * </p>
         * 
         * @param {Number}
         *            fn The function id.
         * @param {Number}
         *            fnt The function type.
         * @returns {Integer} The number of constants supported by a given
         *          function.
         */
        fnCstCount : function fcc(fn, fnt) {
                // if (fnt === this.FNT.DEF) {
            var f = this.FN;
            switch (fn) {
            case f.BETWEEN: // between
            case f.NOT_BETWEEN: // not between
                return 2;
            case f.IS_NULL: // is null
            case f.IS_NOT_NULL: // is not null
                return 0;
            default:
                return 1;
            }
            // }
            // return 1;
        },

        /**
         * Return true if the function is either IN_LIST or NOT_IN_LIST. 
         */
        fn_List: function fn_List(fn, fnt){
            var f = this.FN;
            return fn == f.IN_LIST || fn == f.NOT_IN_LIST;
        },
        
        /**
         * Return true for the function/function type that allows AC or MC expression. 
         */
        fn_AC_MC: function fn_AC_MC(fn, fnt){
            var f = this.FN;
            return (fn == f.EQUAL) || (fn == f.NOT_EQUAL) || (fn == f.GREATER) || (fn == f.LESS) || (fn == f.GREATER_EQUAL) || (fn == f.LESS_EQUAL);      
        },
        
        
        /**
         * Looks up the name for a given function.
         */
        fnName : function fnn(et, fn, fnt, dtp) {
            var arr = this[_ET2FNS[et]];
            if (arr && arr.constructor === Object) {
                arr = arr[this.DTP2FN_DTP[dtp]] || arr["*"];
            }
            var i = _A.find(arr, "did", (fnt || 1) + this.FN_SEP + fn);
            if (i > -1) {
                return arr[i].n;
            }
            return '';
        },

    
        /**
         * Searches a given expression node and its subnodes for conditions with
         * a target (attribute, metric, embedded object).
         * 
         * @param {Object}
         *            nd The expression node.
         * @param {String}
         *            idField The name of the property which specifies a
         *            target's id. Used to filter our duplicate targets from the
         *            result.
         * @param {Object}
         *            h The hashtable in which to record results; if missing,
         *            one is created. Useful for building up results from
         *            separate searches in multiple expression trees.
         * @return {Object} Hashtable of all unique targets found; keyed by the
         *         given idField.
         */
        findTargets : function fndT(nd, idField, h) {
            if (!h) {
                h = {};
            }
            if (nd) {
                // Walk the targets (attributes, metrics).
                for ( var k in OBJKEY2TP) {
                    var t = nd[k];
                    if (t) {
                        if (!t[MTP]) { // renamed "tp" to "t"
                            t[MTP] = OBJKEY2TP[k]; // renamed "tp" to "t"
                        }
                        h[t[idField]] = t;
                    }
                }
        // Walk the dimensionality units (attributes; ignore dimensions).
                if (nd.dmy) {
                    var A = this.TP.ATTR, DA = this.DMY_TP.ATTR, uts = nd.dmy.uts;
                    for ( var u = 0, uLen = (uts && uts.length) || 0; u < uLen; u++) {
                        var ut = uts[u];
                        if (ut && ut.utp === DA) {
                            var dt = ut.utgt;
                            if (!dt.t) {
                                dt.t = A;
                            }
                            h[dt[idField]] = dt;
                        }
                    }
                }

                // If we have children, walk them (recursively).
                var ch = nd.nds, i, len;
                for ( i = 0, len = (ch && ch.length) || 0; i < len; i++) {
                    this.findTargets(ch[i], idField, h);
                }
                var cs = nd.cs,
                    clen = cs && cs.length;
                if (clen){
                    for (i = 0; i < clen; i ++){
                        this.findTargets(cs[i], idField, h);
                    }
                }
            }
            return h;
        },
        onLocaleUpdated : function() {
            var _STRS = mstrmojo.locales.expression,
                _E = mstrmojo.expr;
        /**
         * Lookup of branch qual function names.
         */
            _E.BRANCH_FNS = H.copy(_funcTrans(_STRS.BranchQual), _E.BRANCH_FNS); 
        /*{
            19 : "AND",
            20 : "OR",
            21 : "NOT"
        },*/
    
        /**
         * <p>
         * Lookup of element list functions (operators).
         * </p>
         */
            _E.ELEM_FNS = _arrRep(_fnTrans(_STRS.Element, 'fn'), _E.ELEM_FNS); 
            /*[ {
            did : '1,22',
            n : 'In List',
            t : 'fn'
        }, // renamed "tp" to "t"; assumes mstrmojo.meta.TP is "t"
                {
                    did : '1,57',
                    n : 'Not In List',
                    t : 'fn'
                } // renamed "tp" to "t"
            ],*/
    
            /**
             * <p>
             * Lookup for metric functions (operators), keyed by metric's data type
             * ("*" = default).
             * </p>
             */
            _E.METRIC_FNS = {
                "*" : _fnTrans(_A.filter(_STRS.Metric, function(item){
                        return item.did && (_A.find(METRIC_PROHIBITED['0'], 'did', item.did) < 0);}))
                    /*[ {
                    did : '1,6',
                    'n' : 'Equal to'
                }, {
                    did : '1,7',
                    'n' : 'Not Equal to'
                }, {
                    did : '1,8',
                    'n' : 'Greater than'
                }, {
                    did : '1,10',
                    'n' : 'Greater than or equal to'
                }, {
                    did : '1,9',
                    'n' : 'Less than'
                }, {
                    did : '1,11',
                    'n' : 'Less than or equal to'
                }, {
                    did : '1,17',
                    'n' : 'Between'
                }, {
                    did : '1,44',
                    'n' : 'Not between'
                }, {
                    did : '1,54',
                    'n' : 'Is Null'
                }, {
                    did : '1,55',
                    'n' : 'Is not null'
                }, {
                    did : '1,22',
                    'n' : 'In'
                }, {
                    did : '1,57',
                    'n' : 'Not in'
                }, {
                    did : '2,1',
                    'n' : 'Highest'
                }, {
                    did : '2,2',
                    'n' : 'Lowest'
                }, {
                    did : '3,1',
                    'n' : 'Highest (%)'
                }, {
                    did : '3,2',
                    'n' : 'Lowest (%)'
                } ]*/
            };
            /**
             * <p>
             * Lookup for attribute form functions (operators), keyed by form's data
             * type ("*" = default).
             * </p>
             */
            _E.FORM_FNS = {
                0 : // DTP.NUM
                    _fnTrans(_A.filter(_STRS.Attribute, function(item){
                        return item.did && (_A.find(FORM_PROHIBITED['0'], 'did', item.did) < 0);})),
                1 : // DTP.CHAR
                    _fnTrans(_A.filter(_STRS.Attribute, function(item){
                        return item.did && (_A.find(FORM_PROHIBITED['1'], 'did', item.did) < 0);})),
                2 : // DTP.DATE
                    _fnTrans(_A.filter(_STRS.Attribute, function(item){
                        return item.did && (_A.find(FORM_PROHIBITED['0'], 'did', item.did) < 0) && (_A.find(FORM_PROHIBITED['1'], 'did', item.did) < 0);}))
                    
                    /*[ // DTP.NUM
                {
                    did : '1,6',
                    n : 'Equal to'
                }, {
                    did : '1,7',
                    'n' : 'Not Equal to'
                }, {
                    did : '1,8',
                    'n' : 'Greater than'
                }, {
                    did : '1,10',
                    'n' : 'Greater than or equal to'
                }, {
                    did : '1,9',
                    'n' : 'Less than'
                }, {
                    did : '1,11',
                    'n' : 'Less than or equal to'
                }, {
                    did : '1,17',
                    'n' : 'Between'
                }, {
                    did : '1,44',
                    'n' : 'Not between'
                } ],
                1 : [ // DTP.CHAR
                {
                    did : '1,6',
                    n : 'Equal to'
                }, {
                    did : '1,7',
                    'n' : 'Not Equal to'
                }, {
                    did : '1,8',
                    'n' : 'Greater than'
                }, {
                    did : '1,10',
                    'n' : 'Greater than or equal to'
                }, {
                    did : '1,9',
                    'n' : 'Less than'
                }, {
                    did : '1,11',
                    'n' : 'Less than or equal to'
                }, {
                    did : '1,17',
                    'n' : 'Between'
                }, {
                    did : '1,44',
                    'n' : 'Not between'
                }, {
                    did : '1,76',
                    'n' : 'Contains'
                }, {
                    did : '1,79',
                    'n' : 'Does not contain'
                }, {
                    did : '1,77',
                    'n' : 'Begins with'
                }, {
                    did : '1,80',
                    'n' : 'Does not begin with'
                }, {
                    did : '1,78',
                    'n' : 'Ends with'
                }, {
                    did : '1,81',
                    'n' : 'Does not end with'
                }, {
                    did : '1,18',
                    'n' : 'Like'
                }, {
                    did : '1,43',
                    'n' : 'Not like'
                }, {
                    did : '1,54',
                    'n' : 'Is Null'
                }, {
                    did : '1,55',
                    'n' : 'Is not null'
                }, {
                    did : '1,22',
                    'n' : 'In'
                }, {
                    did : '1,57',
                    'n' : 'Not in'
                } ]*/
            };
    
            _E.DIMTYLEVELS = _arrRep(_fnTrans(_STRS.DimtyLevels), _E.DIMTYLEVELS) ;
                /*[ {
                did : 0,
                n : 'Default level'
            }, {
                did : 1,
                n : 'Metric level'
            }, {
                did : 2,
                n : 'Report level'
            } ],*/
        }
    });
    
    mstrmojo.expr.onLocaleUpdated();

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.dnd");

    var $D = mstrmojo.dom;

    /**
     * Attaches a handler to document.onselectstart to force the cursor to take effect (only performed for webkit browsers).
     *
     * @param {Boolean} rtnValue False to call prevent default.  This value will also be returned from the onselectstart method.
     *
     * @private
     */
    function cursorHack(rtnValue) {
        if ($D.isWK) {//a workaround to make the cursor taking effect in webkit browsers.
            document.onselectstart = function (e) {
                if (!rtnValue) {
                    e.preventDefault();
                }

                return rtnValue;
            };
        }
    }

    mstrmojo._IsMovable = mstrmojo.provide("mstrmojo._IsMovable", {
        /**
         * Whether or not this widget is draggable/movable.
         *
         * @type Boolean
         * @default true
         */
        draggable: true,

        /**
         * Whether or not this widget controls its own avatar when dragged. By default, for a movable object/widget, we do not show
         * any avatar, instead, we just change the mouse cursor to 'move' style.
         *
         *  @type Boolean
         *  @default true
         */
        ownAvatar: true,

        /**
         * A method that returns the movable handle node.
         *
         * @type HTMLElement
         * @default this.domNode
         */
        getMovingHandle: function getMovingHandle() {
            return this.domNode;
        },

        /**
         * A method that returns the target of the move.
         *
         * @type HTMLElement
         * @default this.domNode
         */
        getMovingTarget: function getMovingTarget() {
            return this.domNode;
        },

        /**
         * Handler when dragging starts.
         *
         *  @ignore
         */
        ondragstart: function ondragstart(c) {
            var handle = this.getMovingHandle(),
                targetStyle = this.getMovingTarget().style;

            // Is the moving handle within the source node?
            var shouldBeginDrag = $D.contains(handle, c.src.node, true, document.body);
            if (shouldBeginDrag) {
                // Call cursor hack.
                cursorHack(false);

                // Set moving handle cursor to move.
                handle.style.cursor = 'move';

                // Cache the left and top positions as well as the handle height and width.
                this._leftPos = parseInt(targetStyle.left, 10);
                this._topPos = parseInt(targetStyle.top, 10);
                this._hWidth = handle.clientWidth;
                this._hHeight = handle.clientHeight;
            }

            return shouldBeginDrag;
        },

        /**
         * Handler when dragging.
         *
         *  @ignore
         */
        ondragmove: function ondragmove(c) {
            var targetPosition = c.tgt.pos,
                srcPosition = c.src.pos,
                targetStyle = this.getMovingTarget().style;

            // Position target at cached position plus delta.
            // TQMS #536942: Don't allow the element to be dragged such that the handle is no longer on the screen.
            targetStyle.left = this.left = Math.max(this._leftPos + targetPosition.x - srcPosition.x, -this._hWidth + 40) + 'px';
            targetStyle.top = this.top = Math.max(this._topPos + targetPosition.y - srcPosition.y, -this._hHeight + 10) + 'px';
        },

        /**
         * Handler when dragging ends.
         *
         *  @ignore
         */
        ondragend: function ondragend(c) {
            // Call cursor hack.
            cursorHack(true);

            // Reset moving handle cursor to default.
            this.getMovingHandle().style.cursor = 'default';

            // Clear left and top position and handle height and width.
            delete this._leftPos;
            delete this._topPos;
            delete this._hWidth;
            delete this._hHeight;
        }
    });
}());
(function(){
    
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.css");
    
    /**
     * <p>A map for common formatting style properties.</p>
     * 
     * <dl>
     *      <dt>T</dt>
     *      <dd>position, i.e. top and left.</dd>
     *      
     *      <dt>D</dt>
     *      <dd>dimension, i.e. height and width.</dd>
     *      
     *      <dt>B</dt>
     *      <dd>border, split into color, style and width components.</dd>
     *      
     *      <dt>F</dt>
     *      <dd>common font formatting.</dd>
     *      
     *      <dt>P</dt>
     *      <dd>padding, with 1, 2, 3 or 4 property values.</dd>
     *      
     * </dl>
     * 
     * @type Object
     * 
     * @private
     * @ignore
     */
    var commonProps = {
        T: [ 'top', 'left' ],
        D: [ 'height', 'width' ],
        B: [ 'border', 'border-color', 'border-style', 'border-width' ],
        F: [ 'font', 'color', 'text-decoration' ],
        P: [ 'padding' ]
    };
    
    /**
     * Combines common rw unit formatting properties top, left, height, width and zIndex.
     *
     * @type String[]
     * 
     * @private
     * @ignore
     */ 
    commonProps.RW = ['z-index'].concat(commonProps.T.concat(commonProps.D));
    
    /**
     * Shortcut to dom class.
     * 
     * @private
     * @ignore
     */
    var $D = mstrmojo.dom;
    
    /**
     * Utility function to initialize and populate effects property array.
     * 
     * @param {Object} An object to hold fx properties and values.
     * @param {String} The name of the fx property.
     * @param {String} The new value.
     * 
     * @private
     * @ignore
     */
    function pushFxProperty(fx, n, v) {
        // Extract or initialize value array.
        var p = fx[n] || [];
        // Set new value.
        p.push(v);
        // Set value array back onto fx object.
        fx[n] = p;
    }
    
    /**
     * <p>A mixin for formatting {@link mstrmojo.Widget}s based on MicroStrategy Report Services document definitions.</p>
     * 
     * @class
     * @public
     */
    mstrmojo._Formattable = 
        /**
         * @lends mstrmojo._Formattable#
         */
        {
            _mixinName: 'mstrmojo._Formattable', 
            
            /**
             * Specifies which formatting properties should be applied to which dom slots.
             * @type Object
             */
            formatHandlers: null,
            
            /**
             * Utility function for generating cache key.
             * 
             * @param {mstrmojo.Widget} w The current widget.
             * 
             * @private
             * @ignore
             */
            getCacheKey: function getCacheKey(w) {
                return 'csscache' + (w.thresholdId || '');
            },

            update: function update(node) {
                //TQMS 673119
                this.invisible = !!(node && node.data && node.data.invisible);
                
                if (this._super) {
                    this._super(node);
                }
            },
            
            /**
             * <p>Builds css text for dom slots during rendering.</p>
             * 
             * <p>Extends the widget's preBuildRendering method in order to first build cssText strings
             * from the widget's formatting properties & store the strings in widget properties, 
             * which can then be applied to the rendering.</p>
             * 
             * @returns {Boolean} True
             */            
            preBuildRendering: function preBuildRendering() {
                if (this._super) {
                    this._super();
                }
                
                // Do we have a cache of resolved formatting strings?
                var defn = this.defn;
                if (!defn) {
                    defn = this.defn = {};
                }
                var cacheKey = this.getCacheKey(this),
                    cache = defn[cacheKey];
                if (!cache) {
                    // We don't have a cache. Create and cache formatted strings now.                
                    cache = defn[cacheKey] = {};
                    
                    // Get the formats for this object.
                    var fmts = this.getFormats();
                    if (fmts) {
                    
                        // Step through the collection of slots to be formatted.
                        var fhs = this.formatHandlers;
                        for (var slot in fhs) {
                            var handle = fhs[slot];
                            
                            // Resolve the src (default to format).
                            var src = handle.src? fmts[handle.src] : fmts;
                            if (!src) {
                                return;
                            }
                            
                            // Initialize an array to hold string fragments.
                            var css = [];
                            var x = -1;
                            
                            // Create the name of the slot this will be 
                            var slotCss = slot + 'CssText';
                            
                            // Get the format node.
                            var props = handle.props || handle;
                            if (!props) {
                                continue;
                            }
                            
                            // Step through the collection of properties to apply.
                            for (var bp = props.length-1; bp >= 0; bp--) {
                                var p = props[bp];
                                
                                // If the property is an enumeration from commonProps then use that, otherwise an array with the single property.
                                var c = commonProps[p] || [ p ];
                                
                                // Step through the resolved collection of properties.
                                for (var z = c.length-1; z >= 0; z--) {
                                    // Reset the property name.
                                    p = c[z];
                                    
                                    // Is this property present in the formats?
                                    if (p in src) {
                                        // Is this the 'fx' property?
                                        if (p === 'fx') {
                                            var f = src[p],
                                                fx = {};
                                            
                                            // Format the gradient (if present).
                                            if ('gd' in f) {
                                                this.formatGradient(f.gd, fx);
                                            }
                                            
                                            // Format the text rotation (if present).  We need to do this before drop shadow so the shadow appears in the correct
                                            // position in IE.
                                            if ('rt' in f) {
                                                if(f.rt == 1 || f.rt == 3) this.formatTextRotation(f.rt, fx);
                                            }
                                            
                                            // Format the drop shadow (if present).
                                            if ('ds' in f) {
                                                this.formatDropShadow(f, fx);
                                            }
                                            
                                            // Iterate the fx object.
                                            for (var fp in fx) {
                                                // Join all elements with space (really only needed for IE filter property).
                                                css[++x] = fp + ':' + fx[fp].join(' ');
                                            }
                                        } else {
                                            css[++x] = p + ':' + src[p];
                                        }
                                    }
                                }
                            }
                            //TQMS 673119
                            if ( this.invisible) {
                            	css.push("visibility:hidden");
                            }
                            
                            // Store the aggregated css style text in the slotCssText property. 
                            this[slotCss] = cache[slotCss] = css.join(';') + ';';
    
                        } // end for each slot in fhs
                    } // if fmts
                } else {
                    // Restore from cache.
                    for (var n in cache) {
                        this[n] = cache[n];
                    }
                }            
                return true;
            },
            
            /**
             * Builds the browser specific css for gradients.
             * 
             * @param {Object} gp The gradient properties node as retrieved from the fx formatting node.
             * @param {Integer} gp.t The type of gradient.
             * @param {String} gp.sc The start color of the gradient.
             * @param {String} gp.ec The end color of the gradient.
             * @param {Object} fx An object to hold the new formatting property values.
             */
            formatGradient: function formatGradient(gp, fx) {
                var gd = mstrmojo.css.buildGradient(gp.t, gp.sc, gp.ec);
                if (gd) {
                    pushFxProperty(fx, gd.n, gd.v);
                }
            },
            
            /**
             * Builds the browser specific css for drop shadows.
             * 
             * @param {Object} f The rw unit format node.
             * @param {Object} fx An object to hold the new formatting property values.
             */
            formatDropShadow: function formatDropShadow(f, fx) {
                if ($D.supports($D.cssFeatures.DROP_SHADOW)) {
                    var ds = f.ds;
                    
                    if ($D.isDXIE) {
                        pushFxProperty(fx, 'filter', "progid:DXImageTransform.Microsoft.DropShadow(Color='#66000000',Positive='true',OffX=" + ds + ",OffY=" + ds + ")");
                    } else {
                        var v = [ ds, ds ];
                        
                        // Is the text rotated? 
                        if (f.rt == 1 || f.rt == 3) {
                            // Adjust either the first or second value (based on rotation angle) so that shadow appears in the correct position.
                            v[((f.rt === 1) ? 1 : 0)] = -ds;
                        }
                        
                        pushFxProperty(fx,  ($D.isWK ? '-webkit-' : '') + 'box-shadow', v.join('px ') + 'px 3px 0px #888');
                    }
                }
            }, 
            
            /**
             * Builds the browser specific css for text rotation.
             * 
             * @param {Integer} tr The text rotation value (1 or 3).
             * @param {Object} fx An object to hold the new formatting property values.
             */
            formatTextRotation: function formatTextRotation(tr, fx) {
                if ($D.supports($D.cssFeatures.TEXT_ROTATION)) {
                    if ($D.isDXIE) {
                        pushFxProperty(fx, 'filter', 'progid:DXImageTransform.Microsoft.BasicImage(rotation=' + tr + ')');
                    } else {
                        
                        // The number of degrees to rotate (depending on the type of rotation)...
                        var degrees = (tr === 1) ? 90 : -90;
                        
                        // Rotate about the top-left corner of the element...
                        pushFxProperty(fx, $D.CSS3_PREFIX + 'transform-origin', 'top left');
                        
                        // Rotate the specified number of degrees...
                        // NOTE: For rt==1, we can omit the postBuildRendering stop of relocating the left
                        // position if we are passed the outer height of the text field (which would
                        // be saved in MD as a text width). Assuming it was present, we could add a 
                        // 'translateX' directive (with the text height as its argument) before the
                        // 'rotate' directive as:
                        //
                        // -moz-transform: translateX(22px) rotate(90deg)
                        pushFxProperty(fx, $D.CSS3_PREFIX + 'transform', 'rotate(' + degrees + 'deg)');
                    }
                }
            },
            
            /**
             * Returns the format for this widget from the formatResolver.
             *  
             * @returns {Object} The resolved formats for this widget.
             */
            getFormats: function getFormats() {
                if (!this.fmts) {
                       this.fmts = this.formatResolver.getFormat(this.defn, this.thresholdId);    // formatResolver now expects defn object arg, not key string
                }
                
                return this.fmts;
            },
            
            clearCache: function clearCache() {
                // Clear the format cache for next render.
                delete this.defn[this.getCacheKey(this)];
            },
            
            unrender: function unrender(ignoreDom) {
                // Do we have a thresholdId?
                // TODO: Is this.thresholdId a correct indication ? Should  we use a more specific and persistent boolean instead e.g. what if after a selector action, a textfield doesn't have any conditional formatting applied any more ?
                if (this.thresholdId) {
                    // Clear the cached fmts node.
                    this.fmts = null;
                }
                
                this._super(ignoreDom);
            }
            
        };
    
    /**
     * Returns the individual border width values for the supplied widget (in pixels, but without the unit identifier).
     * 
     * @param {mstrmojo.Widget} w The widget whose border widths should be calculated.
     * 
     * @returns {Object} An object with 't' (top), 'r' (right), 'b' (bottom), 'l' (left), 'h' (top  + bottom) and 'w' (left + right) properties which contain the 
     *  individual border widths (in pixels) for the supplied {@link mstrmojo.Widget}.
     * 
     * @static
     */
    mstrmojo._Formattable.getBorderWidths = function(w) {
        var f = w.getFormats(),
            b = ('border' in f) ? f.border.match(/(\d*|\d*\.\d*)pt/)[0] : f['border-width'],    // Extract border widths from either border or border-width.
            dpi = w.model.docModel ? w.model.docModel.dpi : w.model.dpi; 
        return mstrmojo.css.getBorderWidths(b, dpi);
        };
    
})();
(function(){
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.css", "mstrmojo.array");
    
    var ROW_AXIS = 1, COL_AXIS = 2;
    
    // Only apply to header values
    function _isOfSameUnit(/*Object*/c1, /*Object*/c2){
        return _isOfSameTitle(c1, c2) && c1.o === c2.o;
    }
    
    // Apply to both header values and metric values
    function _isOfSameTitle(/*Object*/c1, /*Object*/c2){
        return c1 && c2 && c1.ui === c2.ui && c1.axis === c2.axis && c1.mix === c2.mix;
    }
    
    function _addToSelection(/*domNode*/td, /*Object*/cell, /*Widget*/ w){
        var ttlId = w.getCellTitleId(cell),
            idx = w.getCellUnitIndex(cell);
        w.selections[ttlId] = w.selections[ttlId] || {};
        w.selections[ttlId][idx] = w.selections[ttlId][idx] || [];
        w.selections[ttlId][idx].push(td);
        _hilite(td);
    }
    
    function _clearSelection(/*Widget*/ w){
        var sel = w.selections;
        for (var i in sel){
            for (var j in sel[i]){
                for (var k=0, len=sel[i][j].length;k<len;k++){
                    _unHilite(sel[i][j][k]);
                }
            }
        }
        w.selections = {};
    }
    
    function _hilite(/*domNode*/td){
        mstrmojo.css.setOpacity(td, 50);
    }
    
    function _unHilite(/*domNode*/td){
        mstrmojo.css.setOpacity(td, 100);
    }
    
    // how many forms this cell title has?
    function _getFormCount(/*Object*/cell, /*Widget*/w){
        // If the cell is not a metric value
        if (cell.mix === undefined){
            var titles = w.gridData.gts[cell.axis === ROW_AXIS?'row':'col'],
                ttl = titles[cell.tui || cell.ui],
                count = 0;
            for (var i=0, len=titles.length;i<len;i++){
                // The forms belong to the same attribute has the same "id" property value
                if (titles[i].id === ttl.id){
                    count++;
                }
            }
            return count;
        }
        return 0;
    }
    
    mstrmojo._XtabSelections = 
        {
            /**
             * The previously table cell selected while SHIFT key is not pressed.  
             * It will be used as an end point during the range selection.
             */
            lastSelectedTD: null,
            
            /**
             * Select/Unselect a single table cell. If the cell has multiple forms, they should be selected as well.  
             * @param td HTMLElement  
             * @param toggle boolean whether to unselect the cell if it's already selected 
             */
            singleSelect: function singleSelect(td, toggle){
                var data = this.getCellForNode(td),
                    row = td.parentNode;
                
                // In toggle mode(when the ctrl key is down), unselect the cell if it's already selected.
                if (toggle){
                    var ttlId =  this.getCellTitleId(data), 
                        idx = this.getCellUnitIndex(data);
                        selectedTitle = this.selections[ttlId];
                        selectedUnit = selectedTitle && selectedTitle[idx];
                    if (selectedUnit){
                        //A 'unit' may contain multiple form cells. We need un-highlight all of them.
                        for (var i = 0, len = selectedUnit.length; i < len; i++){
                            _unHilite(selectedUnit[i]);
                        }
                        delete selectedTitle[idx];// remove from the selections
                        return;
                    }
                }
                
                //number of forms that we are going to find
                var totalForms = _getFormCount(data, this);

                if (data.axis === ROW_AXIS) {
                    // Check the current row
                    for (var i = 0, formFound = 0, len = row.cells.length; i < len && formFound < totalForms; i++){
                        var tc = row.cells[i], tcData = this.getCellForNode(tc);
                        if (_isOfSameUnit(tcData, data)){
                            _addToSelection(tc, tcData, this);
                            formFound++;
                        }
                    }
                } else if (data.axis === COL_AXIS) {
                    var table = mstrmojo.dom.findAncestorByName(td, 'table', false),
                    rows = table.rows;
                    //Iterate through rows until all the forms are found
                    for (var i = 0, formFound = 0, len = rows.length; i < len && formFound < totalForms; i++){
                        var cells = rows[i].cells;
                        //At most one form can be found on one row.
                        for (var j = 0, len2 = cells.length; j < len2; j++){
                            var tc = cells[j], tcData = this.getCellForNode(tc);
                            if (_isOfSameUnit(tcData, data)){
                                _addToSelection(tc, tcData, this);
                                formFound++;
                                break;
                            }
                        }
                    }
                } else { // metric value
                    _addToSelection(td, data, this);
                }
                
            },
            
             
            /**
             * Select a sequence of consecutive table cells
             */            
            rangeSelect: function rangeSelect(fromTD, toTD){
                var fromCell = this.getCellForNode(fromTD), 
                    toCell = this.getCellForNode(toTD);
                
                if (_isOfSameTitle(fromCell, toCell)){
                    // make sure fromCell is at the leftside / topside
                    if (fromCell.o > toCell.o || fromCell._ei > toCell._ei){
                        var tmp = fromTD;
                        fromTD = toTD; fromCell = this.getCellForNode(fromTD);
                        toTD = tmp; toCell = this.getCellForNode(toTD);
                    }
                    
                    var totalForms = _getFormCount(fromCell, this),
                        axis = fromCell.axis,
                        table = mstrmojo.dom.findAncestorByName(fromTD, 'table', false),
                        rows = table.rows,
                        fromRow = fromTD.parentNode,
                        fromRowIdx = fromRow.rowIndex,
                        fromRowCells = fromRow.cells,
                        toRowIdx = toTD.parentNode.rowIndex;
                    
                    if (axis === ROW_AXIS) {
                        for (var i = fromRowIdx; i <= toRowIdx; i++){//The range is determined by fromCell and toCell
                            var cells = rows[i].cells, found1 = false;
                            
                            // find all the forms
                            for (var j = 0, len = cells.length, formFound = 0; j < len && formFound < totalForms; j++){ 
                                var tc = cells[j], tcData = this.getCellForNode(tc);
                                if (_isOfSameTitle(tcData, fromCell)){
                                    _addToSelection(tc, tcData, this);
                                    formFound++;
                                }
                            }
                        }
                    }else if (axis === COL_AXIS){
                        for (var i = 0, len = rows.length, formsFound = 0; i < len && formsFound < totalForms; i++){
                            var cells = rows[i].cells, shouldSelect = false;
                            for (var j = 0, len2 = cells.length; j < len2; j++){ 
                                var tc = cells[j], tcData = this.getCellForNode(tc);
                                if (_isOfSameUnit(tcData, fromCell)){ 
                                    //Found the start position, we should add the cell to the selection from now on until we reach the end position
                                    shouldSelect = true;
                                }
                                if (shouldSelect){
                                    _addToSelection(tc, tcData, this);
                                }
                                if (_isOfSameUnit(tcData, toCell)){ 
                                    //Reach the last cell, no more cells need to be selected.
                                    break;
                                }
                            }
                            if (shouldSelect){
                                formsFound++;
                            }
                        }
                    }else{ // metric value
                        if (fromRowIdx == toRowIdx){
                            // The cells to select are on the same row.
                            for (var i = fromTD.cellIndex, len = toTD.cellIndex; i <= len; i++){
                                var tc = fromRowCells[i], tcData = this.getCellForNode(tc);
                                _addToSelection(tc, tcData, this);
                            }
                        }else{
                            //The cells to select are on the same column.
                            for (var i = fromRowIdx, len = toRowIdx; i <= len; i++){
                                var cells = rows[i].cells;
                                for (var j = 0, len2 = cells.length; j < len2; j++){
                                    var tc = cells[j], tcData = this.getCellForNode(tc);
                                    if (_isOfSameTitle(tcData, fromCell)){
                                        _addToSelection(tc, tcData, this);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            },
            
            /**
             * This event is called from the onclick handler of the XtabBase.
             * Given info about a click event (such as the target), updates this selection's properties according to the targeted cell.
             * With Ctrl/Shift key down, user can select multiple cells.
             * Currently, only interactive cells can be added to the selection.  
             */
            doSelection: function(/*DomEvent?*/ e, /*DomWindow?*/ hWin, /*Object*/ td) {
                var d = mstrmojo.dom,
                    ctrl = d.ctrlKey(hWin, e),
                    shift = d.shiftKey(hWin, e);
                    
                if (!ctrl){
                    _clearSelection(this);
                }
                
                var data = this.getCellForNode(td);
                var isHeaderValue = data && (data.mix === undefined && data.o !== undefined),
                    isMetricValue = data && (data.mix !== undefined && (data._lp || data._tp));
                
                if (isHeaderValue || isMetricValue) { //It's an interactive cell and not on the grid title.
                    if (shift) {
                        this.rangeSelect(this.lastSelectedTD, td);
                    } else {
                        this.singleSelect(td, ctrl);
                        this.lastSelectedTD = td; 
                    }
                }
            }
        };
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.string",
                         "mstrmojo.css");

    var touchClass = 'tx-touch',
        HOLD_TIME = 100,
        previewMarkup = '<div class="mstrmojo-dicPreview dicx{@t} {@x}" ' +
                          'ontouchstart="mstrmojo.all[\'{@id}\'].previewTouchStart()";>' +
                             '<div>' +
                                 '<div>{@v}</div>' +
                             '</div>' +
                         '</div>';

    mstrmojo.android._HasPreviewButton = mstrmojo.provide(

        "mstrmojo.android._HasPreviewButton",

        {
            _mixinName: "mstrmojo.android._HasPreviewButton",

            renderPreview: function renderPreview() {
                // Call _HasPreviewButton minxin function to render the button.
                var openerNode = this.openerNode,
                    group = this.group || this,
                    showFullPreview = (group.openerType === 2) || !!this.dic.dm || this.dicChanged;   // Default to full preview if opener type is field group OR control is inline OR dic data has changed.

                this.renderPreviewButton(openerNode, showFullPreview ? this.dv : openerNode.innerHTML);
            },

            /**
             * Replace a given dom node with created preview button.
             * @param {HTMLElement} target The dom node to placing the button with.
             * @param {String} value The text value showing inside the preview button
             */
            renderPreviewButton: function renderPreviewButton(target, value) {
                var dic = this.dic,
                    dicType = dic.t,
                    group = this.group || this,
                    showPreview = false,                    // Default to no preview.
                    showArrow = true,                       // Default to visible drop down arrow.
                    $TYPES = mstrmojo.DICConfig.TYPES,
                    cls = [];


                // Adjust show arrow for DIC type.
                switch (dicType) {
                case $TYPES.SLIDER:
                case $TYPES.TEXTAREA:
                    // Show arrow if NOT inline.
                    showArrow = !dic.dm;
                    break;

                case $TYPES.SWITCH:
                case $TYPES.TOGGLE:
                case $TYPES.RATING:
                case $TYPES.STEPPER:
                case $TYPES.LIKERTSCALE:
                    // Never show arrow because these types they are inherently inline.
                    showArrow = false;
                    break;
                }

                // Is the DIC a text field?
                if (group.openerType === 2) {
                    // Show preview if drop down arrow is visible.
                    showPreview = showArrow;
                }

                // Are we showing the arrow?
                if (showArrow) {
                    // Clear border and padding on target.
                    var targetStyle = target.style;
                    targetStyle.border = '';
                    targetStyle.padding = '';

                    // Add the arrow class.
                    cls.push('arw');

                    // Are we showing the preview?
                    if (showPreview) {
                        // Add preview class.
                        cls.push('prv');
                    }
                }

                var id = this.id;
                // Replace target inner HTML with preview.
                target.innerHTML = mstrmojo.string.apply(previewMarkup, {
                    t: dicType,
                    v: value || '&nbsp;',                   // Use non-breaking space so control doesn't collapse for empty value.
                    id: id,
                    x: cls.join(' ')
                });

                // Cache preview node.
                this._previewNode = target.firstChild;
                
                // TQMS 724930 put the centralize the icon code back by applying extra css text
                if(this.inlineExtraCssText) {
                    this._previewNode.style.cssText += ' ' + this.inlineExtraCssText;
                }
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                var previewNode = this._previewNode,
                    childNode = previewNode && previewNode.firstChild;

                // Add active class to preview node first child or passed in dom node (if no preview, which is typically an inline widget).
                mstrmojo.css.addClass(childNode || d, 'tx-active');
            },

            previewTouchStart: function previewTouchStart() {
                var me = this;
                mstrmojo.css.addClass(me._previewNode, touchClass);
                if (this._holderTimer) {
                    clearTimeout(this._holderTimer);
                }
                this._holdTimer = setTimeout(function() {
                    delete me._holdTimer;
                    mstrmojo.css.removeClass(me._previewNode, touchClass);
                }, HOLD_TIME);
            }
        }
    );

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.string",
                         "mstrmojo.css");

    /**
     * <p>A mixin for {@link mstrmojo.DocTextfield}s and {@link mstrmojo.DocImage}s
     * that have hyperlinks.</p>
     *
     * @class
     * @public
     */
    mstrmojo._HasDocLink = mstrmojo.provide(
        'mstrmojo._HasDocLink',

        /**
         * @lends mstrmojo._HasDocLink.prototype
         */
        {
            _mixinName: 'mstrmojo._HasDocLink',

            url: '',

            target: '',

            linkEnabled: true,

            ifw: '',

            /**
             * Capture the url and target properties from the element.
             *
             * @ignore
             */
            update: function update(node) {
                var d = node.defn;

                // Cache the URL.
                this.url = node.data.url || d.url;

                // Do we have a target?
                if (d.target) {
                    // Cache it.
                    this.target = d.target;
                }

                if (d.ifw) {
                    this.ifw = d.ifw;
                }

                this._super(node);
            },

            /*
            destroy: function destroy(ignoreDom) {
                //TQMS 618291.
                var doc = this.controller.view;
                if (doc && doc.removeLinkInfo) {
                    doc.removeLinkInfo(this.id);
                }

                this._super(ignoreDom);
            },
            */

            postBuildRendering: function postBuildRendering() {
                // Does this component have a URL?
                if (this.url || this.ifw) {
                    // Add class to dom node so cursor will change to pointer.
                    mstrmojo.css.addClass(this.domNode, 'hasLink');
                }

                //TQMS 618291.
                var doc = this.controller.view,
                    layout = doc && doc.getCurrentLayout();
                if (layout && layout.addLinkInfo) {
                    layout.addLinkInfo(this.id, {
                        url: this.url,
                        target: this.target,
                        src: this
                    });
                }

                return this._super();
            },

            //TQMS 618291.
            setLinkEnabled: function setLinkEnabled(value) {
                this.linkEnabled = value;
                var node = this.domNode;
                if (!node) {
                    return;
                }

                var childNodes = node.childNodes,
                    lastChild = childNodes[childNodes.length - 1],
                    maskId = this.id + '_mask',
                    mask = (lastChild.id === maskId) ? lastChild : null;

                if (value) {
                    if (mask) {
                        node.removeChild(mask);
                        delete this._mask;
                    }

                } else {
                    if (!mask) {
                        mask = document.createElement('div');
                        mask.className = 'mstrmojo-DocLinkMask';
                        mask.id = maskId;
                        mask.innerHTML = '&nbsp;';
                        node.appendChild(mask);
                    }
                }
            },

            onclick: function () {
                //TQMS 618291.
                if (this.linkEnabled) {
                	var drillLinkItems = this.drillLinkItems,
                        defaultLink = drillLinkItems && drillLinkItems[0];
                        url = this.url || (defaultLink && defaultLink.url);

                    // Is this an info window?
                    if (this.ifw) {
                        this.model.showInfoWin(this.ifw, (this.getAnchor && this.getAnchor()) || this.domNode, 'v', true);

                    // Is this a link?
                    } else if (url) {
                        this.model.executeLink(url, this.target, this);
                    }
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.css");

    /**
     * <p>A mixin for adding horizontal selector rendering support.</p>
     *
     * @class
     * @public
     */
    mstrmojo.android.selectors._SupportsHoriz = mstrmojo.provide(

        "mstrmojo.android.selectors._SupportsHoriz",

        /**
         * @lends mstrmojo.android.selectors._SupportsHoriz.prototype
         */
        {
            _mixinName: 'mstrmojo.android.selectors._SupportsHoriz',

            scrollerConfig: {
                bounces: false,
                showScrollbars: false
            },

            minItemHeight: 25,

            getItemProps: function getItemProps(item, idx) {
                // Get default props.
                var props = this._super(item, idx),
                    h = this.height,
                    itemCnt = this.items.length,
                    lineHeight;

                // Change tag to label.
                props.tag = 'label';
                props.n = props.n || "&nbsp";

                // Is the selector horizontal?
                if (this.isHoriz) {
                    // Do we have a specified height?
                    if (h) {
                        // Set line-height to height of control so that the cell is the same height as the row.
                        lineHeight = h;
                    }

                    // Should all items be the same width?
                    if (this.itemWidthMode === 0) {
                        // Add width to item style.
                        props.style += 'width:' + Math.floor(100 / itemCnt) + '%;';
                    }

                } else {
                    // Do we have a specified height?
                    if (h) {
                        // Calculate line-height for single item.
                        lineHeight = Math.round(parseInt(h, 10) / itemCnt);

                        // TQMS #551364: Make sure the line-height is not smaller than the minimum item height?
                        lineHeight = Math.max(lineHeight, this.minItemHeight);

                        // Add pixels.
                        lineHeight += 'px';
                    }

                }

                // Do we have a calculated line height?
                if (lineHeight) {
                    // Apply to item style.
                    props.style += 'line-height:' + lineHeight + ';';
                }

                return props;
            },

            init: function init(props) {
                this._super(props);

                // Is this horizontal orientation?
                if (this.isHoriz) {
                    // Change display from default (block) to table.
                    this.cssDisplay = 'table';

                    // Add horizontal class.
                    var cls = [ 'horiz' ];

                    // Should all items be the same width?
                    if (this.itemWidthMode === 0) {
                        // Add fixedItems class.
                        cls.push('fixedWidth');
                    }

                    // Add collection of css classes.
                    mstrmojo.css.addWidgetCssClass(this, cls);
                }

            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    scrollEl = this.itemsContainerNode,
                    dimension = 'Height',
                    axis = 'y',
                    scroll = 'v',
                    offset = {};

                // Is the selector horizontal?
                if (this.isHoriz) {
                    // Convert to horizontal.
                    dimension = 'Width';
                    axis = 'x';
                    scroll = 'h';
                }

                // Add the scrollEl to the scroll config.
                cfg.scrollEl = scrollEl;

                // Is there a fixed size for this dimension?
                var size = this[dimension.toLowerCase()];
                if (size) {
                    // Parse.
                    size = parseInt(size, 10);

                    // Calculate offset end (scroll element node dimension size minus widget dimension size).
                    var offsetEnd = Math.max(scrollEl['offset' + dimension] - size, 0),
                        enableDimensionScroll = cfg[scroll + 'Scroll'] = (offsetEnd !== 0);

                    // Can we scroll in this dimension?
                    if (enableDimensionScroll) {
                        // Add offset value for appropriate axis.
                        offset[axis] = {
                            start: 0,
                            end: offsetEnd
                        };
                    }
                }

                // Add computed offset to config.
                cfg.offset = offset;

                // Add origin, initializing to 0,0 if we don't have one.
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                return cfg;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.string",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $DOM = mstrmojo.dom,
        $CSS = mstrmojo.css,
        clsSelected = 'selected';

    function delegateSelect(mthName, el, item, idx, widget) {
        // If the widget has a custom hook than call it and check return value.
        var hook = widget.listHooks[mthName];
        if (hook && hook.call(widget, el, item, idx)) {
            // Hook returned true so exit.
            return;
        }

        // Hook returned false so use default selection behavior.
        $CSS[((mthName === 'select') ? 'add' : 'remove') + 'Class'](el, clsSelected);
    }

    function addToCollection(propertyName, delimiter, values) {
        // Retrieve delimited string of existing values (or empty array if none).
        var existing = this[propertyName],
            arr = (existing) ? existing.split(delimiter) : [];

        // Add new values.
        arr = arr.concat(values.split(delimiter));

        // Store values back on instance.
        this[propertyName] = arr.join(delimiter);

        // Return the index of the last added value.
        return arr.length - 1;

    }

    /**
     * <p>A mixin for adding specific behavior to subclasses of {@link mstrmojo.ListBase}.</p>
     *
     * @class
     * @public
     */
    mstrmojo._IsList = mstrmojo.provide(

        "mstrmojo._IsList",

        /**
         * @lends mstrmojo._IsList.prototype
         */
        {
            _mixinName: 'mstrmojo._IsList',

            /**
             * Collection of item renderer hooks that can be implemented by consumers of this mixin (for custom selection code).
             */
            listHooks: {},

            /**
             * Method for generating markup for each item.
             *
             * @param {Object} item The item that will use the markup.
             * @param {Integer} idx The index of the item to render.
             *
             * @returns The markup string for the given item containing tokens for dynamic data replacement.
             */
            getItemMarkup: function (item, idx) {
                return '<{@tag} class="item {@cls}" idx="{@idx}" style="{@style}">{@n}</{@tag}>';
            },

            /**
             * Returns an object with markup string token replacement values for the given item.
             *
             * @param {Object} item The item to render.
             * @param {Integer} idx The index of the item.
             *
             * @returns Object
             */
            getItemProps: function getItemProps(item, idx) {
                var isSelected = !!this.selectedIndices[idx];
                return {
                    tag: 'div',                                                 // Markup root tag name.
                    sel: isSelected,                                            // True if the item is selected.
                    cls: (isSelected) ? clsSelected : '',                       // Item CSS class name.
                    n: item.n || '',                                            // Item text.
                    style: '',                                                  // Item CSS text.
                    idx: idx,
                    addCls: function (cls) {
                        addToCollection.call(this, 'cls', ' ', cls);
                    },
                    addStyle: function (s) {
                        addToCollection.call(this, 'style', ';', s);
                    }
                };
            },

            itemRenderer: {
                render: function (item, idx, widget) {
                    // Add render index to item.
                    item._renderIdx = idx;

                    // Create and return markup.
                    return mstrmojo.string.apply(widget.getItemMarkup(item, idx), widget.getItemProps(item, idx));
                },

                select: function (el, item, idx, widget) {
                    delegateSelect('select', el, item, idx, widget);
                },

                unselect: function (el, item, idx, widget) {
                    delegateSelect('unselect', el, item, idx, widget);
                }
            },

            onclick: function onclick(evt) {
                try {
                    // Select the element.
                    var target = evt.target || $DOM.eventTarget(evt.hWin, evt.e),
                        item = $DOM.findAncestorByAttr(target, 'idx', true, this.domNode),
                        idx = item && parseInt(item.value, 10);

                    if (idx !== null && !isNaN(idx)) {
                        // Is this a radio list?
                        if (!this.multiSelect) {
                            // Single select.
                            this.singleSelect(idx);

                        } else {
                            // Grab the selected indices and figure out whether we need to perform an add or remove.
                            var m = (this.selectedIndices[idx]) ? 'remove' : 'add';

                            // Trigger the addSelect or removeSelect method.
                            this[m + 'Select'](idx);

                        }
                    }
                } catch (ex) {
                    // This is a top level exception handler so we display the error to the user
                    // and do not re-throw the exception.
                    mstrApp.onerror(ex);
                }
            }
        }
    );

    /**
     * The class name added to selected items.
     *
     * @type String
     * @static
     */
    mstrmojo._IsList.SELECTED_CLS = clsSelected;

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.registry",
                         "mstrmojo.array",
                         "mstrmojo.publisher");

    var _R = mstrmojo.registry,
        _A = mstrmojo.array,
        _P = mstrmojo.publisher;

    /**
     * <p>Pre-processing for a new child. Converts a given JSON object into a script class instance,
     * and sets its parent.</p>
     *
     * @param {Object} p The parent to which a child is about to be added.
     * @param {Object} c The child which is about to be added.
     *
     * @private
     */
    function _preAdd(p, c) {
        if (c) {
            c.parent = p;
            return _R.ref(c);
        }
        return null;
    }

    /**
     * <p>Post processing for a new child. Sets an alias reference on the parent to the child.</p>
     *
     * @param {Object} p The parent to which a child has been added.
     * @param {Object} c The child which has been added.
     *
     * @private
     */
    function _postAdd(p, c) {
        if (c && c.alias != null) { // if alias is not null AND not undefined
            p[c.alias] = c;
        }
    }

    /**
     * <p>Post processing for a newly removed child. Clears the alias reference on the parent and
     * the parent reference on the child.</p>
     *
     * @param {Object} p The parent to which a child has been added.
     * @param {Object} c The child which has been added.
     *
     * @private
     */
    function _postRmv(p, c) {
        var a = c.alias;
        if (c.parent === p) {
            delete c.parent;
        }
        if ((a != null) && (p[a] === c)) {  // if alias is not null AND not undefined
            delete p[a];
        }
    }

    /**
     * <p>Converts an array of child references to a new array of child objects.</p>
     *
     * <p>Each array member that is a child reference will be replaced by the evaluation of that reference; the evaluation
     * is done via the mstrmojo.registry.ref method. If the evaluation results in null, the array member is removed.
     * Each array member that is already a child object will remain intact.</p>
     *
     * <p>Each array member will have its parent set, and the parent will have alias references set to the children
     * (for each child that specifies an alias).</p>
     *
     * @param {Object} p The parent to which children will be added.
     * @param {Object[]} refs An array of either child references or child objects.
     * @returns {Object[]} An array of child objects, if successful; otherwise, an empty array or null.
     * @private
     */
    function makeCh(p, refs) {
        var len = refs && refs.length,
            ch,
            i;

        if (len) {
            ch = [];
            for (i = 0; i < len; i++) {
                var c = _preAdd(p, refs[i]);
                if (!c) {
                    continue;
                }
                ch.push(c);
                _postAdd(p, c);
            }
        }
        return ch;
    }

    /**
     * <p>A mixin that equips an observable object with methods for managing an array of children.</p>
     *
     * <p> The children list is maintained in a "children" property (type: Array of Objects). Additions and removals
     * of children in the list raise events that can be handled by this or other objects.</p>
     *
     * @class
     * @public
     */
    mstrmojo._HasChildren = mstrmojo.provide(

        "mstrmojo._HasChildren",

        /**
         * @lends mstrmojo._HasChildren#
         */
        {
            /**
             * @ignore
             */
            _meta_usesSuper: false,

            /**
             * Array of child objects contained by this object.
             *
             * @type Object[]
             */
            //children: null,

            /**
             * <p>Optional handler called after initialization of children.</p>
             *
             * <p>This handler is supported as a customization hook during the initialization process.
             * If specified, the handler will be called after the instance's initial children have been created.
             * If the instance has no initial children, the handler is not called.</p>
             *
             * @type Function
             */
            //postCreateChildren: null,

            /**
             * <p>Constructs child objects from this object's "children" property value.</p>
             * <p>This method is intended to be used during initialization and therefore operates silently;
             * meaning it does not raise "addChild" events for the initial set of children.</p>
             */
            initChildren: function initChildren() {
                var C = "children",
                    c = this[C];

                if (!c) {
                    return;
                }

                // Important: delete this[C] won't work if this[C] is defined on the prototype. Must use this[C] = null!
                this[C] = null;
                this._set_children(C, c, true);

                // Hook for customizations.
                if (this.postCreateChildren) {
                    this.postCreateChildren();
                }
            },

            /**
             * <p>Custom setter for the "children" property value.</p>
             *
             * <p>This method will add a given array of children to this object's
             * "children" property. Any children previously in the "children" property
             * are removed first.</p>
             *
             * @param {String} [n="children"] The property whose value is being set.
             * @param {Object[]} [v] An array of either child objects or references to child objects. If
             * references are specified, they are resolved to actual child objects using the mstrmojo.registry.ref method.
             * @param {Boolean} [silent] If true, suppresses raising of event.
             * @returns {Boolean} false, in order to avoid raising a "childrenChange" event when called from mstrmojo.Obj's "set" method.
             * Instead, calling this method should raise "removeChild" and/or "addChild" events (unless suppressed by the "silent" argument).
             */
            _set_children: function setCh(n, v, silent) {
                var ch = this.children;
                if (v !== ch) {
                    if (ch) {
                        // Call removeChildren with null to clear all children; it doesn't accept arrays.
                        this.removeChildren(null, silent);
                    }
                    this.addChildren(v, 0, silent);
                }
                return false;
            },

            /**
             * <p>Destroys the children of this object, if any.</p>
             *
             * <p>This method calls the destroy method of any objects in the "this.children" array, and removes the objects as children of
             * this parent object.  This is done in reverse order, in case any destroy call causes a child to be removed from this.children.
             * It is also done silently, meaning that no "removeChild" events are raised.</p>
             *
             * <p>This method can be called either separately or from this object's own "destroy" method.  When called from this object's own
             * method, it should be called with a true argument.  This allows the method to pass a flag into the children's "destroy" calls,
             * letting them know whether or not the cleanup is being coordinated by a parent/ancestor object.  The flag is used
             * as a performance optimization for a cascading destruction.</p>
             *
             * @param {Boolean} [meDestroying] This param should be set to true when this method is called from this object's
             * own "destory" method.  If true, this method skips removing the children's "parent" handle from the children,
             * removing the "alias" handle to child from this parent object, and skips clearing the children array.</p>
             */
            destroyChildren: function dstCh(meDestroying) {
                var ch = this.children,
                    len = (ch && ch.length) || 0,
                    i;
                if (len) {
                    for (i = len - 1; i > -1; i--) {
                        var c = ch[i];
                        if (c && c.destroy) {
                            c.destroy(meDestroying);
                            if (!meDestroying) {
                                _postRmv(this, c);
                            }
                        }
                    }
                    if (!meDestroying) {
                        ch.length = 0;
                    }
                }
            },

            invalidateChildren: function invalidateChildren() {
                mstrmojo.array.forEach(this.children, function (child) {
                    child.invalidate();
                });
            },

            invalidate: function invalidate() {
                this.invalidateChildren();
            },

            /**
             * <p>Adds a given child or array of children to this object's "children" array. Notifies event
             * listeners by raising an "addChild" event.</p>
             *
             * <p>Each "child" will have a "parent" property whose value is a handle to this object.
             * Additionally, for each child with an "alias" property, a handle to that child will be
             * stored in a property of this object; the property's name will be the child's "alias" value.</p>
             *
             * <p>
             * @param {Object|Object[]} c A child or array of children to be added.
             * @param {Integer} [idx] Index at which the given child(ren) should be inserted. If missing, they are appended.
             * @param {Boolean} [silent] If true, suppresses raising of event.
             * @returns {Object|Object[]} The child or array of children newly added (possibly empty or null).
             */
            addChildren: function addCh(c, idx, silent) {
                if (!c) {
                    return c;
                }
                // Convert the given children references to an array of proper children.
                var isArr = c.constructor === Array,
                    arr = makeCh(this, isArr ? c : [c]);

                if (arr && arr.length) {
                    // Insert the new kids into our "children" property.
                    var ch = this.children || [];
                    if (idx == null) {  // if idx is null OR undefined
                        idx = ch.length;
                    }
                    this.children = _A.insert(ch, idx, arr);

                    // Raise an event, only if someone is listening for it (including this object itself).
                    if (!silent && (this.onaddChild || _P.hasSubs(this.id, "addChild"))) {
                        this.raiseEvent({
                            name: "addChild",
                            value: arr,
                            index: idx
                        });
                    }
                }
                return isArr ? arr : (arr && arr[0]);
            },

            /**
             * <p>Removes a given child or all children from this object's "children" array. Notifies event
             * listeners by raising an "removeChild" event.</p>
             *
             * <p>Each removed child's parent property is cleared.  Additionally, if a child has an "alias" property,
             * this object's alias handle to that child will be cleared.</p>
             *
             * @param {Object} [c] The child to be removed. If missing, all children are removed.
             * @param {Boolean} [silent] If true, suppresses raising of event.
             * @returns {Integer} The index at which the child was removed, if successful; -1 otherwise.
             */
            removeChildren: function rmCh(c, silent) {
                var ch = this.children,
                    c2r = c ? [c] : (this.children || []).concat(),
                    len = c2r.length,
                    idx = -1,
                    i;

                if (len) {
                    for (i = len - 1; i > -1; i--) {
                        _postRmv(this, c2r[i]);
                    }

                    if (c) {
                        idx = _A.removeItem(ch, c);
                    } else if (ch) {
                        ch.length = 0;
                        idx = 0;
                    }

                    // Raise an event, only if someone is listening for it (including this object itself).
                    if (!silent && (this.onremoveChild || _P.hasSubs(this.id, "removeChild"))) {
                        this.raiseEvent({
                            name: "removeChild",
                            value: c2r,
                            index: idx
                        });
                    }
                }
                return idx;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.publisher");

    var $P = mstrmojo.publisher;

    /**
     * <p>Enables an object to raise events that can be heard by listeners.</p>
     *
     * <p>This mixin provides a generic "set" method for updating an object's property value. The set method is capable of
     * raising an "event" when a property value changes by leveraging mstrmojo.publisher. This event can then be heard
     * by other objects who wish to be notified of the change.  Those objects can sign up as "listeners" by calling the
     * object's "attachEventListener" and "detachEventListener" methods.</p>
     *
     * @class
     * @public
     */
    mstrmojo._Provider = mstrmojo.provide(

        "mstrmojo._Provider",

        /**
         * @lends mstrmojo._Provider#
         */
        {
            /**
             * @ignore
             */
            _meta_usesSuper: false,

            /**
             * <p>Specifies which properties (if any) should raise an event when
             * their value is changed via a call to the "set()" method.<p>
             *
             * <p>For example, if changes to the property "foo" should raise an event that can be listened for by event
             * listeners, then we should set audibles to:</p>
             *
             *   <pre>audibles: {"foo": true}</pre>
             *
             * <p>Alternatively, if the changes to "foo" should NOT raise an event, we can declare:</p>
             *
             *   <pre>audibles: {"foo": false}</pre>
             *
             * <p>To specify default behavior for properties in general, we can use the "*" shortcut:</p>
             *
             *   <pre>audibles: {"*": true}</pre>
             *
             * <p>If no default is specified, we assume the default to be audible.
             * Note that changes to property values which are NOT audible will not generate an internal event
             * which this instance can respond to.</p>
             *
             * @type Object
             */
            audibles: {"*": true},

            /**
             * <p>Sets the value of a given property of this object.</p>
             *
             * <p>This method checks this instance for a custom setter; if not found, the property value is updated directly.
             * If the value of the property was indeed changed, an event named "{propertyname}Change" is raised, but only
             * if both the following conditions are met:</p>
             * <ol>
             * <li>the property is audible; and</li>
             * <li>either this object has a handler for the event, or the global publisher has subscriptions for this event.</li>.
             * </ol>
             *
             * <p>If the custom setter is used and returns truthy, the event is automatically published.</p>
             *
             * @param {String} n The name of the property to change.
             * @param {Number|String|Object} [v] The new value.
             *
             * @returns {Boolean} true if the property value was changed; false otherwise.
             */
            set: function set(n, v) {
                // Do we have a custom setter with the name "_set_XXX"?
                var bChanged = false,
                    f = this["_set_" + n],
                    vWas = this[n];    // Old value.

                if (f) {
                    // We have a custom setter, so call it with our arguments.
                    bChanged = f.apply(this, arguments);
                } else {
                    // We don't have a custom setter, just update our property directly.
                    this[n] = v;
                    bChanged = (vWas !== v);
                }

                // Did the property value actually change?
                if (bChanged) {
                    // Performance optimization: Raise event only if it's audible and someone is
                    // listening for it (including this observable itself).
                    var evtName = n + "Change",
                        aud = this.audibles || {},
                        isAudible =  (aud[n] === true) || ((aud[n] !== false) && (aud["*"] !== false));

                    if (isAudible && (this['pre' + evtName] || this['on' + evtName] || this['post' + evtName] || $P.hasSubs(this.id, evtName))) {
                        // Raise an event corresponding to this property value change,
                        // so listeners can be notified.
                        this.raiseEvent({
                            name: evtName,
                            prop: n,
                            value: v,
                            valueWas: vWas
                        });
                    }
                }
                return this;
            },

            /**
             * <p>Publishes an event that can be handled by this and other objects.</p>
             *
             * <p>Given an object which represents an event that originated within this object, this method will call
             * this object's handler for that event (if any) with the given event object. Additionally, this method will
             * ask the mstrmojo.publisher to publish the event so other objects can be notified of the event.</p>
             *
             * @param {Object} evt An object representing an event; must have a "name" property representing the event's name.
             * @returns {Boolean} False if any event handler return false; true otherwise.
             */
            raiseEvent: function rse(evt) {
                var n = evt && evt.name;
                if (!n) {
                    return null;
                }
                // Set the event source.
                evt.src = this;

                // Hook for customization.
                if (this.preHandleEvent) {
                    this.preHandleEvent(evt);
                }

                // First let this object respond to the event with its own custom handler, if any.
                var ns = ['pre', 'on', 'post'],
                    abort = false,
                    i,
                    len;

                for (i = 0, len = ns.length; i < len; i++) {
                    var fn = ns[i] + n;
                    if (this[fn]) {
                        if (this[fn](evt) === false) {
                            abort = true;
                            break;
                        }
                    }
                }

                // If no event handler has "aborted" this event...
                if (!abort) {
                    // Hook for customization.
                    if (this.postHandleEvent) {
                        this.postHandleEvent(evt);
                    }
                    // Then publish the event for other listeners to be notified.
                    $P.publish(this.id, n, evt);
                }

                return evt;
            },

            /**
             * <p>Optional handler called before event handling is executed.</p>
             *
             * <p>This handler is supported as a customization hook within the event handling process.
             * If specified, the handler will be called from raiseEvent before the object's handler for the event.
             * A single argument will be passed into the call: the event object.</p>
             *
             * @type Function
             */
            //preHandleEvent: null,

            /**
             * <p>Optional handler called after event handling is executed.</p>
             *
             * <p>This handler is supported as a customization hook within the event handling process.
             * If specified, the handler will be called from raiseEvent after the object's handler for the event.
             * A single argument will be passed into the call: the event object.</p>
             *
             * @type Function
             */
            //postHandleEvent: null,

            /**
             * <p>A shortcut for subscribing to events from this observable object.</p>
             *
             * <p>Although mstrmojo.publisher can be called to attach an event listener to an observable object,
             * this method is provided as a convenience for attaching listeners for events that originate within this object.</p>
             *
             * @param {String} name The name of the event we wish to subcribe to.
             * @param {Function|String} callback A function, or name of a method, to be called in response to the event.
             * @param {String} [listener] ID of object which hosts the callback. If omitted, the global context is assumed.
             * @returns {Object} An object representing the attached subscription.  This object can be used subsequently as the argument to
             * detachEventListener to cancel the subscription.
             */
            attachEventListener: function att(name, listener, callback) {
                return $P.subscribe(this.id, name, callback, listener);
            },

            /**
             * <p>A shortcut for unsubscribing from events from this observable object.</p>
             *
             * <p>Although mstrmojo.publisher can be called to detach an event listener to an observable object,
             * this method is provided as a convenience for detaching listeners for events that originate within this object.
             * This method is a complement to the attachEventListener method, and can be used to cancel a subscription created by attachEventListener.</p>
             *
             * @param {Object} sub A single object identifier for the subscription, or an array of object identifiers.
             */
            detachEventListener: function det(sub) {
                $P.unsubscribe(sub);
            },

            /**
             * Clears any subscriptions associated with this component.
             *
             */
            destroy: function destroy() {
                // Clear all subscription to or from this object.
                $P.clearSubscriptions(this.id);
                
                if (this._super) {
                    this._super();
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.registry",
                         "mstrmojo._Provider",
                         "mstrmojo.array");

    var $H = mstrmojo.hash,
        $R = mstrmojo.registry,
        $ARR = mstrmojo.array;

    /**
     * <p>Base class for an observable object.</p>
     *
     * <p>When an instance of Obj is constructed, it is automatically added to the "mstrmojo.all" collection, keyed by its
     * "id" property (if missing, an id will be auto-generated).  Hence the instance can be used with the "publisher" system
     * (mstrmojo.publisher) for raising and listening to "events". When the instance's "destroy" method is called, it is
     * removed from the "all" collection and from the publisher system.</p>
     *
     * <p>Each Obj instance can have any arbitrary set of properties and valies.  The instance has a "set" method for updating
     * its property values.  The "set" method is capable of raising an "event" which can then be heard by other objects who wish
     * to be notified of a change in the Obj's state. Those objects can sign up as "listeners" for events by calling the Obj's
     * "attachEventListener" and "removeEventListener" methods.</p>
     *
     * @class
     */
    mstrmojo.Obj = mstrmojo.declare(
        // superclass
        null,

        // mixins
        [ mstrmojo._Provider ],

        /**
         * @lends mstrmojo.Obj.prototype
         */
        {
            /**
             * The FQCN for this object.
             *
             * @type String
             */
            scriptClass: "mstrmojo.Obj",

            /**
             * <p>Optional handler called during initialization.</p>
             *
             * <p>This handler is supported as a customization hook within the instance creation process.
             * If specified, the handler will be called from constructor after properties are applied to this object,
             * but before the object is registered in the "mstrmojo.all" collection.</p>
             *
             * @type Function
             */
            //postApplyProperties: null,

            /**
             * <p>Optional handler called after initialization.</p>
             *
             * <p>This handler is supported as a customization hook at the end of the instance creation process.
             * If specified, the handler will be called from constructor after the instance properties are finished
             * processing and the instance has been registered in the "mstrmojo.all" collection.</p>
             *
             * @type Function
             */
            //postCreate: null,

            /**
             * <p>Base class for an observable object.</p>
             *
             * <p>Constructs a new instance by doing the following:</p>
             * <ol>
             * <li>applying all the property values in a given hashtable to the new instance,</li>
             * <li>calls the "postApplyProperties" handler, if any,</li>
             * <li>auto-assigns an "id" property value to the instance (if needed),</li>
             * <li>adds the instance to the "mstrmojo.all" collection,</li>
             * <li>calls the "postCreate" handler, if any.</li>
             * </ol>
             *
             * @constructs
             * @param {Object} [props] Hash of property values to be applied to this instance.
             */
            init: function init(props) {
                // Create disposables collection.
                this.disposables = [];
                
                // Apply the given properties to this instance.
                $H.copy(props, this);    // Optimization: use copy rather than mixin, unless truly needed.

                // Hook for customizations before getting registered.
                if (this.postApplyProperties) {
                    this.postApplyProperties();
                }

                // Add this instance to the mstrmojo.all collection so it can participate in event publishing/listening.
                $R.add(this);

                // Hook for customizations after getting registered.
                if (this.postCreate) {
                    this.postCreate();
                }
            },

            /**
             * Removes this instance from the mstrmojo.all collection and from any event subscriptions.
             */
            destroy: function destroy(ignoreDOM) {
                this._super(ignoreDOM);
                
                // Iterate disposables.
                $ARR.forEach(this.disposables, function (d) {
                    // Does item have a destroy method?
                    if (d.destroy) {
                        // Destroy it.
                        d.destroy(ignoreDOM);

                    // Does item has a clear method?
                    } else if (d.clear) {
                        // Clear item.
                        d.clear();
                    }
                });
                
                // reset the disposables
                this.disposables = [];

                // Remove this instance from event publishing/listening.
                $R.remove(this);
            }
        }
    );

    // static convenience function for destroying and deleting an Obj object;
    // if you are disposing of lots of objects, recommendation is to define a local variable = mstrmojo.Obj.free and
    // use it to call this function.
    //
    // You may pass null and undefined variables to this function.
    //
    var obj = mstrmojo.Obj;
    obj.free = function free(o) {
        if (o instanceof obj) {
            o.destroy();
        }
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo._IsList",
                         "mstrmojo.dom");

    /**
     * <p>A mixin for adding Android specific behavior to subclasses of {@link mstrmojo.ListBase}.</p>
     *
     * @class
     * @public
     */
    var isList = mstrmojo.android._IsList = mstrmojo.provide(
        "mstrmojo.android._IsList",

        mstrmojo.hash.copy(mstrmojo._IsList, {
            _mixinName: 'mstrmojo.android._IsList',

            /**
             * Returns the index of the touched element from a touch event.
             *
             * @param {Object} touch The touch event.
             *
             * @returns {Integer} The index of the touched item, or -1 if not found.
             */
            getItemIdxTouch: function getItemIdxTouch(touch) {
                // Select the element.
                var item = mstrmojo.dom.findAncestorByAttr(touch.target, 'idx', true, this.domNode),
                    idx = item && parseInt(item.value, 10);

                return (idx !== null && !isNaN(idx)) ? idx : -1;
            },

            /**
             * Clears the list selection and scroller origin.
             */
            resetListState: function resetListState() {
                // Clear selections without audible events.
                this.clearSelect(true);

                // Do we have a scroller configuration?
                var scrollerConfig = this.scrollerConfig;
                if (scrollerConfig) {
                    // Delete scroller origin.
                    delete this.scrollerConfig.origin;
                }
            },

            /**
             * Restores list selections and scroller origin.
             *
             * @param {Integer} idx The index of the selected element.
             * @param {Object} origin The scroller origin.
             */
            restoreListState: function restoreListState(idx, origin) {
                // Restore selected state.
                var indices = {};
                indices[idx] = true;

                this.selectedIndices = indices;
                this.selectedIndex = idx;

                // Do we have a scroller configuration?
                var scrollerConfig = this.scrollerConfig;
                if (scrollerConfig) {
                    // Override origin.
                    scrollerConfig.origin = origin;
                }
            },

            /**
             * Overridden to call touchTap.
             *
             * @ignore
             */
            touchSelectEnd: function touchSelectEnd(touch) {
                // Call touch tap.
                this.touchTap(touch);
            }
        })
    );

    // Cache current click handler.
    var fnClick = isList.onclick;
    isList.onclick = mstrmojo.emptyFn;

    // Add touch tap handler.
    isList.touchTap = function (touch) {
        // Cache touch target.
        this._listTarget = touch.target;

        // Call click handler.
        fnClick.call(this, touch);
    };

}());
(function(){
    
    mstrmojo.requiresCls("mstrmojo.locales", "mstrmojo.expr", "mstrmojo.date","mstrmojo.num", "mstrmojo.string");
    
    mstrmojo.validation = {
            STATUSCODE: {
                    UNKNOWN: -1,
                    VALID : 0,
                    INVALID: 1,
                    INVALID_EMPTY: 2,
                    INVALID_CHAR: 3,
                    INVALID_OUTOFRANGE:4,
                    INVALID_REGEX:5,
                    INVALID_VALIDATOR:6,
                    INVALID_BAD_NUMERICFORMAT:7,
                    INVALID_BAD_DATESTRING:8            
            },        
            TRIGGER:{
                    NONE: 0,
                    ONBLUR: 1,
                    ONKEYUP: 2,
                    VALUESET: 4,
                    ALL: 7        
            },            
            REGEXP:{
                    US_ZIP: /^\d{5}([- ]?\d{4})?$/, 
                    EMAIL_ADDRESS: /^([a-zA-Z0-9\_\.\-])+@(([a-zA-Z0-9\-])+[\.])+([a-zA-Z0-9]{2,4})+$/,
                    SOCIAL_SECURITY_NUMBER: /^((?!000)(?!666)\d{3})(\s|\-)?((?!00)\d{2})\2((?!0000)\d{4})$/,
                    PHONE_NUMBER: /^(?!-)[ \d\-\(\)\.\+]+$/,
                    FILE_NAME:new RegExp("^[^:*?\"<>|/\\\\()]+$"),
                    FOLDER_PATH_WIN:new RegExp("^([a-zA-Z]:|\\\\\\\\[^:*?\"<>|/\\\\]+|[^:*?\"<>|/\\\\]*)(\\\\[^:*?\"<>|/\\\\]+)*(\\\\){0,1}$"),        
                    FOLDER_PATH_UNIX:new RegExp("^(/){0,1}([^:*?\"<>|/\\\\]+/)*([^:*?\"<>|/\\\\]+){0,1}$"),
                    PRINTER_PATH_SINGLE: new RegExp("^[^$%:*?\"<>|/\\\\]*$"),
                    PRINTER_PATH_MULTIPLE:new RegExp("^((/|\\\\\\\\)[^$%:*?\"<>|/\\\\]+)((/|\\\\)[^$%:*?\"<>|/\\\\]+)*(/|\\\\){0,1}$")
            },
            VALIDATOR:{
                    DEMO:function customValidator(v){
                           var parsed = parseInt(v,10),
                               SC = mstrmojo.validation.STATUSCODE;
                           if(parsed === 0 || parsed === 1 || parsed > 10) {
                               return {code:SC.VALID};
                           }
                           /*For a validator function, it needs to return a code field stating whether the validation is valid or not;
                            * and another optional variable stating the reason of being invalid. 
                            */
                           return {code:SC.INVALID, msg:'This field must be either 0, 1 or greater than 10'};
                    },
                    VALIDATE_PHONENO: function validatePhoneNo(v){
                        var dt = this.dtp, 
                            phoneNo = String(v).replace(/[^\d]/g, '');
                        
                        // how many numbers in the phone number string.
                        if (phoneNo.length < 10){
                            return {code:_SC.INVALID, msg: mstrmojo.desc(9203)}; //'A telephone number must contain at least 10 digits.'
                        }
                        
                        if (!_V.REGEXP.PHONE_NUMBER.test(v)){
                            return {code:_SC.INVALID, msg: mstrmojo.desc(9204)}; //'The telephone number contains invalid characters.'
                        }
                        return {code:_SC.VALID};
                    },
                    VALIDATE_ZIPCODE: function validateZipCode(v){
                        var msg = '', dt = this.dtp;
                        if (!_V.REGEXP.US_ZIP.test(v)){
                            if (_V.isNumeric(dt) || _V.isInt(dt))
                                msg = mstrmojo.desc(9208); //'A zip code must be 5 digits or 5+4 digits.'
                            else if (_V.isString(dt)){
                                msg = mstrmojo.desc(9206); //'The zip code is invalid.'
                            }
                            return {code:_SC.INVALID, msg: msg};
                        }
                        return {code:_SC.VALID};
                    },
                    VALIDATE_EMAIL: function validateEmail(v){
                        var atSignIdx = v.indexOf('@');
                        
                        if (atSignIdx === -1){
                            return {code: _SC.INVALID, msg: mstrmojo.desc(9197)}; //'The email address is missing an at sign (@).'
                        }
                        
                        if (v.substring(atSignIdx).indexOf('.') === -1){
                            return {code: _SC.INVALID, msg: mstrmojo.desc(9198)}; //'The email address is missing a period on the domain.'
                        }
                        
                        return _V.REGEXP.EMAIL_ADDRESS.test(v) ? {code:_SC.VALID} : {code:_SC.INVALID, msg:mstrmojo.desc(9207)}; //'The email address is invalid.'
                    },
                    VALIDATE_SSN: function validateSSN(v){
                        var dt = this.dtp, ssnNo;
                        if (_V.isNumeric(dt) || _V.isInt(dt)){
                            ssnNo = String(v).replace(/[^\d]/g, '');
                            if (ssnNo.length != 9){
                                return {code:_SC.INVALID, msg: mstrmojo.desc(9209)}; //'A Social Security Number must be 9 digits.'
                            }
                        }
                        if (!_V.REGEXP.SOCIAL_SECURITY_NUMBER.test(v)){
                            return {code:_SC.INVALID, msg: mstrmojo.desc(9210)}; //'The Social Security Number is invalid.'
                        }
                        return {code:_SC.VALID};
                    }
            },
            isInt: function(dtp){
                return DTP2TYPE[dtp] == 1;
            },
            isNumeric: function(dtp){
                return DTP2TYPE[dtp] == 2 || DTP2TYPE[dtp] == 5;
            },
            isString: function(dtp){
                return DTP2TYPE[dtp] == 3;
            }            
    };

    
    var _G = window.mstrConfig,
    listSep = _G.listSep,
    _E = mstrmojo.expr,
    DTP = _E.DTP,
    _V = mstrmojo.validation,
    _TR = _V.TRIGGER,
    _SC = _V.STATUSCODE,    
    _C = mstrmojo.css,
    _N = mstrmojo.num,
    _S = mstrmojo.string, 
    _DP = mstrmojo.date,
    DTP2TYPE = {/*1: integer 2: numeric 3:string 4:binary 5: big decimal 6:date*/
        '-1':-1,
        1:1,
        2:1,
        3:2,
        4:2,
        5:2,
        6:2,
        7:2,
        8:3,
        9:3,
        10:3,
        11:4,
        12:4,
        13:4,
        14:6,
        15:6,
        16:6,
        21:2,
        22:2,
        23:3,
        24:4,
        25:3,
        30:5
    };
   
    
    /**
     * Check whether value contains invalid characters based on its data type.
     * @param {String} v The value to validate against.
     */
    function _containsInvalidChar(me, v){
        var dtp = me.dtp,
            c = me.constraints,
            allows = c.allowedFormatChars ? c.allowedFormatChars : '',
            isInt = (DTP2TYPE[dtp] == 1),                        
            isNumeric = (DTP2TYPE[dtp] == 2),                        
            isDT = (DTP2TYPE[dtp] == 6),
            thousand = mstrmojo.locales.number.THOUSANDSEPARATOR,
            decimal = mstrmojo.locales.number.DECIMALSEPARATOR,
            regExp;
                          
        if(isInt){
            if(!me._intRegExp){
                allows += '0-9-' + (me.isList ? listSep : '') + thousand;
                me._intRegExp = new RegExp('[^' + allows + ']');
            }
            regExp = me._intRegExp;
        }
        
        if(isNumeric){
            if(!me._numericRegExp){
                allows += '0-9-' + (me.isList ? listSep : '') + decimal + thousand;
                me._numericRegExp = new RegExp('[^' + allows + ']');
            }
            regExp = me._numericRegExp;                      
        }
            
        if(isDT){//TO-DO: add support for dates:need to extract all formatting characters used for date/time formatting
            
        }
        
        return !!regExp && regExp.test(v);
    }
    
    /**
     * Check whether a value is lower than minimum or higher than maximum based on its data type. 
     * It requires parsing a string into its corresponding data type first and then compare its range.
     * @param {String} v The value to validate against.
     */
    function _valueOutOfRange(me, v){
        var dtp = me.dtp,
        c = me.constraints,
        isInt = (DTP2TYPE[dtp] == 1),                        
        isNumeric = (DTP2TYPE[dtp] == 2),                        
        isDT = (DTP2TYPE[dtp] == 6),
        min = c.min,
        max = c.max,
        parsed;
        
        //no range defined, return
        if(min == undefined && max == undefined) {
            return false;
        }
        
        //check numeric
        if(isInt || isNumeric){
            return _N.inNumericRange(v, min, max) !== 0;
        }
        
        //check date
        if(isDT){
            return _DP.inDateTimeRange(v, min, max) !== 0;
        }
            
        return false;                        
    }
    
    /**
     * Check against any bad format of numeric values.
     * For now, only make sure there is no more than 1 decimal separator
     * 
     * @param {String} v The value to validate against.
     */
    function _badNumericFormat(me, v){                 
        return !_N.isNumeric(v) ;
    }

    /**
     * Check against any component of date is not in valid range. 
     * For example, 32 for day, or 13 for month. 
     */
    function _badDTString(me, v){
        var isD = (me.dtp === DTP.DATE),
            isT = (me.dtp === DTP.TIME);
        return (isD ? !_DP.isDate(v) : (isT ? !_DP.isTime(v) :!_DP.isDateAndOrTime(v)));
    }
    
    /**
     * <p>mstrmojo._CanValidate is a mixin any widget that requires validation shall extend from.</p>
     * 
     * <p>To configure the validation,
     * users can pass in a parameter called "constraints", which contains multiple variables that are useful when deciding
     * when to validate('trigger' variable), range to check against ('min/max' variable), etc. You can also configure callback
     * functions (onValid/onInvalid) so that when validation happens, customized actions can be taken (like to disable/enable a button of an editor).</p>
     * 
     * @class
     * @public
     */
    mstrmojo._CanValidate = mstrmojo.provide(
            "mstrmojo._CanValidate",
            {
                /**
                 * min:minmum value for integer/numeric/date, minimum length for string
                 * max:maximum value for integer/numeric/date, maximum length for string
                 * allowedFormatChars: allowed characters for formatting purpose
                 * regExp: regular expression to check against
                 * validator: custom validation functions
                 * trigger: when to start validation process
                 * invalidCssClass: the css class to used if not valid
                 */
                constraints:null,
                
                /** 
                 * Whether or not this field is required. 
                 */
                required:false,
                
                /**
                 * The data type of this input. 
                 */
                dtp: DTP.INTEGER,
                
                /**
                 * Whether or not this field may contain a list of values of the same data type, separated by the list seperator
                 */
                isList: false,
                
                /**
                 * Whether to format the value into standard output format defined by specific locale.
                 */
                autoFormat: false,
                
                
                /*onValid:null,//onValid: the handler to call if validation returns valid*/
                
                /*onInvalid:null,//onInvalid: the handler to call if validation returns invalid*/
                
                /**
                 * Store the current validation status. Check its 'code' to see the validation status(valid/invalid),
                 * and optional 'msg' field for reason of being invalidated. 
                 */
                validationStatus:null,
                
                init: function init(props){
                    this._super(props);
                    if(!this.constraints) {
                        this.constraints = {};
                    }
                    var c = this.constraints;                    
                    if(!('trigger' in c)) {
                        c.trigger = _TR.NONE;    
                    }
                },
                
             
                
                /**
                 * Override to fire validation if configured. 
                 * @param {String} n The name of property.
                 * @param {String} v The value of property. 
                 */
                _set_value: function(n,v){
                    var vWas = this.value,
                        bChanged = (vWas !== v);
                    if(bChanged){
                        this.value = v;
                        var t = this.constraints.trigger,
                            cv = (t & _TR.VALUESET) > 0;
                        if(cv) {
                            this.validate(v);
                        }
                    }
                    return bChanged;
                },

                /**
                 * If invisible, we shall clear the validation result
                 */
                /*  No need for this support for now
                previsibleChange: function previsibleChange(evt){
                    this.clearValidation();
                },*/
                
                /**
                 * If disabled, we shall clear the validation result
                 */   
                /* No need for this support for now
                preenabledChange: function previsibleChange(evt){
                    this.clearValidation();                  
                }, */               
                
                /**
                 * The main entry method to call in order to start validation process.
                 * It calls doValidation to validate and based on the return value, change textbox appearance and call callback handlers. 
                 */
                validate: function validate(){
                    
                    var v = (this.value !== null && this.value !== undefined)? this.value : '',
                        vl = this.isList ? v.split(listSep) : [v],
                        r, isInvalid, method;
                    
                    for(var i=0, len = vl.length;i<len;i++){
                        r = this.doValidation(vl[i]);
                        isInvalid = (r.code > _SC.VALID);
                        if(isInvalid) {
                            if(len>1){
                                r.msg = mstrmojo.locales.validation.invalidValueInListError.replace("#", vl[i] ? vl[i] : ' ');
                            }
                            break;
                        }
                    }
                    
                    method = isInvalid ? 'onInvalid' : 'onValid';
                    
                    if(!isInvalid && this.autoFormat) {
                        this.format();
                    }
                    
                    //store the result
                    this.set('validationStatus',r);
                    
                    //call backs
                    if (this[method]) {
                        this[method](r);
                    }
                },
                
                /**
                 * Convert the value into standard output format defined by specific locale.
                 * We only do it for date/time for now. May need do it for numbers too. 
                 */
                format: function format(){
                    var dtp = this.dtp,
                        isDT = (DTP2TYPE[dtp] == 6);
                    if(!isDT) return;
                    
                    var listSep = mstrConfig.listSep,
                        v = this.value || '',
                        vl = this.isList ? v.split(listSep) : [v],                                   
                        isD = dtp === 14,
                        va=[], 
                        dt,
                        _DT = mstrmojo.locales.datetime;
                        
                    for(var i =0,len=vl.length;i<len;i++){
                        v = vl[i];
                        dt = _DP.parseDateAndOrTime(v);
                        if(dt){
                            if(isD && dt.date){
                                va.push(_DP.formatDateInfo(dt.date, _DT.DATEOUTPUTFORMAT));
                            } else {
                                va.push((dt.date ? _DP.formatDateInfo(dt.date, _DT.DATEOUTPUTFORMAT):'') + ' ' +
                                        (dt.time ? _DP.formatTimeInfo(dt.time, _DT.TIMEOUTPUTFORMAT) : ''));
                            }
                        }
                    }
                    this.set('value', va.join(listSep));
                },
                
                /**
                 * Whether current validation status is valid. 
                 */
                isValid: function isValid(){
                    var s = this.validationStatus;
                    if(!s) this.validate();
                    return this.validationStatus.code === _SC.VALID;
                },
                
                /**
                 * Provide this method to clear validation status/appearance. 
                 */
                clearValidation: function clearValidation(){
                    this.set('validationStatus', {code:_SC.VALID});
                    if(this.onClearValidation) {
                        this.onClearValidation();  
                    }                    
                },
                
                /**
                 * Method to validate against checking rules. 
                 * Return an object indicating validation result with 3 fields. The first field 'id' is the id of this source widget; 
                 * The second field 'code' indicate the result of validation, either valid or invalid. 
                 * If invalid, it can also be other value (as defined in mstrmojo.validation.STATUSCODE), depending on the reason of invalid. 
                 * The third field 'msg' is optional, when invalid, it is the msg indicating invalid reason. 
                 * @param {String} v The value to validate against.
                 */
                doValidation: function doValidation(v){
                    var c = this.constraints,
                        regExp = c.regExp,
                        validator = c.validator, 
                        r = {id: this.id,code:_SC.VALID,msg:''},
                        dtp = this.dtp,
                        isInt = (DTP2TYPE[dtp] == 1),
                        isNumeric = (DTP2TYPE[dtp] == 2 || DTP2TYPE[dtp] == 5),
                        isString = (DTP2TYPE[dtp] == 3),
                        isDT = (DTP2TYPE[dtp] == 6),
                        isEmpty = _S.isEmpty(v),
                        vLen = String(v).length;
                        err = '',
                        _VAL = mstrmojo.locales.validation;
                    
                    //check against empty values
                    if(this.required && isEmpty) {
                        r.code = _SC.INVALID_EMPTY;
                        r.msg = _VAL.requiredFieldError;
                        return r;
                    }
                    
                    v = _S.trim(v);
                    
                    //check against invalid characters
                    if(!isEmpty && _containsInvalidChar(this,v)){
                        if(isInt) {
                            err = _VAL.integerDataType;
                        }
                        if(isNumeric) {
                            err = _VAL.numericDataType;
                        }
                        if(isDT) {
                            err = _VAL.dateDataType;
                        }
                        r.code = _SC.INVALID_CHAR;
                        r.msg = _VAL.invalidCharError.replace('#',err);
                        return r;
                    }
                    
                    //check against date bad formatting
                    if(!isEmpty && isDT && _badDTString(this,v)){
                        r.code = _SC.INVALID_BAD_DATESTRING;
                        r.msg = _VAL.invalidDateStringError;
                        return r;
                    }
                    
                    //check against numeric bad formatting
                    if(!isEmpty && (isNumeric || isInt) && _badNumericFormat(this,v)){
                        r.code = _SC.INVALID_BAD_NUMERICFORMAT;
                        r.msg = _VAL.invalidNumericFormatError; 
                        return r;
                    }
                    
                    //check range for integer/numeric and dates
                    if(!isEmpty && (isInt || isNumeric || isDT) && _valueOutOfRange(this,v)){
                        r.code = _SC.INVALID_OUTOFRANGE;
                        if(c.min != null && c.max != null){
                            err = _VAL.outofRangeError.replace('#', '').replace('##', c.min).replace('###', c.max);
                        } else if(c.min != null){
                            err = _VAL.noLessMinError.replace('##', c.min).replace('#', '');  
                        } else if(c.max != null){
                            err = _VAL.noGreaterMaxError.replace('###', c.max).replace('#', ''); 
                        }
                        r.msg = err;
                        return r;
                    }
                    
                    //check the length of string value
                    if (isString && c.minLen != null && c.maxLen != null){
                        if (vLen < c.minLen || vLen > c.maxLen){
                            r.code = _SC.INVALID;
                            r.msg = mstrmojo.desc(9211).replace(/#/, c.minLen).replace(/##/, c.maxLen);
                            return r;
                        }
                    }
                    
                    //test regular expression
                    if(regExp && !regExp.test(v)){
                        r.code = _SC.INVALID_REGEX;
                        r.msg = mstrmojo.desc(9205); //'The input is invalid.'
                        return r;
                    }
                    
                    //custom validator
                    var _t = validator && validator.apply(this,[v]);
                    
                    if(_t){
                        r.code = _t.code;
                        r.msg = _t.msg;
                        return r;
                    }
                    
                    //no more checkings, return valid result
                    
                    return r;
                    
                }
                

            });
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.num",
                         "mstrmojo.array",
                         "mstrmojo.DICFactory");

    var INPUT_VALUES_MANUAL = 1,
        POPUP_INLINE = 0,
        POPUP_ABOVE = 1,
        POPUP_BELOW = 2,
        decimal = '.',
        $D = mstrmojo.dom,
        $C = mstrmojo.css,
        $H = mstrmojo.hash,
        TAB_KEY = mstrmojo.Enum_Keys.TAB,

        isNumType = function (dt) {
            return (dt >= 1 && dt <= 7) || dt == 21 || dt == 22 || dt == 30;
        },

        /**
         * Utility function to convert em to px.
         * @private
         */
        convertEmtoPx = function (dom, v) {
            if ($D.isIE && !/px$/.test(v)) {
                var img = document.createElement('img'), pl;
                img.style.zIndex = -1;
                img.style.left = v;

                dom.appendChild(img);

                //get the pixel value
                pl = img.style.pixelLeft;
                dom.removeChild(img);

                return pl + 'px';
            }
            return v;
        },

        _getScaleStyle = function (dom, n) {
            return parseInt(convertEmtoPx(dom, $C.getStyleValue(dom, n)), 10) || 0;
        },

        getPadding = function (dom) {
            return {
                lp: _getScaleStyle(dom, 'paddingLeft'),
                rp: _getScaleStyle(dom, 'paddingRight'),
                tp: _getScaleStyle(dom, 'paddingTop'),
                bp: _getScaleStyle(dom, 'paddingBottom')
            };
        },

        //read font related style info from a given dom node
        getFontStyle = function (dom) {
            var s = dom.currentStyle;
            if (!s) {//Firefox and Chrome
                s =  document.defaultView.getComputedStyle(dom, null);
            }
            return {
                fontFamily: s.fontFamily,
                fontSize: convertEmtoPx(dom, s.fontSize),
                fontStyle: s.fontStyle,
                fontVariant: s.fontVariant,
                fontWeight: s.fontWeight,
                textAlign: s.textAlign
            };
        },
        
        lockInfoWindow = function (widget, isLock) {
            var infowindow = mstrmojo.findAncestor(widget, 'scriptClass', 'mstrmojo.DocInfoWindow');
            if (!!infowindow) {
                infowindow.autoCloseLocked = isLock;
            }
        };

    mstrmojo._IsInputControl = {

        _mixinName: '_IsInputControl',

        /**
         * dic config object
         */
        dic: null,

        /**
         * Either an EditableXtab or an EditableTextField object
         */
        owner: null,

        /**
         * For popup, retrieve styles(font, offset, etc..) from it.
         * For inline, render the dic as its child.
         */
        openerNode: null,

        /**
         * It could be POPUP_INLINE, POPUP_ABOVE, POPUP_BELOW
         */
        popupStyle: POPUP_INLINE,

        /**
         * This should be populated from DIC
         */
        items: null,

        /**
         * Whether the changed value gets applied on enter key
         */
        applyOnEnter: true,

        /**
         * Last value
         */
        lv: null,

        init: function (props) {
            if (this._super) {
                this._super(props);
            }

            var dic = this.dic, dt = dic.dt, _DTP = mstrmojo.expr.DTP, dtObj, arr = [];

            //TQMS 503967: On android, we always get raw value including both date and time part.
            //Need to truncate the unnecessary part off.
            if (mstrApp.useBinaryFormat) {
                if (dt == _DTP.DATE || dt == _DTP.TIME || dt == _DTP.TIMESTAMP) {
                    dtObj = mstrmojo.date.parseDateAndOrTime(this.value);

                    if (dtObj) {
                        if (dt != _DTP.TIME) {
                            arr.push(mstrmojo.date.formatDateInfo(dtObj.date, mstrmojo.locales.datetime.DATEOUTPUTFORMAT));
                        }

                        if (dt != _DTP.DATE) {
                            arr.push(mstrmojo.date.formatTimeInfo(dtObj.time, mstrmojo.locales.datetime.TIMEOUTPUTFORMAT));
                        }
                        this.value = arr.join(' ');
                    }
                }
            }

            // sync the last value
            this.lv = this.value;

            //This is a hack to fix the incorrect DIC config.
            if (dic.wm && dic.w === undefined) {
                dic.wm = 0;
            }
        },

        /**
         * It tells whether the input control is shown immediately after the document is rendered
         */
        showByDefault: false,

        /**
         * It tells whether we should render a preview inside the grid cell or text field for the popup dic.
         * @return
         */
        hasPreview: false,

        /**
         * Get the items objects from dic.vls object. Convert the values into the local string.
         * @returns {Object} The name value pair for the dic.vls object.
         */
        //TODO: save the calculated items on dic object
        getItems: function () {
            var dic = this.dic, m = [], i, v, nm = 0,
                dv = String(dic.itv),
                dx = dv && dv.indexOf(decimal), //vls always uses '.' as decimal regardless locale
                isNumeric = isNumType(dic.dt);

            if (dx >= 0) {
                nm = dv.substring(dx + 1).length;
            }

            if (parseInt(dic.ipt, 10) === 0) { // calculated
                for (i = 0, v = dic.min; v < dic.max + 0.00001; i++, v += dic.itv) {
                    m[i] = {'n': mstrmojo.num.toLocaleString(nm > 0 ? v.toFixed(nm) : v), 'v': v};
                }
            } else {
                m = dic.vls;
                mstrmojo.array.forEach(m, function (mi) {
                    if (mi.n === undefined) {
                        mi.n = isNumeric ? mstrmojo.num.toLocaleString(mi.v) : mi.v;
                    }
                });
            }

            return m;
        },

        font: null,

        //Apply fonts on the control
        onfontChange: function () {
            if (this.getInputNode) {
                var node = this.getInputNode(),
                    f = this.font;

                $H.forEach(f, function (o, i) {
                    node.style[i] = o;
                });
            }
        },

        /**
         * Get the css style of the grid cell or doc text field
         */
        getOpenerNodeStyle: function () {
            var s = this.group && this.group.ons,
                p = this.openerNode;

            if (!s) {
                s = getPadding(p);

                //calculate horizontal padding and vertical padding
                s.hp = s.lp + s.rp;
                s.vp = s.tp + s.bp;

                //calculate inline width and inline height
                s.iw = Math.max(0, p.clientWidth - s.hp);
                s.ih = Math.max(0, p.clientHeight - s.vp);

                //For xtab, need to store this information on dicgroup for performance optimization
                if (this.group) {
                    this.group.ons = s;
                }
            }
            return s;
        },

        /**
         * Will be triggered when DIC's value has been changed. Concrete DIC could override this if needed. (See ToggleDIC.js)
         */
        onvalueChange: function () {
            if (this._super) {
                this._super();
            }

            // TQMS #704360:  Flag this field as changed.
            this.dicChanged = true;

            if (this.showByDefault) {
                this.applyChanges();
            } else {
                if (this.popupStyle !== POPUP_INLINE && this.popup && this.popup.enableApply) {
                    this.popup.enableApply();
                }
            }
        },

        preBuildRendering: function () {
            if (this._super) {
                this._super();
            }

            this.openerNode = this.openerNode || this.owner.domNode;

            if (this.showByDefault) {
                this.openerStyle = this.getOpenerNodeStyle();
                if (this.inlineExtraCssText) {
                    this.cssText += ' ' + this.inlineExtraCssText;
                }
            }

            if (!this.placeholder) {
                this.placeholder = document.body.appendChild(document.createElement("div"));
            }
        },

        postBuildRendering: function () {
            var target = this.openerNode;

            if (this._super) {
                this._super();
            }

            //if the owner does not contains the input control node
            if (!mstrmojo.isDescendant(this.owner, this)) {
                if (this.showByDefault) {
                    // Place the rendered inline widget into openerNode to replace the original content.
                    target.replaceChild(this.domNode, target.lastChild);
                } else {
                    // Popup DICs need to inherit the font style of the opener node
                    this.set('font', getFontStyle(target));
                }
            }

            if (mstrmojo.DICConfig.isKeyNavigable(this.dic)) {
                this.registerKeyEvents(this.domNode);
            }
        },

        /**
         * This method will attempt to apply the changes. If the value is changed, it will notify its opener to handle it.
         *
         * @return {Boolean} indicates whether the change could pass the validation(if any) and be applied.
         */
        applyChanges: function () {
            var lv = this.lv, v = this.getCurValue ? this.getCurValue() : this.value, d = this.openerNode,
                dv = this.getDisplayValue ? this.getDisplayValue() : v,
                dt = this.dic.dt,
                _DTP = mstrmojo.expr.DTP,
                LD = mstrmojo.locales.datetime;

            if (String(v) !== String(lv)) {
                // Binary side cannot recognize localized AM/PM string. We need to parse them to standard form.
                if (mstrApp.useBinaryFormat) {
                    if (dt == _DTP.TIME || dt == _DTP.TIMESTAMP) {
                        v = v.replace(new RegExp(LD.AM_NAME), 'AM').replace(new RegExp(LD.PM_NAME), 'PM');
                    }
                }

                this.lv = v;
                this.dv = dv;

                if (this.owner && this.owner.dataChanged) {
                    this.owner.dataChanged(this.k, lv, {dv: dv, v: v}, d);
                }
            }
            return true;
        },

        /**
         * When cancel changes, we set the value back to its last value because if popup apply button is no clicked, the value can be
         * changed, so if next time the same dic is opened, we should not use changed value.
         */
        cancelChanges: function cancelChanges() {
            this.value = this.lv;
        },

        /**
         * This method is called to render the popup DIC and show it inside the DICPopup
         */
        showInPopup: function () {

            this.popup = mstrmojo.DICFactory.createDICPopup(this.owner, this);

            if (this.focus) {
                this.focus();
            }
            
            this.setInfoWindowLock(true);
        },

        /**
         * This method is called to be notified that the popup dialog is closed
         */
        lockPopup: function () {
            this.setInfoWindowLock(false);
        },
        
        /**
         * Implement this function to render a preview inside the grid cell or text field for the popup dics
         */
        renderPreview: null,

        /**
         * Handle the event when user presses the TAB key.
         */
        onTabDown: function (evt) {
            mstrmojo.dom.preventDefault(window, evt);

            // apply the current changes
            if (this.applyChanges() !== false) {

                // Close the DIC popup if the change is applied without any error (or there's no change)
                if (this.popup) {
                    this.popup.close();
                }

                // Ask the owner (xtab or textfield) to open the next IC
                this.owner.editNext(this.k);
                
                //once the input control is not active anymore, do some clean up
                this.cleanup();
            }
        },

        /**
         * Clean up function for each input control to subclass. The function will be called once the tab focus moves away from the
         * input control.
         */
        cleanup: mstrmojo.emptyFn,
        
        /**
         * Register key events on a specified dom node.
         *
         * @param {DOM} dom A focusable dom node.(tabindex >= 0)
         */
        registerKeyEvents: function (dom) {
            var me = this;

            $D.attachEvent(dom, 'keydown', function (evt) {
                var e = evt || window.event;
                if (e.keyCode === TAB_KEY) { //on TAB key
                    me.onTabDown(evt);
                }
            });

            // IE has weird issues that the focus gets lost when tab key is up sometimes.
            // So we need to call focus again to bring it back.
            if ($D.isIE) {
                $D.attachEvent(dom, 'keyup', function (evt) {
                    var e = evt || window.event;
                    if (e.keyCode === TAB_KEY) {
                        me.focus();
                    }
                });
            }
        },
        
        // set autoCloseLocked true/false to decide wheather closing the info window or not.
        setInfoWindowLock: function(isLock) {
        	lockInfoWindow(this.owner, isLock);
        }
    };
}());
(function(){
	mstrmojo.requiresCls("mstrmojo.num","mstrmojo.VisChartUtils");

	// check if the series are percent (%) values
	var percent = 0;
	
	var $NUM = mstrmojo.num;
	
	var NumUnits = [{n:1, s:""}, {n:1000, s:"K"}, {n:1000000, s:"M"}, {n:1000000000, s:"B"}, {n:1000000000000, s:"T"}, {n:1000000000000000, s:"Q"}];
	var DEFAULT_LEN_LIMIT = 3;
	var MAX_LEN_LIMIT = 5;
	
	function normalizeValue(val, interval, isFloor) {

		var ceilOrFloor = function(val, isFloor) {
			return isFloor ? Math.floor(val) : Math.ceil(val); 
		};
		
		var lab = ceilOrFloor(val/interval, isFloor) * interval;

		if(lab.toString().indexOf(".") >= 0 && interval < 1 && lab > 1) {
			lab = parseFloat(lab.toFixed(2));
		}

		if(lab > 0 && lab < 1 && interval > 1 / 1000) {// xiawang: if the interval is extremely small, using 1 percent might not be enough to properly show the data range
			lab = parseInt(ceilOrFloor(lab * 100, isFloor)) / 100;
		}
		return lab;
	}
	
	function updateSeriesRawValues(s, ds) {
		if(!ds) {
			ds = ','; // default to ,
		}
		var sl = s.length;
		for(var i = 0; i < sl; i++) {
			var rvs = s[i].rv,
				l = rvs.length;
			for(var j = 0; j < l; j++) {
				if(Number(rvs[j])) {
					break; // series is numbers not string don't do anything
				}
				rvs[j] = rvs[j].replace(ds,'.');
			}
		}
	}
	
	mstrmojo.VisChartData = mstrmojo.provide(
			"mstrmojo.VisChartData",
			/**
			 * @lends mstrmojo.VisChartData
			 */
			{
				
				process: function prcss(w) {
	
					if((!w.baseModel && w.model) || w.model.vp) {
						this.setDerivedModel(w);
						//Check if we the series raw data contains anything else but . if yes update data
						var bm = w.baseModel,
							ch = bm.colHeaders,
							chl = ch.length,
							ds = ch[chl -1].items[0].ds;
						if(ds && ds !== '.') {
							updateSeriesRawValues(bm.series, ds);
						} else if(!ds) {
							updateSeriesRawValues(bm.series);
						}
					}
	
					//debugger; // this is to stop at this point for debugging in androidApp page
					//local variables
					var	model = w.model;
					var	values = model.series,
					l = values.length;
					
					if (l <= 0) {
						return;
					}
	
					//make sure this is non linear chart and we are going to draw labels
					var nlc = !w.isLinearChart && w.isDrawAxis && w.drawYAxisLabels,
						ms = "";
	
					percent = 0;
					
					//return the values of all the points on Y axis sorted ascending
					var v = new Array(); 
					if (values && values[0] && values[0].rv.length) {
						for(var j = 0; j < l; j++) {
							var s = values[j].rv,
								sl = s.length,
								k = v.length;	
							for(var i = 0; i < sl; i++ ) {
								var val = s[i];
								// if value is not defined skip it
								if(!val || val.length == 0) {
									continue;
								}
								
								if(percent === 0) {
									// check if the series are percent (%) values or not
									percent = values[j].v[i].indexOf('%')  >= 0 ? 100 : 1;
								}
								
								v[k] = parseFloat(val);
								if(nlc && v[k].toString().length > ms.length) {
									ms = v[k].toString();
								}
								k++;
							}
						}
						v = v.sort(function sortArray(a,b){return a - b;});
					}
					model.mvalues = v;
					if(nlc) {
						//model.mls is the max label size
						model.mls = ms;
						model.ylbls = v;
					}
				},
	
				setDerivedModel: function sdm(w) {
					var m = w.model,
						s = m.series,
						sl = s.length,
						ri = m.ri,
						rows = m.rowHeaders,
						cols = m.colHeaders; // number of columns present we support one attribute and multiple metrics on columns.
					
					var rl = typeof(m.vp) !== 'undefined' && m.vp.rl && m.vp.rl.length > 0 ? m.vp.rl : null;
					
					w.baseModel = m;
					
					//If we have custom properties compute the range of first element
					//Compute the slice we need to draw
					var rne = s[0].rv.length,
						rns = 0;
					if(rl && w.isTimeSeries) {
						var rs = parseInt(rl[0].rs),
						 	sr = rl[0].sr;
						for(var i = 0; i < rows.length; i++) {
							// Now match which row is it to get the start point of the range
							if(rows[i].id == sr) {
								rns = rne - (rows[i].l * rs) >= 0 ? rne - (rows[i].l * rs) : 0;
								break;
							}
						}
					}
					w.model = { categories:m.categories, mtrcs:m.mtrcs, series:s, colHeaders:cols, rowHeaders:rows, rne:rne, rns:rns, ri:ri};
					
				},
				
				processLinearData: function pld(w) {
					this.process(w);
					var model = w.model;
					var vals = model.mvalues,
					_max = w.getMaxValue(),
					_min = w.getMinValue();
					
					var _lbs = this.generateAxisLabels(w, _max, _min);
					model.mvalues = _lbs;
					
	
					var da = w.isDrawAxis && w.drawYAxisLabels;
					
					var useAbbr = w.isTimeSeries ? w.formatProp.condenseLabels : true;
					
					if(da) {
						var res = this.condenseLabels(_lbs, DEFAULT_LEN_LIMIT);
						if(useAbbr){
							var duplicatedCondensed = this.checkDuplicatedCondensed(res.condensedLabels);
							if(duplicatedCondensed){
								for (i=DEFAULT_LEN_LIMIT+1; i<MAX_LEN_LIMIT; ++i) {
									res = this.condenseLabels(_lbs, i);
									duplicatedCondensed = this.checkDuplicatedCondensed(res.condensedLabels);
									if (!duplicatedCondensed) {
										break;
									}
								}
								
								// if still duplicated, don't condense.
								if (duplicatedCondensed) {
									useAbbr = false;
								}
							}
							model.mls = res.maxLabel;
							model.ylbls = res.condensedLabels;
						}
						
						if(!useAbbr){						
							var formatedStr = [];
							var ms = "";
							
							var items = model.colHeaders[model.colHeaders.length - 1].items;
							var formatMask = items && items[0] && items[0].f || "";
							
							for(var i = 0; i < _lbs.length; i++){
								formatedStr[i] = $NUM.formatByMask(formatMask, _lbs[i]);
								
								if(formatedStr[i].toString().length > ms.length) {
									ms = formatedStr[i].toString();
								}
							}
							
							model.mls = ms;
							model.ylbls = formatedStr;
						}
											
						
					}
	
				},
				
				checkDuplicatedCondensed: function checkDuplicatedCondensed(lbls){
					var duplicatedCondensed = false;
					for (var i=1; i<lbls.length; i++) {
						if (lbls[i] == lbls[i-1]) {
							duplicatedCondensed = true;
							break;
						}
					}
					
					return duplicatedCondensed;
				},
				
				condenseLabels: function condenseLabels(lbls, lenLimit){
					var ll = lbls.length;
					var ms = "";
					var _lbstr = new Array();					
					
					for(var i = 0; i < ll; i++) {
						//if greater than 1000 and less than million put K symbol else if greator than 1 million put
						// M symbol else leave it as it is
						_lbstr[i] = this.formatNumber(lbls[i], lenLimit);
						
						if(_lbstr[i].toString().length > ms.length) {
							ms = _lbstr[i].toString();
						}
					}
					
					return {condensedLabels:_lbstr, maxLabel:ms};
				},
				
				generateAxisLabels: function generateAxisLabels(w, _max, _min, intAsStep){
					var _lbs = new Array();
					
					if(_max == _min){
						if( _min < 0){
							_lbs.push(_min);
						}
						_lbs.push(0);
						if(_min > 0){
							_lbs.push(_min);
						}
						
						return _lbs;
					}
					
					var interval = this.calInterval(_max, _min, intAsStep);
									
					/*
					 * if use custom axis scale, we will not normalize the max and min label value
					 * Instead we will use exactly the max and min value user set
					 */
					if(w.isTimeSeries && w.formatProp.useCustomAxisScale){
						var labelMax = _max;					
						var labelMin = _min;
					}else{
						var labelMax = normalizeValue(_max, interval, false);					
						var labelMin = normalizeValue(_min, interval, true);
						
					}
					
					//PM required:If the numeric difference between the MINdata and (Minimun-1) tick-label divided by the step size is less then 10%:Set the (Minimum-1) tick-label to Minimum tick-label
					if((_min - labelMin) > 0.9*interval){
						labelMin =  normalizeValue(_min, interval, false);//_min;
					}
					
					if((labelMax - _max) > 0.9*interval){
						labelMax =  normalizeValue(_max, interval, true);//_max;
					}
					_lbs = new Array();
					
					
	//				var intervalCount = Math.floor((labelMax - labelMin + interval/100)/interval) + 1;
	//				for(var i = 0; i < intervalCount; i++){
	//					var tickValue = this.formatNumber(labelMin + i*interval, 3);
	//					_lbs.push();
	//				}
					
					if( interval < ((labelMax - labelMin) / 30)){
						//too small intervals, show only two ticks
						_lbs.push(labelMin);
						_lbs.push(labelMax);
					}else{
						var currentValue = labelMin;
						
						while(currentValue <= labelMax){
							_lbs.push(currentValue);
							if(currentValue == labelMin){
								currentValue  = Math.ceil((labelMin + interval/100)/interval)*interval;
							}else{
								currentValue = Math.ceil((currentValue + interval) * 1000) / 1000; // xiawang: there is a risk of infinite loop in original implementation of using round
							}
						}
						if(_lbs[_lbs.length - 1] < labelMax){
							_lbs.push(labelMax);
						}
					}
					
					return _lbs;
				},
				
				formatNumber: function formatNumber(number, lenLimit){
					var os = "",
						on = 1,
						posNum = number  * percent;
					if(posNum < 0){
						posNum = -number * percent;
						on = -1;
						os = "-";
					}
					
					if(posNum <= 1+1e-6){
						// simply deal with the number less than 1 currently.
						on *= posNum;
						if (posNum.toString().length <= lenLimit) {
							os += posNum;
						}
						else {
							var precision = 2;
							os += posNum.toFixed(precision);
							// eliminate the last "0" if exists
							
							for (var i=os.length-1; i>=0; --i) {
								if (os.charAt(i) == '.') {
									break;
								}
								else if (os.charAt(i) != '0') {
									++i
									break;
								}
							}
							if (i < os.length) {
								os = os.substr(0, i);
							}
						}
					}else{
						
						var power = Math.log(posNum)/Math.LN10 + 1e-6;
						var n = parseInt(power / 3);					
						
						if (n >= NumUnits.length) {
							n = NumUnits.length - 1;
						}
						var fNum = posNum / NumUnits[n].n;
						var sNum = fNum.toString();
						
						if (sNum.length > lenLimit) {
							var separatorIdx = sNum.indexOf('.');
							var fracLen = separatorIdx < 0 ? 0 : sNum.length - separatorIdx + 1,
								intLen = separatorIdx < 0 ? sNum.length : separatorIdx;
							var nPrecision = lenLimit - intLen - 1;
							// 3 here means the factor of the adjacent elements is 1e3.
//							var nPrecision = lenLimit - 2 - parseInt(power) % 3;
							
							
							sNum = fNum.toFixed(nPrecision < 0 ? 0 : nPrecision);
							
						}
						on *= parseFloat(sNum) * NumUnits[n].n;
						os += sNum + NumUnits[n].s;
					}
					
					return os;				
				},
	
				calInterval: function cInt(_max, _min, intAsStep) {
					var interval,	
						diff = (_max - _min);
					if(diff == 0) {
						if(_max == 0) {
							_max = 1;
							_min = -1;
						} else {
							_max = _max * 2;
							_min = _min / 2;
						}
						diff = _max - _min;
					}
					
					interval = 1;
					if(diff < 1){
						while(diff < 1){
							diff *= 10;
							interval /= 10;
						}
					} else if(diff >= 10){
						while(diff >= 10){
							diff /= 10;
							interval *= 10;
						}
					}
	
					if(diff < 1.8){
						interval *= 0.2;
					} else if(diff < 3.1){
						interval *= 0.4;
					} else if(diff < 4.6){
						interval *= 0.5;
					} else if(diff >= 8.1){
						interval *= 2;
					}
	
					if(intAsStep){
						interval = Math.round(interval);
						if(interval < 1){
							interval = 1;
						}
					}else if((interval > 0 && interval < 1) && (parseInt(interval.toFixed(2) * 100) / 100) > 0) {
						interval = parseInt(interval.toFixed(2) * 100) / 100;
					}
					
					return interval;
				}
			});

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.func",
                         "mstrmojo.Obj");

    var $HASH = mstrmojo.hash;
    
    /**
     * Counter for ensuring unique request submission IDs.
     *
     * @type Integer
     * @static
     * @private
     */
    var cnt = 0;

    /**
     * Queue for requests.
     *
     * @type Object[]
     * @static
     * @private
     */
    var requestQueue = [];

    /**
     * Collection of currently processing graph request keys.
     *
             * @type Object
     * @static
     */
    var graphRequests = {};

    /**
     * Flag to indicate that all requests should be held until graphs have processed.
     *
     * @type boolean
     * @default false
     * @static
     */
    var holdForGraphs = false;

    /**
     * Method for submitting requests.
     *
     * @param {Object} request The request to submit.
     *
     * @private
     */
    function handleSubmission(request) {
        var callback = request.callback;

        // Do we have a submission handler?
        if (callback.submission) {
            // Call it.
            callback.submission( this.userInteractionRequired( request ) );
        }

        // Submit the request.
        this.submitRequest(request);
    }

    /**
     * Checks queue for requests and submits next request (if found).
     *
     * @private
     */
    function submitNextInQueue() {
        // Are there any requests in the queue?
    	// #532349. Do not submit the request if we're still processing graph requests.
    	// the last added graph will submit the holding request.
        if (requestQueue.length && !holdForGraphs) {
            // Shift the first request out of the queue and submit.
            handleSubmission.call(this, requestQueue.shift());
        }
    }

    /**
     * Proxy object to handle server requests.
     *
     * @class
     * @extends mstrmojo.Obj
     */
    mstrmojo.ServerProxy = mstrmojo.declare(
        mstrmojo.Obj,

        null,

        /**
         * @lends mstrmojo.ServerProxy.prototype
         */
        {
            scriptClass: 'mstrmojo.ServerProxy',

            /**
             * The server transport mechanism.
             *
             * @type mstrmojo.Obj
             */
            transport: null,

            cnt: 0,

            /**
             * Assembles the request and submits it to the server transport mechanism.
             *
             * @param {Object} callback An object containing functions to be called as the request process proceeds.
             * @param {Function} callback.submission A function called as the server request is initiated.
             * @param {Function} callback.success A function called when the server request completes successfully.
             * @param {Function} callback.failure A function called if the server request fails for any reason.
             * @param {Function} callback.complete A function called when the server request is completed, regardless of status.
             * @param {Object} params An object containing the task parameters for this request.
             * @param {Boolean} [override=false] TRUE if all preceding server requests should be canceled in favor of this one.
             * @param {Object} [config] An optional object containing configuration parameters for the server transport.
             */
            request: function request(callback, params, override, config) {
                // If override is true then kill any outstanding requests.
                if (override) {
                    this.cancelRequests();
                }

                var proxyId = this.id,
                    transport = this.transport,
                    requestId = mstrmojo.now() + params.taskId + cnt++,
                    callbackCancel = callback.canceled || mstrmojo.emptyFn;

                // We don't want to wrap the cancelled method since we need to propagate the return value.
                callback.canceled = function (id) {
                    // Call the callback paramter's cancel method.
                    callbackCancel();

                    // Call complete, passing TRUE to indicate that the request was canceled.
                    callback.complete(true);

                    // Cancel server request.
                    return transport.cancelRequest(id);
                };

                // Wrap callback methods.
                callback = mstrmojo.func.wrapMethods(callback, {
                    complete: function (id) {
                        // Delete request.
                        mstrmojo.all[proxyId].deleteRequest(id);
                    }
                });

                // Determine holding status and then create new request object.
                // DJH: don't hold the request if it is a login task. On Android we automatically issue
                //      login tasks if the user is not currently logged into the project.
                var existingRequests = !$HASH.isEmpty(this._requests),
                    newRequest = this.createRequest(requestId, callback, params, config),
                    /*                                                      TQMS 652803 */
                    holdRequests = (holdForGraphs || existingRequests) && ! config.doNotHold;

                // Should we hold requests?
                if (holdRequests) {
                    // YES, add this request to the queue.
                    requestQueue.push(newRequest);
                } else {
                    // NO, submit this request.
                    handleSubmission.call(this, newRequest);
                }
            },

            /**
             * <p>Creates a request and stores it in the _requests collection.</p>
             *
             * <p>Subclasses should override this method to add custom data to the request object.
             *
             * @param {String} requestId The id for the new request.
             * @param {Object} callback The callback object as submitted in {@link mstrmojo.ServerProxy.request}.
             * @param {Object} params An object containing the task parameters for this request.
             *
             * @returns Object Newly created request object.
             */
            createRequest: function createRequest(requestId, callback, params, config) {
                var reqsCollection = this._requests;

                // Is this the first request?
                if (!reqsCollection) {
                    // Initial the requests collection.
                    reqsCollection = this._requests = {};
                }

                // Store request.
                var request = reqsCollection[requestId] = {
                    id: requestId,
                    callback: callback,
                    params: params,
                    config: config
                };

                // Return request.
                return request;
            },

            /**
             * <p>Submits the request via the transport mechanism indicated in {@link mstrmojo.ServerProxy.transport}.</p>
             *
             * <p>Subclasses will override this method to add any custom transport handling.</p>
             *
             * @param {Object} request The request object as created in {@link mstrmojo.ServerProxy.createRequest}.
             */
            submitRequest: function submitRequest(request) {
                this.transport.serverRequest(this.id, request.id, request);
            },

            /**
             * Cancels all outstanding requests.
             *
             */
            cancelRequests: function cancelRequests() {
                var didCancel = false;

                // Iterate current requests and call their complete callback handler.
                $HASH.forEach(this._requests, function (request) {
                    // Has the request NOT already gotten a response?
                    if (typeof request.gotResponse === "undefined") {
                        // Cancel the request, caching the returned cancel status.
                        didCancel |= request.callback.canceled(request.id);
                    }
                });

                // Reset requests collection.
                this._requests = {};

                // Reset request queue.
                requestQueue = [];

                // Return cancel status.
                return didCancel;
            },

            /**
             * Receives the results from making the server request.
             *
             * @param {String} requestId The id of the request results being returned.
             * @param {Boolean} status True if the request succeeded.
             * @param {Object} res The response from the server.
             */
            response: function response(requestId, status, res) {

                // Cease profiling the server request.
                $MAPF(false, "AndroidServerTransport", 'transportRequest');

                // Do we have a request for this ID?
                var request = this.getRequest(requestId);
                if (request) {
                    // Mark the response as handled.  This will prevent the response being cancelled if
                // our success or failure callback attempts to fire off another request that has the override property set TRUE
                request.gotResponse = true;

                    // Retrieve the callback from the request object and determine whether to call 'success' or 'failure' (based on status and presence of "mstrerr" property).
                var callback = request.callback,
                    methodName = (status && !res.mstrerr) ? 'success' : 'failure';  // mstrerr means the request completed, but with an error on the server.

                try {
                    // Does the callback have a handler for the result?  If not we ignore assuming the callback doesn't care about result.
                    if (callback[methodName]) {
                        // Call it.
                        callback[methodName](res, request);
                    }
                } finally {
                    // Always call the 'complete' handler.
                    callback.complete(requestId);
                }
                }

                // Submit next request in queue.
                submitNextInQueue.call(this);
            },

            /**
             * Deletes a request from the request collection.
             *
             * @param {String} requestId The ID of the request to be cancelled.
             */
            deleteRequest: function deleteRequest(requestId) {
                var requestCollection = this._requests;
                delete requestCollection[requestId];
            },

            /**
             * Returns a request from the request collection.
             *
             * @param {String} requestId The ID of the request to be returned.
             */
            getRequest: function getRequest(requestId) {
                var requestCollection = this._requests;
                return requestCollection && requestCollection[requestId];
            },
      
            /**
             * Returns TRUE if user interaction is required to process request
             *
             * @param {Object} request request being processed
             */      
            userInteractionRequired: function userInteractionRequired(request) {
                return false;
            },

            /**
             * Adds the graph key to the graph requests collection and holds all requests until collection is empty.
             *
             * @param {String} key The key of the graph currently processing.
             */
            addLoadingGraph: function addLoadingGraph(key) {
                // Store key in collection.
                graphRequests[key] = true;

                // Hold all requests.
                holdForGraphs = true;
            },

            /**
             * Adds the graph key from the graph requests collection and submits queued requests (if any).
             *
             * @param {String} key The key of the graph that is done processing.
             */
            removeLoadingGraph: function removeLoadingGraph(key) {
                // Remove key from collection.
                delete graphRequests[key];

                // Is collection empty?
                if ($HASH.isEmpty(graphRequests)) {
                    // Clear hold status.
                    holdForGraphs = false;

                    // Submit next request in queue.
                    submitNextInQueue.call(this);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo._LoadsScript",
                         "mstrmojo.Binding",
                         "mstrmojo._HasBindings",
                         "mstrmojo._HasMarkup",
                         "mstrmojo._HasTooltip");

    /**
     * <p>Base UI widget class.</p>
     *
     * <p>A Widget is an enhanced Obj with the ability to:
     * <ul>
     * <li>load additional javascript methods at run-time,</li>
     * <li>use "bindings" to set its property values dynamically, and</li>
     * <li>render markup.</li>
     * </ul>
     * </p>
     *
     * @class
     * @extends mstrmojo.Obj
     */
    var $WIDGET = mstrmojo.Widget = mstrmojo.declare(
        // superclass
        mstrmojo.Obj,

        // mixins
        [mstrmojo._LoadsScript, mstrmojo._HasBindings, mstrmojo._HasMarkup, mstrmojo._HasTooltip],

        /**
         * @lends mstrmojo.Widget.prototype
         */
        {
            /**
             * @ignore
             */
            scriptClass: "mstrmojo.Widget",

            /**
             * Handle to the root DOM node of this widget's HTML, if rendered.
             * @type HTMLElement
             */
            domNode: null,

            /**
             * <p>Indicates whether this widget has been rendered.</p>
             * @type Boolean
             */
            hasRendered: false,

            /**
             * Specifies whether or not this widget's DOM node should be visible.
             * @type Boolean
             */
            visible: true,

            /**
             * Specifies whether or not this widget responds to events originating within its DOM.
             * @type Boolean
             */
            enabled: true,
            /**
             * <p>The tooltip for this widget.</p>
             *
             * @type String
             */
            tooltip: '',

            /**
             * Optional CSS class for the domNode. Used for customization.
             * @type String
             */
            cssClass: "",

            /**
             * Optional text to appear in the domNode "style" attribute. Used for customization.
             * @type String
             */
            cssText: "",

            /**
             * The display value to use when this widget is visible.
             *
             * @type String
             * @default block
             */
            cssDisplay: 'block',

            /**
             * <p>Extends the inherited method in order to do the following after initializing itself:
             * <ol>
             * <li>initialize this object's bindings (if any), and</li>
             * <li>call the "postCreateBindings" handler (if any).</li>
             * </ol>
             * </p>
             *
             * @constructs
             * @extends mstrmojo.Obj
             */
            init: function init(props) {
                this._super(props);

                // If we are an orphan, init our bindings now (if any). Otherwise we have a parent,
                // and that parent is responsible for calling us later to init our bindings, after it
                // has finished constructing its children; exception: if our parent has already
                // init'd its bindings, we can do so now.
                // Note: even if we don't have a "bindings" property, we might have references to other
                // widgets (such as list items) which do have bindings, so we should still call initBindings.
                var p = this.parent;
                if (!p || p.hasInitBindings) {
                    this.initBindings();
                }
            },

            /**
             * <p>Extends the inherited method in order to unrender the widget and destroy its bindings before destroying the widget.</p>
             *
             * <p>Bindings are destroyed after the widget in unrendered in order to minimize DOM updates during the destruction of the bindings.</p>
             *
             * @param {Boolean} [skipCleanup] If true, this flag indicates that some parent/ancestor of this object
             * will handle some cleanup after this object is destroyed. Used as a performance optimization.
             */
            destroy: function dst(skipCleanup) {
                if (this.hasRendered) {
                    this.unrender(skipCleanup);
                }
                if (this.bindings) {
                    this.destroyBindings();
                }
                this._super();
            },

            /**
             * When this method is called it means that the widget is not being destroyed but it's data is no longer valid.
             *
             */
            invalidate: mstrmojo.emptyFn
        }
    );

    /**
     * Default markup method for use in subclasses of mstrmojo.Widget for when the cssText property changes.
     *
     * @static
     */
    $WIDGET.cssTextMarkupMethod = function () {
        this.domNode.style.cssText = this.cssText || '';
    };

    /**
     * Default markup method for use in subclasses of mstrmojo.Widget for when the visible property changes.
     *
     * @static
     */
    $WIDGET.visibleMarkupMethod = function () {
        this.domNode.style.display = (this.visible) ? this.cssDisplay : 'none';
    };

    $WIDGET.heightMarkupMethod = function () {
        this.domNode.style.height = this.height || '';
    };

    $WIDGET.widthMarkupMethod = function () {
        this.domNode.style.width = this.width || '';
    };

}());
(function(){

    mstrmojo.requiresCls("mstrmojo.Obj");
    
    mstrmojo.StepperContentProvider = mstrmojo.declare(
        // superclass
        mstrmojo.Obj,
        
        // mixins
        null,
        
        {
            scriptClass: "mstrmojo.StepperContentProvider",
            
            /**
             * The object that actually holds the stepping data.
             * 
             * @type mstrmojo.Obj
             */
            item: null,
            
            /**
             * This property could be set to a renderer object. If not, the value of the stepper will be displayed by default.
             * 
             * @type Object,
             * @default null
             */
            renderer: null,
            
            /**
             * Denotes the min value supported by the stepper. If null, it defaults to an infinite stepper
             * 
             * @default null
             */
            min: null,
            
            /**
             * Denotes the max value supported by the stepper. If null, it defaults to an infinite stepper.
             * 
             * @default null
             */
            max: null,
            
            /**
             * Denotes the step size. 
             * 
             * @type Integer
             * @default 1
             */
            interval: 1,

            /**
             * This property can be set to the name of the property of the stepper widget that holds the min value. 
             * 
             * @default 'min'
             */
            minField: "min",
            
            /**
             * This property can be set to the name of the property of the stepper widget that holds the max value. 
             * 
             * @default 'max'
             */
            maxField: "max",
            
            /**
             * This property can be set to the name of the property of the stepper widget that holds the min value. 
             * 
             * @default 'value'
             */
            valField: "value",
            
            /**
             * This property can be set to the name of the property of the stepper widget that holds the interval value. 
             * 
             * @default 'interval'
             */
            intField: "interval",
            
            /**
             * Property determines whether the stepper should loop. This will only work if there is a min and max set.
             * 
             * @default false
             */
            canLoop: false,
            
            /**
             * This function gets invoked when the user presses the next button on the stepper. This method performs the calculations
             * and does not render.
             */
            next: mstrmojo.emptyFn,
            
            /**
             * This function gets invoked when the user presses the prev button on the stepper. This method performs the calculations
             * and does not render.
             */
            prev: mstrmojo.emptyFn,
            
            /**
             * This function gets invoked when the user presses the prev button on the stepper. This method tells the stepper if the 
             * data provider has a previous value for it.
             */
            hasPrev: mstrmojo.emptyFn,
            
            /**
             * This function gets invoked when the user presses the next button on the stepper. This method tells the stepper if the 
             * data provider has a next value for it.
             */
            hasNext: mstrmojo.emptyFn,
            
            /**
             * This method renders the item using the renderer at the given location.
             * 
             * @param {Number} stepDelta The number of intervals of delta for which the item should be rendered.
             * If no delta is provided, it defaults to the current value. 
             */
            renderItemAt: mstrmojo.emptyFn
        }
    );
}());           
(function () {

    mstrmojo.requiresCls("mstrmojo.StringBuffer",
                         "mstrmojo.hash",
                         "mstrmojo.dom",
                         "mstrmojo._IsGraphDataService",
                         "mstrmojo.func");

    mstrmojo.requiresDescs(8445);

    var $H = mstrmojo.hash;
    var $DOM = mstrmojo.dom;
    var $PST = [mstrmojo.desc(8445, 'Loading')];
    var updateNum = 0;

    function submitRequest(params, callback, config) {
        var updateId = updateNum++,
        	updates = this.getTxUpdates(updateId);
        // Add caller name as the server request source (for error handling).
        config = config || {};
        config.src = arguments.callee.caller.name;

        if (!mstrmojo.string.isEmpty(updates)) {
            params.updateChanges = updates;
        }

        // Submit request.
        mstrApp.serverRequest(params, this.wrapCallback(callback, updateId), config);
    }

    function addContentSize(request) {

    	//Are we running on mobile?
    	var availableDim = window.mstrMobileApp ? this.model.controller.getContentDimensions() : mstrApp.getContentDimensions();

        if (availableDim) {
            // We must be on a mobile device so add style name as well.
            request.styleName = 'RWDocumentMobileStyle';
            request.availableWidth = availableDim.w;
            request.availableHeight = availableDim.h;
        }
    }

    /**
     * <p>Document data service.</p>
     *
     * @class
     * @extends mstrmojo.Obj
     */
    mstrmojo.DocDataService = mstrmojo.declare(
        mstrmojo.Obj,

        [mstrmojo._IsGraphDataService],

        /*
         * @lends mstrmojo.DocDataService.prototype
         */
        {
            scriptClass: "mstrmojo.DocDataService",

            wrapCallback: function wrapCallback(callback, updateId) {
                var me = this;
                return mstrmojo.func.wrapMethods({
                    success: function (res) {
                        if (res) {
                            me.rwb = res.bs || me.rwb;
                            me.msgId = res.mid || me.msgId;
                        }
                        me.clearTxUpdates(updateId);
                    }, failure: function (res) {
                    	me.resetTxUpdates(updateId);
                    }
                }, callback);
            },

            refresh: function refresh(params, callback) {

            	var isRefresh = !!params.useRefreshProgress,
            		pst = isRefresh ? [mstrmojo.desc(10078, 'Refreshing data. Please wait.')] : $PST;

            	delete params.useRefreshProgress;

            	submitRequest.call(this, $H.copy(params, {
                    taskId: 'docRefresh',
                    rwb: this.rwb,
                    rePrompt: false,
                    fresh: false,
                    regenerate: false
                }), callback,  {
                    showProgress:true,
                    hideProgress:true,
                    progressStateText: pst,
                    useRefreshProgress: isRefresh
                });
            },

            getTxUpdates: function getTxUpdates(t) {
                var m = this.model;
                return m && m.getTransactionUpdates && m.getTransactionUpdates(t);
            },

            clearTxUpdates: function clearTxUpdates(t) {
                var m = this.model;
                if (m && m.clearTransactionUpdates) {
                    m.clearTransactionUpdates(t);
                }
            },

            resetTxUpdates: function resetTxUpdates(t) {
                var m = this.model;
                if (m && m.resetTransactionUpdates) {
                    m.resetTransactionUpdates(t);
                }
            },

            loadDocLayout: function loadDocLayout(params, callback) {
                // Create parameters.
                var taskParams = $H.copy(params, {
                    taskId: 'loadDocLayout',
                    rwb: this.rwb
                });

                // Add content size parameters to the request.
                addContentSize.call(this, taskParams);

                // Submit request.
                submitRequest.call(this, taskParams, callback, {
                        showProgress:true,
                        hideProgress:true,
                        progressStateText: $PST
                    }
                );

            },

            setCurrentDocLayout: function setCurrentDocLayout(layoutKey, callback) {
                callback = callback || null;

                submitRequest.call(this, {
                    taskId: 'setDocLayout',
                    rwb: this.rwb,
                    layoutKey: layoutKey
                }, callback, {
                    silent: (callback === null)
                });

                if(typeof mstrMobileApp !== 'undefined') {
                	mstrMobileApp.clearWebViewCache(false);
                }
            },

            fetchDocPage: function fetchDocPage(position, callback) {
                submitRequest.call(this, {
                    taskId: 'fetchDocPage',
                    rwb: this.rwb,
                    pos: position
                }, callback);
            },

            /**
             * Silently updates the server as to which panel is currently selected.
             *
             * @param {String} panelKey The RW Unit key of the currently selected panel.
             * @param {String} panelStackKey The RW Unit key of the panel stack containing the panel.
             * @param {String} selectorKeyContext The selector keys context.
             */
            setCurrentPanel: function setCurrentPanel(panelKey, panelStackKey, selectorKeyContext, callback) {
                submitRequest.call(this, {
                    taskId: 'setCurrentPanel',
                    rwb: this.rwb,
                    key: panelKey,
                    panelStackKey: panelStackKey,
                    selectorKeyContext: selectorKeyContext
                }, callback, {
                    silent: true   // Silent update so XHR shouldn't fail on empty payload.
                });
            },

            /**
             * Downloads a partial update tree for the indicated panel.
             *
             * @param {String} panelKey The RW Unit key of the currently selected panel.
             * @param {String} panelStackKey The RW Unit key of the panel stack containing the panel.
             * @param {String} selectorKeyContext The selector keys context.
             * @param {String} dirtyKeys The collection of the panels dirty child keys.
             * @param {Boolean} useLoader A boolean that will indicate whether to show a default loading message.
             * @param {Object} [callback] An optional object containing functions to be called as the request process proceeds.
             * @param {Function} [callback.submission] A function called as the server request is initiated.
             * @param {Function} [callback.success] A function called when the server request completes successfully.
             * @param {Function} [callback.failure] A function called if the server request fails for any reason.
             * @param {Function} [callback.complete] A function called when the server request is completed, regardless of status.
             */
            requestNewPanel: function requestNewPanel(panelKey, panelStackKey, selectorKeyContext, dirtyKeys, useLoader, callback) {
                submitRequest.call(this, {
                    taskId: 'requestNewPanel',
                    rwb: this.rwb,
                    key: panelKey,
                    panelStackKey: panelStackKey,
                    selectorKeyContext: selectorKeyContext,
                    dirtyKeys: dirtyKeys
                }, callback, {
                    showProgress: useLoader,
                    hideProgress: useLoader,
                    progressStateText: $PST
                });
            },

            /**
             * Applies a selector action from a graph.
             *
             * @param {String} selectorKeyContext The selector keys context.
             * @param {String} targetList A collection of target keys for this selector operation.
             * @param {String} sliceID The slice ID for the graph that is making this selector request.
             * @param {Integer} x The position along the horizontal axis of the graph image that the user clicked.
             * @param {Integer} y The position along the vertical axis of the graph image that the user clicked.
             * @param {Object} [callback] An optional object containing functions to be called as the request process proceeds.
             * @param {Function} [callback.submission] A function called as the server request is initiated.
             * @param {Function} [callback.success] A function called when the server request completes successfully.
             * @param {Function} [callback.failure] A function called if the server request fails for any reason.
             * @param {Function} [callback.complete] A function called when the server request is completed, regardless of status.
             */
            applyGraphSelectorAction: function applyGraphSelectorAction(selectorKeyContext, targetList, sliceID, x, y, callback, zoomFactor) {
                submitRequest.call(this, {
                    taskId: 'applyGraphSelectorAction',
                    rwb: this.rwb,
                    selectorKeyContext: selectorKeyContext,
                    ctrlKeys: targetList,
                    sliceID: sliceID,
                    x: x,
                    y: y,
                    zoomFactor : zoomFactor
                }, callback);
            },

            /**
             * Applies a selector action.
             *
             * @param {String} selectorKeyContext The selector keys context.
             * @param {String} elemList The list of elements selected.
             * @param {String} controlKey The control key of the selector.
             * @param {Boolean} includeClause The include/exclude expression condition.
             * @param {Object} [callback] An optional object containing functions to be called as the request process proceeds.
             * @param {Function} [callback.submission] A function called as the server request is initiated.
             * @param {Function} [callback.success] A function called when the server request completes successfully.
             * @param {Function} [callback.failure] A function called if the server request fails for any reason.
             * @param {Function} [callback.complete] A function called when the server request is completed, regardless of status.
             * @param {Integer} zoomFactor of the document
             */
            setDocSelectorElements: function setDocSelectorElements(selectorKeyContext, elemList, controlKey, includeClause, callback, zoomFactor, useAndroidTask, sdpKeys, tks, disablePU) {
                var params = {
                    taskId: 'setDocSelectorElements',
                    rwb: this.rwb,
                    selectorKeyContext: selectorKeyContext,
                    elemList: elemList,
                    ctlKey: controlKey,
                    zoomFactor : zoomFactor
                };

                if ($DOM.isAndroid || useAndroidTask) {
                    params.taskId = 'androidSetDocSelectorElements';
                }

                if (includeClause !== null && includeClause !== undefined) {
                    params.include = includeClause;
                }

                if(sdpKeys)
        		{
        		   params.sdpKeys = sdpKeys;
        		}
                if ( tks ) {
                    params.tks = tks;
                }
                
                if (disablePU) {
                	params.usePartialUpdate = '0';
                }

                submitRequest.call(this, params, callback, {
                    showProgress: true,
                    hideProgress: true,
                    progressStateText: $PST,
                    delay: true
                });
            },

            /**
             * Visualization widget as selector
             */
            setDocVisSelectorElements: function setDocVisSelectorElements(selectorKeyContext, elemList, controlKey, includeClause, callback, zoomFactor, useAndroidTask, sdpKeys, tks) {
                var params = {
                    taskId: 'setDocVisSelectorElements',
                    rwb: this.rwb,
                    selectorKeyContext: selectorKeyContext,
                    elemList: elemList,
                    ctlKey: controlKey,
                    zoomFactor : zoomFactor
                };

                if ($DOM.isAndroid || useAndroidTask) {
                    params.taskId = 'androidSetDocSelectorElements';
                }

                if (includeClause !== null && includeClause !== undefined) {
                    params.include = includeClause;
                }

                if(sdpKeys)
                {
                   params.sdpKeys = sdpKeys;
                }

                if ( tks ) {
                    params.tks = tks;
                }

                submitRequest.call(this, params, callback, {
                    showProgress: true,
                    hideProgress: true,
                    progressStateText: $PST,
                    delay: true
                });
            },


            /**
             * Applies a multi selector action.
             *
             * @param {Array} selectorObjects an array of selection info. Each selection info contains ck, ctlKey and eid for each attribute
             * @param {Boolean} multiSelect this is always true. But backend code need this flag.
             * @param {Object} [callback] An optional object containing functions to be called as the request process proceeds.
             * @param {Function} [callback.submission] A function called as the server request is initiated.
             * @param {Function} [callback.success] A function called when the server request completes successfully.
             * @param {Function} [callback.failure] A function called if the server request fails for any reason.
             * @param {Function} [callback.complete] A function called when the server request is completed, regardless of status.
             * @param {Integer} zoomFactor of the document
             */
            setMultiDocSelectorElements: function setMultiDocSelectorElements(selectorObjects, multiSelect, callback, zoomFactor) {
                var params = {
                    taskId: 'setMultiDocSelectorElements',
                    rwb: this.rwb,
                    multiSelect: multiSelect,
                    selectorObjects: selectorObjects,
                    zoomFactor : zoomFactor
                };

                submitRequest.call(this, params, callback, {
                    showWait: true,
                    hideWait: true,
                    delay: true
                });
            },

            /**
             * Applies a selector expression.
             *
             * @param {String} unitKeyContext The selector keys context.
             * @param {String} controlKey The control key of the selector.
             * @param {String} objectId The control key of the selector.
             * @param {String} objectType The control key of the selector.
             * @param {String} expressionFunction The control key of the selector.
             * @param {String} expressionFunctionType The control key of the selector.
             * @param {Boolean} includeClause The include/exclude expression condition.
             * @param {String} expressionConstants The control key of the selector.
             * @param {Integer} dataType The control key of the selector.
             * @param {Object} [callback] An optional object containing functions to be called as the request process proceeds.
             * @param {Function} [callback.submission] A function called as the server request is initiated.
             * @param {Function} [callback.success] A function called when the server request completes successfully.
             * @param {Function} [callback.failure] A function called if the server request fails for any reason.
             * @param {Function} [callback.complete] A function called when the server request is completed, regardless of status.
             * @param {Integer} zoomFactor of the document
             * @param {Bollean} a flag indicate whether the expression need to be unset
             */
            setDocSelectorExpression: function setDocSelectorExpression(unitKeyContext, controlKey, objectId, objectType, expressionFunction, expressionFunctionType, includeClause, expressionConstants, dataType, callback, zoomFactor, unset) {
                var params = {
                    taskId: 'setDocSelectorExpression' + (unset ? 'Unset' : ''),
                    rwb: this.rwb,
                    unitKeyContext: unitKeyContext,
                    ctlKey: controlKey,
                    objectId: objectId,
                    objType: objectType,
                    expFunction: expressionFunction,
                    expFunctionType: expressionFunctionType,
                    zoomFactor : zoomFactor
                };

                if (includeClause !== null && includeClause !== undefined) {
                    params.include = includeClause;
                }

                if (expressionConstants !== null && expressionConstants !== undefined) {
                    params.expConstants = expressionConstants;
                }

                if (dataType !== null && dataType !== undefined) {
                    params.dataType = dataType;
                }

                submitRequest.call(this, params, callback);
            },

            /**
             * Modifies a selector include/exclude condition.
             *
             * @param {String} controlKey The control key of the selector.
             * @param {Boolean} includeClause The include/exclude expression condition.
             * @param {Object} [callback] An optional object containing functions to be called as the request process proceeds.
             * @param {Function} [callback.submission] A function called as the server request is initiated.
             * @param {Function} [callback.success] A function called when the server request completes successfully.
             * @param {Function} [callback.failure] A function called if the server request fails for any reason.
             * @param {Function} [callback.complete] A function called when the server request is completed, regardless of status.
             * @param {Integer} zoomFactor of the document
             */
            setDocSelectorInclude: function setDocSelectorInclude(controlKey, includeClause, callback, objectID, objectType, zoomFactor) {
                var params = {
                    taskId: 'setDocSelectorInclude',
                    rwb: this.rwb,
                    include: includeClause,
                    ctlKey: controlKey,
                    zoomFactor : zoomFactor
                };

                if (objectID) {
                    params.objectID = objectID;
                }

                if (objectType) {
                    params.objType = objectType;
                }

                submitRequest.call(this, params, callback);
            },

            /**
             * Clears the selections and returns to the default state on a selector
             * @param {String} unitKeyContext The unitKeyContext of the selector.
             * @param {Function} [callback.submission] A function called as the server request is initiated.
             * @param {Function} [callback.success] A function called when the server request completes successfully.
             * @param {Function} [callback.failure] A function called if the server request fails for any reason.
             * @param {Function} [callback.complete] A function called when the server request is completed, regardless of status.
             * @param {String} controlKey The control key of the selector.
             * @param {Integer} zoomFactor of the document
             */
            setDocUnsetSelector: function setDocUnsetSelector(unitKeyContext, ctlKey, callback, zoomFactor) {
                submitRequest.call(this, {
                    taskId: 'unsetSelector',
                    rwb: this.rwb,
                    unitKeyContext: unitKeyContext,
                    ctlKey: ctlKey,
                    zoomFactor: zoomFactor
                }, callback);
            },

            /**
             * Request the RW graph image from the server.
             *
             */
            getRWGraphImage: function getRWGraphImage(params, callback) {
                var app = mstrApp,
                    id = this.id,
                    p = {
                        taskId: 'getRWGraphImage',
                        taskEnv: 'xhr',
                        imgType: 4,
                        messageID: this.msgId,
                        nodeKey: params.k,
                        sliceID: parseInt(params.sid, 10),
                        width: parseInt(params.w, 10),
                        height: parseInt(params.h, 10)
                    };

                // For mobile devices using the binary format, we submit a task request to get the graph image.
                // The native application (Android) will intercept this request and return us JSON representing the graph.
                // This JSON contains instructions on how to draw the graph using HTML5 canvas element.
                if (app.onMobileDevice() && app.useBinaryFormat) {
                    // TQMS #511440: Request graph JSON in timeout to prevent errant toucheEnd event that cancels scrolling.
                    window.setTimeout(function () {
                        submitRequest.call(mstrmojo.all[id], p, callback);
                    }, 0);

                } else {
                    if (params.encodeImage) {
                        // Add encoding type.
                        p.taskContentEncoding = 'base64';

                        // Remove task envelope.
                        delete p.taskEnv;

                        // Submit request.
                        submitRequest.call(this, p, {
                            success: function (res) {
                                callback.success('data:image/png;base64,' + res);
                            },
                            failure: function (err) {
                                (callback.failure || app.onerror)(err);
                            }
                        });

                    } else {
                        var cfg = app.getConfiguration(),
                            projectId = app.getCurrentProjectId(),
                            values = new mstrmojo.StringBuffer();

                        // Add time stamp and session state to parameters.
                        p.__ts__ = new Date().getTime();
                        p.sessionState = app.getSessionState(projectId);

                        // Convert parameters hash to URL string.
                        $H.forEach(p, function (v, n) {
                            // Use name value pairs with value encoded.
                            values.append(n + '=' + encodeURIComponent(v));
                        });

                        // Pass src url back to success handler.
                        callback.success(cfg.getTaskUrlByProject(projectId) + '?' + values.toString('&'));
                    }
                }
            },

            getImage: function getImage(url) {
                var app = mstrApp,
                    config = app.getConfiguration();

                if (config && url && url.indexOf('://') === -1) {
                    // Add the hostUrl value.
                    url = config.getHostUrlByProject(app.getCurrentProjectId()) + url;
                }

                return (mstrApp.useBinaryFormat) ? String(mstrMobileApp.getImage(url)) : url;
            },

            getDocImage: function getDocImage(url) {
                return this.getImage(url);
            },

            setQuickSwitchViewMode: function setQuickSwitchViewMode(gridKeyContext, displayMode) {
                submitRequest.call(this, {
                    taskId: 'setDisplayMode',
                    gridKeyContext: gridKeyContext,
                    messageID: this.msgId,
                    displayMode: displayMode
                }, null, {
                    silent: true
                });
            },

            setRWUnitProperties: function setRWUnitProperties(key, props, formatType, returnData, callback) {
                submitRequest.call(this, {
                    taskId: 'setRWUnitProperties',
                    rwb: this.rwb,
                    nodeKey: key,
                    props: props,
                    formatType: formatType,
                    returnData: returnData
                }, callback, {
                    silent: true
                });
            },

            setDocZoom: function setDocZoom(params, callback) {
                submitRequest.call(this, {
                    taskId: 'setDocZoom',
                    rwb: this.rwb,
                    zoomType: params.zoomType,
                    zoomFactor: params.zoomFactor
                }, callback);
            },

            sort: function sort(params, callback) {
                submitRequest.call(this, $H.copy(params, {
                    taskId: 'DocSort',
                    rwb: this.rwb
                }), callback);
            },

            pivot: function pivot(params, callback) {
                var request = $H.copy(params, {
                    messageID: this.msgId,
                    rwb: this.rwb
                });

                request.key = params.nodeKey;
                delete request.nodeKey;
                request.taskId = params.formID ? 'docPivotForm' : 'docPivot';

                submitRequest.call(this, request, callback);
            },

            drillGrid: function drillGrid(params, callback) {
                submitRequest.call(this, {
                    taskId: 'DocDrill',
                    messageID: this.msgId,
                    nodeKey: params.nodeKey,
                    drillPathIndex: params.drillPathIndex, // used if is Binary Format
                    drillPathKey: params.drillPathKey,
                    elementList: params.drillElements
                }, callback, {
                    showProgress: true,
                    hideProgress: true,
                    progressStateText: $PST,
                    delay: true
                });
            },

            changeDocGroupBy: function changeDocGroupBy(params, callback, config) {
                var request = {
                    taskId: 'changeDocGroupBy',
                    rwb: this.rwb,
                    messageID: this.msgId,
                    treesToRender: 3
                };

                if ( params.flags) {
                	request.flags = params.flags;
                }
                if (params.groupbyKey) {
                    request.groupByKey = params.groupbyKey;
                    request.elementID = params.elementId;
                } else {
                    request.gbUnits = params.gbUnits;
                }

                // Add the content size parameters to the request.
                addContentSize.call(this, request);

                submitRequest.call(this, request, callback, config);
            },

            downloadGridData: function downloadGridData(params, callback) {
                submitRequest.call(this, {
                    taskId: 'DocXtabIncrementalFetch',
                    rwb: this.rwb,
                    nodeKey: params.nodeKey,
                    rowPosition: params.rowPosition,
                    maxRows: params.maxRows,
                    colPosition: params.colPosition,
                    sliceId: params.sliceId,
                    maxColumns: params.maxColumns
                }, callback);
            },

            txMarkRows: function txMarkRows(params, callback) {
                submitRequest.call(this, {
                    taskId: 'markRow',
                    rwb: this.rwb,
                    nodeKey: params.nodeKey,
                    sliceId: params.sliceId,
                    rowOrdinal: params.rowOrdinal,
                    actionType: params.actionType
                }, callback);
            },

            txChangeData: function txChangeData(params, callback) {
                submitRequest.call(this, {
                    taskId: 'changeData',
                    rwb: this.rwb,
                    nodeKey: params.nodeKey,
                    sliceId: params.sliceId,
                    cells: params.cells,
                    autoRefresh: params.autoRefresh
                }, callback);
            },

            sendTransactionActions: function sntTxActs(params, callback) {
                var request = {
                    taskId: 'DocTransaction',
                    rwb: this.rwb,
                    keyContext: params.keyContext,
                    actions: params.actions,
                    messageID: this.msgId
                    };

                //if we have offline transaction record
                if(params.txrcd) {
                    request.isPending = params.txrcd.pending;
                    request.timestamp = params.txrcd.timestamp;
                }

                submitRequest.call(this, request, callback, {silent: !!callback}); //if callback defined, it will handle error itself.
            },

            RWEventsTask: function RWEventsTask(params, callback){
                submitRequest.call(this, {
                    taskId: 'RWEventsTask',
                    rwb: this.rwb,
                    messageID: params.messageID,
                    styleName: params.styleName,
                    events: params.events
                }, callback);
            },

            getPageByTree: function getPageByTree(callback) {
                mstrApp.serverRequest({
                    taskId: 'getPageByTree',
                    msgID: this.msgId
                }, callback);
            },

            resetSelections: function resetSelections(unitKeyContext, disablePU, callback) {
            	submitRequest.call(this, {
            		taskId: 'resetSelections',
            		rwb: this.rwb,
            		unitKeyContext: unitKeyContext || '',
            		usePartDisplay: disablePU ? '0' : '1'
            	}, callback);
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.func");
    
    /**
     * <p>A ResSetLink to a report or document.</p>
     * 
     * @class
     * @extends mstrmojo.XtabModel
     */
    mstrmojo.ResSetLink = mstrmojo.declare(
        mstrmojo.Obj,
        
        null,
        
        /** 
         * @lends mstrmojo.ResSetLink.prototype
         */
        {            
            scriptClass: "mstrmojo.ResSetLink",
            // Hyperlink Drill Constants
            SAME_PROMPT: 1,
            DO_NOT_ANSWER: 2,
            CLOSE: 3,
            DYNAMIC: 4,
            STATIC: 5,
            CURRENT_UNIT: 6,
            ALL_VALID_UNITS: 7,
            USE_DEFAULT_ANSWER: 8,
            
            toXml: function toXml() {
                
                // Function for createing XML attributes.
                var me = this,
                    fnXMLAttribute = function(name, value) { 
                        return ' ' + name + '="' + value + '"';
                    },
                    fnXMLAttributeElement = function(name, value) {
                        return fnXMLAttribute(name, mstrmojo.string.encodeXMLAttribute(value));
                    },
                    xml = new mstrmojo.StringBuffer();

                                 
                // Get the answers info. 
                var prms = this.prms,
                    prmCnt = prms && prms.length;
                
                // TQMS 576150: if there are no prompts, And the default answer mode is "do not answer", 
                // we will not include the linkAnswers parameter
                if (prmCnt || me.aopam != me.DO_NOT_ANSWER) {
                    // Start the link XML.
                    xml.append('<hl' + fnXMLAttribute('mid', me.mid) + fnXMLAttribute('srct', me.srct) + fnXMLAttribute('aopam', me.aopam) + '>');
                    
                    if (prmCnt) {
                        // Add prompts node. 
                        xml.append('<prms>');
                        
                        for (var i = 0; i < prmCnt; i++) {
                            var prm = prms[i];
                              
                            // Prompt ID, answermode, prompt type.
                            // Add the prompt info node to the xml. 
                            //TQMS 625468 We need to pass target prompt type for Web Objects to parse the answer correctly 
                            xml.append('<prm' + fnXMLAttribute('id', prm.id) + fnXMLAttribute('am', prm.am) + fnXMLAttribute('pt', prm.pt));
                              
                            // Is the prompt origin passed. If yes, add that to the XML too. 
                            if (prm.orid) {
                                xml.append(fnXMLAttribute('orid', prm.orid) + fnXMLAttribute('ortp', prm.ortp));
                            }
                            xml.append('>');  
                  
                            // How should we answer the prompts?
                            switch (prm.am) {
                                case me.DO_NOT_ANSWER:
                                case me.CLOSE:
                                case me.USE_DEFAULT_ANSWER:
                                case me.SAME_PROMPT:
                                    break;
                                      
                                case me.STATIC:
                                    xml.append('<pa ia="1"><es>');
                                    var es = prm.pa.es,
                                        esLen = es && es.length || 0;
    
                                    for (var z = esLen - 1; z >= 0; --z) {
                                        var e = es[z];
                                        xml.append('<e' + fnXMLAttributeElement('ei', e.ei) + fnXMLAttribute('disp_n', e.disp_n) + fnXMLAttribute('emt', e.emt)  + '/>');
                                    }
                                      
                                    xml.append('</es></pa>');
                                    break;
                                      
                                case me.DYNAMIC:
                                case me.ALL_VALID_UNITS:
                                case me.CURRENT_UNIT:
                                    var pa = prm.pa;
                                    if (pa) {
                                        xml.append('<pa ia="1">');
                                        var a = pa.a;
                                        
                                        if (a) {
                                            xml.append('<a' + fnXMLAttribute('id', a.id) + fnXMLAttributeElement('n', a.n) + '>');
                                        }
                                        if ( prm.pt === 1) {
                                            //TQMS 625468 We need to pass a simple string answer for constant prompts 
                                        	xml.append(mstrmojo.string.encodeXMLAttribute(pa.v));
                                        } else {             
	                                        xml.append('<es' + fnXMLAttribute('dispForms', a && a.dispForms >=0 ? a.dispForms : '') + '>'); 
	                                        var es = pa.es
	                                            esLen = es && es.length || 0;
	                                        for (var z = esLen - 1; z >= 0; --z) {
	                                            var e = es[z];
	                                            xml.append('<e' + fnXMLAttributeElement('ei', e.ei) + fnXMLAttribute('disp_n', e.disp_n) + fnXMLAttribute('emt', e.emt)  + '/>');
	                                        }
	                                        xml.append('</es>');
                                          
                                        if (a) {
                                            xml.append('</a>');
                                        }
                                        }
                                        xml.append('</pa>');
                                    }
                                    break;
                                    
                            }
                            xml.append('</prm>');
                        }
                        xml.append('</prms>');
                    }
                    xml.append('</hl>');
                }
                  
                return xml.toString();
            }


        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.hash",
                         "mstrmojo.dom",
                         "mstrmojo.array");

    var $M = Math,
        $HS = mstrmojo.publisher.hasSubs,
        $HASH = mstrmojo.hash,
        $forEachHash = $HASH.forEach,
        $D = mstrmojo.dom;

    var VELOCITY_THRESHOLD = 0.15;      // Minimum velocity (pixels / ms) for deceleration.

    var INC_EDGE_START = 1,
        INC_EDGE_END = 2;

    /**
     * Controller for the scroll out indicators.
     *
     * @static
     * @private
     */
    var indicators = {
        y: {
            edge: [ 'top', 'bottom' ],   // Edge the gradient should begin at.
            size: 0                      // Cached current gradient size (better performance if we can avoid setting duplicate values).
        },

        x: {
            edge: [ 'left', 'right' ],   // Edge the gradient should begin at.
            size: 0                      // Cached current gradient size (better performance if we can avoid setting duplicate values).
        },

        /**
         * The base css class for the scroll indicators.
         */
        clsName: 'mstrmojo-touch-scroll-indicator',

        /**
         * Creates and append the indicator HTMLElements.
         *
         */
        init: function init() {
            // Get indicator info objects.
            var vertical = this.y,
                horizontal = this.x;

            // Have we NOT created the scroll indicators yet?
            if (!vertical.i) {
                // Create the horizontal indicator.
                var vIndicator = vertical.i = document.createElement('div');
                vIndicator.className = this.clsName;

                // Clone horizontal indicator to get vertical indicator.
                var hIndicator = horizontal.i = vIndicator.cloneNode();

                // Append static indicators to the body tag.
                document.body.appendChild(vIndicator);
                document.body.appendChild(hIndicator);
            }
        },

        /**
         * Calculates the background image gradient and sets onto indicator element.
         *
         * @param {Object} indicator The indicator object to manipulated (either the value of the "y" or the "x" property).
         * @param {Boolean} scrollerAtMax True if the scroller is at it's max (end) position.
         * @param {Integer} delta The amount of pixels the scroller is currently scrolled past it's boundary.
         * @param {Integer} containerMaxSize The size of the widget in this direction, which is used to calculate the max gradient size.
         *
         */
        setGradient: function setGradient(indicator, scrollerAtMax, delta, containerMaxSize) {
            // Get gradient edge.
            var indicatorEl = indicator.i,
                edge = indicator.edge[(scrollerAtMax) ? 1 : 0];

            // Calculate size to be a value between 0 and 100 limited by the containerMaxSize, and start and end edges (default to top).
            var gradientSize = $M.min($M.round($M.min($M.abs(delta) / 200, 1) * 100), containerMaxSize / 2),
                start = 'left top',
                end = 'left bottom';

            // Is the scroller at the end (right or bottom)?
            if (scrollerAtMax) {
                // End should be 'left top'.
                end = start;

                // Is the indicator at the bottom?
                if (edge === 'bottom') {
                    // Change start to 'left bottom'.
                    start = 'left bottom';

                } else {
                    // Indicator is 'right' so change start to 'right top'.
                    start = 'right top';

                }

            // Is the indicator at left edge?
            } else if (edge === 'left') {
                // Change end to 'right top';
                end = 'right top';
            }

            // Is the current gradient size different from the calculated?
            if (gradientSize !== indicator.size) {
                // Set background to gradient value.
                indicatorEl.style.background = '-webkit-gradient(linear, ' + start + ', ' + end + ', from(rgba(39, 104, 162, .4)), to(rgba(39, 104, 162, 0)), color-stop(' + (gradientSize / 100) + ', rgba(39, 104, 162, 0)))';

                // Cache gradient size for better performance.
                indicator.size = gradientSize;
            }
        },

        /**
         * Shows, positions and configures a scroll indicator (or hides) for the specified axis.
         *
         * @param {String} axis Either 'y' or 'x' to indicate whether we should position the vertical or the horizontal scroll indicator.
         * @param {Integer} touchPosition The position of the scroll element according to the touch position.
         * @param {Integer} constrainedPosition The constrained position within the scroll offsets.
         * @param {Object} widgetPosition The position of the widget that is being scrolled (@see mstrmojo.dom.position}.
         *
         */
        scrollAxis: function scroll(axis, touchPosition, constrainedPosition, widgetPosition, outOfBounds) {
            // Calculate the difference between the touchPosition and the constrainedPosition.
            var delta = touchPosition - constrainedPosition,            // The difference between the touchPosition and the constrainedPosition.
                isOutOfBounds = outOfBounds[axis] = (delta !== 0);      // True if the scroller is out of bounds for this axis.

            // Is the scroll NOT out of bounds?
            if (!isOutOfBounds) {
                // Make sure the indicator is hidden and exit.
                this.hide(axis);
                return;
            }

            var indicator = this[axis],
                indicatorEl = indicator.i,
                indicatorStyle = indicatorEl.style,
                isVertical = (axis === 'y'),
                scrollerAtMax = (delta > 0),
                clsName = this.clsName + ' ' + indicator.edge[(scrollerAtMax) ? 1 : 0];

            // Is this the first scroll out for this axis OR is the class name of the indicator NOT correct for the current position?
            if (!indicator.size || indicatorEl.className !== clsName) {

                // Set the class name with appropriate edge class from indicator.
                indicatorEl.className = clsName;

                // Create position and size fields, defaulting to the 'top' edge position.
                var px = 'px',
                    borderWidth = 3,
                    top = widgetPosition.y,
                    left = widgetPosition.x,
                    height = 100,
                    width = widgetPosition.w;

                // Is this a vertical indicator?
                if (isVertical) {
                    // Are we at the bottom edge?
                    if (scrollerAtMax) {
                        // Change top position so the indicator will appear at bottom edge (widget height minus element height minus border width).
                        top += widgetPosition.h - height - borderWidth;
                    }

                } else {
                    // Reset width and height for horizontal orientation.
                    width = height;
                    height = widgetPosition.h;

                    // Are we at the right edge?
                    if (scrollerAtMax) {
                        // Change top position so the indicator will appear at right edge (widget width minus element width minus border width).
                        left += widgetPosition.w - width - borderWidth;
                    }
                }

                // Position and size the indicator element.
                indicatorStyle.top = top + px;
                indicatorStyle.left = left + px;
                indicatorStyle.width = width + px;
                indicatorStyle.height = height + px;

                // Show the indicator element.
                indicatorStyle.display = 'block';
            }

            // Add gradient background from indicator.
            this.setGradient(indicator, scrollerAtMax, delta, (isVertical) ? widgetPosition.h : widgetPosition.w);
        },

        scroll: function scroll(scroller, position, constrainedX, constrainedY, scrollEl) {
            // Get x and y positions.
            var x = position.x,
                y = position.y;

            // Is either the x or the y beyond the scroll limits?
            if (x !== constrainedX || y !== constrainedY) {
                // Make sure the indicators have been initialized.
                this.init();

                // Do we NOT have a cached widget position?
                var widgetPosition = this._widgetPosition;
                if (!widgetPosition) {
                    var el = scroller.indicatorEl || scrollEl;
                    // Calculate widget position only once for better performance.
                    widgetPosition = mstrmojo.dom.position(el.parentNode);
                }

                // Get the out of bounds collection from scroller instance.
                var outOfBounds = scroller._outOfBounds || {};

                // Scroll both axes.
                this.scrollAxis('y', y, constrainedY, widgetPosition, outOfBounds);
                this.scrollAxis('x', x, constrainedX, widgetPosition, outOfBounds);

                // Cache the widget position for better performance.
                this._widgetPosition = widgetPosition;

                // Store out of bounds collection back on scroller instance.
                scroller._outOfBounds = outOfBounds;

            } else {
                // Hide both indicators.
                this.hideAll();

                // Mark scroller as NOT out of bounds.
                delete scroller._outOfBounds;

            }
        },


        /**
         * Hides an single scroll indicator.
         *
         * @param {String} axis Either 'y' or 'x' to indicate whether we should hide the vertical or the horizontal scroll indicator.
         */
        hide: function hide(axis) {
            // Have we previously calculated a gradient size for this indicator?
            var a = this[axis];
            if (a.size !== undefined) {
                // Hide and reset class name of indicator element.
                a.i.style.display = 'none';
                a.i.className = this.clsName;

                // Reset calculated gradient size.
                a.size = 0;
            }
        },

        /**
         * Hides both the horizontal and vertical scroll indicator.
         *
         */
        hideAll: function hideAll() {
            // Hide both indicators.
            this.hide('y');
            this.hide('x');

            // Clear the cached widget position.
            delete this._widgetPosition;
        }
    };

    /**
     * Restricts a given point value to be within the supplied offsets.
     *
     * @param {Number} value The position to constrain.
     * @param {Object} offset An object with 'start' and 'end' properties that define the limits of scrolling in a given direction.
     *
     * @private
     */
    function constrainPoint(value, offset) {
        return (offset) ? $M.max($M.min($M.round(value), offset.end), offset.start) : value;
    }

    function raiseScrollerEvent(scroller, evtName, evtObj) {
        // Add name and identifier.
        evtObj.name = evtName;
        evtObj.id = scroller.identifier;

        // Raise event.
        scroller.raiseEvent(evtObj);
    }


    /**
     * Raises the scroll done event and then calls stop deceleration.
     */
    function stopDecelOnScrollDone() {
        // 631249 even if not decelerating raise the scrollDone event
        // Tell the consumer that we have scrolled.
        // Cache the direction for scroll done.
        var evtName = 'scrollDone',
            origin = this.origin;
        if ($HS(this.id, evtName) && origin) {
            raiseScrollerEvent(this, evtName, {
                x: origin.x,
                y: origin.y
            });
        }

        this.stopDeceleration();
    }

    /**
     * Positions the scroller.scrollEl at the new position.
     *
     * @param {mstrmojo.TouchScroller} The scroller.
     * @param {Object} position An object with 'x' and 'y' properties that indicate the current position of the scroll element.
     * @param {Integer} [duration=0] Number of milliseconds the position change should take.
     * @private
     */
    function applyPosition(scroller, position, duration) {
        var scrollEl = scroller.scrollEl;
        // TQMS 689114: 'scrollEl' property of the scroller may be deleted while it is decelerating,
        // so stop the deceleration if it is deleted.  
        if (!scrollEl) {
        	stopDecelOnScrollDone.call(scroller);
            return;
        }
        
        var positions = {
                x: position.x || 0,
                y: position.y || 0
            };

        // Iterate the scrollbars.
        $forEachHash(scroller._scrollBarEls, function (bar, axis) {
            var isX = (axis === 'x'),
                position = positions[axis],
                length = bar.length,
                ratio = bar.ratio,
                viewportSize = bar.viewportSize,
                minScale = 6 / length,
                minPosition = bar['base' + ((isX) ? 'Left' : 'Top')],
                maxPosition = minPosition + viewportSize - length,
                newPosition = $M.round(minPosition + (ratio * position));

            // Adjust position and bar length for scroll out cases.
            if (newPosition < minPosition) {
                newPosition = minPosition - position;
                length += position;
            } else if (newPosition > maxPosition) {
                var delta = (position - scroller.offset[axis].end) * ratio;
                newPosition = $M.min(maxPosition + delta, viewportSize + minPosition - 6) - 1;
                length -= delta;
            }

            // Move and size the bar.  Use webkitTransform for better performance.
            var v = 0,
                translate = [v, v, v],
                scale = [1, 1, 1],
                idx = (isX) ? 0 : 1;

            translate[idx] = (newPosition - minPosition);
            scale[idx] = $M.min($M.max(length / bar.length, minScale), 1);

            $D.translate(bar, translate[0], translate[1], translate[2], ' scale3d(' + scale.join(',') + ')');
        });

        if (duration) {
            duration += 'ms';
        }

        // Is the scroller hosted in a non-touch environment?
        if (scroller._isHosted) {
            // Change scrollTop and scrollLeft to scroll.
            var parentNode = scrollEl.parentNode;
            parentNode.scrollTop = positions.y;
            parentNode.scrollLeft = positions.x;
        } else {
            // Use transition to scroll.
            scrollEl.style[$D.CSS3_TRANSITION_DURATION] = duration || '0';    // Scroll is always instantaneous.
            $D.translate(scrollEl, -positions.x, -positions.y, 0, scroller.transform, scroller.useTranslate3d);
        }

        // Is anybody listening for the "scrollMoved" event?
        if ($HS(scroller.id, 'scrollMoved')) {
            // Raise.
            raiseScrollerEvent(scroller, 'scrollMoved', {
                x: position.x,
                y: position.y
            });
        }
    }

    /**
     * Calculates the anticipated total time of deceleration required for the scroller's initial velocity to reduce to the final velocity
     * given the constant friction parameter.
     *
     * @param {Number} initialVelocity The velocity of the scroller at the start of the deceleration.
     * @param {Number} finalVelocity The velocity of the scroller at the end of the deceleration.
     * @param {Number} friction The friction that will constantly reduce the initial velocity till it reaches the final velocity
     *
     * @return {Number}
     *
     * @private
     */
    function fnGetTime(finalVelocity, initialVelocity, friction) {
        return $M.ceil(1 + $M.log(finalVelocity / $M.abs(initialVelocity)) / $M.log(1 - friction));
    }

    /**
     * Calculates the anticipated total distance the scroller would move (based on it's velocity) from it's current position
     * for the given time interval.
     * given the constant friction parameter.
     *
     * @param {Number} position The initial position of the scroller.
     * @param {Number} directionMultipler +/-1 based on which direction the scroller is moving
     * @param {Number} initialVelocity The velocity of the scroller at the time when the distance moved needs to be calculated
     * @param {Number} timeInterval The time interval for which the scroller would move
     * @param {Number} friction The friction that will constantly reduce the initial velocity.
     *
     * @return {Number}
     *
     * @private
     */
    function fnGetPosition(position, directionMultiplier, initialVelocity, timeInterval, friction) {
        return position + (directionMultiplier * (initialVelocity * (1 - $M.pow(1 - friction, timeInterval)) / friction));
    }

    /**
     * <p>Calculates and returns the position of the given scroller on the given axis at a particular interval in time.</p>
     *
     * <p>This method will calculate position and bounce state for each interval, as well as any events that
     *    need to be raised during that iteration. </p>
     *
     * @param {mstrmojo.TouchScroller} The instance of {@link mstrmojo.TouchScroller} that has finished scrolling.
     * @param (Number) The position of the scroller at the moment the user ends the swipe for the particular axis
     * @param {String} axis The axis that is decelerating ('x' or 'y').
     * @param {Boolean} direction The direction the user swiped in this axis (True for up or left, False for down or right).
     * @param {Number} velocity The starting velocity for this axis.
     * @param (Number) delta The time elapsed since the user ends the swipe
     * @param (Number) totalTime The total anticipated time to complete the deceleration
     *
     * @returns Number
     *
     * @private
     */
    function calculateAxisPosition(scroller, position, axis, direction, velocity, delta, totalTime) {
        var offset = scroller.offset[axis];     // Offsets object (for limits and options).

        // Is there no offset for this direction?
        if (!offset) {
            // Can't scroll in this direction so return a single frame with the current origin value.
            return position;
        }

        var outOfBounds = scroller._outOfBounds,
            isAxisOutOfBounds = outOfBounds && outOfBounds[axis],   // TRUE if the user purposely scrolled outside the offsets.
            incFetch = offset.incFetch,                             // Whether we support incremental fetch.
            friction = scroller.friction,
            start = offset.start,
            end = offset.end,
            limit = (direction) ? end : start;                      // The direction is true if the swipe was up or left, false if down or right.

        // Only work with positive values.
        velocity = $M.abs(velocity);

        // Is the start position out of bounds?
        if (isAxisOutOfBounds) {
            // Make sure the direction and limit are correct.
            direction = (position < start);
            limit = (direction) ? start : end;
        }

        var directionMultiplier = (direction) ? 1 : -1;

        // Is the current position outside the start or is it outside the end AND incremental fetch is not supported?
        if (isAxisOutOfBounds && (direction || !incFetch)) {
            // The user has scrolled outside the boundaries and needs to bounce back.
            // Calculate the initial velocity so that when we scroll back, we will end up with a final velocity of
            // three times the velocity threshold.
            var finalVelocity = VELOCITY_THRESHOLD * 3,
                a = 1 / (1 - friction),
                initialVelocity = finalVelocity / $M.pow((1 - friction), ($M.log(1 - $M.abs(position - limit) * (1 - a) / finalVelocity) / $M.log(a)) - 1);

            // Calculate the current position of the scroller
            var calculatedPosition = $M.round(fnGetPosition(position, directionMultiplier, initialVelocity, delta, friction));

            //Have we reached our destination?
            if (direction ? (calculatedPosition >= limit) : (calculatedPosition <= limit)) {
                //We're done scrolling out and have reached the limit, so stop deceleration
                stopDecelOnScrollDone.call(scroller);

                //Return the limit.
                return limit;
            }

            //We're still scrolling back from the scrolled out location.
            return calculatedPosition;

        }

        // The size of an incremental fetch page.
        var pageSize = offset.pageSize,
            supportedEdges = offset.supportedEdges;


        // Get the new position.
        var newPosition = fnGetPosition(position, directionMultiplier, velocity, delta, friction),
            bStart = (newPosition <= start),
            bEnd = (newPosition >= end);

        // Is the new position outside the offset limits?
        if (bStart || bEnd) {

            // Is incremental fetch supported on the edge the user has scolled to?
            if (incFetch && ((bStart && ((supportedEdges & INC_EDGE_START) > 0)) ||
                    (bEnd && ((supportedEdges & INC_EDGE_END) > 0)))) {

                // Have we scrolled to the end of the page?
                if (newPosition - end >= pageSize) {
                    // Stop at the end of the new page.
                    newPosition = end + pageSize;

                    // Reset limit to newPosition so we'll finish the iteration.
                    limit = newPosition;
                }

                if (!scroller.STATUS_INC_FETCH) {
                    //Set the status
                    scroller.STATUS_INC_FETCH = true;

                    //We've moved past the end, fire off the incremental fetch event so the widget can handle it.
                    raiseScrollerEvent(scroller, 'incFetch', {
                        edge: bEnd ? INC_EDGE_END : INC_EDGE_START
                    });
                }

            } else {

                // Does the scroller bounce?
                if (scroller.bounces) {

                    //adjust the bounce friction
                    var bounceFriction = friction * 2,
                        bVelocity = scroller.bounceVelocity,
                        bTime = scroller.bounceTime,
                        bDistance = scroller.bounceDistance;

                    //Has the scroller entered the bouncing state for the first time? Then cache the following properties
                    if (!scroller.hasBounced) {
                        //The speed when the bounce occured.
                        bVelocity[axis] = $M.abs(VELOCITY_THRESHOLD / $M.pow(1 - friction, totalTime - delta - 1));

                        //The total time to bounce...
                        bTime[axis] = fnGetTime(VELOCITY_THRESHOLD, bVelocity[axis], bounceFriction);

                        //The total distance to bounce...
                        bDistance[axis] = $M.abs(fnGetPosition(newPosition, directionMultiplier, bVelocity[axis], bTime[axis], bounceFriction) - newPosition);

                        // Raise the 'bounceOut' event so it will notify the listener that the scroller has entered it's bounced state.
                        scroller.raiseEvent({
                            name: 'bounceOut',
                            id: scroller.identifier,
                            axis: axis,
                            direction: direction,
                            value: $M.round(newPosition)
                        });

                        //The scroller is now in the bounced state.
                        scroller.hasBounced = true;
                    }

                    var bounceLimit = Math.floor(bDistance[axis] / 2);

                    // At what position are we and how far have we traveled into the bounce?
                    var bouncePosition = fnGetPosition(limit, directionMultiplier, bVelocity[axis], delta, bounceFriction),
                        travelDistance = $M.abs(bouncePosition - limit);

                    // Have we reached the bounceLimit?
                    if ($M.abs(travelDistance) < bounceLimit) {
                        //If not, keep going.
                        return bouncePosition;
                    }

                    // Have we completed the entire bounce and are moving past the destination?
                    if ($M.abs(travelDistance) >= bDistance[axis]) {
                        // We're done! Stop deceleration and return to the limit.
                        stopDecelOnScrollDone.call(scroller);
                        return limit;
                    }

                    // We've reached the bounce limit and are going back to the edge.
                    var limitDistance = bounceLimit - (travelDistance - bounceLimit);
                    return $M.round(limit - ((direction) ? -limitDistance : limitDistance));  // Negative for swipes up and left.
                }

                // Set newPosition to limit to make sure we end up at the limit, and to exit the iteration.
                newPosition = limit;
            }
        }

        //Return the updated position..
        return $M.round(newPosition);
    }

    /**
     * Detaches the scroll listener (if present) that was created for the hosted environment.
     *
     * @param HTMLElement [el=undefined] Optional HTML Element corresponding to the parent node of the scroller scrollEl property.  If this parameter is passed
     *                                   the scrollListener element will be compared with the parameter value and if found to be the same, the scrollListener will
     *                                   not be detached.
     *
     * @type Boolean
     * @returns True if the scroll listener was found and detached, false if the scroll listener was not already attached or the scroll listener was already attached to the el parameter.
     * @private
     */
    function detachHostedScrollListener(el) {
        var scrollListener = this._scrollListener;
        if (scrollListener) {
            if (!el || el !== scrollListener.el) {
                $D.detachEvent(scrollListener.el, 'scroll', scrollListener.fn);
                delete this._scrollListener;

                return true;
            }

            return false;
        }

        return true;
    }

    /**
     * <p>This component is used to scroll an element via touch events.</p>
     *
     * @class
     * @extends mstrmojo.Obj
     */
    var $TOUCHSCROLLER = mstrmojo.TouchScroller = mstrmojo.declare(
        mstrmojo.Obj,

        null,

        /**
         * @lends mstrmojo.TouchScroller.prototype
         */
        {
            scriptClass: "mstrmojo.TouchScroller",

            /**
             * The element to scroll.
             *
             * @type HTMLElement
             */
            scrollEl: null,

            /**
             * Can be set by consumers to uniquely identify this mstrmojo.TouchScroller instance and will be passed out in the 'scrollDone' event.
             */
            identifier: '',

            /**
             * Whether the element scrolls horizontally.
             *
             * @type Boolean
             * @default false
             */
            hScroll: false,

            /**
             * Whether the element scrolls vertically.
             *
             * @type Boolean
             * @default false
             */
            vScroll: false,

            /**
             * An object with 'x' and 'y' properties that have 'start' and 'end' properties to indicate the scroll boundaries.  This object can optionally contain
             * a 'scrollPast' property that will be true if the user is allowed to scroll past the offset limits, but the element will bounce back to the limit when
             * the scroll is completed.
             *
             * @type Object
             */
            offset: null,

            /**
             * An object with 'x' and 'y' properties that contain the current 'x' and 'y' positions of the scroll element.
             *
             * @type Object
             */
            origin: null,

            /**
             * An optional String containing extra properties to be set with each transformation (such a scale).
             *
             * @type String
             */
            transform: '',

            /**
             * The friction that should be applied during deceleration.
             *
             * @type Number
             * @default 0.0015
             */
            friction: 0.0015,

            /**
             * The number of animation frames per second.
             *
             * @type Number
             * @default 60
             */
            frameRate: 60,

            /**
             * Indicates whether the scroll element should bounce when it reaches it's offset limits.
             *
             * @type Boolean
             * @default true
             */
            bounces: true,

            /**
             * Indicates whether the scroller is currently in the bounced state.
             *
             * @type Boolean
             * @default false
             */
            hasBounced: false,

            /**
             * Indicates the distance the scroller has to travel upon bouncing. It includes to properties,
             * x and y indicating the values for each axes.
             *
             * @type Object
             */
            bounceDistance: {},

            /**
             * Indicates the time needed for the scroller to complete the bounce. It includes two properties,
             * x and y indicating the values for each axes.
             *
             *  @type Object
             */
            bounceTime: {},

            /**
             * Indicates the velocity of the scroller the the moment the scroller enters the bounced state. It
             * includes two properties, x and y indicating the values for each axes.
             *
             * @type Object
             */
            bounceVelocity: {},

            /**
             * Indicates whether scroll bars should appear as the scrollEl is scrolled.
             *
             * @type Boolean
             * @default false
             */
            showScrollbars: false,

            /**
             * Indicates whether scroll past indicators should appear as the scrollEl is scrolled beyond it's offset limits.
             *
             * @type Boolean
             * @default true
             */
            showIndicators: true,

            /**
             * Do we want to update the default device behavior into using translate3d
             *
             * @type Boolean
             * @default true
             */
            useTranslate3d: true,

            /**
             * This property stores whether the scroller has triggered an incremental fetch call on the widget
             * and is waiting for data. It is turned back to false once the widget retrieves it's data.
             *
             * @type Boolean
             * @default false
             */
            STATUS_INC_FETCH: false,

            /**
             * Overridden to initialize the static scroll indicators.
             *
             * @ignore
             */
            init: function init(props) {
                this._super(props);

                // Initialize indicators.
                indicators.init();
            },

            /**
             * Used to initialize the scroller.
             *
             * @param {Object} props The properties to be copied onto the scroller.
             *
             */
            initScroller: function initScroller(props) {
                // Copy props onto scroller instance.
                $HASH.copy(props, this);

                // Do we have a scroll element?
                var scrollEl = this.scrollEl;
                if (scrollEl) {
                    // Are we currently hosted in a non-touch environment?
                    var isHosted = this._isHosted = false; //!mstrApp.isTouchApp();
                    if (isHosted) {
                        var parentNode = scrollEl.parentNode;

                        // Make sure there is no lingering scroll listener.
                        if (detachHostedScrollListener.call(this, parentNode)) {
                            // Set scroll element parent node overflow to auto so scroll bars will appear.
                            parentNode.style.overflow = 'auto';

                            // Attach listener to hear when parent node is scrolled.
                            var id = this.id,
                                listener = this._scrollListener = {
                                    el: parentNode,
                                    fn: function (evt) {
                                        var origin = mstrmojo.all[id].origin,
                                            target = evt.target;

                                        origin.x = target.scrollLeft;
                                        origin.y = target.scrollTop;
                                    }
                                };

                            // Attache scroll listener.
                            $D.attachEvent(parentNode, 'scroll', listener.fn);
                        }

                        // Make sure touch scroll bars are not visible since we will be using native hosted scroll bars.
                        this.showScrollbars = false;
                    }
                }
            },

            /**
             * <p>Return true if this scroller is configured to scroll (based on vScroll and hScroll).</p>
             *
             * @returns Boolean True if this scroller can scroll.
             */
            canScroll: function canScroll() {
                return this.vScroll || this.hScroll;
            },

            /**
             * <p>Updates scroll bar position and size.</p>
             *
             * <p>This method will also initialize the scrollbars if we haven't already and the showScrollbars property is true.</p>
             *
             * @param {Object} [viewportCoords] An optional object with top, right, bottom and left positions of the viewport relative to
             *                                  the scrollBarContainerElement.  If undefined the left and top will be assumed to be zero and
             *                                  the right and bottom will be the width and height of the scrollEl parentNode.
             * @param {HTMLElement} [scrollBarContainerElement] Optional container element for the scroll bars.  If omitted, the parentNode
             *                                  of the scrollEl property will be used.
             */
            updateScrollBars: function updateScrollBars(viewportCoords, scrollBarContainerElement) {
                var scrollEl = this.scrollEl;

                // Are we not showing scrollbars, or do we not have a scroll element yet?
                if (!this.showScrollbars || !scrollEl) {
                    // Nothing to do here.
                    return;
                }

                var bars = this._scrollBarEls;

                // Have we NOT created the scroll bar DOM elements yet?
                if (!bars) {
                    var me = this;
                    bars = this._scrollBarEls = {
                        x: 'hScroll',
                        y: 'vScroll'
                    };

                    // Iterate the axes...
                    $forEachHash(bars, function (scroll, axis) {
                        // Do we support scrolling for this axis?
                        if (me[scroll]) {
                            // YES, then create the scroll bar element...
                            var bar = document.createElement('div');
                            bar.className = 'mstrmojo-touch-scrollBar ' + axis + 'Axis';

                            // and insert into DOM and scrollBars collection.
                            (scrollBarContainerElement || scrollEl.parentNode).appendChild(bar);
                            bars[axis] = bar;
                        } else {
                            // NO, so remove this axis from the collection of bars.
                            delete bars[axis];
                        }
                    });
                }

                // Did the consumer not supply viewportCoords?
                if (!viewportCoords) {
                    // Create viewportCoords based on the scoll elements parent node.
                    var parentNode = this.scrollEl.parentNode;
                    viewportCoords = {
                        top: 0,
                        right: parentNode.clientWidth,
                        bottom: parentNode.clientHeight,
                        left: 0
                    };
                }

                // Convert the viewportCoords into position (and length) coordinates for the scrollbars.
                var offset = 9,
                    scrollBarCoords = {
                        x: {
                            left: viewportCoords.left,
                            top: viewportCoords.bottom - offset,
                            x: viewportCoords.right - viewportCoords.left,
                            d: 'Width'
                        },
                        y: {
                            left: viewportCoords.right - offset,
                            top: viewportCoords.top,
                            x: viewportCoords.bottom - viewportCoords.top,
                            d: 'Height'
                        }
                    };

                // Size the scrollbars.
                $forEachHash(bars, function (bar, axis) {
                    var barStyle = bar.style,
                        coords = scrollBarCoords[axis],
                        dimension = coords.d,
                        parentNode = bar.parentNode,
                        x = coords.x;

                    // Calculate position...
                    var left = coords.left,
                        top = coords.top,
                        ratio = x / scrollEl['offset' + dimension],
                        length = Math.min(Math.round(x * ratio), x);

                    // cache on bar for scrolling...
                    bar.baseLeft = left;
                    bar.baseTop = top;
                    bar.ratio = ratio;
                    bar.viewportSize = x;
                    bar.length = length;

                    // position and size bar.
                    barStyle.left = left + 'px';
                    barStyle.top = top + 'px';
                    barStyle[dimension.toLowerCase()] = length + 'px';
                });
            },

            /**
             * Displays (or hides) the scrollbars based on the visible parameter.
             *
             * @param {Boolean} visible Indicates whether the scrollbars should be visible or not.
             */
            toggleScrollBars: function toggleScrollBars(visible) {
                // Iterate scroll bar elements.
                $forEachHash(this._scrollBarEls, function (bar) {
                    // Set opacity to visible (or hidden).
                    bar.style.opacity = (visible) ? 1 : 0;
                });
            },

            /**
             * <p>Scrolls to the given position (without animation).</p>
             *
             * <p>The position will be constrained to the current offset values.</p>
             *
             * @param {Integer} x The coordinate along the x axis.
             * @param {Integer} y The coordinate along the y axis.
             * @param {Integer} [duration=0] Number of milliseconds scroll should take.
             */
            scrollTo: function (x, y, duration) {
                // Can we not scroll in any direction?
                if (!this.canScroll() && !(x === 0 && y === 0)) {
                    // TQMS #610472: If this is not scrollable position it to 0, 0 to avoid the case the scroller is changed in horizontal mode
                    // but not scrollable in portrait mode.
                    applyPosition(this, {
                        x: 0,
                        y: 0
                    });

                    // Do not scroll.
                    return;
                }

                // Calculate the scroll to position.
                var offset = this.offset,
                    origin = this.origin,
                    position = {
                        x: (this.hScroll) ? constrainPoint(x, offset.x) : 0,
                        y: (this.vScroll) ? constrainPoint(y, offset.y) : 0
                    };

                // Apply the new scroll position.
                applyPosition(this, position, duration);

                // Update the origin.
                origin.x = position.x;
                origin.y = position.y;
            },

            /**
             * Scrolls the scroller to the end of the indicated axes.
             *
             * @param {Boolean} x True to scroll the X axis to it's end.
             * @param {Boolean} y True to scroll the Y axis to it's end.
             * @param {Integer} [duration=0] Number of milliseconds scroll should take.
             */
            scrollToEnd: function (x, y, duration) {
                var origin = this.origin,
                    offset = this.offset,
                    result = {
                        x: 0,
                        y: 0
                    };

                // Do we have both an origin and offsets?
                if (origin && offset) {
                    // Iterate axis.
                    mstrmojo.array.forEach([ x, y ], function (scroll, idx) {
                        // Get offset.
                        var axis = (idx) ? 'y' : 'x',
                            axisOffset = offset[axis];

                        // Result will be either the end of the axis offset (if present) or the axis origin.
                        result[axis] = (scroll) ? (axisOffset && axisOffset.end) || 0 : origin[axis];
                    });
                }

                // Perform scroll to.
                this.scrollTo(result.x, result.y, duration);
            },

            /**
             * Scrolls the element based on the touch event parameter.
             *
             * @param {Object} touch The touch event associated with this scroll operation.
             */
            scroll: function scroll(touch) {
                // Are we hosted in a non-touch environment?
                if (this._isHosted) {
                    // Nothing to do.
                    return;
                }

                var offset = this.offset,
                    scrollEl = this.scrollEl,
                    touchDelta = touch.delta,
                    touchDeltaX = touchDelta.x,
                    touchDeltaY = touchDelta.y;

                // Do we NOT have a scroll element?
                if (!scrollEl) {
                    // Nothing to do.
                    return;
                }

                // Do we NOT have an offset and should we show indicators?
                if (!offset && this.showIndicators) {
                    // Only thing we can do is display indicators.
                    indicators.scroll(this, {
                        x: (this.noHScroll) ? 0 : -touchDeltaX,
                        y: (this.noVScroll) ? 0 : -touchDeltaY
                    }, 0, 0, scrollEl);

                    return;
                }

                // Calculate actual touch position and contrained by offset position.
                var origin = this.origin,
                    position = {
                        x: (this.hScroll) ? $M.round(origin.x - touchDeltaX) : 0,
                        y: (this.vScroll) ? $M.round(origin.y - touchDeltaY) : 0
                    },
                    constrainedX = constrainPoint(position.x, offset.x),
                    constrainedY = constrainPoint(position.y, offset.y);

                // Is the user not allowed to scroll past the offsets?
                if (!offset.scrollPast) {
                    // Should we show indicators?
                    if (this.showIndicators) {
                        // Scroll indicators.
                        indicators.scroll(this, position, constrainedX, constrainedY, scrollEl);
                    }

                    // Constrain the position.
                    position.x = constrainedX;
                    position.y = constrainedY;

                } else {
                    // The user is allowed to scroll past the offsets so have they?
                    var isXAxisOutOfBounds = (constrainedX !== position.x),
                        isYAxisOutOfBounds = (constrainedY !== position.y),
                        isOutOfBounds = (isXAxisOutOfBounds || isYAxisOutOfBounds),
                        outOfBounds = this._outOfBounds,
                        evtName = '';

                    // Did the user previously scroll past the offsets?
                    if (outOfBounds) {
                        // Has the current scroll moved them back within the offsets?
                        if (isXAxisOutOfBounds !== (outOfBounds.x === true) || isYAxisOutOfBounds !== (outOfBounds.y === true)) {
                            // May need to raise the "scrollIn" event.
                            evtName = 'scrollIn';
                        }

                    // Has the current scroll moved past the boundaries?
                    } else if (isOutOfBounds) {
                        // May need to raise the "scrollOut" event.
                        evtName = 'scrollOut';
                    }

                    // Has the scrollOut status changed?
                    if (evtName) {
                        // Is anybody listening for this event?
                        if ($HS(this.id, evtName)) {
                            // Raise the event with the new current position and direction.
                            var direction = touch.direction;
                            raiseScrollerEvent(this, evtName, {
                                x: {
                                    position: position.x,
                                    direction: direction.x
                                },
                                y: {
                                    position: position.y,
                                    direction: direction.y
                                }
                            });
                        }

                        // Is the scroller currently out of bounds?
                        if (isOutOfBounds) {
                            // YES, store out of bounds collection.
                            this._outOfBounds = {
                                x: isXAxisOutOfBounds,
                                y: isYAxisOutOfBounds
                            };
                        } else {
                            // NO, delete out of bounds collection.
                            delete this._outOfBounds;
                        }
                    }
                }

                // Apply the new position.
                applyPosition(this, position);
            },

            /**
             * Ends a scroll operation.
             *
             * @param {Object} touch The touch event associated with this scroll end operation.
             */
            scrollEnd: function scrollEnd(touch) {
                // Make sure both indicators are hidden.
                indicators.hideAll();

                // Can we NOT scroll OR are we hosted in a non-touch environment?
                if (!this.canScroll() || this._isHosted) {
                    // Nothing to do.
                    return;
                }

                var id = this.id,
                    friction = this.friction,
                    a = 1 / (1 - friction),
                    initialPosition = this.origin,
                    initialVelocity = touch.velocity,
                    direction = touch.direction,
                    startTime = new Date(),
                    outOfBounds = this._outOfBounds,
                    offset = this.offset,
                    canScrollAxis = {
                        x: this.hScroll,
                        y: this.vScroll
                    },
                    velocity = {},
                    position = {},
                    directionMultiplier = {},
                    totalTime = {},
                    totalDistance = {},
                    finalVelocity = {},
                    start = {},
                    end = {},
                    limit = {},
                    initializeVars = function (axis) {
                        // Set the expected velocity of the scroller as the threshold.
                        finalVelocity[axis] = VELOCITY_THRESHOLD;

                        // Has the offset been assigned along this axis?
                        var axisOffset = offset[axis],
                            axisIsOutOfBounds = (outOfBounds && outOfBounds[axis]),
                            indicatorVisible = (axisIsOutOfBounds && (!axisOffset || !offset.scrollPast));

                        // Calculate the initial position...
                        position[axis] = (canScrollAxis[axis] && !indicatorVisible) ? initialPosition[axis] - touch.delta[axis] : initialPosition[axis];

                        if (axisOffset) {
                            //Cache the start and end of the offsets.
                            start[axis] = axisOffset.start;
                            end[axis] = axisOffset.end;

                            // Is the scroller out of bounds AND are we NOT showing can the scroller scroll past the bounds for this axis?
                            if (axisIsOutOfBounds) {
                                if (!indicatorVisible) {
                                    // Make sure the direction and limit are correct.
                                    direction[axis] = (position[axis] < start[axis]);
                                    limit[axis] = (direction[axis]) ? start[axis] : end[axis];

                                    // Is the current position outside the start or is it outside the end AND incremental fetch is not supported?
                                    if (direction[axis] || !axisOffset.incFetch) {
                                        // The user has scrolled outside the boundaries and needs to bounce back.
                                        // Calculate the initial velocity so that when we scroll back, we will end up with a final velocity of
                                        // three times the velocity threshold.
                                        finalVelocity[axis] = VELOCITY_THRESHOLD * 3;
                                        initialVelocity[axis] = finalVelocity[axis] / $M.pow((1 - friction), ($M.log(1 - $M.abs(position[axis] - limit[axis]) * (1 - a) / finalVelocity[axis]) / $M.log(a)) - 1);
                                    }
                                } else {
                                    // If we've scrolled out of bounds but the indicator is visible, then we should constrain the origin.
                                    position[axis] = constrainPoint(initialPosition[axis] - touch.delta[axis], axisOffset);
                                }
                            }
                        }

                        // Calculate the initial velocity and position of the scroller
                        velocity[axis] = (canScrollAxis[axis] && !indicatorVisible) ? $M.abs(initialVelocity[axis]) : 0;

                        directionMultiplier[axis] = (direction[axis] || false) ? 1 : -1;

                        // Finally calculate the totalTime required to complete the deceleration and the total distance required for the DOM to move.
                        totalTime[axis] = fnGetTime(finalVelocity[axis], velocity[axis], friction);
                        totalDistance[axis] = fnGetPosition(position[axis], directionMultiplier[axis], velocity[axis], totalTime[axis], friction);
                    };

                //Initialize all the properties along both the axes.
                initializeVars('x');
                initializeVars('y');

                // Update the origin.
                initialPosition.x = position.x;
                initialPosition.y = position.y;

                // Calculate decelerate flags.
                var decelerateX = (velocity.x > 0),
                    decelerateY = (velocity.y > 0);

                // Is there no velocity?
                if (!offset.scrollPast && !decelerateX && !decelerateY) {
                    // Stop deceleration to clear any scroll variables.
                    stopDecelOnScrollDone.call(this);

                    // #631469
                    var axis,
                        offsetObj,
                        bStart,
                        bEnd,
                        supportedEdges;

                    for (axis in offset) {
                        offsetObj = offset[axis];

                        supportedEdges = offsetObj.supportedEdges;

                        bStart = ((offsetObj.start === position[axis]) && ((supportedEdges & INC_EDGE_START) > 0));
                        bEnd = ((offsetObj.end === position[axis]) && ((supportedEdges & INC_EDGE_END) > 0));

                        // Is incremental fetch supported on the edge the user is scrolling?
                        if (offsetObj.incFetch && (bStart || bEnd)) {
                            // Set the status.
                            this.STATUS_INC_FETCH = true;

                            // We've at the end, fire off the incremental fetch event so the widget can handle it.
                            raiseScrollerEvent(this, 'incFetch', {
                                edge: (bEnd) ? INC_EDGE_END : INC_EDGE_START
                            });
                        }
                    }


                    // Nothing else to do.
                    return;
                }

                // Initialize all the bounce properties of the scroller
                this.hasBounced = false;
                this.bounceDistance = {};
                this.bounceTime = {};
                this.bounceVelocity = {};

                // Flag that deceleration is taking place.
                this.decelerating = true;

                var expectedInterval = Math.round(1000 / this.frameRate),           // Calculate the best anticipated interval for our deceleration.
                    prevTime = startTime,                                           // Store the time at start of the deceleration.
                    actualInterval,                                                 // This variable will store the actual time it takes to perform the interval.
                    axisIterator = {
                        x: decelerateX,
                        y: decelerateY
                    };

                // Set up an interval loop to perform the animation.
                this.decelerationTimer = window.setTimeout(function () {
                    var scroller = mstrmojo.all[id],
                        origin = scroller.origin,
                        curTime = new Date(),
                        delta = (curTime - startTime),
                        axis;

                    // TQMS 497890
                    if (scroller._halt) {
                        stopDecelOnScrollDone.call(scroller);
                        return;
                    }

                    // Calculate actual time it took to fire this timeout since the next.
                    actualInterval = curTime - prevTime;
                    prevTime = curTime;

                    if (actualInterval > (expectedInterval + 5)) {
                        expectedInterval = expectedInterval + $M.round((actualInterval - expectedInterval) / 2);
                    }

                    // Iterate the axis.
                    for (axis in axisIterator) {
                        // Are we decelerating this axis?
                        if (axisIterator[axis]) {
                            // Calculate new position along this axis.
                            var newPosition = calculateAxisPosition(scroller, position[axis], axis, direction[axis], velocity[axis], delta, totalTime[axis]);

                            // #493132: Is the new position a valid number?
                            if (!isNaN(newPosition)) {
                                // Update origin with new position along this axis.
                                origin[axis] = newPosition;
                            }
                        }
                    }

                    // Position the scroll element at the new position.
                    applyPosition(scroller, origin);

                    // Have we not reached the total time expected for deceleration and does the scroller NOT bounce?
                    var stopDecel = (delta > totalTime.x && delta > totalTime.y);
                    if (!stopDecel && !scroller.bounces) {

                        // Assume we will stop.
                        stopDecel = true;

                        // Iterate offset axes.
                        mstrmojo.hash.forEach(offset, function (axis, key) {
                            // Get current origin for this axis.
                            var v = origin[key];

                            // Is the current origin for this axis NOT at the start or end position?
                            if (v !== axis.end && v !== axis.start) {
                                // No need to stop.
                                stopDecel = false;

                                // Return false to halt iteration.
                                return false;
                            }
                        });
                    }

                    // Should we stop deceleration?
                    if (stopDecel) {
                        stopDecelOnScrollDone.call(scroller);

                    } else if (scroller.decelerating) {
                        // Continue deceleration and cache the new timeout id.
                        scroller.decelerationTimer = window.setTimeout(arguments.callee, expectedInterval);
                    }

                }, expectedInterval);

            },

            /**
             * Stops active deceleration operation and will raise the 'scrollDone' event.
             *
             */
            stopDeceleration: function stopDeceleration() {
                // Are we decelerating?
                var isDecelerating = !!this.decelerating;
                if (isDecelerating) {
                    // Do we have a deceleration interval?
                    if (this.decelerationTimer) {
                        // Clear the interval.
                        window.clearTimeout(this.decelerationTimer);
                        delete this.decelerationTimer;
                    }

                    // Clear the flag...
                    delete this.decelerating;

                    // Hide the scrollbars.
                    this.toggleScrollBars(false);
                }

                // delete scroll instance properties.
                delete this._outOfBounds;
                delete this.hasBounced;
                delete this.bounceDistance;
                delete this.bounceTime;
                delete this.bounceVelocity;
                delete this._halt;

                return isDecelerating;
            },

            haltScroller: function haltScroller() {
                this._halt = !!this.decelerating;
            },

            unrender: function unrender() {
                // Clear the reference to the scroll element.
                delete this.scrollEl;
            },

            /**
             * cleans up the TouchScroller and all it's events
             */
            destroy: function destroy() {
                // We want to stop deceleration before destroying the scroller.
                this.stopDeceleration();

                detachHostedScrollListener.call(this);

                this._super();
            }


        }
    );

    /**
     * Calculates the total scroller offset values for a given widget, through all ancestors.
     *
     * @param {Widget} widget The widget whose offsets should be calculated.
     *
     * @returns {Object} An object with x and y values representing the total amount scrolled for the widget and all it's ancestors.
     *
     * @static
     */
    mstrmojo.TouchScroller.getScrollPositionTotals = function getScrollPositionTotals(widget) {
        var parent = widget.parent,
            scroller = widget._scroller,
            origin = mstrmojo.hash.copy((scroller && scroller.origin) || {      // Use scroller origin, or 0,0 if missing.
                x: 0,
                y: 0
            });

        // Do we have a parent?
        if (parent) {
            // Call recursively and add result.
            var parentOrigin = mstrmojo.TouchScroller.getScrollPositionTotals(parent);
            origin.x += parentOrigin.x;
            origin.y += parentOrigin.y;
        }

        return origin;
    };

    /**
     * Static object for controlling scroll indicators.
     */
    mstrmojo.TouchScroller.ScrollIndicators = indicators;

    /**
     * Set up a static enumation for incremental fetch edges.
     */
    $TOUCHSCROLLER.EnumIncFetchEdges = {
        start: INC_EDGE_START,
        end: INC_EDGE_END
    };
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.hash");

    mstrmojo.touchManager = new mstrmojo.Obj({
        notify: function (srcId, touch) {
            return this.raiseEvent({
                name: 'touchesBegin',
                srcId: srcId,
                touch: touch
            });
        }
    });

    var $D = mstrmojo.dom,
        $DAE = $D.attachEvent,
        $DDE = $D.detachEvent,
        $MATH = Math,
        $C = window.mstrConfig,
        debug = false,                                                  // Set to 'true' to display logging statements in the js console.
        activeWinListener = null,                                       // Holds a reference to the widget that is currently listening to window touch events.
        defaultTouchConfiguration = $C && $C.allowDefaultTouches;

    /**
     * Constants for gesture timing.
     *
     * @type Integer
     * @private
     */
    var SWIPE_THRESHOLD = 10,
        TAP_TIMEOUT = 250,
        SELECT_DURATION = 400,
        MIN_DELTA_BETWEEN_MOVE_EVENTS = 100;

    /**
     * Constants to describe gesture event names.
     *
     * @type Integer
     * @private
     */
    var EVT_BEGIN = 'Begin',
        EVT_END = 'End',
        EVT_MOVE = 'Move',
        EVT_CANCEL = 'Cancel';

    /**
     * Constants to describe gesture actions.
     *
     * @type Integer
     * @private
     */
    var ACTION_SELECT = 1,
        ACTION_SWIPE = 2,
        ACTION_MULTI = 3,
        ACTION_TAP = 4;

    var actionMethodMap = {};
    actionMethodMap[ACTION_SELECT] = 'Select';
    actionMethodMap[ACTION_SWIPE] = 'Swipe';
    actionMethodMap[ACTION_MULTI] = 'Multi';
    actionMethodMap[ACTION_TAP] = 'Tap';

    // We need to disable the default action from the document so that the browser doesn't do it's own scroll out.
    // Attach the touch start event.
    $DAE(document.body, $D.TOUCHMOVE, function (evt) {
        //Has the environment been configured to prevent default?
        if (!$C || !$C.allowDefaultTouches) {
            if (evt.preventDefault) {
                evt.preventDefault();
                return false;
            }
        }

        return true;
    });

    /**
     * Returns the event identifier from the touch event or 1 for mouse events in the hosted application.
     *
     * @param {Event} evt The native touch or mouse event.
     *
     * @private
     */
    function getEvtIdentifier(evt) {
        var id = evt.identifier;
        return (id === undefined) ? 1 : id;
    }

    function debugLog(cmd, msg, widget, evt) {
        // Are we in "debug" mode?
        if (debug) {
            // Log the message to the JS console.
            var touchId = (evt) ? getEvtIdentifier(evt) + ' ' : '';
            window.console.log(cmd + ':' + ((widget) ? ' ' + widget.scriptClass + ' ' + widget.id : '') + ' ' + touchId + (msg || ''));
        }
    }

    /**
     * Returns a boolean indicating if the supplied widget is actively listening for window touch events.
     *
     * @param {mstrmojo.Widget} widget The widget to test.
     *
     * @private
     * @type Boolean
     */
    function isActive(widget) {
        return (activeWinListener === widget);
    }

    /**
     * Detaches touchMove, touchEnd and touchCancel event listeners from the window object.
     *
     * @param {mstrmojo.Widget} widget The widget that is tracking touch events.
     *
     * @private
     */
    function detachWinEvts(widget) {
        // Is this not the active widget?
        if (!isActive(widget)) {
            // Nothing to do.
            return;
        }

        debugLog('detachWinEvts', '', widget);

        // Attach events using Capture phase so the _TouchGestures hears these events before any other component.
        $DDE(window, $D.TOUCHMOVE, widget._tmCallback, true);
        $DDE(window, $D.TOUCHEND, widget._teCallback, true);
        $DDE(window, $D.TOUCHCANCEL, widget._teCallback, true);

        // Clear the active widget.
        activeWinListener = null;
    }

    /**
     * Attaches touchMove, touchEnd and touchCancel event listeners to the window object.
     *
     * @param {mstrmojo.Widget} widget The widget that will be tracking touch events.
     *
     * @private
     */
    function attachWinEvts(widget) {
        // Is this widget already active?
        if (isActive(widget)) {
            // Nothing to do.
            return;
        }

        // Do we have an active widget?
        var activeWidget = activeWinListener;
        if (activeWidget) {
            debugLog('forced deactivation', '', activeWidget);

            // This is a bug so de-activate it.
            detachWinEvts(activeWidget);
        }

        debugLog('attachWinEvts', '', widget);

        // Attach events for touch move, end and cancel.
        $DAE(window, $D.TOUCHMOVE, widget._tmCallback, true);
        $DAE(window, $D.TOUCHEND, widget._teCallback, true);
        $DAE(window, $D.TOUCHCANCEL, widget._teCallback, true);

        // Set this widget as the active widget.
        activeWinListener = widget;
    }

    function getWidgetHandlerMethodName(evtName, action) {
        return 'touch' + ((action && actionMethodMap[action]) || '') + (evtName || '');
    }

    /**
     * Creates the appropriate method name to handle this event.
     *
     *  @param {mstrmojo.Widget} widget The widget to handle this event.
     *  @param {String} [evtName=''] An optional name for the event to be handled.
     *  @param {Integer} [action] An optional action (corresponds to the actionMethodMap constants).
     *
     *  @private
     *  @type String
     *  @returns Either the name of the method to handle this event, or empty string if the widget doesn't handle this event.
     */
    function getWidgetHandler(widget, evtName, action) {
        // Create the method name.
        var methodName = getWidgetHandlerMethodName(evtName, action);

        // Return either the name of the method (if the widget can handle it) or an emtpy string.
        return (widget[methodName] !== undefined) ? methodName : '';
    }

    /**
     * Fires the appropriate widget method to handle this event.
     *
     * @param {mstrmojo.Widget} widget The widget to handle this event.
     * @param {String} [evtName=''] An optional name for the event to be handled.
     * @param {*[]} touch The touch object that gets passed as an argument to the widget's event handler.
     * @param {Integer} [action] An optional action matching one of the ACTION constants.
     * @param {Object} [gesture] An optional gesture object in the event that the touch object does not have it.
     *
     * @private
     * @returns Boolean Either the result of the method call or true if no call was made.
     */
    function fireWidgetHandler(widget, evtName, touch, action, gesture) {
        //Have we been supplied a gesture object or do we have to grab it from the touch?
        gesture = gesture || widget.gestures[touch.id];

        var target = (gesture && gesture.bubbleTarget) || widget,
            methodName = getWidgetHandler(target, evtName, action);

        if (methodName) {
            debugLog('fire', methodName, target);

            // Cache method name in touch object.
            touch.methodName = methodName;

            // Call method on target.
            return target[methodName](touch);
        }
        debugLog('no handler', getWidgetHandlerMethodName(evtName, action), target);

        return true;
    }

    /**
     * Creates an event object used to describe the properties of the touch event.
     *
     *
     * @param (HTMLEvent} e The original HTMLTouchEvent.
     * @param {Object} startTouch The gesture event object describing the initial touch gesture.
     * @param {HTMLTouchEvent} changedTouch The native touch event object.
     * @param {Object) [lastTouch] The last touch event to be used for calculating velocity, direction, etc.
     *
     * @type Object
     * @private
     *
     * @refactoring Should this use screenX.
     */
    function createTouchObject(e, startTouch, changedTouch, lastTouch) {
        var pageX = changedTouch.pageX,
            pageY = changedTouch.pageY,
            timeStamp = e.timeStamp,
            id = getEvtIdentifier(changedTouch),
            delta = {
                x: $MATH.round(pageX - startTouch.pageX),
                y: $MATH.round(pageY - startTouch.pageY)
            };

        var evt = {
            id: id,
            evt: e,
            pageX: pageX,
            pageY: pageY,
            clientX: changedTouch.clientX,
            clientY: changedTouch.clientY,
            target: changedTouch.target,
            delta: delta,
            date: timeStamp,
            stop: function () {
                debugLog('event stopped', id);

                // Stop event propagation.
                e.stopPropagation();
                e.cancelBubble = true;
            }
        };

        if (lastTouch) {
            // Calculate the differences between this touch event and the last touch event.
            var timeDelta = timeStamp - lastTouch.date,
                lastDelta = lastTouch.delta,
                accelDelta = {
                    x: $MATH.abs(delta.x - lastDelta.x),
                    y: $MATH.abs(delta.y - lastDelta.y)
                };

            // Add the velocity since the last touch event.
            evt.velocity = {
                x: accelDelta.x / timeDelta,
                y: accelDelta.y / timeDelta
            };

            // Add an is vertical flag indicating the general orientation of the swipe.
            evt.isVertical = (accelDelta.y > accelDelta.x);

            // Add the delta since the last touch event.
            evt.accelDelta = accelDelta;

            // Add the swipe direction since the last touch event.
            var direction = evt.direction = {};

            // Calculate direction.
            if (pageX !== lastTouch.pageX) {
                direction.x = (pageX < lastTouch.pageX);
            } else if (pageX !== startTouch.pageX) {
                direction.x = (pageX < startTouch.pageX);
            }

            if (pageY !== lastTouch.pageY) {
                direction.y = (pageY < lastTouch.pageY);
            } else if (pageX !== startTouch.pageX) {
                direction.y = (pageY < startTouch.pageY);
            }
        }

        return evt;
    }

    /**
     * Creates an object that encapsulates information about the current gesture.
     *
     * @param {Object} touch An encapsulating object for the current HTMLTouchEvent.
     * @param {Object} previousOneTouch An encapsulating object for the previous HTMLTouchEvent.
     * @param {Object} beginningTouch An encapsulating object for the HTMLTouchEvent that occurred before the previous HTMLTouchEvent.
     * @param {TouchEvent} evt The current touch event.
     *
     * @returns {Object} An object containing information about the current gesture.
     * @private
     */
    function createGestureObject(touch, previousOneTouch, previousTwoTouch, evt) {
        return {
            s: touch,
            p1: previousOneTouch,
            p2: previousTwoTouch,
            evt: evt,
            target: evt.target
        };
    }

    /**
     * Removes the gesture from the bubble target.
     *
     * @param {Widget} target The bubble target.
     * @param {String} touchId The id of the touch gesture to remove.
     */
    function deleteBubbleTargetGesture(target, touchId) {
        if (target) {
            target.gestures[touchId] = null;
        }
    }

    /**
     * Detaches touchMove and touchEnd events and calls the touchEnd method in the widget (if implemented);
     *
     * @param {mstrmojo.Widget} widget The widget that is tracking touch events.
     * @param {Object} touchObject The last touchObject.
     *
     * @private
     */
    function cancelTouch(widget, touchObject) {
        detachWinEvts(widget);

        fireWidgetHandler(widget, EVT_END, touchObject);
    }

    /**
     * Clears the touchSelect timeout handle.
     *
     * @private
     */
    function cancelSelect(widget) {
        if (widget._selectHandle) {
            // Clear select action.
            window.clearTimeout(widget._selectHandle);

            delete widget._selectHandle;

            debugLog('cancelSelect', '', widget);
        }
    }

    /**
     * Event handler for the initial touchStart event.
     *
     * @param {mstrmojo.Widget} widget The widget that is tracking touch events.
     * @param {HTMLEvent} e The native HTMLTouchEvent.
     *
     * @private
     */
    function touchesBegin(widget, e) {
        // Is this a right click mouse event?
        var which = e.which;
        if (which && which === 3) {
            debugLog('ignore', 'right mouse click', widget);

            // Ignore.
            return;
        }

        // Get initial touch event.
        var gestures = widget.gestures,
            touches = e.touches || [ e ],
            changedTouch = (e.changedTouches && e.changedTouches[0]) || e,
            isWidgetActive = isActive(widget),
            touchObject = createTouchObject(e, changedTouch, changedTouch),          // Pass the current touch as both the start and current because this is touchBegin.
            gesture = createGestureObject(touchObject, touchObject, touchObject, e);

        debugLog('touchBegin', '', widget, changedTouch);

        // Is this a multi-touch gesture?
        if (touches.length > 1) {
            // Is this widget NOT already active?
            if (!isWidgetActive) {
                // This is a case where we have a multi touch but the two touches are not on the same touch element so we need to stop the event...
                touchObject.stop();

                debugLog('ignore', 'cross widget multitouch', widget, changedTouch);
                //TQMS #557455:  tap empty place when hold the truncated legend will cause a cross widget multitouch, so we hide the tooltip here.
                var activeWidget = activeWinListener;
                if (activeWidget && activeWidget.onCrossWidgetMultitouch !== undefined) {
                    debugLog('call onCrossWidgetMultitouch for', '', activeWidget);
                    activeWidget.onCrossWidgetMultitouch();
                }
                return false;

            }
        } else {
            // Is this widget already active?
            if (isWidgetActive) {
                debugLog('forced deactivation', '', widget, changedTouch);

                // This is a bug where the detach events was never called so we need to detach them now.
                detachWinEvts(widget);

                // Clear isWidgetActive flag.
                isWidgetActive = false;
            }
        }

        // Should touches be restricted to the touchNode only?
        if (widget.singleNode && changedTouch.target !== widget._tn) {
            debugLog('ignore', 'target is not touch node', widget, changedTouch);

            return;
        }

        // Notify the touch manager that touches have begun.
        if (mstrmojo.touchManager.notify(widget.id, touchObject).ignore) {
            // Event was marked to be ignored so cancel this event.
            touchObject.stop();
            return;
        }

        // Is this the first touch?
        if (!isWidgetActive) {
            // Get the target tag name.
            var tagName = touchObject.target.tagName;
            tagName = tagName && tagName.toLowerCase();

            // Is the target a select box or input field?
            if (tagName === 'select' || tagName === 'input') {
                debugLog('ignore', 'target is input or select', widget, changedTouch);

                // Does the widget want to listen for tap events on inputs?
                if (widget.monitorInputs) {
                    // Fire tap event.
                    fireWidgetHandler(widget, null, touchObject, ACTION_TAP);
                }

                // Return so we don't cancel interaction.
                return;
            }
        }

        // Store the beginning gesture.
        gestures[touchObject.id] = gesture;

        // Is this a multi-touch gesture?
        if (isWidgetActive) {

            // Does the widget NOT support multi-touch?
            if (!widget.multiTouch) {
                // Cancel the select to prevent the touchSelectBegin call in the timeout.
                cancelSelect(widget);

                // Fire touch cancel event.
                var prevTouch = touches[touches.length - 2],
                    prevGesture = gestures[getEvtIdentifier(prevTouch)];

                fireWidgetHandler(widget, EVT_CANCEL, prevTouch, prevGesture.action, prevGesture);
            } else {
                // Change action to multi-touch.
                gesture.action = ACTION_MULTI;

                // Is this the second touch?
                if (widget._singleTouch) {
                    // Cancel any lingering select actions.
                    cancelSelect(widget);

                    // Make sure single touch action is changed to 'Multi'.
                    widget._singleTouch.action = ACTION_MULTI;

                    // delete the bubble target
                    delete widget._singleTouch.bubbleTarget

                    // Delete the reference to single touch.
                    delete widget._singleTouch;

                    // Fire touchMultiBegin.
                    fireWidgetHandler(widget, EVT_BEGIN, touchObject, ACTION_MULTI);
                }
            }

            // Stop the event from bubbling so multiple touch enabled objects won't hear them.
            touchObject.stop();

            // Nothing more to do.
            return;
        }

        // If it's a single touch we need to make sure it started within the touchNode of the widget.
        if (!$D.contains(widget._tn, e.target, true, widget.domNode)) {
            // Remove the gesture.
            delete gestures[touchObject.id];

            // exit.
            return;
        }

        // Store the single gesture.
        widget._singleTouch = gesture;

        // Call touchBegin (if supported).
        if (fireWidgetHandler(widget, EVT_BEGIN, touchObject) === false) {
            // 'touchBegin' returned exactly false so cancel this operation before it begins.
            return;
        }

        // Stop the event from bubbling so multiple touch enabled objects won't hear them.
        touchObject.stop();

        // Does the widget support touch select operations?
        if (getWidgetHandler(widget, EVT_BEGIN, ACTION_SELECT)) {
            // Set a timeout to initiate a select after the select duration has passed.
            widget._selectHandle = window.setTimeout(function () {
                // Record that the current gesture is part of a 'select' operation.
                gesture.action = ACTION_SELECT;

                // Call touchSelectBegin, and if it returns EXACTLY false...
                if (fireWidgetHandler(widget, EVT_BEGIN, touchObject, ACTION_SELECT) === false) {
                    // the operation is not supported on this widget/element so cancel.
                    cancelTouch(widget, touchObject);
                }

                // Clear the timeout handle.
                delete widget._selectHandle;
            }, SELECT_DURATION);
        }

        // Attach events for touch move, end and cancel.
        attachWinEvts(widget);
    }

    /**
     * Event handler for the touchMove event.
     *
     * @param {mstrmojo.Widget} widget The widget that is tracking touch events.
     * @param {HTMLEvent} e The native HTMLTouchEvent.
     *
     * @private
     */
    function touchesMoved(widget, e) {
        var changedTouch = (e.changedTouches && e.changedTouches[0]) || e,
            gesture = widget.gestures[getEvtIdentifier(changedTouch)];

        // Did we not find a gesture?
        if (!gesture) {
            // This is likely due to an ignored multi touch event so ignore.
            return;
        }

        var touchObject = createTouchObject(e, gesture.s, changedTouch, gesture.p2),
            action = gesture.action;

        // Update stored previous gesture events.
        gesture.p2 = gesture.p1;
        gesture.p1 = touchObject;

        // Are we not already in the middle of an action AND has the touch moved more than the swipe threshold?
        if (!action && ($MATH.abs(touchObject.delta.x) > SWIPE_THRESHOLD || $MATH.abs(touchObject.delta.y) > SWIPE_THRESHOLD)) {
            // This must be a swipe so record the action.
            action = gesture.action = ACTION_SWIPE;

            // Cancel the select timeout.
            cancelSelect(widget);

            // Does the widget NOT support either the begin or move for the current action?
            if (!getWidgetHandler(widget, EVT_BEGIN, action) && !getWidgetHandler(widget, EVT_MOVE, action)) {
                // Add the method name to the touchObject.
                touchObject.methodName = getWidgetHandlerMethodName(EVT_BEGIN, action);

                // Bubble the event in case an ancestor does.
                return widget.bubbleTouchEvent(touchObject);
            }

            // Fire the touchSwipeBegin event handler.
            if (fireWidgetHandler(widget, EVT_BEGIN, touchObject, action) === false) {
                // The event handler explicitly returned false so the operation is not supported on this widget/element.
                cancelTouch(widget, touchObject);
                return;
            }
        }

        // Have we initiated an action?
        if (action) {
            var lastMove = gesture.lastMove || gesture.s.date,
                delta = touchObject.date - lastMove;

            // Android 2.x and 3.x fires move events with at least 60ms between events.
            // Android 4.x fires events almost twice as often - throttle back to the 2.x, 3.x level
            // Only on device.
            if (!mstrApp.isTouchApp() || delta >= MIN_DELTA_BETWEEN_MOVE_EVENTS) {
                gesture.lastMove = touchObject.date;
                fireWidgetHandler(widget, EVT_MOVE, touchObject, action);
            }
        }
    }

    /**
     * Event handler for the touchEnd event.
     *
     * @param {mstrmojo.Widget} widget The widget that is tracking touch events.
     * @param {HTMLEvent} e The native HTMLTouchEvent.
     *
     * @private
     */
    function touchesEnd(widget, e) {
        var changedTouch = (e.changedTouches && e.changedTouches[0]) || e,
            touchCount = (e.touches && e.touches.length) || 0,          // If no touches collection then this is single touch environment.
            gestures = widget.gestures,
            touchId = getEvtIdentifier(changedTouch),
            gesture = gestures[touchId];

        // Did we not find a gesture?
        if (!gesture) {
            debugLog('No gesture', touchId, widget, changedTouch);

            // This is likely due to an ignored multi-touch so return and wait for the next one.
            return;
        }

        var action = gesture.action,
            touchObject = createTouchObject(e, gesture.s, changedTouch, gesture.p2);

        // Was no action initiated?
        if (!action) {
            // NO, then we need to cancel the select timeout.
            cancelSelect(widget);

            // If this isn't the last touch from a multi-touch operation than default to a tap operation.
            if (!gesture.wasMulti) {
                action = ACTION_TAP;
            }
        }

        // Are there no more touches in progress?
        if (touchCount === 0) {
            // All touches are over so detach the touch events...
            detachWinEvts(widget);

            // and clear gestures.
            widget.gestures = [];

            debugLog('gestures', 'clear all', widget, changedTouch);
        } else {
            // Remove the single gesture that has just ended.
            gestures[touchId] = null;

            debugLog('gestures', 'clear single', widget, changedTouch);
        }

        // Delete the gesture bubble target.
        deleteBubbleTargetGesture(gesture.bubbleTarget, touchId);

        // What type of action was completed?
        switch (action) {
        case ACTION_SWIPE:
        case ACTION_SELECT:
            //TQMS 556535
            touchObject.stop();
            fireWidgetHandler(widget, EVT_END, touchObject, action, gesture);
            break;

        case ACTION_MULTI:
            // Is the touch count now less than 2 (1 or 0)?
            if (touchCount < 2) {
                // Multi event is over so call 'touchMultiEnd'.
                fireWidgetHandler(widget, EVT_END, touchObject, action, gesture);

                // Is there one touch left?
                if (touchCount === 1) {
                    // This should now become a touchBegin so re-base the remaining touch event at it's current position.
                    var remainingTouch = e.touches[0],
                        rebasedTouch = createTouchObject(e, remainingTouch, remainingTouch),
                        newGesture = createGestureObject(rebasedTouch, rebasedTouch, rebasedTouch, e);

                    // Set a flag so that we don't initiate a 'tap' operation when the user releases the last touch.
                    newGesture.wasMulti = true;

                    // Store new gesture in place of the original.
                    gestures[getEvtIdentifier(remainingTouch)] = newGesture;

                    // Flag as single touch.
                    widget._singleTouch = newGesture;
                }
            }

            // Do we have any touches left?
            if (touchCount > 0) {
                // Return so 'touchEnd' is not called.
                return;
            }
            break;

        case ACTION_TAP:
            // Does the widget NOT care about taps?
            if (!getWidgetHandler(widget, null, action)) {
                // Nothing to do.
                break;
            }
            //TQMS 556535
            //Commented out for TQMS 571038
            //touchObject.stop();

            // Do we already have a tap timeout handler?
            var tapHandler = widget._tapHandler;
            if (tapHandler) {
                // YES, then clear the timeout that hasn't fired yet.
                window.clearTimeout(tapHandler.h);
            }

            // The user didn't swipe or select, but was it a quick tap operation?
            if (touchObject.date - gesture.s.date < SELECT_DURATION) {
                // Call touchTapBefore
                if (fireWidgetHandler(widget, 'Before', touchObject, action, gesture) === false) {
                    // touchTapBefore returned false so there is nothing to do.
                    break;
                }

                if (!widget.multiTap) {
                    // Add the count to the touch event.
                    touchObject.count = 1;

                    // Notify the widget.
                    fireWidgetHandler(widget, null, touchObject, action, gesture);

                } else {
                    // Do we already have a timeout for taps?
                    if (tapHandler) {
                        // YES, then increment the tap counter.
                        tapHandler.count++;
                    } else {
                        // NO, then create a new tap handler and store it on the instance.
                        tapHandler = widget._tapHandler = {
                            count: 1
                        };
                    }

                    // Set a time out to raise the tap event.  We need to do this to support multiple taps -- we don't want to fire the event
                    // until they have finished tapping.
                    tapHandler.h = window.setTimeout(function () {
                        // Add the count to the touch event.
                        touchObject.count = tapHandler.count;

                        // Notify the widget.
                        fireWidgetHandler(widget, null, touchObject, action, gesture);

                        // Clear the tapHandler.
                        delete widget._tapHandler;
                    }, TAP_TIMEOUT);
                }

            } else {
                // Kill the tapHandler.
                delete widget._tapHandler;
            }
            break;
        }


        // Fire the touchEnd event handler.
        fireWidgetHandler(widget, EVT_END, touchObject, undefined, gesture);
    }

    /**
     * Creates touch callbacks and attaches the initial event listener for the start of a touch.
     *
     * @param {mstrmojo.Widget} widget The widget whose touch node should track touches.
     *
     * @private
     */
    function attachTouchEvents(widget) {

        // Do we have a touch node?
        var touchNode = widget._tn;
        if (!touchNode) {
            // Nothing to do here, so exit.
            return;
        }

        // Have we not yet created the touch events callback?
        if (!widget._tmCallback) {
            // Create all callbacks.  We need to store all call backs so that we can release them later.
            widget._tsCallback = function (e) {
                touchesBegin(widget, e);
            };
            widget._tmCallback = function (e) {
                touchesMoved(widget, e);
            };
            widget._teCallback = function (e) {
                touchesEnd(widget, e);
            };
        }

        // Attach the touch start event.
        $DAE(touchNode, $D.TOUCHSTART, widget._tsCallback);
    }

    /**
     * <p>Tracks "touch gestures".</p>
     *
     * @class
     * @public
     */
    mstrmojo._TouchGestures = mstrmojo.provide(
        "mstrmojo._TouchGestures",
        /**
         * @lends mstrmojo._TouchGestures#
         */
        {
            _mixinName: 'mstrmojo._TouchGestures',

            /**
             * Indicates whether the touch events should be restricted to the touchNode, or include it's children.
             *
             * @type Boolean
             * @default false
             */
            singleNode: false,

            /**
             * Indicates whether we support multi-touch.
             *
             * @type Boolean
             * @default false
             */
            multiTouch: false,

            /**
             * The slot that should support touch gestures (will default to domNode).
             *
             * @type HTMLElement
             */
            touchNode: null,

            /**
             * Indicates whether to support multiple taps.  If false each tap will fire an individual tap event.
             *
             * @type Boolean
             * @default false
             */
            multiTap: false,

            /**
             * Indicates whether the consumer wants to listen for tap events on input elements.
             *
             * @type Boolean
             * @default false
             */
            monitorInputs: false,

            /**
             * Caches a reference to the touch node, creates the gestures collection container and attaches touch events.
             *
             * @ignore
             */
            postBuildRendering: function postBuildRendering() {
                if (this._super) {
                    this._super();
                }

                // Get a handle to the touch node.
                this._tn = this.touchNode || this.domNode;

                // Local collection for gestures.
                this.gestures = [];

                // Attach touch events.
                attachTouchEvents(this);
            },

            /**
             * This function bubbles the touch to the widget's parent widget.
             *
             * @param touch The native touch event object.
             */
            bubbleTouchEvent: function bubbleTouchEvent(touch) {
                var evtName = touch.methodName,
                    touchId = touch.id,
                    gesture = this.gestures[touchId],
                    p = this.parent;

                // Loop till we get to a parent that cares about this particular event.
                while (p) {
                    // Get the current event method as well as the touch begin from the parent.
                    var targetMethod = p[evtName],
                        touchBegin = p.touchBegin;

                    // Does the parent support the current event method AND does it either NOT have a touchBegin OR does touchBegin NOT return false?
                    if (targetMethod && (!touchBegin || fireWidgetHandler(p, EVT_BEGIN, touch) !== false)) {
                        // Reset the touch method name (since it was changed in fireWidgetHandler).
                        touch.methodName = evtName;

                        // Delete the gesture bubble target.
                        deleteBubbleTargetGesture(gesture.bubbleTarget, touchId);

                        // Set the bubble target so all future events for this gesture can be delegated efficiently.
                        gesture.bubbleTarget = p;

                        // Add the gestures to the parent.
                        p.gestures[touchId] = gesture;

                        // Log bubble.
                        debugLog('bubble', ((this.k) ? ' ' + this.k : '') + '] bubbled ' + evtName + ' to [' + p.scriptClass + ((p.k) ? ' ' + p.k : '') + ']', this, touch);

                        // Call the event on the parent and return value.
                        return targetMethod.call(p, touch);
                    }

                    // We still haven't found a valid parent, keep looping through the ancestors.
                    p = p.parent;
                }

                return false;
            },

            /**
             * Detaches the touch events.
             *
             * @ignore
             */
            unrender: function unrender(ignoreDom) {
                // Is this widget currently listening to the window events?
                if (isActive(this)) {
                    // Detach the window event listeners.
                    detachWinEvts(this);
                }

                // Do we have a touch node?
                var touchNode = this._tn;
                if (touchNode) {
                    // Detach the touch start event.
                    $D.detachEvent(touchNode, $D.TOUCHSTART, this._tsCallback);
                }

                this._super(ignoreDom);
            },

            /**
             * Resets the configuration to allow or prevent the default touches.
             *
             * @param resetFlag Whether we would like to restore the default environment touch behavior (when true) or override it (when false).
             */
            restoreDefaultTouches: function restoreDefaultTouches(resetFlag) {
                if ($C) {
                    //adjust the flag...
                    $C.allowDefaultTouches = resetFlag && defaultTouchConfiguration;
                }
            }
        }
    );

}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.Obj",
        "mstrmojo._LoadsScript",
        "mstrmojo._HasChildren",
        "mstrmojo.Binding",
        "mstrmojo._HasBindings");
    
    /**
     * <p>Base data model class.</p>
     *
     * <p>A Model is an enhanced Obj with the ability to:
     * <ul>
     * <li>load additional javascript methods at run-time,</li>
     * <li>contain "child" objects (such as instances of Obj, Model), and </li>
     * <li>use "bindings" to set its property values dynamically.</li>
     * </ul>
     * </p>
     *
     * @class
     * @extends mstrmojo.Obj
     */
    mstrmojo.Model = mstrmojo.declare(
        // superclass
        mstrmojo.Obj,

        // mixins
        [mstrmojo._LoadsScript, mstrmojo._HasChildren, mstrmojo._HasBindings],
                
        /**
         * @lends mstrmojo.Model.prototype
         */
        {
            /**
             * @ignore
             */
            scriptClass: "mstrmojo.Model",


            /**
             * <p>Base data model class.</p>
             *
             * <p>Enhances the inherited constructor {@link mstrmojo.Obj#init} in order to do the following after initializing itself:
             * <ol>
             * <li>initialize this object's child objects (if any),</li>
             * <li>call the "postCreateChildren" handler (if any),</li>
             * <li>initialize this object's bindings (if any), and</li>
             * <li>call the "postCreateBindings" handler (if any).</li>
             * </ol>
             * </p>
             * 
             * @constructs
             * @extends mstrmojo.Obj
             */
            init: function init(props) {            
                this._super(props);

                // If we have a "children" config, initialize our children.
                if (this.children) {
                    this.initChildren();
                }
                
                // If we are an orphan, init our bindings now (if any). Otherwise we have a parent,
                // and that parent is responsible for calling us later to init our bindings, after it
                // has finished constructing its children. 
                if (!this.parent){
                    this.initBindings();
                }
            },
            
            /**
             * <p>Extends the inherited method in order to call destroy on its child objects and its bindings before
             * destroying itself.</p>
             *
             * <p>This method destroys this object's children first before destroying this object's bindings.
             * Typically, children with bindings are bound to properties in their ancestors. Therefore, we wait
             * until after our children are destroyed to destroy our own bindings, thereby reducing the number of
             * binding events raised by our own destruction.</p>
             *
             * @param {Boolean} [skipCleanup] If true, this flag indicates that some parent/ancestor of this object
             * will handle some cleanup after this object is destroyed. Used as a performance optimization.
             */
            destroy: function dst(skipCleanup) {
                if (this.children) {
                    this.destroyChildren(true);
                }
                if (this.bindings) {
                    this.destroyBindings();
                }
                this._super(skipCleanup);
            }
        }
    );
    
})();
(function(){

    mstrmojo.requiresCls("mstrmojo.Obj");

    mstrmojo.maps.AndroidMapModel = mstrmojo.declare(
        mstrmojo.Obj,
        
        null,
        
        /** 
         * @lends mstrmojo.maps.AndroidMapModel.prototype
         */
        {            
            scriptClass: "mstrmojo.maps.AndroidMapModel",

            getVisProps: function() {
                return this.data.vp;
            },
            
            /*
                STUB METHODS -             
            */
            
            setPrompts: function setPrompts(prompts) {},

            getDataService: function getDataService() {},
                        
            execute: function execute(params, callback) {},
            
            answerPrompts: function answerPrompts(callback) {},
            
            getPageByTree: function getPageByTree(callback) {},                        
            
            sort: function sort (params, callback) {},
            
            pivot: function pivot (params, callback) {},
            
            drillGrid: function drillGrid (params, callback) {},
            
            drill2Grid: function drill2Grid (params, callback) {},            

            linkToObject: function linkToObject (params, callback) {},
            
            pageBy: function pageBy(pageByKeys, callback) {},
                        
            saveRWProps: function saveRWProps(nodeKey, props, type, loadData, callback) {}
         
        }
        
 
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.func",
        "mstrmojo.Model",
        "mstrmojo._CanProxyCallback",
        "mstrmojo.EnumRWUnitType",
        "mstrmojo.DocDataService",
        "mstrmojo.StringBuffer",
        "mstrmojo.EnumReadystate");

    var $RWTYPES = mstrmojo.EnumRWUnitType,
        $RS = mstrmojo.EnumReadystate,
        $HFE = mstrmojo.hash.forEach,
        $WRAP = mstrmojo.func.wrapMethods,
        $A = mstrmojo.array;

    /**
     * Helper object to convert definition nodes to {@link mstrmojo.Model}s.
     *
     * @private
     * @ignore
     */
    var observables = {
        isObservable: function (defn) {
            // Get the type of unit.
            var t = defn && defn.t;

            // Does this defn NOT have a type OR is it already observable (signified by the presence of a scriptClass).
            if (!t || !(t in this) || defn.scriptClass) {
                // Nothing more to do.
                return false;
            }

            // Details subsection don't need to be observable since they can't contain a portal.
            return (t !== $RWTYPES.SUBSECTION || !defn.dt);
        },

        makeObservable: function (defn) {
            // Tell it which properties should be audible. If a definition is forced to be made observable, make it an empty object.
            defn.audibles = this[defn.t] || {};

            // Does this definition have an audible readyState?
            if ('readyState' in defn.audibles) {
                // Set the initial ready state.
                defn.readyState = $RS.IDLE;
            }

            // Convert to an Model.
            return new mstrmojo.Model(defn);
        }
    };

    observables[$RWTYPES.PANELSTACK] = {
        '*': false,
        selKey: true,    // Selected panel key.
        readyState: true
    };

    observables[$RWTYPES.GRID] = {
        '*': false,
        readyState: true,
        ds: true    // Display state for portals.
    };

    observables[$RWTYPES.GRAPH] = {
        '*': false,
        readyState: true,
        ds: true    // Display state for portals.
    };

    observables[$RWTYPES.GRIDGRAPH] = {
        '*': false,
        qsm: true,
        ds: true    // Display state for portals.
    };

    observables[$RWTYPES.SUBSECTION] = {
        '*': false,
        resize: true,
        adjustSize: true
    };

    observables[$RWTYPES.VISUALIZATION] = {
        '*': false,
        ds: true    // Display state for portals.
    };

    observables[$RWTYPES.SELECTOR] = {
        '*': false,
            cek: true,    // current element key.
            ds: true
    };

    observables[$RWTYPES.MOJOVISUALIZATION] = {
        '*': false,
        ds: true    // Display state for portals.
    };


    /**
     * Returns the current layout node from the supplied definition.
     *
     * @param {Object} node The node (either definition or data) from which to extract the current layout.
     * @param {String} lytKey The current layout key.
     *
     * @private
     * @ignore
     */
    function getLayout(node, lytKey) {

        // Optimization: use a quick lookup hash, if available, to avoid for-loop.  NOTE: This only works for definition.  We don't want to cache
        // data layouts because they might change.
        var lyt = node.layoutMap && node.layoutMap[lytKey];
        if (lyt) {
            return lyt;
        }

        var lyts = node.layouts,
            cnt = (lyts && lyts.length) || 0,
            i = 0;

        for (i = 0; i < cnt; i++) {
            if (lyts[i].k == lytKey) {
                return lyts[i];
            }
        }

        return null;
    }

    /**
     * This method retrieves the definition of an object from the DocModel's "defn" tree.
     *
     * @param {Object} The definition node from the DocModel.
     * @param {String} key The key of the object whose definition is requested.
     *
     * @private
     * @ignore
     */
    function lookupDefn(defn, lytKey, key) {
        var lyt = getLayout(defn, lytKey);

        if (key == lytKey) {
            // Add the layout key to the definition.
            lyt._lkz = lytKey;

            return lyt;

        } else if (lyt) {
            // Retrieve the unit from the units collection.
            var unit = lyt.units[key];
            // Do we have a unit
            if (unit) {
                // Is it of type grid/graph?
                if (unit.t == $RWTYPES.GRIDGRAPH) {
                    // We need to insert defn items for the child grid and child graph.
                    // Have we NOT done it already?
                    if (!lyt.units[key + '_0']) {

                        // Create grid definition object.
                        lyt.units[key + '_0'] = {
                            ck: unit.ck,  // share current key
                            fmts: unit.fmts.gd,    // Sub node
                            txi: unit.txi, // the transaction info object (for Transaction)
                            t: $RWTYPES.GRID
                        };

                        // Create the graph definition object.
                        lyt.units[key + '_1'] = {
                            ck: unit.ck,  // share current key
                            fmts: unit.fmts.gp,    // Sub node
                            t: $RWTYPES.GRAPH
                        };
                    }
                }

                // Does this unit need to be observable?
                if (observables.isObservable(unit)) {
                    // Replace the unit in the collection (and in place) with an observable version.
                    unit = lyt.units[key] = observables.makeObservable(unit);
                }

                // Add the layout key to the definition.
                unit._lkz = lytKey;
            }

        }

        return lyt && lyt.units[key];
    }
    /*
     * Returns filtered child sections.
     * @node the layout node
     * @param types the section types to include or exclude
     * @param include include specified types in returned array or exclude specified types in returned array.
     *
     * Currently filtering only happens for mobile device. For web application, when include = true, it will return empty array, when include = false, it will return all children.
     */
    function filterSectionsByTypes(node, isPartial, types, include) {
        var children = this.getChildren(node, isPartial, 0);
        // enable the dock page header/footer feature #469434
        return (mstrApp.isMobile ? (mstrmojo.array.filter(children, function (sec) {
                                            var idx = types && types.indexOf(sec.defn.t),
                                            	dk = sec.defn.dk;
                                            return include? (idx > -1 && dk === -1) : (idx < 0 || dk !== -1);
                                        })) : (include ? [] : children));
    }

    /**
     * <p>Utility function for building unique ID from the supplied data node.<p>
     *
     * <p>The id is a combination of the layout key, the unit key, the optional widget ID and the models buildTime timestamp.
     *
     * @param {String} data.k The node key.
     * @param {String} [data.wid=""] The widget id for this node.
     * @param {String} lk The layout key.
     *
     * @private
     */
    var fnBuildId = function(data, lk) {
        var id = new mstrmojo.StringBuffer();

        // Do we have a layout key?
        if (lk) {
            // Add layout key.
            id.append('*l' + lk);
        }

        // Add key
        id.append('*k' + data.k);

        // Do we have a widget ID?
        if ('wid' in data) {
            // Add widget ID.
            id.append('*x' + data.wid);
        }

        // Add the build time to ensure uniqueness.
        id.append('*t' + this.buildTime);

        return id.toString();
    };

    /**
     * Get the udpate string in xml and move changed object id into a pending list.
     * @param {String} t The request identifier.
     * @returns {String} update string in xml
     * */
    function getTxUpdates(t) {
        var i, w,
        d = this.delta,
        pu = this.pendingUpdate,
        updates = [];

        // create pending update object if not existing
        if(!pu) {
            pu = this.pendingUpdate = {};
        }

        if(!mstrmojo.hash.isEmpty(d)) {
            updates.push('<updates>');
            for(i in d) {
                if(d.hasOwnProperty(i)) {
                    w = d[i];
                    updates.push(w.getUpdates());
                }
            }
            // move the current delta objects into pending update for a request.
            pu[t] = d;
            // clear the delta list so that new changes can append to it later.
            this.delta = {};

            updates.push('</updates>');
        }
        return updates.join('');
    }

    /**
     * Gets the definition objects for the given object keys.
     *
     * @param {String} keys Delimited string of Object keys.
     * @param {String] [delim=\u001E] An optional delimiter to use when splitting the keys parameter.
     *
     * @returns {Object[]} Array of definition objects.
     */
    function fnGetTargetDefn(keys, delim) {
        var defs;
        if ( keys ) {
	        keys = keys.split(delim || '\u001E');
	        for (var i = 0, cnt = keys.length; i < cnt; i++) {
	            defs = defs || {};
	            defs[keys[i]] = lookupDefn.call(this, this.defn, this.currlaykey, keys[i]);
	        }
        }
        return defs;
    }

    function unloadAffectedLayouts(me, data) {
        var ulkeys = data.ulkeys,
        //var ulkeys = ["K3", "K67"],
            view = me.controller.view;
        if (view && view.unloadLayouts && ulkeys && ulkeys.length) {
            view.unloadLayouts(ulkeys);
        }
    }

    /**
     * Returns true if the supplied key corresponds to an info window panel stack.
     *
     * @param {String} key The key of the unit to check.
     * @param {String} [layoutKey=currentLayoutKey] An optional layout key that will default to the current layout.
     *
     * @private
     */
    function isInfoWindowPS(key, layoutKey) {
        var defn = this.getLayoutUnitDefn(key, layoutKey);
        return (defn && defn.t === $RWTYPES.PANELSTACK && defn.ifw);
    }

    function isCurrentSlice(node, sid){
        return !sid || (node.wid == sid);
    }

    /**
     * This function will check whether there is any groupby unit selecting "AlL"
     *
     * @returns {boolean}
     */
    function hasAllSelectedInGB() {
        var lyts = this.data && this.data.layouts,
            lyt = lyts[$A.find(lyts, 'k', this.getCurrentLayoutKey())],
            gbs = lyt && lyt.gbys && lyt.gbys.groupbys,
            isAllSelected = false;

        $A.forEach(gbs, function (gb) {
            if (gb.unit && gb.unit.elms && gb.unit.elms[gb.unit.idx].v === 'u;' /* All */) {
                isAllSelected = true;
                return false;
            }
        });

        return isAllSelected;
    }
    
    mstrmojo.DocModel = mstrmojo.declare(
        // superclass
        mstrmojo.Model,

        // mixins
        [mstrmojo._CanProxyCallback],

        /**
         * @lends mstrmojo.DocModel.prototype
         */
        {
            scriptClass: 'mstrmojo.DocModel',

            audibles: {
                '*': false,
                data: true
            },

            /**
             * An observable dictionary of feature settings.
             */
            features: null,

            /**
             * A cache of data nodes that have been changed since the original instantiation.
             *
             * @type Object
             */
            dataCache: null,

            /**
             * The controller for this document.
             *
             * @type mstrmojo.Obj
             */
            controller: null,

            /**
	     * Public lookup of secondary data providers and their primary data providers.
	     * @type Object
	     * The key is the secondary data provider key and the value is an object containing parent widget key and visualization Name
	     *
	     */
            sdp : null,

            /**
             * <p>This Class is the main model that contains all definition and data for all document layouts in a MicroStrategy Report Services document.</p>
             *
             * <p>This model is responsible for all interactivity and most communication with the web server.</p>
             *
             * @constructs
             * @extends mstrmojo.Model
             *
             * @param {Object} props A hash of properties/values to be applied to this instance.
             */
            init: function init(props) {
                this._super(props);

                if (!this.features) {
                    this.features = new mstrmojo.Model();
                    this.disposables.push(this.features);
                }
                this.ondefnChange();

                // Initialize the build time to be used as a unique identifier for this document.
                this.buildTime = mstrmojo.now();
            },

            /**
             * Allows the definition object to be made observable so that it can listen to events.
             *
             * @param defn The definition node.
             */
            makeObservable: function makeObservable(defn) {
                return observables.makeObservable(defn);
            },

            /**
             * Gets the definition objects for the given object keys
             * @param {String} keys Object keys
             * @returns {Object} definition objects
             */
            getTargetDefn: function(keys) {
                return fnGetTargetDefn.call(this,keys);
            },

            getTargetInfoWin: function(keys) {
            	var ret = [],
            		tgtDefs = fnGetTargetDefn.call(this, keys);
            	if (tgtDefs) {
            		var tgt;
            		for (tgt in tgtDefs) {
            			if (tgtDefs[tgt] && tgtDefs[tgt].ifw) {
            				ret.push(tgt);
            			}
            		}
            	}

            	return ret;
            },

            /**
             * Gets the definition objects for the given object keys
             * @param {String} keys Object keys
             * @returns {Object} definition objects
             */
            getUnitDefinitions: function(keys, delim) {
                return fnGetTargetDefn.call(this,keys, delim);
            },

            /**
             * Returns true if a given comma-delim list of features are all enabled.  The list
             * may include "!" symbols to require disabled features rather than enabled features.
             */
            hasFeatures: function rsFts(/*String*/ featList){
                var fs = this.features;
                if (!fs) {
                    return false;
                }

                var arr = featList.split(',');
                for (var i=0, len=arr.length; i<len; i++){
                    var s = arr[i],
                        neg = s.match(/^\!/);
                    if (neg) {
                        s = s.replace("!", "");
                    }
                    if (neg ? this.features[s] : !this.features[s]) {
                        return false;
                    }
                }
                return true;
            },

            /**
             * <p>This handler is triggered whenever this DocModel's "defn" property is changed.</p>
             *
             * <p>As a performance optimization, it creates a hashmap for quick lookup of current layout definition.</p>
             */
            ondefnChange: function ondefnChg(){
                var defn = this.defn,
                    lyts = defn && defn.layouts,
                    lytMap = {};
                if (defn) {
                defn.layoutMap = lytMap;

                for (var i = 0, cnt = lyts && lyts.length || 0; i < cnt; i++) {
                    var lyt = lyts[i];
                    lytMap[lyt.k] = lyt;
                }
                }
            },

            /**
             * Returns an object with a getFormat method that returns the formats for a given definition.
             *
             * @type Object
             */
            formatResolver: {

                /**
                 * Returns the resolved formats for the given definition node.
                 *
                 * @param {Object} defn The definition node for the widget.
                 * @param {String} thresholdId The ID of the threshold formatting to use for this instance.
                 *
                 * @returns {Object} The resolved format node for this object.
                 */
                getFormat: function getFormats(defn, thresholdId) {
                    // Get the base formatting.
                    var fmts = ((defn && defn.fmts) || null);

                    // Is there a threshold?
                    if (thresholdId) {
                        // Get the threshold formatting.
                        var ts = defn.thresholds,
                            tFmts = ts && ts[thresholdId];

                        // Did we find threshold formatting?
                        if (tFmts) {
                            // Create composite formatting of thresholds and base formatting.
                            var fx = {},
                                p;

                            // Get all formatting from base.
                            for (p in fmts) {
                                fx[p] = tFmts[p] || fmts[p];
                            }

                            // Overwrite with threshold formatting to get any values that are in the threshold but not in the base formatting.
                            for (p in tFmts) {
                                var formatValue = tFmts[p];
                                fx[p] = (typeof(formatValue) === "string") ? (formatValue + " !important") : formatValue;
                            }

                            // Reset formats to composite format.
                            fmts = fx;
                        }
                    }

                    // Return resolved formatting.
                    return fmts;
                }
            },

            /**
             * Returns an object containing the collections of the grid keys and their styles in the string as the values for the
             * selected layout.
             *
             * @param {String} [k=this.currlaykey] The key of the requested layout grid styles.  If omitted, the current layout key will be used.
             *
             * @returns {Object} A JSon object with a map containing the grid keys and their styles
             */
            getSelectedXtabStyles: function getSelectedGridStyles(k)  {
                var sk = k || this.currlaykey;
                var ss = {};

                var lyts = this.data && this.data.layouts;
                for (var i in lyts) {
                    if (lyts[i].k === sk) {
                        ss = lyts[i].xtabStyles;
                        break;
                    }
                }

                return ss;
            },

            /**
             * <p>Retrieves the child nodes for a given data node.</p>
             *
             * <p>The data node is any node provided by a previous getChildren() call to this model, or null.  If null,
             * the model returns all the layout data nodes in this model.  If a layout data
             * node is given, the model returns all the section data child nodes for the
             * given layout node.</p>
             *
             * <p>If a section data node is given, the model returns all
             * the subsection data nodes for the given section node. If a subsection data node is
             * given, the model returns all the control data nodes for the given subsection node.</p>
             *
             * @todo Do we need support for asynchronous usage? Maybe caller should be required to pass in a callback?
             *
             * @param {Object} node The data node to get children from.
             * @param {Boolean} isPartial Whether this is a partial update or not.
             * @param {Integer} start
             * @param {Integer} count
             * @param {Boolean} includeTotal
             */
            getChildren: function getCh(node, isPartial, start, count, includeTotal) {
                // Default to current layout key.
                var layoutKey = this.currlaykey;

                // Do we have a node?
                if (node) {
                    // Layout key will be the _lkz property of the definition OR the actual key of the node (for layout case).
                    var defn = node.defn;
                    layoutKey = (defn && defn._lkz) || node.k;
                }

                // If it's not a partial update and the dataCache exists then we need to check for data nodes in the dataCache. Partial updates will always
                // use the passed in node because they will replace the dataCache after building.
                var dc = this.getLayoutDataCache(layoutKey),
                    useCache = (!isPartial && !mstrmojo.hash.isEmpty(dc)),
                    lookin;

                // Do we not have a node?
                if (!node) {
                    // This is the current layout so lookin data.
                    lookin = this.data;
                } else {
                    // Get src from data (or node if no data).
                    var src = node.data || node;

                    // Are we using the cache?
                    if (useCache) {
                        // Reset lookin to data cachec.
                        lookin = dc[fnBuildId.call(this, src, layoutKey)];

                        // Reset lookin to data or lookin or src (in that order).
                        lookin = (lookin && lookin.data) || lookin || src;
                    } else {
                        // No cache so use src.
                        lookin = src;
                    }
                }

                // Extracting children from the supplied data node.
                var arr = lookin ? (lookin.sections || lookin.subsections || lookin.objects || lookin.panels || lookin.layouts || lookin.children) : [],
                    ch = [];

                var len = (arr && arr.length) || 0;
                if (len) {
                    var defn = this.defn,
                        traversingLayouts = !node,
                        ck = node ? layoutKey : null,                                           // if !node, we are walking the layouts list, outside of any layout.
                        type = (node && ((node.defn) ? node.defn.t : lookupDefn.call(this, defn, ck, node.k).t));        // The type of unit.

                    // Is it a grid/graph?  Look for the type in the definition (or lookup the definition for partial updates).
                    var isGridGraph = (type === $RWTYPES.GRIDGRAPH),
                        isDetails = (type === $RWTYPES.DETAILS);

                    for (var i = start || 0, stop = (isNaN(count)) ? len : i + count; i < stop; i++) {
                        var item = arr[i];
                        if (isGridGraph) {
                            // Both children share same key and same widget id.
                            item.k = node.k;
                            item.wid = node.data.wid;
                        }
                        var key = item.k,
                            id = fnBuildId.call(this, item, ck),
                            df;

                        //If it is a Panel Stack used as Info Window, put it into the cache for future rendering.
                        //Info Window shall be instantiated and rendered when info window is needed.
                        //If we're traversing layouts, we dont need to check for info window PS.
                        if (!traversingLayouts && !isPartial && isInfoWindowPS.call(this, key, ck)) {
                            var unitDef = this.getLayoutUnitDefn(key),
                                unit = {
                                        data:item,
                                        defn: unitDef,
                                        id: id,
                                        k: key,
                                        p: lookin
                                    };
                            dc[id] = unit;
                            //Store infow window unit into separate collection so we can get it by name.
                            //We need this to handle URL API info window links.
                            if(!this.infoWinByKey || !this.infoWinByKey[key]) { // #763190 don't overwrite the same info window with different keys
                                var infoWindows = this.infoWindows = this.infoWindows || {};
                                var infoWinByKey = this.infoWinByKey = this.infoWinByKey || {};
                                infoWindows[unitDef.n] = infoWinByKey[key] = unit;
                            }
                            continue;
                        }

                        // Is it a GridGraph object?
                        if (isGridGraph) {

                            // We need to modify the id (since the grid and graph children share the same key).
                            id += '_' + i;

                            // Append sub block to key.
                            df = lookupDefn.call(this, defn, ck, item.k + '_' + i);

                        } else {
                            df = lookupDefn.call(this, defn, ck || item.k, item.k);    // if !ck, item is a layout, item.k is the "current" layout key
                        }


                        // Is the parent a details section?
                        if (isDetails) {
                            // Set a flag so that we know later that this is a details subsection.  We use this to prevent details subsection
                            // definitions from being observable.
                            df.dt = true;
                        }

                        // Add the child to the array.
                        ch.push({
                            k: item.k,
                            id: id,
                            defn: df,
                            data: useCache ? (dc[id] && dc[id].data) || item : item
                        });
                    }
                }
                   // Did the caller ask for total count along with the nodes?
                return includeTotal ? { nodes: ch, total: len } : ch;
            },

            /**
             * Returns info windo unit.
             *
             * @param {String} name The info window name.
             */
            getInfoWindow: function getInfoWindow(name) {
                var infoWindows = this.infoWindows;
                return infoWindows && infoWindows[name];
            },

            /**
             * Returns fixed header sections.
             */
            getFixedHeaders: function(node, isPartial) {
                return filterSectionsByTypes.call(this, node, isPartial, [$RWTYPES.PAGEHEADER], true);
            },
            /**
             * Returns fixed footer sections.
             */
            getFixedFooters: function(node, isPartial) {
                return filterSectionsByTypes.call(this, node, isPartial, [$RWTYPES.PAGEFOOTER], true);
            },
            getNonFixedSections: function(node, isPartial) {
                return filterSectionsByTypes.call(this, node, isPartial, [$RWTYPES.PAGEHEADER, $RWTYPES.PAGEFOOTER], false);
            },
            /**
             * Returns the definition for the unit with the specified key.
             *
             * @param {String} key The key of the requested unit definition.
             * @param {String} [layoutKey] Optional layout key for the unit.  If ommited the current layout will be used.
             *
             * @type Object
             */
            getLayoutUnitDefn: function getLayoutUnitDefn(key, layoutKey) {
                return lookupDefn.call(this, this.defn, layoutKey || this.currlaykey, key);
            },

            getUnitInstance: function getUnitInstance(key, widgetID) {
                return mstrmojo.all[fnBuildId.call(this, {
                    k: key,
                    wid: widgetID
                }, this.currlaykey)];
            },

            getFirstUnitInstanceByName: function getFirstUnitInstanceByName(name) {
                var lyt = getLayout(this.defn, this.currlaykey);
                if (lyt) {
                    // Find the unit in the units collection
                    var units = lyt.units;
                    for (u in units) {
                        var unit = units[u];
                        if ( unit.n === name ) {
                           return this.getUnitInstance(u,1);
                        }
                    }
                }
                return null;
            },

            /**
             * Returns the key of the current layout.
             *
             * @param {Object} node
             * @type String
             */
            getSelectedKey: function getSelK(/*Object?*/ node) {
                return (!node && this.currlaykey) || null;
            },

            getCurrentLayoutKey: function getCurrentLayoutKey() {
                return this.currlaykey;
            },

            getCurrentLayoutDef: function getCurrentLayoutDef() {
                var layouts = this.defn && this.defn.layouts;
                return layouts && layouts[$A.find(layouts, 'k', this.currlaykey)];
            },

            /**
             * <p>Updates pertinent DocModel properties and data and defn nodes for the current layout after an xhr call.</p>
             *
             *  @param {Object} node The result of the xhr call.
             */
            replaceLayout: function replaceLayout(key, node) {
                var dc = this.dataCache;

                // Is there a cache for this layout?
                if (dc && dc[key]) {
                    // Clear the dataCache for the current layout since we are replacing current layout.
                    dc[key] = {};
                }

                // Find the index of the current layout.  Based on the request
                var lyts = (this.data && this.data.layouts) || (this.defn && this.defn.layouts);
                for (var i = (lyts && lyts.length - 1) || 0; i >= 0; i--) {
                    if (lyts[i].k === key) {
                        break;
                    }
                }

                // Update bean state.
                this.bs = node.bs;

                // Update zoom factor
                this.zf = node.zf;

                // Update the layout data.
                if (node.data) {
                    this.data.layouts[i] = node.data.layouts[i];
                    //TQMS 507388.
                    this.data.elems = node.data.elems;
                }

                // Update the layout definition.
                if (node.defn) {
                    this.defn.layouts[i] = node.defn.layouts[i];

                    // Update the defn layoutMap to include the new defn.
                    this.ondefnChange();
                }

            },

            /**
             * Accepts new layout JSON, replaces the current layout and raises the 'rebuildLayout' event.
             *
             * @param {Object} layoutJSON The JSON for the new layout.
             * @param {Boolean} [unloadCache=false] Flag to denote whether we want to unload the client cache.
             */
            loadLayout: function loadLayout(layoutJSON, unloadCache, restoreIW) {
                this.replaceLayout(layoutJSON.currlaykey, layoutJSON);

                this.raiseEvent({
                    name: 'rebuildLayout',
                    unloadCache: !!unloadCache, //TQMS#770920, force layouts to be reloaded when UConDS
                    restoreIW: !!restoreIW // #999259. restore info window after rebuild current layout.
                });
            },

            /**
             * Gets the update string from the widgets which have content changed. (transaction code)
             * For discard action, we won't include any update changes.
             * @returns String XML string for changes
             */
            getTransactionUpdates: function getTransactionUpdates(t) {
                return this.txDiscardTargets ? '' : getTxUpdates.call(this, t);
            },

            /**
             * Clears the delta map to remove the changes. (transaction code)
             */
            clearTransactionUpdates: function clearTransactionUpdates(t) {
                this.clearTxDeltaUpdate(t);
            },

            /**
             * Move all the pending update objects back into delta object for a given request
             */
            resetTransactionUpdates: function resetTransactionUpdates(t) {
            	var pu = this.pendingUpdate,
            		d = this.delta;

            	// if the pending update for the request exists, move all the elements into delta
            	if(pu && pu[t]) {
            		// move all pending update widget into delta if not exist
            		$HFE(pu[t], function(v, i) {
            			if(d && !d[i]) {
            				d[i] = v;
            			}
            		});
            		// remove the pending update objects
            		delete pu[t];
            	}
            },

            getDataService: function getDataService() {
                var dataService = this.dataService,
                    me = this;
                if (!dataService) {
                    var params = {
                        rwb: this.bs,
                        msgId: this.mid,
                        model: this
                    };

                    if (mstrApp.modelFactory) {
                        dataService = mstrApp.modelFactory.newDataService('Document', params);
                    } else {
                        dataService = mstrApp.viewFactory.newDocDataService(params);
                    }

                    this.dataService = dataService;
                    this.disposables.push(dataService);
                }
                return dataService;
            },

            partialUpdate: function partialUpdate(data, targetDefinitions) {
                // Update the "dataCache" with a hash of all the partial update nodes which are either targets or descendants of targets.
                var updatedDataCache = this.updateDataCache(data, targetDefinitions);

                // Raise the 'partialUpdate' event so the document widgets will update themselves.
                this.raiseEvent({
                    name: 'partialUpdate',
                    tree: data,                 // Partial update tree.
                    ids: updatedDataCache
               });

                return updatedDataCache;
            },

            /**
             * Partial updates from the Xhr's response. The function gets the keys from the response object, and updates the data cache.
             * @param {Object} res The xhr's response object
             * @returns {Object} An object with information about widgets that need to be updated.
             */
            transactionUpdate: function(res, evt){
                //If no data, do not run partial update
                if (!res.data){
                    return;
                }

                var me = this,
                    tgtDefs;

                // With new partial update mechanism
                if (evt && evt.tks) {
                    tgtDefs = fnGetTargetDefn.call(this, evt.tks);
                }
                // If the response has the partial update keys, overwrite the tgtDefs
                if(res.pukeys) {
                    tgtDefs = fnGetTargetDefn.call(this, res.pukeys);

                    // TQMS 449351: clear "cek" properties for selectors
                    var tgt;
                    for (tgt in tgtDefs) {
                        if (tgtDefs[tgt] && tgtDefs[tgt].cek) {
                            tgtDefs[tgt].cek = null;
                        }
                    }
                }

                //save transaction record info if the data comes from offline cache
                if(res.txrcd) {
                    this.txrcd = res.txrcd;
                } else {
                    //else clear the txrcd from doc model
                    delete this.txrcd;
                }

                // Update this DocModel's "dataCache" with a hash of all the
                // partial update nodes which are either targets or descendants of targets.  Return
                // is a hash of id's that were updated.
                var ids = this.updateDataCache(res.data, tgtDefs, evt && evt.sid),
                    ue = {
                            name: 'partialUpdate',
                            tree: res.data,   // Partial update tree.
                            ids: ids
                        };

                //if has info window, pass on the position.
                if(!mstrmojo.hash.isEmpty(ids.ifws)){
                    if (evt && evt.type === $RWTYPES.GRID) {
                        ue.anchor = evt.anchor;
                    } else {
                        //Info windows should only be targetted by grids and no other objects.
                        ids.ifws = {};
                    }
                }

                // Raise the 'partialUpdate' event so the doc widgets will hear it.
                this.raiseEvent(ue);

                return ids;
            },

            deltaUpdate: function dltUdt(w) {
                var d = this.delta;
                if(!d) {
                    d = this.delta = {};
                }
                d[w.id] = w;
            },

            /**
             * Clear the transaction udpates. If it is in a discard action (txDiscardTargets is not null), move the widget ids that are not in the discard targets into delta.
             * @param {String} t Request identifier.
             */
            clearTxDeltaUpdate: function clrDltUdt(t) {
                var widgetsToClearTx = this.txDiscardTargets,
                    clearAll = !widgetsToClearTx, // Not specified means clear all
                    pu = this.pendingUpdate,
                    me = this,
                    id;

                // if there are widgets contains changes need to be discarded
                if(!clearAll) {
                    // if discard button is clicked, loop through the discard button target widget id
                    $HFE(widgetsToClearTx, function(v, id) {
                        if(me.delta && me.delta[id]) {
                            me.delta[id].clear();
                            delete me.delta[id];
                        }
                    });
                }

                // if there is a pending update, that must means this request is not from discard (discard will not call getTxUpdate)
                if(pu && pu[t]) {
                    // otherwise, it means we need to clear all
                    $HFE(pu[t], function(w) {
                        w.clear();
                    });
                	delete this.pendingUpdate[t];
                }

            },

            /**
             * Sends transaction update to the web server
             * @param {String} ck Action selector control key
             * @param {Integer} at The action type
             * @param {Object} callbacks The callbacks functions that are defined to invoke when the transaction is invoked
             */
            sendTransactionActions: function sendTransactionActions(ck, at, callbacks) {

                var me = this, params;
                if(!callbacks) {
                    callbacks = {
                        success: function(res){
                            //partial update
                            me.transactionUpdate(res);
                        }
                    };
                }

                me.getDataService().sendTransactionActions({
                    keyContext: ck,
                    actions: at,
                    txrcd: this.txrcd
                }, callbacks);
            },

            /**
	     * this.sdp is a map of secondary data providers. The key is secondary data provider key and the value for each
	     * entry of sdp[key1] is an object of the following form
	     * sdp["W53"]  = { k: "W54", visName : stylename}
	     *   k is the primary data provider key , and visName is the visualization style name of the primary data provider
	     *   using which the transform will generate the grid data for this secondary data provider during slicing
	     *
	     * @param {Object} sdpKey
	     * @param {Object} primaryWidgetInfo
	     *
	     */
	     addSDP: function addSDP(sdpKey, primaryWidgetInfo) {
		    if (!sdpKey || !primaryWidgetInfo) {
			return;
		    }
		    if(!this.sdp){
			this.sdp = {};
		    }
		    this.sdp[sdpKey] = {k: primaryWidgetInfo.k,visName:primaryWidgetInfo.visName};

	     },

	    /**
	     * <p>Removes a given object from the secondary data provider observers list.</p>
	     *
	     * @param {Object} key The secondary data provider key
	     * @param {Object} obj The object to be removed from the lookup.
	     *
	     */
            removeSDP: function removeSDP(sdpKey) {
		    if (!sdpKey || !this.sdp[sdpKey]) {
			return;
		    }

		    //remove the listener for this secondary data provider
		    delete this.sdp[sdpKey];

            },

            /**
            * Performs a slice operation or panel stack selector change.
            *
            * @param {mstrmojo.Event} evt The event object.
            * @param {Integer} evt.type The type of selector operation (1 = attribute element, 2 = metric and 3 = panel).
            * @param {String} evt.src The Key of the src selector.
            * @param {String} evt.ck The Control Key Context.
            * @param {String} evt.tks The Target Keys.
            * @param {String} evt.eid The Group by element ID.
            * @param {Boolean} evt.suppressIW Suppress the info window update
            */
            slice: function slice(evt) {
                try {
                    // if no slicing target, return.
                    // TQMS#504779, andriod clients don't need tks while web needs.
                    if (!evt || (!mstrmojo.dom.isAndroid && !evt.tks && !evt.multiSelect && (evt.type === 3 || (evt.type === $RWTYPES.GRAPH && evt.tty != 1)))) {
                        return;
                    }

                    var dataCacheUpdate = null,
                        me = this,
                        dataService = this.getDataService(),

                        // The collection of target definitions for this slice.
                        tgtDefs = evt.tks ? fnGetTargetDefn.call(this, evt.tks) : null,

                        // Copy of original target definitions.
                        orignalTargetDefs = tgtDefs,

                        // Utility function for setting readyState.
                        fnSetReadyState = function (v) {
                            // Iterate previous ready state definitions (if present) or the event target definitions.
                            $HFE(orignalTargetDefs, function (targetDef, key) {
                                // Is there a target definition and is it observable?
                                if (targetDef && targetDef.set) {
                                    // Set the ready state.
                                    targetDef.set('readyState', v);
                                }
                            });
                        },

                        // Utility function for retrieving widgets from registry.
                        fnGetWidget = function (k, wid) {
                            return mstrmojo.all[fnBuildId.call(me, {
                                k: k,
                                wid: wid
                            }, me.currlaykey)];
                        },

                        // Default slice request callback.
                        callback = this.newCallback({
                            method: 'slice',

                            submission: function () {
                                // Set ready state to WAITING on target widget definitions.
                                fnSetReadyState($RS.WAITING);
                            },

                            success: function (res) {

                                if (evt.disablePU) {
                                    me.loadLayout(res, evt.isUConDS, evt.restoreIW); //TQMS#770920, force layouts to be reloaded when UConDS
                                    //me.raiseEvent({name:'rebuildLayout'});
                                    return;
                                }
                                // With new partial update mechanism
                                if (res.pukeys) {
                                    tgtDefs = fnGetTargetDefn.call(me, res.pukeys);
                                }
                                unloadAffectedLayouts(me, res);

                                // Update this DocModel's "dataCache" with a hash of all the partial update nodes which are either targets or descendants of targets.
                                // Returned is an object with information about widgets that need to be updated as a result of this operation.
                                dataCacheUpdate = me.updateDataCache(res.data, tgtDefs,evt && evt.sid);
                                if (typeof(res) == 'object') {
                                    // Update bean state and export options (if found in response).
                                    mstrmojo.hash.copyProps(['bs', 'exopt', 'dty'], res, me);
                                }

                                var ue = {
                                        name: 'partialUpdate',
                                        tree: res.data,   // Partial update tree.
                                        ids: dataCacheUpdate
                                 };

                                 //if has info window, pass on the position.
                                if(!mstrmojo.hash.isEmpty(ue.ids.ifws)){
                                    if (evt && !evt.suppressIW && (evt.type === $RWTYPES.GRID || evt.type === $RWTYPES.GRAPH)) { // #4982622 add support for Graph
                                        ue.anchor = evt.anchor;
                                    } else {
                                        //TQMS 774448 if suppressIW is true, clear the ifws object for partial update
                                        //Info windows should only be targetted by grids and no other objects.
                                        ue.ids.ifws = {};
                                    }
                                }

                                // Raise the 'partialUpdate' event so the doc widgets will hear it.
                                me.raiseEvent(ue);
                            },

                            complete: function () {
                                // Set ready state back to IDLE target widget definitions.
                                fnSetReadyState($RS.IDLE);
                            }
                        });

                    // Was the selector action from a panel selector?
                    if (evt.type == 3) {
                        // Get the panel stack key and panel key (element ID).
                        var panelStackKey = evt.tks,
                            panelKey = evt.eid;

                        // Do we NOT have a panel stack key?
                        if (!panelStackKey) {
                            // Something failed, so skip it.
                            return;
                        }


                        // Do we NOT have a panel definition?
                        var pnlDef = lookupDefn(this.defn, this.currlaykey, panelKey);
                        if (!pnlDef) {
                            // This must be an on demand panel stack, so don't do anything.
                            return;
                        }

                        // Default dirty key is the panel key.
                        var dirtyKeys = panelKey,

                            panelStackDefn = tgtDefs[panelStackKey],

                            // Utility to change active panel to new panel.
                            fnActivatePanel = function () {
                                panelStackDefn.set('selKey', panelKey);
                            },

                            // State based success handler.
                            fnPanelState;

                        // TQMS 428697, 711959, 718665.
                        panelStackDefn.newSelKey = panelKey;

                        // Is the panel already loaded?
                        if (pnlDef.l) {

                            // Retrieve the collection of dirty children keys from the panel?
                            var dk = pnlDef.dirtyKeys;

                            // Were any dirty children found?  If so then the panel is already loaded, but has child widgets that are dirty so we
                            // need to request those widgets from the server.
                            if (!!dk) {

                                // Assemble dirty widget keys collection.
                                dirtyKeys = mstrmojo.hash.keyarray(dk).join(',');

                                // Reset the target definitions collection to the dirty children.
                                orignalTargetDefs = tgtDefs = fnGetTargetDefn.call(this, dirtyKeys, ',');

                                // Create the request success handler specific to dirty panels.
                                fnPanelState = function () {
                                    // Activate panel.
                                    fnActivatePanel();

                                    // Iterate updated widget keys and clear dirty status.
                                    $HFE(dataCacheUpdate.upd, function (v, updatedId) {
                                        // Try to get a widget for this definition.
                                        var updatedWidget = mstrmojo.all[updatedId];

                                        // If we find a widget then set its dirty flag to false.
                                        if (updatedWidget && updatedWidget.setDirty) {
                                            updatedWidget.setDirty(false);
                                        }
                                    });
                                };

                            } else {
                                // Panel is loaded and has no dirty children so all we need to do is silently update server with the newly visible panel key.
                                dataService.setCurrentPanel(panelKey, evt.tks, evt.ck, this.newCallback({
                                    method: 'slice',
                                    success: fnActivatePanel
                                }));
                                return;
                            }

                        } else {
                            // Create the request success handler specific to newly requested panels.
                            fnPanelState = function () {
                                    // Set the currently selected key.
                                fnActivatePanel();

                                    // Mark the definition as loaded.
                                    pnlDef.l = true;
                            };
                                }

                        // Add extra "success" processing for Panel slicing operations.
                        var fnSuccess = callback.success;
                        callback.success = function (res) {

                                // Get the new units from the xhr definition node.
                            var lyt = getLayout(res.defn, me.currlaykey),
                                oldLyt = getLayout(me.defn, me.currlaykey),
                                fnAppendNewProps = function (oldObj, newObj) {
                                        for (var u in newObj) {
                                            // Insert the new definition into the old collection if it's not there already.  We don't want to override any definitions because
                                            // they may be currently observed or contain cached information that we don't want to lose.
                                            if (oldObj[u] === undefined) {
                                                oldObj[u] = newObj[u];
                                            }
                                        }
                                    },
                                    newUnits = lyt && lyt.units,
                                    oldUnits = oldLyt && oldLyt.units,
                                    newCGBMap = lyt && lyt.cgbMap,
                                    oldCGBMap = oldLyt && oldLyt.cgbMap;

                                // If we have new units we need to insert them into the existing definition units.
                                if (newUnits) {
                                fnAppendNewProps(oldUnits, newUnits);
                                }

                                //If we have new objects in the CGBMap, insert them into the existing definition map
                                if (newCGBMap) {
                                    fnAppendNewProps(oldCGBMap, newCGBMap);

                                    //Raise an event to all the listeners who want to know if the Control Group By Map has changed (Selectors, Grid/Graph as selector)
                                    me.raiseEvent({
                                        name: 'CGBMapChange',
                                        cgbMap: oldCGBMap
                                    });
                                }

                            // Call the default slice success function.
                            fnSuccess(res);

                            // Call the panel state success function.
                            fnPanelState();

                            // Notify the panel stack that the current panel isn't dirty.
                            var panelStack = fnGetWidget(evt.tks, 0);
                            if (panelStack) {
                                panelStack.clearDirtyChild(panelKey);
                            }
                        };

                        // Either the panel isn't loaded or it's got dirty children so make request for the panel.
                        dataService.requestNewPanel(panelKey, evt.tks, evt.ck, dirtyKeys, !evt.hasLoader, callback);

                    } else {

                        // Wrap default slice success handler with custom handler for non-panel operations.
                        callback = $WRAP(callback, {
                            success: function (res) {

                                // Iterate target definition keys.
                                $HFE(orignalTargetDefs, function (def, targetKey) {
                                    // Get the widget (default to slice id 1 because dirty state is stored in definition).
                                    var targetWidget = fnGetWidget(targetKey, 1);

                                    // Is there no widget for this definition?
                                    if (!targetWidget) {

                                          //if the targetKey is a secondary data provider, the reason fnGetWidget cannot find is, the id of
					  //secondary data provider widget is not generated by fnBuildId

					  //check if this targetKey is a secondary data provider and notify its observers
					  //usually its observers are the widgets which are primary data providers

					  if (!!me.sdp && !!me.sdp[targetKey]) {
						var sdpData = me.getLayoutDataCache(me.getCurrentLayoutKey());
						var sdpId = fnBuildId.call(me, {k: targetKey, wid: 1}, me.currlaykey);
						me.raiseEvent({name: 'secondaryDataSliced',key:targetKey,data:sdpData[sdpId].data});
					  }

                                        // Skip.
                                        return;
                                    }

                                    // Was the definition for this widget not updated?
                                    if (dataCacheUpdate && !(targetKey in dataCacheUpdate.def)) {

                                        // Notify the widget that it's dirty.
                                        if(targetWidget.setDirty) {
                                    	    targetWidget.setDirty(true);
                                        }

                                    // Target widget was updated, but is this a panel stack?
                                    } else if (def.t == $RWTYPES.PANELSTACK) {

                                        // Tell the widget that it's hidden panels are dirty.
                                        targetWidget.setDirtyChildren();
                                    }
                                });
                            }
                        });

                        var args, methodName;

                        // Is the source of this slice a graph?
                        if (evt.type == $RWTYPES.GRAPH) {
                            // Apply graph selector.
                            methodName = 'applyGraphSelectorAction';
                            args = [ evt.ck, evt.cks, evt.sid, evt.x, evt.y, callback, me.zf];
                        } else {

                            // Apply normal selector.
                            // Create the task parameters to slice the targets.
                        if(evt.isMultipleEvents){
                            methodName = 'RWEventsTask';
                            params = {
                                    messageID: this.mid,
                                    styleName: 'RWDocumentMojoStyle',
                                    events: evt.events
                            };
                            args = [params, callback];
                        } else if ('eid' in evt) { //element id is only used for setDocSelectorElements task
                                methodName = evt.isDocVis ? 'setDocVisSelectorElements' : 'setDocSelectorElements';
                                args = [ evt.ck, evt.eid, evt.ctlKey, evt.include, callback , me.zf];
                                
                                var hasAllInGB = hasAllSelectedInGB.call(this);
                                if (evt.isUConDS || hasAllInGB) {
                                	evt.disablePU = true;
                                    args = args.concat([null, 0, null, true]);
                                }
                                
                                if (hasAllInGB) {
                                    evt.restoreIW = true;
                                }

                				 //check if the this.sdp is not empty and then send all the sdpkeys
                				 //along with the visName's for the transform to use the style name to render the data

                				 if (me.sdp) {
                					var sdpreqKeys = {};
                					$HFE(me.sdp, function(obj, key){
                						if (me.sdp[key]) {
                							sdpreqKeys[key] = obj.visName;
                						}

                					});

                					args[7] = JSON.stringify(sdpreqKeys);

                				 }
                                 args[8] = evt.tks;
                            } else if (evt.multiSelect) {
                                if (evt.selectorObjects.length > 0) {
                                    methodName = 'setMultiDocSelectorElements';
                                    args = [evt.selectorObjects, evt.multiSelect, callback, me.zf];
                                }
                            } else {
                                // #609070. if MC selector is 'unset', we'll send 'setDocSelectorExpressionUnset' task
                                // instead of 'setDocUnsetSelector'
                                if ('srct' in evt && evt.srct == 4) {//metric condition selector
                                    if (evt.onlyInclude){
                                        methodName = 'setDocSelectorInclude';
                                        args = [ evt.ckey, evt.include, callback, evt.srcid, evt.srct, me.zf];

                                    } else {
                                        methodName = 'setDocSelectorExpression';
                                        args = [ evt.ck, evt.ckey, evt.srcid, evt.srct, evt.f, evt.ft, evt.include, evt.cs, 5, callback, me.zf];

                                        if (!evt.cs) {
                                            args[7] = null;
                                            args[8] = null;

                                            if (evt.changeQual) {
                                                //Set the RWUnit properties
                                                dataService.setRWUnitProperties(evt.ckey, evt.ckey + '\u001F' + 'FormattingSelector' + '\u001F' + 'MetricConditionType' + '\u001F' +evt.qt, 1, false, null);

                                                args.push(evt.unset);
                                            }
                                        }

                                    }
                                } else if (evt.unset) {
                                    methodName = 'setDocUnsetSelector';
                                    args = [ evt.ck, evt.ckey, callback, me.zf];

                                } else {
                                    methodName = 'setDocSelectorInclude';
                                    args = [ evt.ckey, evt.include, callback, null, null, me.zf ];

                                }
                            }
                        }

                        if (methodName) {
                            dataService[methodName].apply(dataService, args);
                        }
                    }

                } catch (ex) {
                    mstrmojo.err(ex);
                }
            },

            /**
             * Returns the data cache for the indicated layout node.
             *
             * @param {String} key The key of the requested layout data cache.
             *
             * @type Object
             */
            getLayoutDataCache: function getLayoutDataCache(key) {
                // Did we NOT get a valid key?
                if (!key) {
                    return null;
                }

                var dc = this.dataCache;
                // Is there no dataCache container?
                if (!dc) {
                    // Initialize it.
                    dc = this.dataCache = {};
                }

                // Is there no dataCache for the current layout?
                if (!dc[key]) {
                    // Initialize it.
                    dc[key] = {};
                }

                return dc[key];
            },

            /**
             * Update this DocModel's dataCache after a slice/drill update action with a flat lookup of
             * nodes in the result tree which are either targets or descendants of targets.
             *
             * @param {Object} tree The partial update tree.
             * @param {Object[]} tks The collection of update target definition nodes.
             *
             * @returns {Object} An object with information about widgets that need to be updated as a result
             *      of this operation.
             */
            updateDataCache: function updDC(tree, tks, sid) {

                var me = this,
                    dc = this.getLayoutDataCache(this.getCurrentLayoutKey()),
                    _result = {
                        ifws: {},    // Collection of panel stack IDs who shall be rendered as Info Window.
                        upd: {},    // Collection of widget IDs whose data needs to be updated (via update method).
                        tgts: {},   // Collection of widget IDs that where actually targeted in this operation (need to be refreshed).
                        def: {},    // Collection of widget IDs whose definitions may have been updated (so they are no longer dirty).
                        secs: {}    // Collection of Subsection widget IDs that contain targeted widgets as direct children (for updating CanGrow/CanShrink).
                    };

                /**
                 * <p>Utility search function to find data nodes in a tree that are either targets or descendants of targets</p>
                 *
                 * <p>The search results are stored in this DocModel's "dataCache" property as a hashtable, keyed by node id.</p>
                 *
                 * @param {Object} node The node whose descendants should be iterated.
                 * @param {Boolean} wasInst Whether the parent of the passed in node has been instantiated.
                 * @param {String} [activeKey] The key of the current target.
                 *
                 * @inner
                 */
                function findTgtDescendants(node, wasInst, activeKey) {

                    var isInst = false,   // Flag to indicate that the current node has been instantiated (assume false).
                        chnodes = me.getChildren(node, true), // Fetch the children of the current node.
                        w;              // Holds a reference to the instantiated parent widget.

                    // Do we have children?
                    if (!chnodes.length) {
                        // No children, so nothing to do.
                        return;
                    }

                    // Was the parent of this node instantiated?
                    if (wasInst) {
                        // Try to get the current instance of the widget for this node.
                        w = mstrmojo.all[node.id];

                        // Set the instantiation flag based on the existence of a widget for this node in the registry.  If
                        // we don't have an id that means it's the root layout node so assume it's instantiated already.
                        isInst = !node.id || !!w;
                    }

                    var nodeDefn = node.defn,
                        nodeData = node.data,
                        selectedPanelKey;

                    // Is the current node an on demand panel stack?
                    if (nodeDefn && nodeDefn.t === $RWTYPES.PANELSTACK && nodeDefn.od) {
                        // Cache the selected panel key.
                        selectedPanelKey = nodeData.selKey;
                    }

                    // Iterate through the children of this node...
                    for (var cnt in chnodes) {
                        var ch = chnodes[cnt],
                            childKey = ch.k,
                            id = ch.id,
                            localActiveKey = null;

                        //Check if the child has been instantiated? Then set the is instantiated flag.
                        if (mstrmojo.all[id]) {
                            isInst = true;
                        }

                        // Are we at a target now?
                        if (childKey in tks) {

                            if (isInfoWindowPS.call(me, childKey) && isCurrentSlice(ch.data, sid)) {
                                // Add the new data node to the data cache.
                                dc[id] = ch;

                                // TQMS #497832: Is there no active key meaning this is the upper most target (root info window)?
                                if (!activeKey) {
                                    // Add child key to info window collection.
                                    _result.ifws[childKey] = me.infoWinByKey[childKey].id; // #763190
                                }
                            }

                            // Update the active key.
                            localActiveKey = childKey;

                            // Was the parent instantiated?
                            if (isInst) {
                                // The web server transform has an apparently unfixable bug in that it sends down malformed data nodes for unselected panels of targeted panel stacks.
                                // Since they can't fix their bug, we have to introduce a hack to avoid refreshing unselected panel stacks.
                                if (selectedPanelKey && selectedPanelKey !== childKey) {
                                    // Skip this invisible panel of a target panel stack.
                                    continue;
                                }

                                // Add the id to the result so that we know which widgets to refresh.
                                if (!activeKey) {
                                _result.tgts[id] = true;
                                }

                                var secDef = w && w.defn,
                                    ty = secDef && secDef.t,
                                    ck = secDef && secDef.ck;

                                // Is the parent an instantiated Subsection and will this child possibly change it's dimensions?
                                if (ty === $RWTYPES.SUBSECTION && (ck && (childKey in ck))) {
                                    // Add the subsection id so that we know which subsection need to perform CanGrow/CanShink.
                                    _result.secs[w.id] = true;
                                }
                            }
                        }

                        // Are we at or below a target AND are we not within a panel stack OR is this the selected panel?
                        if ((activeKey || localActiveKey) && (!selectedPanelKey || selectedPanelKey === childKey)) {
                            // Add the new data node to the data cache.
                            dc[id] = ch;

                            // Add the key to the result so we know which widget definitions dirty status has changed.
                            _result.def[childKey] = true;

                            // Is the parent instantiated?
                            if (isInst) {
                                // Add the id to the result so that we know which widgets to update.
                                _result.upd[id] = true;
                            }
                        }

                        // Recursively walk the children of this node.
                        findTgtDescendants(ch, isInst, activeKey || localActiveKey);
                    }
                }

                // Kick off the search at the top of our result tree (if any).
                if (tree && tree.layouts && tks) {
                    // Find the tree for the current layout and build it.
                    findTgtDescendants(mstrmojo.array.filter(tree.layouts, function (l) {
                            return (l.loaded);
                        }, {
                            max: 1
                        })[0], true);
                }

                return _result;
            },
            /**
             * This method should return the control group bys - target keys map.
             */
            getCGBMap: function getCGBMap(){
                var lyt = getLayout(this.defn, this.currlaykey);

                return lyt && lyt.cgbMap;
            },

            executeLink: function executeLink(url, target, src) {
                // Enhancement for Synch selections between documents feature,
                // here we need to get out the "prevMsgID=0" from url, replace with current message id.
                // We have a special case that message ID begins with '0', i.e. prevMsgID=0XXXX
                if (url.indexOf('prevMsgID') > 0) {
                    var replacement = 'prevMsgID=' + this.mid;
                    url = url.replace(/prevMsgID=0($|&)/g, function (match, cap) {
                        if (cap == '&') {
                            return replacement += '&';
                        } else {
                            return replacement;
                        }
                    });
                    //TQMS 762368 - Add cache busting to prevent IE from aggressively caching window.open(url)
                    if (mstrmojo.dom.isIE) {
                        url += '&cb' + mstrmojo.now() + '=1';
                    }
                }

                url = mstrmojo.addCSRFTokenToURL(url);

                this.controller.onLink(
                        this,
                        {
                            url: url,
                            target: target,
                            src: src || null
                        }
                 );
            },

            showInfoWin: function showInfoWin(key, anchor, orientation, invalidate, anchorPosition) {
                var ifwunit = this.infoWinByKey && this.infoWinByKey[key];
                if (ifwunit === undefined) { // #738153  if there is no info window don't try to show anything
                    return;
                }
                this.raiseEvent({
                    name: 'showInfoWin',
                    psId: ifwunit.id,
                    psKey: ifwunit.k,
                    anchor: anchor,
                    anchorOrientation: orientation,
                    anchorPosition: anchorPosition,
                    invalidate: invalidate
                });
            },

            /**
             * Request new incremental fetch grid data from the server.
             *
             * @refactoring This method assumes the data will be in the first layout (tree.layouts[0]) which may not be correct now that we have multi-layout documents.  Also, it
             *         would make the interface much cleaner if we passed in nodeKey, rowPosition, maxRows, colPosition and maxCols as a single parameterized object.  The only place
             *         they are used in this method is to create a parameterized object for the xhr.
             */
            downloadGridData: function downloadGridData(params) {
                var me = this,
                    widgetID = params.xtabId,
                    memo = params.memo,
                    w = mstrmojo.all[widgetID],
                    dataService = this.getDataService();

                var callback = this.newCallback({
                        success: function (res) {
                            // function to recursively search for our widget node.
                            function findWidgetData(/*Object*/ node, /* String */ wID) {
                                // Fetch the given node's immediate children.
                                var chnodes = me.getChildren(node, true);

                                // For each child...
                                for (var cnt in chnodes) {
                                    var ch = chnodes[cnt];
                                    if(wID == ch.id) {
                                        return ch;
                                    }

                                    // Recursively walk the children of this node.
                                    var w = findWidgetData(ch, wID);
                                    // If we found one, end the searching; otherwise, loop to the next child
                                    if(w) {
                                        return w;
                                    }
                                }
                                return null;
                            }

                            // new tree.
                            var tree = res.data,
                                newGridData = null,
                                nodeDef, //node definition
                                lyt = tree && getLayout(tree, me.currlaykey);

                            // Kick off the search at the top of our result tree (if any).
                            if (lyt) {
                                newGridData = findWidgetData(lyt, widgetID);
                            }

                            if (newGridData && w) {
                                w.dataDownloaded(newGridData, memo);
                            }

                            if(lyt && lyt.xtabStyles) {
                                me.raiseEvent({
                                    name: 'updateStyles',
                                key: lyt.k,
                                    updatedStyles: lyt.xtabStyles
                                });
                            }

                            //update graph data if needed
                            nodeDef = lookupDefn.call(me, me.defn, me.currlaykey, params.nodeKey);
                            if(nodeDef && nodeDef.t === $RWTYPES.GRIDGRAPH && memo.recalculating) {
                                var gg = w.parent,
                                    gp = gg && gg.getGraphWidget();
                                if(gg && gp && gg.updateGraph) {
                                    gg.updateGraph(findWidgetData(lyt, gp.id));
                                }
                            }

                        },

                        failure: function() {
                            if(w.dataDownloadErr) {
                                w.dataDownloadErr();
                            }
                        }
                });

                dataService.downloadGridData(params, callback);
            },

            /**
             * Saves property changes to the web server.
             *
             * @param {String} the key for the node whose properties is saving.
             * @param {Object} props An key/value object where the key is the RWUnit key and the value is another object with property name/value pairs.
             * @param {Integer} [type=1] The type of formatting operation (1: Main; 2: Title).
             * @param {Boolean} loadData Whether saving should bring data back. When this param is false, this save process will just be one way action.
             * @param (Object) callback An key/value object where the call back functions are defined to be invoked when saveRWProperties task finishes.
             */
            saveRWProps: function saveRWProps(nodeKey, props, type, loadData, callback) {
                var data = [],
                    d = '\u001F';

                // Iterate keys...
                $HFE(props, function (o, key) {
                    // Iterate properties for eaach key...
                    $HFE(o, function (v, p) {
                        // Add item separated string to data.
                        data.push(key + d + p + d + v);
                    });
                });

                // Do we have NO data?
                if (!data.length) {
                    // Nothing to do.
                    return;
                }

                // Do we expect data to be returned?
                    if (loadData) {
                    // Get definition of node being saved.
                    var g = lookupDefn.call(this, this.defn, this.currlaykey, nodeKey),
                        fnReadyState = function (rs) {
                            g.set('readyState', rs);
                        };

                    // Wrap callback methods to change definition readyState to...
                    callback = $WRAP(callback, {
                        submission: function () {
                            // waiting...
                            fnReadyState($RS.WAITING);
                        },

                        complete: function () {
                            // idle...
                            fnReadyState($RS.IDLE);
                        }
                    });
                }

                // Use data provider to save property values.
                this.getDataService().setRWUnitProperties(nodeKey, data.join('\u001E'), type || 1, loadData, callback);
            },

            loadPartialData: function loadPartialData(data, nodeKey){
                // find the target that is being sorted upon
                var tgtDef =  {};
                tgtDef[nodeKey] = lookupDefn.call(this, this.defn, this.currlaykey, nodeKey);


                // Update this DocModel's "dataCache" with a hash of all the
                // partial update nodes which are either targets or descendants of targets.
                var ids = this.updateDataCache(data, tgtDef),
                    dc = this.getLayoutDataCache(this.getCurrentLayoutKey()),
                    me =  this;

                // Iterate layouts.
                mstrmojo.array.forEach(data.layouts, function (l) {
                    if(l && l.xtabStyles) {
                        me.raiseEvent({
                            name: 'updateStyles',
                            key: l.k,
                            updatedStyles: l.xtabStyles
                        });
                    }
                });

                // update the components
                $HFE(ids, function (col, meth) {
                    if (meth === 'upd') {
                        $HFE(col, function (v, id) {
                            // Get the widget.
                            var w = mstrmojo.all[id];
                            // Does the widget have this method?
                            if (w && w.update) {
                                w.update(dc[id]);
                            }
                        });
                    }
                });
            },

            /**
             * <p>Adds the id for units with 'Fit to Content' width mode to the internal auto width mode collection for the current layout.</p>
             *
             * <p>IDs should only be added after they are rendered</p>
             *
             * @param {String} id The id of the the
             */
            addAutoWidthID: function addAutoWidthID (id) {
                var aws = this.aws || {},
                    units = aws[this.currlaykey] || [];

                // Push the new id into the collection for this layout.
                units.push(id);

                // Set the collection back onto the auto width collection.
                aws[this.currlaykey] = units;

                // Set the auto width collection back onto the model.
                this.aws = aws;
            },

            /**
             * <p>Returns an array of IDs for rendered widgets in the current layout that have a 'Fit to Content' width mode.</p>
             *
             * <p>The IDs are removed from the collection after they are returned.</p>
             *
             *  @returns String[]
             */
            getAutoWidthIDs: function getAutoWidthIDs() {
                var aws = this.aws,
                    l = this.currlaykey;

                // Do we have a collection of id's for this layout?
                var ids = aws && aws[l];
                if (ids) {
                    // Delete the collection so it's not used later.
                    delete aws[l];
                }

                return ids;
            }
        }
    );
})();

/**
 * Widget for slider on mobile device
 * only horizontal now, need to think
 */
(function () {
    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo.css",
                         "mstrmojo.dom",
                         "mstrmojo.num",
                         "mstrmojo._TouchGestures");

    var $D = mstrmojo.dom,
        $CSS = mstrmojo.css,
        $MIN = Math.min,
        $MAX = Math.max,
        $RND = Math.round,
        $NUM = mstrmojo.num,
        $CD = $NUM.countOfDecimals;

    /**
     *          _________________________________________________________________________
     *          |                         ______                                        |
     *          |   _____________________|__  __|____________________________________   |
     *          |  |                     | |  | |                                    |  |
     *          |  |                     | |  | |                                    |  |
     *          |  |                     | |  | |                                    |  |
     *          |  |---------------------|-|  |-|------------------------------------|  |
     *          |                        |------|                                       |
     *          |-----------------------------------------------------------------------|
     *
     * To consider the border/padding margins, we calculate the positioning of the individual parts of slider as:
     * 1. effective length used for representing the units are: the whole width of the container node - the offset width of the thumb
     * 2. the left position of thumb is current value * the unit length of each unit.
     *    So, for the first unit, the thumb's left would be at the border of the container node (covering the border/padding of the left node).
     *    For the last unit, the thumb's right would be at right border of the container node (covering the border/padding of the right node).
     * 3. the width of the left node is current value * the unit length of each unit + 1/2 of the thumb width - left/right side extra space (border/padding/margin). margin?????
     * 4. the width of hte right node is current value * the unit length of each unit + 1/2 of hte thumb width - left/right side extra space (border/padding/margin). margin?????
     */

    /**
     * Initial positioning and caching some dimensions for later use.
     * we need to cache these dimensions:
     * - thumb width (_thumbLen)
     * - left node's extra width (_lnExt)
     * - right node's extra width (_rnExt)
     */
    function initCal() {
        var cs = document.defaultView.getComputedStyle,
            ns = [this.leftNode, this.rightNode],
            ps = [ 'border-left-width', 'padding-left', 'margin-left', 'border-right-width', 'padding-right', 'margin-right' ],
            ds = [0, 0],
            i,
            j;

        // dimensions for all nodes involved in calculation. domNode, left node, right node...
        for (i = 0; i < ns.length; i++) {
            var styl = cs(ns[i]);
            for (j = 0; j < ps.length; j++) {
                ds[i] += parseInt(styl.getPropertyValue(ps[j]), 10) || 0;
            }
        }

        this._lnExt = ds[0];
        this._rnExt = ds[1];

        // calculate thumb length
        if (!this._thumbLen) {
            this._thumbLen = parseInt(this.thumbNode.offsetWidth, 10);
        }

        // the length can be used for representing units is
        // outer div's length - left/right nodes' 1) margin left/right, 2) border left/right, 3) padding left/right - thumb width
        this._length = this.domNode.clientWidth;
        this._effLen = $RND(this._length - this._thumbLen);
        this._unitLen = this._effLen / (this.max - this.min);
        ////console.log("length: " + this._length + " effLen:" + this._effLen  + "unitLen: " + this._unitLen);
    }

    /**
     * Position left node, thumb node and right node according to current slider value.
     */
    function position(v) {
        // current length = current value / max value (0-based) * effective length
        var min = this.min,
            unitLength = this._unitLen,
            thumbLength = this._thumbLen / 2,
            lLen = $RND((v - min) * unitLength);

        // left node's width = current length + 1/2 thumb width - extra space
        this.leftNode.style.width = (lLen + thumbLength - this._lnExt) + 'px';

        // right node's width = current length + 1/2 thumb width - extra space
        this.rightNode.style.width = (this._effLen - lLen + thumbLength - this._rnExt) + 'px';

        // thumb node's left = current length
        //this.thumbNode.style.left = $MAX($MIN(lLen , (this.max - min) * unitLength),0) + 'px';
        //this.thumbNode.style.webkitTransform = "translateX(" + $MAX($MIN(lLen , (this.max - min) * unitLength),0) + 'px' + ")";
        $D.translate(this.thumbNode, $MAX($MIN(lLen, (this.max - min) * unitLength), 0), 0);
    }

    /**
     * Calculates slider value based on the delta change on GUI
     */
    function calValueWDelta(v, delta) {
        var interval = this.interval;
        return $MIN($MAX(this.min, parseFloat(v, 10) + $RND(delta / this._unitLen / interval) * interval), this.max).toFixed(this._intervalDecimals); //add calling toFixed() to solve the JavaScript floating point problem
    }

    /**
     * Calculates slider value based on the position on GUI
     */
    function calValueWX(x) {
        return calValueWDelta.call(this, this.min, x - $D.position(this.domNode, true).x - this._thumbLen / 2);
    }

    function getTouchRedirectFn(methodName) {
        return function (touch) {
            return this['touchSelect' + methodName](touch);
        };
    }
    /**
     * MobileSlider class
     *
     * @class
     * @extends mstrmojo.Widget
     */
    mstrmojo.ui.MobileSlider = mstrmojo.declare(
        mstrmojo.Widget,

        [ mstrmojo._TouchGestures ],

        /**
         * @lends mstrmojo.ui.MobileSlider.prototype
         */
        {
            markupString: '<div class="mstrmojo-MobileSlider" style="visibility:hidden;">' +
                              '<div class="v"></div>' +        // left highlighted bar, inline
                              '<div class="bk"></div>' +        // right unselected bar, inline
                              '<div class="th"><div></div></div>' +        // middle thumb, absolute position
                              '<div class="min">{@minText}' + '</div>' +     // little marker for min value, inline float left
                              '<div class="max">{@maxText}</div>' + // little marker for max value, inline float right
                          '</div>',

            markupSlots: {
                leftNode: function () { return this.domNode.childNodes[0]; },
                rightNode: function () { return this.domNode.childNodes[1]; },
                thumbNode: function () { return this.domNode.childNodes[2]; },
                minNode: function () { return this.domNode.childNodes[3]; },
                maxNode: function () { return this.domNode.childNodes[4]; }
            },

            markupMethods: {
                onvalueChange: function () {
                    if (this.hasRendered) {
                        // check the current value and position the nodes
                        position.apply(this, [this.value]);
                    }

                    if (this.slidingValue !== this.value) {
                        this.set('slidingValue', this.value);
                    }
                },
                onslidingValueChange: function () {
                    if (this.hasRendered) {
                        position.apply(this, [this.slidingValue]);
                    }
                }

            },
            /**
             * Current value of the slider.
             */
            value: 0,

            /**
             * The value set by slider during sliding.
             */
            slidingValue: 0,

            /**
             * Max value of the slider
             */
            max: 10,

            /**
             * Min value of the slider
             */
            min: 0,

            /**
             * Interval between acceptable values.
             */
            interval: 1,

            /**
             * User internally to save the number of decimal digits. It is used to overcome the inaccuracy in JavaScript Math calculation.
             * For example, 6*0.05 = 3.0000000000000004. We can avoid this by calling toFixed() with the decimal digits desired. For this example,
             * calling (6*0.05).toFixed(2) = "3.00".
             */
            _intervalDecimals: 0,

            /**
             * Override
             */
            init: function init(props) {
                this._super(props);
                this._intervalDecimals = $CD(this.interval, '.'); //interval decimal is not localized
            },

            onintervalChange: function onintervalChange(n, v) {
                this._intervalDecimals = $CD(v, '.'); //interval decimal is not localized
            },

            preBuildRendering: function preBuildRendering() {
                //set localized min and max string
                this.minText = $NUM.toLocaleString(this.min);
                this.maxText = $NUM.toLocaleString(this.max);

                this._super();
            },

            /**
             * Override
             *
             * @ignore
             */
            postBuildRendering: function postBuildRendering() {
                this._super();

                // calculate the real length can be used for representation and real unit length
                initCal.call(this);

                // position the left/right/thumb correctly
                position.call(this, this.value);

                // now set it visible
                this.domNode.style.visibility = 'visible';
            },

            resize: function resize() {
                // Calculate the real length can be used for representation and real unit length.
                initCal.call(this);

                // Position the left/right/thumb correctly.
                position.call(this, this.value);
            },
            // ------------------------------ Touch support --------------------------------------------

            /**
             * <p>Cancels the touch event.</p>
             *
             * <p>If we later decide that we don't want to handle this touch we will bubble it.</p>
             *
             * @param {Object} touch The touch event as raised from {@link mstrmojo._TouchGestures}.
             *
             * @ignore
             */
            touchBegin: function touchBegin(touch) {
                touch.stop();
            },

            /**
             * Begins sliding process if thumb was pressed, otherwise, bubbles touch event to parent.
             *
             * @param {Object} touch The touch event as raised from {@link mstrmojo._TouchGestures}.
             *
             * @ignore
             */
            touchSelectBegin: function touchSelectBegin(touch) {
                // Is the target not a thumb?
                var target = touch.target;
                if (!target || target !== this.thumbNode) {
                    // Bubble the touch.
                    return this.bubbleTouchEvent(touch);
                }

                // Add active css class.
                $CSS.addClass(this.domNode, 'active');

                // Store the sliding value.
                this.slidingValue = this.value;
            },

            /**
             * Updates the 'slidingValue' during sliding.
             *
             * @param {Object} touch The touch event as raised from {@link mstrmojo._TouchGestures}.
             *
             * @ignore
             */
            touchSelectMove: function touchSelectMove(touch) {
                this.set('slidingValue', calValueWDelta.apply(this, [ this.value, touch.delta.x || 0 ]));
            },

            /**
             * Updates the 'slidingValue' && 'value' when sliding ends.
             *
             * @param {Object} touch The touch event as raised from {@link mstrmojo._TouchGestures}.
             *
             * @ignore
             */
            touchSelectEnd: function touchSelectEnd(touch) {
                // Remove active css class.
                $CSS.removeClass(this.domNode, 'active');

                this.set('slidingValue', calValueWDelta.apply(this, [this.value, touch.delta.x || 0 ]));
                this.set('value', this.slidingValue);
            },

            touchSwipeBegin: getTouchRedirectFn('Begin'),

            touchSwipeMove: getTouchRedirectFn('Move'),

            touchSwipeEnd: getTouchRedirectFn('End'),

            //----------------------------- click support ------------------------------------------------
            /**
             * Updates the 'value' when the slider got clicked on.
             * @param DomEvent evt
             * @param DomWindow hWin
             */
            onclick: function onclick(evt, hWin) {
                this.touchTap({
                    clientX: $D.getMousePosition(evt.e, hWin).x
                });
            },

            // ------------------------------ Tap support ------------------------------------------------
            /**
             * Updates the 'value' when the slider got tapped on.
             */
            touchTap: function touchTap(touch) {
                this.set('value', calValueWX.call(this, touch.clientX));
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls(
        "mstrmojo.dom",
        "mstrmojo._TouchGestures",
        "mstrmojo.TouchScroller"
    );

    var $forEachArray = mstrmojo.array.forEach,
        $forEachHash = mstrmojo.hash.forEach,
        $D = mstrmojo.dom;

    /**
     * Translates an HTML element. It in turn calls the translate method on mstrmojo.dom
     *
     * @param (Array)   node A collection of HTMLElement that needs to translated.
     * @param (Array)   c Coordinates across which the node has to be translated ([x,y,z])
     *
     */
    function translate(node, c) {
        var i;
        for (i in node) {
            $D.translate(node[i], c[0], c[1], c[2]);
        }
    }

    /**
     * Helps preventing noise on the wrong axis while scrolling.
     *
     * @param t The HTMLTouchEvent
     *
     * @return (Object) with boolean values for both x and y axes.
     */
    function preventMove(t) {
        var abs = Math.abs;
        return {
            x: (abs(t.accelDelta.x) < abs(t.accelDelta.y)),
            y: (abs(t.accelDelta.y) < abs(t.accelDelta.x))
        };
    }

    /**
     * Raises an event with the new origin positions.
     *
     * @param {mstrmojo._TouchScroll} The scroller.
     * @param {Object} position An object with 'x' and 'y' properties that indicate the current position of the scroll element.
     *
     * @private
     */
    function raiseScrolledOutEvent(scroller, e) {
        scroller.raiseEvent({
            name: 'scrolledOut',
            value: e.value,
            axis: e.axis,
            direction: e.direction
        });
    }

    /**
     * Creates an instance of type {@link mstrmojo.TouchScroller} and sets up the scroll element,
     * offsets, and the direction in which it scrolls.
     *
     * @param {HTMLElement} el The scroll Element.
     * @param offset (Object) The Boundaries beyond which the scroller cannot scroll
     * @param v (Boolean) Whether the scroller scrolls along the Y - axis
     * @param h (Boolean) Whether the scroller scrolls along the X - axis
     * @param {Number} frameRate The number of animations per second when decelerating the scroller.
     * @param {Boolean} showBar Whether the scroller should show scrollbars.
     */
    function setupScroller(el, offset, v, h, frameRate, showBar, friction, indEl) {
        var scroller = new mstrmojo.TouchScroller({
            scrollEl: el,
            vScroll: v,
            hScroll: h,
            frameRate: frameRate,
            showScrollbars: showBar,
            offset: offset,
            origin: {
                x: 0,
                y: 0
            },
            bounces: false,    //TODO: don't bounce as for lock headers it has to adjust the container.
            useTranslate3d: false, //TQMS: 720295 do not use translate 3d as android 4.2 devices have repainting problem.
            indicatorEl: indEl
        });

        //Do we have a friction value provided? Then we want to override the default friction on the TouchScroller.
        if (friction) {
            scroller.friction = friction;
        }

        return scroller;
    }

    /**
     * Takes a scroller and calls stop deceleration on it.
     *
     * @param: s Scroller element {@link mstrmojo.TouchScroller}
     */
    function stopDeceleration(scroller) {
        var i;
        //Loop through all the scrollers in the array
        for (i in scroller) {
            // Stop any deceleration.
            if (scroller[i].decelerating) {
                scroller[i].stopDeceleration();
            }
        }
    }

    /**
     * Stores whether we want to restrict the scrolling along one axis.
     *
     * @type Object of boolean
     * @default false
     */
    var PREVENT_MOVEMENT = {
        x: false,
        y: false
    };

    /**
     * Returns the current axis of movement.
     *
     * @return {String} 'x' or 'y' depending on the axis. Null if neither.
     */
    function getAxis() {
        var prevent = PREVENT_MOVEMENT;

        //Since we restrict movement only to one axes, only one of the properties will be false.
        if (!prevent.x) {
            return 'x';
        }
        if (!prevent.y) {
            return 'y';
        }
        //Although unlikely, this returns the axis as null when nothing has happened.
        return null;
    }

    /**
     * Stores a boolean whether we have swapped the container node as the scroll element.
     *
     * @type Boolean
     * @default false
     */
    var isContainerScrollElement = {
        x: false,
        y: false
    };

    /**
     * Changes the scroll element dynamically in lock header cases to account for iphone incremental
     * fetch and page by gestures.
     *
     * @param {mstrmojo._HasXtabTouchScroll} widget The Xtab Touch Scroller mixin widget.
     * @param {Object} d The object which contains the new X and Y positions.
     */
    function syncScrollEl(xtab, d) {
        //Get the current axis of movement on the widget.
        var currentAxis = getAxis(),
            scrollPast = xtab.scrollerConfig.scrollPast;

        //Do we have an axis of movement or is the Xtab not going to scrollPast?
        if (!currentAxis || !scrollPast) {
            //No Axis? Exit out. OR If the Xtab can't scrollPast, then let scrolling continue
            return !!currentAxis && !scrollPast;
        }

        function syncHelper(axis) {
            var container = xtab.viewport,
                node = xtab._TSN[axis],
                scroller = xtab._scroller[axis],
                curPosition = xtab.tPos[axis],
                newPosition = d[axis],
                isCntrScrllEl = isContainerScrollElement[axis],
                otherAxis = (axis === 'x') ? 'y' : 'x',
                otherScroller = xtab._scroller[otherAxis],
                isContainerOnOtherAxis = isContainerScrollElement[otherAxis],
                i;

            //In the event that we're done scrolling, and the other axis still has the container node and isn't
            //decelerating, we want to reset it back to the scroll nodes.
            if (!otherScroller[0].decelerating && isContainerOnOtherAxis) {
                //Special case when we have to sync the scroller on the other axis. However, we don't
                //care about the result hence we don't use the return value.
                syncHelper(otherAxis);
            }

            //Has the user scrolled out of the top or left ?
            if (curPosition <= 0 && newPosition > 0) {

                if (!isCntrScrllEl) {
                    if (isContainerOnOtherAxis) {
                        //Exit out as we cannot have two scrollers updating the same dom node. Causes flashing
                        return false;
                    }

                    //TODO: this should take into account the other axis.
                    translate(node, [0, 0, 0]);

                      //Change the scroll elements to the container node.
                    for (i in scroller) {
                        scroller[i].scrollEl = container;
                    }

                    //The scroll element is now the container
                    isContainerScrollElement[axis] = true;
                }
            } else {

                if (isCntrScrllEl) {
                    //TODO: this should take into account the other axis.
                    translate([container], [0, 0, 0]);

                    //Normal scroll, set the scroll elements back to the original scroll nodes.
                    for (i in scroller) {
                        scroller[i].scrollEl = node[i];
                    }

                    //The scroll element is no longer the container
                    isContainerScrollElement[axis] = false;
                }
            }

            //The function executed successfully. Return true.
            return true;
        }

        //Perform the sync on the current axis of movement.
        return syncHelper(currentAxis);
    }

    function handleScrollEvents(xtab, evt) {
        var axis = evt.axis,
            incRender = xtab.scrollboxHeightFixed,
            evtName = evt.name;

        if (xtab.ss) {
            //Get the row info based on the position from the zone...
            var rowInfo = xtab.zones._BR.getRowInfoByPosition(evt[axis]);

            //Add the current position to the info object.
            rowInfo.position = evt[axis];

            //Trigger the on move on the sticky sections.
            xtab.ss.onMove(rowInfo);
        }

        //Set the new position.
        //TODO: In some cases, evt.x or evt.y are objects and this tPos should NOT be assigned to that object.
        xtab.tPos[axis] = evt[axis];

        if (evtName === 'scrollDone') {
            // Hide all scrollbars.
            $forEachHash(xtab._scroller, function (scrollers) {
                $forEachArray(scrollers, function (scroller) {
                    scroller.toggleScrollBars(false);
                });
            });

            //Checks if we have to sync the scroll element in the event if we're at the limits.
            if (!syncScrollEl(xtab, evt)) {
                return true;
            }
        }

        // Is this the Y axis
        if (axis === 'y') {

            // Utility function for calling onScrolledToLastRow.
            var fnEnd = function (newPosition) {
                // Is the xtab not already downloading and is the new position at or beyond the bottom row of available data?
                if (!xtab._isDownloading && (-newPosition <= xtab._TMAX[axis])) {
                    //Do we need to do something if we have reached the bottom?
                    if (xtab.onScrolledToLastRow) {
                        xtab.onScrolledToLastRow();
                    }
                }
            };

            // Is this the scrollDone event?
            if (evtName === 'scrollDone') {
                // Clear decelerating flag.
                delete xtab._isDecelerating;

                // Do we have a cached download?
                if (xtab._cachedDownload) {
                    // Tell the xtab to render the cachedDownload.
                    xtab.dataDownloaded();
                } else {
                    // Has the user scrolled to the end of the available content?
                    fnEnd(evt.y);
                }

                //Do we support Incremental Render?
                if (incRender) {
                    // Scroll is done so tell the grid to render another "Page" in the direction of the scroll.
                    var newPosition = evt.y;

                    xtab.notifyScrollListeners({
                        x: evt.x,
                        y: Math.max(newPosition, 0)
                    });
                }

            } else if (evtName === 'scrollDecel') {
                // Store flag to indicate that we are decelerating.
                xtab._isDecelerating = true;

                // Will the position be at the end of the available content after download?
                fnEnd(evt.fY);

                //Do we support Incremental Render
                if (incRender) {
                    // Grid is about to decelerate so render the page at the final resting position.
                    xtab.notifyScrollListeners({
                        x: evt.fX,
                        y: evt.fY
                    });
                }
            } else if (evtName === 'scrollOut') {
                // Store flag to indicate that we are decelerating.
                xtab._isDecelerating = true;

                // Has the user scrolled to the end of the available content?
                fnEnd(evt.y.position);
            }
        }
    }

    function getScrollerOffsets(widget, axis) {
        var abs = Math.abs,
            offset = {};

        //create the offset object
        var axisOffset = offset[axis] = {
            start: widget._TMIN[axis],
            end: abs(widget._TMAX[axis])
        };

        //Set the scroll past property as defined by the scroller config.
        offset.scrollPast = widget.scrollerConfig.scrollPast;

        // Is this the y axis?
        if (axis === 'y') {
            //Do we want to use seamless incremental fetch? Set the incFetch flag on the scroller.
            if (widget.useSeamlessIncFetch) {
                // Add the incFetch flag to indicate whether the scroller will be performing incremental fetch in this direction.
                axisOffset.incFetch = !widget.endFetching;

                // Page Size should be scrollbox height minus four rows. If we don't have fixed row height, we'll set it to scrollbox height minus 100px (magic number)
                axisOffset.pageSize = widget.scrollboxHeight - ((parseInt(widget.gridData.rh, 10) || 25) * 4);
            }
        }

        return offset;
    }

    function createScrollers(widget) {
        // Create the helper scrollers.
        widget._scroller = {
            x: [],
            y: []
        };

        var viewportCoords = widget._viewportCoords;

        // Iterate touch nodes to create scrollers.
        $forEachHash(widget._TSN, function (nodes, axis) {
            var offset = getScrollerOffsets(widget, axis),
                isY = (axis === 'y'),
                isX = (axis === 'x'),
                len = nodes.length;

            // Iterate each node on this axis...
            $forEachArray(nodes, function (node, idx) {
                // and setup the scroller.  Note that we only show scrollbars for the last scroller on the current axis. (if the Xtab is setup to show scrollbars)
                var scroller = setupScroller(node,
                        offset,
                        isY,
                        isX,
                        widget.frameRate,
                        (idx === len - 1) && widget.scrollerConfig.showScrollbars,
                        widget.scrollerFriction,
                        widget.domNode);

                scroller.updateScrollBars(viewportCoords, widget.domNode);

                widget._scroller[axis][idx] = scroller;
            });

            // Attach an event listener to the first scroller in each axis to hear scrollDone and scrollMoved.
            // TODO: We may be able to remove scrollMoved and use scrollDecel instead.
            var zeroScroller = widget._scroller[axis][0],
                evts = [ 'scrollDone', 'scrollMoved' ];

            if (zeroScroller) {
                // Is this a "y" axis scroller?
                if (isY) {
                    // Add scrollDecel and scrollOut event listeners too.
                    evts = evts.concat([ 'scrollDecel', 'scrollOut' ]);
                }

                // Iterate complete list of events for this axis.
                $forEachArray(evts, function (evtName) {
                    // Attach event listeners.
                    zeroScroller.attachEventListener(evtName, widget.id, function (evt) {
                        // Add axis and call handler.
                        evt.axis = axis;
                        handleScrollEvents(widget, evt);
                    });
                });
            }
        });
    }

    /**
     * Whenever the Xtab's dimension changes, we need to update the offsets such that the user can scroll properly to either end.
     *
     * @param {String} dimension Whether we need to update the dimension properties along the height or width.
     */
    function updateOffsets(dimension) {
        // Has the Xtab already rendered?
        if (this.hasRendered) {
            //Update the dimensions.
            this[dimension + 'Limit'] = parseInt(this[dimension], 10);

            // Do we support scrolling (TQMS: #509604)?
            if (this.zones) {
                //Set offsets.
                var me = this; //#511245
                window.setTimeout(function () {
                    if (me.hasRendered) {
                        // Set the new offsets
                        me.setOffsets();
                        
                        // Now that the offsets are check if we need to create new scrollers.
                        me.setupScrollers();
                    }
                }, 0);
            }
        }
    }

    /**
     * <p>A mixin that enables scrolling for the widget.
     * It supports scrolling different nodes across different axes within the touchNode (defaults to domNode).
     *
     * </p>
     *
     * @implements mstrmojo._TouchGestures hence requires the widget to include the mixin.
     * @class
     * @public
     */
    mstrmojo._HasXtabTouchScroll = mstrmojo.provide(
        "mstrmojo._HasXtabTouchScroll",
        /**
         * @lends mstrmojo._HasXtabTouchScroll#
         */
        {
            /**
             * Flag to disable scroller initialization during postBuildRendering.
             *
             * @type Boolean
             * @default false
             */
            noScrolling: false,

            /**
             * Flag to identify whether we are using touch scroller for the scrolling.
             *
             * @type Boolean
             * @default true
             */
            useTouchScrolling: true,

            /**
             * <p>A configuration object that can be used to pass properties to the {@link mstrmojo.TouchScroller}.</p>
             */
            scrollerConfig: {
                showScrollbars: false,
                scrollPast: false
            },

            /**
             * Touch specific nodes. These nodes are Array objects to support multiple nodes for scrolling.
             * These nodes get assigned in setupTNs in postBuildRendering.
             * Each of them is an array of HTMLElement.
             */
            _TSN: null,

            /**
             * Stores the position of the nodes with every touch movement
             *
             * @type Object of Integer
             * @default 0
             */
            tPos: {
                x: 0,
                y: 0
            },

            /**
             * Stores the minimum limit for movement of the touch nodes along the x and y axis.
             *
             * @type Object of Integer
             * @default 0
             */
            _TMIN: {
                x: 0,
                y: 0
            },

            /**
             * Setup the touch scroll nodes depending which nodes have to scroll across the x
             * and y axis.
             * By default they get assigned to the domNode.
             */
            setupTNs: function setupTNs() {
                //Default the scroll nodes to the domNode.
                this._TSN.x = this._TSN.y = [this.domNode];
            },

            /**
             * Handler called by the {@link mstrmojo._TouchGestures} mixin when the user touches the screen
             *
             * @param {Object} touch An object containing information about the native HTMLTouchEvent.
             * @ignore
             */
            touchBegin: function touchBegin(touch) {
                // Do we support scrolling for this instance?
                if (!this.noScrolling) {
                    // We want to all touch events within this component so cancel the native event.
                    touch.stop();

                    if (!this._isDownloading) {
                        if (this.toolbarMgr) {
                            this.toolbarMgr.closeToolbar();
                        }

                        var scrollers = this._scroller,
                            min = this._TMIN,
                            max = this._TMAX;

                        //Stops deceleration if  the scroller is within bounds.
                        $forEachHash(this.tPos, function (position, axis) {
                            // Cancel deceleration only if the scroller is within bounds. If out of bounds,
                            // let it decelerate to initial position.
                            if (position >= min[axis] && position <= Math.abs(max[axis])) {
                                //Stop deceleration for all scrollers along the axis.
                                stopDeceleration(scrollers[axis]);
                            }
                        });
                    }

                    // Due to the chunk of data being moved, the 2 scrollers on the x axis get misaligned.
                    // Reset the x values on both the scrollers origin.
                    var xScrollers = this._scroller.x;
                    $forEachHash(xScrollers, function (scroller) {
                        scroller.origin.x = xScrollers[0].origin.x;
                    });
                }

                // Return true so the tap is fired.
                return true;
            },

            /**
             * Handler called by the {@link mstrmojo._TouchGestures} mixin when a touch event is initiated.
             *
             * @param {Object} touch An object containing information about the native HTMLTouchEvent.
             * @ignore
             */
            touchSwipeBegin: function touchSwipeBegin(touch) {
                // Do we not support scrolling for this instance?
                if (this.noScrolling) {
                    // Bubble the event.
                    return this.bubbleTouchEvent(touch);
                }

                // Are we downloading new data?
                if (this._isDownloading) {
                    // Return false to cancel touch event.
                    return false;
                }

                PREVENT_MOVEMENT = preventMove(touch);

                // Check if we need to bubble this event to the parent and set the flag so we know that we're in bubble mode.
                var axis = PREVENT_MOVEMENT.y ? 'x' : 'y',
                    scroller = this._scroller[axis][0],
                    offset = scroller.offset,
                    offsetVal = offset[axis][touch.direction[axis] ? 'end' : 'start'];

                //Are we currently scrolling past the offset? Then we want to bubble the event to the parent
                if (!offset.scrollPast && offsetVal === scroller.origin[axis]) {
                    var bubbleTouchEvent = this.bubbleTouchEvent(touch);

                    // Is anyone expecting the bubbled event. If not handled, let is continue
                    // #717921 cancel the touch event return false also.
                    if (bubbleTouchEvent !== undefined) {
                        return bubbleTouchEvent;
                    }
                }

                //Stop deceleration along the x and y axis.
                var s = this._scroller;

                //Syncs the scroll element when at the limits.
                if (!syncScrollEl(this, touch.delta)) {
                    return true;
                }

                //Stop deceleration only if the user scroller scrolls on the same axis.
                //In other cases let the deceleration complete.
                if (!PREVENT_MOVEMENT.x) {
                    stopDeceleration(s.x);
                }
                if (!PREVENT_MOVEMENT.y) {
                    stopDeceleration(s.y);
                }

                // Display the scrollbars.
                $forEachHash(this._scroller, function (scrollers, axis) {
                    // Are we moving along this axis?
                    if (!PREVENT_MOVEMENT[axis]) {
                        // Show the scroll bar for this axis.
                        $forEachArray(scrollers, function (scroller) {
                            scroller.toggleScrollBars(true);
                        });
                    }
                });

                return true;
            },

            /**
             * Handler called by the {@link mstrmojo._TouchGestures} mixin when a touch event move occurs.
             *
             * @param {Object} touch An object containing information about the native HTMLTouchEvent.
             * @ignore
             */
            touchSwipeMove: function touchSwipeMove(touch) {
                //Syncs the scroll element when at the limits.
                //TODO: may not be the best idea to do this in touchSwipeMove. Needs better fix.
                if (!syncScrollEl(this, touch.delta)) {
                    return true;
                }

                var scrollers = this._scroller;

                $forEachArray([ 'x', 'y' ], function (axis) {
                    if (!PREVENT_MOVEMENT[axis]) {
                        $forEachHash(scrollers[axis], function (scroller) {
                            scroller.scroll(touch);
                        });
                    }
                });
            },

            /**
             * Handler called by the {@link mstrmojo._TouchGestures} mixin when a touch event has ended.
             *
             * @param {Object} touch An object containing information about the native HTMLTouchEvent.
             * @ignore
             */
            touchSwipeEnd: function touchSwipeEnd(touch) {
                var prevent = PREVENT_MOVEMENT,
                    axis = null,
                    delta = touch.delta,
                    direction = touch.direction;

                if (!prevent.x && delta.x !== 0) {
                    axis = 'x';
                    direction = direction.x ? 'left' : 'right';
                }
                if (!prevent.y && delta.y !== 0) {
                    axis = 'y';
                    direction = direction.y ? 'up' : 'down';
                }

                if (axis) {
                // Tell the consumer that we have scrolled.
                    raiseScrolledOutEvent(this, {
                        axis: axis,
                        value: this.tPos[axis],
                        direction: direction
                    });

                    //Perform scrollend deceleration animation on the particular axis.
                    var scroller = this._scroller[axis],
                        i;
                    if (!prevent[axis]) {
                        for (i in scroller) {
                            scroller[i].scrollEnd(touch);
                        }
                    }
                }

            },

            /**
             * Callback by the individual containing grids of the Xtab notifying the Xtab that they have finished rendering.
             *
             * Once they have finished rendering, we measure them again to calculate the right offsets.
             */
            gridPagesRendered: function gridPagesRendered() {
                if (this._super) {
                    this._super();
                }

                this.setOffsets();
            },

            /**
             * Override the empty grid rendering method to set the noScrolling flag to be true
             */
            renderEmptyGrid: function renderEmptyGrid() {
                if (this._super) {
                    this._super();
                }

                this.noScrolling = true;
            },

            postBuildRendering: function postBuildRendering() {

                if (this._super) {
                    this._super();
                }

                // Do we support scrolling and do we have zones? TQMS 715529 Do not set up touch scroller node if grid is empty
                if (this.zones && !this.gridData.eg) {
                    var me = this;

                    //Set up the scrollers in a timeout so as to speed up browser rendering performance. The setting up the scroller a little later doesn't affect
                    //scrolling.
                    window.setTimeout(function () {
                        // #551347 make sure that the widget is rendered.  When rotating device widget might have been unrendered
                        if (me.hasRendered) {
                            me._TSN = {
                                x: [],        //Touch Scroll Node along the X axis
                                y: []         //Touch scroll node along the Y axis
                            };

                            // Setup the Touch scroll nodes after everything is done.
                            me.setupTNs();
                            
                            // Setup the scrollers.
                            me.setupScrollers();
                        }
                    }, 0);
                }
            },

            /**
             * @see mstrmojo.MobileXtab
             */
            setOffsets: function setOffsets() {
                var me = this,
                    domNode = this.domNode,
                    zones = this.zones,
                    TR = zones._TR,
                    BL = zones._BL,
                    isDocNotFullScreen = (!this.isFullScreenWidget && this.isDocXtab),
                    viewportCoords = this._viewportCoords = {
                        top: TR ? TR.cp.rc * parseInt(this.gridData.rh, 10) : 0,
                        //For grids in documents displayed at template level, we want to retreive the width from the formats. - Applies to Xtabs and Interactive Grids
                        right: isDocNotFullScreen ? this.widthLimit : parseInt(this.width, 10),
                        bottom: isDocNotFullScreen ? this.heightLimit : parseInt(this.height, 10),
                        left: BL ? BL.totalColWidth : 0
                    };

                // If we're already created the scrollers, iterate them
                $forEachHash(this._scroller, function (scrollers, axis) {
                    // Iterate the scroll bars for this axis.
                    $forEachArray(scrollers, function (scroller) {
                        // Update the offsets.
                        scroller.offset = getScrollerOffsets(me, axis);

                        // Update the scrollbar sizes and positions.
                        scroller.updateScrollBars(viewportCoords, domNode);

                        //If we already have an origin - check its validity after the offsets have changed
                        var origin = scroller.origin;
                        if (origin) {
                            //Scroll to that position. If the origin is at an invalid position, it will constrain it to the offsets.
                            scroller.scrollTo(origin.x, origin.y);
                        }
                    });
                });
            },
            
            /**
             * Sets up the scrollers if a touch enabled Xtab supports scrolling.
             */
            setupScrollers: function setupScrollers() {
                // Set the no scrolling flag if the user can't scroll in either direction and scroll past is off
                var gd = this.gridData,
                    MAX_OFFSETS = this._TMAX,
                    noScrolling = this.noScrolling = ((gd && gd.co) || (!this.scrollerConfig.scrollPast && MAX_OFFSETS.x === 0 && MAX_OFFSETS.y === 0));

                // Now that we have determined that the grid can scroll, let's set up the scrollers.
                if (!noScrolling && !this._scroller) {
                    //Set boolean since onload, the container is not a scroll element.
                    isContainerScrollElement = {
                        x: false,
                        y: false
                    };

                    //There is a flickering issue when we scroll the report for the very first time. Not sure why but it only happens when
                    //we call the webkit translate method for the very first time. Hence adding it when we setup the touch nodes.
                    translate(this._TSN.x, [0, 0, 0]);
                    translate(this._TSN.y, [0, 0, 0]);

                    //Associate scrollers with the touch scroll nodes.
                    createScrollers(this);
                }
            },

            /**
             * Callback when the viewport's height changes. Typically gets called on Xtab's rendered as full screen and if the
             * device orientation changes.
             */
            onwidthChange: function onwidthChange() {
                updateOffsets.call(this, 'width');

                // Call super.
                if (this._super) {
                    this._super();
                }
            },

            /**
             * Callback when the viewport's height changes. Typically gets called on Xtab's rendered as full screen and if the
             * device orientation changes.
             */
            onheightChange: function onheightChange() {
                updateOffsets.call(this, 'height');

                // Call super
                if (this._super) {
                    this._super();
                }
            },

            /**
             * @see mstrmojo._HasMarkup
             */
            unrender: function unrender(ignoreDom) {
                 // Iterate the scroller axes.
                $forEachHash(this._scroller, function (scrollers) {
                    // Iterate the individual scrollers for this axis.
                    $forEachArray(scrollers, function (scroller) {
                        //Destroy the scrollers.
                        scroller.destroy();
                    });
                });
                
                // Delete the Mobile Xtab's reference of the scrollers.
                delete this._scroller;

                if (this._super) {
                    this._super(ignoreDom);
                }
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo._TouchGestures",
                         "mstrmojo.css",
                         "mstrmojo.dom",
                         "mstrmojo.hash");

    /**
     * <p>A mixin for consumers of {@link mstrmojo._HasDocLink} on the Android application.</p>
     *
     * @class
     * @extends mstrmojo._TouchGestures
     * @public
     */
    mstrmojo.android.ui._IsTouchLink = mstrmojo.provide(
        'mstrmojo.android.ui._IsTouchLink',

        /**
         * @lends mstrmojo.android.ui._IsTouchLink#
         */
        mstrmojo.hash.copy(mstrmojo._TouchGestures, {
            _mixinName: 'mstrmojo.android.ui._IsTouchLink',

            ontouchend: function (evt) {
                // Is the link NOT enabled?
                if (!this.linkEnabled) {
                    return;
                }

                // Has this event NOT been handled by some other component?
                if (!evt.e.handled) {
                    // Create highlight mask.
                    var domNode = this.domNode,
                        mask = document.createElement('div'),
                        id = this.id;

                    // Add mask to domNode.
                    mask.className = 'activeLink on';
                    domNode.appendChild(mask);

                    // Set timeout to remove mask.
                    window.setTimeout(function () {
                        // Is the domNode still rendered?
                        var link = mstrmojo.all[id];
                        if (link && link.hasRendered) {
                            mstrmojo.dom.attachOneTimeEvent(mask, 'webkitTransitionEnd', function () {
                                // Remove mask when background color has faded.
                                domNode.removeChild(mask);
                            });

                            // Remove on css class.
                            mstrmojo.css.removeClass(mask, 'on');
                        }
                    }, 200);

                    // Simulate a click.
                    this.onclick();
                }
            }
        })
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.array",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    /*Private variables*/

    var $C = mstrmojo.css,
        $EF = mstrmojo.emptyFn,
        $D = mstrmojo.dom,
        $HANDLE_WIDTH = 32,
        $CSS = mstrmojo.css,

        types = { //Global types of sliders
            SINGLE: 1,
            INCLUDE: 2,
            EXCLUDE: 3
        },

        f = { //Flags to be used internally
            CONTINUOUS_STEPS: -1,
            UNSET: -4641
        },

        tmp = {}, //stores temp values used while dragging

        /*
         * Returns and caches the width of the slider container
         * */
        getSliderWidth = function (t) {
            if (!tmp[t.id + "cw"]) {

                var width = parseInt($C.getComputedStyle(t.sliderContainer).width, 10);
                if (isNaN(width)) {

                    width = parseInt($C.getComputedStyle(t.domNode.parentNode).width, 10);
                }

                tmp[t.id + "cw"] = width;
            }
            return tmp[t.id + "cw"];
        },

        /*
         * Returns the step of the single handle or the left thumb of the range handle
         * based on the left position of it, for example a 0 (0px left) will return step 0
         * t : widget
         * left : optional, the left of the handle, if it is not provided the third
         *          parameter handle should be provided
         * handle : optional, if not provided, the second parameter left should be provided,
         *          and should be the handle which the step will be returned, [singleHandle | rangeContainer]
         * */
        getSingleStep = function (t, left, handle) {
            var range = t.type !== types.SINGLE,
                handleWidth = $HANDLE_WIDTH,
                l = !!left ? (left - (handleWidth / 2)) :  parseInt(handle.style.left, 10),
                st = t.steps,
                contWidth = getSliderWidth(t) - handleWidth,
                gap = Math.round(contWidth / (st - (!range ? 1 : 0))), //number of gaps on the slider |----|----|----| (3)
                maxStep = range ? t.rightStep : st - 1;

            return Math.min(maxStep, Math.round(l / gap));
        },

        /*
         * returns the current right step based on the position (width of the
         * rangeContainer + left position) of the right handle
         * t : widget
         * */
        getRightStep = function (t) {
            var rcStyle = t.rangeContainer.style,
                width = parseInt(rcStyle.width, 10) - $HANDLE_WIDTH,
                left = parseInt(rcStyle.left, 10),
                st = t.steps, //Use one more step for range calculations, the rightStep is exclusive
                contWidth = getSliderWidth(t) - $HANDLE_WIDTH,
                gap = Math.round(contWidth / st);

            return Math.max(0,
                            Math.min(Math.round((left + width) / gap),
                                     st));
        },

        /*
         * Returns where the left handle should be based on the current step
         * t : widget
         * step : which step is currently being calculated
         * handle : the handle node, the width of this node is used calculate the correct left so the handle
         *          does not get out of the container
         * */
        getLeftForSingle = function (t, step) {
            var st = t.steps,
                w = getSliderWidth(t),
                hs = $HANDLE_WIDTH;
            return Math.min(w - hs, Math.max(0, ((w / (st - 1) * step) - hs / 2))) + "px";
        },

        /*
         * Gets the left position of the include handle based on the provided leftStep, the include and exclude handles have left and right step.
         * t : widget
         * leftStep : current left step
         * */
        getLeftForRange = function (t, leftStep) {

            var st = t.steps,
                w = getSliderWidth(t) - $HANDLE_WIDTH;

            return ((w / st) * leftStep) + "px";
        },

        /*
         * Returns the width of the include handle based on provided left and right step
         * t : widget
         * leftStep : current left step
         * rigthStep: current right step
         * */
        getWidthForRange = function (t, leftStep, rightStep) {
            var st = t.steps, //The last step on the range handle is exclusive, use one more step for calculations
                w = getSliderWidth(t) - $HANDLE_WIDTH,
                ch = rightStep - leftStep;

            return ((ch * w) / st) + $HANDLE_WIDTH + "px";
        },

        /*
         * Once the correct steps are calculated, this method will position the single selector
         * on the correct place. Basically converts steps to left position.
         * t : widget
         * step : step where the singleHandle will be positioned
         * */
        positionSingleStep = function (t, step) {
            var singleHandle = t.singleHandle;
            if (singleHandle) {
                singleHandle.style.left = getLeftForSingle(t, step);
            }
        },

        /*
         * Once the correct steps are calculated, this method will position the slider
         * on the correct place, using the style properties. Basically translates from steps to
         * left and width of the range handle.
         * t : widget
         * leftStep : step where the left handle will be positioned
         * rightStep : step where the right handle will be positioned
         * */
        positionRangeStep = function (t, leftStep, rightStep) {
            var ic = t.rangeContainer,
                sty,
                handleWidth = (t.rangeLHandle.clientWidth || $HANDLE_WIDTH) + 5;

            if (ic) {
                var ircStyle = t.innerRangeContainer.style;

                sty = ic.style;
                sty.left = getLeftForRange(t, leftStep);
                sty.width = getWidthForRange(t, leftStep, rightStep);

                //set up the hit area between the thumbs
                ircStyle.left = parseInt(sty.left, 10) + handleWidth + 'px';
                ircStyle.width = Math.max(parseInt(sty.width, 10) - (2 * handleWidth), 0) + 'px';
            }
        },

        /*  After moving the single handle, snap it on the correct position based on the step number
         *  t : widget object
         *  l : optional left position of the single handle, if not present will take the left from the style,
         *      this is useful when the left is calculated and the handle hasn't been moved yet, for example when tapping the container.
         *  handle : the handle that will be snapped
         * */
        snapHandle = function (t, l, handle) {
            var range = t.type !== types.SINGLE,
                step = getSingleStep(t, l, handle), //if the calculated step is out of bounds use the max step
                stepName = range ? "leftStep" : "singleStep",
                func;

            if (step !== t[stepName]) {
                t.set(stepName, step);
                this.step = step;
            } else {
                func = range ? positionRangeStep : positionSingleStep;
                func(t, step, t.rightStep);
            }
        },

        /*
         * Once the drag is done, snap the range handle to the closest step and set the current step on the widget
         * t : widget
         * left : optional, the left of the handle, if it is not provided the third
         *        parameter handle should be provided
         * handle : optional, if not provided, the second parameter left should be provided,
         *          and should be the handle which the snap will be performed, [singleHandle | rangeContainer]
         * */
        snapRangeHandles = function (t, left, handle) {
            var rangeContainer = t.rangeContainer,
                step,
                leftStep = t.leftStep,
                grabDrag = (handle === rangeContainer || handle === t.innerRangeContainer);

            if (handle === t.rangeRHandle || grabDrag) {
                step = getRightStep(t);
                leftStep += grabDrag ? step - t.rightStep : 0; //only modify left step if the handle was the container

                positionRangeStep(t, leftStep, step);
                if (t.rightStep !== step) {
                    t.set("rightStep", step);
                    if (grabDrag) {
                        t.set("leftStep", leftStep);
                    }
                }
            } else if (handle === t.rangeLHandle) {
                snapHandle(t, left, rangeContainer);
            }
        },

        /*
         * Depending on the type of slider will try to snap the handles on the correct position
         * based on the number of steps
         * */
        snapHandles = function (t, target) {
            switch (t.type) {
            case types.SINGLE:
                snapHandle(t, null, t.singleHandle);
                break;
            case types.EXCLUDE:
            case types.INCLUDE:
                snapRangeHandles(t, null, target);
                break;
            }
        },


        /*
         * Moves the range handle when tapping on the slider container, it moves the
         * slider one step to the tap position side
         * t : widget
         * tapPosition : position in pixels where the tap was done horizontally
         * */
        jumpRangeHandle = function (t, tapPosition) {
            var rangeContainer = t.rangeContainer,
                rcStyle = rangeContainer.style,
                width = parseInt(rcStyle.width, 10),
                left = parseInt(rcStyle.left, 10),
                leftStep = t.leftStep,
                rightStep = t.rightStep,
                nuRs = rightStep,
                nuLs = leftStep;

            if (tapPosition > 0 && tapPosition < left && leftStep > 0) {
                nuRs--;
                nuLs--;
            } else if (tapPosition > (left + width) && tapPosition < getSliderWidth(t)) {
                nuRs++;
                nuLs++;
            }
            positionRangeStep(t, nuLs, nuRs);
            t.set("leftStep", nuLs);
            t.set("rightStep", nuRs);
        },


        /*
         * Moves a handle based on a delta, tries to keep it in bounds, used while dragging.
         * t : widget
         * node : node to be moved, usually the same handle but not always
         * handle : handle dom node
         * originalPosition : position from where the delta is calculated
         * deltaX : delta movement on the x axis
         * */
        moveHandle = function (slider, node, handle, position, deltaX) {

            // Get the width of the thumb from the style collection.
            var width = handle.style.width;

            // Is the width empty?
            if (width === '') {
                // Get the width of the thumb from the computed style.
                width = $C.getComputedStyle(handle).width;
            }

            // Calculate final thumb position to be the position (plus optional delta) with a minimum value of 0 and a maximum value of the slider width (minus thumb width).
            position = Math.min(Math.max(0, position + (deltaX || 0)), getSliderWidth(slider) - parseInt(width, 10));

            // Move the thumb.
            node.style.left = position + 'px';

            return position;
        },

        /*
         * Moves the left handle based on a delta, tries to keep it in bounds, used while dragging.
         * t : widget
         * originalPosition : position from where the delta is calculated
         * originalWidth : original width of the range handle, before the move started.
         * deltaX : delta movement on the x axis
         * */
        moveRangeLHandle = function (t, originalPosition, originalWidth, deltaX) {
            var rangeContainer = t.rangeContainer,
                rangeLHandle = t.rangeLHandle,
                contWidth = getSliderWidth(t) - $HANDLE_WIDTH,
                gap = Math.round(contWidth / t.steps), //number of gaps on the slider |----|----|----| (3)
                newWidth = originalWidth - deltaX,
                handlePos;

            if (newWidth >= (gap + $HANDLE_WIDTH)) {
                handlePos = moveHandle(t, rangeContainer, rangeLHandle, originalPosition, deltaX);

                if ((originalPosition + deltaX) > 0) {
                    rangeContainer.style.width = newWidth + "px";
                }
                return handlePos;
            }
        },


        moveRangeRHandle = function (t, originalPosition, originalWidth, deltaX) {
            var rangeContainer = t.rangeContainer,
                max = getSliderWidth(t) - parseInt(rangeContainer.style.left, 10),
                newWidth = originalWidth + deltaX,
                contWidth = getSliderWidth(t) - $HANDLE_WIDTH,
                gap = Math.round(contWidth / t.steps), //number of gaps on the slider |----|----|----| (3)
                handlePos;

            if (newWidth >= (gap + $HANDLE_WIDTH)) {
                handlePos = Math.min(max, newWidth);
                rangeContainer.style.width = handlePos + "px";

                return handlePos;
            }
        },

        /*
         * Calls the build summary method that should be implemented by the subclasses
         * with the correct arguments
         * t : widget
         * */
        prepareSummary = function (t) {
            var singleStep, leftStep, rightStep, summary;
            switch (t.type) {
            case types.SINGLE:
                singleStep = parseInt(this.step, 10) === f.UNSET ?  getSingleStep(t, null, t.singleHandle) : this.step;
                summary = t.buildSummary(singleStep);
                this.step = f.UNSET;
                break;
            case types.EXCLUDE:
            case types.INCLUDE:
                leftStep = getSingleStep(t, null, t.rangeContainer);
                rightStep = getRightStep(t);
                summary = t.buildSummary(null, leftStep, rightStep);
                break;
            }

            return summary;
        };

    /**
     * Widget for displaying slider selector for the Android platform.
     *
     * @class
     * @extends mstrmojo.Widget
     * @borrows mstrmojo._TouchGestures
     */
    mstrmojo.android.selectors.MobileSliderSelector = mstrmojo.declare(

        mstrmojo.Widget,

        [ mstrmojo._TouchGestures, mstrmojo._ListSelections ],

        /**
         * @lends mstrmojo.android.selectors.MobileSliderSelector.prototype
         */
        {

            /*Confifuration flags*/

            width: 0, //width of the selector

            type : f.UNSET, //Type of slider, include, exclude or single select

            value : f.UNSET, //The user input of the value, it will be parsed to populate the (private) values field.

            steps : f.UNSET, //Number of steps on the slider, use CONTINUOUS_STEPS if unlimited

            include : f.UNSET,

            /*End of configuration flags*/

            /*Start abstract methods*/

            initState : $EF, //called just after the rendering was performed, should be used to initialize the slider

            buildSummary : $EF, //called when the summary needs to be updated, notice that the steps will be provided on the arguments, do not use this steps attributes.

            updateMinMaxLabels : $EF, //called when the min or max labels need to be updated

            flushSelections : $EF, //called when the steps have been modified

            /*End of abstract methods*/

            step: f.UNSET,  //Cached step of the single thumb, used later for building summary

            singleStep : f.UNSET, //Current step of the single thumb, used for single select slider

            leftStep : f.UNSET, //Current step of the left thumb, used for include/exclude slider

            rightStep : f.UNSET, //Current step of the right thumb, used for include/exclude slider

            cssDisplay: 'block',

            scriptClass: "mstrmojo.android.selectors.MobileSliderSelector",

            useRichTooltip: true,

            markupString : '<div class="mstrmojo-sliderSel" id="{@id}">' +
                                '<div></div>' + //floating editor
                                '<div class="mstrmojo-sliderSelSummary">&nbsp;</div>' + //Summary
                                '<div class="mstrmojo-sliderSelScrollerContainer">' + //Slider
                                    '<div class="mstrmojo-sliderSelScrollerHandle" style="display:none;">' + //include container, set  width and left
                                        '<div class="mstrmojo-sliderSelScrollerHandle1 leftHandle"><div></div></div>' + //include left handle
                                        '<div class="mstrmojo-sliderSelScrollerHandle1 rightHandle"><div></div></div>' + //include right handle
                                    '</div>' +
                                   '<div class="mstrmojo-sliderSelScrollerHandle2" style="display:none;"><div></div></div>' + //single handle, set left
                                   '<div class="mstrmojo-sliderSelScrollerHandleArea" style="display:none;position:absolute"></div>' +
                               '</div>' +
                               '<div class="mstrmojo-sliderSelLabels">' + //Min and max labels
                                   '<label class="mstrmojo-sliderSelLL">&nbsp;</label>' +
                                   '<label class="mstrmojo-sliderSelLR">&nbsp;</label>' +
                               '</div>' +
                           '</div>',

            markupSlots : {
                editor: function () { return this.domNode.childNodes[0]; },
                summary: function () { return this.domNode.childNodes[1]; },
                sliderContainer: function () { return this.domNode.childNodes[2]; },
                innerRangeContainer: function() {return this.domNode.childNodes[2].childNodes[2];},
                rangeContainer: function () { return this.domNode.childNodes[2].childNodes[0]; },
                rangeLHandle: function () { return this.domNode.childNodes[2].childNodes[0].childNodes[0]; },
                rangeRHandle: function () { return this.domNode.childNodes[2].childNodes[0].childNodes[1]; },
                singleHandle: function () { return this.domNode.childNodes[2].childNodes[1]; },
                minLabel: function () { return this.domNode.childNodes[3].childNodes[0]; },
                maxLabel: function () { return this.domNode.childNodes[3].childNodes[1]; }
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? this.cssDisplay : 'none'; },
                /*
                 * Updates the slider style based on the type, basically allowing switching between include or
                 * exclude mode on runtime, not actually intended to change between single and include/exclude.
                 * */
                ontypeChange: function () {
                    var s,
                        i = "none",
                        scClassName = "mstrmojo-sliderSelScrollerContainer",
                        handleClassName = "Handle1";

                    switch (this.type) {
                    case types.SINGLE:
                        s = 'block';
                        break;
                    case types.EXCLUDE:
                        scClassName = "mstrmojo-sliderSelScrollerContainerExcl";
                        handleClassName = "Handle2";
                        i = 'block';
                        break;
                    case types.INCLUDE:
                        i = 'block';
                        break;
                    }

                    this.rangeContainer.style.display = i;
                    this.innerRangeContainer.style.display = i;
                    this.sliderContainer.className = scClassName;
                    this.rangeLHandle.className = "mstrmojo-sliderSelScrollerHandleX leftHandle".replace("HandleX", handleClassName);
                    this.rangeRHandle.className = "mstrmojo-sliderSelScrollerHandleX rightHandle".replace("HandleX", handleClassName);

                    this.singleHandle.style.display = s;
                },
                onconstantsChange: function () {
                    this.updateMinMaxLabels();
                },
                onvalueChange: function () {
                    prepareSummary(this);
                }
            },

            postBuildRendering: function postBuildRendering() {
                var rtn = this._super();
                this.initState();

                var d = this.tooltipNode || this.domNode;

                $D.detachEvent(d, 'mouseover', this._ontooltipover);
                $D.detachEvent(d, 'mouseout', this._ontooltipout);

                return rtn;
            },

            onsingleStepChange : function () {
                positionSingleStep(this, this.singleStep);
            },

            onleftStepChange : function () {
                positionRangeStep(this, this.leftStep, this.rightStep);
            },

            onrightStepChange : function () {
                positionRangeStep(this, this.leftStep, this.rightStep);
            },

            /**
             * Only starts sliding process if thumb has been pressed on.
             * store temp positions when slide starts.
             */
            touchSwipeBegin: function (touch) {
                var target = touch.target;
                if (!target) {
                    return false;
                }

                this.touchTap(touch);

                // Create collection to hold glowing elements.
                var glowTargets = this._glowing = [];

                // Add glow css class to target and add target to glow collection.
                $CSS.addClass(target, 'glow');
                glowTargets.push(target);

                // Cache slider target.
                this._sliderTarget = target;

                var singleHandle = this.singleHandle,
                    rangeContainer = this.rangeContainer,
                    left,
                    style;

                switch (target) {
                case singleHandle:
                    left = singleHandle.style.left;
                    //tml.shl has the handle original left position, when the move started.
                    tmp.shl = parseInt(!!left ? left : 0, 10);
                    break;

                case rangeContainer:
                case this.innerRangeContainer:
                case this.rangeLHandle:
                case this.rangeRHandle:
                    style = rangeContainer.style;
                    left = style.left;
                    //tmp.icl has the handle original left position, when the move started.
                    tmp.icl = parseInt(!!left ? left : 0, 10);
                    //tmp.icw has the handle original width, when the move started.
                    tmp.icw = parseInt(style.width, 10);
                    break;
                case this.sliderContainer:
                    // Add glow css class to single handle and add single handle to glow collection.
                    $CSS.addClass(singleHandle, 'glow');
                    glowTargets.push(singleHandle);
                    break;

                default:
                    this.bubbleTouchEvent(touch);
                }

                this._initTooltip();

                if (this.type === types.SINGLE) {
                    this.touchSelectMove(touch, true);
                }
            },

            /**
             * Moves the thumb while the finger of the user is down moving the handle,
             * it triggers the summary update. This method is called by the touchGestures mixin.
             */
            touchSwipeMove: function (touch, ignoreNodeWidth) {
                var target = touch.target;
                if (!target) {
                    return false;
                }

                // Reset target to original slider target so this works in hosted mode.
                target = this._sliderTarget;

                var singleHandle = this.singleHandle,
                    rangeContainer = this.rangeContainer,
                    rangeLHandle = this.rangeLHandle,
                    rangeRHandle = this.rangeRHandle,
                    deltaX = touch.delta.x,
                    leftPos;


                switch (target) {
                case singleHandle:
                    leftPos = moveHandle(this, singleHandle, singleHandle, tmp.shl, deltaX);
                    break;
                case rangeRHandle:
                    leftPos = moveRangeRHandle(this, tmp.icl, tmp.icw, deltaX);
                    break;
                case rangeLHandle:
                    leftPos = moveRangeLHandle(this, tmp.icl, tmp.icw, deltaX);
                    break;
                case rangeContainer:
                case this.innerRangeContainer:
                    if (this.type === types.INCLUDE) {
                        leftPos = moveHandle(this, rangeContainer, rangeContainer, tmp.icl, deltaX);
                    }
                    break;
                case this.sliderContainer:
                    leftPos = moveHandle(this, singleHandle, singleHandle, touch.clientX - $D.position(this.sliderContainer, true).x);
                    break;
                }

                this._updateTooltip(touch.evt, target, leftPos, ignoreNodeWidth);
            },

            /*
             * When the touch ends, this method tries to snap the handles on the
             * correct step, and then if changed it will flush the selections, flushSelections
             * should be implemented on the extended class. Called by the touchGestures mixin.
             */
            touchSwipeEnd: function (touch) {

                var target = (touch.target === this.sliderContainer) ? this.singleHandle : this._sliderTarget,
                    l = this.leftStep,
                    r = this.rightStep,
                    s = this.singleStep;

                // Iterate currently glowing targets and...
                mstrmojo.array.forEach(this._glowing, function (glowTarget) {
                    // remove glow class.
                    $CSS.removeClass(glowTarget, 'glow');
                });

                // Snap handles will position the handles on the correct place and update the
                // step value depending on the handle that was moved.
                snapHandles(this, target);

                if (l !== this.leftStep || r !== this.rightStep || s !== this.singleStep) {
                    this.flushSelections();
                }

                this.hideTooltip(touch.evt, this);
            },

            /*
             * When a tap is performed on the slider, this is called by the touchGestures
             * mixin, the tap can be done on the slider container, and will move the handle
             * to that position.
             * */
            touchTap: function (touch) {
                var target = touch.target;
                if (!target) {
                    return false;
                }

                var sliderContainer = this.sliderContainer,
                    clientX = touch.clientX,
                    containerTapped = (sliderContainer === target),
                    tapPosition = clientX - $D.position(sliderContainer, true).x,
                    l = this.leftStep,
                    r = this.rightStep,
                    s = this.singleStep;

                switch (this.type) {
                case types.SINGLE:
                    if (containerTapped) {
                        snapHandle(this, tapPosition, this.singleHandle);
                    }
                    break;
                case types.INCLUDE:
                    if (containerTapped) {
                        jumpRangeHandle(this, tapPosition);
                    }
                    break;
                    //Do nothing for exclude mode, for now.
                }

                if (l !== this.leftStep || r !== this.rightStep || s !== this.singleStep) {
                    prepareSummary(this);
                    this.flushSelections();
                }
            },

            touchSelectBegin: function (touch) {
                this.touchSwipeBegin(touch);
            },
            touchSelectMove: function (touch) {
                this.touchSwipeMove(touch, true);
            },
            touchSelectEnd: function (touch) {
                this.touchSwipeEnd(touch);
            },

            touchEnd: function touchEnd(touch) {
                this.hideTooltip(touch.evt, this);
            },

            _initTooltip: function _initTooltip() {

                this.set('richTooltip', {refNode : this.domNode,
                                         posType: mstrmojo.tooltip.POS_BOTTOMCENTER,
                                         contentNodeCssClass: 'mstrmojo-sliderTip'});
            },

            _updateTooltip: function _updateTooltip(event, target, leftPos, ignoreNodeWidth) {

                this.showTooltip(event, this);
                var containerNode = $D.position(this.sliderContainer, false),
                    dposDomNode = $D.position(this.domNode, false),
                    boxContainer = mstrmojo.boxmodel.offset(this.sliderContainer),
                    breachedTopBoundary = (containerNode.y < 90),
                    ttN = this.richTooltip,
                    content = prepareSummary(this),
                    nodeWidth;

                if (ignoreNodeWidth) {

                    nodeWidth = ($HANDLE_WIDTH / 2);
                } else {

                    nodeWidth = target.style.width;

                    if (nodeWidth === "") {
                        nodeWidth = $C.getComputedStyle(target).width;
                    }
                    nodeWidth = parseInt(nodeWidth, 10) / 2;
                }

                ttN.content = '<div class="mstrmojo-sliderTip-top">' + content + '</div>' +
                              '<div class="mstrmojo-sliderTip-bottom' + (breachedTopBoundary ? ' down' : '') + '">' + '</div>';

                ttN.top = dposDomNode.y - boxContainer.top - 20 + (breachedTopBoundary ? 100 : 0);
                ttN.left = leftPos + nodeWidth + (dposDomNode.x - boxContainer.left);

                this.richTooltip = null;
                this.set('richTooltip', ttN);
            },

            onselectionChange: function onselChg() {
                // A hook for custom behavior
                if (this.onchange) {
                    this.onchange();
                }

                if (this.makeSelection) {
            		this.makeSelection({
            			selItem: this.type === types.SINGLE ? this.singleHandle : this.rangeContainer
            		});
            	}
            },

            //Utility method to be called via JS, used for debugging purposes.
            slideHosted: function (single, left, right) {
                if (single !== null && single !== undefined) {
                    this.set("singleStep", single);
                }
                if (left !== null && left !== undefined) {
                    this.set("leftStep", left);
                }
                if (right !== null && right !== undefined) {
                    this.set("rightStep", right);
                }
                this.flushSelections();
                prepareSummary(this);
            }

        }
    );

    var $MSL = mstrmojo.android.selectors.MobileSliderSelector;

    $MSL.TYPES = types;
    $MSL.FLAGS = f;

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.TouchScroller",
                         "mstrmojo.hash");

    var $HASH = mstrmojo.hash;

    /**
     * <p>A mixin that equips a {@link mstrmojo.Widget} with default methods for creating and scrolling using a {@link mstrmojo.TouchScroller}.</p>
     *
     * <p>Any properties that the consuming {@link mstrmojo.Widget} would like passed to the {@link mstrmojo.TouchScroller} should be set in the scrollerConfig.</p>
     *
     * <p>Any dynamic scrollerConfig properties can be computed in the updateScrollerConfig method.</p>
     *
     * @class
     * @public
     */
    mstrmojo._HasTouchScroller = mstrmojo.provide(

        "mstrmojo._HasTouchScroller",

        /**
         * @lends mstrmojo._HasTouchScroller#
         */
        {
            _meta_usesSuper: true,

            /**
             * <p>A configuration object that can be used to pass properties to the {@link mstrmojo.TouchScroller}.</p>
             */
            scrollerConfig: {},

            /**
             * Indicates whether touch events should bubble when the scroller starts at it's offset limit.
             *
             * @type Boolean
             * @default true
             */
            allowTouchBubble: true,

            /**
             * Allows the user of the scroller to delay the scroller setup in a timeout.
             *
             * @default undefined Which will setup the scroller instantaneously.
             */
            scrollerSetupDelay: undefined,

            init: function init(props) {
                this._super(props);

                // Convert scroller config to a clone so that all instances don't share the same config.
                this.scrollerConfig = $HASH.clone(this.scrollerConfig);
            },

            /**
             * Hook for updating the scrollerConfig object with dynamic values.
             *
             * @returns {Object} The updated scroller config.
             */
            updateScrollerConfig: function updateScrollerConfig() {
                return this.scrollerConfig;
            },

            /**
             * Calls updateScrollerConfig and applies new scroller config properties to existing scroller instance (if present).
             *
             * @param {Boolean} [noScrollToOrigin=false] True if you do not want the scroller to synchronize with the origin.
             * @param {Integer} [duration=0] The duration of the scrollToOrigin.
             *
             */
            updateScroller: function updateScroller(noScrollToOrigin, duration) {
                var scroller = this._scroller;

                //TQMS 493892. Under certain circumstances this method is called by the Publisher within Global scope
                if (scroller) {
                    // Update the configuration.
                    var cfg = this.updateScrollerConfig();

                    // Update the scroller with current config.
                    scroller.initScroller(cfg);

                    // Should we synchronize the scroller with the origin?
                    if (!noScrollToOrigin) {
                        // Do we have an origin?
                        var origin = cfg.origin;
                        if (origin) {
                            // Make sure the scroller is positioned at the origin.
                            scroller.scrollTo(origin.x, origin.y, duration);
                        }
                    }

                    // Update scroll bars.
                    scroller.updateScrollBars();
                }
            },

            /**
             * A custom hook called immediately after the scroller is created.
             *
             * @param {mstrmojo.TouchScroller} scroller The instance of {@link mstrmojo.TouchScroller} to be initialized.
             *
             */
            initScroller: mstrmojo.emptyFn,

            /**
             * If true, the scroller will be scrolled for touchSelectMove as well as touchSwipeMove.
             *
             * @type Boolean
             * @default false
             */
            useSelectScroll: false,

            /**
             * Instantiates a {@link mstrmojo.TouchScroller} and stores it in the "_scroller" property.
             */
            postBuildRendering: function postBuildRendering() {
                var scroller = this._scroller;

                // Do we NOT already have a scroller?
                if (!scroller) {
                    // Initialize scroller without config.
                    scroller = this._scroller = new mstrmojo.TouchScroller();

                    // Call the custom hook for scroller initialization.
                    this.initScroller(scroller);
                } else {  // TQMS 497890
                    scroller.haltScroller();
                }

                // Do we NOT have _HasLayout mixed in?
                if (!this.layoutConfig) {
                    var $this = this,
                        delay = this.scrollerSetupDelay;

                    if (!isNaN(delay)) {
                        window.setTimeout(function () {
                            $this.updateScroller();
                        }, delay);

                    } else {
                        // Need to manually call updateScroller (instead of relying on afterLayout of _HasLayout).
                        this.updateScroller();
                    }
                }

                // Call super.
                if (this._super) {
                    this._super();
                }
            },

            /**
             * Calls updateScroller to calculate new dynamic scroller properties and apply them to the scroller instance.
             *
             * @ignore
             */
            afterLayout: function afterLayout() {
                this._super();

                // Update scroller.
                this.updateScroller();
            },

            getScrollPos: function getScrollPos() {
                return $HASH.copy(this._scroller.origin || {
                    x: 0,
                    y: 0
                });
            },

            /**
             * Returns true if the touch event should be bubbled based on scroller configuration and position.
             *
             * @type Boolean
             */
            shouldTouchBubble: function shouldTouchBubble(touch) {
                // Does this widget NOT allow touch bubbling?
                if (!this.allowTouchBubble) {
                    // Exit without bubbling.
                    return false;
                }

                // Default to horizontal.
                var scroller = this._scroller,
                    isVertical = touch.isVertical,
                    axis = (isVertical) ? 'y' : 'x';

                // Does the scroller not scroll in this orientation OR is the scroller at the end in this orientation?
                return (!scroller[((isVertical) ? 'v' : 'h') + 'Scroll'] || scroller.offset[axis][touch.direction[axis] ? 'end' : 'start'] === scroller.origin[axis]);
            },

            /**
             * Stops the deceleration of the private {@link mstrmojo.TouchScroller} instance if it's currently decelerating.
             *
             * @param {Object} touch An object containing information about the native HTMLTouchEvent.
             * @ignore
             */
            touchBegin: function touchBegin(touch) {
                // Stop deceleration.
                this._scroller.haltScroller();

                return (this._super && this._super(touch)) || true;
            },

            /**
             * Shows the scrollbars.
             *
             * @param {Object} touch An object containing information about the native HTMLTouchEvent.
             * @ignore
             */
            touchSwipeBegin: function touchSwipeBegin(touch) {
                // Should we bubble the touch event?
                if (this.shouldTouchBubble(touch)) {
                    // Try to bubble the event.  Did it return false, meaning that it won't be handled by anybody else?
                    if (this.bubbleTouchEvent(touch) === false) {
                        // We still need to handle the event to potentially mark the swipe end event as handled, so locally mark this touch as canceled.
                        this._touchCanceled = true;
                    }

                    // Were done, so return.
                    return;
                }

                // Do we have a super?
                if (this._super) {
                    // Call it.
                    this._super(touch);
                }

                // Show scrollbars.
                this._scroller.toggleScrollBars(true);
            },

            /**
             * Calls touchSwipeBegin if useSelectScroll is true.
             *
             * @param {Object} touch An object containing information about the native HTMLTouchEvent.
             * @ignore
             */
            touchSelectBegin: function touchSelectBegin(touch) {
                // Do we have a super?
                if (this._super) {
                    // Call it.
                    this._super(touch);
                }

                // Is select scroll enabled?
                if (this.useSelectScroll) {
                    // Simulate a touch swipe.
                    this.touchSwipeBegin(touch);
                }
            },

            /**
             * Calls the scroll method of the private {@link mstrmojo.TouchScroller} instance.
             *
             * @param {Object} touch An object containing information about the native HTMLTouchEvent.
             * @ignore
             */
            touchSwipeMove: function touchSwipeMove(touch) {
                // Was the touch NOT canceled?
                if (!this._touchCanceled) {
                    // Do we have a super?
                    if (this._super) {
                        // Call it.
                        this._super(touch);
                    }
                }

                // Scroll the scroller.
                this._scroller.scroll(touch);
            },

            /**
             * Calls touchSwipeMove if useSelectScroll is true.
             *
             * @param {Object} touch An object containing information about the native HTMLTouchEvent.
             * @ignore
             */
            touchSelectMove: function touchSelectMove(touch) {
                // Was the touch NOT canceled?
                if (!this._touchCanceled) {
                    // Do we have a super?
                    if (this._super) {
                        // Call it.
                        this._super(touch);
                    }
                }

                // Is select scroll enabled?
                if (this.useSelectScroll) {
                    // Simulate a touch swipe move.
                    this.touchSwipeMove(touch);
                }
            },

            /**
             * Calls the scrollEnd method of the private {@link mstrmojo.TouchScroller} instance.
             *
             * @param {Object} touch An object containing information about the native HTMLTouchEvent.
             * @ignore
             */
            touchSwipeEnd: function touchSwipeEnd(touch) {
                // Mark the event as handled so the touchEnd event used to stop the scrolling can be ignored by other components.
                touch.evt.handled = true;

                // Was the touch NOT canceled?
                if (!this._touchCanceled) {
                    // Do we have a super?
                    if (this._super) {
                        // Call it.
                        this._super(touch);
                    }
                }

                // Tell the scroller to end.
                this._scroller.scrollEnd(touch);
            },

            /**
             * Calls touchSwipeEnd if useSelectScroll is true.
             *
             * @param {Object} touch An object containing information about the native HTMLTouchEvent.
             * @ignore
             */
            touchSelectEnd: function touchSelectEnd(touch) {
                // Was the touch canceled?
                if (this._touchCanceled) {
                    // Nothing to do.
                    return;
                }

                // Do we have a super?
                if (this._super) {
                    // Call it.
                    this._super(touch);
                }

                // Is select scroll enabled?
                if (this.useSelectScroll) {
                    // Simulate a touch swipe end.
                    this.touchSwipeEnd(touch);
                }
            },

            touchEnd: function touchEnd(touch) {
                // Was the touch canceled?
                if (this._touchCanceled) {
                    // Delete the canceled flag and return.
                    delete this._touchCanceled;
                    return;
                }

                if (this._super) {
                    this._super(touch);
                }
            },

            unrender: function unrender(ignoreDom) {

                // Do we have a scroller?
                var scroller = this._scroller;
                if (scroller) {
                    // Tell it we are unrendering.
                    scroller.unrender();
                }

                // Release the scroll element.
                delete this.scrollerConfig.scrollEl;

                this._super(ignoreDom);
            },


            /**
             * Overridden to destroy the TouchScroller reference.
             *
             * @ignore
             */
            destroy: function destroy() {
                // Do we have a scroller?
                if (this._scroller) {
                    // Destory it and delete the reference.
                    this._scroller.destroy();
                    delete this._scroller;
                }

                // Do we have a super?
                if (this._super) {
                    // Call it.
                    this._super();
                }
            }

        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom","mstrmojo.TouchScroller");
    
    var $D = mstrmojo.dom,
    	$M = Math;
    
    function constrainPoint(value, offset) {
        return (offset) ? $M.max($M.min($M.round(value), offset.end), offset.start) : value;
    }

    /*
     * when one scroller moved
     * other scroller in this.listeners will moved in sync
     * If you want to attachEventListener to ScrollMoved and ScrollDone event in your class, 
     * you need to rewrite the onScrollMoved and onScrollDone function
     */
    mstrmojo._NeedSyncScroller = mstrmojo.provide(

        "mstrmojo._NeedSyncScroller",

        /**
         * @lends mstrmojo._NeedSyncScroller#
         */
        {
           init: function init(props){
	    	   if(this._super){
	    		   this._super(props);
	    	   }
	    	   
	        	 if(!this.lisenters){
	        		 this.lisenters = [];
	        	 }  
        	 
           },

           initScroller : function initScroller(scroller) {
        	   if(this._super){
        		   this._super(scroller);
        	   }
        	   
				// Attach event listeners.  Call back to listen when scroll is moved
				this._scrollMovedListener = this._scroller.attachEventListener('scrollMoved', this.id, function (evt) {
					this.onScrollMoved(evt);
				});
				
				// Attach event listeners.  Call back to listen when scroll is done
				this._scrollDoneListener = this._scroller.attachEventListener('scrollDone', this.id, function (evt) {
					this.onScrollDone(evt);
				});
           },
           
           onScrollMoved: function onScrollMoved(evt){
        	   if(this._super){
        		   this._super(evt);
        	   }
        	   this.syncScroller(evt, true);
           },
           
           onScrollDone: function onScrollDone(evt){
        	   if(this._super){
        		   this._super(evt);
        	   }
        	   
        	   this.syncScroller(evt, false);
        	   
        	   
           },
           
           syncScroller: function sScroller(evt, showScrollBar){
        	   if(!evt || evt.x == undefined || evt.y == undefined){
        		   return;
        	   }
        	   var lisenters = this.lisenters,
        	   		lisCount = this.lisenters.length;
        	   for(var i = 0 ; i < lisCount; i++ ){
        		   var scroller = lisenters[i]._scroller,
        		   		offset = scroller.offset;
      				
      				//update scroll element
        		   scroller.origin = {
       					x : scroller.hScroll ? evt.x : 0,
       					y : scroller.vScroll ? evt.y : 0
       				};
        		   $D.translate(scroller.scrollEl, -scroller.origin.x, -scroller.origin.y, 0, scroller.transform, scroller.useTranslate3d);
        		   //update scroll bar
        		   scroller.toggleScrollBars(showScrollBar);
        		   mstrmojo.hash.forEach(scroller._scrollBarEls, function (bar, axis) {
        	            var isX = (axis === 'x'),
        	                position = evt[axis],
        	                length = bar.length,
        	                ratio = bar.ratio,
        	                viewportSize = bar.viewportSize,
        	                minScale = 6 / length,
        	                minPosition = bar['base' + ((isX) ? 'Left' : 'Top')],
        	                maxPosition = minPosition + viewportSize - length,
        	                newPosition = $M.round(minPosition + (ratio * position));

        	            // Adjust position and bar length for scroll out cases.
        	            if (newPosition < minPosition) {
        	                newPosition = minPosition - position;
        	                length += position;
        	            } else if (newPosition > maxPosition) {
        	                var delta = (position - scroller.offset[axis].end) * ratio;
        	                newPosition = $M.min(maxPosition + delta, viewportSize + minPosition - 6) - 1;
        	                length -= delta;
        	            }

        	            // Move and size the bar.  Use webkitTransform for better performance.
        	            var v = 0,
        	                translate = [v, v, v],
        	                scale = [1, 1, 1],
        	                idx = (isX) ? 0 : 1;

        	            translate[idx] = (newPosition - minPosition);
        	            scale[idx] = $M.min($M.max(length / bar.length, minScale), 1);

        	            $D.translate(bar, translate[0], translate[1], translate[2], ' scale3d(' + scale.join(',') + ')');
        	        });
        		   
        	   }
           },
           
           addSyncScroller: function addSyncScroller(l){
        	   this.lisenters.push(l);
           },
           
           destroy: function destroy(){
        	   this.lisenters = null;
        	   
        	   // Detach scrolling event listeners
	            if(this._scrollDoneListener){
	            	this._scroller.detachEventListener(this._scrollDoneListener);
	            	delete this._scrollDoneListener;
	            }
	            if(this._scrollMovedListener){
	            	this._scroller.detachEventListener(this._scrollMovedListener);
	            	delete this._scrollMovedListener;
	            }
	            
        	   this._super();
           }

        }
    );

}());//@ sourceURL=_NeedSyncScroller.js
(function(){
    mstrmojo.requiresCls("mstrmojo.TouchScroller", "mstrmojo.dom");

    var LOCK_OFF = 0,
        LOCK_ROW = 1,
        LOCK_COL = 2,
        LOCK_BOTH =3,
        
        TAB_INFO = 'CellInfo',
        TAB_DRILL = 'Drill',
        TAB_LINK = 'Link',

        // For tablets
        TOUCH_OFFSET = 25,
        CONTENT_LINE_HEIGHT = 40,
        TITLE_HEIGHT = 55,
        TITLE_BORDER_HEIGHT = 6,
        MAX_ENTRIES = 4,
        isTablet = false,
        
        CSS_TAB = 'InfoViewer-Tab',
        CSS_TAB_WRAPPER = 'InfoViewer-TabWrapper',
        CSS_SCOLL_TAB = 'InfoViewer-nTab',
        CSS_SHOW_ALL = 'showAll',
        CSS_DRILL_TO = 'drillTo',
        CSS_LINK_TO = 'linkTo',
        CSS_GLOW = 'glow',
        
        $CSS = mstrmojo.css,

        EVENT_HANDLERS = [];
        
        /**
         * Tab Switching
         */
        EVENT_HANDLERS[CSS_TAB] = EVENT_HANDLERS[CSS_SCOLL_TAB] = function(dom){
            var cssClass = dom.className;
            
            // if we are tapping on inner dom, we need to find its wrapper node
            if (cssClass == CSS_TAB){
                cssClass = dom.parentNode.className;
            }
            
            // switch tab
            for (var i = 0, len = this.tabs.length; i < len; i++){
                if (cssClass.indexOf(this.tabs[i].name) > -1){
                    this.setCurrentTab(i);
                    break;
                }
            }
            
            // resize and position the dialog with new content
            this.xtab.magnifier.resizeAndPosition();
        };
    
        /**
         * Drill to
         */
        EVENT_HANDLERS[CSS_DRILL_TO] = function(){
            mstrApp.closeDialog();
            this.xtab.controller.onDrill(this.xtab, this.drillPaths[0].act);
        };
        
        /**
         * Link to
         */
        EVENT_HANDLERS[CSS_LINK_TO] = function(dom){
            mstrApp.closeDialog();
            this.xtab.controller.onLink(this.xtab, this.linkPaths[dom.getAttribute('lnk')].act);
        };
        
        /**
         * Show all information
         */
        EVENT_HANDLERS[CSS_SHOW_ALL] = function(dom){
            // remember that the current tab has been expanded
            this.tabs[this.currentTabIndex].expanded = true;
            // show all entries 
            $CSS.removeClass(this.xtab.magnifier.containerNode, 'hideMore');
            
            // magnifier with new content needs to be resized
            this.xtab.magnifier.resizeAndPosition();
        };
    
    /**
     * Helper class for Magnifiers
     */
    mstrmojo.XtabMagnifierHelper = mstrmojo.declare(
            
        mstrmojo.Obj,
        
        null,
        
        {
            xtab: null,
            
            cellInfo: null, 
            
            selectedCell: null,
            
            drillPaths: null,
            
            linkPaths: null,
            
            tabs: [],
            
            currentTabIndex: 0,
            
            init: function(props){
                this._super(props);
                
                isTablet = mstrApp.isTablet();
                
                // For phones, change appearance propotional to DPI
                var dpi = mstrMobileApp.getDeviceDPI();
                if (dpi <= 120) { // low density
                    CONTENT_LINE_HEIGHT = 26;
                    TITLE_HEIGHT = 35; 
                    TOUCH_OFFSET = 15; 
                } else if (dpi <= 160) { // normal density
                    CONTENT_LINE_HEIGHT = 35;
                    TITLE_HEIGHT = 46; 
                    TOUCH_OFFSET = 20;
                } else if (dpi <= 213) {
                    CONTENT_LINE_HEIGHT = 46;
                    TITLE_HEIGHT = 61;
                    TOUCH_OFFSET = 26;
                } else if (dpi <= 240){ // medium density
                    CONTENT_LINE_HEIGHT = 53;
                    TITLE_HEIGHT = 69;
                    TOUCH_OFFSET = 30;
                } else { // high density
                    CONTENT_LINE_HEIGHT = 70;
                    TITLE_HEIGHT = 92;
                    TOUCH_OFFSET = 40;
                }
                
                if (!isTablet) {
                // Show only 3 entries on phones
                	MAX_ENTRIES = 3;
                }
                
                this.titleHeight = TITLE_HEIGHT;
            },
            
            /**
             * highlight the dom when user touch on it
             */
            glowOnTap: function(dom){
                var glowCssClass = [CSS_TAB_WRAPPER, CSS_SHOW_ALL, CSS_DRILL_TO, CSS_LINK_TO],
                    cssClass = dom.className;

                if (cssClass == CSS_TAB){
                    dom = dom.parentNode;
                    cssClass = dom.className;
                }
                
                for (var i = 0, len = glowCssClass.length; i < len; i++){
                    if (cssClass.indexOf(glowCssClass[i]) > -1){
                        $CSS.addClass(dom, CSS_GLOW);
                 
                        // highlight the dom node for 0.2s
                        setTimeout(function(){
                            $CSS.removeClass(dom, CSS_GLOW);
                        }, 200);
                        
                        break;
                    }
                }
            },
            
            /**
             * handle touch events on info viewer
             */
            handleTouchTap: function(dom){
                this.glowOnTap(dom);
                
                // Find the event handler by matching the css class
                for (n in EVENT_HANDLERS){
                    if (dom.className.indexOf(n) > -1){
                        EVENT_HANDLERS[n].call(this, dom);
                    }
                }
            },
            
            /**
             * handle swipe gestures on info viewer
             */
            handleTouchSwipe: function(touch){
                // Disabled on tablets
                if (!isTablet){
                    var directionX = touch.direction.x,
                        delta = touch.delta,
                        idx = this.currentTabIndex,
                        tabLen = this.tabs.length,
                        totalWidth = parseInt(this.xtab.magnifier.width, 10),
                        minDeltaX = isNaN(totalWidth) ? 50 : totalWidth * 0.2; 
                    
                    // if the horizontal offset is twice larger than vertical offset
                    if (Math.abs(delta.x) > minDeltaX){
                        if (delta.x > 0){
                            // switch to the tab on the left
                            idx = (idx + tabLen - 1) % tabLen;
                        }else {
                            idx = (idx + tabLen + 1) % tabLen;;
                        }
                        
                        // it's a different tab
                        if (idx != this.currentTabIndex){
                            this.setCurrentTab(idx);
                            // resize and position the dialog with new content
                            this.xtab.magnifier.resizeAndPosition();
                        }
                    }
                }
            },
            
            /**
             * Resolve the touch event on Xtab to the following information.
             * 1) which grid cell is tapped by user's finger?
             * 2) which xtab zone does this cell belong to?
             * 3) a rectangle area calculated based the touched position which the magnifier should not be overlapped with.
             * 
             * If we cannot find 1), we would return null as result.
             */
            resolveTouchEvent: function(touch){
                var x = touch.pageX, y = touch.pageY,
                    dom = document.elementFromPoint(x, y),
                    xtab = this.xtab, zones = xtab.zones, td, z;
                
                // go up through the dom tree
                while (dom){
                	var c = dom.className;
                    // if it's the first table cell we encounterd, remember it!
                    if (!td && dom.tagName === 'TD' && c && c.toLowerCase().indexOf('xtab-td') >= 0){
                        td = dom;
                    }
                    // if we encounter a DOM node for the xtab zone. 
                    if (/mstrmojo-XtabZone/.test(c)){
                        // try to find out which zone it is
                        for (var i in zones){
                            if (dom == zones[i].domNode){
                                z = zones[i];
                            }
                        }
                        // exit the loop
                        break;
                    }
                    dom = dom.parentNode;
                }

                // if the touched grid cell is found
                if (td && z){
                    return {
                        cell: td,
                        zone: z,
                        pos: {x: x - TOUCH_OFFSET, y: y - TOUCH_OFFSET, w: TOUCH_OFFSET*2, h: TOUCH_OFFSET*2}
                    };
                }
                
                // return null otherwise
                return null;
            },
            
            /**
             * Resolve the relevant information of the touched cell including:
             * 1) context info of the cell (row headers, column headers) 
             * 2) drill paths
             * 3) link paths
             * 
             * @param {Object} touchObj object returned by the resolveTouchEvent
             * 
             * @return null if it couldn't be resolved correctly 
             */ 
            resolveInfoToDisplay: function(touchObj){
                var td = touchObj.cell,
                    zone = touchObj.zone,
                    xtab = this.xtab,
                    lv = xtab.lockHeadersCase,
                    r = parseInt(td.getAttribute('r'), 10),
                    colTitleCell, umCells, row, i, tdIndex, 
                    si, rhc, colIdx, c, cs, i, iLen, j, jLen, k, kLen, listOfPairs = [], me = this,
                    addPair = function(title, value, isSelected){
                        if (isSelected){
                            me.selectedCell = value;

                            // make the selected row as the first row
                            listOfPairs.unshift({
                                title: title,
                                value: value
                            });
                        }else {
                            listOfPairs.push({
                                title: title,
                                value: value
                            });
                        }
                    };
                
                // first clear cached selected cell
                delete this.selectedCell;
                    
                // get the actual row index relative to the content provider of row headers or values
                if (lv == LOCK_OFF || lv == LOCK_ROW){
                    //Need to subtract the row count of column headers if they are in the same zone 
                    r = r - (Math.max(xtab.titlesCP.rc, xtab.chsCP.rc) || 0);
                }else if (zone.slot == '_TR' || zone.slot == '_TL'){
                    r = -1;
                }
                
                //We have different logic for column headers or title cells
                if (r < 0){
                    //find the title cell or the column header cell
                    colTitleCell = xtab.getCellForNode(td);
                    
                    //return null if it's a grid title
                    if (colTitleCell && colTitleCell.o !== undefined){
                        addPair(xtab.model.getCellTitleInfo(colTitleCell).title, colTitleCell, true);
                    }else {
                        return null;
                    }
                }else{
                    umCells = xtab.rhsCP.getUnmergedCells(r) || [];

                    row = {
                        rh: umCells.concat(xtab.rhsCP.getRowCells(r)),//row headers
                        vs: xtab.valuesCP.getRowCells(r),//values
                        ch: []//column headers
                    };
                   
                    for( i = 0, iLen = xtab.chsCP.rc; i < iLen; i++) {
                        row.ch.push(xtab.chsCP.getRowCells(i));
                    }
                    
                    // we use the index of table cell to determine the xtab cell's position
                    tdIndex = td.cellIndex;

                    // If the selected cell are in the same zone with row headers
                    if (lv == LOCK_OFF || lv == LOCK_COL || zone.slot == '_BL'){ 
                      //If the td is in the first row inside <tbody>, we should always ignore unmerged cells if any.(This is due to the tbody stitching)
                        if (td.parentNode.sectionRowIndex === 0){
                            si = tdIndex;
                        }else {
                            //the selected index should take unmerged headers into account
                            si = tdIndex + umCells.length;
                        }
                    }else { // Otherwise, the selected cell in the zone right to the row header zone
                        //add up the count of row headers
                        si = tdIndex + row.rh.length;
                    }
                    
                    rhc = row && row.rh.length;
                    
                    //Is the selected index is larger than the total count of row headers?
                    if (si >= rhc){
                        //It must be a metric value cell, find the relative index of the values collection 
                        si -= rhc;
                        //process column headers
                        for (j = 0, jLen = row.ch.length; j < jLen; j++) {
                            colIdx = 0;//remember the current column index
                            for (k = 0, kLen = row.ch[j].length; k < kLen; k++) {
                                c = row.ch[j][k];
                                cs = (c && c.cs) || 1; //column span
                
                                //If the selected cell falls in this column
                                if((si >= colIdx) && (si < colIdx + cs)) {
                                    if(c.mix !== undefined) { //metric value
                                        addPair(c, row.vs[si], true);
                                    } else if (c.ui != null || c.tui != null){ //col headers
                                        addPair(xtab.model.getCellTitleInfo(c).title, c); 
                                    }
                                    break;
                                }
                                // move the current column index forward
                                colIdx += cs;
                            }
                        }
                        
                        // If selected cell is not populated
                        if (!this.selectedCell ){
                            addPair(null, row.vs[si], true);
                        }
                        
                        // reset "si" so that it won't highlight any row headers.
                        si = -1;
                    }
                    
                    //process row headers from leftmost
                    for(i = 0, iLen = rhc; i < iLen; i++) {
                        c = row.rh[i];
                        addPair(xtab.model.getCellTitleInfo(c).title , c, i == si);
                        
                        //stop at the selected cell
                        if (i == si){
                            break;
                        }
                    }
                }
                
                this.cellInfo = listOfPairs;

                // If we have info to display for this cell
                if (this.cellInfo){
                    this.tabs = [];
                    
                    // Populate tabs 
                    this.tabs.push({name: TAB_INFO, label: mstrmojo.desc(10638, 'Info'), expanded: false, content: this.cellInfo});
                    
                    // TQMS 747958: Option to 'Drill' should not be available off cells that are displayed as blank.
                    var selectedCell = this.selectedCell,
                        drillable = (selectedCell.v !== undefined) && !!(selectedCell.at & 1),
                        linkable = !!(selectedCell.at & 4);
                
                    if (drillable){
                        this.drillPaths = [];
                        this.drillPaths.push({
                            n: xtab.model.getCellDrillsInfo(selectedCell).n,
                            act: xtab.model.getDrillAction([selectedCell])
                        });
                        
                        this.tabs.push({name: TAB_DRILL, label: mstrmojo.desc(145, 'Drill'), expanded: false, content: this.drillPaths});
                    }else {
                        this.drillPaths = null;
                    }
                    
                    if (linkable){
                        this.linkPaths = [];
                        var lInf = xtab.model.getCellLinksInfo(selectedCell);
                        for (var i = 0, len = lInf.links.length;i < len;i++){
                            this.linkPaths.push({
                                n: lInf.links[i].n, 
                                act: xtab.model.getLinkAction(selectedCell, i)
                            });
                        }
                        
                        this.tabs.push({name: TAB_LINK, label: mstrmojo.desc(8149, 'Link'), expanded: false, content: this.linkPaths});
                    }else{
                        this.linkPaths = null;
                    }
                }
                
                return this.cellInfo;
            },
            
            /**
             * generate the tabs on top: Info - Drill - Link
             * 
             * @param {DOM} parentNode Parent DOM node
             */
            createTitle: function(parentNode){
                var mks = [], 
                    i = 0,
                    tabs = this.tabs,
                    len = tabs.length,
                    tab, idx;
                
                for (; i < len; i++){
                    tab = tabs[i];

                    if (isTablet){
                        mks.push('<div class="', CSS_TAB_WRAPPER, ' ', tab.name, '" style="height:' + (TITLE_HEIGHT - TITLE_BORDER_HEIGHT) + 'px;" >');
                        mks.push('<div class="', CSS_TAB, '">', tab.label, '</div>');
                        mks.push('</div>');
                    } else {
                        mks.push('<div class="', CSS_SCOLL_TAB , ' ', tab.name, '" >', tab.label, '</div>');
                    }
                }
                
                parentNode.style.lineHeight = parentNode.style.height = TITLE_HEIGHT + 'px';
                parentNode.innerHTML = mks.join('');
                
                // Set the default tab to display
                this.setCurrentTab();
            },
            
            /**
             * generate the content to display: cellInfo, drill paths(optional), links(optional)
             * 
             * @param {DOM} parentNode Parent DOM node
             */
            createContent: function(parentNode){
                var info = this.cellInfo, 
                    drillPaths = this.drillPaths,
                    linkPaths = this.linkPaths,
                    mks = [], rows = [],
                    xtab = this.xtab,
                    addPair = function(l, r, selected) {
                        function _cellMarkup(c, cs) {          
                            var cmk = [],
                                lineHeight = (cs === 'value' && !isTablet) ? CONTENT_LINE_HEIGHT/2 : CONTENT_LINE_HEIGHT;
                            
                            cmk.push('<td><div class="', cs, '" style="line-height:', lineHeight, 'px;max-height:', CONTENT_LINE_HEIGHT, 'px;" >');
                            
                            if (c){
                                if (c.ts == 4){ // Image
                                    var imgURL = (c.n || c.v),
                                        ds = xtab.controller && xtab.controller.model && xtab.controller.model.dataService;
                                    if ( ds && ds.getImage ) {
                                        imgURL = ds.getImage(imgURL);
                                    }
                                    cmk.push('<img src="' + imgURL + '"/>');
                                }else{
                                    cmk.push(c.n || c.v || '&nbsp;');
                                }
                            }
                            
                            cmk.push('</div></td>');
                            return cmk.join('');
                        };
                        rows.push('<tr style="height:', CONTENT_LINE_HEIGHT, 'px">', _cellMarkup(l, 'title'), _cellMarkup(r, 'value'), '</tr>');
                    },
                    i, len;
                    
                // no info ? do not proceed any further
                if (info == null){
                    return;
                }
                
                // create the content for info tab
                for (i = 0, len = info.length; i < len; i++){
                    addPair(info[i].title, info[i].value);
                }
                mks.push('<table class="content">');
                mks.push(rows.join(''));
                mks.push('</table>');
                
                // create the content for drill/link tab if the cell is drillable/linkable
                // TODO: refactoring later when multiple drill paths supported
                if (drillPaths){
                    mks.push('<div class="actionMenu hide">');
                    for (var i = 0, len = drillPaths.length; i < len; i++){
                        mks.push('<div class="drillTo" style="line-height:', CONTENT_LINE_HEIGHT, 'px">', drillPaths[i].n, '</div>');
                    }
                    mks.push('</div>');
                }
                
                if (linkPaths){
                    mks.push('<div class="actionMenu hide">');
                    for (var i = 0, len = linkPaths.length; i < len; i++){
                        mks.push('<div class="linkTo" style="line-height:', CONTENT_LINE_HEIGHT, 'px" lnk="', i, '">', linkPaths[i].n, '</div>');
                    }
                    mks.push('</div>');
                }
                mks.push('<div class="', CSS_SHOW_ALL, '" style="line-height:', CONTENT_LINE_HEIGHT, 'px" >' + mstrmojo.desc(8995, 'See all...') + '</div>');
                
                parentNode.innerHTML = mks.join('');  
            },

            /**
             * Configure the current tab.
             * 
             * @param {Integer} idx The current tab index
             */
            setCurrentTab: function(idx){
                var tabIndex = idx || 0,
                    tabs = this.tabs,
                    tab = tabs[tabIndex],
                    tabLen = tabs.length,
                    magnifier = this.xtab.magnifier,
                    tabs = magnifier.titleNode.children,
                    contents = magnifier.containerNode.children,
                    i, len, contentInfo;
                
                this.currentTabIndex = tabIndex;
                
                // find the selected tab
                for (i = 0 ; i < tabLen; i++){
                    $CSS.toggleClass(tabs[i], 'selected', i == tabIndex);
                    
                    if (!isTablet){
                        if (tabLen <= 2){
                            $CSS.toggleClass(tabs[i], 'left', i != tabIndex);
                        }else {
                            $CSS.toggleClass(tabs[i], 'left', i == (tabIndex + tabLen - 1) % tabLen);
                        }
                        $CSS.toggleClass(tabs[i], 'right', i == (tabIndex + tabLen + 1) % tabLen);
                    }
                }
                
                // display the content for the selected tab and hide others
                for (i = 0, len = contents.length - 1; i < len; i++){
                    $CSS.toggleClass(contents[i], 'hide', i != tabIndex);
                    
                    if (i == tabIndex){
                        this.contentNode = contents[i];
                    }
                }
                
                // if current tab has not been expanded yet and it contains more than 3 entries
                $CSS.toggleClass(magnifier.containerNode, 'hideMore', !tab.expanded && tab.content.length > MAX_ENTRIES);
            },
            
            
            /**
             * @return the height of the display content 
             */
            getContentHeight: function(){
                function calculateHeight(tab){
                    var content = tab.content,
                        entryNum = content.length,
                        expanded = tab.expanded;
                    // If the tab is not expanded and the content contains more than 4 entries
                    return (!expanded && entryNum > MAX_ENTRIES) ? (CONTENT_LINE_HEIGHT + 1) * (MAX_ENTRIES + 1) : (CONTENT_LINE_HEIGHT + 1) * entryNum;
                }
                
                var tabs = this.tabs;
                
                if (isTablet){
                    return calculateHeight(tabs[this.currentTabIndex]);
                }else{
                    var max = 0;
                    for (var i = 0, len = tabs.length; i < len; i++){
                        max = Math.max(calculateHeight(tabs[i]), max);
                    }
                    return max;
                }
            }
        });
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.TouchScroller");
            
    
    var OFFSET_PROP = {
        v: {
            axis: 'y',
            dimension: 'height'
        }, 
        h: {
            axis: 'x',
            dimension: 'width'
        }
    };

    /**
     * <p>A mixin that adds incremental fetch functionality to subclasses of {@link @mstrmojo.ListBase}.</p>
     *
     * @class
     * @public
     */
    mstrmojo.android._IsIncFetchList = mstrmojo.provide(

        "mstrmojo.android._IsIncFetchList",

        /**
         * @lends mstrmojo.android._IsIncFetchList.prototype
         */
        {
            _mixinName: 'mstrmojo.android._IsIncFetchList',

            /**
             * Supports incremental fetch.
             *
             * @ignore
             */
            supportsIncFetch: true,

            /**
             * This property should be set to a data helper that provides an interface for the widget to get the next block of data.
             */
            ifDataHelper: null,
            
            /**
             * Determines the direction on which the incremental fetch occurs.
             * 
             * @type String
             * @default 'v'
             * Other possible values: 'h'
             */
            ifDirection: 'v',
            
            /**
             * Determines the edges on which incremental fetch should be triggered. 
             * 
             * @default 2 Only at the end.
             */
            supportedEdges: mstrmojo.TouchScroller.EnumIncFetchEdges.end,

            /**
             * Overridden to attach an event listener to the scroller for incremental fetch.
             *
             * @ignore
             */
            initScroller: function initScroller(scroller) {
                this._super(scroller);

                // Does the list have a data helper?
                var dataHelper = this.ifDataHelper;
                if (dataHelper) {
                    // Attach an event listener on the scroller whenever it needs more data...
                    scroller.attachEventListener('incFetch', this.id, function (evt) {
                        // Do we NOT support incremental fetch right now?
                        if (!this.supportsIncFetch) {
                            // Nothing to do.
                            return;
                        }
                        
                        // Get the next block of data from the data helper.
                        var me = this;
                        dataHelper.next({
                            success: function (e, items) {
                                me.addItems(items || e.items);
                                me._scroller.STATUS_INC_FETCH = false;
                            },

                            failure: function (res) {
                                mstrmojo.alert("Error in fetching next: " + res);
                            }
                        }, evt.edge);
                    });
                }
            },

            /**
             * Overridden to update scroller config with incremental fetch properties.
             *
             * @ignore
             */
            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    incFetch = this.supportsIncFetch,
                    dir = this.ifDirection,
                    offsetProp = OFFSET_PROP[dir];

                // Can the list scroll?
                if (cfg[dir + 'Scroll']) {
                    var offset = cfg.offset[offsetProp.axis];

                    // Set the incremental fetch properties.
                    offset.incFetch = incFetch;
                    offset.supportedEdges = this.supportedEdges;
                    offset.pageSize = incFetch ? (parseInt(this[offsetProp.dimension], 10) - 100) : 0;

                    // Store the configuration back on the instance.
                    this.scrollerConfig = cfg;
                }

                return cfg;
            },

            /**
             * Overridden to render new markup and update scroller.
             *
             * @ignore
             */
            addItems: function addItems(items) {
                // Call super.
                this._super(items);

                // Do we need to fetch more elements? Set the incremental fetch flag appropriately
                this.supportsIncFetch = ((this.ifDataHelper.totalSize === -1) || (this.items.length < this.ifDataHelper.totalSize));

                // Do we have a scroller?
                if (this.updateScroller) {
                    // Update the scroller config.
                    this.updateScroller();
                }
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.array",
                         "mstrmojo.StringBuffer",
                         "mstrmojo.ResSetLink");
    
    var ROW_AXIS = 1,
        COL_AXIS = 2;
    
    var ATTRIBUTE_SORT = 2,
        COLUMN_SORT = 4;
    
    var DRILLING_ACTION = 1,
        HYPERLINK_ACTION = 4;
    
    
    /**
     * Utility function to retrieve the axis from the grid titles collection.
     * 
     * @param {Object} gts The grid titles collection.
     * @param {Integer} ax The axis to retrieve (1 = rows, 2 = columns).
     * 
     * @private
     * @returns Object[]
     */
    function getTitlesAxis(gts, ax) {
        return gts[((ax === ROW_AXIS) ? 'row' : 'col')];
    }
    
    function getCellLinksContainer(cell, title) {
        var linkMap = title.lm;
        
        // If the cell has a metric index (for metric values), we need to look at the linksContainer at the corresponding index under the title. 
        return linkMap && linkMap[cell.mix || 0];
    }
    
    function getCellDrillsContainer(cell, title) {
        var drillList = title.dp;
        
        return drillList && drillList[cell.mix || 0];
    }
    
    
    function buildLink(linksContainer, linkInfo, cell) {
        var link = new mstrmojo.ResSetLink({
            mid: this.getMessageId(),
            srct: 2,
            aopam: linkInfo.daMode
        });          
        // Get the answers info. 
        var answers = linkInfo.ans,
            answerCnt = answers && answers.length;
          
        if (answerCnt) {
            
            // Add prompts node. 
            var prms = link.prms = [],
                i = 0;

            for (i = 0; i < answerCnt; i++) {
                var answer = answers[i];
                  
                // Prompt ID, answermode, prompt type.
                var pid = answer.pid,
                    am = parseInt(answer.m, 10),
                    prm = {
                        id: pid,
                        am: am,
                        //TQMS 625468 We need to know target prompt type to build proper link XML 
                    	pt: answer.pt
                    };
                prms.push(prm); 
                if (answer.po) {
                    prm.orid = answer.po.did;
                    prm.ortp = answer.po.t;
                }
                  
      
                // How should we answer the prompts?
                switch (am) {
                    case link.DO_NOT_ANSWER:
                    case link.CLOSE:
                    case link.USE_DEFAULT_ANSWER:
                    case link.SAME_PROMPT:
                        break;
                          
                    case link.STATIC:
                        var statElems = answer.es,
                        staticLen = (statElems && statElems.length) || 0,
                        z;

                        prm.pa = {
                            es:[]        
                        };
                    for (z = staticLen - 1; z >= 0; --z) {
                            var statElem = statElems[z];
                            prm.pa.es.push({
                                ei: statElem.id,
                                disp_n: statElem.n,
                                emt: 1
                            });
                        }
                          
                        break;
                          
                    case link.DYNAMIC:
                    case link.ALL_VALID_UNITS:
                    case link.CURRENT_UNIT:
                        var dynUnits = answer.dunits;       // Dynamic units.
                        if (dynUnits && dynUnits.length && cell) {
                            var pa = prm.pa = {};

                            // We want to traverse the current cell and its parent to pick up the dynamic ancestors of dynamic units configured.
                            var pCell = cell,
                                // Has the link originated from a metric value ? If so, it would have a metric index (metric headers would have that too !) AND it would have left and top parents. 
                                isMetricValue = (cell.mix !== undefined) && (cell._lp || cell._tp);
                                  
                                // For metric value, we will first start looking at the parent row headers, then the col headers. 
                                if (isMetricValue) {
                                    // Start with the row headers (leftParent), then the row headers. 
                                    // If there's no left parent, we start with the top parent itself.  
                                    pCell = cell._lp || cell._tp;
                                }
                                  
                        var axis = parseInt(pCell.axis, 10);
                                while (pCell) {
                                    // Update parent title.
                                	  var pTitle = this.getPTitle(pCell, axis); 

                                    // Is the title in the dynamic units collection. 
                                    if (pTitle && mstrmojo.array.find(dynUnits, 'id', pTitle.id) >= 0) {
                                    if (am !== link.DYNAMIC) {
                                        pa.a = {
                                            id: pTitle.id,
                                            n: pTitle.n,
                                            dispForms: pTitle.dfi
                                        };
                                    }
                                    if ( answer.pt === 1 ) {//Constant
                                        //TQMS 625468 We need to pass cell value for constant prompts 
                                    	pa.v = pCell.v;
                                    	break;
                                    } else {
                                        // ID of the current cell.  
                                        var eid = pCell._e.id,
                                            dsn = pCell._e.n; // display name
                                        
                                        pa.es = [];
                                        pa.es.push({
                                            ei: eid,
                                            emt: 1,
                                            disp_n: dsn 
                                        });
                                    }
                                    
                                    if (am === link.CURRENT_UNIT) {
                                            break;
                                        }
                                    }

                                    // next parent. cell/
                                   pCell = this.getPCellParentNode(pCell, axis);
                                    
                                    // For metrics, if we don't find a parent cell in the row headers, we should switch over to the col headers.  
                                    if (isMetricValue && !pCell && axis === ROW_AXIS) {
                                        // Update the axis. 
                                        axis = COL_AXIS;
                                          
                                        // First top parent of the metric value. note - We find that using the original cell NOT pCell. 
                                        pCell = cell._tp;
                                    }
                                }
                        }
                        break;
                }
            }
        }
        return link;
    }
        
    /**
     * Returns a comma delimited string of drill elements.
     * 
     * @param {Object} cells The interactive cells for the html table cell that initiated the drill.
     * 
     * @private
     */
    function getDrillElements(cells) {
        var titleInfo = this.getCellTitleInfo(cells[0]),
            elements = [],
            fnAddCell= function (cell) {
                if (cell) {
                    if ( mstrApp.useBinaryFormat ) {
                    	if ( cell._e ) {
	                        elements.push(cell.axis + 'A' + (cell.ui + 1) + 'A' + cell._e.id);
                    	}
                        fnAddCell(cell._p);
                    } else {
                        elements.push(cell.axis + 'A' + (cell.ui + 1) + 'A' + cell.o);
                    }
                }
            },
            i,
            len;
        
        if (!titleInfo.isSrcTitle) {            
            for (i = 0, len = cells.length; i < len; i++) {
                var c = cells[i];            
                // Is this a metric value?
                if (c.mix !== undefined && (c._lp || c._tp)) {
                    fnAddCell(c._lp);
                    fnAddCell(c._tp);
                } else {
                    fnAddCell(c);
                }
            }
        }

        return (mstrApp.useBinaryFormat) ? elements : elements.join(',');
    }
    
    /**
     * <p>A model for handling Xtab interactivity.</p>
     * 
     * @class
     * @extends mstrmojo.Obj
     */
    mstrmojo.XtabModel = mstrmojo.declare(
        mstrmojo.Obj,
        
        null,
        
        /** 
         * @lends mstrmojo.XtabModel.prototype
         */
        {            
            scriptClass: "mstrmojo.XtabModel",
            
            getMessageId: function getMessageId() {
                return this.data.mid;
            },
            
            /**
             * Retrieves title information for a given cell node.
             * 
             * @param {Object} cell The interactive cell.
             * @param {Object} [dataBlock] The data block the title belongs to.
             * @returns {Object} An object with the title and a boolean (isSrcTitle) indicating if this is the src title.
             */
            getCellTitleInfo: function getCellTitleInfo(cell, dataBlock) {
                var gts = dataBlock ? dataBlock.gts : this.data.gts;
                
                // No ordinal => Title cell.   
                // TODO: For now its a reasonable assumption that if cell doesn't have an ordinal, its Title. Eventually, when we put support for 
                // metrics, we may need a cell type to help classify. Would be best if we can avoid adding extra properties though and infer type 
                // using the existing cell properties. 
                var title = null;
                
                // Is the cell a metric value cell? (inferred using property -> mix [metricIndex]). If not, we can use the (axis, ui) on the cell to reach the title.    
                if (cell.mix === undefined) {
                    title = getTitlesAxis(gts, cell.axis)[cell.tui || cell.ui];
                    
                } else {
                    
                    // We will need to find the Metric title. Object type is -1 for Metrics Title. 
                    var findMetricTitle = function(titles) {
                        var len = (titles && titles.length) || 0,
                            i;

                        for (i = len - 1; i >= 0; --i) {
                            if (parseInt(titles[i].otp, 10) === -1) {
                                // Found.
                                return titles[i];
                            }
                        }
                        
                        // Not found.
                        return null;
                    };
                    
                    // Search for the metrics title in column axis followed by the row axis. 
                    title = findMetricTitle(gts.col) || findMetricTitle(gts.row); 
                }
                
                return {
                    isSrcTitle: (cell.o === undefined), 
                    title: title
                };            
            },
            
            /**
             * Retrieves links information for a given data cell.  The title data can be passed in as
             * an optional argument as a performance optimization; if missing, it is looked up in the xtab data.
             */
            getCellLinksInfo: function getCellLinksInfo(cell, title) {
                if (!title) {
                    var titleInfo = this.getCellTitleInfo(cell);
                    title = titleInfo && titleInfo.title;
                }
                
                return getCellLinksContainer(cell, title);
            },

            /**
             * Retrieves drills information for a given data cell.  The title data can be passed in as
             * an optional argument as a performance optimization; if missing, it is looked up in the xtab data.
             * 
             */
            getCellDrillsInfo: function getCellDrillsInfo(cell, title) {
                if (!title) {
                    var titleInfo = this.getCellTitleInfo(cell);
                    title = titleInfo && titleInfo.title;
                }
                return getCellDrillsContainer(cell, title);
            },
            
            getLinkDrillAction: function getLinkDrillAction(cells) {
                return this.getActionObject(cells);
            },

            getAction: function getAction(cells) {
                return this.getActionObject(cells);
            },

            getActionObject: function getActionObject(cells) {
                var actionType = cells[0] && cells[0].at,
                    _rtn = null;

                // Resolve what the action should be.
                if (actionType) {
                    // Is this a hyperlink action?
                    if (actionType & HYPERLINK_ACTION) {
                        _rtn = {
                            h: 'onLink',
                            a: this.getLinkAction(cells[0])
                        };
                        
                    // Is this a drilling action?
                    } else if (actionType & DRILLING_ACTION) {
                        _rtn = {
                            h: 'onDrill',
                            a: this.getDrillAction(cells)
                        };
                    }
                }
                
                return _rtn;
            },
            
            /**
             * Returns an object containing sorting information for the supplied cell.
             * 
             * @param {Object} cell The interactive cell for the title or metric header that is being sorted.
             * @param {Boolean} isAsc TRUE if the sort should be ascending.
             * 
             * @returns Object An object containing the action values.
             */
            getSortAction: function getSortAction(cell, isAsc) {
                var titleInfo = this.getCellTitleInfo(cell),
                    title = titleInfo.title,
                    subTotalsPos = this.data.gts[((cell.axis === ROW_AXIS) ? 'row' : 'col') + 'SubPos'],
                    elems = [],
                    unitAxis = title.axis,
                    sortType,
                    unitID,
                    unitType,
                    formId;
                
                // If isAsc is not specified, toggle the current sort order.
                isAsc = (isAsc === null || isAsc === undefined) ? !(cell && cell.so) : isAsc;
                
                // Is this a title?
                if (titleInfo.isSrcTitle) {
                    sortType = ATTRIBUTE_SORT;
                    unitID = title.id;
                    unitType = title.otp;
                    formId = title.fid;
                    
                } else {
                    // Must be a metric header.
                    sortType = COLUMN_SORT;
                    unitType = 4;
                    unitAxis = ROW_AXIS;
                    subTotalsPos = this.data.gts.rowSubPos;
                    
                    // Metric header uses objectID instead of elementID. We use that to find the metric header element.
                    // If the current element is an attribute header, we need to start building the elements collection from this element itself.
                    do {
                        // Does the current cell have an element?
                        var e = cell._e;
                        if (e) {
                        // Have we found a metric ? If yes, the unitID is the metric Id. 
                        if (e.oid) {
                            unitID = e.oid;
                            
                        } else {
                            // Add the current cell's element to our sort filter.
                            elems.push(e.id);
                            
                        }                
                        }
                        
                        // Next parent.  
                        cell = cell._p;
                        
                    } while (cell);
                }
                
                // Create action.
                var action = {
                    sortType: sortType,
                    axis: unitAxis, 
                    isAsc: isAsc, 
                    unitID: unitID, 
                    unitType: unitType, 
                    elementList: elems.join('\u001E'), 
                    subTotalsPos: subTotalsPos
                };
                
                // Do we have a unit ID?
                if (unitID) {
                    // Add it to action.
                    action.unitID = unitID;
                }

                // Do we have a form ID?
                if (formId) {
                    // Add it to action.
                    action.formId = formId;
                }
                
                // Build the sort key.
                var sortKey;
                if (sortType === COLUMN_SORT) {
                    sortKey = [ '', '', action.elementList || '', action.axis ];
                } else {
                    sortKey = [ action.formId, '21' ];
                }
                sortKey = [ action.unitType, action.unitID ].concat(sortKey);
                action.sortKey = sortKey.join('!');
                
                // Return action.
                return action;

            },
            
            /**
             * Returns an object containing sorting information for the supplied cell.
             * 
             * @param {Object} cell The interactive cell for the title or metric header that is being pivoted.
             * @param {String} btn The ID of the pivot button that was clicked.
             * 
             * @returns Object An object containing the action values.
             */
            getPivotAction: function getPivotAction(cell, btn) {
                var isForm = false,                                // Assume it's not an attribute form.
                    isMetric = cell.hasOwnProperty('mix'),         // Is this a metric?
                    ax = (isMetric) ? null : cell.axis,            // Target axis
                    pos = ((isMetric) ? cell.mix : cell.ui) + 1,   // Target depth (one based).
                    isMT = (cell.otp === -1);                      // Is this the metric title?
                
                // Is this a cross axis button (to columns or to rows).
                if (!isNaN(btn)) {
                    ax = btn;           // The key of the button is the id of the target axis.
                    pos = 1;            // Move to first position of target axis.
                    
                    // Is the cell a metric header?
                    if (isMetric) {
                        isMetric = false;   // Since it's cross axis we are not pivoting a metric...
                        isMT = true;        // we are pivoting the metric title.
                    }
                    
                } else {
                    // Is the operation a decrement (button was 'up' or 'left')?
                    var dec = (btn === 'u' || btn === 'l');
    
                    // Is this NOT a metric?
                    if (!isMetric) {
                        
                        var axis = getTitlesAxis(this.data.gts, ax),        // Source axis for this pivot.
                            cnt = 0,                                        // Unit counter.
                            info = {},                                      // Info object to hold information about the contents of this axis.
                            bCur = false;                                   // Flag to indicate that we've found the current unit on the axis.
                        
                        // Create an object with information about actual position and number of forms.
                        mstrmojo.array.forEach(axis, function (u) {
                            // Have we encountered this unit yet?
                            if (info[u.id]) {
                                // Yes, then update the form count.
                                info[u.id].frm++;
                                
                            } else {
                                // No, then increment the unit counter...
                                cnt++;
                                
                                // and add to the info.
                                info[u.id] = {
                                    pos: cnt,
                                    frm: 1
                                };
                                
                                // Is this the pivoted unit?
                                if (u.id === cell.id) {
                                    // Set the flag to indicate that we've found the unit.
                                    bCur = true;
                                } else if (bCur) {
                                    // We have moved beyond the pivoted unit so there is no reason to continue.  Return FALSE to stop the iteration.
                                    return false;
                                }
                            }
                            
                        });
                        
                        // Reset position to the calculated position.
                        pos = info[cell.id].pos;
    
                        // Check for an attribute form index.
                        var fix = cell.fix;
                        if (fix) {
                            
                            // Is the action NOT a decremental pivot or is this form NOT the first one for the attribute?
                            if (!dec || fix > 1) {
                                // Is the action a decremental pivot or is this NOT the last form for the attribute?
                                if (dec || fix !== info[cell.id].frm) {
                                    // Reset the position to the attribute form index.
                                    pos = fix;
                                    
                                    // Set the isForm flag to indicate that we are pivoting within the attribute.
                                    isForm = true;
                                }
                            }
                        }
                    }
                    
                    // Calculate the new position.
                    pos = pos + ((dec) ? -1 : 1);
                }
                
                // Create the action object.
                var action = {
                    pos: pos        // Target axis depth
                };
                
                // Is this a form?
                if (isForm) {
                    // Add the attribute form ID.
                    action.formID = cell.fid;
    
                } else if (!isMetric) {
                    // Add the axis for non metric and non attribute form units.
                    action.axis = ax;
                }
                
                // Is this not the metric title?
                if (!isMT) {
                    // Reset the source to the element if this is a metric.
                    var mSrc = (isMetric) ? cell._e : cell;
                    
                    // Add the object type for non forms.
                    if (!isForm) {
                        action.objectType = mSrc.otp;
                    }
                    
                    // Add the object ID.
                    action.objectId = (isMetric) ? mSrc.oid : cell.id;
                }
                
                return action;
            },
            
            /**
             * Determines if a given pivot button should be visible based on the selected cell.
             * @param {Object} c The selected cell.
             * @param {String} btn The ID of the button.
             * 
             * @type Boolean
             */
            isPvtButtonVisible: function isPvtButonVisible(c, btn) {
                var ax = c.axis,                                         // Axis value.
                    axis = getTitlesAxis(this.data.gts, ax),             // Unit axis.
                    isMetric = c.hasOwnProperty('mix');
                
                // Is this a cross axis button (to columns or to rows).
                if (!isNaN(btn)) {
                    // Is the target axis the same as the current axis?
                    if (parseInt(btn, 10) === ax) {
                        return false;
                    }
                    
                    // Is this a metric header?
                    if (isMetric) {
                        // True if the metrics template unit is hidden.
                        return !!axis[c.ui]._hid;
                    }
                    
                    // Must be visible.
                    return true;
                }
    
                var es = axis[c.ui].es,                           // Element collection
                    pos = c.ui,                                   // Unit depth.
                    len = (isMetric) ? es.length : axis.length;   // Length of unit axis.                        
                    
                // Is there only one unit on this axis?
                if (len === 1) {
                    // Don't need any within axis pivot buttons if there is only one unit.
                    return false;
                }
                        
                // Are cells on this axis laid out horizontally?
                if (ax === ((isMetric) ? COL_AXIS : ROW_AXIS)) {
                    // Eliminate 'up' and 'down' buttons.
                    if (btn === 'u' || btn === 'd') {
                        return false;
                    }
                } else {
                    // Otherwise, eliminate 'left' and 'right' buttons.
                    if (btn === 'l' || btn === 'r') {
                        return false;
                    }
                }
                
                // Is this the first unit on the axis?
                if ((isMetric) ? c._e === es[0] : pos === 0) {
                    // Eliminate left and up buttons.
                    if (btn === 'l' || btn === 'u') {
                        return false;
                    }
                }
                    
                // Is this the last unit on the axis?
                if (isMetric ? c._e === es[len - 1] : pos === len - 1) {
                    // Eliminate right and down buttons.
                    if (btn === 'r' || btn === 'd') {
                        return false;
                    }
                }
                
                // Passed all tests so it must be visible.
                return true;
            },
            
            /**
             * Gets drill information for the Drills from the template unit supplied.
             * 
             * @param {Array} cells The interactive cells for the html table cell that initiated the drill.
             */
            getDrillAction: function getDrillAction(cells) {
                var titleInfo = this.getCellTitleInfo(cells[0]),
                    title = titleInfo.title,
                    drillPath = title.dp[cells[0].mix || 0];
                
                return {
                    srcMsgId: this.data.mid,
                    isWithin: drillPath.within,
                    drillPathKey: drillPath.k,
                    drillPathIndex: drillPath.dpi,
                    drillElements: getDrillElements.call(this, cells)
                };
            },
            
            getPTitle: function getPTitle(pCell, axis){
            	var gts = this.data.gts;
           		return getTitlesAxis(gts, axis)[pCell.tui];
            },
            
            getPCellParentNode: function getPCellParentNode(pCell, axis){
            	 // todo2 - how about having _lp and _tp on each header also instead of _p for header and _lp, _tp for metric values ?                 
            	return pCell._p;
            },
                        
            /**
             * Returns an action object describing the link action.
             * 
             * @param {Object} cell The interactive cell for the html table cell that initiated the link.
             * @param {Integer} [idx] The index of the selected link (if omitted we will use the defined default link).
             * 
             */
            getLinkAction: function getLinkAction(cell, idx) {
                var titleInfo = this.getCellTitleInfo(cell),
                    title = titleInfo.title;                
                return this.getLinkActionImpl(cell, title, idx);
            },
            
            getLinkActionImpl: function getLinkActionImpl(cell, title, idx) {
                var linksContainer = getCellLinksContainer(cell, title),    // Assume attribute links for now (no metric links).
                    linkArray = linksContainer && linksContainer.links,
                    linkTarget = (linksContainer.onw) ? '_blank' : '';
                
                // If link idx was not given, use the default link index, or if none, the first link.
                if (idx === null || idx === undefined) {
                    // add "|| 0" to fix #702888
                    idx = (linksContainer && linksContainer.di) || 0;    // di => default (link) index.
                }
                
                // Do we have a link info?
                var linkInfo = linkArray && linkArray[idx];           
                if (!linkInfo) {
                    // None, so return null action object.
                    return null;
                }
                
                // Create action.
                var action = {
                    linkInfo: linkInfo,
                    linkTarget: linkTarget
                };
                
                // Does the link info contain a url?
                var url = linkInfo.url;
                if (url) {
                    // Replace current element with the element id for the cell that was selected.
                    var currentElement = '&CurrentElement';
                    if (cell && title && url.indexOf(currentElement) > -1) {
                        url = url.replace(currentElement, cell._e.id);
                    }

                    // Add url.
                    action.url = url;

                } else {
                    
                    var target = linkInfo.target,
                        evt,
                        idField;
                    
                    // What type is the target?
                    switch (parseInt(target && target.t, 10)) {
                        case 55:                // DSSTYPE_DOC_DEFINITION
                            // Execute a doc.
                            if (parseInt(target.st, 10) === 14081) { //  DSSSUB_TYPE_RW
                                // Execute an RW document
                                evt = 2048001;   // RUN_RW_DOCUMENT
                                idField = 'objectID';

                            } else {
                                // Execute an HTML document.
                                evt = 32001;   // RUN_DOCUMENT
                                idField = 'documentID';
                            }
                            break;
                            
                        case 3:                 // DSSTYPE_RPT_DEFINITION
                            // Execute a report.
                            evt = 4001;         // RUN_REPORT
                            idField = 'reportID';
                            
                            // subtype 301 (EnumDssXmlObjectSubTypes) => Graph view mode (EnumWebViewModes) otherwise Grid mode.  
                        action.reportViewMode = ((parseInt(target.st, 10) === 0x301) ? 2 : 1);
                            break;
                            
                        default: 
                            // Unhandled.
                            return null;
                    }
                    
                    // Update action.
                    action.evt = evt;
                    action[idField] = target.did;
                    action.srcMsgId = this.getMessageId();
                    
                    // Add answers xml.
                    var link = buildLink.call(this, linksContainer, linkInfo, cell);
                    if (link) {
                        action.link = link;
                    }
                    //var answerXML = buildLinkXml.call(this, linksContainer, linkInfo, cell);
                    //if (answerXML) {
                    //    action.linkAnswers = answerXML;
                    //}
                    
                    return action;
                }
            },
            
            /**
             * @param {Integer} rowPosition
             * @param {Integer} maxRows
             * @param {Integer} colPosition
             * @param {Integer} maxCols
             * @param {String} widgetID
             * @param {Object} memo
             * 
             */
            getDownloadAction: function getDownloadAction(rowPosition, maxRows,  colPosition, maxCols, widgetID, memo) {
                return {
                    xtabId: widgetID,
                    rowPosition: rowPosition,
                    maxRows: maxRows,
                    colPosition: colPosition,
                    maxColumns: maxCols,
                    memo: memo
                };
            }
        }
    );
}());
(function() {
    
    mstrmojo.requiresCls("mstrmojo.DocDataService");
    
    function _getCacheSrcIfExists(src, imc, imgKey) {
        if(imc && imc.cachedImg[imgKey]) {
            return imc.baseURL + imc.cachedImg[imgKey];
        } else {
            if(!imc.unCachedImg[imgKey]) {
                imc.unCachedImg[imgKey] = src;
            }
            return src;
        }
    }
    
    mstrmojo.iPhoneDocDataService = mstrmojo.declare(
            mstrmojo.DocDataService,
            null,
            {
                scriptClass: "mstrmojo.iPhoneDocDataService",
                
                imgCache: null,
                
                getRWGraphImage: function getRWGraphImage(params, callback) {
                    var imgKey =  params.k + "," + parseInt(params.sid, 10) + ","  + params.gbk + "," + this.msgId,
                        imc = this.imgCache;
                    //overriding callback
                    this._super(params, { 
                        success: function(src) {
                            callback.success(_getCacheSrcIfExists(src, imc, imgKey));
                         }
                    });
                    
                },
                
                getDocImage: function(url) {
                    var imgKey = url && url.replace(/\\/g, '/'),
                    imc = this.imgCache;
                    return _getCacheSrcIfExists(url, imc, imgKey);
                }
            }
        );
})();
(function(){

    mstrmojo.requiresCls("mstrmojo.StepperContentProvider");
    
    /**
     * Has previous and has next helper method.
     * 
     * @param {mstrmojo.NumStepperContentProvider} cp The content provider 
     * @param {String} direction The direction for which the next or previous value exists needs to be checked (true - next, false - previous)
     * 
     * @return {Boolean} Whether the user has access to go next or previous.
     */
    function has(cp, direction) {
        //Initialize to arbitrary variables
        var boundary = direction ? cp.max : cp.min,
            altBoundary = direction ? cp.min : cp.max,
            newVal = cp.getVal(direction ? 1 : -1);
        
        return (//Is it Infinite?
                boundary === null ||
                //Is it within the provided range?
                (direction ? (newVal <= boundary) : (newVal >= boundary)) ||
                //Can the stepper loop?
                (altBoundary !== null && cp.canLoop));
    }
    
    /**
     * Helper method to provide the value to the stepper when it moves next or previous.
     * 
     * @param {mstrmojo.NumStepperContentProvider} cp The content provider 
     * @param {String} direction The direction for which the next or previous value exists needs to be checked (true - next, false - previous)
     */
    function traverse(cp, direction) {
        var min = cp.min,
            max = cp.max,
            multiplier = direction ? 1 : -1,
            newVal = cp.getVal(multiplier),
            loop = cp.canLoop,
            isOutOfBounds = direction ? (max !== null && newVal > max) : (min !== null && (newVal < min));
        
        //Would we be out of bounds if we adjusted the current value?
        if(isOutOfBounds) {
            //Yes, its out bounds. Can we loop?
            if (loop) {
                newVal = ((newVal - min) % (max - min + 1)) + min;
                newVal = (newVal >= min) ? newVal : newVal + (max - min + 1); // when decrease the modulo may be negative, bring it into the range. 
            } else {
                return;
            }
        }
        
        //Adjust the curval by the interval.
        cp.curVal = newVal;
        
        //Set the value field
        cp.item[cp.valField] = cp.curVal;
        
        //Customized hook up
        if (cp.onTraverse){
            cp.onTraverse();
        }
    }
    
    /**
     * This widget acts as a numeric content provider for the MicroStrategy Mojo widget mstrmojo.Stepper.
     * 
     * @class
     * @extends mstrmojo.StepperContentProvider
     */
    mstrmojo.NumStepperContentProvider = mstrmojo.declare(
        // superclass
        mstrmojo.StepperContentProvider,
        
        // mixins
        null,
        
        // instance members 
        {
            scriptClass: "mstrmojo.NumStepperContentProvider",
            
            curVal: null,
            
            /**
             * @see mstrmojo.Obj
             */
            init: function(props){
                //Call super.
                this._super(props);
                
                //Initialize the properties.
                this.initProps(props);
            },
            
            /**
             * Initializes the properties for the stepper's content provider. This method reads the values from the value field and makes copies 
             * of the current value, min and max.
             */
            initProps: function initProps() {
                var minVal = this.isInfinite(this.minField)?  null:this.item[this.minField],
                    maxVal = this.isInfinite(this.maxField)?  null:this.item[this.maxField];
                    intVal = this.item[this.intField];
                
                if(minVal !== null && typeof minVal !== undefined) {
                    this.min = minVal;
                }

                if(maxVal !== null && typeof maxVal !== undefined) {
                    this.max = maxVal;
                }
                    
                if(intVal !== null && typeof intVal !== undefined) {
                   this.interval = intVal;
                }
                
                this.curVal = this.item[this.valField];
                if( this.curVal === null || typeof this.curVal === 'undefined') {
                    //Initialize the current value.
                    this.curVal = (this.min !== null) ? this.min : 0;
                }
            },
            
            /**
             * Returns whether the stepper is an infinite stepper. The stepper can be infinite in one direction. It can be acheived by not setting
             * the min and max values for the stepper.
             * 
             * @return Boolean Whether the stepper is infinte.
             */
            isInfinite: function isInfinite(fieldName){
                return (typeof fieldName === 'undefined' || fieldName === null || this.item[fieldName] === null || typeof this.item[fieldName] === 'undefined');
            },
            
            /**
             * @see mstrmojo.StepperContentProvider
             */
            next: function(){
                traverse(this, true);
            },
            
            /**
             * @see mstrmojo.StepperContentProvider
             */
            prev: function(){
                traverse(this, false);
            },
            
            /**
             * @see mstrmojo.StepperContentProvider
             */
            hasPrev: function(){
                return has(this, false);
            },
            
            /**
             * @see mstrmojo.StepperContentProvider
             */
            hasNext: function(){
                return has(this, true);
            },
            
            /**
             * @see mstrmojo.StepperContentProvider
             */
            renderItemAt: function(delta){
                //Get the value at the given delta
               var val = this.getVal(delta);
               
               //Do we have a renderer? Use that or simply render the item.
               return (this.renderer)? this.renderer.render(val, this) : val;
            },
            
            /**
             * @see mstrmojo.StepperContentProvider
             */
            getVal: function(delta){
                //If no delta is provided, reset to 0
               delta = (delta)? delta: 0;
               
               //Return the adjusted value... 
               return this.curVal + this.interval * delta;
            }
        }
    );
}());           
(function () {
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.Widget");

    /**
     * This widget emulates a semi-locked section header for scrollable lists. It remains locked until all elements within
     * it's grouping have been scrolled and then animates to make space for the next section title.
     *
     * The widget is typically used at the top of the list so as to create a a grouping effect.
     *
     * It assumes that the list has constant row height.
     *
     * @class
     * @extends mstrmojo.Widget
     *
     */
    mstrmojo.StickySections = mstrmojo.declare(
        // superclass
        mstrmojo.Widget,
        // mixins
        null,
        // instance members
        {
            scriptClass: "mstrmojo.StickySections",

            markupString: '<div id="{@id}" style="{@cssText};overflow:hidden">' +
                              '<div class="mstrmojo-StickySections {@cssClass}">{@currentSectionTitle}</div>' +
                          '</div>',

            /**
             * Callback whenever the widget's section title changes. It changes the innerHTML of the widget
             * to reflect the next HTML.
             *
             * @param evt The event object.
             */
            oncurrentSectionTitleChange: function oncurrentTitleChange(evt) {
                this.domNode.lastChild.innerHTML = this.currentSectionTitle;
            },


            /**
             * This method needs to be called whenever the List is scrolled so as to ensure that the necessary animation
             * whenever a new section is encountered. It expects the following info object
             *
             * {
             *   isNextRowNewSection: Boolean,
             *   position: Integer
             *   sectionName: String
             * }
             *
             * @param {Object} info An object passed in to help with the animation
             * @param {Boolean} info.isNewSection Tells the widget whether the current location of the list is at a new section.
             * @param {Boolean} info.isNextRowNewSection Tells the widget whether the next row moving to the top is a new section row.
             * @param {Integer} info.position Tells the widget the position of the list being scrolled
             * @param {String} info.sectionName Tells the widget the current section name for display.
             *
             */
            onMove: function onMove(info) {
                var value = 0;

                //Do we need to animate moving to the next section? Calculate where the section node is going to be next
                if (info.isNextRowNewSection) {
                    //When moving down, the widget has to animation from the top. Use row height in our calculations
                    var position = info.position,
                        rowStart = info.rowStart,
                        directionValue = (rowStart > position) ? (this.domNode.offsetHeight + 1) : 0;

                    //Calculate where the sticky section is going to be next..
                    value = (rowStart - position) - directionValue;
                }
                
                //Move the node to animate the push, pull or to reset back on top...
                mstrmojo.dom.translate(this.domNode.lastChild, 0, value, 0, "", true);
                
                //Set the current title name
                if (info.sectionName && info.sectionName !== this.currentSectionTitle) {
                    this.set('currentSectionTitle', info.sectionName);
                }
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls(
        "mstrmojo.dom",
        "mstrmojo.css",
        "mstrmojo.Widget"
    );

    var $CSS = mstrmojo.css;

    /**
     * @class
     * @extends {mstrmojo.Widget}
     */
    mstrmojo.VisTooltip = mstrmojo.declare(

        mstrmojo.Widget,

        null,

        /**
         * @lends mstrmojo.VisTooltip.prototype
         */
        {
            scriptClass: 'mstrmojo.VisTooltip',

            cssClass: 'vis-tooltip',

            markupString:
                '<div class="{@cssClass}">' +
                    '<div class="vis-tooltip-container">' +
                        '<table class="vis-tooltip-table">' +
                        '</table>' +
                    '</div>' +
                '</div>',

            markupSlots: {
                domContainer: function () { return this.domNode.firstChild; },
                domTable: function () { return this.domNode.firstChild.firstChild; }
            },

            toggle: function toggle(show){
                if (show) {
                    this.domNode.style.display = 'block';
                } else {
                    this.domNode.style.display = 'none';
                }
            },

            displayInfo: function displayInfo(infoArr, pos) {
                var i, n, item, tbody, tr, td0, td1, td2,
                    doc = document,
                    table = this.domTable;

                table.innerHTML = '';
                n = infoArr.length;

                for (i = 0; i < n; i++) {
                    item = infoArr[i];
                    tbody = doc.createElement('tbody');
                    tr = doc.createElement('tr');
                    td0 = doc.createElement('td');
                    td1 = doc.createElement('td');
                    td2 = doc.createElement('td');
                    td0.setAttribute('class', 'vis-tooltip-name');
                    td1.setAttribute('class', 'vis-tooltip-space');
                    td2.setAttribute('class', 'vis-tooltip-value');

                    if (item === null) { // line separator
                        tr.setAttribute('class', 'vis-tooltip-tr separator');
                    } else {
                        tr.setAttribute('class', 'vis-tooltip-tr');
                        td0.innerHTML = item.n + ':';
                        td2.innerHTML = item.v;
                    }

                    tr.appendChild(td0);
                    tr.appendChild(td1);
                    tr.appendChild(td2);
                    tbody.appendChild(tr);
                    this.domTable.appendChild(tbody);
                }

                if (pos) {
                    var loc = mstrmojo.dom.position(doc.body),
                        w = this.domNode.offsetWidth,
                        h = this.domNode.offsetHeight,
                        dx = pos.x + w - loc.x - loc.w,
                        dy = pos.y + h - loc.y - loc.h;

                    if (dx > 0) {
                        pos.x -= dx;
                    }
                    if (dy > 0) {
                        pos.y -= dy;
                    }

                    this.domNode.style.left = pos.x + 'px';
                    this.domNode.style.top = pos.y + 'px';
                }
            },

            doLayout: function doLayout(tableMaxWidth) {
                var table = this.domTable,
                    ttpStyle = $CSS.getComputedStyle(this.domNode),
                    tds = table.firstChild.firstChild.childNodes,
                    valueTDs = table.getElementsByClassName('vis-tooltip-value'),
                    i;

                var maxWidthForValue = tableMaxWidth - parseInt(ttpStyle.paddingLeft) - parseInt(ttpStyle.paddingRight);
                //remove name td width
                maxWidthForValue -= tds[0].offsetWidth;
                //remove space td width
                maxWidthForValue -= 10;
                

                for(i = 0; i < valueTDs.length; i++) {
                    valueTDs[i].style.maxWidth = maxWidthForValue + 'px';
                }
            },

            /***
             * move the tooltip to right pos
             * @param pos {object} have
             */
            posTo: function posTo(pos){
                this.domNode.style.left = pos.x + 'px';
                this.domNode.style.top = pos.y + 'px';
            }
        }
    );

}());
(function(){

    mstrmojo.requiresCls( "mstrmojo.publisher",
    					"mstrmojo.Widget",
                         "mstrmojo.fx",
                         "mstrmojo.locales",
                         "mstrmojo.expr",
                         "mstrmojo.date",
                         "mstrmojo.css");
    
    var _DT = function(){ return mstrmojo.locales.datetime; },
        $D = mstrmojo.dom,
        $E = mstrmojo.expr,
        DTP = $E.DTP,
        $P = mstrmojo.date,
        _P = mstrmojo.publisher,
        $H = mstrmojo.hash,
        $A = mstrmojo.array,
        $RMV = $A.removeIndices,
        $C = mstrmojo.css;
    
    var _pre_table = '<table border="0" cellpadding="0" cellspacing="0">',
        _post_table = '</table>';
    function _pre_table_with_style(style){
    	return '<table border="0" cellpadding="0" cellspacing="0" style="' + style + '">';
    }
    function _getLeadingBlanks(y,m,fdw){
        var fd = $P.getFirstDateOfMonth(y,m);
        return (fd.getDay() - fdw + 8) % 7;
    }
    
    /**
     * This method takes a date value provided as String and parses it into JSON Object notation
     * 
     *  @param {String} value The date which needs to be parsed 
     *  @return {Object}
     */
    function parseDateAndTimeToJSON(value) {
        //Parse the string containing the date.
        var dt = $P.parseDateAndOrTime(value),
            d, t, r;
        
        //Do we have an object returned?
        if(dt){
            //Yes, the date provided is valid.
            r = {};
            d = dt.date;
            t = dt.time;
            if(d) {
                $H.copy(d, r);
            }
            if(t) {
                $H.copy(t, r);
            }
        }
        
        //Return the result.
        return r;
    }
    
    /**
     * Returns whether the date is out of the min and max date bounds. If no min and max are provided,
     * this method returns false.
     * 
     * @param {Object} date The date provided in the object notification as returned by #parseDateAndTime
     * @param {String} min The min date the calendar can support.
     * @param {String} max The max date the calendar can support.
     * @return Boolean
     */
    
    function isDateInDateTimeRange(day, month, year, min, max) {
        var d = $P.formatDateInfo({day: day, month: month, year: year}, _DT().DATEOUTPUTFORMAT);
        //Check if the date is within time range...
        return $P.inDateTimeRange(d, min, max) == 0;
    }
    
    /**
     * This function checks if the widget should display it's increase and decrease traversal buttons based on the next and previous dates
     * 
     * @param {mstrmojo.Calendar} widget The Calendar widget.
     * @param {Object} prev, next The next and previous date objects which contain the day, month and year properties.
     */
    function updateTraversalIcons(widget, prev, next) {
        var db = widget.decreaseButton,
            ib = widget.increaseButton,
            cssPrefix = 'mstrmojo-Calendar',
            updateCSS = function (node, className, date) {
                //Adjust the class name
        		var disabled = !isDateInDateTimeRange(date.d, date.m, date.y, widget.min, widget.max);
                node.className = (cssPrefix + className) + (disabled ? ' disabled' : '');
                node.disabled = disabled; 
            };

        //Update the Css..
        updateCSS(db, '-decrease', prev);
        updateCSS(ib, '-increase', next);
    }
    
    /**
     * Function returns the index of the date selected. If it isn't selected, it returns -1.
     * 
     * @param {Array} An array with all the selected dates.
     * @param {Integer} The day that needs to be found
     * @param {Integer} The month that needs to be found
     * @param {Integer} The year that needs to be found
     * @return {Integer}
     */
    function isDateSelected(selectedDates, day, month, year) {
        var i = 0,
            len = selectedDates.length,
            sd;
    
        for (i = 0; i < len; i++) {
            //Get the current iterated object
            sd = selectedDates[i];
            
            //Is the date same as the selected object?
            if (sd && sd.day === day && sd.month === month && sd.year === year) {
                return i;
            }
        }
        
        return -1;
    }
    
    function isToday(day,month,year){
    	var td = new Date();
    	return (td.getFullYear() == year)
    		&& ((td.getMonth() + 1) == month)
    		&& (td.getDate() == day);
    }
    
    /**
     * This method removes the selection for a given index on the selectionDates array
     * 
     * @param {mstrmojo.Calendar} widget The Calendar widget
     */
    function removeSelection(widget, index) {
        var divs = widget.dayView.getElementsByTagName('div'),
            sd = widget.selectedDates,
            date = sd[index],
            by = widget.browseYear,
            bm = widget.browseMonth,
            l = $P.getDaysOfMonth(by, bm), //length of browse month
            pm = $P.getPreMonth(by,bm),
            pl = $P.getDaysOfMonth(pm.y, pm.m), //length of previous month
            lb = _getLeadingBlanks(by, bm, widget.firstDayOfWeek),
            inx = ((date.month == bm) ? date.day + lb -1:
                 (date.month > bm ? date.day + lb + l -1 : 
                     lb - pl + date.day -1)),
            d = divs[inx];
        
        //Remove the CSS selected class...
        
        if(d){
           	toggleSelectionStyle(d, widget, false);
        }
        
        //Remove the selected date from the selections list.
        $RMV(sd, index, 1);
    }
    /**
     * This method removes all the selections from the selectionDates array
     * @param {mstrmojo.Calendar} widget The Calendar widget
     */
    function clearSelection(widget) {
        var sd = widget.selectedDates;
        // use while because the length of sd is decreasing in the loop
        while(sd.length) {
            removeSelection(widget, 0);
        }
    }
    
    function addSelectionByElems(widget, elem) {
        var ymd = getYMDFromElem(widget, elem),
            sds = widget.selectedDates;
        //Push the selected date into our selection list.
        sds.push({
            day: ymd.d, 
            month: ymd.m, 
            year: ymd.y
        });
        
        toggleSelectionStyle(elem, widget, true);
    }
    
    function addSelectionByDates(widget, dates) {
        if (!dates || !dates.length) return null;
        var sds = widget.selectedDates;
        for(var i = 0, len = dates.length; i < len; i++) {
            var d = dates[i],
                div = getElemFromDate(widget, d);
            sds.push({
                day: d.d, 
                month: d.m, 
                year: d.y
            });
            
            if (div) {
            	toggleSelectionStyle(div, widget, true);
            }
        }
    }
    
    function getElemFromDate(widget, d) {
        var divs = widget.dayView.getElementsByTagName('div'),
            ldivs = divs.length,
            by = widget.browseYear,
            bm = widget.browseMonth,
            pm = $P.getPreMonth(by,bm),
            pl = $P.getDaysOfMonth(pm.y, pm.m), //length of previous month
            nm = $P.getNextMonth(by, bm),
            l = $P.getDaysOfMonth(by, bm), //length of browse month
            lb = _getLeadingBlanks(by, bm, widget.firstDayOfWeek); //leading blanks
            
        var fdate = lb > 0 ? {y:pm.y , m:pm.m, d:divs[0].innerHTML} : {y:by, m:bm, d:divs[0].innerHTML},
            ldate = (divs.length - l -lb) > 0 ? {y:nm.y, m:nm.m, d:divs[ldivs-1].innerHTML} : {y:by, m:bm, d:divs[ldivs-1].innerHTML},
            diff_fdate = diffDates(fdate, d),
            diff_ldate = diffDates(d, ldate),
            index = null;
        
        // make sure the date is between the two dates
        if (diff_fdate >= 0 && diff_ldate >=0) {
            var ma = 0;
            if (diff_fdate < lb) ma = -1;
            if (diff_ldate < (divs.length - lb -l)) ma = 1;
            index = ((ma == 0) ? d.d + lb - 1 :
                (ma == 1 ? d.d + lb + l - 1 : 
                    lb - pl + d.d -1));
            return divs[index];
        } else {
            return null;
        }
    }
    /**
     * This method compute the selections when user pressed shift and click on a date
     * @param {mstrmojo.Calendar} widget The Calendar widget 
     * @param {HTMLElement} div The current node 
     */
    function getShiftSelection(widget, div) {
        var sd = widget.selectedDates,
            length = sd.length;
    
        if (!length) {
            return null;
        }
    
        var ld = sd[length - 1],
            cd = getYMDFromElem(widget, div),
            df = diffDates({y:ld.year, m:ld.month, d:ld.day}, cd),
            selection = [],
            inc = df > 0,
            sz = Math.abs(df);
            
        for(var i= 0;i <= sz; i++){
            var nd = new Date(cd.y, cd.m -1, cd.d);
            nd.setDate(nd.getDate() + (inc?-i:i));
            var y = nd.getFullYear(), m = nd.getMonth() + 1, d = nd.getDate();
            if (widget.isDateDisabled(d, m, y, widget.min, widget.max)) continue;
            selection.push({'y':y,'m':m,'d':d});
        }
        
        return selection;

    }
    
    function diffDates(from, to) {
        var fd = new Date(from.y, from.m - 1, from.d),
            td = new Date(to.y, to.m - 1, to.d);
        
        return (td - fd)/1000/3600/24;
    }
    function getYMDFromElem(widget, elem) {
        var by = widget.browseYear,
            bm = widget.browseMonth,
            d = parseInt(elem.innerHTML,10),
            ma =  parseInt(elem.getAttribute("m"),10)
            ymd = null;
        
        ymd = (ma === 0) ? {y: by, m: bm} : (ma === 1 ? $P.getNextMonth(by,bm) : $P.getPreMonth(by,bm));  
        ymd.d = d;
        return ymd;
    }
    
    /**
     * Returns the last selected date from the selections array
     * 
     * @param {mstrmojo.Calendar} widget The Calendar widget
     * @return {Object} An object with the date information.
     */
    function getLastSelectedDate(w) {
        var sds = w.selectedDates,
            length = sds.length;
        
        return (length === 0) ? null : sds[length - 1];
    }
    
    function toggleSelectionStyle(elem, widget, select) {
        var c = widget.selectedColor;
        $C.toggleClass(elem,['selected', widget.selectedCssStyle], select);
        elem.parentNode.style.backgroundColor = select?c:'';
        elem.style.backgroundColor = select?c:'';
    }
    
    function selectedStyle(widget){
    	return widget.selectedColor?('style="background-color:'+widget.selectedColor+';"'):'';
    }
    /**
     * helper function to make 'td' clickable on dayView, monthView and yearView
     * @param t the original target
     * @returns {HTMLElement}
     */
    function findTarget(t) {
        return (t.tagName.toLowerCase() == 'td') ? t.firstChild : t;
    }
    /**
     * <p>Calendar is a widget that allows to pick a date/time. </p>
     * 
     * <p> It has 6 views that can be used to change the corresponding date/time part of this widget: day, month, year, hour, minute and second. 
     * Each view can be accessed by clicking on the label on Calendar interface (hour, minute and second views are only available 
     * when the "dtp" is set to "TIMESTAMP/TIME".</p>
     * 
     * @class
     * @extends mstrmojo.Widget
     */
    mstrmojo.Calendar = mstrmojo.declare(
        // superclass
        mstrmojo.Widget,
        // mixins
        null,
        
        /**
         * @lends mstrmojo.Calendar.prototype
         */
        {
            scriptClass: "mstrmojo.Calendar",
            
            /**
             * A class name prefixed to the domNode.
             * @default ''
             */
            cssPrefix: '',
            
            /**
             * The current browsing month. 
             * 
             * @type Integer
             */
            browseMonth: null,
            
            /**
             * The current browsing year. 
             * 
             * @type Integer
             */            
            browseYear: null,
            
            /**
             * The starting point of year view. 
             * 
             * @type Integer
             */            
            yearRangStart: null,
            
            /**
             * The object holds the current selected date.
             * 
             *  @type Array
             *  @default null
             */
            selectedDates: null,
            
            /**
             * The object holds the current selected date's style.
             * 
             *  @type Array
             *  @default null
             */
            
            selectedColor:'',
            /**
             * Denotes whether the calendar supports multi-select
             * 
             * @type Boolean
             * @default false
             */
            isMultiSelect: false,
            
            /**
             * hilight today
             */
            
            hilightToday: false,
            
            /*
             * yearViewSize ^ 2 is the total number of years in the the year view
             * */
            yearViewSize: 5,
            
            cssTextDay:'',
            cssTextMonth:'',
            cssTextYear:'',
            cssTextWeekDay:'',
            cssTextHeader:'',
            cssTextMonthYearLabel:'',
            /**
             * 
             */
            forceNonEmptySelection: false,
            
            /*
             * 
             * */
            showCurMonthDatesOnly:false,
            
            /**
             * The current displayed view. 
             * 
             *  @type String
             */
            currentView: 'day',
            
            /**
             * The duration of the effect used when switching between different views. 
             * 
             * @type Integer
             */
            duration:600,
            
            /**
             * The delimiter used to seperate different time parts: hour, minute and second. 
             */
            timeDelimiter:':',
            
            /**
             * Value from mstrmojo.expr.DTP. data type: we use this value to decide whether or not to show the time part.
             */
            dtp:DTP.DATE,
            
            /**
             * The value to decide which date/time is currently selected. It is synchronized with selectedDates. 
             */
            value: '',
            
            /**
             * default is 1, which means that the week starts with Sunday.
             * if set to 2, it means that the week starts with Monday
             */
            firstDayOfWeek: 1, 
            
            /**
             * Whether only update value property when OK button is hit. Also used to decide whether the OK/Cancel button would be shown or not.
             */
            changeValueOnOK: false,
            
            /**
             * Label to be used for ok button.
             */
            okLabel: mstrmojo.desc(1442,'OK'),
            
            /**
             *  This property controls how the month names are displayed on the calendar
             */
            monthNames: function(i){return _DT().MONTHNAME_SHORT[i];},
            
            /**
             * This property controls how the day names are displayed on the calendar.
             */
            dayNames: function(i){return _DT().dayShortNames[i];},
            
            /**
             * The minimum date supported by the Calendar View
             * 
             * @type String
             * @default null
             */
            min: null,
            
            /**
             * The maximum date supported by the Calendar View
             * 
             * @type String
             * @default null
             */
            max: null,
            
            /**
             * Configurable property allows the user to determine which view modes should be supported by
             * the Calendar widget.
             */
            supportedViews: {
                day: true,
                month: true,
                year: true,
                hour: true,
                minute: true,
                second: true
            },
            
            /**
             * The matrix used to config what direction to used when sliding/switching between different views. 
             */
            sDirMatrix:{
                day:{'month':'down','year':'down','hour':'up','minute':'up','second':'up'},
                month:{'day':'up','year':'left','hour':'up','minute':'up','second':'up'},
                year:{'day':'up','month':'right','hour':'up','minute':'up','second':'up'},
                hour:{'day':'down','month':'down','year':'down','minute':'left','second':'left'},
                minute:{'day':'down','month':'down','year':'down','hour':'right','second':'left'},  
                second:{'day':'down','month':'down','year':'down','hour':'right','minute':'right'} 
            },
            
            markupString:'<div id="{@id}" class="{@cssPrefix} mstrmojo-Calendar {@cssClass}" style="{@cssText}" mstrAttach:mousedown,mouseup,mouseover,mouseout>' + 
                            '<div class="mstrmojo-Calendar-header" style="{@cssTextHeader}">' +
                                '<div class="mstrmojo-Calendar-decrease"></div>' +
                                '<div class="mstrmojo-Calendar-increase"></div>' +
                                '<div class="mstrmojo-Calendar-title">' +
                                  '<span class="mstrmojo-Calendar-monthLabel" style="{@cssTextMonthYearLabel}">{@browseMonth}</span>' +
                                  '<span class="mstrmojo-Calendar-comma">,</span>' +
                                  '<span class="mstrmojo-Calendar-yearLabel" style="{@cssTextMonthYearLabel}">{@browseYear}</span>' +        
                                '</div>' +                             
                            '</div>' +
                            '<div class="mstrmojo-Calendar-body" style="{@cssTextBody}">' +
                                '<div class="mstrmojo-Calendar-dayView"></div>' +    
                            '</div>' +
                            '<div class="mstrmojo-Calendar-timePart">' +
                                '<span class="mstrmojo-Calendar-hourLabel">00</span>' +
                                '<span class="mstrmojo-Calendar-timeDelimiter">{@timeDelimiter}</span>' +                                
                                '<span class="mstrmojo-Calendar-minuteLabel">00</span>' +    
                                '<span class="mstrmojo-Calendar-timeDelimiter">{@timeDelimiter}</span>' +    
                                '<span class="mstrmojo-Calendar-secondLabel">00</span>' +    
                            '</div>' +
                            '<div class="mstrmojo-Calendar-tools">' +
                                '<div class="mstrmojo-Calendar-ok"> {@okLabel} </div>' + 
                            '</div>' +                            
                         '</div>',
            
            markupMethods: {
                onvisibleChange: function(){this.domNode.style.display = this.visible ? 'block' : 'none';},                
                onbrowseMonthChange:function(){this.monthLabel.innerHTML = this.monthNames(this.browseMonth - 1);},
                onbrowseYearChange:function(){this.yearLabel.innerHTML = this.browseYear;},
                ondtpChange:function(){this.timePart.style.display = (this.dtp === DTP.TIMESTAMP || this.dtp === DTP.TIME) ? "block" : "none";},
                onvalueChange:function(){
                    if(this.lastValue === undefined || this.value !== this.lastValue){
                            this.updateSelectedDate();
                        }
                },
                onchangeValueOnOKChange:function(){this.tools.style.display = (this.changeValueOnOK ? "block" : "none");}
            },
            
            markupSlots: {
                monthLabel: function(){return this.domNode.firstChild.lastChild.firstChild;},
                yearLabel: function(){return this.domNode.firstChild.lastChild.lastChild;},
                decreaseButton:function(){return this.domNode.firstChild.firstChild;},
                increaseButton:function(){return this.domNode.firstChild.childNodes[1];},                
                bodyContainer: function(){return this.domNode.childNodes[1];},
                dayView:function(){return this.domNode.childNodes[1].firstChild;},
                monthView:function(){return this.domNode.childNodes[1].childNodes[1];},
                yearView:function(){return this.domNode.childNodes[1].lastChild;},
                timePart:function(){return this.domNode.childNodes[2];},
                hourLabel:function(){return this.domNode.childNodes[2].firstChild;},
                minuteLabel:function(){return this.domNode.childNodes[2].childNodes[2];},
                secondLabel:function(){return this.domNode.childNodes[2].childNodes[4];},
                tools:function(){return this.domNode.childNodes[3];},
                okButton: function(){return this.domNode.childNodes[3].firstChild;}
            },
            
            init:function init(props){
                if(this._super) {
                    this._super(props);
                }
                if(this.duration<1) {
                    this.duration = 1;  
                }
                
                //Initialize the selectedDates property to an empty array
                if (!this.selectedDates) {
                    this.selectedDates = [];
                }
                
                this.timeVal = { hour: 0, min: 0, sec: 0 };
            },
            
            /**
             * This method returns an array of selected dates as a string formatted by an output format.
             * 
             * @param {String} format The format in which the date needs to be outputted.
             */
            getSelectedDatesAsString: function getSelectedDatesAsString(format) {
                var result = [];
                
                // Create an object with information about actual position and number of forms.
                $A.forEach(this.selectedDates, function (sd) {
                    result.push($P.formatDateInfo(sd, format || _DT().DATEOUTPUTFORMAT));
                });
                
                return result;
            },
            
            /**
             * Method to be called when the value property is changed. 
             * 
             * @private
             */
            updateSelectedDate: function updateSelectedDate(){
                var v = this.value,
                    tv = this.timeVal,
                    sds = this.selectedDates,
                    r, update = function (me, r) {
                        me.set('browseYear',r.year);
                        me.set('browseMonth',r.month);
                        me.updateTimePart();
                        me.updateView(me.currentView);
                    };
                
                //Has the calendar been initialized using the selectedDates property?
                if (sds.length === 0) {
                    //No, Do we have a value property set?
                    if(v){
                        //Parse it into our JSON notification.
                        r = parseDateAndTimeToJSON(v);
                        
                        if (r && r.hour !== undefined){
                            tv.hour = r.hour;
                            tv.min = r.min;
                            tv.sec = r.sec;
                        }
                    }
                    
                    //Did we succesfuly create an object from the date string?
                    if(!r){
                        //No, default to the current date.
                        r = $P.getDateJson(new Date());
                    }
                    
                    //Is the date being selected valid?
                    if (this.isDateDisabled(r.day, r.month, r.year, this.min, this.max)) {
                        // spec: Today if inside [Min, Max]. If Min is after today, use Min. If Max is before today, use Max.
                        if (this.min && $P.compareDate(r, this.min) < 0) {
                            r = parseDateAndTimeToJSON(this.min);
                        } else if (this.max && $P.compareDate(r, this.max) > 0) {
                            r = parseDateAndTimeToJSON(this.max);
                        }
                    }
                    
                    //Add the date to the selectedDates array.
                    sds.push(r);
                    
                    update(this, r);                 

                } else {
                    //Pick the first date in the array to show as the browse year.
                    r = sds[0];
                    
                    if (this.value != null) {

                        update(this, r);                 
                    }
                }
                
            },
            
            /**
             * Method to be called to synchronize the value with the last selected date on property selectedDates. 
             * 
             * @private
             */
            updateValue: function updateValue(){
                var sd = getLastSelectedDate(this),
                    v = '';
                
                if (sd) {
                    v = $P.formatDateInfo(sd,_DT().DATEOUTPUTFORMAT);
                    if (this.dtp !== DTP.DATE) {
                        v += ' ' + $P.formatTimeInfo(this.timeVal, _DT().TIMEOUTPUTFORMAT);
                    } 
                }
                
                this.lastValue = v;                
                this.set('value', v);                
                
                if(this.onValueUpdate) {//call value change always
                    this.onValueUpdate();
                }                
            },   
            
            /**
             * Method to be called to update the time part labels. 
             * @private
             */
            updateTimePart:function updateTimePart(){
                var time = this.timeVal,
                    hh = time.hour || 0,
                    twelve = (hh % 12 === 0) ? 12 : (hh % 12);
                this.hourLabel.innerHTML = hh < 12 ? twelve + _DT().AM_NAME : twelve + _DT().PM_NAME;
                this.minuteLabel.innerHTML = $P.formatInteger(time.min || 0, 2);
                this.secondLabel.innerHTML = $P.formatInteger(time.sec || 0, 2);
            },                  
            
            /**
             * Event handler to handle mouse down event. 
             * @param {Object} event object raised when mouse down event is fired. 
             * 
             * @private
             */
            premousedown: function(evt){
                var e = evt.e,
                    t = $D.eventTarget(evt.hWin,e);
                if(t === this.decreaseButton || t === this.increaseButton){
                	if($D.isFF){ // fix the :active css issue on FF, interactive mode.
                		$D.stopPropogation(window,e);
                	}
                    return true;
                }else{
                	//Process the event with the target element.
                	return this.processEvent(t, e);
                }
            },
                
            premouseup: function(evt){
            	var e = evt.e;
            	if(e.ctrlKey || e.shiftKey){
            		$D.clearBrowserHighlights();
            	}
            	var t = $D.eventTarget(evt.hWin,e);
                if(t === this.decreaseButton && !t.disabled){
                    this.decrease();
                    return true;
                }
                
                if(t === this.increaseButton && !t.disabled){
                    this.increase();
                    return true;
                }
            	
            },
            /**
             * Helper method process the events on the Calendar based on which element is being targeted
             * 
             * @param {HTMLElement} t Target HTML element.
             */    
            processEvent: function(t, e) {
                var cv = this.currentView,
                    sds = this.selectedDates,
                    sd = getLastSelectedDate(this),
                    y, m, d, ma, v; 
                
                
                if(t === this.okButton && this.changeValueOnOK){
                    this.updateValue();
                }
                
                if(t === this.monthLabel){
                    if(cv !== 'month') {
                        this.switchViewTo('month');
                    }
                    return true;
                }
                
                if(t === this.yearLabel){
                	if (cv !== 'year') {          
                		this.adjustYearStart();
                		this.switchViewTo('year');
                    	return true;
                	}
                }
                
                if(t === this.hourLabel){                  
                    if(cv !== 'hour') {
                        this.switchViewTo('hour');
                    }
                    return true;
                }                
                
                if(t === this.minuteLabel){                  
                    if(cv !== 'minute') {
                        this.switchViewTo('minute');
                    }
                    return true;
                }
                
                if(t === this.secondLabel){
                    if(cv !== 'second') {
                        this.switchViewTo('second');
                    }
                    return true;
                }    
                
                if($D.contains(this.hourView, t, false,this.domNode)){
                    var ha = t.getAttribute('h');
                    
                    v = parseInt(t.innerHTML, 10);
                    
                    if(!isNaN(ha) && !isNaN(v)){
                        ha = parseInt(ha,10);
                        this.timeVal.hour = v%12 + ha * 12;
                        this.updateTimePart();  
                        this.switchViewTo('day');
                        if(!this.changeValueOnOK){
                            this.updateValue(); 
                        }                       
                    }
                    return true;                     
                }
                
                if($D.contains(this.minuteView, t, false,this.domNode)){
                    v = parseInt(t.innerHTML, 10);
                    if(!isNaN(v)){
                        this.timeVal.min = v;
                        this.updateTimePart();
                        this.switchViewTo('day');
                        if(!this.changeValueOnOK){
                            this.updateValue();        
                        }
                    }
                    return true;                    
                }  
                
                if($D.contains(this.secondView, t, false,this.domNode)){
                    v = parseInt(t.innerHTML, 10);
                    if(!isNaN(v)){
                        this.timeVal.sec = v;
                        this.updateTimePart();
                        this.switchViewTo('day');
                        if(!this.changeValueOnOK){
                            this.updateValue(); 
                        }
                    }
                    return true;                    
                }                  
                
                if($D.contains(this.dayView, t, false,this.domNode)){
                    //update class name to reflect the new selected
                    var by = this.browseYear,
                        bm = this.browseMonth,
                        pnm;
                    
                    t = findTarget(t);
                    d = parseInt(t.innerHTML,10);
                    ma = parseInt(t.getAttribute("m"),10);
                    
                    if(!isNaN(d) && !isNaN(ma)){
                        pnm = (ma === 0) ? {y: by, m: bm} : (ma === 1 ? $P.getNextMonth(by,bm) : $P.getPreMonth(by,bm));  
                        
                        //Check if the clicked date is disabled, if yes, return.
                        if(this.isDateDisabled(d, pnm.m, pnm.y, this.min, this.max) || e.button==2) {
                            return true;
                        }
                        
                        var selIndex = isDateSelected(sds, d, bm, by),
                        	ms = sds.length > 1,
                        	nonEmpty = this.forceNonEmptySelection,
                        	ims = this.isMultiSelect,
                            ctrl = ims && e.ctrlKey,
                            shift = ims && e.shiftKey,
                            dates = null;
                       
                        if (shift) { 
                            dates = getShiftSelection(this, t);
                            clearSelection(this);
                            addSelectionByDates(this, dates);
                        } else if(ctrl){
                            if(selIndex === -1){
                                addSelectionByElems(this, t);
                            }else{
                            	if(!nonEmpty || ms){
                            		removeSelection(this, selIndex);
                            	}
                            }
                        }else{
                            clearSelection(this);
                            if (ms || selIndex === -1 || nonEmpty) {
                                addSelectionByElems(this, t);
                            }
                        }
                        if (this.onselect || _P.hasSubs(this.id, "select") ) {
                                this.raiseEvent({
                                    name: "select", 
                                    value: this.selectedDates
                                });
                        }
                        
                        if(ma === 1) {
                            this.increase();
                        } else if(ma === -1) {                       
                            this.decrease();
                        }  
                        
                        if(!this.changeValueOnOK){
                            this.updateValue();
                        }
                    }
                    return true;
                }
                
                if($D.contains(this.monthView, t, false,this.domNode)){
                	t = findTarget(t);
                    m = parseInt(t.getAttribute('m'),10);
                    if(!isNaN(m)){
                        this.set("browseMonth", m + 1);
                        this.switchViewTo('day');
                    }
                    return true;
                }

                if($D.contains(this.yearView, t, false,this.domNode)){
                	t = findTarget(t);
                    y = parseInt(t.innerHTML,10);
                    if(!isNaN(y)){
                        this.set("browseYear", y);
                        this.switchViewTo('day');
                    }
                    return true;
                }
                
                return true;
            },             
            
            /**
             * Method to be called when decrease button is clicked. 
             */
            decrease: function(){
                var v = this.currentView,
                    newView = v,
                    y = this.browseYear,
                    m = this.browseMonth,
                    yrs = this.yearRangStart,
                    pre;
                
                switch(v){
                case 'day':
                    pre = $P.getPreMonth(y, m);
                    this.set('browseMonth', pre.m);
                    this.set('browseYear', pre.y);
                    break;
                case 'month':
                    this.set('browseYear', y - 1);
                    break;
                case 'year':
                    this.yearRangStart = yrs - this.yearViewSize * this.yearViewSize;
                    break;
                case 'hour':
                        newView = 'second';
                    break;
                case 'minute':
                        newView = 'hour';
                    break;
                case 'second':
                        newView = 'minute';
                    break;
                }

                //Switch to the new view...
                this.switchViewTo(newView,'right');
            },
            
            /**
             * Method to be called when increase button is clicked. 
             */            
            increase: function(){
                var v = this.currentView,
                    newView = v,
                y = this.browseYear,
                m = this.browseMonth,
                yrs = this.yearRangStart,
                next;

                switch(v){
                case 'day':
                    next = $P.getNextMonth(y, m);
                    this.set('browseMonth', next.m);
                    this.set('browseYear', next.y);
                    break;
                case 'month':
                    this.set('browseYear', y + 1);
                    break;
                case 'year':
                    this.yearRangStart = yrs + this.yearViewSize * this.yearViewSize;
                    break;
                case 'hour':
                        newView = 'minute'; 
                    break;
                case 'minute':
                        newView = 'second'; 
                    break;
                case 'second':
                        newView = 'hour';
                    break;                    
                }                
                
                //Switch to the new view...
                this.switchViewTo(newView,'left');
            },         
            
            /**
             * Update the current view. 
             * @param {String} v The view to be updated. 
             */
            updateView: function(v){
                var html = this[v + 'ViewHTML']();
                this[v + 'View'].innerHTML = html;
            },
            adjustYearStart: function(){
            	this.yearRangStart = this.browseYear - 10 - this.browseYear%5;
            },
            /**
             * Method to switch from one view to another. 
             * @param {String} v The view to switch to.
             * @param {String} dr The direction to be used by the Sliding effect. 
             * 
             */

            switchViewTo: function(v,dr){
                var cn = 'mstrmojo-Calendar-' + v + 'View', 
                    div = document.createElement('div'),
                    cv = this[this.currentView + 'View'],
                    hn = v + 'ViewHTML',
                    plb = this[this.currentView + 'Label'],
                    nlb = this[v + 'Label'];
                
                //Is the view supported?
                if (!this.supportedViews[v]) {
                    return;
                }
                
                if(!dr) {
                    dr = this.sDirMatrix[this.currentView][v];
                }
                
                div.className = cn;
                div.innerHTML = this[hn]();
                
                this.currentView = v;
                
                //update the corresponding label
                if(plb){
                    mstrmojo.css.removeClass(plb, ['highlight']);
                }
                if(nlb){
                    mstrmojo.css.addClass(nlb, ['highlight']);
                }
                
                this[v + 'View'] = div;
                
                this._slideIntoView(cv,div,dr);
            },  

            /**
             * Method to slide a view into body part
             * @param {DOMNode} c The div to be moved out.
             * @param {DOMNode} t The div to be moved into body.
             * @param {String} d Direction to be used for sliding effect. 
             */
            _slideIntoView: function(c, t, d){
                var p = this.bodyContainer,
                    v = (d === 'left' || d === 'right') ? c.offsetWidth : c.offsetHeight,
                    pn = (d === 'left' || d === 'right') ? 'left' : 'top',
                    pv = (d === 'left' || d === 'up') ? v : -v, 
                    e1 = new mstrmojo.fx.AnimateProp({
                        props: {},
                        duration:this.duration,
                        interval:this.duration/10,
                        target:c,
                        onEnd:function(){
                            p.removeChild(c);
                        }
                    }),      
                    e2 = new mstrmojo.fx.AnimateProp({
                        props: {},
                        duration:this.duration,
                        interval:this.duration/10,                        
                        target:t
                    }); 
                                    
                t.style[pn] = pv + 'px';
    
                p.appendChild(t);
    
                e1.props[pn] = {start:0,stop:-pv, suffix:'px'};
                e2.props[pn] = {start:pv, stop:0, suffix:'px'};
    
                e1.play();
                e2.play();

            },
            
            /**
             * Method to generate html for day view. 
             * 
             */
            dayViewHTML: function(){
                var y = this.browseYear,
                    m = this.browseMonth,
                    dm = $P.getDaysOfMonth(y,m),
                    pm = $P.getPreMonth(y,m),
                    dpm = $P.getDaysOfMonth(pm.y, pm.m),
                    nm = $P.getNextMonth(y,m),
                    lb = _getLeadingBlanks(y,m,this.firstDayOfWeek),
                    html = [],
                    scStyle = selectedStyle(this),
                    c = 0,
                    sd = this.selectedDates,
                    min = this.min,
                    max = this.max,
                    date, status, i, j,
                    showCurStyle = this.showCurMonthDatesOnly?'style="visibility:hidden;"':'';
                
                //Update the increase and decrease buttons on the calendar.
                updateTraversalIcons(this, {d: dpm, m: pm.m, y: pm.y}, {d: 1, m: nm.m, y: nm.y});
                
                html.push(_pre_table_with_style(this.cssTextDay));
                html.push(this._dayViewTHead());
                //first row
                html.push('<tr>');
                for(i=0;i<lb;i++){
                    //Calculate the day
                    date = dpm-lb+i+1;
                    
                    //Initialize the status to empty.
                    status = this.isDateDisabled(date, pm.m, pm.y, min, max) ? 'disabled' : '';
                    
                    html.push('<td '+showCurStyle + '><div class="mstrmojo-Calendar-day-pre ' + status + '" m="-1">');
                    html.push(date);
                    html.push('</div></td>');
                    c++;
                }
                for(i=0;i<dm;i++){
                    //Calculate the day
                    date = i+1;
                    
                    //Initialize the status to empty.
                    status = this.isDateDisabled(date, m, y, min, max) ? ' disabled' : '';
                    var td = isToday(date,m,y),
                    	tdCssClass = td?' today':'',
                    	sel = isDateSelected(sd, date, m, y) !== -1;
                    tdCssClass = (this.hilightToday && td)? ' hilightToday':tdCssClass;
                    html.push('<td '+ (td?('class="'+tdCssClass+'" '):' ')+(sel?scStyle:'') + '><div class="mstrmojo-Calendar-day-cur' + (sel ? (' selected ') : '') + status + '" m="0"'+ (sel?scStyle:'') + '>');
                    html.push(i+1);
                    html.push('</div></td>');
                    if((++c)%7 === 0) {
                        html.push("</tr><tr>");
                    }
                }
                for(j=c;j<42;j++){
                    //Calculate the next day
                    date = c-dm-lb+1;
                    
                    //Initialize the status to empty.
                    status = this.isDateDisabled(date, nm.m, nm.y, min, max) ? 'disabled' : '';
                    
                    html.push('<td '+showCurStyle+'><div class="mstrmojo-Calendar-day-next ' + status + '" m="1">');
                    html.push(date);
                    html.push('</div></td>');   
                    if((++c)%7 === 0 && c!==42) {
                        html.push("</tr><tr>");   
                    }
                }
                html.push('</tr>');
                html.push(_post_table);
                return html.join('');
            },
            
            /**
             * Method to generate html for day view table head. 
             * 
             */            
            _dayViewTHead: function(){
                var html = [],
                    pre = '<thead><tr class="mstrmojo-Calendar-thead"'+' style="'+ this.cssTextWeekDay+';">',
                    post = '</tr></thead>',
                    fd = this.firstDayOfWeek - 1,
                    dayNames = this.dayNames,
                    i;
                
                html.push(pre);
                for(i = fd; i < fd + 7; i++){
                   html.push('<td>');
                   html.push(dayNames(i%7));
                   html.push('</td>');
                }
                html.push(post);
                return html.join('');
            },
            
            /**
             * Method to generate html for month view. 
             * 
             */            
            monthViewHTML: function(){
                var html = [],
                    bm = this.browseMonth - 1,
                    by = this.browseYear,
                    i;
                updateTraversalIcons(this, {d: 31, m: 12, y: by - 1}, {d: 1, m: 1, y: by + 1});
                html.push(_pre_table_with_style(this.cssTextMonth));
                html.push('<tr>');
                for(i=0;i<12;i++){
                    html.push('<td '+ ((i === bm)?selectedStyle(this):'') + '><div class="mstrmojo-Calendar-month' + ((i === bm) ? ' selected' : '')+'" m="');
                    html.push(String(i));
                    html.push('">');                        
                    html.push(this.monthNames(i));
                    html.push('</div></td>');
                    if(i%3 === 2) {
                        html.push("</tr><tr>");
                    }
                }
                html.pop();
                html.push("</tr>");
                html.push(_post_table);
                return html.join('');
            },
            
            /**
             * Method to generate html for year view. 
             * 
             */            
            yearViewHTML: function(){
                var start = this.yearRangStart,
                    html = [],
                    by = this.browseYear,
                    y, i,
                    ysz = this.yearViewSize;
                
                updateTraversalIcons(this, {d: 31, m: 12, y: start - 1}, {d: 1, m: 1, y: start + ysz*ysz});
                
                html.push(_pre_table_with_style(this.cssTextYear));
                html.push('<tr>');
                for(i=0;i<ysz*ysz;i++){
                    y = start + i;
                    html.push('<td '+ ((by===y)?selectedStyle(this):'') +'><div class="mstrmojo-Calendar-year' +  ((by===y) ? ' selected' : '') + '">');
                    html.push(y);
                    html.push('</div></td>');
                    if(i%ysz === (ysz-1)) {
                        html.push("</tr><tr>");     
                    }
                }
                html.pop();
                html.push("</tr>");
                html.push(_post_table);
                return html.join('');
            },
            
            /**
             * Method to generate html for hour view. 
             * 
             */            
            hourViewHTML: function(){
                var html = [],
                    hh = this.timeVal.hour,
                    i;
                html.push(_pre_table);
                html.push('<tr><td colspan="6"><div class="mstrmojo-Calendar-hourTitle">');
                html.push(_DT().AM_NAME);
                html.push('</div></td></tr>');
                for(i=0;i<12;i++){
                    html.push('<td><div class="mstrmojo-Calendar-hour' +  ((i === hh)? ' selected' : '') + '" h="0">');
                    html.push((i === 0) ? 12 : i);
                    html.push('</div></td>');
                    if(i === 5) {
                        html.push("</tr><tr>");
                    }
                }
                html.push('</tr><tr><td colspan="6"><div class="mstrmojo-Calendar-hourTitle">');
                html.push(_DT().PM_NAME);
                html.push('</div></td></tr>');                
                for(i=0;i<12;i++){
                    html.push('<td><div class="mstrmojo-Calendar-hour' + (((12 + i) === hh) ? ' selected' : '') + '" h="1">');
                    html.push((i === 0) ? 12 : i);
                    html.push('</div></td>');
                    if(i === 5) {
                        html.push("</tr><tr>");
                    }
                }
                html.push("</tr>");
                html.push(_post_table);
                return html.join('');
            },
            
            /**
             * Method to generate html for minute view. 
             * 
             */            
            minuteViewHTML: function(){
                return this._minuteSecondViewHTML(this.timeVal.min, "mstrmojo-Calendar-minute");
            },
            
            /**
             * Method to generate html for second view. 
             * 
             */            
            secondViewHTML: function(){
                return this._minuteSecondViewHTML(this.timeVal.sec, "mstrmojo-Calendar-second");
            },
            
            /**
             * Method to generate html for day/second view. 
             * @private
             */            
            _minuteSecondViewHTML: function(s,c){
                var html = [],
                    i;
                
                html.push(_pre_table);
                html.push('<tr>');
                for(i=0;i<60;i++){
                    html.push('<td><div class="');
                    html.push(c);
                    html.push((i === s) ? ' selected">' : '">');
                    html.push(i);
                    html.push('</div></td>');
                    if(i%10 === 9) {
                        html.push("</tr><tr>");
                    }
                }
                html.pop();
                html.push("</tr>");
                html.push(_post_table);
                return html.join('');                
            },
            /**
             * Returns whether the date is out of the min and max date bounds. If no min and max are provided,
             * this method returns false.
             * 
             * @param {Object} date The date provided in the object notification as returned by #parseDateAndTime
             * @return Boolean
             */
            isDateDisabled: function(day, month, year){
                 var d = $P.formatDateInfo({day: day, month: month, year: year}, _DT().DATEOUTPUTFORMAT);
                 
                 //Check if the date is within time range...
                 return !isDateInDateTimeRange(day, month, year, this.min, this.max);
            },
            unrender: function unrender(ignoreDom) {
                // need to clean up the lastValue so that the calendar could display correctly when rendered again.
                delete this.lastValue;
                this._super(ignoreDom);
            }
        }
    );
    
}());
(function() {
    mstrmojo.requiresCls("mstrmojo._IsInputControl");

    // Input control simply does nothing
    mstrmojo.DefaultDIC = mstrmojo.declare(
        
        mstrmojo.Widget,
        
        null,
        
        {
            scriptClass: 'mstrmojo.DefaultDIC',
            
            isDummy: true,
            
            showInPopup: function(){
                mstrmojo.alert('The control style has not been supported yet.');
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.Widget",
        "mstrmojo._Formattable");

    /**
     * <p>The widget for a single MicroStrategy Report Services line control.</p>
     * 
     * @class
     * @extends mstrmojo.Widget
     * 
     * @borrows mstrmojo._Formattable#formatHandlers as #formatHandlers
     * @borrows mstrmojo._Formattable#getFormats as #getFormats
     */
    mstrmojo.DocLine = mstrmojo.declare(
        mstrmojo.Widget,
        
        [mstrmojo._Formattable],

        /**
         * @lends mstrmojo.DocLine.prototype
         */
        {
            scriptClass: "mstrmojo.DocLine",

            markupString: '<div id="{@id}" class="mstrmojo-DocLine" title="{@tooltip}" style="{@domNodeCssText}"></div>', 
            
            formatHandlers: {
                domNode: [ 'RW', 'border-top', 'border-left', 'fx' ]
            },
			
			markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },
            
            update: function update(node) {
                // if there is a threshold, kill the format
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }
                
                this.thresholdId = node.data.tid;
				
				this.set('visible', !node.data.hidden);

                if (this._super) {
                    this._super(node);
                }
            },
            
            getFormats : function getFormats(){
                var fmts = this._super();
                if(fmts && parseInt(fmts.height, 10) === 0) { // 487725 only set the height if it equals 0
                    fmts.height = "1px";//481296; when height is 0 phone does not render.
                }
                return fmts;
            }
        }
    );
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo.dom");

    var baseCssClass = 'mstrmojo-Image';

    /**
     * An image class.
     *
     * @class
     * @extends mstrmojo.Widget
     *
     */
    mstrmojo.Image = mstrmojo.declare(

        mstrmojo.Widget,

        null,

        /**
         * @lends mstrmojo.Image
         */
        {
            scriptClass: "mstrmojo.Image",

            markupString: '<div id="{@id}" class="' + baseCssClass + ' {@cssClass}" style="{@cssText}" mstrAttach:click>' +
                              '<image src="{@src}" mstrAttach:load />' +
                          '</div>',


            markupSlots: {
                imgNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onsrcChange: function () {
                    // Do we have an imgNode?
                    var imgNode = this.imgNode;
                    if (imgNode) {
                        // Set image source.
                        imgNode.src = this.src || '../javascript/mojo/css/images/1ptrans.gif';
                    }
                },
                oncssClassChange: function () {
                    // Do we have a domNode?
                    var domNode = this.domNode;
                    if (domNode) {
                        // Set dom node css class to the cssClass property (or base class if empty).
                        domNode.className = this.cssClass || baseCssClass;
                    }
                },
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },

            /**
             * The src of the image.
             *
             * @type String
             * @default ""
             */
            src: '',

            /**
             * Returns the inner height and width of the image node.
             *
             * @type Object
             */
            getImageSize: function getImageSize() {
                var imgNode = this.imgNode;
                return {
                    w: imgNode.clientWidth,
                    h: imgNode.clientHeight
                };
            }
        }
    );

    /**
     * The base CSS class applied to the domNode.
     *
     * @static
     * @type String
     */
    mstrmojo.Image.baseCssClass = baseCssClass;

}());
/*global mstrmojo:false, window:false, document:false */
/*jslint forin: true, undef: true, browser: true, newCap: true */

(function(){
    var regExH = /"height", "[0-9.]+"/g;
    var regExW = /"width", "[0-9.]+"/g;
    var regExH1 = /height="?[0-9.]+"?/g;
    var regExW1 = /width="?[0-9.]+"?/g;
    
    mstrmojo.requiresCls("mstrmojo.Widget", 
                         "mstrmojo._Formattable",
                         "mstrmojo._IsSelectorTarget");
    
    /**
     * <p>The widget for custom Visualization.</p>
     * 
     * @class
     * @extends mstrmojo.Container
     * 
     */
    mstrmojo.DocVisualization = mstrmojo.declare(
        // superclass
        mstrmojo.Widget,
        
        // mixins,
        [mstrmojo._Formattable, mstrmojo._IsSelectorTarget],
        
        // body
        {
            scriptClass: "mstrmojo.DocVisualization",

            markupString:   '<div id={@id} class="mstrmojo-docvisualization" title="{@tooltip}" style="{@domNodeCssText}">{@htmlText}</div>',
            
            formatHandlers: {
                domNode: [ 'RW', 'T', 'B', 'fx']
            },
                            
            /**
             * Updates the DocVisulaization
             * 
             * @param {Object} node The widget node.
             */
            update: function update(node) {
                if (this._super) {
                    this._super(node);
                }
                
                var d = node.data;
                this.htmlText = d.htmlText;
                this.jsText = d.jsText;
                this.selData = d.selData;
                this.ctrLink = d.ctrLink;
                this.vp = d.vp;
            	this.eg = d.eg;
            	
            	if (this.eg) {
            		this.htmlText = this.eg;
            	}
            },
            
            preBuildRendering: function () {
                if (this._super) {
                    this._super();
                }
                var fmts = this.getFormats();
                if (!fmts) {
                    return;
                }
                var h = fmts.height;
                if (h) { 
                    h = h.replace('px','');
                }
                var w = fmts.width;
                if (w) {
                    w = w.replace('px','');
                }
                if (this.jsText) {
                    this.jsText = this.jsText.replace(regExH, '"height", "' + h + '"').replace(regExW, '"width", "' + w + '"');
                }
            },
            
            postBuildRendering: function pstBldRnd(){
                if (this._super) {
                    this._super();
                }
                
                eval(this.jsText);

            }, 
            
            resize: function () {
                if (this.eg) {
                    //It's an empty grid.
                    return;
                }
                var embedNode = this.domNode.firstChild.firstChild.firstChild;
                if (!embedNode) {
                    return;
                }
                var fmts = this.getFormats();
                var h = fmts.height;
                if (h) {
                    h = h.replace('px','');
                }
                var w = fmts.width;
                if (w) {
                    w = w.replace('px','');
                }
                if(mstrmojo.dom.isIE){ //449799
                    embedNode.firstChild.setAttribute("height", h);
                    embedNode.firstChild.setAttribute("width", w);
                }else{
                    embedNode.innerHTML = embedNode.innerHTML.replace(regExH1, 'height="' + h + '"').replace(regExW1, 'width="' + w + '"');
                }

            },
            
            makeSelections: function (selections) {
                var shuffledData = {},
                    i, j, attId, e;
                
                // Joining the element ids
                for (i = 0; i < selections.length; i++) {
                    var attIdI = selections[i].attId;
                    if (!shuffledData[attIdI]) {
                        shuffledData[attIdI] = [];
                    }
                    shuffledData[attIdI] = shuffledData[attIdI].concat(selections[i].values);    
                }

                var sep = '\u001E',
                    sep1 = '\u001F';
                var ckJoined = '',
                    eidJoined = '',
                    cklJoined = '';
                var tksArray = [];
                for (attId in shuffledData) {
                
                    var sd = this.getSelectionData(attId);
                    if (!sd) {
                    	// TQMS 447130, certain widgets will pass down non-selectors 
                    	continue;
                    }
                    var ctrLink = this.ctrLink[attId];
                    var values = shuffledData[attId];

                    if (sd && values && values.length>0) { 
                        // update client-side selectionData as this bone is not getting re-rendered
                        sd.sel = values;
                        sd.ias = false;
                        for (e in values) {
                            if (e === "u;") {
                                sd.ias = true; // update client-side selectionData as this widget is not getting re-rendered
                                break;
                            }
                        }
                    }
                    // TQMS 444885, sometimes we use "gbTargets" instead of "targets"
                    if (ctrLink.gbTargets) {
                        var t = ctrLink.targets = [],
                            gbt = ctrLink.gbTargets,
                            cgbmap = this.model.getCGBMap();
                        for(j = 0; j < gbt.length; j++) {
                            var targetKey = cgbmap[gbt[j]];
                            if (targetKey) {
                                t.push(targetKey);
                            }
                        }
                        delete ctrLink.gbTargets;
                    }
                    ckJoined += ctrLink.ctxt + sep1;
                    eidJoined += values.join(sep) + sep1;
                    cklJoined += ctrLink.ck + sep1;
                    tksArray = tksArray.concat(ctrLink.targets);

                } // for (var attId in shuffledData) 
                
                // trimming the ending separator ","
                ckJoined = ckJoined.substring(0, ckJoined.length-1);
                eidJoined = eidJoined.substring(0, eidJoined.length-1); 
                cklJoined = cklJoined.substring(0, cklJoined.length-1);
				
				if(tksArray.length == 0)
				{ //TQMS :538664
					return;
				}
                var evt = {
                        ck: ckJoined,
                        eid: eidJoined,
                        src: this.k,
                        tks: tksArray.join(sep),
                        type: this.defn.t,
                        ctlKey: cklJoined,
                        include: true,
                        isDocVis: true //flag to indicate to use setDocVisSelectorElements task.                        
                    };
                this.model.slice(evt);
            },
            
            getAllSelectionData: function () {
                return this.selData;
            },
            
            getSelectionData: function (attId) {
                var selData = this.selData,
                    k;
                
                if (selData && selData.attl){
                    var attl = selData.attl;
                    if (attId) {
                        return attl[attId];
                    }
                    else {
                        for (k in attl) {
                            // no attID, return the first one
                            return attl[k];
                        }
                    }
                }
            },
            
            saveVisProps: function (widgetPropsXml) {
				var props = {};                                                               
                props[this.k] = {
                	FormattingWidget: "WidgetProps" + '\u001F' + widgetPropsXml
                };
                        
                mstrApp.docModel.saveRWProps(this.k, props , 1, false, {success:function() {}});
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.Widget",
        "mstrmojo._Formattable");
    
    /**
     * <p>The widget for a single MicroStrategy Report Services rectangle control.</p>
     * 
     * @class
     * @extends mstrmojo.Widget
     * 
     * @borrows mstrmojo._Formattable#formatHandlers as #formatHandlers
     * @borrows mstrmojo._Formattable#getFormats as #getFormats
     */
    mstrmojo.DocRectangle = mstrmojo.declare(
        mstrmojo.Widget,
        
        [mstrmojo._Formattable],

        /**
         * @lends mstrmojo.DocRectangle.prototype
         */
        {
            scriptClass: "mstrmojo.DocRectangle",

            markupString: '<div id="{@id}" class="mstrmojo-DocRectangle" title="{@tooltip}" style="{@domNodeCssText}"></div>', 

            markupMethods: {
                onheightChange: function(){
                    if (this.height) {
                        this.domNode.style.height = this.height + 'px';
                    }
                },
                onwidthChange: function(){
                    if (this.width) {
                        this.domNode.style.width = this.width + 'px';
                    }
                },
				onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },
            
            formatHandlers: {
                domNode: ['RW', 'B', 'background-color', 'fx']
            },
            
            /**
             * Adds css for rounded rectangles (if required and supported).
             * 
             * @ignore
             */
            preBuildRendering: function preBuildRendering() {
            	var rtn = this._super(),
            		defn = this.defn;
            	
            	// Is this actually a rounded rectangle?
            	if (defn.r) {
            		// Add the css for border-radius.
               		this.domNodeCssText += mstrmojo.css.buildRoundCorners(defn.r, defn.topc);
            	}
            	
            	return rtn;
            },
            
            /**
             * <P>Compute rectangle width/height when it is set at 100% with border in order to display border property</p>
             * @ignore
             */
            postBuildRendering: function() {
                var rtn = this._super();
                   
                //#392459 - rectangles 100% width/height with border:
                var fmts = this.fmts;
                if (fmts) {
                    var b = fmts.border || fmts['border-width'],
                        bw = b && (parseInt(b, 10) / 72 * this.model.dpi ); //convert pt to px
                        
                    if (bw) {
                        if (fmts.height == '100%') {
                            this.set('height', this.domNode.clientHeight - 2 * bw);
                        }
                        if (fmts.width == '100%') {
                            this.set('width', this.domNode.clientWidth - 2 * bw);
                        }
                    }
                }
                return rtn;
            },
            
            update: function update(node) {
                // if there is a threshold, kill the format
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }
                
                this.thresholdId = node.data.tid;
                
				this.set('visible', !node.data.hidden);
				
                if (this._super) {
                    this._super(node);
                }
            }
        }
    );
    
})();
(function() {
	mstrmojo.requiresCls("mstrmojo.array",
						 "mstrmojo.BarcodeReader",
						 "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton");
	
	var $ARR = mstrmojo.array;
	
	mstrmojo.android.inputControls.BarcodeDIC = mstrmojo.declare(
			
		mstrmojo.Widget,
		
		[mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton],
		
		{
			scriptClass: 'mstrmojo.android.inputControls.BarcodeDIC',
			
			markupString: '<div></div>',
			
			/**
             * @override mstrmojo._IsInputControl.showInPopup
             */
            showInPopup: function(){
            	var me = this;
            	var callback = {
	                success: function (val) {
	                	if (val !== '') {
	                		// val stores the element index when 'Match barcode against attribute elements' 
	                		// is enabled; otherwise, it stores the barcode value.
	                		if (!!me.dic.em) {
	                			me.value = me.dic.vls[parseInt(val, 10)].v;
	                		} else {
	                			me.value = val;
	                		}
	                		
		                	me.applyChanges();
	                	}
	                },
	                
	                failure: function (val) {}
	            };
            	
            	// 'barcodeDIC' property is used by Java to choose Activity
            	var params = {'barcodeDIC': true};
            	// if 'Match barcode against attribute elements' is enabled
            	if (!!me.dic.em) {
            		var vls = [];
            		$ARR.forEach(me.dic.vls, function(o, i){
            			// search against 'barcode form' 
            			vls[i] = o.m || o.v;
            		});
            		
            		params.vls = vls;
            	}
            	
            	mstrmojo.BarcodeReader.readBarcodes(params, callback, this.popupTitle);
            }
		}
	)
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo.dom",
                         "mstrmojo.hash",
                         "mstrmojo.css");

    var $DOM = mstrmojo.dom,
        $HASH = mstrmojo.hash,
        $CSS = mstrmojo.css;

    /**
     * <p>A button that can hold an image or text.</p>
     *
     * @class
     * @extends mstrmojo.Widget
     */
    mstrmojo.Button = mstrmojo.declare(
        // superclass
        mstrmojo.Widget,

        // mixins
        null,

        /**
         * @lends mstrmojo.Button.prototype
         */
        {
            scriptClass: 'mstrmojo.Button',

            /**
             * An optional second CSS class that will be added to the domNode "class" attribute.
             * Typically used for setting an icon for the Button.
             *
             * @type String
             */
            iconClass: '',

            /**
             * An optional CSS class that will be added to the textNode "class" attribute.
             * Typically used for setting an icon for the Button, especially the Button has iconClass set with other background.
             *
             * @type String
             */
            innerIconClass: '',

            /**
             * The tooltip for this button.
             *
             * @type String
             */
            title: '',

            /**
             * An optional text to appear in the button.
             *
             * @type String
             */
            text: '&nbsp;',

            /**
             * Whether the button is enabled.
             *
             * @type Boolean
             */
            enabled: true,

            /**
             * Whether the button is selected.
             *
             * @type Boolean
             */
            selected: false,

            /**
             * css display property value used when widget is visible
             * @type String
             */
            cssDisplay: 'block',

            /**
             * @ignore
             */
            markupString: '<div id="{@id}" class="mstrmojo-Button {@cssClass} {@iconClass}" title="{@title}" style="{@cssText}" mstrAttach:touchstart,click,mousedown,mouseup>' +
                            '<div class="mstrmojo-Button-text {@innerIconClass}"></div>' +
                          '</div>',

            /**
             * @ignore
             */
            markupSlots: {
                textNode: function () { return this.domNode.firstChild; }
            },

            /**
             * @ignore
             */
            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; },
                onenabledChange: function () {
                    $CSS[this.enabled ? 'removeClass' : 'addClass'](this.domNode, ['disabled']);
                },

                onselectedChange: function () {
                    $CSS[this.selected ? 'addClass' : 'removeClass'](this.domNode, ['selected']);
                },

                ontextChange: function () {
                    this.textNode.innerHTML = this.text;
                },

                onwidthChange: function () {
                    var w = this.width;
                    if (w) {
                        this.domNode.style.width = w;
                    }
                }
            },

            oniconClassChange: function oniconClassChange(evt) {
                if (this.hasRendered && this.domNode) {
                    var old = evt.valueWas,
                        v = evt.value;
                    this.domNode.className = this.domNode.className.replace(old, '') + ' ' + v;
                }
            },

            /**
             * Called when the button is clicked.
             */
            onclick: mstrmojo.emptyFn,

            ontouchend: function ontouchend(evt) {
                this.onclick(evt);
            }
        }
    );

    /**
     * Helper function to create icon button configuration objects.
     *
     * @param {String} t The tooltip text to display in the button.
     * @param {String} c The css class(es) used to display the button image.
     * @param {Function} fn The function to execute when the button is clicked.
     * @param {Object} [b] An optional collection of bindings for this button.
     * @param {Object} [ps] An option collection of properties to be added to the button config.
     *
     * @returns {Object} The button config.
     *
     * @static
     */
    mstrmojo.Button.newIconButton = function (t, c, fn, b, ps) {
        // Create the button config.
        var btn = {
            scriptClass: 'mstrmojo.Button',
            title: t,
            cssClass: c,
            text: '',
            onclick: fn
        };

        // Are there bindings?
        if (b) {
            // Add the bindings.
            btn.bindings = b;
        }

        // copy extra properties
        $HASH.copy(ps, btn);

        return btn;
    };

    /**
     * Helper function to create an interactive text button.
     *
     * @param {String} t The text to appear in the button.
     * @param {Function} [fn] An optional function to execute when the button is clicked.
     * @param {String} [haloColor] The color to use a the active halo
     * @param {Object} [ps] An optional collection of properties to add to the button.
     *
     * @return {Object} The button configuration object.
     */
    mstrmojo.Button.newInteractiveButton = function (t, fn, haloColor, ps) {
        // Create base button config.
        var btn = {
            scriptClass: 'mstrmojo.Button',
            cssClass: 'mstrmojo-InteractiveButton',
            text: t,
            glowClass: "glow"
        };

        // Do we have an onclick function?
        if (fn) {
            btn.onclick = fn;
        }

        // Should the buttons use halo?
        if (haloColor && ($DOM.isFF || $DOM.isWK)) {
            // Add the mousedown and mouseup to apply halo.
            $HASH.copy({
                onmousedown: function () {
                    $CSS.applyShadow(this.domNode, 0, 0, 10, haloColor);
                },
                onmouseup: function () {
                    $CSS.removeShadow(this.domNode);
                }
            }, btn);
        }

        // Copy extra properties.
        $HASH.copy(ps, btn);

        return btn;
    };
}());
(function(){

	mstrmojo.requiresCls("mstrmojo.Widget", "mstrmojo._ListSelections");
	
	/**
	 * ListBase is an "abstract" base class for list widgets that display a 1-D array of data items.
	 * It is called "abstract" in the sense that it does not implement the 4 methods "_markupPrefix", "_markupSuffix", "_itemPrefix" and "_itemSuffix".
	 * These methods are implemented by subclasses such as ListBox and ListBoxHoriz in order to render a table layout.
	 */
	mstrmojo.ListBase = mstrmojo.declare(
		// superclass
		mstrmojo.Widget,
		
		// mixins
		[mstrmojo._ListSelections],
		
        // instance members 
		{
			scriptClass: "mstrmojo.ListBase",
			
		
            selectionPolicy: null,
            
			/**
			 * Responsible for defining the HTML of each data item, and optionally for marking a rendered item as selected,
			 * unselected, hovered, or unhovered. The itemRenderer should have the following public members:
			 * {
			 *		render: function(item, index, widget),		// required
			 *		select: function(el, item, index, widget),	// optional
			 *		unselect: function(el, item, index, widget),	// optional
			 *		hover: function(el, item, index, widget),	// optional
			 *		unhover: function(el, item, index, widget),	// optional
			 *		colWidth: Integer	// optional
			 * }
			 */
			itemRenderer: null,
			
            /**
             * CSS text for the items container node.
             * 
             * @type String
             * @default ''
             */
            icnCssText: '',
            
            /**
             * CSS class name for the items container node.
             * 
             * @type String
             * @default
             */
            icnCss: '',
            
            markupString: '<div id="{@id}" class="mstrmojo-ListBase {@cssClass}" style="{@cssText}" mstrAttach:click,mouseover>' + 
                              '<div class="{@icnCss}" style="{@icnCssText}">{@itemsHtml}</div>' + 
                          '</div>',
			
			markupSlots: {
                itemsContainerNode: function() { return this.domNode.firstChild; },
                scrollboxNode: function() { return this.domNode; }
			},
			
			markupMethods: {
                onvisibleChange: function() { this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; },
                onheightChange: function() { if (this.height) this.domNode.style.height = this.height; },
                onwidthChange: function() { if (this.width) this.domNode.style.width = this.width; }
			},
									
			/**
			 * Extends the rendering by defining the "itemsHtml" property at run-time, thus rendering
			 * the data items.
			 */
			buildRendering: function bldRnd() {
				// Set the itemsHtml property to an HTML string for the first page of table cells.
				this.itemsHtml = '';
				var len = this.items && this.items.length;
				if (len) {
					this.itemsHtml = this._buildItemsMarkup(
										0, 
										len-1, 
										this._markupPrefix && this._markupPrefix(),
										this._markupSuffix && this._markupSuffix(),
										this._itemPrefix && this._itemPrefix(),
										this._itemSuffix && this._itemSuffix()).join('');
				}
				
				// This does the actual DOM construction, and attaches listener to our own scrollbox.
				// We assume the scrollbox is our own, not our parent's. 
				// TO DO: does this.connectScrollbox(this) cause 2 listeners to be attached?
				this._super();	
				
				delete this.itemsHtml;
				// Record pointer to the newly constructed table for future reference.
				this.addSlots({itemsNode: this.itemsContainerNode.firstChild});
			},
			
			_markupPrefix: null,
			_markupSuffix: null,
			_itemPrefix: null,
			_itemSuffix: null,
						
			/**
			 * Returns an HTML string for a <table> with a single <tbody> whose rows contain the data from the items
			 * of a given range of indices.
			 */
			_buildItemsMarkup: function(/*Integer*/ start, /*Integer*/ end, /*String?*/ markupPrefix, /*String?*/ markupSuffix, /*String?*/ itemPrefix, /*String?*/ itemSuffix) {
				// For performance, we generate the HTML as an array of small strings, which the caller can then join when needed.
				var markup = [],
					count = 0;
				markup[count++] = markupPrefix || '';

				// Do we have an item renderer with a render function?				
				var ir = this.itemRenderer,
					fn = ir && ir.render;
				if (fn && typeof(fn) == "function") {
					// Walk the items and generate a single table row of HTML for each.
					var PRE = itemPrefix || '',
						POST = itemSuffix || '',
						its = this.items,
						len = (its && its.length) || 0,
						me = this;
					for (var i=start, stop=Math.min(end+1, len); i<stop; i++) {
						markup[count++] = PRE;
						markup[count++] = fn(its[i], i, me);
						markup[count++] = POST;
					}
				}
								
				markup[count++] = markupSuffix || '';
				return markup;
			},
			
            /**
             *  Handler for selectionChange event, raised by _ListSelections mixin.
             */			
            onselectionChange: function onselChg(evt) {
                if (!evt) {
                    return;
                }
                
                var ir = this.itemRenderer;
                if (!ir) {
                    return;
                }
                
                var unsel = ir.unselect,
                    its = this.items || [],
                    rem = evt.removed,
                    ix, el;
                
                if (unsel && rem) {
	                // ask itemRenderer to unhighlight previous selections
	                for (var j=0, jLen=rem.length; j<jLen; j++) {
	                    ix = rem[j];
	                    el = this._getItemNode(ix);
	                    if (el) {
		                    unsel(el, its[ix], ix, this);
	                    }
	                }
				}
                
                var sel = ir.select,
                    added = evt.added;

                if (sel && added) {
                    // ask itemRenderer to highlight selections
                    for (var i=0, len=added.length; i<len; i++) {
                        ix = added[i];
                        el = this._getItemNode(ix);
                        if (el) {
                            sel(el, its[ix], ix, this); 
                        }
                    }             
                }
                
                // A hook for custom behavior
                if (this.onchange) {
                	this.onchange();
                }
            },
            
            /**
             * Handler for select event, raised by _ListSelections mixin
             */
            onselect: function onsel(evt) {
            	if (this.makeSelection && evt.idxs && evt.idxs.length) {
            		var selItem = this._getItemNode(evt.idxs[0]);
            		this.makeSelection({
            			selIdx: evt.idxs[0],
            			selItem: selItem
            		});
            	}
            },
            
            /**
             * If true, this widget will set its "visible" property when we set its "items" property:
             * false if items is null or an empty array, true otherwise.
             */
            autoHide: false,
            
            /**
             * Extends the inherited method in order to implement the "autoHide" feature.
             */
            init: function init(/*Object?*/ props) {
            	this._super(props);
				if (this.autoHide) {
					this.visible = !!(this.items && this.items.length);
				}
            }, 
            
            _getItemNode: function(idx) {
                var itemsNode = this.itemsContainerNode;
                return (itemsNode && itemsNode.childNodes[idx]) || null;
            }, 
            
            /**
             * Custom setter for "items", implements the autoHide feature.
             */
			_set_items: function stitems(n, v) {
				if (this.autoHide) {
					this.set('visible', !!(v && v.length));
				}
				var was = this.items;
				this.items = v;
				if (was != v) {
					var hr = this.hasRendered;
					if (hr) {
						this.unrender();
					}
					// Setting items clears any prior selections.  Previously we only cleared
					// selections that are out of bounds, but this breaks lists in popups
					// that only have 1 item, yet need to have their selectedIndex reset to -1
					// every time they are opened.
					this.clearSelect();

                    if (hr) {
                        this.render();
                    }
					return true;
				} else {
					return false;
				}
				return was != v;
			}
		}
	);
})();			
(function () {

    mstrmojo.requiresCls("mstrmojo.publisher",
                         "mstrmojo.Widget",
                         "mstrmojo._HasChildren");

    var _P = mstrmojo.publisher;

    /**
     * <p>Base widget container class.</p>
     *
     * <p>Container is a widget that contains other "child" widgets. Typically used to arrange other widgets
     * visually in a GUI.</p>
     *
     * @class
     * @extends mstrmojo.Widget
     */
    mstrmojo.Container = mstrmojo.declare(
        // superclass
        mstrmojo.Widget,

        // mixins
        [ mstrmojo._HasChildren ],

        /**
         * @lends mstrmojo.Container.prototype
         */
        {
            /**
             * @ignore
             */
            scriptClass: "mstrmojo.Container",

            /**
             * <p>The default slot name under which children should be placed.</p>
             *
             * <p>Typically each child has a "slot" (String) property which indicates which "slot node" that child's DOM should
             * be appended to. If the chid's "slot" property is undefined, we assume this default instead.</p>
             */
            defaultChildSlot: "containerNode",

            /**
             * <p>Base widget container class.</p>
             *
             * <p>Overwrites the inherited constructor {@link mstrmojo.Widget#init} in order to initialize child widgets (if any)
             * before initializing this object's bindings.</p>
             *
             * @constructs
             * @param {Object} [props] Hash of property values to be applied to this instance.
             */
            init: function init(props) {
                this._super(props);

                // If we have a "children" config, initialize our children.
                if (this.children) {
                    this.initChildren();
                }

                // If we are an orphan, init our bindings now (if any). Otherwise we have a parent,
                // and that parent is responsible for calling us later to init our bindings, after it
                // has finished constructing its children.
                // Note: If we have no bindings, our children still might, so dont skip initBindings call.
                var p = this.parent;
                if (!p || p.hasInitBindings) {
                    this.initBindings();
                }
            },

            /**
             * <p>Extends the inherited method in order to call destroy on its child objects and its bindings before
             * destroying itself.</p>
             *
             * <p>This method destroys this object's children first before destroying this object's bindings.
             * Typically, children with bindings are bound to properties in their ancestors. Therefore, we wait
             * until after our children are destroyed to destroy our own bindings, thereby reducing the number of
             * binding events raised by our own destruction.</p>
             *
             * <p>This method passes a flag along to its children's "destroy" call which lets the children know
             * that they can skip the DOM cleanup, because it will be handled by this container.</p>
             */
            destroy: function dst(skipCleanup) {
                if (this.children) {
                    this.destroyChildren(true);
                }
                if (this.bindings) {
                    this.destroyBindings();
                }
                this._super(skipCleanup);
            },

            /**
             * <p>Extends the inherited method to unrender all children before unrendering this container.</p>
             *
             * <p>This container calls the children's "unrender" before performing its own unrender, because
             * the children might assume that their domNode is still in the document when their unrender is called.</p>
             *
             * <p>This method also passes a flag along to its children's "unrender" call which lets the children know
             * that they can skip the DOM cleanup, because it will be handled by a container. This is intended as
             * a performance optimization, so that the children's DOM can be removed from the document in a single batch operation.</p>
             *
             * @param {Boolean} ignoreDom If true we don't need to clear the DOM (meaning it'll be handled by a parent/ancestor).
             */
            unrender: function unrn(ignoreDom) {
                var c = this.children,
                    len = (c && c.length) || 0,
                    i;
                for (i = len - 1; i > -1; i--) {
                    c[i].unrender(true);
                }
                this._super(ignoreDom);

            },

            /**
             *
             * <p>Extends the rendering cycle to trigger the rendering of child widgets, if any.</p>
             *
             * <p>This method triggers the rendering of this container's children after the container's domNode
             * has been rendered but BEFORE the container's "hasRendered" property is set to true.</p>
             */
            postBuildRendering: function pstBR() {
                var ret = this._super ? this._super() : undefined;
                if (ret !== false) {
                    this.renderChildren();
                    // Override the return value to show that we rendered.
                    ret = true;
                }
                return ret;
            },

            /**
             * <p>Asks all children who are ready for rendering to render now.</p>
             *
             * <p>Container's implementation of renderChildren renders
             * all the children immediately who pass the "childRenderCheck" filter.
             * Subclasses of Container can enhance/overwrite this behavior to support alternative rendering modes.
             */
            renderChildren: function rnCh() {
                var ch = this.children,
                    len = (ch && ch.length) || 0,
                    i;

                for (i = 0; i < len; i++) {
                    var c = ch[i];
                    if (this.childRenderCheck(c)) {
                        c.render(null);
                    }
                }
            },

            /**
             * <p>Returns true if a given child is ready to be rendered.</p>
             *
             * <p>A child is considered ready if:</p>
             * <ol>
             * <li>the child has not rendered yet, and</li>
             * <li>the child's "slot" property corresponds to a non-null slot in this Container.</li>
             * </ol>
             *
             * <p>The slot check was important because a container may choose to
             * deliberately omit a slot so that certain children won't render.</p>
             *
             * @param {mstrmojo.Widget} child The child widget to be checked.
             * @returns {Boolean} true if the child is ready to be rendered; false otherwise.
             */
            childRenderCheck: function chRnCk(c) {
                if (c && !c.hasRendered) {
                    var s = c.slot || this.defaultChildSlot;
                    return !!this[s];
                }
                return false;
            },

            /**
             * <p>Extends the inherited method to trigger the rendering of newly added children.</p>
             */
            addChildren: function addCh(c, idx, silent) {
                var arr = this._super(c, idx, silent);
                if (arr) {
                    this.childRenderOnAddCheck(arr);
                }
                return arr;
            },

            /**
             * <p>Extends the inherited method to remove the children's DOM.</p>
             */
            removeChildren: function rmCh(c, silent) {
                var c2r = c ? [c] : (this.children || []),
                    len = c2r.length,
                    i;

                // Remove domNode(s) from slot(s).
                for (i = len - 1; i > -1; i--) {
                    var w = c2r[i],
                        dn = w && w.domNode;
                    if (dn) {
                        var s = this[(w.slot || this.defaultChildSlot)];
                        if (dn.parentNode === s) {
                            s.removeChild(dn);
                        }
                    }
                }

                // Call the inherited method to remove children from this.children.
                return this._super(c, silent);
            },

            /**
             * <p>Checks if newly added child should be rendered.</p>

             * <p>Called when children are newly added.  Checks if each child should be rendered, and if so,
             * calls the child's render() method. If the child has already been rendered, attempts to include
             * its rendering within this container's rendering.</p>
             *
             * <p>If this container has not been rendered, this method does nothing.</p>
             *
             * @param {mstrmojo.Widget[]} ch The newly added child widgets to be checked.
             */
            childRenderOnAddCheck: function childRndrOnAddChk(ch) {
                if (this.hasRendered && ch) {
                    var len = ch.length,
                        i;

                    for (i = 0; i < len; i++) {
                        var c = ch[i];
                        if (this.childRenderCheck(c)) {
                            c.render();
                        } else if (c && c.hasRendered) {
                            this.onchildRenderingChange(c);
                        }
                    }
                }
            },

            /**
             * <p>If true, the domNodes of the Container's children will be inserted into their
             * corresponding slot nodes in the same order in which the children are listed in the "children" array
             * property.</p>
             *
             * <p>Otherwise, the domNodes are appended to their corresponding slot nodes in whatever
             * order they happen to be rendered; by default, that order is the same sequence as the "children" array,
             * but in general, other subclasses can modify that order if desired (for example, an "on-demand" rendering mixin).</p>
             *
             * @type Boolean
             */
            preserveChildDomOrder: true,

            /**
             * <p>Inserts a given child widget's DOM into a slot of this container. Once all children are
             * rendered, raises a "childrenRendered" event.</p>
             *
             * <p>The target slot name is determined by the child's "slot" property (if missing,
             * this container's "defaultChildSlot" property value is assumed).</p>
             *
             * <p>If the targeted slot is not defined in the current rendering, the child widget's domNode is
             * simply removed from DOM until future use.
             * If the targeted slot is defined, the child's domNode will be appended to
             * the slot node, unless this Container's "preserveChildDomOrder" property is
             * true; if so, the child's domNode will be inserted at the child index corresponding
             * to the child's order in this container's "children" array.</p>
             *
             * @param {mstrmojo.Widget} child The child whose rendering is to be inserted.
             */
            onchildRenderingChange: function onChldChngRndr(child) {
                var d = child && child.domNode;
                if (!d) {
                    return;
                }

                // Compare the domNode's parentNode to the slot node it belongs under.
                var sdef = this.defaultChildSlot,
                    s = child.slot || sdef,
                    n = this[s],
                    ch = this.children;

                if (!n) {
                    // No slot found. Remove child domNode from DOM.
                    if (d.parentNode) {
                        d.parentNode.removeChild(d);
                    }
                } else {
                    // We have a slot. Is the domNode already inserted into the slotNode?
                    // TO DO: Do we really need this parentNode check? What happens if you try to call node.parentNode.appendChild(node)?
                    if (d.parentNode === n) {
                        return;
                    }
                    // Insert the domNode; compute the insertion index.
                    if (!this.preserveChildDomOrder) {
                        // Append the domNode, insertion index is irrelevant.
                        n.appendChild(d);
                    } else {
                        // Compute an insertion position. Find the domNode of the last preceeding child in the same slot (if any).
                        var sib,
                            i;

                        for (i = ch.length - 1; i >= 0; i--) {
                            var c = ch[i];

                            // Is this the rendered child?
                            if (c === child) {
                                // We've found the child so the last sib value is it's sib.
                                break;
                            }

                            // Is this child in the same slot as the rendered child?
                            if (s === (c.slot || sdef)) {
                                // Does it have a domNode?
                                var cNode = c.domNode;

                                // Does the parent of the domNode match the slotNode?
                                if (cNode && cNode.parentNode === n) {
                                    // This is the node of the child that should appear after the rendered child.
                                    sib = cNode;
                                }
                            }
                        }

                        // Do we have a child that should appear after the rendered child?
                        if (sib) {
                            // Yes, then insert the child before that node.
                            n.insertBefore(d, sib);
                        } else {
                            // No, then append the child to the slot node.
                            n.appendChild(d);
                        }
                    }
                }

                // Raise a "childrenRendered" if all children are now rendered.
                if (_P.hasSubs(this.id, "childrenRendered")) {
                    var klen = ch.length,
                        k;

                    // Iterate my children
                    for (k = 0; k < klen; k++) {
                        // Does the domNode NOT exist?  We check for the existence of the domNode rather than the isRendered flag because at this point, the
                        // isRendered flag has not been set yet.
                        if (!ch[k].domNode) {
                            // No, then no reason to raise event.
                            return;
                        }
                    }

                    // All children are rendered so raise the event.
                    this.raiseEvent({
                        name: "childrenRendered"
                    });
                }
            }
        }
    );

}());
(function(){

    var AUTO_TR = '<tr>';
    var TBL_MKP_START = ['<table cellspacing="0" cellpadding="0" style="table-layout:', null,
                                                   ';width:', null,
                                                   ';mstr-tablestyle-slot" ', null,
                                                   '>', null,
                                                   '<tbody>'];
    var NBSP = "&nbsp;";
    var STITCH_TOP_CSS = "fsbp_1 ";
    var STITCH_MIDDLE_CSS = "fsbp_2 ";
    var STITCH_BOTTOM_CSS = "fsbp_3 ";
    var STACK_TOP = 1,
        STACK_MIDDLE = 2,
        STACK_BOTTOM = 3,
        NO_STACK = 4,
        FULL_STACK = 5,
        STACK_CSS = {
        1: ' stack-top',
        2: ' stack-middle',
        3: ' stack-bottom',
        4: ' no-stack',
        5: ' stack-full'
    };

    var $CSS = mstrmojo.css;

    var BASEFORM_PICTURE = 4;

    /**
     * The function stitch the cells in the last block of data
     * @param {Array} cells the array holding the locations of the cells that needs to be stitched
     * @param {DOMNode} tbody The tobody which has the last rows to be stitched
     */
    function stitchBottomCells(cells, tbody) {
        for(var i=0, iLen = cells.length; i < iLen; i++) {
            var c = cells[i];
            var d = tbody.rows[c.rows].cells[c.cells];
            if(d) {
                mstrmojo.css.addClass(d, STITCH_TOP_CSS);
            }
        }

    }

    mstrmojo.requiresCls(
            "mstrmojo.Widget");

    mstrmojo.GridBase = mstrmojo.declare(
        // superclass
        mstrmojo.Widget,

        // mixins.
        null,

        // instance methods
        {
            scriptClass: "mstrmojo.GridBase",

            // Note - this can be overriden in the widgets extending this one e.g. XtabZone.
            markupString: '<span id="{@id}" class="mstrmojo-Grid {@cssClass}" style="{@cssText}"></span>',

            markupSlots: {
                gridContainerNode: function(){ return this.domNode; }
            },

            /**
             * AutoFitWindow - This property represents whether auto fit to window is set ON for the Table.
             * The value should be set by the parent container (e.g. Xtab, SelectorControl).
             */
            autoFitWindow:false,

            /**
             * This property represents the fixed layout to use (auto or fixed). For Xtabs, we would typically figure out the value using col widths collection, however
             * for cases like Selector Controls the caller may want to force the layout (e.g. Auto when ItemWidthMode is set to Proportional).
             */
            tableLayout:null,

            /**
            for xtabs, titles & colHeaders zones are not rendered with fixed height. So, we check (and cache) from the CP - number of initial rows that need to be rendered in auto height mode.
            */
            numAutoHeightRows:0,

            /**
            * This property represents the content provider for this zone.
            */
            cp:null,

            /**
            * Row count of this zone. Typically read from the content provider & cached
            * locally for quick lookup.
            */
            rc:0,

            /**
            * Column count of this zone. Typically derived from content provider's column
            * widths array & cached locally for quick lookup.
            */
            cc:0,

            /**
            * Column widths array. Typically read from the content provided & cached
            * locally for quick lookup.
            */
            cws:null,

            /**
             * Row height for every row of this zone. Typically read from content provider
             * and cached locally for quick lookup.
             */
            rh:null,

            /**
             * The total width of all the coloumns in a particular zone.
             */
            totalColWidth: 0,

            /**
             * Index of the Start row to render.
             */
            start:0,

            /**
             * Index of the End row to render.
             */
            end:0,

            forceFixedSizes:true,

            /**
             * A map contains the groups of the domNodes that have been highlighted and the positions of the cells that need
             * to be hilighted
             */
            hiliteCellsMap: null,

            /**
             * A map contains the extra info and the cell position that contains the extra info
             */
            eiMap: null,

            /**
             * Called from constructor.
             */
            init: function init_Grid(/*Object?*/ props) {
                // Apply the superclass constructor first.
                this._super(props);
            },

            /**
             * A number passed by Xtab to identify how many columns the grid can have. The
             * value is used to exclude the cells (such as value cells to be merged)
             */
            numColumnCanMerge: 0,

            /**
             * Preps content provider and caches some commonly-used content provider
             * properties (after null-checking).
             */
            preBuildRendering: function preBuildRendering(res) {
                var cp = this.cp;
                if(!cp) {
                    return;
                }
                cp.initContent();
                this.rc = cp.rc || 0;           // Row count.
                this.cws = cp.colWidths || [];  // Column widths array.
                this.cc = this.cws.length;              // Column count.

                this.tdWidths = cp.tdWidths || [];	// table td widths array
                this.tdCnt = this.tdWidths ? this.tdWidths.length : 0;	// table td count in one row

                this.start = 0;
                this.end = this.rc - 1;

                // for xtabs, titles & colHeaders zones are not rendered with fixed height. So, we check (and cache) from the CP - number of initial rows that need to be rendered in auto height mode.
                this.numAutoHeightRows = cp.getNumAutoHeightRows && cp.getNumAutoHeightRows() || 0;

                this.hiliteCellsMap= {};
                this.eiMap= {};
                this.posMap = [];
                this.thPosMap = [];

                //initial the totalColWidth
                this.totalColWidth = 0;

                // trigger the parent's prebuild rendering.
                //return this._super(res);
            },

            /**
             * Extends the widget's buildRendering method in order to first build a "tableHtml" string
             * from the widget's data and store the string in a widget property,
             * which can then be applied to the rendering.
             */
            buildRendering: function buildRendering(res) {
                // The inherited method will do the actual DOM construction.
                var ret = this._super(res);

                this.renderGrid();

                return ret;
            },

            /**
             * This is the main method that renders the Grid Table. It builds the table at the position specified by top, left.
             * @param {Boolean} [append] If the append flag is set to be true, the give rows [start, end] will be rendered into a tbody and append to the grid container.
             * Otherwise, the grid data will replace the whole content in the grid container.
             */
            renderGrid: function renderGrid(append) {
                // Which node should the Grid Table reside in ?.
                var containerNode = this.getGridContainer();

                // extensions for subclasses to override
                this.preBuildGridTable();

                // build the grid table.
                this.buildGridTable(containerNode, append);

             // extensions for subclasses to override
                this.postBuildGridTable();
            },

            /**
             * This builds a DOM Container node that will host the Grid HTML. Since we would be rendering tableHTML for some on demand cases, this API abstraction would help avoid having to overwrite innerHTML as we
             * build new tableHTMLs on demand. Note that in IE, we cannot change innerHTML table - otherwise we may be able to avoid this container node.
             */
            getGridContainer: function getGridContainer() {
                return this.gridContainerNode;
            },


            /**
             * Constructs the Grid Table. .
             */
            buildGridTable: function buildGridTable(/* DomNode */ gridContainer, /* Boolean */append) {
                // build the table start markup (<table ...><colgroup>....</colgroup><tbody>)
                var tms = this.getTableStartMarkup();

                // build the table end markup (</tbody></table>)
                var tme = this.getTableEndMarkup();

                // set mergeHdrsAcrossBlks flag to notify merging headers when building table
                if(append) {
                    this.mergeHdrsAcrossBlks = true;
                }

                // finally build the table rows markup. The APIsupports prefix and suffix which we will use to concatenate the tableStart and tableEnd markups above.
                var tInnerHTML = this.buildTableRowsMarkup(this.start, this.end, tms, tme).join('');

                if(append) {
                    // Create the HTMLElement from html fragment.
                    var creationContainer = document.createElement('div');
                    creationContainer.innerHTML = tInnerHTML;

                    var cn = gridContainer.firstChild,
                        tBodies = cn && cn.tBodies,
                        ntBody = creationContainer.firstChild.tBodies[0],
                        mh = this.matchedHdrsAcrossBlks;

                    cn.appendChild(ntBody);

                    if(mh && mh.length > 0) {
                        stitchBottomCells(mh, tBodies[tBodies.length - 2]);
                    }
                } else {
                    // Replace the container HTML.
                gridContainer.innerHTML = tInnerHTML;
                }
            },

            getTableStartMarkup : function _bldTableSMkp() {
                // get the grid column widths
                var gw = this._getGridWidths(),
                       mkp = TBL_MKP_START;

                mkp[1] = gw.tableLayout;

                mkp[3] = gw.totalColWidths;

                // since we render <table> within <table> (Xtab-Table::XtabZone-Tables), some of the CSS properties from outer table don't get inherited e.g. border, padding. This is
                // a way to accomplish that - pass on the css class to inner tables.
                mkp[5] = this.tableCssClass ? "class=" + this.tableCssClass : '';

                mkp[7] = '<colgroup>' + gw.colgroup + '</colgroup>';

                if(this.tbodyStyle) {
                    mkp[8] = '<tbody style="' + this.tbodyStyle + '">';
                }
                return mkp.join('');
            },

            getTableEndMarkup : function _bldTableEMkp() {
                return '</tbody></table>';
            },

            /**
             * Returns a JSON Object that includes grid column widths related information.
             * {
             *     totalColWidths: String               // total of the column widths
             *     colgroup:String                                 // col group String for the table HTML
             *     tableLayout:String                           // table layout based on settings, colwidths.
             * }
             */
            _getGridWidths : function _initGridWidths() {
                var gw = {};

                // Replace the tableContainerNode's HTML with a row-less table.
                var totalColWidths = '',
                    colgroup = [],
                    tl='fixed',
                    cws = this.cws,
                    cols = cws.length;

                if (cols) {
                    totalColWidths = 0;
                    colgroup = [];
                    // TQMS 395589: for IE7, the column width value setting on col tag is normally smaller than the expected column width.
                    // Using percentage in column width for IE, we can get expected column width.
                    for (var i=0; i<cols; i++) {
                        if(cws[i].w !== "") {
                            totalColWidths += parseInt(cws[i].w, 10);
                        }
                    }

                    for (i=0; i<cols; i++) {
                        var width = cws[i];
                        if(width.w !== "") {
                            // update the total.
                            var w = parseInt(width.w, 10);

                            // add col group string.
                            if (mstrmojo.dom.isIE7) {
                                if(w === 0) {
                                    colgroup.push('<col style="width:0%;display:none"></col>');
                                } else {
                                    colgroup.push('<col style="width:' + (w / totalColWidths * 100) + '%"></col>');
                                }
                            } else if (mstrmojo.dom.isWK && w === 0) {
                                //Bug with Webkit browsers causes it to mess up the grid widths if set to 0. Small values such as 0.0001px and the likes don't work either.
                                //So, I've set the col width to -1px.
                                colgroup.push('<col style="width:-1px"></col>');
                            } else {
                                colgroup.push('<col style="width:' + width.w +'"></col>');
                            }
                        } else {
                            colgroup.push('<col />');
                            // if any of the widths is not fixed, grid needs to be rendered in auto mode.
                            tl = 'auto';
                        }
                    }

                    //Cache the value of the total col widths in a class property
                    this.totalColWidth = totalColWidths;
                }

                //425393
                // update our gridWidths object.
                gw.colgroup = colgroup.join('');

                // do we have a tableLayout set ? If yes, use that otherwise, use the value derived through the column widths iteration above.
                tl = this.tableLayout || tl;

                if(this.autoFitWindow) {
                    // Xtabs render in 'fixed' mode for this setting. So, unless the setting is forced (using tableLayout), use 'fixed'.
                    tl = this.tableLayout || tl || 'fixed';
                    totalColWidths = '100%';
                } else if(tl == 'fixed') {
                    totalColWidths += 'px';
                } else {
                    totalColWidths = 'auto';
                }

                // update our gridWidths object.
                gw.totalColWidths = totalColWidths;
                gw.tableLayout = tl;

                return gw;
            },


            /**
             * Array of static string parts that comprise the HTML for a table cell.  Dynamic parts are left as null.
             * They are populated at run-time as each cell is rendered by the method _buildRowsMarkup.
             */
            //_CELL_MARKUP: ['<td style="overflow:hidden;white-space:nowrap" rowSpan="', null, '" colSpan="', null, '" class="', null, '" ei="',null, '">', null, '</td>'],
            _CELL_MARKUP: ['<td rowSpan="', null, '" colSpan="', null, '" class="', null, '" ei="',null, '" style="', null, '" r="', null, '">', null, '</td>'],

            /**
             * Generates the HTML string for a block of rows starting at the given row index.
             * Since the HTML String can be long and string concatenation can be slow, we avoid doing
             * concatenations here by returning an array of small strings.  The caller
             * function can then do an Array.join('') to build the result String when desired.
             * As an optimization, we support an optional "markup" Array argument. If given, this
             * array will be appended to with the HTML string pieces; otherwise a new array is constructed.
             * This argument allows us to support a performance optimization whereby, for the first block of
             * rows rendered, we do NOT set the innerHTML of a temporary <div> but rather of the actual
             * XtabZone's tableContainerNode itself!
             */
            buildTableRowsMarkup: function _buildRowsMarkup(/*Integer*/ start, /*Integer*/ end, /*String?*/ markupPrefix, /*String?*/ markupSuffix) {
                // Have we been given a string with the markup for the <table> & <tbody> tags?
                // If not, generate our own such string. If so, start our markup with it, and assume it
                // has a <table..> & <tbody> in it; otherwise, start the markup with a plain "<table><tbody>" string.
                // This assumption works because the argument is only ever supplied by our _buildTableMarkup method,
                // which does indeed create the <table> and <tbody> strings.
                var markup = [],
                    i = 0;
                markup[i++] = markupPrefix || '<table><tbody>';

                // Cache handle to content provider for frequent usage.
                var cp = this.cp,
                    // Use the content provider's row height by default
                    rh = cp.getRowHeight(),
                    // Cache HTML string pieces for each <td>.
                    TD = this._CELL_MARKUP,
                    // Cache HTML string for each <tr> [assumes they'll all share the same height].
                    TR = rh ? '<tr style="height:' + (rh ? rh + 'px' : '') + '">' : AUTO_TR;

                // For each row to render...
                var firstRow = true,
                    lastMatched = true,
                    nlr = [], rhi; //the row headers that can across blocks

                this.matchedHdrsAcrossBlks = [];

                for (var r = start; r<=end; r++) {
                    //save markup <tr> index
                    rhi = i++;
                    // Append the <tr> tag. If the row index is less than the number of auto height rows configured, we use the TR markup without row height.
                    markup[rhi] = r < this.numAutoHeightRows ? AUTO_TR : TR;
                    var cells = cp.getRowCells(r);

                    // What is the maximum rowspan a cell can have
                    var maxRowspan = end + 1 - r;

                    var umCellsLen = 0;
                    //stitch Top always assume that the top row has all the elements
                    if(!this.mergeHdrsAcrossBlks) {
                    // Starts stitching the first row when 1. not the first page 2. there some cells missing (cell number < column number)
                    if(firstRow && start > 0 && cells.length < cp.colWidths.length) {
                        // Get the missing cells from content provider
                        var umCells = cp.getUnmergedCells(start);
                        if (umCells) {
                            umCellsLen = umCells.length;
                        }
                        for(var j in umCells) {
                            var p = umCells[j];
                            // Does the rowspan of the cell exceeds the maximun rowspan?
                            if(p.rs > maxRowspan) { // Yes, we need to truncate the row in the generated markup string
                                TD[1] = maxRowspan;
                                // Apply the stitch middle css
                                TD[5] = STITCH_MIDDLE_CSS + p.css;
                            } else { // No, we set the rowspan of the cell to its original value
                                TD[1] = p.rs || 1; //bottom
                                // Apply the stitch bottom css
                                TD[5] = STITCH_BOTTOM_CSS + p.css;
                            }
                            if(p.cet) {
                                TD[5] += " mstrmojo-selected-cell";
                                this.addHilitePosition(p.cet, r, j);
                            }
                            if(p._ei) {
                                this.addExtraInfoMap(p._ei, r, j);
                                TD[5] += " pt";
                            }
                                TD[9] = "";
                                TD[13] = NBSP;
                            TD[3] = p.cs;
                            TD[7] = p._ei !== undefined ? p._ei : "";;

                            markup[i++] = TD.join('') ;
                        }
                        firstRow = false;
                    }
                    }

                    for (var c=0, len=cells.length; c<len; c++) {
                        var cell = cells[c], rt;
                        if(cell.rs && cell.rs > maxRowspan) {
                            TD[1] = maxRowspan;
                            TD[5] = STITCH_TOP_CSS + cell.css;
                            if(cell._ei) {
                                this.addExtraInfoMap(cell._ei, r, c);
                            }

                        } else {
                            TD[1] = cell.rs || 1;
                            TD[5] = cell.css;
                        }

                        if (cell.rowType !== STACK_TOP){
                            TD[5] += " xtab-td ";
                        }

                        if(cell.cet) {
                            TD[5] += "sc_" + this.parent.k;
                            this.addHilitePosition(cell.cet, r, c);
                        }

                        rt = cell.rowType;
                        if(rt) {
                            //set css for the stacked row cells
                            TD[5] += STACK_CSS[rt] || '';
                            //row height for speical rows, most likely the Interactive Grid rows
                            var srh = cp.getRowHeight(rt);
                            if(srh) {
                                markup[rhi] = '<tr style="height:' + (srh ? srh + 'px' : '') + '">';
                            }
                        }

                        TD[3] = cell.cs || 1;
                        // extra info ? Typically for interactivity e.g. Drilling, Selector Controls.
                        TD[7] = cell._ei !== undefined ? cell._ei : "";

                        if (cell.fs || cell._e){
                            this.addTitleHeaderPositionMap(r, c + umCellsLen, cell);
                        }

                        if (cell._ei != null){
                            this.addPositionMap(cell._ei, r, c + umCellsLen);
                        }

                        TD[11] = r;
                        if(cell.ts === BASEFORM_PICTURE) {

                            // if we can use image cache
                            // imgCacheMap object contains:
                            // baseURL: the base URL of the image. The absolute url of the image will be the baseURL + the imageName
                            // cachedImg: an map stores the map from original url to cahced image name
                            // unCachedImg: an array stores the images that are not previously cached

                            /** used for mojo grid
                            if(this.imgCacheMap) {
                                var m = this.imgCacheMap;
                                if(m.cachedImg[cell.v]) {
                                    cell.v = m.baseURL + m.cachedImg[cell.v];
                                } else {
                                    if(this.unCachedMap && !this.unCachedMap["'" + cell.v + "'"]) {
                                        this.unCachedMap["'" + cell.v + "'"] = true;
                                        m.unCachedImg.push(cell.v);
                                    }
                                }
                            }**/

                            var imgUrl = cell.v;
                            //Used for iPhone mojo document
                            if(this.imgCacheMap) {
                                var m = this.imgCacheMap,
                                    v = imgUrl && imgUrl.replace(/\\/g, '/');

                                if(m.cachedImg[v]) {
                                    cell.v = imgUrl = m.baseURL + m.cachedImg[v];
                                } else {
                                    if(v && !m.unCachedImg[v]) {
                                        //this.unCachedMap["'" + v + "'"] = true;
                                        m.unCachedImg[v] = v;
                                    }
                                }
                            } else {
                                var ds = this.parent && this.parent.controller && this.parent.controller.model && this.parent.controller.model.dataService;
                                if ( ds && ds.getImage ) {
                                    imgUrl = ds.getImage(imgUrl);
                                }
                            }

                            // For all cells with a row type (no stack, top, bottom, full stack) we want to add a div and an image tag.
                            if(cell.rowType) {
                            	// Zhang Hongchao 2013-05-31
                            	// change height from cp.stackedRH to cp.getRowHeight(cell.rowType) to make stacked image row and stacked row the same height
                            	// However, I am not clear what's fsHeight for
                            	// Zhang Hongchao 2013-06-08
                            	// using colIdx to get table td width of the given cell, so we can get the max width of the image in the cell
                                var height = (cp.getRowHeight(cell.rowType) || cp.rh || rh),
                                	fsHeight = height,
                                	cws = this.tdWidths,
                                	colIdx = cell.colIdx,
                                	colWidth = 0;
                                if (colIdx!=='undefined' && colIdx>-1 && cws && cws.length>colIdx) {
                                	var cw = cws[colIdx] && cws[colIdx].w;
                                	if (cw !== 'undefined') {
                                		colWidth = parseInt(cw, 10);
                                	}
                                }
                                var maxWidth = colWidth>30 ? (colWidth-30) : 0;
                                    //fsHeight = cp.getRowHeight(FULL_STACK);
                                // #539096 Zhang Hongchao 2013-05-29
                                // change line-height from "**px" to "**px !important" to make it effective;
                                // change img's height to max-height to make smaller images not change;
                                TD[13] = '<div><div style="top:' + (-parseInt(fsHeight/2, 10)) + 'px;height:' + height + 'px;line-height:' + height + 'px !important;">&nbsp;<img style="max-height:' + height + 'px; max-width: ' + maxWidth + 'px;" src="' + imgUrl + '"></img></div></div>';
                            // Is this a lock headers case?
                            } else if (this.parent.gridData.lhv) {
                                // Insert threshold image as a background since table layout is fixed.
                                TD[9] = "background-image:url('" + imgUrl + "');background-repeat:no-repeat;background-position:center " + (cell.rs > 1 ? 'top' : 'center') + ";";
                                TD[13] = NBSP;
                            } else {
                                // Insert threshold image as an <img> tag since table layout is not fixed.
                                TD[9] = '';
                                TD[13] = '<img src="' + imgUrl + '"></img>';
                                //The <span> tag is only added for the cells with clickable text(LINK/DRILL/SELECTOR actions) so that we can
                                //know whether user wants to select this cell or perform the default action on it.
                                if (cell.css && cell.css.indexOf('hl') > -1){
                                    TD[13] = '<span>' + TD[13] + '</span>';
                                }
                            }

                        } else {
                            TD[9] = "";
                            //TQMS 433770 if empty cell, we need &nbsp;. Otherwise the row with only empty cells will shrink.
                            TD[13] = cell.v || cell.n || NBSP;
                            //The <span> tag is only added for the cells with clickable text(LINK/DRILL/SELECTOR actions) so that we can
                            //know whether user wants to select this cell or perform the default action on it.
                            if (cell.css && cell.css.indexOf('hl') > -1){
                                TD[13] = '<span>' + TD[13] + '</span>';
                            }
                        }

                        // if grid can have merged cells across blocks, we should found out those cells
                        // numColumnCanMerge is used for identify the cells we need to check
                        // for unmerged header case, the numColumnCanMerge will be 0
                        if(c < this.numColumnCanMerge) {
                            // if we are at the top of the block, for the cells, the cells that match to the row headers in previous block should be
                            // 1. remove the up border
                            // 2. set the content to be empty string
                            if(r === start && this.mergeHdrsAcrossBlks) {
                                var lr = this.rowHdsAcrossBlks;
                                //lastMatched flag is used to stop the unnecessary comparisons
                                //if we already find any cell that is not match, we should not continue going through all the following cells
                                // because those cells cannot be merged
                                if(lastMatched && cell.v && lr && lr[c]) {
                                    if(cell.v === lr[c].v) { // find the cell that can be merged
                                        TD[1] = cell.rs || 1;
                                        TD[5] = STITCH_BOTTOM_CSS + cell.css;
                                        TD[13] = "";
                                        // push the found cell to the matchedHdrsAcrossBlks array
                                        // the array will be used to merge the headers in previous rendered tbody
                                        this.matchedHdrsAcrossBlks.push(lr[c]);
                                    } else {
                                        lastMatched = false;
                                    }
                                }
                            }

                            if(TD[1] >= maxRowspan && cell.v) { // last row
                                nlr.push({rows: r-start, cells: c, v:cell.v});
                            }
                        }
                        markup[i++] = TD.join('');
                    }
                    // Append the </tr> tag.
                    markup[i++] = '</tr>';
                }

                // Append the </tbody></table> tags.
                markup[i++] =  markupSuffix || '</tbody></table>';

                // cache the row headers that can be across blocks
                this.rowHdsAcrossBlks = nlr;
                return markup;
            },

            addHilitePosition: function(key, row, cell) {
                var hm = this.hiliteCellsMap[key];
                if(!hm) {
                    this.hiliteCellsMap[key] = {pos: [], nodes: []};
                }
                this.hiliteCellsMap[key].pos.push({row: row, cell: cell, page: 0});
            },

            addExtraInfoMap: function(ei, r, c) {
                if(!this.eiMap[ei]) {
                    this.eiMap[ei] = [];
                }
                this.eiMap[ei].push({row:r, cell:c, page: 0});
            },

            addPositionMap: function(ei, r, c){
                //only remember the first cell that has the same _ei
                if(!this.posMap[ei]) {
                    this.posMap[ei] = {row:r, cell:c, page:0};
                }
            },

            addTitleHeaderPositionMap: function(r, c, o){
                this.thPosMap.push({row:r, cell:c, page:0, obj:o});
            },

            /**
             * Clear the highlight cells using the same group key
             * @param {String} key The group key used to group highlighted cells
             */
            clearHilites: function(key) {
                //hilited cells
                var hc = this.hiliteCellsMap[key],
                    ns = hc && hc.nodes,
                    parent = this.parent;

                if(ns) {
                    if (ns.length == 0 && hc.pos) {
                        ns = this.getNodesByPositions(hc.pos);
                    }
                    for(var i = 0, iLen = ns.length; i < iLen; i++) {
                        var nd = ns[i],
                            cn = nd.className,
                            cell = parent.getCellForNode(nd);
                        //TQMS 754169. We must maintain correct value for the cet property in case this grid will be re-rendered
                        if ( cell ) {
                            delete cell.cet;
                        }
                        $CSS.removeClass(nd, "sc_" + parent.k);
                    }
                    this.hiliteCellsMap[key].nodes = [];
                }
            },

            /**
             * Set the given node to be highlighted.
             * @param {String} key the key of the group
             * @param {DOMNode} the dom node that needs to be highlighted
             */
            setHilites: function(key, node) {
                $CSS.addClass(node, "sc_" + this.parent.k);

                if(!this.hiliteCellsMap[key]) {
                    this.hiliteCellsMap[key] = {pos:[], nodes:[]};
                }
                this.hiliteCellsMap[key].nodes.push(node);
                //TQMS 754169. We must maintain correct value for the cet property in case this grid will be re-rendered
                var cell = this.parent.getCellForNode(node);
                if ( cell ) {
                    cell.cet = key;
                }

            },

            /**
             * Get the cell dom node by using the row and column
             * @param {Object} pos A json object contains row and column
             */
            getNodesByPositions: function(/*JSON*/pos) {
                var tbl = this.tableNode,
                    arr = [];

                for(var i in pos) {
                    var v = pos[i];
                    arr.push(tbl.tBodies[0].rows[v.row].cells[v.cell]);
                }
                return arr;
            },

            preBuildGridTable : function preBuildGridTable() {
                //do nothing.
            },

            /**
             * Sets the "tableNode" slot to the dynamically-generated data table HTML node.
             * For memory optimization, the "tableHtml" property is then deleted after the rendering is completed.
             */
            postBuildGridTable : function postBuildGridTable() {
                this.addSlots({tableNode: this.gridContainerNode && this.gridContainerNode.firstChild});
                //delete this.tableHtml;
            }
        }   // close - instance methods block.
    );

})();
(function () {

    mstrmojo.requiresCls(
        "mstrmojo.Widget"
    );
    
    var HOLD_INTERVAL = 50,
        HOLD_THRESHOLD = 500;
    
    /**
     * Widget to allow the user to step through various lists of items. Items can be either numeric or text. Each stepper needs a 
     * data provider. (See mstrmojo.StepperContentProvider).
     * 
     * @class
     * @extends mstrmojo.Widget
     */
    mstrmojo.Stepper = mstrmojo.declare(
        //superclass
        mstrmojo.Widget,
            
        //mixins
        null,
            
        {

            scriptClass: "mstrmojo.Stepper",
            
            /**
             * Denotes the orientation of the stepper.
             * Supported modes are 'horizontal' and 'vertical' 
             * 
             * @type String
             * @default 'vertical'
             */
            orientation: 'vertical',
            
            /**
             * Content provided which feeds the data to the stepper. The stepper will not function without one. 
             */
            provider: null,
            
            /**
             * Stepper title text
             */
            title: '',
            
            markupString:   '<div id="{@id}" class="mstrmojo-Stepper {@orientation} {@cssClass}" mstrAttach:click,mousedown,mouseup,selectstart>' +
                                '<div class="title">{@title}</div>' +
                                '<div class="next">+</div>' +
                                '<div class="text">{@itemHtml}</div>' +
                                '<div class="prev">-</div>' +
                            '</div>',
                            
            markupSlots: {
                titleNode: function() { return this.domNode.firstChild; },
                nextNode: function () { return this.domNode.children[1]; },
                textNode: function () { return this.domNode.children[2]; },
                prevNode: function () { return this.domNode.lastChild; }
            },
            
            /**
             * @see mstrmojo._HasMarkup
             */
            preBuildRendering: function preBuildRendering() {
                //Generate the item's HTML.
                this.itemHtml = this.provider.renderItemAt();
                
                //Call super
                this._super();
            },
            
            /**
             * Handles the click and tap events on the stepper to identify the user action.
             * 
             * @param {mstrmojo.Stepper} stepper The stepper widget
             * @param (HTMLElement} target The targeted dom element from the click or touch event handlers.
             */
            processEvent: function processEvent(target) {
                //Is the targetted node a text node?
                if (target === this.textNode || target === this.titleNode) {
                    //TODO: We need to make the stepper's text node an input node.
                    return;
                }
                
                var provider = this.provider,
                    mthd = ((target === this.nextNode) ? 'Next' : 'Prev');

                //Check if the stepper's data provider has a next or previous value for it ?
                if (provider['has' + mthd]()) {
                    //Ask the provider for the next or previous value.
                    provider[mthd.toLowerCase()]();
                    
                    //Update the text node to reflect the new value.
                    this.updateDisplayText();
                }
            },
            
            /**
             * Update the display text of the Stepper
             */
            updateDisplayText: function updateDisplayText(){
                this.textNode.innerHTML = this.provider.renderItemAt();
            },
            
            /**
             * Starts an interval so that the stepper can keep updating itself infinitely (until the timer is cancelled)
             * 
             * @param fn The function to call each time hte interval is fired.
             * @param evt The event handler's event object.
             */
            startStepperInterval: function startStepperInterval(evt, fn) {
                var me = this;
                //Start an interval to keep updating the stepper while holding
                this._holdTimer = setInterval(function () {
                    //Call the respective function on the stepper. 
                    me[fn](evt);
                }, HOLD_INTERVAL);
            },
            
            /**
             * Stops the interval so as to stop updating the stepper.
             */
            stopStepperInterval: function stopStepperInterval() {
                //Is the hold interval already firing? Then we need to clear the interval.
                if (this._holdTimer) {
                    clearInterval(this._holdTimer);
                    delete this._holdTimer;
                }
            },
            
            /**
             * Event listener for mouse onclick events.
             */
            onclick: function onclick(evt) {
                this.processEvent(evt.e.target);
            },
    
            /**
             * starts a timer to call onclick periodically until onmouseup
             */
            onmousedown: function onmousedown(evt) {
                //Are we already in hold status? (This should not happen - the user should not already be in hold status and click again)
                if (!this._holdTimer && !this._startHoldTimer) {
                    var me = this;
                    
                    this._startHoldTimer = setTimeout(function () {
                        //Delete any lingering timeout ids.
                        delete me._startHoldTimer; 
                        
                        //Start the stepper interval.
                        me.startStepperInterval(evt, 'onclick');
                        
                    }, HOLD_THRESHOLD);
                }
            },
            
            /**
             * On mouse up event listener.
             */
            onmouseup: function onmouseup() {
                //Have we created a hold calculation timer? Then we need to clear the timeout.
                if (this._startHoldTimer) {
                    clearTimeout(this._startHoldTimer);
                    delete this._startHoldTimer;
                }
                
                //Stop the stepper interval.
                this.stopStepperInterval(this);
            },
            
            /**
             * On select start event listener. We don't want the user to be able to select.
             */
            onselectstart: function onselectstart() {
                return false;
            }
        }
    );
}());
(function(){
    
    mstrmojo.requiresCls("mstrmojo.array", "mstrmojo.css", "mstrmojo.string", "mstrmojo.dom");
    
    var $A = mstrmojo.array,
        $C = mstrmojo.css,
        $S = mstrmojo.string,
        $D = mstrmojo.dom,
        _US = 'unselected',
        CSS_DISPLAY = 'inline-block';
    /**
     * @extends mstrmojo.Widget
     */
    mstrmojo.ImageToggle = mstrmojo.declare(
        mstrmojo.Widget,
        null,
        /**
         * @lends mstrmojo.ImageToggle.prototype
         */
        {
            scriptClass: 'mstrmojo.ImageToggle',
            
            /**
             * The url to the unset image 
             */
            unset: null,
            
            useAnimation: true,
            
            markupString: '<div class="mstrmojo-ImageToggle {@cssClass}" style="{@cssText}" tabindex="{@tabIndex}"  mstrAttach:click,blur,keydown ></div>',
            
            tabIndex: 0,
            
            markupMethods: {
                onimageListChange: function() {
                    var imgs = this.imageList && this.imageList.slice(), //duplicate the image list 
                        me = this,
                        ust = this.unset, i, div, img;
                    //if we have an unset image, add it into the image list
                    if(!$S.isEmpty(ust) && imgs) {
                        imgs.push({n: ust, v: ust, _ust: true});
                    }
                    if(this.domNode && imgs) {
                        me.domNode.innerHTML = '';
                        me.domNode.style.minHeight = Math.min(20, me.height) + 'px';
                        me.domNode.style.minWidth = Math.min(20, me.width) + 'px';
                        me._loadedImgs = imgs.length;
                        mstrmojo.array.forEach(imgs, function(imgObj, i) {
                            div = document.createElement('div');
                            div.style.cssText = 'display:none;font-size:0px !important;line-height:' + me.height + 'px !important;';
                            
                            img = document.createElement('img');
                            img.alt = img.title = imgObj.v;
                            img.style.verticalAlign = 'middle';
                            img.style.maxHeight = me.height + 'px';
                            //TQMS 553784: In IE7, we need to subtract 1 from the width so that the image won't be pushed down to another line
                            img.style.maxWidth = (me.width - 1) + 'px'; 
                            
                            if (!mstrmojo.dom.isIE) {
                                //TQMS#480117 set a image not found image if the src is not valid
                                img.onerror = function() {
                                    this.src = '../images/image_not_found.jpg';
                                };
                            }
                            div.appendChild(img);
                            me.domNode.appendChild(div);
                            img.src = imgObj.n || '../images/image_not_found.jpg';
                            
                            //save the unset image index
                            if(imgObj._ust) {
                                me.ustImgIdx = i;
                            }
                            me._imgs[i] = div;
                        });
                        
                        this._setSelectedValue();
                    } 
                },
                onvalueChange: function() {
                    this._setSelectedValue();
                }
            },
            
            imageList: null,
            
            value: null,
            
            selectedIndex: -1,
            
            preBuildRendering: function preBldRnd() {
                if(this._super) {
                    this._super();
                }
                
                this._imgs = [];
            },

            _setSelectedValue: function setSltV() {
                var me = this, 
                    s = this.selectedIndex, 
                    imgs = this.imageList;
                
                if(imgs) {
                    //unselect previous one
                    if(imgs[s]) {
                        me._imgs[s].style.display = 'none';
                    }
                    $A.forEach(this.imageList, function(img, i) {
                        if(img.v == me.value) {
                            $C.removeClass(me.domNode, _US);
                            me.selectedIndex = i;
                            me._imgs[i].style.display = CSS_DISPLAY;
                            return ;
                        }
                    });
                    
                    if(this.selectedIndex === -1) {
                        if(!this.unset) {
                            //unset status
                            $C.addClass(this.domNode, _US);
                        } else {
                            var div = this._imgs[this.ustImgIdx],
                                img = div.lastChild;
                            
                            img.alt = img.title = this.value;
                            div.style.display = CSS_DISPLAY; 
                        }
                    }
                }
            },
            
            onclick: function onclk() {
                var imgs = this.imageList,
                    len = imgs && imgs.length,
                    d = 300,
                    s = this.selectedIndex,
                    ls = s,
                    p = this.domNode,
                    e1, e2, c, t, me = this;
                
                c = (s === -1 && this.ustImgIdx !== null) ? this._imgs[this.ustImgIdx] : this._imgs[s];
                s = (s + 1) % len;
                t = this._imgs[s];
                $C.removeClass(p, _US);
                this.selectedIndex = s;
                
                if (this.useAnimation){
                    e2 = new mstrmojo.fx.FadeIn({
                        duration: d,
                        // TQMS 653524: Toggling between images is slow in IE8.
                        interval: ($D.isIE8 ? (d/3) : (d/10)),
                        target: t,
                        preStart: function(){
                            this.target.style.display = CSS_DISPLAY;
                        }
                    });
                    
                    e1 = new mstrmojo.fx.FadeOut({
                        duration: d,
                        // TQMS 653524: Toggling between images is slow in IE8.
                        interval: ($D.isIE8 ? (d/3) : (d/10)),
                        target: c,
                        onEnd: function() {
                            c.style.display = 'none';
                            //the source image is an unset image, re should remove it when the animation is done
                            if(ls === -1) {
                                me._imgs.splice(me.ustImgIdx, 1);
                                p.removeChild(c);
                                delete me.ustImgIdx;
                            }
                            e2.play();
                        }
                    });
    
                    //some time we will have unset status
                    if(c) {
                        e1.play();
                    }else {
                        e2.play();
                    }
                }else {
                    if (c){
                        c.style.display ='none';
                        if(ls === -1) {
                            me._imgs.splice(me.ustImgIdx, 1);
                            p.removeChild(c);
                            delete me.ustImgIdx;
                        }
                    }
                    t.style.display = CSS_DISPLAY;
                }
                
                this.value = this.imageList[s].v;
            },
            
            onkeydown: function(evt){
                var hWin = evt.hWin, 
                    e = evt.e || hWin.event;
                
                if (e.keyCode === mstrmojo.Enum_Keys.SPACE){ //Space key
                    mstrmojo.dom.preventDefault(hWin, e);
                    this.onclick();
                }
            }
        }
    );
}());
(function(){

	mstrmojo.requiresCls(
		"mstrmojo.Widget",
        "mstrmojo._Formattable");
	
	/**
	 * <p>An IFrame type of HTMLContainer.  HTML text HTMLContainer are handled by the {@link mstrmojo.DocTextfield}.</p>
	 *
	 * @class
	 * @extends mstrmojo.Widget
	 * 
     * @borrows mstrmojo._Formattable#formatHandlers as #formatHandlers
     * @borrows mstrmojo._Formattable#getFormats as #getFormats
	 */
	mstrmojo.DocHTMLContainer = mstrmojo.declare(
		// superclass
		mstrmojo.Widget,
		
		// mixins,
        [mstrmojo._Formattable],
		
        /** 
         * @lends mstrmojo.DocHTMLContainer.prototype
         */
		{
			scriptClass: "mstrmojo.DocHTMLContainer",
			
			scrolling: "auto",
			
	        markupString: '<iframe id="{@id}" class="mstrmojo-DocHTMLContainer" title="{@tooltip}" style="{@domNodeCssText}" src="{@v}" scrolling="{@scrolling}"></iframe>',

            formatHandlers: {
                domNode: [ 'RW', 'B', 'F', 'background-color', 'text-align', 'white-space', 'fx' ]
            },
			
			markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },
            
            /**
             * Updates the src of the IFrame that may change due to a selector action.
             * 
             * @param {Object} node The widget node.
             */
            update: function update(node) {
                this.v = node.data.v;
                
                //check if it is android or not, if yes set scrolling property to no
                if(mstrApp && mstrApp.isTouchApp()) {
                	this.scrolling = "no";
                }
                
                // if there is a threshold, kill the format
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }                
                
                this.thresholdId = node.data.tid;
                this.set('visible', !node.data.hidden);
            }
		}
	);
	
})();
(function(){

    mstrmojo.requiresCls("mstrmojo.Widget");
    
    mstrmojo.Label = mstrmojo.declare(
        // superclass
        mstrmojo.Widget,
        // mixins
        null,
        // instance members
        {
            scriptClass: "mstrmojo.Label",
            
            /**
             * The text (or HTML) to be displayed in the label.
             */
            text: null,

            markupString: '<div id="{@id}" class="mstrmojo-Label {@cssClass}" style="{@cssText}" mstrAttach:click>' + 
                          '</div>',
            
            /**
             * css display property value used when widget is visible
             * @type String
             */            
            cssDisplay: 'block',
                          
            markupMethods: {
                ontextChange: function(){ this.domNode.innerHTML = (this.text != null) ? this.text : ''; },
                oncssTextChange: function() { this.domNode.style.cssText = (this.cssText != null) ? this.cssText : ''; },
                onvisibleChange: function(){ this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; }
            },
            
            // There are no markupSlots, so we can omit that property.

            /**
             * If true, this widget will update its visible property when we set its "text" property:
             * false, if text is null or empty; true otherwise.
             */
            autoHide: false,            
            
            /**
             * Custom setter for text, implements the autoHide feature.
             */
            _set_text: function sttxt(n, v) {
                if (this.autoHide) {
                    this.set('visible', (v!=null) && (v!=="")); // must use !=="" because value 0 should not be hidden
                }
                var was = this.text;
                this.text = v;
                return was != v;
            }
        }
    );
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo.dom",
                         "mstrmojo._IsAnchorable");

    var POS_LEFT = 1,
        POS_RIGHT = 2,
        POS_TOP = 3,
        POS_BOTTOM = 4;
    var AREA_TYPE_TITLE = 'title',
        AREA_TYPE_CONTENT = 'content';

    /**
     * This widget is a text tooltip for those cells whose text content is not displayed completely
     *
     * @class
     * @public
     */
    mstrmojo.VisTextTooltip = mstrmojo.declare(
        mstrmojo.Widget,

        [mstrmojo._IsAnchorable],

        {
            scriptClass: 'mstrmojo.VisTextTooltip',

            left: 0,

            top: 0,

            zIndex: 10,

            boundaryNodeName : "boundary",

            popupNodeName : 'infoNode',

            baseTipClass: 'mstrmojo-vis-tip',

            anchorOffset : 1,

            anchorOrientation : 'h',

            anchor: null,

            boundary: null,

            tipNodeColor: '#ffffff',

            utils: mstrmojo.VisChartUtils,

            touchAreaType: AREA_TYPE_CONTENT,

            markupString: '<div id="{@id}" class="{@cssClass}" style="top:{@top}px;left:{@left}px;z-index:{@zIndex};position:absolute;{@cssText};">' +
                    '<div class="timeseries-slider-tooltip" style="display: block"></div>' +
                    '<div class="mstrmojo-vis-tip" style="display: block"></div>' +
                '</div>',

            markupSlots: {
                infoNode: function () { return this.domNode.firstChild; },
                tipNode: function () { return this.domNode.childNodes[1]; }
            },

            toggle: function toggle(show) {
                if (show) {
                    this.domNode.style.display = 'block';
                } else {
                    this.domNode.style.display = 'none';
                }
            },

            updateContent: function (anchor, touchAreaType, text) {
                this.fillContent(anchor, touchAreaType, text);
                this.positionDialog();
            },

            // fill content of this VisTextTooltip according to anchor
            fillContent: function fC(anchor, touchAreaType, text) {
                this.anchor = anchor;
                this.touchAreaType = touchAreaType;
                this.domNode.firstChild.innerHTML = text || this.anchor.innerText;
                this.toggle(true);
            }

            /*
            // calculate position of this VisTextTooltip
            calcPos: function cP() {
                var widget = this.boundary,
                    anchor = this.anchor,
                    tDom = this.domNode;
                if (widget && anchor && tDom) {
                    var pWidth = (widget.domNode) ? widget.domNode.offsetWidth : 0,
                        pHeight = (widget.domNode) ? widget.domNode.offsetHeight : 0,
                        aWidth = anchor.offsetWidth,
                        aHeight = anchor.offsetHeight,
                        tWidth = tDom.offsetWidth,
                        tHeight = tDom.offsetHeight,
                        scrLeft, scrTop;
                    //					if (this.touchAreaType === AREA_TYPE_CONTENT) {
                    //						// for IG, get scroller position in content
                    //						// as the scrollboxNode.scrollLeft and scrollboxNode.scrollTop are both 0 (not sure about the reason)
                    //						// so get scroll position through widget.scrollboxLeft and widget.scrollboxTop
                    //						scrLeft = (typeof(widget.scrollboxLeft) !== 'undefined') ? widget.scrollboxLeft : 0;
                    //						scrTop = (typeof(widget.scrollboxTop) !== 'undefined') ? widget.scrollboxTop : 0;
                    //					} else if (this.touchAreaType === AREA_TYPE_TITLE) {
                    //						// for IG, set scroller position as {left: 0, top: 0} for title
                    //						scrLeft = 0;
                    //						scrTop = 0;
                    //					} else {
                    //						// for widget using _HasTouchScroller, get scroller position
                    //						scrLeft = (typeof(widget._scroller) !== 'undefined') ? widget._scroller.origin.x : 0;
                    //						scrTop = (typeof(widget._scroller) !== 'undefined') ? widget._scroller.origin.y : 0;
                    //					}

                    // get offset of anchor relative to widget domNode
                    // as the scrollboxNode.scrollLeft and scrollboxNode.scrollTop are both 0 (not sure about the reason)
                    // we need to minus scrLeft and scrTop from offset
                    //					var offset = mstrmojo.boxmodel.offset(anchor, widget.domNode),
                    //						aLeft = offset.left - scrLeft,
                    //						aTop = offset.top - scrTop;

                    var targetPos = mstrmojo.dom.position(anchor),
                        parentPos = mstrmojo.dom.position(widget.domNode),
                        aLeft = (targetPos && parentPos) ? (targetPos.x - parentPos.x) : 0,
                        aTop = (targetPos && parentPos) ? (targetPos.y - parentPos.y) : 0;

                    // position the VisTextTooltip
                    var tDomStyle = tDom.style,
                        tempLeft, tempTop;
                    if (aLeft > tWidth) {
                        // if there is room on the left
                        tDomStyle.left = aLeft - tWidth + 'px';

                        tempTop = aTop + (aHeight - tHeight) / 2;
                        if (tHeight > pHeight) {
                            // tooltip is heighter than parent widget
                            tempTop = (tHeight - pHeight) / 2;
                        } else if (tempTop + tHeight > pHeight) {
                            // tooltip is out of the bottom border of parent widget
                            tempTop = pHeight - tHeight;
                        } else if (tempTop < 0) {
                            // tooltip is out of the top border of parent widget
                            tempTop = 0;
                        }
                        tDomStyle.top = tempTop + 'px';
                    } else if (pWidth - aLeft - aWidth > tWidth) {
                        // if there is room on the right
                        tDomStyle.left = aLeft + aWidth + 'px';

                        tempTop = aTop + (aHeight - tHeight) / 2;
                        if (tHeight > pHeight) {
                            // tooltip is heighter than parent widget
                            tempTop = (tHeight - pHeight) / 2;
                        } else if (tempTop + tHeight > pHeight) {
                            // tooltip is out of the bottom border of parent widget
                            tempTop = pHeight - tHeight;
                        } else if (tempTop < 0) {
                            // tooltip is out of the top border of parent widget
                            tempTop = 0;
                        }
                        tDomStyle.top = tempTop + 'px';
                    } else {
                        if (this.touchAreaType === AREA_TYPE_CONTENT) {
                            if (aTop > tHeight) {
                                // if there is room on the top
                                tempLeft = aLeft + (aWidth - tWidth) / 2;
                                if (tWidth > pWidth) {
                                    // tooltip is wider than parent widget
                                    tempLeft = (tWidth - pWidth) / 2;
                                } else if (tempLeft + tWidth > pWidth) {
                                    // tooltip is out of the right border of parent widget
                                    tempLeft = pWidth - tWidth;
                                } else if (tempLeft < 0) {
                                    // tooltip is out of the left border of parent widget
                                    tempLeft = 0;
                                }
                                tDomStyle.left = tempLeft + 'px';

                                tDomStyle.top = aTop - tHeight + 'px';
                            } else if (pHeight - aTop - aWidth > tHeight) {
                                // if there is room on the bottom
                                tempLeft = aLeft + (aWidth - tWidth) / 2;
                                if (tWidth > pWidth) {
                                    // tooltip is wider than parent widget
                                    tempLeft = (tWidth - pWidth) / 2;
                                } else if (tempLeft + tWidth > pWidth) {
                                    // tooltip is out of the right border of parent widget
                                    tempLeft = pWidth - tWidth;
                                } else if (tempLeft < 0) {
                                    // tooltip is out of the left border of parent widget
                                    tempLeft = 0;
                                }
                                tDomStyle.left = tempLeft + 'px';

                                tDomStyle.top = aTop + aHeight + 'px';
                            } else {
                                // if no room for VisTextTooltip
                                tDom.style.display = 'none';
                            }
                        } else if (this.touchAreaType === AREA_TYPE_TITLE) {
                            if (pHeight - aTop - aWidth > tHeight) {
                                // if there is room on the bottom
                                tempLeft = aLeft + (aWidth - tWidth) / 2;
                                if (tWidth > pWidth) {
                                    // tooltip is wider than parent widget
                                    tempLeft = (tWidth - pWidth) / 2;
                                } else if (tempLeft + tWidth > pWidth) {
                                    // tooltip is out of the right border of parent widget
                                    tempLeft = pWidth - tWidth;
                                } else if (tempLeft < 0) {
                                    // tooltip is out of the left border of parent widget
                                    tempLeft = 0;
                                }
                                tDomStyle.left = tempLeft + 'px';

                                tDomStyle.top = aTop + aHeight + 'px';
                            } else {
                                // if no room for VisTextTooltip
                                tDom.style.display = 'none';
                            }
                        }

                    }

                }

            }
            */

        }

    );

})();//@ sourceURL = VisTextTooltip.js
(function(){

    mstrmojo.requiresCls(
        "mstrmojo.Widget",
        "mstrmojo._Formattable");
    
    /**
     * <p>The widget for a single MicroStrategy Report Services rounded rectangle control.  NOTE: This is only 
     * for use in IE as all other browsers natively support round rectangles using {@link mstrmojo.DocRectangle}.</p>
     * 
     * @class
     * @extends mstrmojo.Widget
     * 
     * @borrows mstrmojo._Formattable#formatHandlers as #formatHandlers
     * @borrows mstrmojo._Formattable#getFormats as #getFormats
     * @borrows mstrmojo._Formattable#formatGradient as #formatGradient
     */
    mstrmojo.DocRoundRectangle = mstrmojo.declare(
        mstrmojo.Widget,
        
        [mstrmojo._Formattable],

        /**
         * @lends mstrmojo.DocRoundRectangle.prototype
         */
        {
            scriptClass: "mstrmojo.DocRoundRectangle",
            
            markupString: '<div id="{@id}" class="mstrmojo-DocRoundRectangle" title="{@tooltip}" style="{@domNodeCssText}">' +
                            '<div class="mstrmojo-DocRoundRectangle-l1" style="{@tCornersCssText}{@tCornersCssGradText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l2" style="{@tCornersCssText}{@tCornersCssGradText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l3" style="{@tCornersCssText}{@tCornersCssGradText}"></div>' +
                            '<div style="{@rectNodeCssText}{@rectNodeGradCssText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l3" style="{@bCornersCssText}{@bCornersCssGradText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l2" style="{@bCornersCssText}{@bCornersCssGradText}"></div>' +
                            '<div class="mstrmojo-DocRoundRectangle-l1" style="{@bCornersCssText}{@bCornersCssGradText}"></div>' +
                        '</div>', 
                        
            markupSlots: {
            	rectNode: function(){ return this.domNode.childNodes[3]; }
            },
            
            markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },	
            
            formatHandlers: {
                domNode: [ 'top', 'left', 'width', 'z-index', 'fx' ],
                rectNode: [ 'height', 'background-color' ],
                tCorners: [ 'background-color' ],
                bCorners: [ 'background-color' ]
            },
            
            update: function update(node) {
                // if there is a threshold, kill the format
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }
                
                this.thresholdId = node.data.tid;
                this.set('visible', !node.data.hidden);
            },
            
            /**
             * Adjusts the height of the rounded rectangle to account for the 8 extra pixels in the corners.
             * 
             * @ignore
             */
            preBuildRendering: function preBuildRendering() {
            	var rtn = this._super();

            	var f = this.getFormats(),
            		topOnly = !!this.defn.topc,							// Indicates only the top corners are rounded.
            		delta = (topOnly) ? 4 : 8,							// Delta is 8 if showing all four rounded corners, or 4 if only top two are rounded.
            		$2 = '(\\d*px)',									// Any numbers followed by 'px'
            		h = Math.max(parseInt(f.height, 10) - delta, 0);	// Reduce specified height by delta to account for corners.
            	
            	// Is the height of the rectangle 100%?
            	if (f.height === '100%') {
            		// Exactly '100%'.
            		$2 = '(100%)';
            		// Use the height of the parent, minus delta to account for corners.
            		h = this.parent.height() - delta;
            	}
            	
            	// Replace the current height with the new one.
            	this.rectNodeCssText = this.rectNodeCssText.replace(new RegExp('(.*height:)' + $2 + '(.*)'), '$1' + h + 'px$3');
            	
            	// Is it top corners only?
            	if (topOnly) {
            		// Then hide the bottom corners.
            		this.bCornersCssText = 'display:none;';
            	}
            	
            	return rtn;
            },
            
            /**
             * Builds the browser specific css for gradients for the corner elements.
             * 
             * @ignore
             */
            formatGradient: function formatGradient(gp, flt) {
            	// Get the browser specific gradient info.
            	var gd = mstrmojo.css.buildGradient(gp.t, gp.sc, gp.ec);
            	
            	// Does this browser support gradients?
            	if (!gd) {
            		// No, so return.
            		return;
            	}
            	
            	var gdt = gd.n + ':' + gd.v + ';',
            		bc = 'background-color:';
            	
            	// Add the gradient value to the rectNode css text.
            	this.rectNodeGradCssText = gdt;
            	
            	// Is it a vertical gradient?
            	if (gp.t === 0) {
            		// Set the background colors of the top and bottom corners to the start and end color.
            		this.tCornersCssGradText = bc + gp.sc + ';';
            		this.bCornersCssGradText = bc + gp.ec + ';';
            	} else {
            		// Apply the same horizontal gradient to both the top and bottom corners.
            		this.tCornersCssGradText = this.bCornersCssGradText = gdt;
            	}
            }
            
        }
    );
    
})();
(function () {    

    /* Required classes for TristateCheckBox */
    mstrmojo.requiresCls(
            "mstrmojo.Label",
            "mstrmojo.css",
            "mstrmojo.hash");
    
    /**
     * TristateCheckBox is a widget that works similarly to the CheckBox input element in html. Compared to the CheckBox input element though,
     * it is able to show a third state, when its grayed parameter is set to true. When the grayed is set to false, then it would work the same
     * as the CheckBox input element: when clicked, it would switch between checked and unchecked. To retrieve the value of a TristateCheckBox, 
     * you need to retrieve both grayed and checked parameters:
     * if grayed = true, checked = true, 3rd state;
     * if grayed = false, checked = false, unchecked;
     * if grayed = false, checked = true, checked;
     * grayed = false, checked = false is an invalid state and shall not be used. 
     */
    mstrmojo.TristateCheckBox = mstrmojo.declare(
            // superclass
            mstrmojo.Label,
            
            // mixins
            null,
            
            /**
             * @lends mstrmojo.TristateCheckBox.prototype
             */
            {
                scriptClass:'mstrmojo.TristateCheckBox', 
                grayed: true,
                checked: true,
                cssClass: 'tristate',                
                onclick: function() {
                    if (this.grayed) {
                        this.set('grayed', !this.grayed);
                    } else {
                        this.set('checked', !this.checked);
                    }
                },
                markupMethods: mstrmojo.hash.copy({
                    oncheckedChange: function() {
                        mstrmojo.css.toggleClass(this.domNode, 'checked', this.checked);
                    },
                    ongrayedChange: function() {
                        mstrmojo.css.toggleClass(this.domNode, 'grayed', this.grayed);
                    },
                    onenabledChange: function() {
                        mstrmojo.css.toggleClass(this.domNode, 'disabled', !this.enabled);
                    }
                }, mstrmojo.hash.copy(mstrmojo.Label.prototype.markupMethods))
            }
    ); 
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Label",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo._TouchGestures");

    mstrmojo.android.TextArea = mstrmojo.declare(
        mstrmojo.Label,

        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        {
            scriptClass: "mstrmojo.android.TextArea",

            markupString: '<div id="{@id}" class="mstrmojo-TextArea {@cssClass}" style="{@cssText}">' +
                              '<div>{@text}</div>' +
                          '</div>',

            markupMethods: {
                ontextChange: function () { this.domNode.firstChild.innerHTML = this.text || ''; },
                oncssTextChange: function () { this.domNode.style.cssText = this.cssText || ''; },
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? this.cssDisplay : 'none'; },
                onheightChange: function () { this.domNode.style.height = this.height || 'auto'; }
            },

            /**
             * Overridden to disable touch bubbling.
             *
             * @ignore
             */
            allowTouchBubble: false,

            updateScrollerConfig: function updateScrollerConfig() {

                var cfg = this._super(),
                    domNode = this.domNode,
                    scrollEl = domNode.firstChild,
                    h = parseInt(this.height, 10);

                // Is our height specified?
                if (isNaN(h)) {
                    // Height wasn't specified in the properties, so measure.
                    h = domNode.clientHeight;
                }

                // Disable bouncing.
                cfg.bounces = false;

                // Add the scrollEl to the scroll config.
                cfg.scrollEl = scrollEl;

                // Initialize origin to 0,0 (if not already there).
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                // Calculate offset end (items container node height minus widget height).
                var offsetEnd = Math.max(scrollEl.offsetHeight - h, 0);

                // Should we be able to vertically scroll?
                var enableScroll = cfg.vScroll = (offsetEnd !== 0);
                if (enableScroll) {
                    // Add the computed offset.
                    cfg.offset = {
                        y: {
                            start: 0,
                            end: offsetEnd
                        }
                    };
                }

                return cfg;
            }
        }
    );

}());
(function() {
    mstrmojo.requiresCls("mstrmojo.css", "mstrmojo.ImageToggle", "mstrmojo._IsInputControl");
    
    //inline only
    mstrmojo.ToggleDIC = mstrmojo.declare(
        mstrmojo.ImageToggle,
        
        [mstrmojo._IsInputControl],
        
        {                  
            scriptClass: 'mstrmojo.ToggleDIC',
            
            init: function(props){
                this._super(props);
                
                this.unset = this.dic.ust;
            },
            
            focus: function(){
                this.domNode.focus();
            },
            
            onvalueChange: function(){
                //override to do nothing so that changes will be applied when the toggle loses focus 
            },
            
            onblur: function(e){
                var evt = e.e || e,
                    dom = this.domNode,
                    ofst = mstrmojo.boxmodel.offset(dom, document.body);
                if(evt.clientX > ofst.left && evt.clientX < ofst.left + dom.offsetWidth && evt.clientY > ofst.top && evt.clientY < ofst.top + dom.offsetHeight) {
                    this.domNode.focus();    
                } else {
                    this.applyChanges();
                }
            },
            
            postBuildRendering: function(){
                if (this._super){
                    this._super();
                }
                
                if (this.showByDefault){
                    var ops = this.openerStyle;
                    
                    this.width = ops.iw;
                    this.height = ops.ih;
                    this.set('imageList', this.dic.vls);
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Stepper",
                         "mstrmojo._TouchGestures");
      
    /**
     * Touch enabled widget to allow the user to step through various lists of items. Items can be either numeric or text. Each stepper needs a 
     * data provider. (See mstrmojo.StepperContentProvider).
     * 
     * @class
     * @extends mstrmojo.Stepper
     */
    mstrmojo.ui.MobileStepper = mstrmojo.declare(
        //superclass
        mstrmojo.Stepper,
            
        //mixins
        [ mstrmojo._TouchGestures ],
            
        {

            scriptClass: "mstrmojo.ui.MobileStepper",
            
            /**
             * On click event listener.
             */
            onclick: function onclick(evt) {
                //Debugging code, we do not want it executing in the mobile app.
                if (!mstrApp.isTouchApp()) {
                    this._super(evt);
                }
                return false;
            },

            /**
             * onmousedown event listener.
             */
            onmousedown: function onmousedown(evt) {
                //Debugging code, we do not want it executing in the mobile app.
                if (!mstrApp.isTouchApp()) {
                    this._super(evt);
                }
                return false;
            },
            
            /**
             * onmouseup event listener.
             */
            onmouseup: function onmouseup(evt) {
                //Debugging code, we do not want it executing in the mobile app.
                if (!mstrApp.isTouchApp()) {
                    this._super(evt);
                }
                return false;
            },
            
            /**
             * @see mstrmojo._TouchGestures
             */
            touchSelectBegin: function touchSelectBegin(touch) {
                //Start an interval to update the stepper periodically.
                this.startStepperInterval(touch, 'touchTap');
            },
            
            /**
             * @see mstrmojo._TouchGestures
             */
            touchSelectEnd: function touchSelectEnd(touch) {
                //The user has lifted his/her finger - stop the interval.
                this.stopStepperInterval();
            },
            
            /**
             * @see mstrmojo._TouchGestures
             */
            touchTap: function touchTap(touch) {
                this.processEvent(touch.target);
            },
            
            /**
             * @see mstrmojo._TouchGestures
             */
            touchBegin: function touchBegin(touch){
                var dom = touch.target;
                if (dom == this.nextNode || dom == this.prevNode){
                    mstrmojo.css.addClass(dom, 'glow');
                }
            },
            
            /**
             * @see mstrmojo._TouchGestures
             */
            touchEnd: function touchEnd(touch){
                var dom = touch.target;
                if (dom == this.nextNode || dom == this.prevNode){
                    mstrmojo.css.removeClass(dom, 'glow');
                }
            }
        }
    );
    
    //The mobile device triggers a copy text and then in turn does not trigger onmouseup. Do in do not want to attach mousedown and mouseup events. 
    //(Is there a better way to do this?)
    mstrmojo.ui.MobileStepper.prototype.markupString = mstrmojo.ui.MobileStepper.prototype.markupString.replace(',mousedown,mouseup', '');
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
            "mstrmojo.color",
            "mstrmojo.css",
            "mstrmojo.GridBase");

    var $C = mstrmojo.css,
        $CLR = mstrmojo.color;
    
    /**
     * <p>The method goes thought the ancestors of the given widget to return first matched widget object that contains the given function name.</p>
     * 
     * <p>The search stops whenever the ancestor is a panel stack object.</p>
     * 
     * @param {Widget} w The starting widget object. 
     * @param {String} func The function name.
     * 
     * @returns A widget object if the method is found. Otherwise, returns null.
     */
    function findContainerByMethodName(w, func) {
        var anc = w && w.parent;
        while (anc && anc.scriptClass.indexOf('DocPanelStack') === -1) {
            if(func in anc) {
                return anc;
            }
            anc = anc.parent;
        }
        return null;
    };
    
    function repaint(node) {
        var img = document.createElement('img');
        node.appendChild(img);
        node.removeChild(img);
    };
    
    function getTableRowCells(ri, grid) {
        var page = Math.floor(ri/grid.rowsPerPage),
            row = ri % grid.rowsPerPage,
            tbl = grid.tableNode.tBodies[page];
            r = tbl.rows[row].cells;

        return r;
    }
    
    /**
     * Cleans up after page rendering.
     * 
     * @private
     */
    function renderingCleanUp() {
        // Do we have a rendering interval?
        var timer = this._renderTimer;
        if (timer) {
            // Cancel interval.
            self.clearInterval(timer);
            
            // Delete interval handle.
            delete this._renderTimer;
            
            // Clear rendering rows flag.
            this.renderingRows = false;
        }
    }
    
    mstrmojo.Grid = mstrmojo.declare(
        // superclass
        mstrmojo.GridBase,
        
        // mixins.
        null,
        //[mstrmojo.FillViewport],
        //[mstrmojo.FillScrolled],
        
        // instance methods
        {
            scriptClass: "mstrmojo.Grid",

            /**
             * On Demand Grid rendering happens through pages. Each page is approximately the size of our viewport (scrollbox). RowsPerPage represents the (computed) rows of table
             * that each page would hold  
             */
            rowsPerPage: 0,
            
            /**
             * This represents the actual height that a cell occupies - including padding and border. Used for precise calculations towards rendering grid pages.   
             */
            effectiveRh: 0,

            /**
             * Count of pages which have been rendered (either filled with cells or not; both are counted).
             */
            numPagesRendered: 0,
            
            /**
             * Count of total pages of rows, rendered or not.
             */
            totalPages: 0,
            
            /**
             * Array (0-based) of objects with rendering info for each rendered page: {filled: true|false, height: ### (pixels)}.
             */
            pageStatus: null,
            
            /**
             * Effective row height times number of rows per page. This is the height of the place holder pages (tbodies) in pixels.
             */
            _defaultPageHeight: 0,
            
            /**
             * Render Pause between rendering pages. This can be overriden by strategies. Note - value of 0 breaks IE8. 
             */
            renderPause: 10,

            /**
             * Minimum Row Height (used to calculation when row height is not fixed). 
             */
            rhMin: 15,
            
            /** 
             * default rows per page to use, when there's no scrollbox height.
             */
            defaultRowsPerPage: 100,
            
            /**
             * Minimum rows per page to use. This configuration is important to avoid frequent innerHTML replacements as we are scrolling. Rendering too small pages while scrolling  may increase number of innerHTML replacements
             * and slow down the rendering. 
             */
            minRowsPerPage: 50,
                        
            /**
             * Called from constructor.
             */
            init: function init_Grid(/*Object?*/ props) {
                // Apply the superclass constructor first.
                this._super(props);
                
                // we don't want to force fixed sizes in this rendering mode. 
                this.forceFixedSizes = true;

            },

            /*
            preBuildRendering: function preBuildRendering(res) {
                // we want to make sure that scrollbox is connected to the new DOM. That will happen only after all its current listeners are removed. SCrollbox itself attaches to the DOM only the first time.
                if(this.connectedScrollbox) {
                    this.parent.disconnectScrollbox(this);
                    this.connectedScrollbox = false;
                }                
                this._super();
            },
            */
            
            /**
             * Before rendering a (OnDemand) Grid we need to compute how many pages will represent the Grid and what will be the rows per page. This helper does that.
             * It also initializes the numPagesRendered list to indicate that none of the pages have been rendered.   
             */
            initPageSettings: function intiPageSettings() {
                
                var p = this.parent,
                        rpp = this.defaultRowsPerPage;

                // do we have a fixed row height ? If not, we need to base our row height calculations using an approximate row height (rhMin). 
                this.effectiveRh = this.rh || this.rhMin || 1;

                if(p && p.numRowFixed) {
                    // When numRowFixed flag is true, that means we need to render all the available rows in the first page, and let the 
                    // remaining data to be fetched when user scrolls the scrollbar.
                    // In this case, rpp is the number of the available rows. 
                    rpp = this.cp.getAvailableRowsCount();
                } else if (p && p.scrollboxHeightFixed) {
                    // does the does our container (xtab scrollbox) have a fixed height ?  
                
                    // Nice, we have a fixed scrollbox. We now think of our viewPort (scrollbox height) as 1 page. So, essentially, number of rows rpp page (rpp) is equal to the number of rows that would fit in the viewPort/.
                    rpp = Math.ceil(p.scrollboxHeight/this.effectiveRh);
                    
                    // Enforce the min rows per page setting, 
                    rpp = Math.max(rpp, this.minRowsPerPage);
                }

                this.pageStatus = [];
                
                // update the final rowsPerPage we have derived. 
                this.rowsPerPage = rpp;

                this.initPageStatus(this.pageStatus);
                
                this._defaultPageHeight = this.rowsPerPage * this.effectiveRh;
            },            
            
            // initialize the size of the array of pages filled (the size is important, because we need
            // to walk the entire array length to determine if all pages are filled)
            initPageStatus: function initPageStatus(/* Array */ pageStatus) {
                var rpp = this.rowsPerPage;
                
                this.totalPages = rpp && Math.ceil(this.cp.rc/rpp) || 0;
                pageStatus = pageStatus || this.pageStatus;

                // we may not have all pages ready (incremental fetch). 
                for(var i=0;i< this.totalPages ;++i) {
                    // Mark the page status to convey that data needs to be loaded on demand.
                    var startIndex = i*rpp,
                    endIndex = startIndex + rpp - 1,
                    dataAvailable = this.cp.isDataAvailable(startIndex, endIndex);

                    // create the page status object, if not there. 
                    if(!pageStatus[i]) {
                        pageStatus[i] = {};
                    }
                    
                    // update the OnDemand property on the page Status. 
                    pageStatus[i].onDemand = !dataAvailable;
                }
            },

            /**
             * Overwrites  buildRendering so that before delegating the actual grid rendering to its parent, 
             * we compute the page sizes and ensure that the rows are stitched before rendering the first page.  
             */
            buildRendering: function buildRendering(/* DomNode */ tcn) {
                if (this.renderMode == "vscroll") {
                    // calculate the page sizes. 
                    this.initPageSettings();

                    // is our very first page on demand ? Ifyes, we need to trigger onscroll to download the page.
                    var ps0 = this.pageStatus[0],
                            isOnDemand = ps0 && ps0.onDemand;
                    
                    this.start = 0;
                    this.end = -1;
                    
                    if(!isOnDemand) {
                        // now that we know the rows per page, we can go to the Content provider and ask it to stitch its rows using our rows per page. 
    
                        // Determine how many rows to build in the first block.
                        // update the start, end row index.
                        this.end = Math.min(this.cp.rc, this.rowsPerPage) - 1;
                    }
                        
                    // extension points. Before calling the parent's build rendering that will trigger the rendering of the first page, we fire events for pre processing (e.g. container style - top setting in case of fixed size on demand rendering).
                    // Note, we typically render more than one pages at a time. That way we can keep the frequency of some DOM operations under control. So, we expose extension points for both renderPages and renderPage.
                    this.preRenderPages();
                    // super::buildRendering has rendered the first tbody. We didn't end up rendering any rows if it is the OnDemand case. That is quite equivalent to rendering a page with filled=false. Hence trigger pre and post with <filled> flag
                    // based on <onDemand>. 
                    this.preRenderPage(0, !isOnDemand);
                }

                // this will build the first page. 
                this._super();
                
                if (this.renderMode == "vscroll") {
                	var p = this.parent,
                	    me = this,
                    	setMinHeight = function() {
                            me.gridContainerNode.style[mstrmojo.css.MINHEIGHT] = (me.cp.rc * me.effectiveRh) + 'px';
                	    };
                    // One-time setup operations:
                    // Set the estimate table height once, then remove the guess when rendering is complete.
                	if (mstrmojo.dom.isIE7) {
                	    //TQMS 544894: set "height" to '1px' to force the "hasLayout" property set to true.
                        this.gridContainerNode.style.zoom = '1';
                        window.setTimeout(setMinHeight,10);
                	} else {
                	    setMinHeight();
                	}
                	
                    // Set up the scrollbox connection once, then disconnect when rendering is complete.
                    if (!this.connectedScrollbox) {
                        if (p && p.connectScrollbox) {
                            p.connectScrollbox(this);
                            this.connectedScrollbox = true;
                        }
                    }
                    
                    // since we have rendered the first page, we just continue with corresponding post operations.
                    this.postRenderPage(0, !isOnDemand);
                    this.postRenderPages();                    

                    // check whether the table is fit to content. If it is fit to content (scrollbox height is not fixed), and we have 
                    // more pages needs to be rendered, call onscroll to render the remaining data
                    var afc = p && !p.scrollboxHeightFixed && !p.numRowFixed;
                    if(afc && this.numPagesRendered >= this.totalPages && !isOnDemand) {
                        // fit to content, and we have finish rendering all the pages, call postRenderingCleanup.
                        this.postRenderingCleanup();
                    } else if(isOnDemand || afc) {
                        this.onscroll();
                    }
                } else {
                    this.configureActions();
                }
                
            },

            /**
             * Joinpoint for preprocessing before rendering the current block of pages (typically as part of scrolling). 
             */
            preRenderPages: function prePages() {
                // do nothing. 
            },

            /**
             * Joinpoint for postprocessing after rendering the current block of pages. We use these joinpoints to update our DOM dimensions and perform height calculations - for scrollbar synchup.  
             */
            postRenderPages: function postPages() {
                this.configureActions();
            },
            
            configureActions: function configureActions() {
                // check for interactivity ? Maybe, we rendered cells that need interactivity now. 
                var p = this.parent;
                if(p && p.configureActions) {
                    p.configureActions();
                }
            },
                        
            /**
             * Joinpoint for preprocessing before rendering a page. 
             */
            preRenderPage: function prePage(/* int */ idx, /*Boolean*/ bFillCells) {
                // debuggin
                this.pageNum = idx;
            },

            /**
             * Joinpoint for postprocessing after rendering a page. 
             */
            postRenderPage: function postPage(/* int */ idx, /*Boolean*/ bFillCells, /*DomNode?*/ el) {
                // mark the current page as rendered. 
                if (idx+1 > this.numPagesRendered) {
                	this.numPagesRendered = idx+1;
                }
                // update the page's status: did we fill the cells? if so, what is the actual height of the page?
                var arr = this.pageStatus,
                    status = arr[idx];
                if (!status) {
                    // the page has rendered (but possibly not filled), so add a record for it
                    status = arr[idx] = {};
                }
                if (bFillCells) {
                    // update the filled record for the page; if it was previously filled, dont ever reset back to un-filled.
                    status.filled = true;
                    status.dirty = false;
                }
                
                // In some case when the estimated row height is bigger than the real row height, the min-height of the container
                // will be larger than it should be. So when scrolling to the last page, there will be a blank space under the grid.
                // So we unset the min-height if the last page is rendered.
                var cnStyle = this.gridContainerNode.style;
                if(idx == this.totalPages - 1 && cnStyle) {
                    cnStyle[mstrmojo.css.MINHEIGHT]= '';    
                }
                
            },            
            
            /**
             * Set all the pages to be invalid status.
             */
            invalidAllPages: function() {
                for(var i=0;i< this.totalPages ;++i) {
                    var ps = this.pageStatus[i];
                    if(ps.filled) {
                        ps.dirty = true;
                    }
                    ps.onDemand = true;
                    ps.filled = false;
                    ps.isDownloading = false;
                }
                this.thPosMap = [];
                this.posMap = [];
            },
            
            /**
             * Routine to render a block of pages requested through scrolling (or filling up viewport empty space after rendering the first page).   
             */
            _startPageRenderThread: function startRndrThd() {
                var id = this.id;
                
                // Set rendering flag.
                this.renderingRows = true;
                
                // Set render interval.
                this._renderTimer = self.setInterval(function() {
                    try {
                        // We render a block of pages during a given iteration. Implementations can easily implement the API to render one page at a time instead.  
                        var grid = mstrmojo.all[id];
                        
                        if (!grid) return;
                        
                        var pages = grid.getPagesToRender();
                        
                        // if there are pages to render, trigger preProcessing followed by their rendering and post processing extension. 
                        if (pages.length > 0) {
                            grid.preRenderPages();
                            grid.renderPages(pages);
                            grid.postRenderPages();
                            grid._postPagesClearup = true;  
                            
                        } else {
                            if (grid._postPagesClearup) {
                                grid.postRenderPagesCleanup();
                                grid._postPagesClearup = false;                                                    
                            }
                            
                            // No more pages to render so clean up.
                            renderingCleanUp.call(grid);
                            
                            if (grid.isRenderingComplete()) {
                                grid.postRenderingCleanup();
                            }
                        }
                        
                    } catch (ex) {
                        // Clean up after rendering.
                        renderingCleanUp.call(mstrmojo.all[id]);
                        
                        // Throw exception so it will be handled further up the chain.
                        throw ex;
                    }
                        
                }, this.renderPause);
            },
            
            /**
             * Scrollbox Listener. Triggers the rendering routine if its not active already.
             * @param {Boolean} setMask Boolean value decide whether we should set a mask on parent maskNode 
             */
            onscroll: function onscroll(setMask) {
                // if we are rendering currently, don't do anything. The page rendering thread will take care of ensuring that the most recent viewport (scrollbox) is filled up. 
                if (!this.renderingRows) {
                    //sometimes the first parameter is passed as an object, we need to only consider the case when passed in a boolean value
                    if(setMask === true) {
                        var p = this.parent;
                        if(p && p.maskNode) {
                            $C.addClass(p.maskNode, 'wait');
                        }
                    }
                    this._startPageRenderThread();
                }
            },

            /**
             * Checks whether all pages have been rendered. 
             */
            isRenderingComplete: function isRdrComplete() {
                // first make sure we've rendered all pages
                if (this.end >= this.cp.rc - 1) {
                    // all pages are rendered, now make sure all pages have their cells filled in.
                    // this assumes that the length of the array _pagesFilled was initialized to the # of pages.
                    for (var arr=this.pageStatus, i = this.totalPages-1; i >-1; i--) {
                        if (!arr[i] || !arr[i].filled) {
                        	return false;
                        }
                    }
                    return true;
                }
                return false;
            }, 
            
            /**
             * Renders the pages with index passed (as an array)
             */
            renderPages: function renderPages(/* Array[Object] */ pages) {
                for(var i=0,len=pages.length;i<len;++i) {
                    this.renderPage(pages[i].idx, pages[i].fill);
                }
            },
            
            /**
             * Renders a page at the given index. 
             */
            renderPage: function renderPage(/* int */ idx, /*Boolean*/ bFillCells) {
                // Has the requested page already been rendered?
                var arrStatus = this.pageStatus,
                    alreadyRendered = (this.numPagesRendered >= idx+1);
                if (alreadyRendered) {
                    // Yes it has been rendered. If we're not asked to fill its cells, or if it's cells are already filled,
                    // then we don't need to do anything, so exit.
                    if (!bFillCells || (arrStatus[idx] && arrStatus[idx].filled)) {
                    	return;
                    }
                }

                var rpp = this.rowsPerPage,
                    dn = this.domNode;
                
                // update the start, end indexes. 
                this.start = idx * rpp;
                this.end = Math.min(this.start + rpp, this.cp.rc) - 1; 

                // pre processing extension. 
                this.preRenderPage(idx, bFillCells);
                
                // in this mode, we will render each page as a tbody and after rendering, we will move the tbody to the actual Grid table. 
                // create the tbody inside a temp div, which is cached for re-use with subsequent pages.
                var tempTable = this.tempTable;
                if (!tempTable) {
                    tempTable = this.tempTable = dn.ownerDocument.createElement('div');
                }
                
                /*
                var tempTD = '<td style="height:' + (this.effectiveRh * (this.end-this.start+1))+ 'px">&nbsp;</td>';
                
                var tdStr = "";
                
                for(var i=0;i<this.cws.length;++i) {
                    tdStr += tempTD;
                }
                
                var tInnerHTML = bFillCells ?
                                    this.buildTableRowsMarkup(this.start, this.end, '<table><tbody n="' + this.pageNum + '">', '</tbody></table>').join('') :
                                    '<table><tbody class="xtab-empty-page" n="' + this.pageNum + '"><tr>' + tdStr + '</tr></tbody></table>';
                tempTable.innerHTML = tInnerHTML; 
                */
                
                var tInnerHTML = bFillCells ?
                        this.buildTableRowsMarkup(this.start, this.end, '<table><tbody n="' + this.pageNum + '">', '</tbody></table>').join('') :
                            '<table><tbody n="' + this.pageNum + '"><tr><td style="height:' + (this.effectiveRh * (this.end-this.start+1))+ 'px">&nbsp;</td></tr></tbody></table>';
                        tempTable.innerHTML = tInnerHTML; 

                // get the first tbody from our temp table. 
                var tbody = tempTable.firstChild.tBodies[0],
                    tn = this.tableNode;
                
                // move the tbody we just built to the actualy Grid Table. 
                // if the page has not been rendered yet, simply append.
                if (!alreadyRendered) {
                    tn.appendChild(tbody);
                } else {
                    // otherwise, it has been rendered, so we need to swap the old tbody for the new tbody
                    tn.replaceChild(tbody, tn.tBodies[idx]);
                }
                                
                // post processing extension. 
                this.postRenderPage(idx, bFillCells, tbody);
            },
            
            /**
             * Returns the indices of the pages to be rendered. We compute the pages corresponding to the top and bottom of the scrollbox and return them alongwith (index of) pages in between, if any. 
             */
            getPagesToRender: function getPagesToRender() {
                var pages = [],
                    p = this.parent,
                    // what is our page size ? 
                    pageSize  = this._defaultPageHeight,
                    tBodies = null,
                    stats = this.pageStatus,
                    me = this;
                    
                // util function for obtaining the height of a page.
                function pageHeight(idx) {
                    // is the page filled?
                    var stat = stats[idx];
                    if (stat && (stat.filled || stat.dirty)) {
                        // page is filled: use cached page measurement (if cache missing, measure now & cache)
                        if (!stat.height) {
                            if (!tBodies) {
                            	tBodies = me.tableNode.tBodies;
                            }
                            stat.height = tBodies[idx].offsetHeight;
                        }
                        return stat.height;
                    } else {
                        // page is not filled: use the default page height
                        return pageSize;
                    }
                }

                // get indices of the top and bottom page adjacent to the scrolled region.
                // first, for the top, walk the page heights until you reach the scrollboxTop.
                var y = 0,
                    topPageIdx = null,
                    bottomPageIdx = null,
                    scrollTop = p.scrollboxTop;
                for (var i=0, len=this.totalPages, arr = this.pageStatus; i<len; i++) {
                    y += pageHeight(i);
                    if (y >= scrollTop) {
                        topPageIdx = i;
                        break;
                    }
                }
                // did we find a top page? 
                if (topPageIdx === null) {
                    // no, assume its the last page
                    topPageIdx = bottomPageIdx = len-1;
                } else {
                    // yes, so now find the bottom page index by continuing walk of page heights
                    var scrollBottom = p.scrollboxBottom;
                    
                    //TODO: scrollboxBottom can be NaN if grid height is fit to content, 
                    //For transaction, we will render all the pages if one page data is changed.
                    //The better way to fix it is go to _HasScrollBox to set the proper scrollboxBottom value
                    if(isNaN(scrollBottom) && p.numRowFixed) {
                        scrollBottom = scrollTop;
                    }
                    
                    for (var j=topPageIdx+1; j<len; j++) {
                        // Important - make sure our check for bottom ensures that the rendered page overflows the scrollbottom (> check instead of >=). Consider the case where someone jumps to the bottom after opening the grid. That would mean that based
                        // on the original approximation we would likely render some of the last few pages as against the actual last page (since our initial min-height was an approximation). So, now the scroller would jump a little and show
                        // more available rows. If the user tries to scroll to the end again, the problem is that the current rendered page heights would total the scrollBottom so the last set of pages would not render. 
                        if (y > scrollBottom) {
                            bottomPageIdx = j-1;
                            break;
                        }
                        y += pageHeight(j);
                    }
                }
                // if we didn't find a bottom page, assume it was the last page
                if (bottomPageIdx === null) {
                    bottomPageIdx = len-1;
                }
                // add to our list any pages which are above the viewport and have not been rendered at all;
                // these do not need to have their cells filled.
                for(var n=this.numPagesRendered;n<topPageIdx;++n) {
                    pages.push({idx: n, fill: false});
                }                   
                
                // add to our list any pages which are WITHIN the viewport and have not had their cells filled.
                // these need to have their cells filled.
                var arrStats = this.pageStatus,
                        numRowsToDownload = 0,
                        rpp = this.rowsPerPage,
                        showStatus = false;
                
                for (var m=topPageIdx;m<=bottomPageIdx;++m) {
                    var stat = stats[m];
                    if (!stat || !stat.filled) {
                        // is the data available ? If not, instead of rendering we need to trigger the download of these pages. 
                        if(stat && stat.onDemand) {
                            showStatus = true;
                            // if we're not already downloading this page, trigger its download, but ONLY if we're not already
                            // downloading some other page.  if we ARE downloading something, don't pile on any more downloads.
                            // wait for the current download to finish; its callback will eventually cause us to return here.
                            if(!stat.isDownloading && !this.isDownloading){ // was: !this.cp.isDownloading
                                numRowsToDownload += rpp; 
                                stat.isDownloading = true;
                                this.isDownloading = true;
                                var startIndex = m*rpp,
                                        endIndex = startIndex + rpp - 1;
                                
                                // trigger the download. 
                                this.cp.download(startIndex, endIndex);
                                //console.log("page " + m + " needs to be downloaded !!!!");
                            }
                            // While awaiting data download, render a placeholder. This fixes the issue that occurs when later pages
                            // download first, and so we render them first, and the order of our page tBodies gets messed up.
                            pages.push({idx: m, fill: false});
                        } else {
                            pages.push({idx: m, fill: true});
                        }
                    }
                }

                // todo1 - status bar code needs to be cleaned !!!! 
                if(showStatus) {
                	this.parent.showDownloadStatus(numRowsToDownload);
                } else {
                    if (this.parent.closeDownloadStatus) this.parent.closeDownloadStatus();
                }
                
                return pages;
            },            

            /**
             * Add the highlight position to the cell
             */
            addHilitePosition: function(key, row, cell) {
                var hm = this.hiliteCellsMap[key];
                if(!hm) {
                    this.hiliteCellsMap[key] = {pos: [], nodes: []};
                }
                var r = row - (this.pageNum || 0) * this.rowsPerPage;
                this.hiliteCellsMap[key].pos.push({row: r, cell: cell, page: this.pageNum});                
            },
            
            /**
             * Go through the position to highlights cells
             */
            setHilites: function(key, node) {
                var ei = node.getAttribute('ei'),
                    pos = this.eiMap[ei],
                    arr = this.getNodesByPositions(pos);
                
                if(!arr.length) {
                    this._super(key, node);
                    return ;
                }
                
                for(var i = 0, iLens = arr.length; i < iLens; i++) {
                    this._super(key, arr[i]);
                }
            },
            
            addExtraInfoMap: function(ei, row, cell) {
                if(!this.eiMap[ei]) {
                    this.eiMap[ei] = [];
                }
                
                this.eiMap[ei].push(this.getPosObj(row, cell));
            },            
            
            addPositionMap: function(ei, row, cell){
                //only remember the first cell that has the same _ei
                if(!this.posMap[ei]) {
                    this.posMap[ei] = this.getPosObj(row, cell);
                }
            },
            
            addTitleHeaderPositionMap: function(row, cell, o){
                var pos = this.getPosObj(row, cell);
                pos.obj = o;
                this.thPosMap.push(pos);
            },

            getPosObj: function(r, c){
                return {row: r - this.pageNum * this.rowsPerPage, cell: c, page: this.pageNum};
            },
            
            getNodeByPosition: function(pos) {
                return this.tableNode.tBodies[pos.page].rows[pos.row].cells[pos.cell];
            },            
            
            getRowIdxByCell: function(cell) {
                var pos = this.posMap[cell._ei];
                return pos.page * this.rowsPerPage + pos.row;
            },
            
            /**
             * Get the cell dom node by using the row, column, and page
             * @param {Object} pos A json object contains the row, column, and page information about the cell location.  
             */            
            getNodesByPositions: function(/*JSON*/pos) {
                var arr = [];
                
                for(var i in pos) {
                    var v = pos[i],
                        p = (v && v.page) || 0,
                        r = v && v.row,
                        c = v && v.cell;
                    
                    arr.push(this.tableNode.tBodies[p].rows[r].cells[c]);
                }
                
                return arr;
            },
            
            /**
             * Gets the height of the given page. If the page is not rendered or not exist, returns 0.
             * @param {Integer} idx The index number of the page
             * @return the height of the given page
             */
            getPageHeight: function getPageHeight(idx) {
                var tbd = this.tableNode.tBodies;
                return (tbd && tbd[idx] && tbd[idx].offsetHeight) || 0;
            },
            
            /**
             * Gets the target cell that contains the given coordinate. The function will go through rows from the beginning of the table 
             * to find the cell that is located at the coordinate.
             * @param {Integer} x X axis value
             * @param {Integer} y Y axis value
             */
            getTargetCell: function(x, y) {
                var h = 0, 
                    i = 0;
                
                // find the right tbody
                for(var len = this.totalPages; i < len; i++) {
                    h += this.getPageHeight(i);
                    if(y <= h) {
                        break;
                    }
                }
                var tbody = this.tableNode.tBodies[i];

                if (tbody){
                    // for each row
                    for(var i = 0, len = tbody.rows.length; i < len; i++) {
                        var row = tbody.rows[i];
                        // for each cell in the row
                        for(var j = 0, jLen = row.cells.length; j < jLen; j++) {
                            var cell = row.cells[j];
                            // if y <= the cell bottom
                            if(cell.offsetTop + cell.offsetHeight >= y) {
                                // if x is inside the cell, then we find the cell
                                if(x >= cell.offsetLeft && x <= cell.offsetLeft + cell.offsetWidth) {
                                    return cell;
                                }
                            } else {
                                break;
                            }
                        }
                    }
                }
            },
            
            postRenderPagesCleanup: function _postRenderPagesCleanup() {
                var p = this.parent;
                
                if(p && p.gridData && p.gridData.afc) {
                    var tb = this.tableNode;
                    //TQMS 434357 when grid width changed, need to call xtab's onGridWidthChanged function 
                    if(tb && (this.lastWidth != tb.offsetWidth)) {
                        if(p.onGridWidthChanged) {
                            p.onGridWidthChanged();
                        }
                        mstrmojo.array.forEach(this.pageStatus, function(s) {
                            delete s.height;
                        });
                        this.lastWidth = tb.offsetWidth;
                    }
                    var w = findContainerByMethodName(p, 'adjustAutoWidth');
                    if(w) {
                        w.adjustAutoWidth(p);
                    }
                }
                
                if(p.gridPagesRendered) {
                    p.gridPagesRendered();
                }                
                
                //TQMS 433545, IE7 sometimes cannot render newly appended tbody
                if(mstrmojo.dom.isIE && !mstrmojo.dom.isIE8) {
                    repaint(this.domNode);
                }
                
                //finish downloading and rendering, clear the mask if any
                if(p && p.maskNode) {
                    $C.removeClass(p.maskNode, 'wait');
                }
                //high light goes here
                this.hightLightChangedCells();
            },
            
            hightLightChangedCells: function hightLightChangedCells() {
                var ucs = this.cp.getUpdatedRows(),
                    me = this, cells,
                    r, rcells, ci, i, c, ri, doms = [];
                if(ucs) {
                    //get rows, get table, hightlight
                    mstrmojo.hash.forEach(ucs, function(v, k) {
                        ri = parseInt(k, 10);
                        cells = me.cp.getRowCells(ri);
                        r = getTableRowCells(ri, me);
                        rcells = r.length;
                        ci = cells.length - 1;
                        
                        if(ci >= 0) {
                            for(i = rcells - 1; i >= 0; i--) {
                                c = r[i];
                                if(ci<0) {
                                    break;
                                }
                                if(cells[i]._d) {
                                    var bgColor = c.style.backgroundColor,
                                        ftColor = c.style.color;
                                    doms.push({dom: c, bgcolor: bgColor, ftcolor: ftColor});
                                    c.style.backgroundColor = $CLR.getHighlightColor($CLR.rgbStr2rgb(mstrmojo.css.getStyleValue(c, 'backgroundColor'), true));
                                    c.style.color = $CLR.getContrastingColor($CLR.rgbStr2hex(mstrmojo.css.getStyleValue(c, 'backgroundColor')), ['#ffffff', '#000000']);
                                    delete cells[i]._d;
                                }
                                ci--;
                            }
                        }
                    });
                    
                    if(doms.length > 0) {
                        window.setTimeout(function() {
                            mstrmojo.array.forEach(doms, function(domCell) {
                                //mstrmojo.css.removeClass(dom, 'mstrmojo-data-modified');
                                domCell.dom.style.backgroundColor = domCell.bgcolor;
                                domCell.dom.style.color = domCell.ftcolor;
                            });
                        }, 300);
                    }
                }
            },
            
            /**
             * The following method is provides information specific to the row at a given position. 
             * 
             * @param {Integer} y The location at which the caller wants the grid information
             */
            getRowInfoByPosition: function (y) {
                return this.cp.getRowCellInfo(y);
            },
            
            /**
             * Post Rendering Cleanup after all pages have been rendered, 
             */
            postRenderingCleanup: function _postRenderingCleanup() {
                var p = this.parent;
                // detach scroll event listener
                if (p && this.connectedScrollbox) {
                	p.disconnectScrollbox(this);
                }
                this.connectedScrollbox = false;  
                
                // ask the subsection object to resize
                if (p && !p.scrollboxHeightFixed) {
                   var c = findContainerByMethodName(p, 'performCanGrowCanShrink');
                   if (c) {
                	   c.performCanGrowCanShrink([p], true);
                   }
                }             
            },
            
            unrender: function unrender(ignoreDom) {
                // Clean up rendering (just in case).
                renderingCleanUp.call(this);
                
                // Detach scroll event listener.
                if (this.connectedScrollbox) {
                    this.parent.disconnectScrollbox(this);
                    this.connectedScrollbox = false;
                }
                
                this.numPagesRendered = 0;
                this.lastWidth = 0;
                this.isDownloading = false;
                
                this._super(ignoreDom);
            },
            
            dataDownloaded: function dataDownloaded() {
                this.isDownloading = false;
                this.initPageStatus();
                this.onscroll();
            }
        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo.EnumRWUnitType");

    var HTML_CONTAINER = mstrmojo.EnumRWUnitType.HTMLCONTAINER;

    /**
     * <p>The widget for a single MicroStrategy Report Services text control or HTMLContainer (HTMLText type only, not IFrame {@see mstrmojo.DocHTMLContainer}).</p>
     *
     * @class
     * @extends mstrmojo.Container
     *
     * @borrows mstrmojo._Formattable#formatHandlers as #formatHandlers

     */
    mstrmojo.DocTextfield = mstrmojo.declare(
        // superclass
        mstrmojo.Container,

        // mixins,
        [ mstrmojo._Formattable ],

        /**
         * @lends mstrmojo.DocTextfield.prototype
         */
        {
            scriptClass: "mstrmojo.DocTextfield",

            markupString:   '<div id="{@id}" class="mstrmojo-DocTextfield {@cssClass}" title="{@tooltip}" style="{@domNodeCssText}">' +
                                '<div class="mstrmojo-DocTextfield-valueNode" style="{@valueNodeCssText}" mstrAttach:click >{@v}</div>' +
                                '{@buttonNodeMarkup}' +
                            '</div>',

            markupSlots: {
                valueNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                domNode:  [ 'T', 'z-index' ],
                valueNode: [ 'D', 'B', 'F', 'P', 'background-color', 'fx', 'text-align', 'white-space', 'overflow' ]
            },

            markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },

            /**
             * Updates the DocTextField data that may change due to a selector action.
             *
             * @param {Object} node The widget node.
             */
            update: function update(node) {
                var d = node.data,
                    v = d.v || '';

                // Is this a text field being used to render an static HTML container?
                if (node.defn.t === HTML_CONTAINER) {
                    // Decode the value.
                    var div = document.createElement('div');
                    div.innerHTML = '<textarea>' + v + '</textarea>';
                    v = '<div style="display:none">&nbsp;</div>' + div.firstChild.value;
                    // Kill element.
                    div = null;
                }

                // Store value on instance.
                this.v = v;

                // Is there a threshold?
                if (this.thresholdId || d.tid) {
                    // Kill the format
                    delete this.fmts;
                }

                // Store threshold ID.
                this.thresholdId = d.tid;

				this.set('visible', !node.data.hidden);

                if (this._super) {
                    this._super(node);
                }
            },

            /**
             * Adjust the position of rotated text for non-IE browsers.
             *
             * @ignore
             * @refactoring If the textField has a hyperlink, the mouse's cursor shape will be a hand whenever a user moves the
             *                 cursor over the TextField.
             *                 The code in this method runs during rendering and likely has poor performance so we should evaluate
             *                 whether we want to support rotated text in non-IE browsers.
             */
            postBuildRendering: function postBuildRendering() {

                var $D = mstrmojo.dom,
                    f = this.getFormats(),
                    rotateValue = f.fx && f.fx.rt,
                    i,
                    len;

                // Is the text rotated, is this a non IE browser and is text rotation supported?
                if (rotateValue && !$D.isIE && $D.supports($D.cssFeatures.TEXT_ROTATION)) {
                    // We need to adjust the position of the object because IE rotates and
                    // translates at the same time
                    var dn = this.domNode;

                    // Switch on the type of rotated text...
                    switch (rotateValue) {
                    case 1:    // Are we looking at text which is rotated 90 clockwise?
                        // If so, simply translate the left position by the text height
                        // NOTE: We can remove this call if we enhance the preBuildRendering
                        // to pass the outer text height (saved in the MD as a fixed width)
                        // and add a call to translateX(__text_height__)
                        dn.style.left = (parseInt(f.left, 10) + dn.offsetHeight) + 'px';
                        break;

                    case 3: // Are we looking at text which is rotated 90 counterclockwise?
                        // Otherwise, translate the top position by text width...
                        dn.style.top = (parseInt(f.top, 10) + dn.offsetWidth) + 'px';
                        break;
                    }
                }

                // Is this a text field being used to render an static HTML container?
                if (this.defn.t === HTML_CONTAINER) {
                    // Grab collection of script tags within html container.
                    var scripts = this.domNode.getElementsByTagName('script');
                    for (i = 0, len = scripts.length; i < len; i++) {
                        // Eval each script text.
                        eval(scripts[i].innerHTML);
                    }
                }

                return this._super();
            },

            getAnchor: function getAnchor() {
                return this.valueNode;
            }

        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo._HasBuilder",
                         "mstrmojo._CanMeasureChildren",
                         "mstrmojo._CanRenderDocOnScroll",
                         "mstrmojo.dom");

    /**
     * The widget for a single MicroStrategy Report Services document layout.
     *
     * @class
     * @extends mstrmojo.Container
     *
     * @borrows mstrmojo._Formattable#formatHandlers as #formatHandlers
     * @borrows mstrmojo._Formattable#getFormats as #getFormats
     *
     * @borrows mstrmojo._HasBuilder#postBuildRendering as #postBuildRendering
     * @borrows mstrmojo._HasBuilder#buildChildren as #buildChildren
     *
     * @borrows mstrmojo._CanMeasureChildren#height as #height
     * @borrows mstrmojo._CanMeasureChildren#width as #width
     *
     * @borrows mstrmojo._CanRenderDocOnScroll#renderBlockSize as #renderBlockSize
     * @borrows mstrmojo._CanRenderDocOnScroll#renderMode as #renderMode
     * @borrows mstrmojo._CanRenderDocOnScroll#renderChildren as #renderChildren
     * @borrows mstrmojo._CanRenderDocOnScroll#onscroll as #onscroll
     * @borrows mstrmojo._CanRenderDocOnScroll#showRenderStatus as #showRenderStatus
     * @borrows mstrmojo._CanRenderDocOnScroll#_startScrollThread as #_startScrollThread
     * @borrows mstrmojo._CanRenderDocOnScroll#_renderSubsectionsToScroll as #_renderSubsectionsToScroll
     */
    mstrmojo.DocLayout = mstrmojo.declare(
        // superclass
        mstrmojo.Container,

        // mixins,
        [mstrmojo._Formattable, mstrmojo._HasBuilder, mstrmojo._CanMeasureChildren, mstrmojo._CanRenderDocOnScroll],

        /**
         * @lends mstrmojo.DocLayout.prototype
         */
        {
            scriptClass: "mstrmojo.DocLayout",

            markupString: '<div id="{@id}">' +
                              '<div class="mstrmojo-DocLayout {@cssClass}" style="{@domNodeCssText}"></div>' +
                          '</div>',

            markupSlots: {
                containerNode: function () { return this.domNode.firstChild; },
                popupNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                domNode: [ 'B', 'background-color', 'D', 'min-height', 'width' ]
            },

            alias: 'docLayout',
            markupMethods: {
                onminHeightChange: function () {
                    var mh = this.minHeight;
                    if (!mh) {
                        var fmts = this.getFormats();
                        mh = fmts && fmts['min-height'];
                    }
                    if (mh) {
                        this.containerNode.style[mstrmojo.css.MINHEIGHT] = mh;
                    }
                }
            },

            getHeight: function getHeight() {
                var h = 0;

                // Iterate children (sections) to get the sum of their heights.
                mstrmojo.array.forEach(this.children, function (child) {
                    h += child.height();
                });

                // Last resort, measure.
                return h || this.containerNode.offsetHeight;
            },

            getWidth: function getWidth() {
                // #497635, #501685, #502227
                var children = this.children;
                return (children && children.length) ? children[0].width() : this.containerNode.offsetWidth;
            },

            preBuildRendering: function preBuildRendering() {
                var f = this.getFormats();

                // Is the document in auto-width mode?
                if (f && f['min-width'] !== undefined) {
                    // Is so we need to copy the min-width value to the width property so the initial width will be correct.
                    f.width = f['min-width'];
                }

                this._super();
            },

            /**
             * Adjust the width of the containerNode to account for any 'Fit to Content' objects.
             *
             * @ignore
             * @see mstrmojo.Container
             */
            renderChildren: function renderChildren() {
                this._super();

                this.resizeOrReposition();
            },

            /**
             * Resizes the layout to fit it's contents.
             *
             * @ignore
             */
            resizeOrReposition: function resizeOrReposition() {
                var containerNode = this.containerNode;

                // Does this layout support auto width?
                if (!!this.defn.aw) {
                    // Get collection of autu width (fit to content) widgets.
                    var aws = this.model.getAutoWidthIDs(),
                        len = (aws && aws.length) || 0,
                        mx = 0,             // Right most position.
                        all = mstrmojo.all,
                        i;

                    // Are there zero auto width (fit to content) widgets?
                    if (!len) {
                        // Nothing to do.
                        return;
                    }

                    // Iterate fit to content widgets.
                    for (i = 0; i < len; i++) {
                        // Calculate the right most posotion for this widget.
                        mx = Math.max(this._getWidgetRightMostPosition(all[aws[i]]), mx);
                    }

                    // Adjust calculated maximum value for layout minimum value.
                    mx = Math.max(this.getLayoutMinWidth(), mx);

                    // Is the right most position of fit the fit to content widgets greater than the current width?
                    if (mx > parseInt(this.getFormats().width, 10)) {
                        // Set right most position as the width.
                        containerNode.style.width = mx + 'px';
                    }
                }

                // Are we on a mobile device and is zoom set to fit to width (1) OR fit to page (2)?
                var zoomToFit = this.model.zt;
                if (mstrApp.isMobile && zoomToFit) {

                    // Does the parent have a domNode?
                    var viewerNode = this.parent.domNode;
                    if (viewerNode) {

                        // Calculate margins.
                        var controller = this.model.controller,
                            isPortrait = !!controller.orientation,
                            verticalMargin = 0,                        // Default to fit to width.
                            parent = this.parent,
                            parentHeight = parent.getHeight() - parent.fixedHeaderNode.clientHeight - parent.fixedFooterNode.clientHeight; // #721240 parent Height minus fixed header footer height

                        // Is the zoom set to fit to page?
                        if (zoomToFit === 2) {

                            //TQMS# 729487 - We want to subtract the bottom action toolbar when it still does not exist in this.parent
                        	//controller.getBottomToolBarHeight() has code to check whether we should subtract or not
                            if (!controller.toolBarDelegated) {
                            	parentHeight -= controller.getBottomToolBarHeight();
                            }

                            // Calculate vertical margins so that layout is vertically centered.
                            verticalMargin = Math.round(isPortrait ? Math.max((parentHeight - this.getHeight()), 0) / 2 : 0) + 'px';
                        }

                        // Apply calculated margins.
                        containerNode.style.margin = verticalMargin + ' auto';

                        // Notify controller the widget has changed its position.
                        var me = this;
                        window.setTimeout(function () {
                            controller.nudgeWidget(me.id, {
                                left: containerNode.offsetLeft,
                                top: containerNode.offsetTop
                            });
                        }, 0);
                    }
                }
            },

            /**
             * Returns the minimum layout width (in pixels).
             *
             * @type Integer
             */
            getLayoutMinWidth: function getLayoutMinWidth() {
                return 0;
            },

            /**
             * Returns the right most position (in pixels) of widget associated with autoWidthIDs.
             *
             * It sums the left position plus the widget dimension width. The widget that has fit-to-content style should define a getDim() to return the actual widget width
             * in order to calculate the correct rightmost position; otherwise, the widget's domNode width will be applied.
             *
             * @param w Widget Instance whose id is in autoWidthIDs collection
             * @type Integer
             */
            _getWidgetRightMostPosition: function getLayoutMinWidth(w) {
                return parseInt(w.getFormats().left, 10) + (w.getDim && w.getDim().w || w.domNode.offsetWidth);
            },

            /**
             * Adjust the width of the containerNode to account for any 'Fit to Content' objects.
             *
             * @ignore
             * @see mstrmojo._CanRenderDocOnScroll
             */
            renderCtrlsInViewport: function renderCtrlsInViewport() {
                this._super();

                this.resizeOrReposition();
            },

            /**
             * Adjust mstrmojoDocLayout containerNode once the given widget width get changed
             * @param {Widget} w the 'Fit to Content' widget object
             */
            adjustAutoWidth: function adjustAutoWidth(w) {
                // Does the layout NOT support auto widths?
                if (!this.defn.aw || !w) {
                    // Nothing to do.
                    return;
                }

                // Calculate the right most position for this widget.
                var cs = this.containerNode.style,
                    wd = parseInt(cs.width, 10) || 0;      // Current width of the layout.

                //use timeout to ensure getting w's dimension correctly
                var me = this;
                window.setTimeout(function(){
                    var mx = me._getWidgetRightMostPosition(w);

                    // Is the right most position of the widget greater than the current width of the layout?
                    if (mx > wd) {
                        // Apply right most position as the width of the layout.
                        cs.width = mx + 'px';
                    }
                }, 1);
            },

            // override _getModelChildNodes in _CanRenderDocOnScroll to skip fixed header and footer
            _getModelChildNodes: function _getModelChildNodes(node, isPartial, start, count, includeTotal) {
                // cache ?????????????
                // first get all children
                var nds = this.model.getNonFixedSections(node, isPartial);

                // now process start, count, includeTotal parameters
                var len = nds.length;

                count = isNaN(count) ? len : count;
                start = start || 0;

                if (start > 0 || count < len) {
                    nds = nds.slice(start, start + count);
                }

                return includeTotal ? {
                    nodes: nds,
                    total: len
                } : nds;
            },
            // override getChildren in _HasBuilder to omit skip header and footer
            getChildren: function getChildren(node, isPartial, start, count, includeTotal) {
                return this._getModelChildNodes(node || this.node, isPartial || false, start, count, includeTotal);
            },

            getCaptureDimensions: function getCaptureDimensions() {
            	var domNode = this.domNode,
            		position = {};

            	if(!this.domNode) {
            		return;
            	}

            	position = mstrmojo.dom.position(domNode);

            	position.w = Math.min(domNode.offsetWidth, position.w);
            	position.h = Math.min(domNode.offsetHeight, position.h);

            	return position;
            },

            preserveChildDomOrder: false,

            postBuildRendering: function postBuildRendering(){

            	if (window.mstrMobileApp !== undefined) {
            		this.defn.lastOrientation = mstrMobileApp.getOrientation();
            	}

            	this._super();
            }

        }
    );

}());
(function(){

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._IsRwDocument",
                         "mstrmojo._HasBuilder",
                         "mstrmojo.array");

    /**
     * The widget for a single MicroStrategy iPhone Report Services document.
     * 
     * @class
     * @extends mstrmojo.Container
     * 
     * @borrows mstrmojo._IsRwDocument#updateXtabStyles as #updateXtabStyles
     * @borrows mstrmojo._IsRwDocument#buildChildren as #buildChildren
     * 
     * @borrows mstrmojo._HasBulder#buildChildren as #buildChildren
     */
    mstrmojo.iPhoneDoc = mstrmojo.declare(
        // superclass
        mstrmojo.Container,
        
        [ mstrmojo._HasBuilder, mstrmojo._IsRwDocument],
        
        /**
         * @lends mstrmojo.iPhoneDoc.prototype
         */
        {
            scriptClass: "mstrmojo.iPhoneDoc",

            markupString: '<div id="{@id}" class="mstrmojo-iPhoneDoc" style="{@cssText}"></div>',
            
            markupSlots: {
                containerNode: function(){ return this.domNode; }
            },
            
            buildChildren: function buildChildren(noAddChildren) {
                // Did we build children (pass false to add children automatically)?
                if (this._super(false)) {
                    // Select the current layout if any. Use set() so that stack can use a custom setter to show/hide its children.
                    var k = this.model.getSelectedKey(this.node),
                        i = (k !== null) ? mstrmojo.array.find(this.children, "k", k) : -1,
                        ch = (i > -1) ? this.children[i] : null;
                    
                    //Set the current child to be visible.
                    if (ch) {
                        ch.set("visible", true);
                    }
                        
                    return true;
                }
                
                return false;
            }
        }
    );
    
})();
(function(){
	mstrmojo.requiresCls('mstrmojo.Container', 'mstrmojo.css');
	
	/**
	 * The prefix to use when designating new slots.
	 * 
	 * @const
	 * @private
	 * @ignore
	 */
	var C_PREFIX = '',	/* TODO check with GB, should we have some prefix for cell slot id? */
        R_PREFIX = 'row-',
        TABLE = mstrmojo.css.DISPLAY_TABLE;

	mstrmojo.Table = mstrmojo.declare(
		// super class
		mstrmojo.Container,
		// mixin
		null,
		// instance method
		{
			scriptClass: 'mstrmojo.Table',
			cellCssClass: '',
			/**
			 * Setting for number of rows
			 */
			rows: -1,
			/**
			 * Setting for number of columns
			 */
			cols: -1,
			/**
			 * Total rows in the table
			 */
			_trows: -1,
			
			cellPadding: 0,
			cellSpacing: 0,
			
			/**
			 * Setting for table layout. 
			 */
			layout: null,
			markupString: '<table id="{@id}" class="mstrmojo-Table {@cssClass}" style="{@cssText}" cellpadding="{@cellPadding}" cellspacing="{@cellSpacing}">{@tableHtml}</table>',
			markupSlots: {
				containerNode: function() { return this.domNode; }
			},
            markupMethods: {
                onvisibleChange: function() { this.domNode.style.display = this.visible ? TABLE : 'none'; }
            },
			preBuildRendering: function preBR () {
				// if layout defined, we need to construct table
				var rs = [],
					ccc = this.cellCssClass;
				if (this.layout){
					var rlen = this._trows = this.layout.length;
					// populate each row
					for (var i = 0; i < rlen; i ++ ){
						var r = this.layout[i],
							cells = r.cells,
							clen = cells.length,
							cs =[];
						// populate each cell
						for (var j = 0; j < clen; j ++) {
							var c = cells[j], 
								att = '';
							att += ((c.cssClass || ccc)? ' class="' + (c.cssClass || ccc) + '"' : '');
							att += (c.cssText? ' style="' + c.cssText + '"' : '');
							att += (c.rowSpan? ' rowspan="' + c.rowSpan + '"' : '');
							att += (c.colSpan? ' colspan="' + c.colSpan + '"' : '');
							cs[j] = '<td' + att + '></td>';
						} // end of looping through cells
						var rAtt = '';
						rAtt += (r.cssClass? ' class="' + r.cssClass + '"' : '');
						rAtt += (r.cssText? ' style="' + r.cssText + '"' : '');
						rs[i] = '<tr' + rAtt + '>' + cs.join('') + '</tr>';
					} // end of looping through rows
				} else{
					this._trows = this.rows;
					var att = (ccc? ' class="' + ccc + '"' : ''),
						cs = [];
					// populate each row
					for (var i = 0; i < this.rows; i ++) {
						for (var j = 0; j < this.cols; j ++) {
							cs[j] = '<td' + att + '></td>';
						}
						rs[i] = '<tr>' + cs.join('') + '</tr>';
					}
				}
				this.tableHtml = rs.join('');
				// calling super
				if (this._super) {
				    this._super();
			    }
			},
			/**
			 * After rendering, we need to record the slots for every row 
			 * (TODO check with GB, is the slot for row neccessary. I need it before I may add empty rows before a row with cells...)
			 * and every cell,
			 * so later, we can insert child widget to the correct location.
			 */
			postBuildRendering: function postBuildRendering() {
				// Do we have rows in table?
				if (this._trows){
					var slots = {},
						trs = this.containerNode.rows,
						rlen = trs.length;
					// loop through rows
					for (var i = 0; i < rlen; i ++) {
						var cells = trs[i].cells,
							clen = cells.length;
						slots[R_PREFIX + i] = trs[i];
						// loop through cells
						for (var j = 0; j < clen; j ++) {
							slots[C_PREFIX + i + ',' + j] = cells[j];
						}						
					}
					// add slots
					this.addSlots(slots);
				}
				// calling super
				this._super();
			},
			/**
			 * Overwrites the inherited childRenderCheck from Container to support
			 * rendering children whose slot = "<rowIndex>,<cellIndex>" even if no such slot is defined yet.
			 * For such children, the slot will be created dynamically on-demand.
			 */
			childRenderCheck: function childRndrChk(/*Object*/ child) {
				if (child && !child.hasRendered) {
					var slotName = child.slot || this.defaultChildSlot;  // TODO check with GB, what is the defaultChildSlot?
					return !!this[slotName] || slotName.match(/^([\d]+),([\d]+)$/);
				}
				return false;
			},
			/**
			 * When a child widget finishes rendering itself, we need to insert it into the correct cell.
			 * If we have not built the cell, we need to built the cell before rendering.
			 * If we even have not built the row, then we need to 
			 */
			on_child_change_rendering: function onChldChngRndr(/*Event|Widget*/ obj) {
				var child = (obj && obj.src) || obj,
				d = child && child.domNode;
				if (d) {
					// What is the slot name of the child?
					var s = child.slot;
					// Do we have a slot node to match that name?
					if (!this[s]) {
						// No. We may need to build it on-the-fly.
						// Does the slot name have this syntax: "<rowIndex>,<cellIndex"?
						var match = s && s.match(/^([\d]+),([\d]+)$/);
						if (match) {
							// The # is an index for a cell. Build the cell as a new slot (which
							// in turn requires building cells/slots for all preceeding indices too).
							var ri = parseInt(match[1], 10), // row index
								ci = parseInt(match[2], 10), // cell index
								cn = this.containerNode,	 // table node
								rslot = this[(R_PREFIX + ri)],	// row slot
								slots = [];
							// if we do not have the row built yet, we need to build all the rows missing
							if (!rslot) {
								var rs = cn.rows,
								rlen = rs && rs.length || 0;
								// insert rows
								for (var i = rlen; i <= ri; i ++) {
									slots[R_PREFIX + i] = cn.insertRow(); // TODO check with GB about usage of insertRow
								}
								// get the row slot for the target row
								rslot = slots[R_PREFIX + ri];
							}
							// now we have the row slot, we need to insert the cell
							var cLen = rslot.cells && rslot.cells.length || 0;
							for (var i = cLen; i <= ci; i++) {
								var td = rslot.insertCell(i);
								slots[C_PREFIX + ri + ',' + i] = td;
								if (this.cellCssClass) {
									td.className = this.cellCssClass;
								}
							}
							this.addSlots(slots);
						}
					}
				}
				// Call the inherited method to actually insert the child DOM into slot.
				this._super(obj);
				
			}
		}
	);
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo._ContainsDocObjects",
                         "mstrmojo._HasBuilder",
                         "mstrmojo.css",
                         "mstrmojo.array");

    var $CSS = mstrmojo.css;

    var ITEM_SPA = 2;
    /**
     * Looks at the panels parent's parent to see if it is also a panel.  If so, if will call the supplied method name passing the supplied key.
     * 
     * @param {mstrmojo.DocPanel} pnl The panel in question.
     * @param {String} methodName The name of the method to call on the ancestor panel.
     * @param {String} key The key to pass as the parameter of the method.
     * @private
     */
    function passDirtyKeyToAncestorPanel(pnl, methodName, key) {
        // Get the parent of our parent.
        var p = pnl.parent.parent;

        // Is the grandparent a panel too? 
        if (p && p instanceof mstrmojo.DocPanel) {
            // Call the requested method (with supplied key as parameter).
            p[methodName + 'DirtyKey'](key);
        }
    }

    /**
     * Iterates the children of the panel to find any panel stacks and sets their children as dirty, but only if
     * the current panel is dirty.
     * 
     * @param {String} key The current dirty key.  If the key does not match the panel key nothing will happen.
     * @param {mstrmojo.DocPanel} panel The panel in question.
     * @param {Boolean} allDirty Whether all child panels are dirty (true) or only non-visible panels (false).
     * 
     * @private
     */
    function setDirtyChildrenOnDescendant(key, panel, allDirty) {
        // Is the dirty key our own panel key?
        if (key === panel.k) {
            // Iterate our children...
            mstrmojo.array.forEach(panel.children, function (child) {
                // Can this child contain dirty children (panel stacks only)?
                if (child.setDirtyChildren) {
                    // Tell it to mark its children (panels) as dirty.
                    child.setDirtyChildren(allDirty);
                }
            });
        }
    }

    /**
     * Report Services Document Panel.
     *
     * @class
     * @extends mstrmojo.Container
     *
     * @borrows mstrmojo._Formattable
     * @borrows mstrmojo._ContainsDocObjects
     * @borrows mstrmojo._HasBuilder
     */
    mstrmojo.DocPanel = mstrmojo.declare(
        // superclass
        mstrmojo.Container,

        // mixins,
        [ mstrmojo._Formattable, mstrmojo._ContainsDocObjects, mstrmojo._HasBuilder ],

        /**
         * @lends mstrmojo.DocPanel.prototype
         */
        {
            scriptClass: "mstrmojo.DocPanel",

            /**
             * Whether this panel is visible.
             *
             * @type boolean
             * @default false
             */
            visible: false,

            /**
             * Whether this panel is selected in it's parent panel stack.
             *
             * @type boolean
             * @default false
             */
            selected: false,

            cssDisplay: 'block',

            // record the top start point for next child, only used for filter panel
            // start at 2 because we want to spacing between the first selector and the panel title bar 
            topStart: ITEM_SPA,
            
            // special used for filter panel, record the width for chlid items
            contentWidth: 0,
            
            markupString: '<div id="{@id}" class="mstrmojo-DocPanel {@cssClass}" style="{@cssText}{@domNodeCssText}">' +
                              '<div class="mstrmojo-DocSubPanel-content" style="height:100%;width:100%;position:absolute;{@containerNodeCssText}"></div>' +
                          '</div>',

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; }
            },

            markupSlots: {
                containerNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                containerNode: [ 'background-color', 'fx' ]
            },

            title: '',

            /**
             * Sets this panel's title according to the given node definition, if any.
             *
             * @ignore
             */
            init: function init(props) {
                this._super(props);

                // Do we have a title?
                if (!this.title) {
                    // No, then retrieve it from the definition.
                    this.title = this.node.defn.ttl || '';
                }
                
            },

            /**
             * Only render children for selected panels.
             *
             * @ignore
             */
            childRenderCheck: function childRenderCheck(c) {
                return (this._super(c) && this.selected);
            },

            postBuildRendering: function postBuildRendering() {
                var c = $CSS.addClass;
                // Is the panel NOT loaded and is this render NOT the result of a forced render?
                if (!this.defn.l && !this._forceRender) {
                    // Add placeholder class.
                    c(this.domNode, 'placeholder');
                }

                return this._super();
            },

            onselectedChange: function onselectedChange(evt) {
                this.set('visible', !!evt.value);
                // Is the panel newly selected?
                if (evt.value) {
                    // Make sure the children are rendered.
                    this.renderChildren();
                }
                this.model && this.model.raiseEvent({name: 'panelSelected',panelId:this.id, panelVisible:!!evt.value});
            },

            /**
             * Manually calls refresh on all objects within this panel.
             *
             * @ignore
             * @see mstrmojo.Widget
             */
            refresh: function refresh() {
                // Have we NOT already rendered?
                if (!this.hasRendered) {
                    // Nothing to do.
                    return;
                }

                // If the panel is not selected now it means it was just requested from the server (lazy loading) so we need to force a render to
                // build children.
                if (!this.selected) {
                    // Clear built children flag...
                    if (!this.children) {
                        this.builtChildren = false;
                    }

                    // cache forced status...
                    this._forceRender = true;

                    // let super handle the refresh...
                    this._super();

                    // and clear forced status.
                    delete this._forceRender;

                } else {
                    // Manually call refresh on all children rather than rebuild html for PanelStack.
                    var c = this.children || [],
                        i;

                    for (i = c.length - 1; i >= 0; i--) {
                        c[i].refresh();
                    }
                    
                    // TQMS 544927: for filter panel, we have to relocate the position of its children
                    if (this._isFP()) {
                        this.refreshFP();
                    }
                }
            },

            /**
             * Adds (or removes) this panels key to it's own store of dirty keys.
             *
             * @param {Boolean} isDirty Whether this panel is dirty or not.
             */
            setDirty: function setDirty(isDirty) {
                var mth = ((isDirty) ? 'add' : 'remove') + 'DirtyKey';
                this[mth](this.k);
            },

            /**
             * Adds the supplied key to this panels dirty key collection.  This method also raises the key to any ancestor panels.
             *
             * @param {String} key The key of the dirty widget.
             */
            addDirtyKey: function addDirtyKey(key) {
                // Cache the dirtyKeys (or empty object).
                var d = this.defn,
                    hash = d.dirtyKeys || {};

                // Add the passed in key.
                hash[key] = true;

                // Store the dirtyKeys back on the definition.
                d.dirtyKeys = hash;

                // Set dirty children state for all panels within child panel stacks.
                setDirtyChildrenOnDescendant(key, this, true);

                // Pass command to the grand parent (if Panel).
                passDirtyKeyToAncestorPanel(this, 'add', key);
            },

            /**
             * Removes the supplied key from this panels dirty key collection.  This method also raises the key to any ancestor panels.
             *
             * @param {String} key The key of the clean widget.
             */
            removeDirtyKey: function removeDirtyKey(key) {
                // Pass command to the grand parent (if Panel).
                passDirtyKeyToAncestorPanel(this, 'remove', key);

                // Set dirty children state for non-visible panels within child panel stacks.
                setDirtyChildrenOnDescendant(key, this, false);

                // Grab the dirty keys collection.
                var defn = this.defn,
                    dk = defn.dirtyKeys;

                // Did we find any dirty keys?
                if (!dk) {
                    // Dirty keys may not be there if the panel was not previously loaded when the slice occurred, so return.
                    return;
                }

                // Delete this key from the collection.
                delete dk[key];

                // Do any keys remain?
                if (!mstrmojo.hash.isEmpty(dk)) {
                    // Yes, then return.
                    return;
                }

                // No dirty keys left so delete the collection.
                delete defn.dirtyKeys;
            },
            
            renderChildren: function rnCh() {   
                var ch = this.children;
                if (ch && (this._isFP() || this._isFSP())) {
                    // record the original order
                    for (var i=0,len=ch&&ch.length||0; i<len; i++) {
                        ch[i].orgPos = i;
                    }
                    // adjust the children items by z-index
                    ch.sort(function(l,r) {
                        var lz = (l.getFormats() && l.getFormats()['z-index']) || 0,
                            rz = (r.getFormats() && r.getFormats()['z-index']) || 0;
                        
                        // #530852, if the 'z-index' is equal, keep the items in the original order.
                        return lz - rz || l.orgPos - r.orgPos;
                    });                                                   
                }
                
                if (this._isFP()) {     //Is Filter Panel
                    if (ch) {
                        // render each children and sum the current children height for next child rendering top start point
                        // TODO: we need to consider the vertical scrollbar width if it show up
                        var ocw = this.domNode.clientWidth - 2 * ITEM_SPA
                        
                        // reset topStart TQMS 575606
                        this.topStart = ITEM_SPA + 1;
                        
                        for (var i=0,len=ch&&ch.length||0; i<len; i++) {
                            var cw = this.domNode.clientWidth - 2 * ITEM_SPA;
                            this.contentWidth = (cw > 0) ? cw : 0;
                            
                            if (cw != ocw) {    
                                //vertical scrollbar show up, we need to redraw previous rendered children
                                this.topStart = ITEM_SPA;
                                for (var j=0; j<i; j++) {
                                    var oc = ch[j];
                                    oc.refresh();                                                                  
                                    if (oc.getContainerHeight) {
                                        this.topStart += oc.getContainerHeight() + ITEM_SPA;
                                    }
                                }
                            }
                            
                            var c = ch[i];
                            if (this.childRenderCheck(c)) {
                                c.render(null);    
                                                           
                                if (c.getContainerHeight) {
                                    this.topStart += c.getContainerHeight() + ITEM_SPA;
                                }
                            }
                        }
                    }
                } else {
                    this._super();
                } 
            },

            
            refreshFP: function() {
                if (!this.hasRendered) {
                    return;
                }
                
                var ch = this.children;
                this.topStart = ITEM_SPA;  //2px gap between each selectors
                var cw = this.domNode.clientWidth - 2 * ITEM_SPA;
                this.contentWidth = (cw > 0) ? cw : 0;
                
                // reset the top of each children
                for (var i=0,len=ch&&ch.length||0; i<len; i++) {
                    var c = ch[i];
                    if (c.relocate) {
                        c.relocate(this.topStart, this.contentWidth);
                    }
                                                   
                    if (c.getContainerHeight) {
                        this.topStart += c.getContainerHeight() + ITEM_SPA;
                    }
                }
            },
            
            getChildren: function getChildren(){                
                var ch = this.model.getChildren(this.node, false);
                
                if (this._isFP() || this._isFSP()) {
                    for (var i=0,len=ch&&ch.length||0; i<len; i++) {
                        var c = ch[i];
                        if (this._isFP() && !c.defn.iifp) {
                            c.defn.iifp = true; //iifp: is inside the filter panel
                        }
                        if (this._isFSP() && !c.defn.iifs) {
                            c.defn.iifs = true; //iifs: is inside the filter summary
                        }
                    }
                }
                
                return ch;
            },
            
            // is a filter panel
            _isFP: function() { 
                return this.parent.defn.ifp;
            },
            
            // is a filter summary panel
            _isFSP: function() {
                return this.parent.defn.ifsp;
            }
                
        }
    );

}());
(function(){


    mstrmojo.requiresCls("mstrmojo._HasBuilder",
                         "mstrmojo._HasLayout",
                         "mstrmojo.Container");

    var DARK_BORDER_WIDTH = 1;

    mstrmojo.maps.androidmap.AndroidDocMapInfoWindow = mstrmojo.declare(
        // superclass
        mstrmojo.Container,
        
        // mixins,
        [ mstrmojo._HasBuilder, mstrmojo._HasLayout ],
        
        // instance props+methods
        {
            scriptClass: "mstrmojo.maps.androidmap.AndroidDocMapInfoWindow",
            
            markupString: '<div class="mstrmojo-androidmap-DocInfoWindow-wrapper">' +
                              '<div id="{@id}" class="mstrmojo-androidmap-DocInfoWindow"></div>' +
                          '</div>',

            markupSlots: {
                infoNode: function() { return this.domNode.firstChild; },
                containerNode: function() { return this.domNode.firstChild; }
            },
                        
            getChildren: function getChildren(){
                
                var m = this.model,
                    c = m.getLayoutDataCache(m.getCurrentLayoutKey())[this.psId],
                    f = c.defn.fmts;
                
                // Override positioning format of child.
                f.left = DARK_BORDER_WIDTH + 'px';
                f.top = DARK_BORDER_WIDTH + 'px';
                
                return [c];
            }
        });

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container");

    var $WIDGET = mstrmojo.Widget;

    mstrmojo.Box = mstrmojo.declare(

        mstrmojo.Container,

        null,

        {
            scriptClass: "mstrmojo.Box",

            markupString: '<div id="{@id}" class="mstrmojo-Box {@cssClass}" style="{@cssText}"></div>',

            markupSlots: {
                containerNode: function () { return this.domNode; }
            },

            markupMethods: {
                onvisibleChange: $WIDGET.visibleMarkupMethod,
                onheightChange: $WIDGET.heightMarkupMethod,
                onwidthChange: $WIDGET.widthMarkupMethod
            }
        }
    );

}());
(function(){

	mstrmojo.requiresCls("mstrmojo.Container");
	
	
	/**
	 * The prefix to use when designating new slots.
	 * 
	 * @const
	 * @private
	 * @ignore
	 */
	var PREFIX = "slot";
	
	/**
	 * A container for laying children out in a single horizontal row.
	 * @class
	 * 
	 * @extends mstrmojo.Container
	 */
	mstrmojo.HBox = mstrmojo.declare(
		// superclass
		mstrmojo.Container,
		
		// mixins,
		null,
		
		/**
		 * @lends mstrmojo.HBox.prototype
		 */
		{
			scriptClass: "mstrmojo.HBox",
			
			cellCssClass: "",
			
			cellSpacing: 0,
			
			cellPadding: 0,
						
			markupString: '<table id="{@id}" class="mstrmojo-HBox {@cssClass}" style="{@cssText}" cellspacing="{@cellSpacing}" cellpadding="{@cellPadding}">{@colHTML}<tr>{@tableHtml}</tr></table>',
			
			colHTML: '',

			markupSlots: {
				containerNode: function() { return this.domNode.rows[0]; }
			},
			
			markupMethods: {
				onvisibleChange: function() { this.domNode.style.display = this.visible ? mstrmojo.css.DISPLAY_TABLE : 'none'; }
			},

			/** 
			 * Extends the rendering cycle by populating the tableHtml property with an HTML markup
			 * string that contains a table cell for each child present at render-time.  Each child is
			 * assigned a table cell as its slot.
			 */ 
			buildRendering: function bldRn() {
				// Build the tableHtml string property.
				this.tableHtml = '';
				var t = [],
					ch = this.children,
					len = (ch && ch.length) || 0,
					i;
				
				if (len) {
					var counter = 0,
						css = this.cellCssClass ?
								' class="mstrmojo-HBox-cell ' + this.cellCssClass + '" ' :
								'',
						tdHtml = '<td ' + css + '></td>';
					for (i=0; i<len; i++) {
						t[counter++] = tdHtml;
						ch[i].slot = PREFIX+i;
					}
					this.tableHtml = t.join('');
				}				

				// Call the inherited method to do the DOM construction.				
				this._super();				
				
				// Add the newly generated cells as slots.  This must be done
				// before renderChildren() is called in postBuildRendering, so that
				// the slots are ready to receive the children's DOM nodes.
				if (len) {
					var slots = {},
						tds = this.containerNode.cells;
					for (i=0; i<len; i++) {
						slots["slot"+i] = tds[i];
					}
					this.addSlots(slots);
				}
			},
			
			addChildren: function addChild(widget, idx, silent) {
				if (!widget) {
					return widget;
				}
				
				// Calculate the index (if not supplied).
				if (idx === undefined || isNaN(idx) || idx < 0) {
				    var ch = this.children;
					idx = (ch && ch.length) || 0;
				}
				
				var i = 0,
				    cnt;
				
				// If an array of children we need to iterate...
				if (widget.constructor === Array) {
					for (i = 0, cnt = widget.length; i < cnt; i++) {
						widget[i].slot = PREFIX + (idx + i);
					}
				} else {
					// Otherwise, just do it once.
					widget[i].slot = PREFIX + idx;
				}
				
				// Add the child widget(s).
				return this._super(widget, idx, silent);
			},
			
			/**
			 * Overwrites the inherited childRenderCheck from Container to support
			 * rendering children whose slot = "slot<#>" even if no such slot is defined yet.
			 * For such children, the slot will be created dynamically on-demand.
			 */
			childRenderCheck: function childRndrChk(/*Object*/ child) {
				if (child && !child.hasRendered) {
					var slotName = child.slot || this.defaultChildSlot;
					return !!this[slotName] || slotName.match(/^slot[\d]+$/);
				}
				return false;
			},
			
			onchildRenderingChange: function chRnChg(/*Event|Widget*/ obj) {
				var child = (obj && obj.src) || obj,
					d = child && child.domNode;
				
				if (d) {
					// What is the slot name of the child?
					var s = child.slot;
					// Do we have a slot node to match that name?
					if (!this[s]) {
						// No. We may need to build it on-the-fly.
						// Does the slot name have this syntax: "slot<#>"?
						var match = s && s.match(/^slot([\d]+)$/);
						if (match) {
							// The # is an index for a cell. Build the cell as a new slot (which
							// in turn requires building cells/slots for all preceeding indices too).
							var idx = parseInt(match[1], 10),
								cn = this.containerNode,
								cells = cn.cells,
								cLen = (cells&&cells.length) || 0,
								slots = {};
							for (var i = cLen; i <= idx; i++) {
								var td = cn.insertCell(i);
								slots["slot"+i] = td;
								if (this.cellCssClass) {
									td.className = this.cellCssClass;
								}
							}
							this.addSlots(slots);
						}
					}
				}
				
				// Call the inherited method to actually insert the child DOM into slot.
				this._super(obj);
			}			
		
		}
	);
	
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo._IsPanelStack",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo._HasBuilder",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.TouchScroller",
                         "mstrmojo.css");

    var $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom,
        $M = Math,
//        debug = false,
        SWITCH_DURATION = 700;

    function clearAnimationTimeout() {
        // Do we already have an animation handle?
        var handle = this._animHandle;
        if (handle) {
            // Clear timeout and delete handle.
            window.clearTimeout(handle);
            delete this._animHandle;
        }
    }

    function clearAnimationFlag() {
        // Delete timeout handle and...
        delete this._animHandle;

        // Clear animating flag.
        this._isAnimating = false;
    }

    /**
     * Applies the duration and transform value to the supplied node.
     *
     * @param {Integer} duration The duration of the transition (in milliseconds).
     * @param {Integer} value The value of the x position.
     * @param {Boolean} [force=false] True if we should apply the new position, even if it's the same as the last position.
     * @param {Boolean} [simulateEvt=false] True if we should set a timeout to make sure the animation state is cleared.
     *
     * @private
     */
    function applyTransform(duration, value, force, simulateEvt) {
        // Is this value different from the last value?
        var lastValue = this._translateX;
        if (force || value !== lastValue) {
//            if (debug) {
//                console.log(this.k + ' will move to ' + (value - (lastValue || 0)) + ' over ' + duration);
//            }

            // Store the new values on the instance.
            this._translateX = value;

            // Make sure any previous animation timers are cleared.
            clearAnimationTimeout.call(this);

            // Is there a duration?
            if (duration) {
                // Set animation flag.
                this._isAnimating = true;
            }

            // Move the node.
            var nodeStyle = this.containerNode.style;
			nodeStyle[$DOM.CSS3_TRANSITION_DURATION] = duration + 'ms';
			nodeStyle[$DOM.CSS3_TRANSFORM] = $DOM.createTranslateString(-value);

            // Should we set a timer to simulate the webkitEndTransistion event?
            if (simulateEvt) {
                var id = this.id;
                this._animHandle = window.setTimeout(function () {
                    // Get widget reference.
                    var w = mstrmojo.all[id];

                    // Is widget still animating?
                    if (mstrmojo.all[id]._isAnimating) {

                        // Clear animating flag.
                        clearAnimationFlag.call(w);
                    }
                }, duration * 3);
            }

            if (this._scroller) {
                this._scroller.raiseEvent({
                    name: 'transformAnim',
                    x: value,
                    y: 0
                });
            }
        }
    }

    /**
     * Renders the docked selector buttons.
     *
     * @private
     */
    function renderSelector() {
        // Do we NOT have a docked selector?
        if (!this.defn.dk) {
            return;
        }
        var panels = this.children,
            i = 0,
            cnt = panels.length,
            selectedIdx = this.selectedIdx,
            btnMarkup = [];

        // Iterate panels.
        for (i = 0; i < cnt; i++) {
            // Start single button markup.
            btnMarkup.push('<div idx="' + i + '" class="');

            // Is this the selected panel?
            if (i === selectedIdx) {
                btnMarkup.push('on');
            }

            // Finish single button markup.
            btnMarkup.push('"><div></div></div>');
        }

        // Size selector btns node...
    	var selectorBtnsNode = this.selectorBtns,
    		dpi = mstrMobileApp.getDeviceDPI();

		// TQMS# 722957 use some hard coded values depending on device DPI.  These values match the mstrmojo-SelectorBtns rules in CSS.  
    	// If we have an unknown resolution we scale the 160 dpi size proportionally to the device dpi.
		var tabWidths = {
				160:	26,
				213:	26,
				240:	38,
				320:	57
			},
			btnWidth = tabWidths[dpi] || ( tabWidths[160] * dpi / 160 );  
		
        selectorBtnsNode.style.width = (cnt * btnWidth) + 'px';

        // add button markup...
        selectorBtnsNode.innerHTML = btnMarkup.join('');

        // and make selector visible.
        this.selector.style.display = 'block';
    }

    /**
     * A widget to display a panel stack within a Report Services document on the Android platform.
     *
     * @class
     * @extends mstrmojo.Container
     *
     * @borrows mstrmojo._Formattable
     * @borrows mstrmojo._IsSelectorTarget
     * @borrows mstrmojo._HasBuilder
     * @borrows mstrmojo._HasTouchScroller
     * @borrows mstrmojo._IsPanelStack
     * @borrows mstrmojo._TouchGestures
     */
    mstrmojo.android.DocPanelStack = mstrmojo.declare(

        mstrmojo.Container,

        [ mstrmojo._Formattable, mstrmojo._IsSelectorTarget, mstrmojo._HasBuilder, mstrmojo._HasTouchScroller, mstrmojo._IsPanelStack, mstrmojo._TouchGestures ],

        /**
         * @lends mstrmojo.android.DocPanelStack.prototype
         *
         */
        {
            scriptClass: "mstrmojo.android.DocPanelStack",

            btnMarkup: '',

            markupString: '<div id="{@id}" title="{@tooltip}" class="mstrmojo-DocPanelStack {@cssClass}" style="{@domNodeCssText}">' +
                            '<div></div>' +
                            '<div class="mstrmojo-PanelSelector">' +
                                '<div class="mstrmojo-SelectorBtns"></div>' +
                            '</div>' +
                          '</div>',

            markupSlots: {
                containerNode: function () { return this.domNode.firstChild; },
                selector: function () { return this.domNode.lastChild; },
                selectorBtns: function () { return this.domNode.lastChild.firstChild; }
            },

            formatHandlers: {
                domNode: [ 'RW', 'B' ]
            },

            scrollerConfig: {
                bounces: false,
                showScrollbars: false,
                vScroll: false,
                hScroll: true
            },

            /**
             * Panels are hidden by default so we need to set the visibility of the current panel to true.
             *
             * @see mstrmojo.Container
             */
            addChildren: function addChildren(panels, idx, silent) {

                this._super(panels, idx, silent);

                var containerNodeStyle = this.containerNode.style,
                    formats = this.getFormats(),
                    width = this._pnlWidth = parseInt(formats.width, 10),
                    height = parseInt(formats.height, 10),
                    selectedIdx = this.selectedIdx;

                // Set the width of the container node to the sum width of all panels.
                var newPosition = this.selectedIdx * width;

                // Set width of container node to the width of a panel times the number of panels.
                containerNodeStyle.width = (width * panels.length) + 'px';

                // Make sure the panel slider is in the correct position.
                if (!$DOM.isWinPhone) {
                    applyTransform.call(this, 0, newPosition);
                } else {
                    containerNodeStyle.msTransform = newPosition;
                }

                // Iterate panels.
                var i = 0,
                    cnt = panels.length;

                for (i = 0; i < cnt; i++) {
                    var panel = panels[i];

                    // All panels should be visible.
                    panel.visible = true;

                    // Only the current panel is selected.
                    panel.selected = (i === selectedIdx);

                    // Update panel dimensions so that they render end to end.
                    panel.updatePanelDimensions(i * width, height, width);
                }

                // Render the docked panel selector.
                renderSelector.call(this);

                // Update the scroller now that we have children.
                this.updateScroller();

                return true;
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                // Render the docked panel selector.
                renderSelector.call(this);

                // Attach transition end event to hear when panel is done animating.
                var id = this.id;
                mstrmojo.dom.attachEvent(this.containerNode, $DOM.CSS3_TRANSITION_END, function (evt) {

                    var widget = mstrmojo.all[id];
                    if (evt.target !== widget.containerNode) {
                        return true;
                    }

//                    if (debug) {
//                        console.log(widget.k + ' STOPPED animating.');
//                    }

                    // Make sure any previous animation timers are cleared.
                    clearAnimationTimeout.call(widget);

                    // Stop propagation so ancestor elements don't hear the event as well.
                    evt.stopPropagation();

                    // Clear animating flag.
                    clearAnimationFlag.call(widget);

                    return false;
                });

                return true;
            },

            /**
             * Sets the dimensions on the panel stack and it the containing panels. It also repositions
             * the panels correctly based on the new dimensions.
             *
             * @param {Object} d Object containing the new dimensions of the panel stack.
             */
            setInfoWindowDimensions: function setInfoWindowDimensions(d) {
                // Is the parent of the panel stack a portlet?
                var parent = this.parent;
                if (parent.scriptClass === 'mstrmojo.DocPortlet') {
                    // Pass dimensions to the portlet so it can resize and adjust dimensions for portlet chrome.
                    parent.setInfoWindowDimensions(d);
                }

                var h = d.h,
                    w = d.w,
                    domNodeStyle = this.domNode.style,
                    panels = this.children,
                    len = panels.length,
                    px = 'px',
                    i;

                // Update the dimensions of the panel stack DOM Node.
                domNodeStyle.height = h + px;
                domNodeStyle.width = w + px;

                // Update the width of the container node.
                this.containerNode.style.width = (w * len) + px;

                // Update the cached panel width.
                this._pnlWidth = w;

                // Update the translateX field.
                this._translateX = (this.selectedIdx || 0) * w;

                // Iterate panels.
                for (i = 0; i < len; i++) {
                    // Update panel dimensions.
                    panels[i].updatePanelDimensions(i * w, h, w, true);
                }

                // Update the scroller for the new size.
                this.updateScroller();
            },

            getTitle: function getTitle() {
                // We should get the title from the title property as it accounts for both the cases of 'Custom Title' and 'Show Panel Title'.
                return this.title;
            },

            /**
             * Attach an event listener to update _translateX when scroll actions are complete.
             *
             * @param {mstrmojo.TouchScroller} scroller The scroller widget.
             *
             * @see mstrmojo._HasTouchScroller
             * @ignore
             */
            initScroller: function initScroller(scroller) {
                // Attach an event listener to hear when scrolls are done.
                scroller.attachEventListener('scrollDone', this.id, function (evt) {
                    // Update the translateX value after each scroll.
                    this._translateX = evt.x;
                });
            },

            /**
             * Update the scroller config with current offset, origin and transform value.
             *
             * @see mstrmojo._HasTouchScroller
             * @ignore
             */
            updateScrollerConfig: function updateScrollerConfig() {
                var children = this.children,
                    length = children && children.length,
                    cfg = this._super();

                // Panel stack do not scroll vertically.
                cfg.noVScroll = true;

                // Do we have any children?
                if (length) {
                    var position = this._translateX || 0,
                        width = this._pnlWidth,
                        offset;

                    // Create X axis offset and cache for later use.
                    offset = {
                        start: $M.max(position - width, 0),                                      // Beginning of previous panel, or 0, whichever is greater.
                        end: $M.min(position + width, length * width - width)                    // End of current panel, or position of current panel if this is the last panel.
                    };

                    // Overwrite offset, origin and transform values on the scroller configuration.
                    mstrmojo.hash.copy({
                        scrollEl: this.containerNode,

                        offset: {
                            x: offset,
                            scrollPast: false
                        },

                        origin: {
                            x: position,
                            y: 0
                        }
                    }, cfg);
                }

                return cfg;
            },

            onselectedIdxChange: function onselectedIdxChange(evt) {
                var selector = this.selectorBtns,
                    buttons = selector && selector.childNodes;

                // Do we have buttons to update?
                if (buttons) {
                    // Update classes on buttons.
                    $CSS.addClass(buttons[evt.value], 'on');
                    $CSS.removeClass(buttons[evt.valueWas], 'on');
                }
            },

            /**
             * Changes the visibility of the child panels based on the selected key.
             *
             * @param {String} evt.value The key of the newly selected panel.
             */
            onselectedKeyChange: function onselKeyChg(evt) {

                this._super(evt);

                // Calculate the new position for the panels.
                var width = this._pnlWidth,
                    position = this.selectedIdx * width;

                // Is this a windows phone?
                if ($DOM.isWinPhone) {
                    // Change container node position to relative.
                    var containerNode = this.containerNode;
                    containerNode.style.position = 'relative';

                    // Animate transition.
                    (new mstrmojo.fx.AnimateProp({
                        props: {
                            left: {
                                isStyle: true,
                                start: position,
                                stop: this.prevSelectIdx * width,
                                suffix: 'px',
                                ease: mstrmojo.ease.linear
                            }
                        },
                        duration: 0,
                        target: containerNode
                    })).play();

                } else {
                    // Apply the transform with no duration (for performance).
                    applyTransform.call(this, 0, position);
                }

                // Update the scroller so the origin is synchronized (passing true so we don't scroll to the origin again).
                this.updateScroller(true);
            },

            touchBegin: function touchBegin(touch) {
                // Are we animating?
                if (this._isAnimating) {
                    // Stop the touch event...
                    touch.stop();

//                    if (debug) {
//                        console.log(this.k + ' IS animating - touch ' + touch.id + ' stopped');
//                    }

                    // and ignore all touches until done.
                    return false;
                }

                // Does the panel stack NOT support swipe changes AND is the target of the touch NOT the panel stack selector?
                if (!this.defn.sw && !$DOM.contains(this.selector, touch.target, true, this.domNode)) {
                    // Return false to ignore touch.
                    return false;
                }

//                if (debug) {
//                    console.log(this.k + ' IS NOT animating - touch ' + touch.id + ' proceeds');
//                }

                return this._super(touch);
            },

            touchTap: function touchTap(touch) {
                var target = touch.target,
                    domNode = this.domNode;

                // Did the tap occur within the selector node?
                if ($DOM.contains(this.selector, target, true, domNode)) {
                    var selectorBtnsNode = this.selectorBtns,
                        panelIdx = -1;

                    // Did the tap occur with the selector button node?
                    if ($DOM.contains(selectorBtnsNode, target, true, domNode)) {
                        // Use the target idx attribute value to find panel.
                        panelIdx = $DOM.findAncestorByAttr(target, 'idx', true, selectorBtnsNode).value;
                    } else {
                        // Calculate target panel index by position clicked on the selector.
                        panelIdx = this.selectedIdx + ((touch.clientX - domNode.offsetLeft < (this._pnlWidth / 2)) ? -1 : 1);
                    }

                    // Did we find a panel index?
                    if (panelIdx > -1) {
                        // Is there a panel at that index (may not be if the user didn't click a button and there are no more panels in that direction).
                        var panel = this.children[panelIdx];
                        if (panel) {
                            // Select the target panel.
                            this.selectPanel(panel.k);
                        }
                    }
                } else {
                    // Does the controller have a viewTap method?
                    var ctrl = this.controller;
                    if (ctrl && ctrl.viewTap) {
                        // Call it.
                        ctrl.viewTap();
                    }
                }
            },

            touchSwipeBegin: function touchSwipeBegin(touch) {
//                if (debug) {
//                    console.log(this.k + ': Swipe Begin id ' + touch.id);
//                }

                // Does the panel stack support swipe changes OR is the target of the swipe the panel stack selector?
                if (this.defn.sw || $DOM.contains(this.selector, touch.target, true, this.domNode)) {
                    return this._super(touch);
                }

                // Bubble the event and return (since we won't handle it).
                return this.bubbleTouchEvent(touch);
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                // Mark the event as handled so the touchEnd event used can be ignored by other components.
                touch.evt.handled = true;

                // Make sure the scroll indicators are not visible.
                mstrmojo.TouchScroller.ScrollIndicators.hideAll();

                var x = this._translateX || 0,
                    width = this._pnlWidth,
                    offset = this._scroller.offset.x,                                           // Cached in touchSwipeBegin so we know the limits of the swipe.
                    position = $M.max($M.min(x - touch.delta.x, offset.end), offset.start),     // Calculate the new position (limited by offsets).
                    delta = x - position,                                                       // Distance of the swipe (could be negative).
                    absDelta = $M.abs(delta),                                                   // Absolute distance of swipe.
                    duration = SWITCH_DURATION,
                    isRevertAction = (absDelta < width * 0.2);

                // Did the swipe move less than 20% of the width?
                if (isRevertAction) {
                    // Reset to old position.
                    position = x;
                    duration *= absDelta / width;
                } else {
                    // Calculate new position based on direction of swipe.
                    position = x + ((delta < 0) ? width : -width);
                    duration *= (width - absDelta) / width;
                }

//                if (debug) {
//                    console.log(this.k + ': Swipe End at position ' + position + ' id ' + touch.id);
//                }

                // Move the panels manually because we want it faster than it happens by default.
                applyTransform.call(this, $M.round(duration), position, true, isRevertAction);
                // Select the new panel.
                this.selectPanel(this.children[position / width].k, true);
            }
        }
    );

}());
(function(){

	mstrmojo.requiresCls("mstrmojo.Container",
						 "mstrmojo._HasScrollbox",
						 "mstrmojo._HasLayout",
						 "mstrmojo._ShowsStatus");
	

	function getDimension(dimension) {
	    var domNode = this.domNode,
	    x = parseInt(this[dimension.toLowerCase()], 10);

	    return (isNaN(x)) ? domNode['offset' + dimension] : x;
	}	
	
	/**
	 * The widget for the MicroStrategy Report Services Layout Viewer.
	 * 
	 * @class
	 * @extends mstrmojo.Container
	 * 
	 * @borrows mstrmojo._HasScrollbox#scrollListeners as #scrollListeners
	 * @borrows mstrmojo._HasScrollbox#scrollListenerCount as #scrollListenerCount
	 * @borrows mstrmojo._HasScrollbox#connectScrollbox as #connectScrollbox
	 * @borrows mstrmojo._HasScrollbox#disconnectScrollbox as #disconnectScrollbox
	 * @borrows mstrmojo._HasScrollbox#notifyScrollListeners as #notifyScrollListeners
	 * @borrows mstrmojo._HasScrollbox#scrollInterval as #scrollInterval
	 * @borrows mstrmojo._HasScrollbox#scrollboxTop as #scrollboxTop
	 * @borrows mstrmojo._HasScrollbox#scrollboxLeft as #scrollboxLeft
	 * @borrows mstrmojo._HasScrollbox#scrollboxHeight as #scrollboxHeight
	 * @borrows mstrmojo._HasScrollbox#scrollboxBottom as #scrollboxBottom
	 *
	 * @borrows mstrmojo._HasLayout#height as #height
	 * @borrows mstrmojo._HasLayout#width as #width
	 * @borrows mstrmojo._HasLayout#layoutConfig as #layoutConfig
	 * @borrows mstrmojo._HasLayout#onwidthChange as #onwidthChange
	 * @borrows mstrmojo._HasLayout#onheightChange as #onheightChange
	 * @borrows mstrmojo._HasLayout#setSlotDimension as #setSlotDimension
	 */
	mstrmojo.DocLayoutViewer = mstrmojo.declare(
		// superclass
		mstrmojo.Container,
		
		// mixins,
		[mstrmojo._Formattable, mstrmojo._HasScrollbox, mstrmojo._HasLayout, mstrmojo._ShowsStatus],
		
		/**
		 * @lends mstrmojo.DocLayoutViewer.prototype
		 */
		{
			scriptClass: "mstrmojo.DocLayoutViewer",
			
			markupString: '<div id="{@id}" class="mstrmojo-DocLayoutViewer {@cssClass}" style="{@domNodeCssText}">' +
							'<div></div>' +
							'<div>' +
								'<div class="mstrmojo-progress" style="display:none">' +
									'<div class="mstrmojo-progress-barbg">' +
										'<div class="mstrmojo-progress-bar"></div>' +
									'</div>' +
									'<div class="mstrmojo-progress-text"></div>' +
								'</div>' +
								'<div id="{@id}_fh"></div>' + // fixed header
								'<div id="{@id}_scrollboxNode" class="mstrmojo-DocLayoutViewer-layout" style="{@_scrollCssText}"></div>' +
								'<div id="{@id}_ff"></div>' + // fixed footer
							'</div>' +
							'<div></div>' +
						  '</div>',
						
			markupMethods: {
				onvisibleChange: function(){ this.domNode.style.display = this.visible ? 'block' : 'none'; },
				onborderChange: function(){ if (this.border) { this.domNode.style.border = this.border; }}
			},
			
			markupSlots: {
				groupBy: function(){ return this.domNode.firstChild; },
				layout: function() { return this.domNode.childNodes[1].childNodes[2]; },
				scrollboxNode: function() { return this.domNode.childNodes[1].childNodes[2]; },
				containerNode: function() { return this.domNode.childNodes[1].childNodes[2]; },
				incFetchNode: function() { return this.domNode.lastChild; },
				fixedHeaderNode: function() {return this.domNode.childNodes[1].childNodes[1]; },
				fixedFooterNode: function() {return this.domNode.childNodes[1].childNodes[3]; },
				
				_STATUS: function(){ return this.domNode.childNodes[1].firstChild; },
				_STATUS_TXT: function(){ return this.domNode.childNodes[1].firstChild.lastChild; },
				_STATUS_BAR: function(){ return this.domNode.childNodes[1].firstChild.firstChild.firstChild; }
			},
			
			layoutConfig: {
				h: {
					groupBy: 'auto',
					fixedHeaderNode: 'auto',
					layout: '100%',
					fixedFooterNode: 'auto',
					incFetchNode: 'auto'
				},
				w: {
					layout: '100%'
				}
			},

			// These values are always fixed.
			scrollboxHeightFixed: true,
			scrollboxWidthFixed: true,
			
			//We are trying to retrieve a cached value in order to improve performance
			getHeight: function getHeight() {
			    return getDimension.call(this, 'Height');
			},

			//We are trying to retrieve a cached value in order to improve performance
			getWidth: function getWidth() {
			    return getDimension.call(this, 'Width');
			},   
            
			/**
			 * Custom handler to incrementally render after a layout has taken place.
			 * 
			 * @ignore
			 */
			afterLayout: function afterLayout() {
				this._super();

				// Notify the scroll listeners to start rendering.
				this.notifyScrollListeners();
			},
			
			preBuildRendering: function preBuildRendering() {
				// We need to manually extract the height and width from the parent slot because the DocLayoutViewer is added to the Doc after 
				// the Doc has rendered so _HasLayout did not get a chance to do this for us.
				// Check for parent to handle cases where we are rendering a layout outside of the document (e.g. map info windows)
				if ( this.parent ) {
					var p = this.parent[this.slot].style,
						h = this.height,
						w = this.width;
					
					this.height = (h !== 'auto') ? h : p.height;
					this.width = (w !== 'auto') ? w : p.width;
				}
				
				// set Zoom factor
				this.zf = this.model.zf;
				this.bs = this.model.bs;
				
				// adjust height and min-height on DocLayout, since we pulled fixed headers and footers out, we need to adjust DocLayout's height to deduct those heights
//				var ch = this.children,
//					i,
//					layout = null,
//					fixSecHeight = 0;
//				for (i = 0; i < ch.length; i ++) {
//					var c = ch[i];
//					if (c.slot === 'fixedHeaderNode' || c.slot === 'fixedFooterNode') {
//						fixSecHeight += (c.height && c.height()) || 0;
//					} else if (c.slot === 'layout') {
//						layout = c; // cache for later to adjust its heights
//					}
//				}
//				// we need to adjust heights
//				if (fixSecHeight && layout) {
//					var fmts = layout.defn.fmts;
//					if (fmts.height && !fmts.orgHeight) {
//						fmts.orgHeight = fmts.height;
//						fmts.height = Math.max(parseInt(fmts.height, 10) - fixSecHeight, 0) + 'px;';
//					}
//					if (fmts['min-height'] && !fmts.orgMinHeight) {
//						fmts.orgMinHeight = fmts['min-height'];
//						fmts['min-height'] = Math.max(parseInt(fmts['min-height'], 10) - fixSecHeight, 0) + 'px;';
//					}
//					if (layout.minHeight && layout.orgMinHeight){
//						layout.node.data.orgMh = layout.node.data.mh;
//						layout.orgMinHeight = layout.minHeight;
//						layout.minHeight = layout.node.data.mh = Math.max(node.data.mh - fixSecHeight, 0);
//					}
//				}

				
				return this._super ? this._super() : true;
			},
			setSlotDimensions: function setSlotDimensions(slot, h, w) {
				// Is this the layout slot?
				if (slot === 'layout') {
					// Cache the height and width for use by the _CanRenderDocOnScroll mixin.
					// NOTE: theoretically, h or w could be undefined, but in the case of a doc layout viewer that should never happen,
					// so we don't need to test for undefined.
					this.scrollboxHeight = parseInt(h, 10);
					this.scrollboxWidth = parseInt(w, 10);
				}
				
				this._super(slot, h, w);
			}, 
			
			onaddChild: function onaddChild(evt) {
				if (!isNaN(evt.index)) {
					var nc = this.children[evt.index];
					if (nc && nc.slot === "groupBy") {
						this.docGroupBy = nc;
					}
				}
			}
		}
	);
	
}());
(function(){


    mstrmojo.requiresCls("mstrmojo._HasBuilder",
                         "mstrmojo._HasLayout",
                         "mstrmojo.Container");

    var DARK_BORDER_WIDTH = 1;

    mstrmojo.maps.jsmap.AndroidDocMapInfoWindow = mstrmojo.declare(
        // superclass
        mstrmojo.Container,
        
        // mixins,
        [ mstrmojo._HasBuilder, mstrmojo._HasLayout ],
        
        // instance props+methods
        {
            scriptClass: "mstrmojo.maps.jsmap.AndroidDocMapInfoWindow",
            
            markupString: '<div class="mstrmojo-DocInfoWindow-wrapper">' +
                              '<div id="{@id}" class="mstrmojo-DocInfoWindow"></div>' +
                          '</div>',

            markupSlots: {
                infoNode: function() { return this.domNode.firstChild; },
                containerNode: function() { return this.domNode.firstChild; }
            },
                        
            getChildren: function getChildren(){
                
                var m = this.model,
                    c = m.getLayoutDataCache(m.getCurrentLayoutKey())[this.psId],
                    f = c.defn.fmts;
                
                // Override positioning format of child.
                f.left = DARK_BORDER_WIDTH + 'px';
                f.top = DARK_BORDER_WIDTH + 'px';
                
                return [c];
            }
        });

}());
/*global mstrmojo:false, window:false */

(function(){

    mstrmojo.requiresCls(
        "mstrmojo.Container",
        "mstrmojo._HasBuilder",
        "mstrmojo._Formattable",
        "mstrmojo._HasToolbar");
    
    var ELEM_SEP = "\u001E";
    
    var GD = 1;
    var GP = 2;
    
    /**
     * Helper object for repositioning children of the Grid/Graph object.
     * 
     * @class
     * @private
     * @ignore
     */
    var ggHelper = {
            
        TOP: 0,
        
        BOTTOM: 1,
        
        LEFT: 2,
        
        RIGHT: 3,
        
        vert: [ 'height', 'width', 'top' ],
        
        horiz: [ 'width', 'height', 'left' ],
        
        updateStyle: function (gg) {
            var qsm = gg.defn.qsm;
            if (!qsm) {
                return;
            }
            if (gg.getFormats().width) {
                return;
            }
            var child = null;
            if (qsm == GD) {
                child = gg.containerNode.firstChild; // grid node
            }
            else {
                child = gg.containerNode.lastChild; // graph node
            }
            if(!child){
                return;
            }
            var h = child.clientHeight + 'px';
            var w = child.clientWidth + 'px';
            
            var dnStyle = gg.domNode.style;
            dnStyle.height = h;
            dnStyle.width = w;
            
            if (gg.parent.updateStyle){
                gg.parent.updateStyle(h, w);
            }

        },
        
        repositionChildren: function (gg) {
        
            var f = gg.getFormats(),
                h = parseInt(f.height, 10),                                 // Unit height.
                w = parseInt(f.width, 10);                                    // Unit width.
        
            var ch = gg.children,
                gdf = ch[0].getFormats(),    // The format node for the grid (always index 0).
                gpf = ch[1].getFormats();    // The format node for the graph (always index 1).
            
            var isVert = (gg.defn.gp < this.LEFT),    // Is vertical orientation?
                x = (isVert) ? h : w,
                y = (isVert) ? w : h,
                dd = this[((isVert) ? 'vert' : 'horiz')];
            
            // Calculate the actual size devoted to the grid component as the RWUnit size times the percentage of grid area. 
            var gs = Math.round(x * (gg.defn.ga / 100));
            
            // Set dimensions of the grid.
            gdf[dd[0]] = gs + 'px';    // Grid size
            gdf[dd[1]] = y + 'px';    // Unit size
            
            // Set dimensions of the graph.
            gpf[dd[0]] = (x - gs) + 'px';     // Unit size minus grid size
            gpf[dd[1]] = y + 'px';            // Unit size.
            
            // Is the grid position top or left?
            if ((gg.defn.gp % 2) === 0) {
                // Set the top/left of the graph to the grid size.
                gpf[dd[2]] = gs + 'px';
            } else {
                // set the top/left of the grid to the Unit size minus grid size.
                gdf[dd[2]] = (x - gs) + 'px';
            }
            this.resizeChildren(ch[0], ch[1]);
        },
        stackChildren: function(gg) {
            var ch = gg.children,
            f = gg.getFormats(),
            gf;
            
            for (var i = ch.length - 1; i >= 0; i --){
              gf = ch[i].getFormats();
              gf.width = f.width;
              gf.height = f.height;
            }
            this.resizeChildren(ch[0], ch[1]);
        },
        resizeChildren: function(gd, gp) {
            // Remove and then render the grid again.
            gd.renderPortalState();

            // Resize the graph.
            var gpf = gp.getFormats();
            gp.resizeForDisplayState(parseInt(gpf.height, 10), parseInt(gpf.width, 10), true);
        },
        // show/hide GridGraph
        // TODO Question: quick switch mode?
        // TODO check with GB/Mark is it better to use onvisiblechange()?
        changeVisibility: function(gg, show) {
            var cd = gg.children,
                qsm = gg.defn.qsm,
                gds = show && (!qsm || gg.viewMode === GD),
                gps = show && (!qsm || gg.viewMode === GP);
            
            if(cd && cd.length > 0) {
                if (cd[0].visible !== gds) {
                    cd[0].set('visible', gds);
                }
                if (cd[1].visible !== gps){
                    cd[1].set('visible', gps);
                }
            }
            gg.visible = show;
        },
        
        // Set the visibility of the grid or graph
        setViewMode: function setViewMode(gg) {
            var cd = gg.children,
                vs = gg.visible;
            
            if(gg.defn.qsm && cd && cd.length > 0) {
                var ggm = gg.viewMode;
                cd[0].set('visible', (ggm == GD) && vs );
                cd[1].set('visible', (ggm == GP) && vs);
            }
        },
        
        clearFormatCache: function clearFormatCache(gg) {
            var cd = gg.children;
            for (var i = 0, len = cd && cd.length || 0; i < len; i ++) {
                cd[i].clearCache();
            }
        }
        
    };
    
    /**
     * <p>The widget for a single MicroStrategy Report Services Grid and Graph control.</p>
     * 
     * @class
     * @extends mstrmojo.Container
     * 
     * @borrows mstrmojo._Formattable#formatHandlers as #formatHandlers
     * @borrows mstrmojo._Formattable#getFormats as #getFormats
     * @borrows mstrmojo._IsSelectorTarget#setDirty as #setDirty
     */
    mstrmojo.DocGridGraph = mstrmojo.declare(
        // superclass
        mstrmojo.Container,
        
        // mixins,
        [ mstrmojo._HasBuilder, mstrmojo._Formattable, mstrmojo._IsSelectorTarget],
        
        /** 
         * @lends mstrmojo.DocGridGraph.prototype
         */
        {
            scriptClass: "mstrmojo.DocGridGraph",
            
            markupString: '<div id="{@id}" title="{@tooltip}" class="mstrmojo-DocGridGraph" style="{@domNodeCssText}">' +
                            '<div class="mstrmojo-DocGridGraph-msg"></div>' +
                            '<div class="mstrmojo-DocGridGraph-container"></div>' +
                          '</div>',
                        
            markupSlots: {
                msgNode: function(){ return this.domNode.firstChild; },
                containerNode: function(){ return this.domNode.lastChild; }
            },
            
            formatHandlers: {
                // note - we need 'font' for Zoom feature. 
                domNode: [ 'RW', 'B', 'background-color', 'fx', 'font' ]
            },
            
            /**
             * Grid (1) or graph (2) displayed
             */
            viewMode: null,
            /**
             * Whether this container is visible. When it is minimized, it is not visible.
             */
            visible: true,
            
            resize: function resize() {
                // Clear the format from cache
                this.clearCache();                
                // clear children cache
                ggHelper.clearFormatCache(this);
                var f = this.getFormats(),
                w = parseInt(f.width,10),
                h = parseInt(f.height,10);
                
                if (w > 0 && h > 0) {
                    ggHelper.changeVisibility(this, true);
                    // If it is quick switch mode, will not do reposition
                    if (!this.defn.qsm) {
                        ggHelper.repositionChildren(this);
                    } else {
                        ggHelper.stackChildren(this);
                    }
                }else {
                    // since portlet will not have overflow: hidden, we need to hide grid/graph
                    ggHelper.changeVisibility(this, false);
                }
            },
            
            postBuildRendering: function postBuildRendering() {
                this._super();
                
                var eg = this.node.data.eg;
                if (eg === undefined) {
                    // hide the msgNode
                    this.msgNode.style.display = "none";
                    // render grid normally
                    this.containerNode.style.display = "block";
                } else {
                    this.msgNode.innerHTML = eg;
                    this.msgNode.style.display = "block";
                    this.containerNode.style.display = "none";
                }
                
                // Set the view mode value
                var qsm = this.defn.qsm;
                if(!this.viewMode && qsm) {
                    this.viewMode = qsm;
                }
                
                //Grab the node definition... 
                var d = this.node.defn;
                
                // ...and attach an event listener for qsm (Quick Switch Mode) change. Since multiple instances of the same grid
                // share the same definition object, they all listen to this event. Furthermore, since different grids have different 
                // definition objects, the event is not broadcasted to all grids on the page. 
                d.attachEventListener("qsmChange", this.id, function (evt){
                    // Flip the current view mode.
                    this.viewMode = evt.value;
                    
                    // set the view mode.
                    ggHelper.setViewMode(this);
                    
                    // Silently calls quick switch task to save the display mode
                    this.model.getDataService().setQuickSwitchViewMode(this.defn.tt + ELEM_SEP + this.k, this.viewMode);
                    
                    ggHelper.updateStyle(this);
                });

                ggHelper.setViewMode(this);
                ggHelper.updateStyle(this);
                
                // #522647 call to resize so that the size display properly. #608910 if qsm is enabled don't call resize
                if(!qsm) {
                    this.resize();
                }
            },

            getGridWidget: function() {
                return this.children[0];
            },
            
            getGraphWidget: function() {
                return this.children[1];
            },
            
            /**
             * Update and refresh graph object
             * @param {Object} node New node date
             */
            updateGraph: function(node) {
                var gp = this.getGraphWidget();
                
                if(gp) {
                    gp.update(node);
                    gp.refresh();
                }
            },
                                    
            quickSwitch: function quickSwitch() {
                // Is current view mode grid?
                var gd = this.viewMode != GP;                
                
                // update qsm on definition
                this.defn.set('qsm', (gd ? GP : GD));
                
                return true;
            }
        }
    );
    
})();
(function() {
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.Container", "mstrmojo._IsPopup", "mstrmojo.boxmodel", "mstrmojo.css");

    var _B = mstrmojo.boxmodel,
    _D = mstrmojo.dom,
    _CURSOR_HEGIHT = 20;
    /**
     * Attach listener to opener's parent's scroll event
     */
    function attScrll(o, me) {
        var p = o && o.parent;
        while (p){
            if (p.connectScrollbox){
                p.connectScrollbox(me);
            }
            p = p.parent;
        }
    }
    /**
     * Detach listener to opener's parent's scroll event
     */
    function detScrll(o, me) {
        var p = o && o.parent;
        while (p){
            if (p.disconnectScrollbox){
                p.disconnectScrollbox(me);
            }
            p = p.parent;
        }
    }
    /**
     * Positions the tooltip to desired location.
     * 
     * @param me {mstrmojo.Tooltip} The tooltip to be positioned
     * @param offset {Object} offset has property 'top' and 'left', which is the offset of the reference point in document coordinate. 
     *                 The tooltip's 'top' and 'left' are offsets from reference point.
     * @private
     * @ignore
     */
    var _position = function(me){
        // if tooltip is not visible, we do not need to position it.
        if (me.visible) {
            // update position
            // x and y in event refers to a certain node, we need to calculate the offset corresponding to document
            var ref = me.refNode,
                // if we have reference node, we need to calculate the offset in document
                // if we do not have a reference node, then the left/top are from event, 
                // which is in window coordinate, so we need to calculate the scroll offset
                offset = ref ? _B.offset(ref, document.body) : {
                                                                left: _D.getHorizontalScroll(),
                                                                top: _D.getVerticalScroll()
                                                            },
            s = me.domNode.style, 
            c = me.containerNode,
            l = me.left,
            t = me.top,
            p = me.posType,
            T = mstrmojo.tooltip,
            p_r = (p === T.POS_TOPRIGHT) || (p === T.POS_BOTTOMRIGHT), 
            p_b = (p === T.POS_BOTTOMLEFT) || (p === T.POS_BOTTOMRIGHT) || (p === T.POS_BOTTOMCENTER), 
            offLeft = offset.left,
            offTop = offset.top,
            containerOffWidth = c.offsetWidth;
                                                            
            if (l !== null) {
                
                s.left = Math.max(parseInt(l, 10) + offLeft - (p_r ? (containerOffWidth):
                                                                     ((p===T.POS_BOTTOMCENTER) ? (containerOffWidth / 2) : 0))
                                   , 0) + 'px';                
            }
            if (t !== null){
                
                s.top = Math.max(parseInt(t, 10) + offTop - ((p_b)? (c.offsetHeight):0), 0) + 'px';
            }
        }
    };

    var _repaint = function(me) {
        me.containerNode.className = ('mstrmojo-Tooltip-content ' + me.contentNodeCssClass);
        me.containerNode.style.cssText = me.contentNodeCssText;
        me.containerNode.innerHTML = me.content;
        if (!me.content) {
            me.set('_tempVis', false);
        } else {
            me.set('_tempVis', true);
        }
        _position(me);
        if (me.optimizePos) {
        	// TQMS 762074: has multiple tooltips, need to optimize their positions.
        	me.optimizePos();
        }
    };

    /**
     * Calling _position() with delay.
     */
    function _dlyPaint(me) {
        if (!me._dp){
            me._dp = window.setTimeout(function() {
                me._dp = null;
                _repaint(me);
            }, 50);
        }
    }
    /**
     * Updates current tooltip properties based on opener's properties
     */
    var _update = function(me, w, e, win) {
        // update
        var r = w && (w.richTooltip || w.tooltip),
            mp = e ? _D.getMousePosition(e, win || self) : null,
            isStr = r && (typeof(r) === 'string'),
            l = isStr ? null : (r && r.left || 0),
            t = isStr? null: (r && r.top || 0);
        me.set('contentNodeCssClass', isStr ? '' : (r && r.contentNodeCssClass || ''));
        me.set('contentNodeCssText', isStr ? '' : (r && r.contentNodeCssText || ''));
        me.set('content', (isStr) ? r : (r && r.content || ''));
        me.set('refNode', isStr ? null : r && r.refNode || null);
        me.set('posType', isStr ? 1: r && r.posType || 1);
        me.set('left', (isStr || l === undefined || l === null) ? (mp && mp.x || me.left) : l);
        me.set('top', (isStr || r === undefined || r === null) ? (mp && (mp.y + _CURSOR_HEGIHT) || me.top): t);        // vertical offset is cursor position + cursor height (20px)
    };
    /**
     * This is the tooltip popup to show customized tooltip.
     */
    mstrmojo.Tooltip = mstrmojo.declare(
            mstrmojo.Container,
            [mstrmojo._IsPopup],
            {
                scriptClass: 'mstrmojo.Tooltip',
                /**
                 * Tooltip content
                 */
                content: null,
                /**
                 * Top position of the tooltip. 
                 * 
                 * The final position of the tooltip is decided by (top,left) x refNode x posType.
                 */
                top: null,
                /**
                 * Left position of the tooltip.
                 * 
                 * The final position of the tooltip is decided by (top,left) x refNode x posType.
                 */
                left: null,
                /**
                 * The reference node for top/left. If refNode is null, then left/top is corresponding to window.
                 */
                refNode: null,
                /**
                 * The corner of the tooltip is positioned. 
                 * mstrmojo.tooltip.POS_TOPLEFT: the top left corner of the tooltip would be positioned according to the offset (top, left) of refNode.
                 *                     (top,left)
                 *                         o-----------
                 *                      |  tooltip |
                 *                      ------------
                 *                        --------------------
                 *                        |                  |
                 *                        |    RefNode       |
                 *                        --------------------
                 * mstrmojo.tooltip.POS_BOTTOMLEFT: the bottom left corner of the tooltip would be positioned according to the offset (top, left) of refNode.
                 *                         ------------
                 *                      |  tooltip |
                 *                      o-----------
                 *                  (top,left)
                 *                  
                 *                        
                 *                        --------------------
                 *                        |                  |
                 *                        |    RefNode       |
                 *                        --------------------
                 * mstrmojo.tooltip.POS_TOPRIGHT: the top right corner of the tooltip would be positioned according to the offset (top, left) of refNode.
                 *                     (top,left)
                 *              -----------o
                 *           |  tooltip |
                 *           ------------
                 *                        --------------------
                 *                        |                  |
                 *                        |    RefNode       |
                 *                        --------------------
                 * mstrmojo.tooltip.POS_BOTTOMRIGHT: the bottom right corner of the tooltip would be positioned according to the offset (top, left) of refNode.
                 *           ------------
                 *           |  tooltip |
                 *              -----------o
                 *                     (top,left)
                 * 
                 * 
                 *                        --------------------
                 *                        |                  |
                 *                        |    RefNode       |
                 *                        --------------------
                 * Default value is mstrmojo.tooltip.POS_TOPLEFT.
                 *                        
                 */
                posType: 1, 
                /**
                 * Tooltip popup markup string.
                 * 
                 * @ignore
                 */
                markupString: '<div id="{@id}" class="mstrmojo-Tooltip {@cssClass}" style="{@cssText}">' +
                                '<div class="mstrmojo-Tooltip-shadow {@shadowNodeCssClass}"></div>' + 
                                '<div class="mstrmojo-Tooltip-content {@contentNodeCssClass}" style="{@contentNodeCssText}"></div>' +
                              '</div>',
                /**
                 * Markup slots.
                 * 
                 * @ignore
                 */
                markupSlots: {
                    containerNode: function(){ return this.domNode.lastChild; },
                    shadowNode: function() { return this.domNode.firstChild; }
                },
                /**
                 * Markup methods.
                 * 
                 * @ignore
                 */
                markupMethods: {
                    onvisibleChange: function(){ 
                        if (this.visible){
                            // since some of the positioning part relate to measuring, we may need to do it before tooltip visible.
                            var s = this.domNode.style;
                            s.visibility = 'hidden';
                            s.display = 'block';
                            // now even the tooltip can not be seen by user, we can measure it now
                            _position(this);
                            s.visibility = this.content? 'visible' : 'hidden';
                        } else {
                            this.domNode.style.display = 'none'; 
                        }
                    },
                    on_tempVisChange: function() {
                        this.domNode.style.visibility = this._tempVis ? 'visible' : 'hidden'; 
                    },
                    onleftChange: function(){ _dlyPaint(this); },
                    ontopChange: function(){ _dlyPaint(this); },
                    onrefNodeChange: function() {_dlyPaint(this); },
                    onposTypeChange: function() {_dlyPaint(this); },
                    oncontentNodeCssClassChange: function (){_dlyPaint(this);},
                    oncontentNodeCssTextChange: function() {_dlyPaint(this);},
                    oncontentChange: function() {_dlyPaint(this);}
                },
                /**
                 * If there is no parent node assigned for this tooltip, we need to append it to the document body node.
                 * 
                 * @ignore
                 */
                preBuildRendering: function() {
                    // if no slot or placeholder is assigned, create the placeholder under the body node.
                    if (!this.slot && !this.placeholder) {
                        this.placeholder = document.body.appendChild(document.createElement('div'));
                    }
                    if (this._super) {
                        this._super();
                    }
                },
                _on_tooltip_change: function(evt){
                    _update(this, evt && evt.src);
                },
                /**
                 * Custom setter for 'opener' property. 
                 * 
                 * Since we are going to share the same tooltip instance with different widget, each time when this tooltip associates with a new widget,
                 * we need to perform some cleanup with previous widget and set up some listeners with the new widget.
                 */
                _set_opener: function(n, v) {
                    var ov = this.opener;
                    // if new opener is different from previous opener, 
                    // 1. we need to attach event listeners for scrolling to the new opener
                    // at the same time detach event listeners for scrolling from previous opener
                    // 2. we need to listen to any change of opener's richTooltip and tooltip
                    if ((v !== ov)){
                        if (v) {
                            attScrll(v, this);
                        }
                        if (ov) {
                            detScrll(ov, this);
                        }                        
                        if (ov && ov.detachEventListener) {
                            ov.detachEventListener(this._richSubs);
                            ov.detachEventListener(this._ttpSubs);
                        }
                        if (v && v.attachEventListener) {
                            this._richSubs = v.attachEventListener('richTooltipChange', this.id, '_on_tooltip_change');
                            this._ttpSubs = v.attachEventListener('tooltipChange', this.id, '_on_tooltip_change');
                        }
                        this.opener = v;
                        return true;
                    }
                    return false;
                },
                /**
                 * Updates config for Popup rendering.
                 */
                updatePopupConfig: function(config, opener){
                    _update(this, opener, config && config.e, config && config.win);
                },
                /**
                 * Event handler for scroll event generated from any ancestor of opener.
                 * When any ancestor of opener is scrolled, we need to reposition tooltip. 
                 */
                onscroll: function() {
                    //421475
                    if (this.visible && this.nudge) {
                        this.nudge();
                    }
                }
            }
    );

    // singleton for tooltip widget
    var ttpInst = null;
    mstrmojo.tooltip = {
            // constants
            POS_TOPLEFT: 1,
            POS_BOTTOMLEFT: 2,
            POS_TOPRIGHT: 3,
            POS_BOTTOMRIGHT: 4,
            POS_BOTTOMCENTER: 5,
            /**
             * Asks tooltip singleton to show the tooltip
             */
            open: function(opener, e, win, config) {
                //Create a new tooltip object if either we haven't created the object.
                //OR if the tooltip object has been destroyed...
                if (!ttpInst || !mstrmojo.all[ttpInst.id]) {
                    ttpInst = new mstrmojo.Tooltip();
                }
                
                if (!config) {
                    config = {};
                }
                config.e = e;
                config.win = win;
               ttpInst.open(opener, config);
            },
            /**
             * Asks tooltip singleton to hide the tooltip
             */
            close: function() {
                if (ttpInst) {
                    ttpInst.close();
                }
            }
    };
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable");

    mstrmojo.DocImage = mstrmojo.declare(
        // superclass
        mstrmojo.Container,

        // mixins,
        [mstrmojo._Formattable],

        // instance props+methods
        {
            scriptClass: "mstrmojo.DocImage",

            markupString: '<div id="{@id}" class="mstrmojo-DocImage" title="{@tooltip}" style="{@domNodeCssText}">' +
                                '<div style="{@shadowNodeCssText}"><img src="{@v}" style="{@imgNodeCssText}" mstrAttach:click></div>' +
                                '{@buttonNodeMarkup}' +
                          '</div>',

            markupSlots: {
                imgNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
            	onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },	

            /**
             * Updates the DocImage data that may change due to a selector action.
             *
             * @param {Object} node The widget node.
             */
            update: function update(node) {
                var ds = this.model.getDataService(),
                    v = node.data.v;

                this.v = (ds && ds.getDocImage && ds.getDocImage(v)) || v;

                // if there is a threshold, kill the format
                if (this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }

                this.thresholdId = node.data.tid;
                this.set('visible', !node.data.hidden);

                //TQMS 724924 and 740560
                if (this._super) {
                    this._super(node);
                }
            },

            formatHandlers: {
                domNode: ['left', 'top', 'z-index' ],
                shadowNode: ['width', 'height', 'B', 'fx' ],
                imgNode: [ 'height', 'width' ]
            },

            preBuildRendering: function preBuildRendering() {
                if (this._super) {
                    this._super();
                }

                // make the domNode dimension enough to contain the image/border/dropshadow - only IE7 does NOT need this.
                if (!mstrmojo.dom.isIE7) {
                    var fmt = this.getFormats(),
                        ds = (fmt.fx && fmt.fx.ds) || 0,  //dropshadow size
                        border = mstrmojo._Formattable.getBorderWidths(this);

                    this.domNodeCssText += 'width:' + ((parseInt(fmt.width, 10) || 0) + ds + border.w) + 'px;' + ' height: ' +  ((parseInt(fmt.height, 10) || 0) + ds + border.h) + 'px;';
                }
            },
            
            getAnchor: function getAnchor() {
            	return this.imgNode;
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._IsPopup",
                         "mstrmojo._CanAutoClose");

    /**
     * Popup is a Container that is also a popup and can autoHide.
     */
    mstrmojo.Popup = mstrmojo.declare(
        // superclass
        mstrmojo.Container,
        // mixins
        [mstrmojo._IsPopup, mstrmojo._CanAutoClose],
        // instance members
        {
            scriptClass: "mstrmojo.Popup",

            shadowNodeCssClass: "mstrmojo-popup-shadow",

            contentNodeCssClass: "mstrmojo-popup-content",

            cssDisplay : "block",

            markupString: '<div id="{@id}" class="mstrmojo-Popup {@cssClass}" style="{@cssText}" '
                + '><div class="mstrmojo-Popup-shadow {@shadowNodeCssClass}"></div><div class="mstrmojo-Popup-content {@contentNodeCssClass}"></div>',

            markupSlots: {
                containerNode: function () { return this.domNode.lastChild; },
                shadowNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? this.cssDisplay : 'none'; },
                onleftChange: function () { this.domNode.style.left = (this.left != null) ? this.left : ''; },
                ontopChange: function () { this.domNode.style.top = (this.top != null) ? this.top : ''; }
            },
            
            /**
             * Override build rendering to add support to mstrmojo.Popup to open by itself.
             * 
             */
            buildRendering: function buildRendering() {
                // Get a reference to the placeholder (since it will be blown away in the _super).
                var ph = this.placeholder;

                // Call super.
                if (this._super()) {
                    // Do we not have a parent and did we not have a placeholder?
                    if (!this.parent && !ph) {
                        var node = this.placeNode || document.body;

                        // Insert the domNode as a child of the body tag.
                        node.appendChild(this.domNode);
                    }
                    return true;
                }

                return false;
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.Container",
        "mstrmojo._Formattable",
        "mstrmojo._ContainsDocObjects",
                         "mstrmojo._CanGrowOrShrink",
        "mstrmojo.boxmodel");
    
    /**
     * Report Services Document Subsection.
     * @class
     * 
     * @extends mstrmojo.Container
     * 
     * @borrows mstrmojo._Formattable#formatHandlers as #formatHandlers
     * @borrows mstrmojo._Formattable#getFormats as #getFormats
     * 
     * @borrows mstrmojo._ContainsDocObjects#height as height
     * @borrows mstrmojo._ContainsDocObjects#width as width
     * @borrows mstrmojo._ContainsDocObjects#getMaxZIndex as getMaxZIndex
     * 
     * @borrows mstrmojo._HasBuilder#postBuildRendering as #postBuildRendering
     * @borrows mstrmojo._HasBuilder#buildChildren as #buildChildren
     */
    mstrmojo.DocSubsection = mstrmojo.declare(
        // superclass
        mstrmojo.Container,
        
        // mixins,
        [ mstrmojo._Formattable, mstrmojo._ContainsDocObjects, mstrmojo._HasBuilder, mstrmojo._CanGrowOrShrink ],
        
        /**
         * @lends mstrmojo.DocSubsection.prototype
         */
        {
            scriptClass: "mstrmojo.DocSubsection",

            markupString: '<div id="{@id}" class="mstrmojo-DocSubsection" style="{@domNodeCssText}"></div>',
            
            markupSlots: {
                containerNode: function() { return this.domNode; }
            },
            
            formatHandlers: {
                domNode: [ 'D', 'B', 'background-color', 'fx' ]
            },
            
            update: function update(node) {
                // if there is a threshold, kill the format
                if(this.thresholdId || node.data.tid) {
                    delete this.fmts;
                }
                
                this.thresholdId = node.data.tid;
                
                if (this._super) {
                    this._super(node);
                }
            },
            
            postBuildRendering: function postBldRndr() {
                var d = this.defn;
            
                // Does this subsection support CanGrow or CanShrink?
                if (d.hc || d.vc) {
                    var dn = this.domNode,
                        f = this.getFormats(),
                        id = this.id,
                        oH = f.height,  // Store original height and width values (pre CanGrow/CanShrink adjustments).
                        oW = f.width;
                    
                    // Set an event listener to hear when the subsection has resized.
                    d.attachEventListener('resized', id, function () {
                        if ('height' in f) {
                            dn.style.height = f.height;
                        }
                        
                        if ('width' in f) {
                            dn.style.width = f.width;
                        }
                    });
                    
                    // Set an event listener to hear when the subsection may need to resize to fit it's contents.
                    d.attachEventListener('adjustSize', id, function (e) {
                        var ds = dn.style,
                        	orgHeight = ds.height;
                        
                        // Is horizontal can shrink or can grow and is the current width different from the original width?
                        if (d.hc && ds.width !== oW) {
                            // Reset width to original width.
                            ds.width = oW;
                        }
                        
                        // Is vertical can shrink or can grow and is the current height different from the original height?
                        if (d.vc && ds.height !== oH) { 
                            // Reset height to original height.
                            ds.height = oH;
                        }
                        
                        this.performCanGrowCanShrink(this.children);

                        //TQMS 479853/436050:  Need to render the objects that are originally not in the viewport.
                        e.heightReduced = (parseInt(orgHeight, 10) > parseInt(ds.height, 10));
                    });
                }
                
                return (this.renderMode !== 'scroll') ? this._super() : true;
            },

            childRenderOnAddCheck: function childRenderOnAddCheck(children) {
                return (this.renderMode !== 'scroll') ? this._super(children) : false;
            },
            
            /**
             * Calls performCanGrowCanShrink for the single child that was just rendered.
             * 
             * @param {mstrmojo.Event|mstrmojo.Width} obj
             * @ignore
             */
            onchildRenderingChange: function chRnChg(obj) {
                this._super(obj);
                
                // If renderMode is not equal to 'scroll' then perform the CanGrow and CanShrink for the single child that was just rendered. 
                if (this.renderMode !== 'scroll') {
                	var parentSlot = this.parent.slot, // #717880 if parent slot is fixed header or footer don't shrink.
                	    dontShrink = parentSlot === 'fixedHeaderNode' || parentSlot === 'fixedFooterNode'; 
                    this.performCanGrowCanShrink([ (obj && obj.src) || obj ], dontShrink);
                }
            },
            
            /**
             * <p>Resizes mstrmojo.DocSubsection elements if CanGrow or CanShrink is enabled and a portal in this section has been maximized.</p>
             * 
             * <p>The resize is done in such a way that all mstrmojo.DocSubsection instances with the same key will also resize.</p>
             * 
             * @returns Object An object with updated properties that should be sent to the server for this subsection. 
             */
            portalMaximized: function portalMaximized() {
                var d = this.defn,
                    vc = d.vc,    // CanGrow/Shrink vertically.
                    hc = d.hc;    // CanGrow/Shrink horizontally.
                
                // Does this subsection support can grow or can shrink?
                if (!hc && !vc) {
                    // If not, then return because there is nothing we need to do.
                    return {};
                }
                
                // Clear all CanGrow and CanShrink properties.
                delete d.vc;
                delete d.hc;
                delete d.ck;    // Collection of id's for dynamically sized objects. 
                
                var f = this.getFormats(),
                    m = this.model,
                    ss = this.domNode,
                    me = this;

                // Create an object to hold server update properties.
                var props = {
                    HideIfEmpty: -1
                };

                /**
                 * Resets height (or width) value, clears associated cache and adds to server properties object.
                 * 
                 * @param {String} h The dimension, either 'Height' or 'Width'.
                 * @param {String} v The suggested subsection height or width as stored in the metadata.
                 * @param {String} [s=''] The suffix to use for the CanGrow and CanShrink server properties, either 'Horizontally' for width or '' for height.
                 * 
                 * @inner
                 * @ignore
                 */
                var fn = function (h, v, s) {
                    var p = h.toLowerCase(),
                        as = parseInt(ss.style[p], 10);    // Current value
                    
                    // If the suggested value is undefined we should use the current value.  Otherwise we should use the maximum of the suggested value or current value.
                    v = ((v === undefined) ? as : Math.max(parseInt(v, 10), as)) + 'px';
                    
                    // Is the suggested value different from the current value?
                    if (f[p] !== v) {
                        // Change the size in the format node.
                        f[p] = v;

                        // Add the new size value to the server properties (needs to be converted to inches).
                        props[h] = mstrmojo.boxmodel.px2Inches(m, v);
                        
                        // Clear the cached height.
                        delete me['_fixed' + h];
                    }
                    
                    // Add server properties.
                    s = s || '';
                    props['Max' + h] = 0;
                    props['CanGrow' + s] = 0;
                    props['CanShrink' + s] = 0;
                };

                // Does this subsection support vertical CanGrow/Shrink?
                if (vc) {
                    fn('Height', f.normHeight);
                }
                
                // Does this subsection support horizontal CanGrow/Shrink?
                if (hc) {
                    fn('Width', f.normWidth, 'Horizontal');
                }
                
                // Raise an event so all instances of this subsection will resized.
                d.raiseEvent({
                    name: 'resized'
                });
                
                return props;
            },
            
            adjustSectionSize: function adjustSectionSize() {
                var d = this.defn;
                
                if (d.vc || d.hc) {
                    return d.raiseEvent({
                        name: 'adjustSize'
                    });
                }
                
                return null;
            },
            
            refresh: function refresh() {
                if (!this.hasRendered) {
                    return;
                }
                                    
                var c = this.children || [];
                for (var i = c.length - 1; i >= 0; i--) {
                	c[i].refresh && c[i].refresh();
                }
            },
            
            /**
             * @ignore
             */
            preserveChildDomOrder: false
        }
    );
    
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget", "mstrmojo.css");

    var _C = mstrmojo.css;

    /**
     * Applies emptyText and emptyClass properties to a given widget.
     * Typically called whenever the widget receives focus or gets its "value" property updated to a non-empty value.
     * @private
     */
    function _hideEmpty(me) {
        var el = me.inputNode;

        var v = (me.value != null) ? String(me.value) : '';

        if (v !== el.value) {
            el.value = v;
        }
        if (el.mstrmojoEmpty) {
            _C.removeClass(el, [me.emptyClass]);
            el.mstrmojoEmpty = null;
        }
    }

    /**
     * Applies emptyText and emptyClass properties to a given widget.
     * Typically called whenever the widget loses focus or gets its "value" property updated to a non-empty value.
     * @private
     */
    function _showEmpty(me) {
        var el = me.inputNode;
        el.value = me.emptyText || '';
        _C.addClass(el, [me.emptyClass]);
        el.mstrmojoEmpty = true;
    }

    /**
     * Sets the value of the given TextBox widget to match the current value in its inputNode.
     * Typically called from DOM after end-user types into inputNode.
     * @param {mstrmojo.TextBox} me The TextBox widget.
     * @private
     */
    function _dom2value(me) {
        var inputNode =  me.inputNode;
        if(inputNode) {
            me.readingDom = true; // Lets event handlers know that this event was triggered by DOM.
            me.set("value",  inputNode.value);
            me.readingDom = false;
        }
    }

    var _KEYCODENAME = {
        9: 'Tab',
        13: 'Enter',
        27: 'Esc',
        38: 'ArrowUp',
        40: 'ArrowDown'
    };

    /**
     * A simple text box control.
     *
     * @class
     * @extends mstrmojo.Widget
     */
    mstrmojo.TextBox = mstrmojo.declare(
        // superclass
        mstrmojo.Container,

        // mixins
        null,

        /**
         * @lends mstrmojo.TextBox.prototype
         */
        {
            scriptClass: 'mstrmojo.TextBox',

            /**
             * The value to appear in the text box.
             *
             * @type String
             * @default ''
             */
            value: '',

            /**
             * The type of the input tag.
             *
             * @type String
             * @default 'text'
             */
            type: 'text',

            /**
             * String to appear as hint in html 5 text box.
             *
             * @type String
             * @default ''
             */
            hint: '',

            /**
             * Specifies whether the input is readonly or not.
             *
             * @type Boolean
             * @default false
             */
            readOnly: false,

            /**
             * The length of the text box input in characters.
             *
             * @type String
             * @default ''
             */
            size: '',

            /**
             * The maximum allowed number of characters.
             *
             * @type String
             * @default ''
             */
            maxLength: '',

            cssDisplay: 'inline',

            /**
             * The position of the text box input in tabbing order.
             *
             * @type Integer
             */
            tabIndex: '',

            // attributes available on INPUT elements in some browsers (e.g. WebKit)
            autoComplete: true,
            autoCorrect: true,
            autoCapitalize: true,
            
            placeholderText: '',

            markupString: '<input id="{@id}" placeholder="{@placeholderText}" class="mstrmojo-TextBox {@cssClass}"  style="{@cssText}" ' +
                                 'title="{@tooltip}" type="{@type}" ' +
                                 'value="" size="{@size}" maxlength="{@maxLength}" index="{@tabIndex}"' +
                                 'min="{@min}" max="{@max}" placeholder="{@hint}"' +
                                 ' mstrAttach:focus,keyup,blur,paste,cut,input,click ' +
                              '/>',

            markupSlots: {
                inputNode: function () { return this.domNode; }
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; },
                oncssClassChange: function () { this.inputNode.className = "mstrmojo-TextBox " + (this.cssClass || ''); },
                onhintChange: function () { this.inputNode.setAttribute('placeholder', this.hint); },
                onenabledChange: function () {
                    this.inputNode.disabled = !this.enabled;
                    mstrmojo.css.toggleClass(this.inputNode, 'disabled', !this.enabled);
                },
                onvalueChange: function () {
                    // Update the DOM value.
                    var v = this.value,
                        em = (v === null) || (v === "");

                    // Toggle the empty styling as needed.
                    if (em) {
                        // If the inputNode has focus currently, dont show the empty value yet.
                        // Wait for the blur handler to do it.
                        if (!this.hasFocus) {
                            _showEmpty(this);
                        } else {
                            this.inputNode.value = "";
                        }
                    } else {
                        _hideEmpty(this);
                    }
                },
                ontooltipChange: function () {
                    this.domNode.title = this.tooltip;
                },
                onreadOnlyChange: function () { this.inputNode.readOnly = this.readOnly; }
            },

            /**
             * <p>Optional text to display when TextBox's value is empty string or null.</p>
             *
             * <p>The text disappears (temporarily) when the end-user gives the TextBox focus, and
             * then reappears when the end-user leaves the TextBox if the TextBox is empty.</p>
             */
            emptyText: '',

            /**
             * Optional CSS class name to be temporarily appended to TextBox's inputNode whenever
             * emptyText is displayed.
             */
            emptyClass: 'mstrmojo-empty',

            postBuildRendering: function postBuildRendering() {
                this._super();

                // set auto correction, etc. attributes on the input element
                var e = this.inputNode;
                e.setAttribute("autocomplete", this.autoComplete ? "on" : "off");
                e.setAttribute("autocorrect", this.autoCorrect ? "on" : "off");
                e.setAttribute("autocapitalize", this.autoCapitalize ? "on" : "off");
            },

            focus: function focus() {
                this.inputNode.focus();
            },

            /**
             * Responds to inputNode getting focus by clearing emptyText, if shown.
             */
            prefocus: function prefocus() {
                this.hasFocus = true;
                // Remove the empty styling, if any.
                _hideEmpty(this);
            },

            /**
             * Handler blur events by updating the widget's "value" property to the DOM's input,
             * and then applying emptyText if the widget's "value" property is empty.
             */
            preblur: function preblur() {
                window.setTimeout(function () {
                    // do nothing just a hack for issue #528431
                }, 200);
                this.hasFocus = false;
                _dom2value(this);
                var v = this.value;
                if ((v === null || v === "") && this.emptyText) {
                    // Apply the empty styling.
                    _showEmpty(this);
                }
            },

            /**
             * Handles key up events for the inputNode.
             * @private
             */
            prekeyup: function pku(evt) {
                // Do we have an onenter method and did the user hit the enter key?
                var hWin = evt.hWin,
                    e = evt.e || hWin.event;

                _dom2value(this); // set value to match the domNode.value
                var n = _KEYCODENAME[e.keyCode];
                if (this['on' + n]) {
                    this['on' + n](evt);
                }
            },
            
            /**
             * Handles input events for the inputNode.
             * WebKit browser does not update the <input> value at keyup, need this 'input' event to do it.
             * @private
             */
            preinput: function pku(evt) {
                // Do we have an onenter method and did the user hit the enter key?
                var hWin = evt.hWin,
                    e = evt.e || hWin.event;

                _dom2value(this); // set value to match the domNode.value
            },
            

            /**
             * Handles paste events for the inputNode.
             * @private
             */
            prepaste: function prepaste() {
                this.delaySetValue(this);
            },

            /**
             * Handles precut events for the inputNode.
             * @private
             */
            precut: function precut() {
                this.delaySetValue(this);
            },

            /**
             * Delay for a time to sets the value of the given TextBox to match the current value in its inputNode.
             * @private
             */
            delaySetValue: function delaySetValue(tgt) {
                window.setTimeout(function () {
                    _dom2value(tgt);
                }, 100);
            },

            /**
             * Puts the TextBox into an error state due to a validation failure.
             *
             * @param {String} [msg] The error message to display.
             */
            setInvalidState: function setInvalidState(msg) {
                // Add the error class to the dom node.
                mstrmojo.css.addClass(this.inputNode, ['err']);

                // Is there a message to display?
                if (msg) {
                    // Put it in the tooltip.
                    this.domNode.setAttribute('title', msg);
                }
            },

            /**
             * Cleans up the text box inputs value and validation status.
             */
            cleanUp: function cleanUp() {
                // Clear the value.
                this.inputNode.value = '';

                // Make sure the error class is not on the domNode.
                mstrmojo.css.removeClass(this.domNode, ['err']);

                // Reset the tooltip.
                this.domNode.setAttribute('title', this.tooltip);
            }
        }
    );

}());
(function () {
    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._IsList");

    var markup;

    /**
     * <p>A control for displaying the list within the {@link mstrmojo._HasSuggestion} popup.</p>
     *
     * @class
     *
     * @extends mstrmojo.ListBase
     *
     * @borrows mstrmojo._IsList
     */
    mstrmojo.SuggestionList = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._IsList ],

        /**
         * @lends mstmrojo.SuggestionList.prototype
         */
        {
            scriptClass: 'mstrmojo.SuggestionList',

            itemField: 'n',

            getItemMarkup: function (item, idx) {
                // Have we NOT cached the markup yet?
                if (!markup) {
                    var itemField = this.itemField;
                    markup = this._super(item).replace('>{@n}<', ' title="{@' + itemField + '}">{@' + itemField + '}<');
                }

                // Return cached markup.
                return markup;
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx),
                    itemField = this.itemField;

                // Update dynamic update field.
                props[itemField] = item[itemField];

                return props;
            },

            onclick: function onclick(evt) {
                this._super(evt);

                var parent = this.parent,
                    opener = parent.opener;

                // Clear suggsetion shown on opener.
                opener.suggestionShown = false;

                // Do we have a selected item?
                var item = this.selectedItem;
                if (item) {
                    // Tell opener to handle.
                    opener.handleSuggestionItemSelect(item);
                }

                // Close parent popup.
                parent.close();
            },

            bindings: {
                itemField: 'this.parent.opener.itemField',
                items: 'this.parent.opener.suggestionItems'
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android._IsList",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android.selectors._SupportsHoriz",
                         "mstrmojo.css");

    /**
     * An Android specific selector check list (or radio list based on the multiSelect property).
     *
     * @class
     * @extends mstrmojo.ListBase
     */
    mstrmojo.android.selectors.CheckList = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._TouchGestures, mstrmojo.android._IsList, mstrmojo._HasTouchScroller, mstrmojo.android.selectors._SupportsHoriz ],

        /**
         * @lends mstrmojo.android.selectors.CheckList.prototype
         */
        {
            scriptClass: "mstrmojo.android.selectors.CheckList",

            hasEvenRows: true,

            init: function init(props) {
                this._super(props);

                // Default class.
                var cls = [ 'selector-checklist' ];

                // Do we support multiselect?
                if (this.multiSelect) {
                    // Add multiselect class.
                    cls.push('multi');
                }

                // Add collection of css classes.
                mstrmojo.css.addWidgetCssClass(this, cls);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android._IsList",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android.selectors._SupportsHoriz",
                         "mstrmojo.color",
                         "mstrmojo.css");

    /**
     * Utility function for overriding item renderer select and unselect methods.
     *
     * @param {Boolean} isSelected True if the select method is requested, false if not.
     *
     * @returns Function
     * @private
     */
    function getItemRenderMethod(isSelected) {
        return function (el, item, idx, widget) {
            // Create default items style and class name values.
            var style = el.style,
                clsMethod = 'remove',
                bgColor = 'transparent',
                color = 'inherit';

            // Is the item selected?
            if (isSelected) {
                // Change to selected item style and class name.
                clsMethod = 'add';
                bgColor = widget.selColor;
                color = widget._txtColor;
            }

            // Set item style properties.
            style.backgroundColor = bgColor;
            style.color = color;

            // Add (or remove) selected class.
            mstrmojo.css[clsMethod + 'Class'](el, mstrmojo.android._IsList.SELECTED_CLS);
        };
    }

    /**
     * An Android specific selector link bar.
     *
     * @class
     * @extends mstrmojo.ListBase
     */
    mstrmojo.android.selectors.LinkBar = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._TouchGestures, mstrmojo.android._IsList, mstrmojo._HasTouchScroller, mstrmojo.android.selectors._SupportsHoriz ],

        /**
         * @lends mstrmojo.android.selectors.LinkBar.prototype
         */
        {
            scriptClass: "mstrmojo.android.selectors.LinkBar",

            /**
             * The background color of selected links.
             *
             * @type String
             * @default #60b1f6
             */
            selColor: '#60b1f6',

            minItemHeight: 29,

            getItemMarkup: function (item) {
                var itemMarkup = this._itemMarkup;
                if (!itemMarkup) {
                    // Add separator and use font color from formats (defaults to black) for separator background color.
                    this._itemMarkup = itemMarkup = this._super(item).replace('{@n}', '<div>{@n}<div style="background-color:' + (this.parent.getFormats().color || '#000') + ';"></div></div>');
                }

                return itemMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                // Get default props.
                var props = this._super(item, idx);

                // Is the item selected?
                if (props.sel) {
                    // Add selected state colors in the style property.
                    props.style += 'color:' + this._txtColor + ';background-color:' + this.selColor + ';';
                }

                return props;
            },

            preBuildRendering: function preBuildRendering() {
                // Add specific css class.
                this.cssClass += ' selector-linkbar';

                // Calculate a contrasting color for text of selected elements.
                this._txtColor = mstrmojo.color.getContrastingColor(this.selColor, ['#ffffff', '#000000']);

                return this._super();
            }
        }
    );

    var linkBar = mstrmojo.android.selectors.LinkBar.prototype,
        itemRenderer = linkBar.itemRenderer;

    // Override default item render methods.
    linkBar.itemRenderer = {
        render: itemRenderer.render,
        select: getItemRenderMethod(true),
        unselect: getItemRenderMethod(false)
    };

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android._IsList",
                         "mstrmojo.css",
                         "mstrmojo.dom",
                         "mstrmojo.array");

    var $DOM = mstrmojo.dom,
        $CSS = mstrmojo.css;

    /**
     * Selects (or unselects) a node without actually selecting it in the list.
     *
     * @param {Object} touch The touch event.
     * @param {String} mthName The name of the method to call on the item renderer.
     *
     * @private
     */
    function selectNode(touch, mthName) {
        var item = $DOM.findAncestorByAttr(touch.target, 'idx', true, this.domNode);
        if (item) {
            var v = item.value,
                ir = this.itemRenderer;

            ir[mthName](item.node, this.items[v], v, this);
        }
    }

    /**
     * A simple touch enabled list for the Android platform.
     *
     * @class
     * @extends mstrmojo.ListBase
     */
    mstrmojo.android.SimpleList = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo.android._IsList, mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        /**
         * @lends mstrmojo.android.SimpleList.prototype
         */
        {
            scriptClass: "mstrmojo.android.SimpleList",

            scrollerConfig: {
                bounces: false,
                showScrollbars: false
            },

            /**
             * If true, the item will be highlighted, but not selected during a select move operation.
             *
             * @type boolean
             * @default false
             */
            highlightOnSelect: false,

            /**
             * Denotes whether the list contains items that have a even height. This allows for a performance optimization that allows us to cache the
             * row height and then use that for all our calculations.
             *
             * @type boolean
             * @default false
             */
            hasEvenRows: false,

            /**
             * If the property mstrmojo.SimpleList.hasEventRows has even rows, this property is used to cache the individual row height.
             *
             * @type Integer
             * @default -1
             */
            rowHeight: -1,
            
            /**
             * If this is true a clearing div will be added to the end of the list for floating items.
             * 
             * @type Boolean
             * @deafult false
             */
            itemsFloat: false,

            /**
             * Overridden to add hosted css class for non touch enabled applications.
             *
             * @ignore
             */
            init: function init(props) {
                this._super(props);

                // Are we in the hosted environment?
                if (!mstrApp.isTouchApp()) {
                    // Add hosted class.
                    $CSS.addWidgetCssClass(this, [ 'hosted' ]);
                }
            },

            /**
             * Re-renders and replaces the list node at the given index.
             *
             * @param {Integer} idx The index of the item to replace.
             */
            updateItem: function updateItem(idx) {
                // Create local DIV for element from string creation and get the item.
                var div = document.createElement('div'),
                    item = this.items[idx],
                    me = this;

                // Set innerHTML of local DIV
                div.innerHTML = this.itemRenderer.render(this.items[idx], idx, this);

                // Replace original element with new element.
                var newEl = div.firstChild;
                this.itemsContainerNode.replaceChild(newEl, this._getItemNode(idx));

                // Iterate the dependents of this item and update them.
                mstrmojo.array.forEach(item.dependents, function (d) {
                    me.updateItem(d._renderIdx);
                });

                return newEl;
            },

            /**
             * Overridden to update scroller after resize.
             *
             * @ignore
             */
            setDimensions: function setDimensions(h, w) {
                // Is either height or width different from current value?
                if (this.height !== h || this.width !== w) {
                    // Set new dimensions.
                    this.height = h;
                    this.width = w;

                    // Resize dom node.
                    var dn = this.domNode;
                    if (dn) {
                        dn.style.height = h;
                        dn.style.width = w;

                        // Update the scroller.
                        this.updateScroller();
                    }
                }
            },
            
            buildRendering: function buildRendering() {
                var rtn = this._super();
                
                // Do items float?
                if (this.itemsFloat) {
                    // Create clearing DIV.
                    var clearDiv = document.createElement('div');
                    clearDiv.className = 'clear-me';

                    // Append clearing DIV to the items container node.
                    this.itemsContainerNode.appendChild(clearDiv);
                }

                return rtn;
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    icn = this.itemsContainerNode,
                    h = parseInt(this.height, 10);

                // Is our height specified?
                if (isNaN(h)) {
                    // Height wasn't specified in the properties, so measure.
                    h = this.domNode.clientHeight;
                }

                // Add the scrollEl to the scroll config.
                cfg.scrollEl = icn;

                // Simple list if for vertical scrolling only so turn on noHScroll.
                cfg.noHScroll = true;

                // Initialize origin to 0,0 (if not already there).
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                // Do we have an offset index?
                var offsetIdx = cfg.offsetIdx;
                if (offsetIdx) {
                    // Delete from configuration.
                    delete cfg.offsetIdx;

                    // Set origin to computed item offset.
                    cfg.origin.y = this.getItemOffset(offsetIdx);
                }

                // Calculate offset end (items container node height minus widget height).
                var offsetEnd = Math.max(this.getItemsContainerHeight() - h, 0);

                // Should we be able to vertically scroll?
                var enableScroll = cfg.vScroll = (offsetEnd !== 0 && cfg.noVScroll !== true);
                if (enableScroll) {
                    // Add the computed offset.
                    cfg.offset = {
                        y: {
                            start: 0,
                            end: offsetEnd
                        }
                    };
                } else {
                    // Make sure there is no offset hanging around.
                    cfg.offset = null;
                }

                return cfg;
            },

            /**
             * Returns the offsetTop value of the item at the given index.
             *
             * @param {Integer} idx The index of the item within the items collections.
             *
             * @type Integer
             */
            getItemOffset: function getItemOffset(idx) {
                var node = this._getItemNode(idx);
                return Math.max(node.offsetTop - parseInt($CSS.getStyleValue(node, 'marginTop'), 10), 0);
            },

            /**
             * Returns the index of the item within the items collection for the current origin.
             * 
             * @type Integer
             */
            getOffsetIndex: function getOffsetIndex() {
                var cfg = this.scrollerConfig,
                    origin = cfg && cfg.origin,
                    y = origin && origin.y;

                // Is the list scrolled?
                if (y) {
                    // Does the list have even rows and a cached row height?
                    var rowHeight = this.rowHeight;
                    if (this.hasEvenRows && rowHeight !== -1) {
                        // Calculate and return the first visible index?
                        return Math.round(y / rowHeight);
                    }

                    var nodes = this.itemsContainerNode.childNodes,
                        min = 0,
                        max = nodes.length - 1;

                    // Binary search to find the element that includes the scroll origin.
                    while (max >= min) {
                        var mid = min + max >> 1,
                            testNode = nodes[mid],
                            nodeY = testNode.offsetTop,
                            nodeH = testNode.offsetHeight;

                        // Is the current origin less than the item offsetTop minus it's height?
                        if (y < nodeY - nodeH) {
                            // Reset max to less than mid.
                            max = mid - 1;

                        // Is The current origin greater than the item offsetTop plus twice it's height?
                        } else if (y > nodeY + (nodeH * 2)) {
                            // Reset max to greater than mid.
                            min = mid + 1;

                        } else {
                            // The current origin is within one item height of the item top or bottom so use this index.
                            return mid;
                        }
                    }
                }

                // Offset index was not found so default to zero.
                return 0;
            },

            /**
             * Scrolls the list such that a particular item is visible.
             *
             * @param {Integer} idx The index of the item within the items collection.
             * @param {Integer} [duration=0] Optional scroll animation duration.
             */
            scrollToItem: function scrollToItem(idx, duration) {
                // Do we have a scroller?
                var scroller = this._scroller;
                if (scroller) {
                    // Scroll to the indicated item.
                    scroller.scrollTo(0, this.getItemOffset(idx), duration || 0);
                }
            },

            /**
             * Calculates the items container's height. It has a performance optimization to avoid making a dom measurement by caching the row
             * height of a single node the first time and reusing the cached height for future calculations.
             *
             * @return The items container's height as a integer.
             */
            getItemsContainerHeight: function getItemsContainerHeight() {
                var hasEvenRows = this.hasEvenRows,
                    rtn;

                // Does the list not have evenRows OR do we have not a cached row height?
                if (!hasEvenRows || this.rowHeight === -1) {
                    // Does the list have evenRows?
                    if (hasEvenRows) {
                        // Does the list have any items?
                        var firstItem = this._getItemNode(0);
                        if (firstItem) {
                            // Cache the row height for future use.
                            this.rowHeight = firstItem.offsetHeight;
                        }
                    } else {
                        // Clear the row height.
                        this.rowHeight = -1;
                    }

                    // Measure the container's height.
                    rtn = this.itemsContainerNode.offsetHeight;
                } else {
                    // Calculate the container height by using the cached row height and multiplying it for each of the items.
                    var items = this.items;
                    rtn = (this.rowHeight * ((items && items.length) || 0));
                }

                return rtn;
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                // Should we highlight on select?
                if (this.highlightOnSelect) {
                    // Highlight the element.
                    selectNode.call(this, touch, 'select');
                }

                this._super(touch);
            },

            touchSelectMove: function touchSelectMove(touch) {
                // Cache that this was a select move.
                this._selectMove = true;

                this._super(touch);
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                var wasMoved = this._selectMove;
                delete this._selectMove;

                // Was the select NOT a select move?
                if (!wasMoved) {
                    // Simulate tap.
                    this.touchTap(touch);

                } else {
                    // Did we highlight on select?
                    if (this.highlightOnSelect) {
                        // Remove element highlight.
                        selectNode.call(this, touch, 'unselect');
                    }
                }
            },
            
            /**
             * Ignore native touch end in favor of _TouchGestures because it's coming from ListBase onclick which we don't need.
             * 
             * @ignore
             */
            touchend: mstrmojo.emptyFn
        }
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.ListBase");

    /**
     * <p>SelectBox renders data items as HTML &lt;options&gt;s in a &lt;select&gt; box.</p>
     * 
     * <p>If "size" is set to 1, the GUI is rendered as a dropdown &lt;select&gt;.</p>
     * 
     * @class
     * @extends mstrmojo.ListBase
     */
    mstrmojo.SelectBox = mstrmojo.declare(
        // superclass
        mstrmojo.ListBase,
        
        // mixins
        null,
        
        /**
         * @lends mstrmojo.SelectBox.prototype
         */ 
        {
            scriptClass: "mstrmojo.SelectBox",
            
            size: 10,
            
            cssDisplay: 'inline',
            
            markupString: '<select id="{@id}" class="mstrmojo-SelectBox {@cssClass}" style="{@cssText}" size="{@size}" {@multipleHtml} ' +
                                     'mstrAttach:keyup,change >' + 
                                     '{@itemsHtml}' + 
                                 '</select>',
            
            markupSlots: {
                itemsContainerNode: function(){return this.domNode; },
                scrollboxNode: function(){return this.domNode; }
            },
            
            /**
             * Overwrites inherited onvisibleChange to make the selectbox render inline rather than block. 
             * 
             * @ignore
             */
            markupMethods: {
                onvisibleChange: function(){ this.domNode.style.display = this.visible ? this.cssDisplay : 'none'; },
                onenabledChange: function(){ this.domNode.disabled = !this.enabled;}
            },

            /**
             * CSS class names for unselected and selected items' divs. Used by itemRenderer.
             * 
             * @type String
             */
            itemCssClass: "mstrmojo-selectbox-item",

            /**
             * Name of field from which to read each item's display name. Used by itemRenderer.
             * 
             * @type String
             */
            itemDisplayField: 'n',

            /**
             * Name of field from which to read each item's data value. Used by itemRenderer.
             * 
             * @type String
             */
            itemIdField: 'v',
            
            /**
             * Whether show tooltip for every item. Not supported Safari.
             * 
             * @type Boolean
             */
            showItemTooltip: false,
                        
            /**
             * <p>Renders an HTML &lt;option&gt; for each item. The option's display text is read from the item's field 
             * set as this widget's "itemDisplayField".</p>
             * 
             * <p>Methods for selecting/unselecting items manipulate the option's "selected" HTML attribute.</p>
             * 
             * @type Object
             */
            itemRenderer: {
                render: function(/*Object*/ item, /*Integer*/ idx, /*Widget*/ widget) {
                    var itemNm = mstrmojo.string.htmlAngles((widget.getItemName) ? widget.getItemName(item, idx) : (widget.itemDisplayField && item[widget.itemDisplayField]));
                    
                    return '<option class="' + widget.itemCssClass + '" ' +
                                'value="' + ((widget.getItemValue) ? widget.getItemValue(item, idx) : (widget.itemIdField && item[widget.itemIdField])) + '" ' + 
                                ((widget.selectedIndices[idx]) ? 'selected="true" ' : '') + ((widget.showItemTooltip)? 'title="' + mstrmojo.string.encodeXMLAttribute(itemNm)+ '"' : '') + '>' +
                                    itemNm + 
                           '</option>';
                },
                select: function(/*DomNode*/ el, /*Object*/ item, /*Integer*/ idx, /*Widget*/ widget) {
                    el.selected = true;
                },
                unselect: function(/*DomNode*/ el, /*Object*/ item, /*Integer*/ idx, /*Widget*/ widget) {
                    el.selected = false;
                }
            },
            
            /**
             * Extends the inherited method to support the "multipleHtml" property in the markup string.
             * 
             * @ignore
             */
            buildRendering: function bldRnd(){
                this.multipleHtml = this.multiSelect ? ' multiple="true" ' : '';
                this._super();
                delete this.multipleHtml;
            },
            
            _getItemNode: function(idx) {
                // Assumes the scrollboxNode slot points ot the <select> HTML node.
                var s = this.scrollboxNode;
                return s && s.options[idx];
            },

            /**
             * <p>Updates selectedIndices after the end-user changes the DOM's current selection.</p>
             * 
             * <p>Raises a "selectionChange" event if the selectedIndices are modified.</p>
             * 
             * @param {Object} evt A manufactured object representing the event.
             * @param {DomWindow} evt.hWin The window containing the clicked element.
             * @param {DomEvent} evt.e The click event.
             * @private
             */
            prechange: function prechg(evt) {
                // To avoid repainting the selections in DOM unnecessarily (and even possibly
                // triggering an infinite loop), use a temp flag to indicate that we are
                // synchronizing our selectedIndices with the DOM.
                if (this._syncDom) {
                    return;
                }
                
                this._syncDom = true;

                var el = this.scrollboxNode;
                // Use _ListSelections method to update selectedIndices/Index/Value
                // and raise a selectionChange event.
                if (this.multiSelect) {
                    // We support multiselect, so walk the DOM options to see which are selected.
                    var os = el.options,
                        idxs = [];
                    for (var i=0, len=os.length; i<len; i++) {
                        if (os[i].selected) {
                            idxs.push(i);
                        }
                    }
                    this.select(idxs);
                } else {
                    // We don't support multiselect, so ask DOM for the single selected index.
                    this.singleSelect(el.selectedIndex);
                }
                
                delete this._syncDom;
            },
            
            /**
             * <p>Check if user change the selected.</p>
             * 
             * <p>Call prechange to handle the change</p>
             * 
             * @param {Object} evt A manufactured object representing the event.
             * @param {DomWindow} evt.hWin The window containing the clicked element.
             * @param {DomEvent} evt.e The keyup event.
             * @private
             */
            prekeyup: function(evt) {
                var el = this.scrollboxNode,
                isChanged = false; // flag indicates if the selected is changed.

                if (this.multiSelect) {
                    // walk the DOM options to see if any selected is changed.
                    var os = el.options;
                    for (var i=0, len=os.length; i<len; i++) {
                        if (os[i].selected !== !!this.selectedIndices[i]) {
                            isChanged = true;
                            break;
                        }
                    }

                } else {
                   if (el.selectedIndex !== this.selectedIndex) {
                       isChanged = true;
                   }
                }
                if (isChanged) { //if selected changed, use change() to handle
                    var e = evt;
                    e.name = "change";
                    this.raiseEvent(evt);
                }
            },
            
            /**
             * Extends the inherited method in order to avoid:
             * <ol>
             * <li>repainting the DOM to reflect the new selections, and</li>
             * <li>firing the optional "onchange" handler</li>
             * </ol>
             * if the "selectionChange" event was triggered by a native "change" DOM event.
             * For such an event, these 2 operations are not needed because:
             * <ol>
             * <li>the browser will automatically update the DOM selections, and</li>
             * <li>the onchange handler will be called by the _HasMarkup::captureDomEvent method</li>.
             */
            onselectionChange: function onselchg(evt){
                if (!this._syncDom) {
                    this._super(evt);
                }
            }
            
        }
    );
    
})();            
(function () {

    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android._IsList",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android.selectors._SupportsHoriz",
                         "mstrmojo.css");

    var itemMarkup,
        LINE_REG_EXP = /line-height:(\d*)px/,
        $CSS = mstrmojo.css;
    
    /**
     * Adds (or removes) the glow CSS class to (or from) the domNode.
     *
     * @param {Boolean} [doGlow=false] Whether the glow class should be added (or removed).
     *
     * @private
     */
    function toggleGlow(doGlow) {
        // Is this NOT an ActionSelector?
        if (this.parent.defn.ct !== '4') {
            // Nothing to do.
            return;
        }

        mstrmojo.css[((doGlow) ? 'add' : 'remove') + 'Class'](this.domNode, 'glow');
    }

    /**
     * An Android specific selector Button bar.
     *
     * @class
     * @extends mstrmojo.ListBase
     *
     * @borrows mstrmojo._TouchGestures
     * @borrows mstrmojo.android._IsList
     * @borrows mstrmojo.android.selectors._SupportsHoriz
     */
    mstrmojo.android.selectors.ButtonBar = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._TouchGestures, mstrmojo.android._IsList, mstrmojo._HasTouchScroller, mstrmojo.android.selectors._SupportsHoriz ],

        /**
         * @lends mstrmojo.android.selectors.ButtonBar.prototype
         */
        {
            scriptClass: "mstrmojo.android.selectors.ButtonBar",

            cssClass: 'selector-btnbar',

            getItemMarkup: function getItemMarkup(item) {
                if (!itemMarkup) {
                    itemMarkup = this._super(item).replace('{@n}', '<div>{@n}</div>');
                }

                return itemMarkup;
            },

            getItemProps: function getItemProps(item, idx) {
                // Get default props and extract line-height.
                var props = this._super(item, idx),
                    style = props.style,
                    lineHeight = style.match(LINE_REG_EXP);

                // Do we have a specific item line-height?
                if (lineHeight) {
                    // Reduce the line height by 2 pixels to account for borders.
                    props.style = style.replace(LINE_REG_EXP, 'line-height:' + (parseInt(lineHeight[1], 10) - 2) + 'px');
                }

                return props;
            },
            
            touchBegin: function touchBegin() {
                toggleGlow.call(this, true);
            },
            
            touchEnd: function touchEnd() {
                toggleGlow.call(this);
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.Button",
                         "mstrmojo.url");

    mstrmojo.requiresDescs(1442, 2140);
    
    var $NIB = mstrmojo.Button.newInteractiveButton;

    mstrmojo.android.inputControls.SignatureDIC = mstrmojo.declare(

        mstrmojo.Widget,

        [ mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: 'mstrmojo.android.inputControls.SignatureDIC',

            markupString: '<div></div>',

            /**
             * Whether user has already created a signature
             */
            hasSignature: false,

            /**
             * @override mstrmojo._IsInputControl.showInPopup
             */
            showInPopup: function showInPopup() {
                var ownerObj = this.ownerCell || this.owner;

                // If the cell already has the signature
                if (ownerObj.mdf) {
                    var me = this;
                    mstrmojo.confirm('Continuing will erase the existing signature. Do you want to proceed?', [ $NIB(mstrmojo.desc(2140, 'Cancel'), null, null), $NIB(mstrmojo.desc(1442, 'Ok'), function () {
                        me.captureSignature();
                    }, null) ]);
                } else {
                    this.captureSignature();
                }
            },

            /**
             * Start the android activity to capture the signature.
             */
            captureSignature: function captureSignature() {
                mstrMobileApp.captureSignature(JSON.stringify({
                    serverURL: mstrApp.getConfiguration().getTaskUrlByProject(mstrApp.getCurrentProjectId()),
                    sessionState: mstrApp.getSessionState(),
                    showGuideLine: this.dic.sgl
                }), 'mstrmojo.all["' + this.id + '"].signatureCaptured');
            },

            /**
             * callback when the signature is captured.
             */
            signatureCaptured: function signatureCaptured(imagePath) {
                this.value = mstrmojo.url.getAbsoluteURL(imagePath, mstrApp.getConfiguration().getCurrentProjectWebServerUrl());

                this.applyChanges();
            },

            renderPreview: function renderPreview() {
                var previewValue = '',
                    ownerObj = this.ownerCell || this.owner,
                    openerNode = this.openerNode,
                    sigValue = this.value;

                // Does the signature value have an image source?
                if (ownerObj.mdf && /^(http|https).+(png|jpg)$/.test(sigValue)) {
                    previewValue = '<img src="' + this.value + '" style="max-height:' + openerNode.clientHeight + 'px;max-width:' + (openerNode.clientWidth - 30) + 'px;"></img>\u00a0';
                }

                this.renderPreviewButton(openerNode, previewValue);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Button",
                         "mstrmojo.css",
                         "mstrmojo.hash");

    var $CSS = mstrmojo.css,
        $HASH = mstrmojo.hash,
        cssGlow = 'glow';

    /**
     * <p>A touch enabled button that can hold an image or text.</p>
     *
     * @class
     * @extends mstrmojo.Button
     * 
     * @borrows mstrmojo._TouchGestures
     */
    var $BTN = mstrmojo.android.ui.Button = mstrmojo.declare(
        mstrmojo.Button,

        [ mstrmojo._TouchGestures ],

        /**
         * @lends mstrmojo.android.ui.Button.prototype
         */
        {
            scriptClass: 'mstrmojo.android.ui.Button',

            onclick: mstrmojo.emptyFn,

            touchBegin: function touchBegin() {
                // Add glow class if enabled.
            	if ( this.enabled ) {
                    $CSS.addClass(this.domNode, cssGlow);
            	}
            }, 

            touchTap: function touchTap(touch) {
                // Simulate click event if enabled.
            	if ( this.enabled ) {
	                this.onclick({
	                    e: touch.evt
	                });
            	}
            },

            // Needed so that _TouchGestures will create select action.
            touchSelectBegin: mstrmojo.emptyFn,

            touchSelectEnd: function touchSelectEnd(touch) {
                // Simulate click event if enabled.
            	if ( this.enabled ) {
                    this.onclick({
                        e: touch.evt
                    });
            	}
            },

            touchEnd: function touchEnd() {
                // Remove glow class.
                $CSS.removeClass(this.domNode, cssGlow);
            }
        }
    );

    // Strip "mstrAttach" event handler tokens from markup string.
    $BTN.prototype.markupString = $BTN.prototype.markupString.replace(new RegExp(' mstrAttach:[a-zA-Z,]*'), '');

    /**
     * Creates an interactive button that will glow when user touches it.
     * 
     * @param {String} text The text to appear in the button.
     * @param {Function} [fnClick] An optional function to execute when the button is clicked.
     * @param {Object} [props] An optional collection of properties to add to the button.
     *
     * @return {Object} The button configuration object.
     * @static
     */
    $BTN.newButton = function newButton(text, fnClick, props) {
        // Create base button config.
        var btn = {
            scriptClass: 'mstrmojo.android.ui.Button',
            text: text
        };

        // Do we have an onclick function?
        if (fnClick) {
            btn.onclick = fnClick;
        }

        // Copy extra properties.
        $HASH.copy(props, btn);

        return btn;
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Calendar",
                         "mstrmojo._TouchGestures");
    
    /**
     * <p>MobileCalendar is a widget that allows to pick a date for touch-enabled
     *  devices. </p>
     * 
     * @class
     * @extends mstrmojo.MobileCalendar
     */
    mstrmojo.MobileCalendar = mstrmojo.declare(
        // superclass
        mstrmojo.Calendar,
        // mixins
        [mstrmojo._TouchGestures],
        
        /**
         * @lends mstrmojo.MobileCalendar.prototype
         */
        {
            scriptClass: "mstrmojo.MobileCalendar",
            
            /**
             * @see mstrmojo.Calendar
             */
            cssPrefix: 'mobile-calendar',

            /**
             * Mobile Calendar shows the full calendar names.
             * 
             * @see mstrmojo.Calendar
             */
            monthNames: function(i){ return mstrmojo.locales.datetime.MONTHNAME_FULL[i]; },
            
            
            /**
             * The Mobile Calendar only shows the day view.
             * 
             * @see mstrmojo.Calendar
             */
            supportedViews: {
                day: true,
                month: true,
                year: true
            },
            
            /**
             * @see mstrmojo.Calendar
             */
            premousedown: function premousedown(e) {
                //for debugging purposes: Let the calendar handle clicks when testing on a non-mobile device.
                if (!mstrApp.isTouchApp()) {
                    return this._super(e);
                }
            },
            
            /**
             * @see mstrmojo._TouchGestures.
             */
            touchTap: function touchTap(touch) {
                //Process the event based on where the user has tapped.
                this.processEvent(document.elementFromPoint(touch.pageX, touch.pageY));
                
                return false;
            }
        }
    );
    
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.NumStepperContentProvider", "mstrmojo.date");
    
    var $D = mstrmojo.date;
    
    mstrmojo.DateStepperContentProvider = mstrmojo.declare(
        // superclass
        mstrmojo.StepperContentProvider,
        
        // mixins
        null,
        
        // instance members 
        {
            scriptClass: "mstrmojo.DateStepperContentProvider",
            
            curVal: null,
            
            init: function(props){
                this._super(props);
                
                //Set the instance variables
                var item = this.item,
                    intVal = item[this.intField],
                    val = item[this.valField],
                    minF = this.minField,
                    maxF = this.maxField,
                    min = item[minF],
                    max = item[maxF];
                
                //Get the min, max and the interval values from the steppers data item.
                this.min = min && $D.getDateFromDateInfo(min);
                this.max = max && $D.getDateFromDateInfo(max);
                
                //Do we have an initial value? If not, do we have a min? If not, reset the value to the current date.
                this.curVal = val ? $D.getDateFromDateInfo(val) : (this.min ? new Date(this.min) : new Date());
                
                //Create stepper content providers for month, day, year fields.
                this.createChildProviders();
            },
            
            /**
             * The following interfaces are not applicable.
             * Use the ones from the child content providers instead. 
             * 
             * next: mstrmojo.emptyFn,
             * prev: mstrmojo.emptyFn,
             * hasPrev: mstrmojo.emptyFn,
             * hasNext: mstrmojo.emptyFn,
             * renderItemAt: mstrmojo.emptyFn
             */
            
            
            /**
             * Create individual number stepper content providers for the year, month and day stepper.
             */
            createChildProviders: function(){
                var me = this;
                
                mstrmojo.array.forEach(['year', 'month', 'day'], function(n){
                    me[n + 'CP'] = new mstrmojo.NumStepperContentProvider({
                                        item: { interval:1 },
                                        canLoop: true,
                                        updateConfig: function(v, max, min){
                                            this.curVal = v;
                                            this.max = max;
                                            this.min = min;
                                        },
                                        onTraverse: function(){
                                            //notify the dateProvider to traverse
                                            me.traverse(n, this.curVal);
                                        }
                                    });
                });
                
                this.updateChildProviders();
            },
            
            /**
             * Update the year, month and day stepper provider with the new value, max and min.
             */
            updateChildProviders: function(){
                var max = this.max,
                    min = this.min,
                    year = this.curVal.getFullYear(),
                    month = this.curVal.getMonth(),
                    day = this.curVal.getDate(),
                    // Is it on the year boundary?
                    atMaxYear = max && (year === max.getFullYear()),
                    atMinYear = min && (year === min.getFullYear()),
                    // Is it on the month boundary?
                    atMaxMonth = atMaxYear && (month === max.getMonth()),
                    atMinMonth = atMinYear && (month === min.getMonth());
                
                // Directly use the max/min year from the config
                this.yearCP.updateConfig(year, max ? max.getFullYear() : null, min ? min.getFullYear() : null);
                // Read the max/min month from the config if we are on the year boundary,
                // Otherwise, use [1-12] instead
                this.monthCP.updateConfig(month + 1, atMaxYear ? max.getMonth() + 1 : 12, atMinYear ? min.getMonth() + 1 : 1);
                // Use the max/min day from the config if we are on the month boundary,
                // Otherwise, calculate it based on the year and month value.
                this.dayCP.updateConfig(day, atMaxMonth ? max.getDate() : mstrmojo.date.getDaysOfMonth(year, month + 1), atMinMonth ? min.getDate() : 1);
            },
            
            /**
             * Allow child providers to update the date value
             * 
             * @param field {String} 'year', 'month' or 'day'
             * @param value {Number} the current value of year, month or day
             */
            traverse: function(field, value){
            //update the underlying date value to let it fit into the range
                var v = this.curVal,
                    y = (field === 'year') ? value : this.curVal.getFullYear(),
                    m = (field === 'month') ? value : this.curVal.getMonth() + 1, //the value of 'm' is 1-based
                    d = (field === 'day') ? value : this.curVal.getDate();
                
                //when year or month changes, the current day value may be invalid;
                d = Math.min(mstrmojo.date.getDaysOfMonth(y, m), d);
                
                //update the date with the valid year, month, day
                v.setFullYear(y, m - 1, d);
                
                //Check whether the current date is out of bounds.
                if (this.max){
                    v = Math.min(this.max, v); // This will convert the date type to integer
                }
                if (this.min){
                    v = Math.max(this.min, v); // This will convert the date type to integer
                }
                
                this.curVal = new Date(v);
                
                this.updateChildProviders(); //update sub providers with the new max/min limits
                
                if (this.onTraverse){
                    this.onTraverse();
                }
            }
        }
    );
}());           
(function(){

    mstrmojo.requiresCls("mstrmojo.XtabModel",
                         "mstrmojo.array",
                         "mstrmojo.func");
    
    var MX = 'Metrics',
        SELECTOR_ACTION = 2;
    
    /**
    * Resolves any control group by (if any) to the target keys property (tks) in the selector control map.
    * 
    *  @param {Object} The control group by mapping of all the control group bys and their respective target keys in a 
    *  given layout.
    */
   function _resolveCGBToTKS(cgbMap) {
       //Return if we don't have new values
       if (!cgbMap) return;
       
       var scm = this.scm,
           delim = '\u001E',
           i = 0,
           id = null,
           curSelector = null,
           cgb = null,
           cgbKey = null,
           targetKey = null,
           updatedTks = false;
       
       for (id in scm) {
           curSelector = scm[id];
           cgb = curSelector.cgb;
           
           //Loop through the control group by that the selector targets and see if we have 
           //the respective target keys.
           for (i in cgb) {
               cgKey = cgb[i];
               targetKey = cgbMap[cgKey];
               
               //We append the target key only if it doesn't exist
               if (targetKey) {
                   if (!curSelector.tks){
                       curSelector.tks = targetKey;
                       updatedTks = true;
                   } else if (curSelector.tks && (curSelector.tks.indexOf(targetKey) < 0)) {
                       curSelector.tks += delim + targetKey;
                       updatedTks = true;
                   }
               }
           }
       }
       
       return updatedTks;
   }
    
    function createSelectorMap () {
        var data = this.data,
            gridTitles = data.gts;
        
        // Do we NOT have any grid titles?
        if (!gridTitles) {
            // Nothing to do.
            return;
        }
        
        var map;
        
        // Iterate grid titles axis.
        mstrmojo.array.forEach([ gridTitles.row, gridTitles.col ], function (axis) {
            // Iterate units on this axis.
            for (var i = 0, cnt = axis.length; i < cnt; i++) {
                // Is this unit a selector?
                var unit = axis[i];
                if (unit.sc) {
                    // Initialize map.
                    map = map || {};
                    
                    // Store the selector in the map.
                    map[unit.id || MX] = unit.sc;
					//TQMS : 702824 , we need to calculate tks and store in all the forms for the attribute not just the last one
					if (unit.fid) { 
						map[unit.id + "_"+ unit.fid] = unit.sc;
					}
                }
            }
        });
        
        this.scm = map;
        
        _resolveCGBToTKS.call(this, this.docModel.getCGBMap());
    }
    
    function submitToDataService(methodName, args) {
        var dataService = this.getDataService();
        dataService[methodName].apply(dataService, args);
    }

    /**
     * <p>A model for handling Document Xtab interactivity.</p>
     * 
     * @class
     * @extends mstrmojo.XtabModel
     */
    mstrmojo.DocXtabModel = mstrmojo.declare(
        mstrmojo.XtabModel,
        
        null,
        
        /** 
         * @lends mstrmojo.DocXtabModel.prototype
         */
        {            
            scriptClass: "mstrmojo.DocXtabModel",
            
            docModel: null,
            
            init: function init(props) {
                this._super(props);
                
                this.docModel.attachEventListener('CGBMapChange', this.id, function(evt) {
                    // TODO: add onCGMapChange code here
                });                
            },
            
            ondataChange: function ondataChange(evt) {
                createSelectorMap.call(this);
            },
            
            getMessageId: function getMessageId() {
                return this.docModel.mid;
            },
            
            getDataService: function getDataService() {
                return this.docModel.getDataService();
            },            
            
            getAction: function getAction(cells, domNode, isReselect) {
                var cell = cells[0],
                    actionType = cell && cell.at;

                var action;
                // Resolve what the action should be.
                if (actionType) {
                    // Is this a selector action?
                    if (actionType & SELECTOR_ACTION) {
                        
                        var titleInfo = this.getCellTitleInfo(cell),
                            title = titleInfo && titleInfo.title,
                            titleId = title && title.id,
                            selectorControlMap = this.scm;
                    
                        // Cache selected title id for highlighting cells.
                        this.sti = {
                            titleId: titleId || MX
                        };
                        
                        // Retrieve the selector from the selector map.
                        var sc = (titleId && selectorControlMap[titleId]) || selectorControlMap[MX];
                        
                        // Do we have a selector?
                        if (sc) {
                            var xtab = this.xtab,
                                shouldDeselectCurrentCell = (xtab.allowToggleSelections && sc.all && isReselect),
                                selectAllElements = (titleInfo.isSrcTitle || shouldDeselectCurrentCell);
                            
                            this.sti.deselectCurrent = shouldDeselectCurrentCell;
                            
                            // Return the selector action.
                            action = {
                                h: 'onGridSelector',
                                a: {
                                    type: mstrmojo.EnumRWUnitType.GRID,
                                    anchor: domNode,
                                    ck: sc.ck,
                                    tks: sc.tks,
                                    eid: selectAllElements ? 'OA:(All)' : cell._e.id,
                                    ctlKey: sc.ckey,
                                    sliceId: xtab.sid,
                                    isUConDS: sc.isUConDS
                                }
                            };
                        }        
                    }
                }
                
                // Delegate to super because we couldn't handle it.
                if ( ! action ) {
                    var action = this._super(cells);
                }
                //TQMS 496126 We need to pass the slice ID to the server
                if ( action && action.a ) {
                    action.a.sliceId = this.xtab.sid;
                }
                return action;

            },
            
            getDownloadAction: function getDownloadAction(/* Integer */ rowPosition, /* Integer */ maxRows,  /* Integer */ colPosition, /* Integer */ maxCols, /* String */ widgetID, /* Object */ memo) {
                //TQMS:506089, 505174 add slice Id as the task parameter
                var action = this._super(rowPosition, maxRows, colPosition, maxCols, widgetID, memo);
                action.sliceId = this.xtab.sid;
                return action;
            },
            
            /**
             * Gets drill information for the Drills from the template unit supplied.
             * 
             * @param {Object} cells The interactive cells. The first cell is the html table cell that initiated the drill.
             */
            getDrillAction: function getDrillAction(cells) {
                var action = this._super(cells);                
                action.srcMsgId = this.docModel.mid;
                
                return action;
            },    
            
            sort: function sort (params, callback) {
                // Submit to data service.
                submitToDataService.call(this, 'sort', arguments);
            },
            
            pivot: function pivot (params, callback) {
                // Submit to data service.
                submitToDataService.call(this, 'pivot', arguments);
            },
            
            drillGrid: function drillGrid (params, callback) {
                submitToDataService.call(this, 'drillGrid', arguments);
            },
            
            downloadGridData: function downloadGridData (params, callback) {
                submitToDataService.call(this, 'downloadGridData', arguments);
            },
            
            loadLayout: function loadLayout(res) {
                // This is actually a document model operation so pass the response to the doc model.
                this.docModel.loadLayout(res);
            }
        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._Formattable",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.hash");

    /**
     * <p>A widget to display HTML text (for iFrame {@see mstrmojo.DocHTMLContainer}) in the Android Platform.</p>
     *
     * @class
     * @extends mstrmojo.Widget
     *
     */
    mstrmojo.android.HTMLContainer = mstrmojo.declare(
        mstrmojo.Widget,

        // mixins,
        [ mstrmojo._Formattable, mstrmojo._HasTouchScroller, mstrmojo._TouchGestures ],

        /**
         * @lends mstrmojo.android.HTMLContainer.prototype
         */
        {
            scriptClass: "mstrmojo.android.HTMLContainer",

            markupString:   '<div id="{@id}" class="mstrmojo-HTMLContainer {@cssClass}" title="{@tooltip}" style="{@domNodeCssText}">' +
                                '<div>{@v}</div>' +
                            '</div>',

            markupSlots: {
                valueNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                domNode:  [ 'RW', 'B', 'F', 'P', 'background-color', 'fx', 'text-align', 'white-space' ]
            },

            /**
             * Updates the DocTextField data that may change due to a selector action.
             *
             * @param {Object} node The widget node.
             */
            update: function update(node) {
                var d = node.data,
                    v = d.v || '';

                // Decode the value.
                var div = document.createElement('div');
                div.innerHTML = '<textarea>' + v + '</textarea>';
                v = '<div style="display:none">&nbsp;</div>' + div.firstChild.value + '&nbsp;';     // Second nbsp; is to ensure that we can scroll to the bottom.

                // Kill element.
                div = null;

                // Store value on instance.
                this.v = v;
                
                // Is there a threshold?
                if (this.thresholdId || d.tid) {
                	// Kill the format
                	delete this.fmts;
                }

                // Store threshold ID.
                this.thresholdId = d.tid;

                // Overwrite scroller config for re-renders.
                this.scrollerConfig = {
                    bounces: false,
                    showScrollbars: false
                };
            },

            /**
             * Overridden to execute scripts.
             *
             * @ignore
             */
            postBuildRendering: function postBuildRendering() {

                // Grab collection of script tags within html container.
                var scripts = this.domNode.getElementsByTagName('script'),
                    len = scripts.length,
                    i;

                for (i = 0; i < len; i++) {
                    // Eval each script text.
                    eval(scripts[i].innerHTML);
                }

                return this._super();
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    scrollEl = this.valueNode,
                    domNode = this.domNode,
                    fmts = this.getFormats(),
                    iterator = {
                        'Height': {
                            a: 'y',
                            s: 'v'
                        },
                        'Width': {
                            a: 'x',
                            s: 'h'
                        }
                    },
                    offset = {};

                // Add the scrollEl to the scroll config.
                cfg.scrollEl = scrollEl;

                mstrmojo.hash.forEach(iterator, function (info, dimension) {
                    // Is scrolling disabled in this direction?
                    if (cfg['no' + info.s.toUpperCase() + 'Scroll']) {   // 'noHScroll' or 'noVScroll'.
                        // Nothing to do.
                        return;
                    }

                    // Get widget size for this dimension.
                    var widgetSize = parseInt(fmts[dimension.toLowerCase()], 10);

                    // Do we not have a fixed widget size?
                    if (isNaN(widgetSize)) {
                        // Retrieve widget size from the domNode.
                        widgetSize = domNode['client' + dimension];
                    }

                    // Calculate offset end (scroll element node dimension size minus widget dimension size).
                    var offsetEnd = Math.max(scrollEl['offset' + dimension] - widgetSize, 0),
                        enableDimensionScroll = cfg[info.s + 'Scroll'] = (offsetEnd !== 0);

                    // Can we scroll in this dimension?
                    if (enableDimensionScroll) {
                        // Add offset value for appropriate axis.
                        offset[info.a] = {
                            start: 0,
                            end: offsetEnd
                        };
                    }
                });

                // Add computed offset to config.
                cfg.offset = offset;

                // Add origin, initializing to 0,0 if we don't have one.
                cfg.origin = cfg.origin || {
                    x: 0,
                    y: 0
                };

                return cfg;
            }

        }
    );

}());
(function () {

	mstrmojo.requiresCls("mstrmojo.Widget",
						 "mstrmojo.VisHeatMapColorTheme",
						 "mstrmojo._TouchGestures",
						 "mstrmojo._HasTouchScroller",
						 "mstrmojo.dom",
						 "mstrmojo.css"
						 );
	
	var STEP_X = 1200,
		STEP_Y = 800;
	
	var LABEL = {
		ON: 0,
		OFF: 1,
		PROPORTIONAL: 2
	};
	
	var FMT = {
		LABEL_CTNR_THRES: 6, // label container threshold dimension
        LABEL_CTNR_WIDTH_THRES: 32,
		LGD_GUTTER: 5, // extra space around label, when it has drop shadow or playing as padding between label and border
        LABEL_PADDING: 2 // left and right padding around labels 
	};
	
	var CSSATTR = {
		"heatmap-one-level-1": {},
		"heatmap-two-level-2": {},
		"heatmap-multi-level-1": {},
		"heatmap-multi-level-2": {},
		"heatmap-multi-level-3": {},
		init: false
	};
	
	function getCSSColor(rgb) {
		var c = 0x1000000 + rgb; 
		var str = '#' + c.toString(16).substring(1).toUpperCase();
		return str;
	}
	
	function wfs(root, f) {
		var arr = [root];
		while (arr.length !== 0) {
			var node = arr.shift();
			if (node === undefined || node.deleted) {
				continue;
			}
			
			f(node);
			
			var children = node.entityChildren;
			if (children !== undefined) {
				var l = children.length;
				for (var i = 0; i < l; i++) {
					arr.push(children[i]);
				}
			}
		}
	}
	
	function dfs(root, f, indexString) {
		if(root.deleted) {
			return;
		}
		if(indexString === undefined){
			f(root);
		}else{
			f(root, indexString);
		}
		
		if(root.entityChildren === undefined){
			return;
		}
		var arr = root.entityChildren,
			l = arr.length;
		for(var i = 0; i < l; i++){
			var e = arr[i];
			if(indexString === undefined){
				dfs(e, f);
			}else{
				var param = indexString;
				if (!param) {
					param = i.toString();
				} else {
					param = param + ":" + i;
				}
				dfs(e, f, param);
			}
		}					
	}
	
	function getLabelCSS(l, n) {
		var css;
		if (n === 1) {
			if (l === 0) {
				css = "heatmap-one-level-1";
			}
		} else if (n === 2) {
			if (l === 0) {
				css = "heatmap-multi-level-1";
			} else if (l === 1) {
				css = "heatmap-two-level-2";
			}
		} else if (n >= 3) {
			if (l === 0) {
				css = "heatmap-multi-level-1";
			} else if (l === 1) {
				css = "heatmap-multi-level-2";
			} else if (l === 2) {
				css = "heatmap-multi-level-3";
			}
		}

		return css;
	}

	function intersect(lhs, rhs) {
        if(!lhs || !rhs) {
                return false;
        }
		if (rhs.x >= lhs.x + lhs.w ||
			rhs.y >= lhs.y + lhs.h ||
			rhs.x + rhs.w <= lhs.x ||
			rhs.y + rhs.h <= lhs.y) {
			return false;
		} else {
			return true;
		}
	}
	
	function rectIntersection(a, b) {
		var x = Math.max(a.x, b.x);
		var y = Math.max(a.y, b.y);
		var w = Math.min(a.x + a.w, b.x + b.w) - x;
		var h = Math.min(a.y + a.h, b.y + b.h) - y;
		if (w < 0 || h < 0) {
			return {
				x : NaN,
				y : NaN,
				w : NaN,
				h : NaN
			};
		}
		return {
			x : x,
			y : y,
			w : w,
			h : h
		};
	}
	
	mstrmojo.VisHeatMapCanvas = mstrmojo.declare(
		
		mstrmojo.Widget,
		
		null,
		
		{
			scriptClass: 'mstrmojo.VisHeatMapCanvas',
			
			parent: null,
			
			root: null,
			
			colorTheme: null,
			
			attributes: [],
			
			scale: 1.0,
			
			labelSetting: 0, // 0: On; 1: Off; 2: PROPORTIONAL
			
			showMetric: false,
			
			bgColor: '#333333',
			
			numImages: 0,
			
			offsetX: 0,
			offsetY: 0,
			
			markupString: 
			'<div style="position:absolute; width:{@width}px; height:{@height}px">' +
				'<canvas width={@width} height={@height} style="visibility: hidden; z-index:0"></canvas>' +
				'<span></span>' +
			'</div>',
			
			markupSlots: {
				domCanvas:	function () { return this.domNode.firstChild; },
				domSpan:	function () { return this.domNode.childNodes[1]; },
				domImage:	function () { return this.domNode.childNodes[2]; }
			},
			
			buildRendering: function () {
				var that = this;
				var backup = mstrmojo.string.apply;
				mstrmojo.string.apply = function (tmpl, obj) {
					if (!tmpl) {
						return "";
					}
					return tmpl.replace(/\{([^\}]+)\}/gm,
						function tokenRepl(token, prop) {						
							var s = token.replace(/@/g, 'that.');
							var res = eval(s);
							return res === undefined ? '' : res;
						}
					);
				};
				
				if (this._super) {
					this._super();
				}
				
				mstrmojo.string.apply = backup;
			},
			
			postBuildRendering: function () {
				this.initCSSATTR();
				
				this.draw();

				if (this._super) {
					this._super();
				}
			},
			/*
			onclick: function () {
				this.draw();
			},
			*/
			removeImageAndLabels: function () {
				var dom = this.domNode,
					labels = dom.childNodes,
					n = labels.length;
				for (var i = n-1; i > 1; i--) {
					var node = labels[i];
					dom.removeChild(node);
				}
				this.numImages = 0;
			},
			
			removeLabels: function () {
				var dom = this.domNode,
					labels = dom.childNodes,
					n = labels.length,
					stop = 1 + this.numImages;
				for (var i = n-1; i > stop; i--) {
					var node = labels[i];
					dom.removeChild(node);
				}
			},
			
			updateOffsets: function (x, y) {
				this.offsetX = x;
				this.offsetY = y;
				this.removeLabels();
				this.drawLabels();
			},
			
			draw: function (x, y) { // offset
				if (x !== undefined)	this.offsetX = x;
				if (y !== undefined)	this.offsetY = y;
				this.removeImageAndLabels();
				this.drawRects();
				this.drawLabels();
			},
			
			drawRects: function () {
				var w = this.width,
					h = this.height,
					k = this.scale,
					cw = Math.ceil(w * k),
					ch = Math.ceil(h * k),
					cvs = this.domCanvas,
					dom = this.domNode,
					fragment = document.createDocumentFragment(),
					row = Math.ceil(ch / STEP_Y),
					col = Math.ceil(cw / STEP_X),
					count = 0;
				
				for (var i = 0; i < row; i++) {
					for (var j = 0; j < col; j++) {
						var window = {
							x: j * STEP_X,
							y: i * STEP_Y,
							w: STEP_X,
							h: STEP_Y
						};
						if (i + 1 === row) { // last row
							window.h = ch - window.y;
						}
						if (j + 1 === col) { // last col
							window.w = cw - window.x;
						}

						cvs.setAttribute('width', window.w);
						cvs.setAttribute('height', window.h);
						var cxt = cvs.getContext("2d");
						cxt.fillStyle = this.bgColor;
						cxt.fillRect(0, 0, window.w, window.h);
						
						var drawPiece = function (e, idx) {
							var rect = e.size;
							if (e.entityChildren === undefined && !e.deleted && intersect(window, rect)) {
								var x1 = Math.max(rect.x - window.x, 0),
									y1 = Math.max(rect.y - window.y, 0),
									x2 = Math.min(rect.x + rect.w - window.x, window.w),
									y2 = Math.min(rect.y + rect.h - window.y, window.h);
								cxt.fillStyle = e.color;
								cxt.fillRect(x1, y1, x2-x1, y2-y1);
							}
							e.idx = idx; // assign each tree node an id
						};

						dfs(this.root, drawPiece, '');
						
						var res = cvs.toDataURL();
						var img = document.createElement('img');
						img.src = res;
						img.style.position = 'absolute';
						img.style.left = window.x + 'px';
						img.style.top = window.y + 'px';
						img.setAttribute("draggable", "false");
						img.setAttribute("orgx", window.x);
						img.setAttribute("orgy", window.y);
						fragment.appendChild(img);
						count++;
					}
				}
				
				cvs.setAttribute('width', 0);
				cvs.setAttribute('height', 0);
				dom.style.width = cw + 'px';
				dom.style.height = ch + 'px';
				dom.appendChild(fragment);
				this.numImages = count;
			},
			
			drawLabels: function () {
				var l = this.attributes.length,
					that = this,
					dom = this.domNode,
					gut = FMT.LGD_GUTTER,
                    padding = FMT.LABEL_PADDING,
					window = {
						x: this.offsetX,
						y: this.offsetY,
						w: this.width,
						h: this.height
					};
				
				var caches = [],
					layout = [{}, {}, {}];
					
				var ext = Math.floor( Math.log(this.scale) / Math.log(2) ); 
				ext = Math.min(ext, l - 3);
				ext = Math.max(ext, 0);
				this._ext = ext; // right shift ext levels, e.g. if scale is 2.0, then we will draw label for level 2,3,4 instead of 1,2,3
				
				var drawText = function (e) {
					if (e === that.root || e.deleted) {
						return;
					}
					
					var rect = e.size,
						w = rect && rect.w,
						h = rect && rect.h;

					if (!intersect(window, rect)) {
						return;
					}
						
					if (w < FMT.LABEL_CTNR_WIDTH_THRES + 2 * FMT.LABEL_PADDING || h < FMT.LABEL_CTNR_THRES) { // the rect is too small to have a label
						return;
					}
					
					var str = e.text,
						idx = e.idx,
						level = e.level - ext;
						
					if (level >= 0 && level < 3) {
						var tw, th, // text width & height
							labelCSS = getLabelCSS(level, l),
							font = CSSATTR[labelCSS].font,
							fontSize = CSSATTR[labelCSS].fontSize,
							o = {
								s: {},
								e: e,
								m: 0, // movement status
								css: labelCSS
							};
							
						if (that.showMetric === true && e.entityChildren === undefined) {
							var loc = {};
							mstrmojo.hash.copy(rect, loc);
							
							if (l > 1 && level === 0) { // has drop shadow
								loc.w -= 2 * gut;
								loc.h -= gut;
							} else {
								loc.w -= 2*padding;
							}
							
							var lh, txtS; // line height
							
							if (that.labelSetting === LABEL.PROPORTIONAL) {
								lh = 9;
								var step = 8,
									shrink = false,
									txtS = that.getTextSize(str, font, lh, true, false, loc.w); // with maximal width constraint

								while (step >= 1) {
									if (txtS.h < loc.h) {
										lh += step;
									} else {
										if (lh === 9) { // 
											break;
										}
										if (lh >= loc.w) {
											break;
										}
										if (!shrink) {
											step /= 2;
										}
										shrink = true;
										lh -= step;
									}
									
									txtS = that.getTextSize(str, font, lh, true, false, loc.w);
									
									if (shrink) {
										step = step >> 1;
									}
								}
								
								if (txtS.h > loc.h && lh > 9) {
									lh--;
								}
								if (lh > loc.w) {
									lh = loc.w;
								}

                                o.fs = lh;
								
							} else {
								lh = fontSize;
							}
							
							o.lh = lh; // line height
							
							txtS = that.getTextSize(str, font, lh, true, false, loc.w);
							
							tw = Math.min(txtS.w, loc.w);
							th = txtS.h;
							
							if (th > loc.h) {
								th = Math.floor(loc.h / lh) * lh;
							}
						} else {
							if (caches[level] === undefined) {
								caches[level] = {};
							}
							
							var cache = caches[level];
								
							if (cache[str] === undefined) {
								var txtS = that.getTextSize(str, font, fontSize, true),
								tw = txtS.w,
								th = txtS.h;
								if (l > 1 && level === 0) {
									tw += 2 * gut;
									th += gut;
								}
								cache[str] = {w: tw, h: th};
							} else {
								tw = cache[str].w;
								th = cache[str].h;
							}
							
							if (th > h) return;
							
							o.lh = th;
							
                            var p ;
                            if (l > 1 && level === 0) {
                                    p = 2 * gut;
                            } else {
                                    p = 2 * padding;
                            }
							if (tw > w - p) {
								var trunw = tw >> 1,
                                    lineCount = Math.floor(h/o.lh);
                                //if half of the string can be put in the rectangle WHEN CHARACTER WRAP IT, it'll be displayed
								if (trunw > (w - p)*lineCount) {
                                        return;
                                }
                                tw = w - p;
                                //the lowest level label, irrespective if they are level 1, level 2 or level 3
                                if( (l == 1 && level == 0) || (l == 2 && level == 1) || (l >2 && level == 2) ) {
                                        //th *= Math.ceil((tw + p)/w);
                                        var ts = that.getTextSize(str, font, fontSize, true, false, w-p, true);
                                        th *= Math.floor(Math.min(ts.h, h) / o.lh);
                                        o.isLowestLevel = true;
                                }
							}
						}
						
						var x = rect.x + ((w - tw) >> 1),
							y = rect.y + ((h - th) >> 1);
						
						o.s = {x: x, y: y, w: tw, h: th};
						layout[level][idx] = o;
					}
					
				};
				
				if (that.labelSetting !== LABEL.OFF) {
					wfs(this.root, drawText);
					this.layoutLabels(layout);
				}
			},
			
			layoutLabels: function (layout) {
				var that = this,
					doc = document,
					fragment = doc.createDocumentFragment();
			
				function generateLabel(o) {
					var s = o.s,
						e = o.e,
						css = o.css,
						color = that.getLabelColor(s, e),
						hasM = o.fs !== undefined;
						
					var div = doc.createElement('div'); // should be no reflow?
					if (hasM) {
                        div.setAttribute('style', 'font-size: ' + o.fs + 'px' + ' !important');
						//div.style.fontSize = o.fs + 'px' + ' !important'; //make sure overwrite other settings
						div.className = css + ' heatmap-showMetric-text';
					} else {
						div.className = css + ' heatmap-trun-text';
					}
					div.style.position = 'absolute';
					div.style.color = color;
					div.style.backgroundColor = 'rgba(255, 255, 255, 0)';
					div.style.zIndex = '1';
					div.style.left = s.x + 'px';
					div.style.top = s.y + 'px';
					div.style.width = s.w + 'px';
					div.style.height = s.h + 'px';
					div.style.lineHeight = o.lh + 'px';
                    if(o.isLowestLevel) {
                            div.style.textOverflow = 'ellipsis';
                            div.style.wordBreak = 'normal';
                    }
					
					
					div.setAttribute("idx", e.idx);
					div.innerHTML = e.text;
					fragment.appendChild(div);
				}
				
				var L0 = layout[0],
					L1 = layout[1],
					L2 = layout[2],
					idx;
				
				for (idx in L1) {
					var info = L1[idx],
						bbox = info.s,
						node = info.e,
						prt = node.parentEntity,
						pinfo = L0[prt.idx];
					
					if (pinfo === undefined) {
                        generateLabel(info);
                        continue;
                    }

					var pbox = pinfo.s,
						inter = rectIntersection(bbox, pbox);
					
					var rmIt = false;
					if (inter.w > 5 || inter.h > 5) { // otherwise accept it
						if (pbox.y <= bbox.y) {
							var delta = ((pbox.y + pbox.h - bbox.y) >> 1) + 1;
							if (pinfo.m !== 2 && (pbox.y - delta >= prt.size.y) && (bbox.y + bbox.h + delta <= node.size.y + node.size.h)) {
								pbox.y -= delta;
								bbox.y += delta;
								pinfo.m = 1;
							} else {
								rmIt = true;
							}
						} else {
							var delta = ((bbox.y + bbox.h - pbox.y) >> 1) + 1;
							if (pinfo.m !== 1 && (pbox.y + pbox.h + delta <= prt.size.y + prt.size.h) && (bbox.y - delta >= node.size.y)) {
								pbox.y += delta;
								bbox.y -= delta;
								pinfo.m = 2;
							} else {
								rmIt = true;
							}
						}
					}
					
					if (rmIt !== true) {
						generateLabel(info);
					}
				}

				for (idx in L0) { // always create level 0 labels directly
					generateLabel(L0[idx]);
				}
				
				for (idx in L2) {
					rmIt = false;
					
					var info2 = L2[idx],
						node2 = info2.e,
						node1 = node2.parentEntity,
						node0 = node1.parentEntity,
						idx1 = node1.idx,
						idx0 = node0.idx,
						info1 = L1[idx1],
						info0 = L0[idx0];
						
					if (info1 !== undefined) {
						var inter12 = rectIntersection(info1.s, info2.s);
						if (!isNaN(inter12.w)) {
							rmIt = true;
						}
					}
					if (rmIt === false && info0 !== undefined) {
						var inter02 = rectIntersection(info0.s, info2.s);
						if (!isNaN(inter02.w)) {
							rmIt = true;
						}
					}
						
					if (rmIt !== true) {
						generateLabel(info2);
					}
				}
				
				this.domNode.appendChild(fragment);
			},
			
			getLabelColor: function (s, e) {
				var level = e.level - this._ext;
				if (level === 0) {
					return '#FFFFFF';
				}
			
				var ct = this.colorTheme;
				if (e.entityChildren === undefined) {
					return getCSSColor(ct.getContrastColor( parseInt(e.color.substring(1, e.color.length), 16) ));
				}
			
				var stack = [e],
					ls = 0,
					ds = 0;
			
				while (stack.length !== 0) {
					var node = stack.shift(),
						ch = node.entityChildren,
						n = node.entityChildren.length;
					
					for (var i=0; i<n; i++) {
						var child = ch[i];
						if (child.deleted)	continue;
						
						var rect = rectIntersection(s, child.size);
						if (child.entityChildren === undefined) {
							if (!isNaN(rect.w)) {
								if (ct.isBrightColor( parseInt(child.color.substring(1, child.color.length), 16) )) {
									ls += rect.w * rect.h;
								} else {
									ds += rect.w * rect.h;
								}
							}
						} else {
							if (!isNaN(rect.w)) {
								stack.push(child);
							}
						}
					}
				}
				
				if(ls > ds){
					return '#000000';
				} else {
					if (level === 1) {
						return '#e6e7e8';
					} else {
						return '#d1d3d4';
					}
				}
			},
			
			getEntity: function (pos) {
				var ox = pos.x,
					oy = pos.y,
					target;
					
				var hitTest = function (node) {
					if (node.entityChildren === undefined && !node.deleted && node.size) {
						var size = node.size,
							x1 = size.x,
							y1 = size.y,
							x2 = x1 + size.w,
							y2 = y1 + size.h;
						
						if (ox >= x1 && ox <= x2 && oy >= y1 && oy <= y2) {
							target = node;
						}
					}
				};
				
				var dfsReturnOnFound = function (root, f) {
					if(root.deleted) {
						return;
					}
					
					f(root);
					
					var arr = root.entityChildren;
					if (arr !== undefined) {
						var l = arr.length;
						for (var i = 0; i < l; i++) {
							var e = arr[i];
							dfsReturnOnFound(e, f);
							if (target !== undefined) {
								return;
							}
						}
					}
				};
				
				dfsReturnOnFound(this.root, hitTest);
				
				return target;
			},
			
			initCSSATTR: function () {
				if (CSSATTR.init === false) {
					var dom = this.domSpan;
					for (var css in CSSATTR) {
						if (css === 'init')	continue;
						dom.setAttribute('class', css);
						var res = document.defaultView.getComputedStyle(dom);
						CSSATTR[css].fontSize = parseInt(res['fontSize']);
						CSSATTR[css].font = res['fontFamily'];
					}
				}
			},
			
			getTextSize: function (str, fontName, fontSize, isBold, isItalic, width, normalBreak) {
				var dom = this.domSpan,
                    breakMethod = 'break-all';
                if (normalBreak) {
                        breakMethod = 'normal';
                }

                dom.className = '';
				dom.innerHTML = str;
				dom.style.cssText = "position:absolute; visibility:hidden; z-index:-1; font-family:" + fontName + 
				"; font-size:" + fontSize + "px; font-weight:" + (isBold ? 'bold' : 'normal') + 
				"; font-style:" + (isItalic ? 'italic' : 'normal') + "; line-height:" + fontSize + "px;";
				
				var w = dom.offsetWidth;
				if (width !== undefined && w > width) {
					dom.style.cssText += "overflow:hidden; word-break:" + breakMethod + "; width:" + width + "px;";
					w = dom.offsetWidth;
				}
				
				return {w: w, h: dom.offsetHeight};
			}
		}
	);

})();
(function () {
        mstrmojo.requiresCls("mstrmojo._HasTouchScroller",
                             "mstrmojo.dom");

        var $D = mstrmojo.dom;

        function rectIntersection(a, b) {
                var x = Math.max(a.x, b.x);
                var y = Math.max(a.y, b.y);
                var w = Math.min(a.x + a.w, b.x + b.w) - x;
                var h = Math.min(a.y + a.h, b.y + b.h) - y;
                if (w < 0 || h < 0) {
                        return {
                                x : NaN,
                                y : NaN,
                                w : NaN,
                                h : NaN
                        };
                }
                return {
                        x : x,
                        y : y,
                        w : w,
                        h : h
                };
        }

        function copyRect (a){
                return {x: a.x, y: a.y, w: a.w, h: a.h};
        }

        mstrmojo.SmoothScroll = mstrmojo.provide(
                //null,
                //[mstrmojo._HasTouchScroller],
                "mstrmojo.SmoothScroll",
                {

                        //scriptClass: "mstrmojo.SmoothScroll",
                        //all the points are in document page corrdinate system
                        viewRect: null,
                        
                        scrollerRect: null,

                        // "[)" for the adjacent area
                        unitRect: null,

                        cachedUnits: [],

                        demarcationUnits: {left: null, right: null, top: null, bottom: null},

                        //cut the nodes outside the viewRect, cache them in cachedUnits and set demarcationUnits 
                        viewCutX: function(){
                        },

                        storeUnits: function() {
                                this.cachedUnits = [];
                                var ir = copyRect(this.unitRect),
                                    len = Math.ceil(this.scrollRect.h / ir.h),
                                    i;

                                for(i = 0; i < len; i++, ir.y += ir.h){
                                        //var isr = rectIntersection(ir, this.viewRect),
                                        var unit = this.getUnitFromPoint(ir.x + ir.w/2, ir.y+ir.h/2);
                                        if(!unit){
                                                continue;
                                        }
                                        this.cachedUnits.push(unit);
                                        /*if(!isr){// outside
                                                unit.outside = true;
                                        }else{// inside
                                                unit.outside = false;
                                        }*/
                                }
                        },

                        appendUnits: function(i1, i2) {
                                var cus  = this.cachedUnits,
                                    i;
                                for(i = i1; i <= i2; i++){
                                        var unit = cus[i];
                                        if(!unit){
                                                return ;
                                        }
                                        if(unit.outside == true){
                                                unit.outside = false;
                                                var p = unit._parentNode,
                                                    cn = p.children;
                                                p.insertBefore(unit, cn[unit._oldIndex]);
                                                p.style.paddingTop = '';
                                                delete unit._parentNode;
                                                delete unit._oldIndex;
                                        }
                                }
                                console.log(i2-i1+1 + ' units added.');
                        },
                        removeUnits: function(i1, i2) {
                                var cus  = this.cachedUnits,
                                    i;
                                for(i = i1; i <= i2; i++){
                                        var unit = cus[i];
                                        if(!unit){
                                                return ;
                                        }
                                        if(unit.outside != true){
                                                var p = unit.parentNode,
                                                    cn = p.children;
                                                unit._parentNode = p;
                                                //unit._oldIndex = cn.indexOf(unit);
                                                unit._oldIndex = 0;
                                                p.removeChild(unit);
                                                p.style.paddingTop = this.unitRect.h + 'px';
                                                unit.outside = true;
                                        }
                                }
                                console.log(i2-i1+1 + ' units removed.');
                        },
                                    

                        //offset to _scroller
                        viewCutY: function(e) {
                                if(!this.viewRect || !this.scrollRect || !this.unitRect){
                                        return;
                                }
                                var y1 = e ? e.y : this._scroller.origin.y,
                                    y2 = y1 + this.viewRect.h;
                                if(!this._scroller || !this._scroller.scrollEl){
                                        console.log("no scrollEl.");
                                        return ;
                                }

                                var scrollEl = this._scroller.scrollEl;

                                var i1 = Math.floor(y1 / this.unitRect.h),
                                    i2 = Math.floor(y2 / this.unitRect.h),
                                    cus = this.cachedUnits,
                                    len = cus.length;
                                    delta = 0;//blank space left or taken away
                                this.removeUnits(0,i1-1);
                                /*if(cus[0]._parentNode){
                                        cus[0]._parentNode.style.paddingTop = i1 * this.unitRect.h + 'px';
                                }*/
                                this.appendUnits(i1,i2);
                                this.removeUnits(i2+1, len);
                                /*if(cus[len-1]._parentNode){
                                        cus[len-1]._parentNode.style.paddingBottom = (len-i2) * this.unitRect.h + 'px';
                                }*/
                                delta = i1;
                                //scrollEl.style.webkitTransform = 'translate(0,' + delta*this.unitRect.h - y1 + ')'; 
                                console.log("do viewCut.");
                        },

                        updateScroller: function(o, d) {
                                if(this._super){
                                        this._super(o, d);
                                }
                                var $P = mstrmojo.dom.position;
                                if(!this.unitRect || !this.unitRect.w || !this.unitRect.h){
                                        var su = this.cachedUnits[0];
                                        if(!su){
                                                return ;
                                        }
                                        this.unitRect =  $P(su);
                                }
                                if(this.viewNode){
                                        this.viewRect = $P(this.viewNode);
                                }
                                this.scrollRect = {x: this.unitRect.x, y: this.unitRect.y, w: this.unitRect.w, h:this.unitRect.h * this.cachedUnits.length}; 
                                if(!this.viewRect || !this.scrollRect || !this.unitRect){
                                        return;
                                }
                                //this.storeUnits();
                                this.viewCutY(this._scroller.origin);
                        },
                        

                        getUnitFromPoint: function (x, y) {
                                var cache = [],
                                    found = false;
                                do{
                                        var target = document.elementFromPoint(x,y);
                                        if(target == lastTarget){
                                                break;
                                        }
                                        if(target.offsetHeight == this.unitRect.h && target.offsetWidth == this.unitRect.w){
                                                found = true;
                                        }else{
                                                target.__metaDisplay = target.style.display;
                                                cache.push(target);
                                                target.style.display = 'none';
                                        }
                                        var lastTarget = target;
                                }while(!found && target != document.body);
                                
                                var ret = target;
                                
                                while(cache.length){
                                        var target = cache.pop();
                                        target.style.display = target.__metaDisplay;
                                        delete target.__metaDisplay;
                                }

                                if(found){
                                        return ret;
                                }else{
                                        return null;
                                }
                        },

                        //todo: add event listener to "scrollMoved"
                        postBuildRendering: function(c) {
                                if(this._super){
                                        this._super(c);
                                }
                                console.log("event binded!");
                                this.smoothSwipeListener = this._scroller.attachEventListener("scrollMoved", this.id, this.viewCutY);
                        },

                        unrender: function () {
                                //this._scroller.detachEventListener(this.smoothSwipeListener);
                                if(this._super){
                                        this._super();
                                }
                        }






                        










                }
        );
        /*mstrmojo._HasSmoothScroll = mstrmojo.provide(
                "mstrmojo._HasSmoothScroll",
                new mstrmojo.SmoothScroll()
        );*/
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.selectors.MobileSliderSelector",
                         "mstrmojo.hash");
    
    var $M = mstrmojo.android.selectors.MobileSliderSelector,
        $F = $M.FLAGS,
        $T = $M.TYPES;
    
    /**
     * Widget for displaying slider items selector for the Android platform.
     * 
     * @class
     * @extends mstrmojo.android.selectors.MobileSliderSelector
     */
    mstrmojo.android.selectors.Slider = mstrmojo.declare(

        mstrmojo.android.selectors.MobileSliderSelector,

        null,
        
        /**
         * @lends mstrmojo.android.selectors.Slider
         */
        {
            scriptClass: "mstrmojo.android.selectors.Slider",
            
            items : $F.UNSET,
            
            initState: function initState() {
                if (!!this.items) {
                    //Clear cached values issue #497643
                    this.leftStep = this.rightStep = this.singleStep = null;
                    
                    this.set('type', (!this.multiSelect) ? $T.SINGLE : (this.include) ? $T.INCLUDE : $T.EXCLUDE);
                    this.set('steps', this.items.length);
                    this.value = null;
                    this.set('value', this.selectedIndices);
                }
            },
            
            /**
             * If the value changed, update the steps to trigger GUI update.
             */
            onvalueChange : function onvalueChange() {
                var values = this.value,
                    mn = mstrmojo.hash.any(values, true),
                    mx = mn;
                
                if (this.type === $T.SINGLE) {
                    this.set('singleStep', parseInt(mn) || 0);
                    
                } else {
                    var p;
                    
                    for (p in values) {
                        mn = Math.min(p, mn);
                        mx = Math.max(p, mx);
                    }
                    
                    // Default to zero.
                    mn = mn || '0';
                    if (mx === undefined || mx === null) {                        
                        mx = String(this.steps - 1);
                    }
                    
                    this.set('leftStep', parseInt(mn, 10));         // leftStep is inclusive
                    this.set('rightStep', parseInt(mx, 10) + 1);    // rightStep is exclusive
                }
            },
            
            /**
             * The steps just changed, select the values using the _ListSelections mixin
             */
            flushSelections: function flushSelections() {
                if (this.type === $T.SINGLE) {
                    this.select([ this.singleStep ]);
                    
                } else {
                    var s = [],
                        i = this.leftStep;
                    
                    for (; i < this.rightStep; i++) {
                        s.push(i);
                    }
                    
                    this.select(s);
                }
            },
            
            /**
             * Update the summary based on the steps
             * singleStep : optional, provided when in single mode
             * leftStep : optional, provided when in include/exclude mode
             * rightStep : optional, provided when in include/exclude mode
             */
            buildSummary: function buildSummary(singleStep, leftStep, rightStep) {
                var items = this.items,
                    s = (singleStep !== null) ? singleStep : leftStep;
                
                // Is selector unset?
                if (s === undefined || s === null || isNaN(s) || !items.length) {
                    // No summary to build so exit.
                    return;
                }
                
                var summary = (singleStep === null && leftStep !== rightStep - 1) ? items[leftStep].n + " - " + items[rightStep - 1].n : (items[s] && items[s].n) || '';
                
                this.summary.innerHTML = summary;
                
                return summary;
            }
            
        }
    );
    
}());
(function(){
    
    mstrmojo.requiresCls(
            "mstrmojo.css",
            "mstrmojo.array",
            "mstrmojo.dom",
            "mstrmojo._TouchGestures",
            "mstrmojo.SmoothScroll",
            "mstrmojo._HasTouchScroller"
    );
    
    var PAD_STEP = 16; // xiawang: This is used to represent how much pixels we need to step right for each level
    
    // var STATE_TEXT_WIDTH = 25;
    
    var NODE_STATE_TEXT_MAP = {
        0: "&#9654;", // Left Arrow for Collapsed Node
        1: "&#9660;",  // Down Arrow for Expanded Node
        2: "&nbsp;" // Space for Leaf Node
    }; // xiawang: This is obsoleted as different device shows different symbol effect. So we will switch back to use images
    
    var NODE_STATE_CSS_MAP = ["heatmap-tree-state-text collapsed", "heatmap-tree-state-text expanded", "heatmap-tree-state-text leaf"];
    
    var SELECTION_STATUS = {
    	NO: 0,
    	YES: 1,
    	PART: 2
    };
    
    
    /**
     * TreeBrowser is a widget allowing to browse into the tree hierarchy of objects. 
     * Working with TreeBrowserNode, it supports on-demand content request and incremental fetch/rendering. It is noted that unlike 
     * its parent class, this class supports selections across different branches. It allows selections across different branches of the tree. 
     * The behavior can be reverted by setting selectionAcrossBranch to be false. You can turn off the checkBoxNode in TreeBrowserNode by setting
     * the noCheckBox to be true for this class. 
     */
    mstrmojo.VisHeatMapTreeItem = mstrmojo.declare(
        // superclass
    	mstrmojo.Container, // Container
        // mixins
        null,
        {
            scriptClass:'mstrmojo.VisHeatMapTreeItem',
            
            
            isRoot: false,
            
            
            showRoot: false,
            
            
            rootText: "",
            
            
            idx: 0,
            
            
            buttonNodeCss: "heatmap-tree-checkbox",
            
            
            buttonNodeWidget: null,
            
            
            /**
             * @ignore
             */
            markupString: '<div id="{@id}" class="heatmap-tree" style="{@cssText}">'
                            + '<div class="heatmap-tree-div" idx="{@idx}">'
                            	+ '<div class="heatmap-tree-state">' 
                            		+ '<div class="heatmap-tree-state space">&nbsp;</div>'
                            		+ '<div class="heatmap-tree-state-text"></div>'
                            	+ '</div>'
                            	+ '<div class="heatmap-tree-text"></div>'
                            	+ '<div class="{@buttonNodeCss}">&nbsp;</div>'
                            + '</div>'
                            + '<div class="heatmap-tree-container"></div>'
                            + '</div>',
            
            /**
             * @ignore
             */
            markupSlots: {
                contentNode: function(){return this.domNode.firstChild;},
                stateNode: function(){return this.domNode.firstChild.firstChild;},
                stateSpaceNode: function(){return this.domNode.firstChild.firstChild.firstChild;},
                stateTextNode: function(){return this.domNode.firstChild.firstChild.lastChild;},
                textNode: function(){return this.domNode.firstChild.childNodes[1];},
                buttonNode: function(){return this.domNode.firstChild.childNodes[2];},
                containerNode: function(){return this.domNode.lastChild;}
            },
            
            markupMethods: {
                ontextChange: function(){ this.textNode.innerHTML = this.text;},
                onstateChange: function(){
                    // this.stateTextNode.innerHTML = NODE_STATE_TEXT_MAP[this.state];
                	this.stateTextNode.className = NODE_STATE_CSS_MAP[this.state];
                	//heatmap-tree-state-text
                	// heatmap-tree-state
                    if (!this.isRoot) {
                    	this.containerNode.style.display = (this.state === 1) ? 'block' : 'none';
                    	if (this.state != 2) {
                    		this.tree.resized();
                    	}
                    }
                }
            },
            
            
            level: -1,
            
            
            tree: null,
            
            
            itemDisplayField: "n",
            
            
            itemChildrenField: "items",
            
            
            isSelectable: true,
            
            
            itemFunctionField: "itemFunction",
            
            
            itemIncludeFunction: function () {return true;}, // users of this class could overwrite this function so specify what items should be included
            
            
            dataProvider: null, // if data provider is provided, we will use this to load items and bind view to data
            
            
            owner: null, // point to widget

			fillData: function() {
            	var tree = this.tree || this;
            	if (this.dataProvider) {
            		this.items = this.dataProvider[this.itemChildrenField];
            		
            	}
            	var items = this.items;
            	// xiawang: TODO 
            	if (this.items && this.items.length) { // for non-leaf node
            		this.childTree = [];
					//this.itemPlaceHolders = [];
            		var childIndex = 0; // xiawang: we now some of the item might not be included, we use childIndex other than i to store the childTree
                	for (var i = 0; i < items.length; i++) {
                		var item = items[i];
                		if (this.itemIncludeFunction(item)) {
	                		//var placeholder = document.createElement("div");
	                		//this.containerNode.appendChild(placeholder);
							//this.itemPlaceHolders.push(placeholder);
	                		var text;
	                		if (tree.owner) {
	                			//text = tree.owner.getEntityDisplayName(item);
                                text = item.label;
	                		} else {
	                			text = item[this.itemDisplayField];
	                		}

                            var d = new Date();
                            var t1 = (new Date()).getTime();
	                		/*var iw = new mstrmojo.VisHeatMapTreeItem({
	                				idx: childIndex,
	                				isRoot: false,
	                				text: text,
	                				itemFunction: item[this.itemFunctionField],
	                				buttonNodeWidget: item["buttonNodeWidget"],
	                				tree: tree,
	                				level: (this.level + 1),
	                				itemDisplayField: this.itemDisplayField,
	                                itemChildrenField: this.itemChildrenField,
	                                parent: this,
	                                parentTree: this,
	                                state: 0,
	                                //placeholder: placeholder,
	                                isSelectable: this.isSelectable,
	                                itemIncludeFunction: this.itemIncludeFunction,
	                                buttonNodeCss: this.buttonNodeCss
	                			});*/

	                		var iw = {
	                				idx: childIndex,
	                				isRoot: false,
	                				text: text,
	                				itemFunction: item[this.itemFunctionField],
	                				buttonNodeWidget: item["buttonNodeWidget"],
	                				tree: tree,
	                				level: (this.level + 1),
	                				itemDisplayField: this.itemDisplayField,
	                                itemChildrenField: this.itemChildrenField,
	                                parent: this,
	                                parentTree: this,
	                                state: 0,
	                                //placeholder: placeholder,
	                                isSelectable: this.isSelectable,
	                                itemIncludeFunction: this.itemIncludeFunction,
	                                buttonNodeCss: this.buttonNodeCss,
                                    //add method
                                    fillData: this.fillData,
                                    buildTree: this.buildTree,
                                    setChildStatus : this.setChildStatus,
                                    updateSelection : this.updateSelection
                                    
	                			};

                            //newTime += (new Date()).getTime() - t1;
	                		
	                		if (this.dataProvider) { // if in data provider mode, we set data provider
	                			iw.dataProvider = item;
	                		} else { // if in normal mode, we set items directly
	                			iw.items = item[this.itemChildrenField];
	                		}
	                		this.childTree[childIndex] = iw;
	                		//iw.render();
	                		childIndex++;
                		}
                	}
            	}
				
            
			},
			/*preBuildRendering: function () {
				this.fillData();
				if(this._super)
					this._super();
                    },*/

            renderChildrenList: function(){
                    if(!this.childTree)
                            return;
                    var len = this.childTree.length,
                        insertIndex,
                        cachedUnits;
                    if(this.tree){
                            cachedUnits = this.tree.cachedUnits;
                            insertIndex = cachedUnits.indexOf(this.contentNode) + 1;
                            if(insertIndex == 0){
                                    insertIndex = cachedUnits.length;
                            }

                    }
                    if(this.isRoot && this.showScrollbars){
                            insertIndex = 0;
                            cachedUnits = this.cachedUnits;
                    }
                    for(var i = 0; i< len; i++){
                            if(this.childTree[i].domNode){
                                    this.tree.cachedUnits.splice(insertIndex, 0, this.childTree[i].contentNode);
                                    insertIndex ++;
                                    continue;
                            }
                            var div = document.createElement('div');
                            this.containerNode.appendChild(div);
                            this.childTree[i].placeholder = div;
                            var treeItem = new mstrmojo.VisHeatMapTreeItem(this.childTree[i]);
                            if(!treeItem)
                                    alert("new failed!");
                            treeItem.childTree = this.childTree[i].childTree;
                            if(treeItem.childTree){
                                    var child = treeItem.childTree,
                                        clen = child.length;
                                    for(var j = 0; j < clen; j++){
                                            child[j].parent = treeItem;
                                            child[j].parentTree = treeItem;
                                    }
                            }

                            this.childTree[i] = treeItem;

                            this.childTree[i].render();

                            if(!isNaN(insertIndex)){
                                    cachedUnits.splice(insertIndex, 0, this.childTree[i].contentNode);
                                    insertIndex ++;
                            }
                    }
            },


            
            postBuildRendering: function () {
            	if(this._super) {
                	this._super();
                }
            	
                //hide it first to reduce some unnecessary reflows
                this.domNode.style.display = 'none';

            	var tree = this.tree || this;
            	if (this.dataProvider) {
            		this.items = this.dataProvider[this.itemChildrenField];
            		
            	}
            	//var items = this.items;
            	// xiawang: TODO 

				/*var placeHolders = this.itemPlaceHolders;
				if(placeHolders)
					var plL = placeHolders.length;
					
				for(var i = 0; i< plL; i++){
						this.containerNode.appendChild(placeHolders[i]);
						this.childTree[i].render();
				}*/
					
            	if (this.isRoot) {
            		if (!this.showRoot) {
            			this.contentNode.style.display = "none";		
            		} else {
            			this.stateNode.style.display = "none";
            			this.textNode.innerHTML = this.rootText;
            		}
            		this.containerNode.className = "heatmap-tree-container root";
            	} else {
	            	if (this.buttonNodeWidget) {
	            		this.buttonNodeWidget.placeholder = this.buttonNode;
	            		var buttonWidget = mstrmojo.insert(this.buttonNodeWidget);
	            		buttonWidget.render();
	            		this.buttonNode = buttonWidget.domNode;
	            	}
	        		this.textNode.innerHTML = this.text;
	            	var padLeft = (this.level + 1) * PAD_STEP; // level start from 0
	            	this.stateSpaceNode.style.width = (padLeft >= 0? padLeft: 0) + "px"; 
	            	// this.stateTextNode.style.width = STATE_TEXT_WIDTH + "px";
	            	this.textNode.style.width = this.domNode.offsetWidth - this.stateNode.offsetWidth - this.buttonNode.offsetWidth - 10 + "px";

            	}
                //if(this.parent && this.parent.isRoot){
                if (!(this.items && this.items.length)) {
                        this.set("state", 2); // leaf node
                        this.tree.sampleUnit = this.domNode;
                } else {
                        this.set("state", 0); // close for non-leaf node
                }
                /*}else{
                        if (!(this.items && this.items.length)) {
                                //this.set("state", 2); // leaf node
                                this.state = 2;
                        } else {
                                //this.set("state", 0); // close for non-leaf node
                                this.state = 0;
                        }
                }*/                       

				/*if((!this.items || this.items.length == 0) && !this.showRoot)
					this.domNode.style.display = "none";
				else
					this.domNode.style.display = "block";*/
                this.domNode.style.display = 'block';
            },
            buildTree: function() {
                    this.fillData();

                    if(this.childTree)
                            var len = this.childTree.length;
                    for(var i = 0; i < len; i++)
                            this.childTree[i].buildTree();
            },

            
            clickHandler: function (evt) {
                    //if(!this.childTree)
                            //this.buildTree();
                    var target = evt.target;
                    if (this.state !== 2 && mstrmojo.dom.contains(this.stateNode, target, true, this.domNode)) {
                            this.set("state", this.state === 0 ? 1 : 0);
                            if(this.state == 1){
                                    /*var childTree = this.childTree,
                                      len = childTree && childTree.length;
                                      if(!isNaN(len)){
                                      for(var i = 0; i < len; i++){
                                      var treeNode = childTree[i]
                                      state = treeNode.state;
                                      treeNode.set('state',state); 
                                      }
                                      this.tree.resized();
                                      this.tree.updateScroller();
                                      }*/
                                    this.renderChildrenList();
                                    this.updateChildrenSelection();
                            }else{
                                    var deleteIndex = this.tree.cachedUnits.indexOf(this.contentNode);
                                    if(deleteIndex != -1){
                                            deleteIndex ++;
                                            var len = this.childTree.length;
                                            this.tree.cachedUnits.splice(deleteIndex,len);
                                    }
                            }
                            this.tree.resized();
                            this.tree.updateScroller();
                            return;
                    }
                    // else, update selection
                    if (this.itemFunction) {
                            this.itemFunction(evt);
                    }
                    if (!this.isSelectable) {
                            return;
                    }
                    // else, show a blue background for the whole row and fades out in 0.5s
                    mstrmojo.VisHeatMapAnimation.animate(this.contentNode, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});

                    if (this.selectionStatus === SELECTION_STATUS.YES) { // if original is YES, set to NO
                            this.selectionStatus = SELECTION_STATUS.NO;
                    } else { // if original is NO or PART, set to YES
                            this.selectionStatus = SELECTION_STATUS.YES;
                    }
                    this.setChildStatus(this.selectionStatus);
                    this.updateSelection(false, true);
            },

            
            setChildStatus: function (/* SELECTION_STATUS*/ status) {
            	if (this.childTree) {
	            	for (var i = 0; i < this.childTree.length; i++) {
	            		var item = this.childTree[i];
                        if(!item)
                                continue;
	            		item.selectionStatus = status;
	            		item.setChildStatus(status);
	            		item.updateSelection(false, false);
	            	}
            	}
            },

            updateChildrenSelection: function(){
                    if(!this.childTree)
                            return ;
                    var len = this.childTree.length;
                    for(var i = 0; i < len; i++)
                    if(this.childTree[i])
                            this.childTree[i].updateSelection(false,false);
            },
            
            
            updateSelection: function (/* Boolean */ checkChild, /* Boolean*/ callParent) {
            	if (checkChild && this.childTree) {
	            	var allSelected = true;
	            	var noSelected = true;
	            	var partSelected = false;
	            	for (var i = 0; i < this.childTree.length; i++) {
	            		var item = this.childTree[i];
	            		if (allSelected && item.selectionStatus !== SELECTION_STATUS.YES) {
	            			allSelected = false;
	            		}
	            		if (noSelected && item.selectionStatus !== SELECTION_STATUS.NO) {
	            			noSelected = false;
	            		}
	            		if (!allSelected && !noSelected) {
	            			partSelected = true;
	            			break;
	            		}
	            	}
	            	this.selectionStatus = allSelected? SELECTION_STATUS.YES: (noSelected? SELECTION_STATUS.NO: SELECTION_STATUS.PART);
            	}
            	var cssClass = "heatmap-tree-div";
            	switch (this.selectionStatus) {
            		case SELECTION_STATUS.YES:
            			cssClass += " selected";
            			break;
            		case SELECTION_STATUS.PART:
            			cssClass += " partSelected";
            			break;
            		case SELECTION_STATUS.NO:
            		default:
            			break; // do nothing
            	}
            	
                this.cssName = cssClass;
                if(this.contentNode)
                        this.contentNode.className = cssClass;
            	if (callParent && this.parentTree) {
            		this.parentTree.updateSelection(true, true);
            	}
            	if (this.isRoot) { // when selection status get updated, call notifyAll() for root tree
            		this.notifyAll();
            	}
            },
            
            
            resized: function () {
            	if (this.parent.resized) {
            		this.parent.resized(this.domNode.offsetHeight);
            	}
            },
            
            
            selectionStatus: SELECTION_STATUS.NO         
        });
    
    
    mstrmojo.VisHeatMapTree = mstrmojo.declare(
    		
    		mstrmojo.VisHeatMapTreeItem,
    		[mstrmojo._TouchGestures, mstrmojo._HasTouchScroller, mstrmojo.SmoothScroll],
    		
        	{
        		scriptClass: "mstrmojo.VisHeatMapTree",
        		
        		
                isRoot: true,
                
                
                showRoot: false,
                
                
                rootText: "",
                
                
                heightLimit: 0, // 0 means no limit. Otherwise, we will limit the total height of the tree
                
                
                defaultSelectionStatus: SELECTION_STATUS.NO,
                
                
                markupString: '<div id="{@id}" class="heatmap-tree root {@cssClass}" style="{@cssText} mstrAttach:mousedown,mousemove,mouseup,click">' +
					                '<div class="heatmap-tree-div" style="line-height:40px;" idx="{@idx}">' +  // for root 
	                            		'<div class="heatmap-tree-state" style="display:none;">'  +
	                            			'<div class="heatmap-tree-state space">&nbsp;</div>' +
	                            			'<div class="heatmap-tree-state-text"></div>' +
	                            		'</div>' +
					            		'<div class="heatmap-tree-text"></div>' + 
					            		'<div class="{@buttonNodeCss}">&nbsp;</div>' +
					            	'</div>' +
					            	'<div style="overflow:hidden; position:relative">' + // this is the scroller box;
					            			'<div class="heatmap-tree-container"></div>' + // this is the scroller
                					'</div>' +
    					       '</div>',

    			markupSlots: {
                    contentNode: function(){return this.domNode.firstChild;},
                    stateNode: function(){return this.domNode.firstChild.firstChild;},
                    stateSpaceNode: function(){return this.domNode.firstChild.firstChild.firstChild;},
                    stateTextNode: function(){return this.domNode.firstChild.firstChild.lastChild;},
                    textNode: function(){return this.domNode.firstChild.childNodes[1];},
                    buttonNode: function(){return this.domNode.firstChild.childNodes[2];},
                    scrollboxNode: function(){return this.domNode.lastChild;},
                    containerNode: function(){return this.domNode.lastChild.firstChild;}
    			},
    			
    			initialized: false,
    			
    			
    			dirty: false,

                showIndicators: false, 

                showScrollbars: false,

                cachedUnits: [],
    			
    			
    			/*initScroller: function (scroller) {
                        if(this.isRoot)
                                this.scrollerConfig.scrollEl = this.containerNode;
    			},*/
    			
    			init: function (config) {
    				this._super(config);
    				this.observer = []; // set an observer array
    			},
    			
    			register: function (widget) {
    				this.observer.push(widget);
    				this.notifyAll();
    			},
    			
    			notifyAll: function () {
    				var enabled = false;
    				if (this.childTree && this.childTree.length > 0) { // if has child
    					enabled = true;
    				}
    				// for the root node, if there is no childTree, we should set it disabled
    				if (enabled) {
    					mstrmojo.css.removeClass(this.contentNode, "disabled");
    				} else {
    					mstrmojo.css.addClass(this.contentNode, "disabled");
    				}
    				// now we will also check if there is any selection there. If no, we will always set it to disabled
    				if (this.selectionStatus === SELECTION_STATUS.NO) {
    					enabled = false;
    				}
    				for (var index in this.observer) {
    					this.observer[index].notify(enabled);
    				}
    			},

                buildRendering: function() {
                        if(this.isRoot){
                                this.cachedParent = this.parent;
                                delete this.parent;
                        }
                        if(this._super)
                                this._super();
                },
    			
    			postBuildRendering: function () {


                        var t0 = (new Date()).getTime();
    				

                    if(this.isRoot){
                            this.scrollerConfig = {
                                    bounces : false,
                                    showIndicators: this.showIndicators,
                                    showScrollbars : this.showScrollbars,
                                    useTranslate3d : true,
                                    vScroll: true,
                                    hScroll: false,
                                    offset : {
                                            y: {
                                                    start: 0,
                                                    end: 0 
                                            },
                                            x: {
                                                    start: 0,
                                                    end: 0
                                            }
                                    },
                                    origin: {
                                            x: 0,
                                            y: 0
                                    },
                                    scrollEl : this.containerNode
                            };
                    }

                    //this.buildTree();

                    //var t1 = (new Date()).getTime();

    				this._super();




                    //console.log("Profiling:  super() "+ ((new Date()).getTime() - t1)); 

                    //t1 = (new Date()).getTime();

                    //this.fillData();

                    //newTime = 0;
                    this.buildTree();

                    //console.log("Profiling:  buildTree() "+ ((new Date()).getTime() - t1)); 
                    //console.log("Profiling:  new Object time "+ newTime); 




                    //t1 = (new Date()).getTime();
                    this.renderChildrenList();
                    //console.log("Profiling:  renderChildrenList() "+ ((new Date()).getTime() - t1)); 

                    //this.tree.resized();
                    //this.tree.updateScroller();
                    if(this.isRoot){
                            this.parent = this.cachedParent;
                            this.parent.containerNode.appendChild(this.domNode);
                    }

    				// apply height Limit if set
    				if (this.heightLimit > 0) {
    					var limit = this.heightLimit - this.contentNode.offsetHeight - 2; // offset for border
    					if (limit >= 0) {
    						this.scrollboxNode.style.maxHeight = limit + "px";
    					}
    				}

                    // set default selection
    				this.selectionStatus = this.defaultSelectionStatus;
            		this.setChildStatus(this.selectionStatus);
                	this.updateSelection(false, true);
            		
                    //for SmoothScroll
                    this.viewNode = this.scrollboxNode;

    				this.notifyAll();
                    this.resized();
                    this.updateScroller();


                    //t1 = (new Date()).getTime();
                    //console.log("Profiling:  postBuildRendering  "+ (t1 - t0)); 


					//this._scroller.showScrollbars = true;
					//this._scroller.offset.y.end = this.containerNode.offsetHeight ;
    				//	this._scroller.offset.y.end = childHeight - this.scrollboxNode.offsetHeight;

    			},

    			touchTap: function (event) {
    				var title = mstrmojo.dom.findAncestorByAttr(event.target, "id", true, this.domNode);
    				if (!title) { // if click on the tree root node
    					//if (this.childTree && this.childTree.length > 0) { // if has child, set the status
    						this.clickHandler(event);
    					//} else { // if no child, do nothing
    						// alert("no child!");
    					//}
    					return;
    				}
    				var item = mstrmojo.all[title.value];
    				if (item && item.clickHandler) {
    					item.clickHandler(event);
    				}
    			},
    			
    			resized: function ( childHeight) {
                    //this.updateRects();
                    var $P = mstrmojo.dom.position;
                    if(!this.viewRect){
                            this.viewRect = $P(this.scrollboxNode, true);
                    }
    				if (!(this.heightLimit > 0)) { // no action is height limit is not set
    					return;
    				}

                    if(!this._scroller.offset){
                            return;
                    }

    				childHeight = childHeight || this.containerNode.offsetHeight;
    				if (childHeight > this.scrollboxNode.clientHeight) {
    					this._scroller.offset.y.end = childHeight - this.scrollboxNode.clientHeight ;
    				} else {
    					this._scroller.offset.y.end = 0;
    					this._scroller.scrollTo(0, 0, 0);
    				}
    			},

    			
                refresh: function () {
                	if (this.needRefresh) {
	                	this.containerNode.innerHTML = "";
	                	// only containerNode is re-rendered. we need to also reset the selection status of the root
	                	// this.selectionStatus = this.defaultSelectionStatus;
	            		// this.updateSelection(false, false);
	            		
						//this.fillData();
	                	this.postBuildRendering();
	                	this.resized();
                        this.updateScroller();
	                	this.needRefresh = false;
                	}
                }
        	}
    		
    );
   
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.DocXtabModel",
                         "mstrmojo.array",
                         "mstrmojo.func");
    
    var SELECTOR_ACTION = 2;
    var ROW_AXIS = 1,
    COL_AXIS = 2;

    /**
     * <p>A model for handling Document Vis interactivity.</p>
     * 
     * @class
     * @extends mstrmojo.XtabModel
     */
    mstrmojo.DocVisModel = mstrmojo.declare(
        mstrmojo.DocXtabModel,
        
        null,        
      
        {            
            scriptClass: "mstrmojo.DocVisModel",
            
            getAction: function getAction(cells) {
                var cell = cells[0],
                    actionType = cell && cell.at;

                var action;
                // Resolve what the action should be.
                if (actionType) {
                    // Is this a selector action?
                    if (actionType & SELECTOR_ACTION) {
                        
                    	action = { //AndroidDocumentController -> _IsDocController -> onVisSelector
                            h: 'onVisSelector',
                            a: this.getSelectAction(cell)
                        };       
                    }
                }
                
                // Delegate to super because we couldn't handle it.
                if ( ! action ) {
                	action = this.getActionObject(cells);
                }
               
                return action;
            },
            
            getSelectAction: function getSelectAction(actionObj){
				var scObjList = actionObj.scObjList,
	        		scObjListLength = scObjList.length,
	        		action = null;
	        		
	        	if(scObjListLength > 1){
	        		//multi-select
	        		action = { 
						multiSelect: true,
						type: mstrmojo.EnumRWUnitType.GRID,
						src: actionObj.k,						
						sliceId: 1,
						sid:1,
						anchor: actionObj.anchor,
						selectorObjects: []
					};
					
	        		//{#ke;wenwang;655199; we need have tks in the outmost level to have DocModel to know there is a panelStack#}
	        		var scTks = {};
	        		var strTks = '';
	        		for(var i = 0; i < scObjListLength; i++){
	        			var scObj = scObjList[i];
	        			
	        			/*
	        			 * if there are multi tks on the attr, the tks of sc will be "W45\x1EW50"
	        			 * so scObj.sc.tks.split("\x1E") will split to "";"W45";"W50"
	        			 */
	        			var tksList = scObj.sc.tks.split("\x1E");
	        			for(var j = 0; j < tksList.length; j++){
	        				var target = tksList[j];
	        				if(!scTks[target]){
	        					scTks[target] = true;
	        					if(strTks.length > 0){
	        						//add '\x1E' between all the target, but not before first one
	        						strTks = strTks + '\x1E'+target;
	        					}else{
	        						strTks = target;
	        					}
	        					
	        				}
	        			}
	        				
	        		}
	        		//console.log("strTks = " + strTks);
					for (var i = 0; i < scObjListLength; i++) {
						var scObj = scObjList[i];
						action.selectorObjects.push({ // push this element selection info to event
							ck: scObj.sc.ck,
							ctlKey: scObj.sc.ckey,
							tks: scObj.sc.tks,
							eid: scObj.eid
						});
					}
				//we need to set tks at outmost level
					if(!action.tks)
						action.tks = strTks;
					
	        	}else if(scObjListLength == 1){
	        		var scObj = scObjList[0];
	        		action = { 
						type: mstrmojo.EnumRWUnitType.GRID,
						src: actionObj.k,						
						sliceId: 1,
						sid:1,
						ck: scObj.sc.ck,
						ctlKey: scObj.sc.ckey,
						tks: scObj.sc.tks,
						eid: scObj.eid,
						anchor: actionObj.anchor
					};
	        	}
	            
	            return action;

			},
			
			getLinkAction: function getLinkAction(actionObj, idx) {
				var node = actionObj.node,
					title = node && node.titleInfo;    		
                
                return this.getLinkActionImpl(node, title, idx);
            },
            
            getPCellParentNode: function getPCellParentNode(pCell, axis){            	
            	return ( axis == ROW_AXIS ) ? pCell._lp : pCell._tp;
            },
            
            getPTitle: function getPTitle(pCell, axis){
            	return pCell.titleInfo;
            }
        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.date",
                         "mstrmojo.Stepper",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.DateStepperContentProvider",
                         "mstrmojo.NumStepperContentProvider");

    var $A = mstrmojo.array,
        $D = mstrmojo.date,
        $H = mstrmojo.hash,
        $BTN = mstrmojo.android.ui.Button.newButton,
        DTP = mstrmojo.expr.DTP,
        DT = {
            interval: 1
        },
        H = {
            min: 1,
            max: 12,
            interval: 1,
            value: 12
        },
        H24 = {
            min: 0,
            max: 23,
            interval: 1,
            value: 0
        },
        M = {
            min: 0,
            max: 59,
            interval: 1
        };

    function createChildren() {
        var dtp = this.dtp,
            sc = this.stepperClass,
            value = this[this.valueField],
            children = [],
            dateText,
            timeText;

        if (this._hasDate) {
            children.push({
                scriptClass: sc,
                slot:  'monthNode',
                alias: 'monthStepper',
                title: mstrmojo.desc(871), //'month'
                provider: this.dateProvider.monthCP
            }, {
                scriptClass: sc,
                slot:  'dayNode',
                alias: 'dayStepper',
                title: mstrmojo.desc(872), //'day'
                provider: this.dateProvider.dayCP
            }, {
                scriptClass: sc,
                slot:  'yearNode',
                alias: 'yearStepper',
                title: mstrmojo.desc(873), //'year',
                provider: this.dateProvider.yearCP
            });
        }

        if (this._hasTime) {
            children.push({
                scriptClass: sc,
                slot:  'hourNode',
                alias: 'hourStepper',
                provider: this.hourProvider
            }, {
                scriptClass: sc,
                slot:  'minNode',
                alias: 'minStepper',
                provider: this.minProvider
            });
        }

        // Add the switcher nodes only if not explicitly hidden.
        if (!this.hideSwitchers) {
            if (dtp !== DTP.TIME) {
                dateText = (value && value.date) ? $D.formatDateInfo(value.date, mstrmojo.locales.datetime.DATEOUTPUTFORMAT) : mstrmojo.desc(2052); //'Date'
                children.push($BTN(dateText, function () { this.parent.toDateView(); }, { alias: 'dateToggle', slot: 'switcherNode', cssClass: '', selected: true }));
            }

            if (dtp !== DTP.DATE) {
                timeText = (value && value.time) ? $D.formatTimeInfo(value.time, mstrmojo.locales.datetime.TIMEOUTPUTFORMAT) : mstrmojo.desc(2170); //'Time'
                children.push($BTN(timeText, function () { this.parent.toTimeView(); }, { alias: 'timeToggle', slot: 'switcherNode', cssClass: '', selected: dtp == DTP.TIME }));
            }
        }

        if (this._hasDate) {
            this.viewCssClass = 'dateView';
        } else if (this._hasTime) {
            this.viewCssClass = 'timeView';
        }

        this.addChildren(children);
    }

    function createProviders() {
        var propNames = [this.valueField, 'min', 'max'],
            dateItem = $H.copy(DT),
            hourItem = this.is24HourMode ? $H.copy(H24) : $H.copy(H),
            minItem = $H.copy(M),
            value = this[this.valueField],
            timeValue = value && value.time,
            me = this;

        //Set the date properties from the init props
        $A.forEach(propNames, function (p) {
            dateItem[p] = $H.copy(me[p]);
        });

        if (this._hasDate) {
            this.dateProvider = new mstrmojo.DateStepperContentProvider({
                item: dateItem,
                valField: this.valueField,
                canLoop: true,
                onTraverse: function () {
                    //refresh
                    me.updateDate();
                }
            });
        }

        if (this._hasTime) {
            //Do we have a custom minuteInterval set-up?
            if (this.minuteInterval !== undefined) {
                minItem.interval = this.minuteInterval;
            }

            //Delete the JSON minuteInterval property as we don't want to copy it.
            delete this.minuteInterval;

            if (timeValue) {
                //Set the initial time
                if (!this.is24HourMode) {
                    hourItem.value = timeValue.hour % 12 || 12;
                    //Set the meridiem property
                    this.set('meridiem', (timeValue.hour < 12));
                } else {
                    hourItem.value = timeValue.hour;
                }
                minItem.value = timeValue.min;
            }

            //Set the hour stepper's content provider.
            this.hourProvider = new mstrmojo.NumStepperContentProvider({
                item: hourItem,
                valField: 'value',
                canLoop: true,
                onTraverse: function () {
                    me.updateTime();
                }
            });

            //Set the minute stepper's content provider...
            this.minProvider = new mstrmojo.NumStepperContentProvider({
                item: minItem,
                valField: 'value',
                canLoop: true,
                renderer: {
                    render: function (v) {
                        return String(v).length == 1 ? ('0' + v) : v;
                    }
                },
                onTraverse: function () {
                    me.updateTime();
                }
            });
        }
    }

    /**
     * Widget for allowing the user to pick date or time using a stepper style.
     *
     * @class
     * @extends mstrmojo.Container
     */
    mstrmojo.DateTimePicker = mstrmojo.declare(
        /**
         * Super Class
         */
        mstrmojo.Container,

        /**
         * Mixins
         */
        null,

        {

            scriptClass: "mstrmojo.DateTimePicker",

            /**
             * This property is set by the user to set and retrieve the time on the time picker. This object is of type
             * date info (@see mstrmojo.date#parseDateAndOrTime)
             *
             * @type Object
             */
            value: null,

            /**
             * The minimum date/time supported by the date time picker. The object is of type date info
             * @see mstrmojo.date#parseDateAndOrTime
             *
             * @type Object
             */
            min: null,

            /**
             * The maximum date/time supported by the date time picker. The object is of type date info
             * @see mstrmojo.date#parseDateAndOrTime
             *
             * @type Object
             */
            max: null,

            /**
             * The boolean denotes whether the True - AM, False - PM
             *
             * @type Boolean
             * @default true
             */
            meridiem: true,

            /**
             * Allows the widget to dynamically show/hide switcher nodes. Typically done when only a date or a time picker
             * is used by itself.
             *
             * @type Boolean
             * @default false
             */
            hideSwitchers: false,

            /**
             * This property denotes whether the date time picker needs to support an interval other than 1. We only support intervals
             * in minutes based on the Web GUI and hence only the minute stepper will support the interval property
             */
            minuteInterval: null,

            /**
             * This property denotes whether the date picker is displayed in 24 hour mode or not.
             *
             * @type Boolean
             * @default false
             */
            is24HourMode: false,

            /**
             * Date type, used to decide whether to show date or time picker.
             */
            dtp: mstrmojo.expr.DTP.TIMESTAMP,

            /**
             * applied on the viewNode.
             * @private
             */
            viewCssClass: '',

            /**
             * the name of the property which holds the date JSON object
             */
            valueField: 'value',

            /**
             * ScriptClass of the child widgets which are responsible for changing the date value
             */
            stepperClass: 'mstrmojo.Stepper',

            markupString: "<div id='{@id}' class='mstrmojo-DateTimePicker' style='{@cssText}'>" +
                              "<div class='switcher'></div>" +
                              "<div class='{@viewCssClass}'>" +
                                  "<span class='stepNode month'></span>" +
                                  "<span class='stepNode day'></span>" +
                                  "<span class='stepNode year'></span>" +
                                  "<span class='stepNode hour'></span>" +
                                  "<span class='stepNode min'></span>" +
                                  "<span class='meridiem' mstrAttach:click></div>" +
                              "</div>" +
                          "</div>",

            markupSlots: {
                switcherNode: function () { return this.domNode.firstChild; },
                viewNode: function () { return this.domNode.children[1]; },
                monthNode: function () { return this.domNode.children[1].children[0]; },
                dayNode: function () { return this.domNode.children[1].children[1]; },
                yearNode: function () { return this.domNode.children[1].children[2]; },
                hourNode: function () { return this.domNode.children[1].children[3]; },
                minNode: function () { return this.domNode.children[1].children[4]; },
                meridiemNode: function () { return this.domNode.children[1].children[5]; }
            },

            markupMethods: {
                onmeridiemChange: function () {
                    // Do not show the meridiem part in 24 hour mode.
                    if (this.is24HourMode) {
                        this.meridiemNode.display = 'none';
                    } else {
                        this.meridiemNode.innerHTML = this.meridiem ? mstrmojo.locales.datetime.AM_NAME : mstrmojo.locales.datetime.PM_NAME;
                    }
                },
                onviewCssClassChange: function () {
                    this.viewNode.className = this.viewCssClass;
                }
            },

            /**
             * @see mstrmojo.Obj
             */
            init: function init(props) {
                //Call super
                this._super(props);

                var dtp = this.dtp;

                this._hasDate = (dtp === DTP.DATE || dtp === DTP.TIMESTAMP);
                this._hasTime = (dtp === DTP.TIME || dtp === DTP.TIMESTAMP);

                //Create data providers for the steppers
                createProviders.call(this);

                //Dynamically populate its children
                createChildren.call(this);
            },

            /**
             * @return datetime JSON object
             */
            getDateTime: function getDateTime() {
                return {
                    date: this.getDate(),
                    time: this.getTime()
                };
            },

            /**
             *
             * @return date JSON object
             */
            getDate: function getDate() {
                if (this._hasDate) {
                    var dateInfo = this.dateProvider.curVal;

                    return {
                        year: dateInfo.getFullYear(),
                        month: dateInfo.getMonth() + 1,
                        day: dateInfo.getDate()
                    };
                }

                return null;
            },

            /**
             * @return time JSON object
             */
            getTime: function getTime() {
                if (this._hasTime) {
                    return {
                        hour: !this.is24HourMode ? $D.capitalHour(this.hourProvider.curVal, this.meridiem ? ' AM' : ' PM') : this.hourProvider.curVal,
                        min: this.minProvider.curVal
                    };
                }
                return null;
            },

            /**
             * @return the string representation of the current date time
             */
            getDateTimeString: function getDateTimeString() {
                var str = '';
                if (this._hasDate) {
                    str += $D.formatDateInfo(this.getDate(), mstrmojo.locales.datetime.DATEOUTPUTFORMAT);
                }
                if (this._hasDate && this._hasTime) {
                    str += ' ';
                }
                if (this._hasTime) {
                    str += $D.formatTimeInfo(this.getTime(), mstrmojo.locales.datetime.TIMEOUTPUTFORMAT);
                }
                return str;
            },

            /**
             * Will be invoked when the date value is changed
             */
            updateDate: function updateDate() {
                if (this.hasRendered) {
                    //update the year, month, day steppers' display value
                    var me = this;
                    $A.forEach(['year', 'month', 'day'], function (n) {
                        me[n + 'Stepper'].updateDisplayText();
                    });
                }

                if (this.dateToggle) {
                    //update the display text of the date toggle button.
                    this.dateToggle.set('text', $D.formatDateInfo(this.getDate(), mstrmojo.locales.datetime.DATEOUTPUTFORMAT));
                }
            },

            /**
             * Will be invoked when the time value is changed
             */
            updateTime: function updateTime() {
                if (this.timeToggle) {
                    //update the display text of the time toggle button.
                    this.timeToggle.set('text', $D.formatTimeInfo(this.getTime(), mstrmojo.locales.datetime.TIMEOUTPUTFORMAT));
                }
            },

            /**
             * Switch to the Month-Day-Year picker view
             */
            toDateView: function toDateView() {
                this.set('viewCssClass', 'dateView');
                this.dateToggle.set('selected', true);
                var timeToggle = this.timeToggle;
                if (timeToggle) {
                    timeToggle.set('selected', false);
                }
            },

            /**
             * Switch to the Hour-Minute-Meridiem picker view
             */
            toTimeView: function toTimeView() {
                this.set('viewCssClass', 'timeView');
                var dateToggle = this.dateToggle;
                if (dateToggle) {
                    dateToggle.set('selected', false);
                }
                this.timeToggle.set('selected', true);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.MobileCalendar",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton");

    mstrmojo.android.inputControls.CalendarDIC = mstrmojo.declare(
        mstrmojo.MobileCalendar,

        [ mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: "mstrmojo.android.inputControls.CalendarDIC",

            // Will be invoked when the popup's dimension has been changed.
            onpopupResized: function onpopupResized(e) {
                var dn = this.domNode;
                if (dn) {
                    dn.style.zoom = parseInt((95 * e.width / dn.offsetWidth), 10) + '%';
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Widget",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.array",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    mstrmojo.requiresDescs(221);

    var $CSS = mstrmojo.css,
        $BTN = mstrmojo.android.ui.Button.newButton;

    /**
     * Widget for displaying drop down lists on the Android platform.
     *
     * @class
     * @extends mstrmojo.Widget
     * @borrows mstrmojo._TouchGestures
     */
    mstrmojo.android.DropDownList = mstrmojo.declare(

        mstrmojo.Widget,

        [ mstrmojo._TouchGestures ],

        /**
         * @lends mstrmojo.android.DropDownList.prototype
         */
        {
            scriptClass: "mstrmojo.android.DropDownList",

            cssDisplay: 'block',

            markupString: '<div id="{@id}" class="mstrmojo-AndroidDropDownList {@cssClass}" mstrAttach:click><div>{@value}</div></div>',

            markupSlots: {
                valueNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? this.cssDisplay : 'none'; },
                onvalueChange: function () {
                    var value = this.value,
                        options = this.options;

                    // Do we have options?
                    if (options) {
                        var idx = mstrmojo.array.find(options, 'v', value),
                            item = options[idx];

                        // Update DOM.
                        this.valueNode.innerHTML = item.n;

                        // Do we have an "unset" option?
                        if (value !== "-1" && options[0].v === "-1") {
                            // Remove it.
                            options.shift();

                            // TQMS 496922.
                            idx--;
                        }

                        // Update idx silently so we don't loop.
                        this.idx = idx;
                    }
                }
            },

            /**
             * An array of items to be displayed when drop down is clicked.
             *
             * @type Object[]
             * @default null
             */
            options: null,

            /**
             * The currently selected string value.
             *
             * @type String
             * @default ''
             */
            value: '',

            /**
             * The name of the selector.
             * 
             * @type String
             * @default ''
             */
            name: '',

            /**
             * The index of the currently selected option.
             *
             * @default 0
             */
            idx: 0,

            singleSelectByField: function singleSelectByField(value) {
                this.set('value', value);
            },

            /**
             * Displays a {@link mstrmojo.ui.MobileCheckList} dialog for the user to make a selection.
             *
             */
            touchTap: function touchTap() {
                // Show a mobile checklist dialog.
                var id = this.id,
                    domNode = this.domNode,
                    app = mstrApp;

                app.showDialog({
                    autoClose: true,
                    title: this.name,
                    fadeOnClose: false,
                    cssClass: 'dropDownList',
                    onClose: function () {
                        $CSS.removeClass(domNode, 'down');
                    },
                    children: [{
                        scriptClass: 'mstrmojo.ui.MobileCheckList',
                        items: this.options,
                        multiSelect: false,
                        isElastic: true,
                        selectedIndex: this.idx,
                        hasEvenRows: true,
                        postselectionChange: function (evt) {
                            // Close the dialog.
                            // TQMS #507789: Need to close dialog before setting index to avoid random browser repaint issues.
                            mstrApp.closeDialog();

                            // Set the idx on the DropDownList.
                            mstrmojo.all[id].set('idx', evt.added[0]);
                        }
                    }],
                    buttons: [ $BTN(mstrmojo.desc(221, 'Cancel'), function () {
                        mstrApp.closeDialog();
                    }) ]
                });

                $CSS.addClass(domNode, 'down');
            },

            touchSelect: function touchSelect() {
                this.touchTap();
            },

            onidxChange: function onidxChange() {
                // Do we have options?
                var options = this.options;
                if (options) {
                    // Update value using set so the DOM changes.
                    this.set('value', options[this.idx].v);
                }
            },

            preBuildRendering: function preBuildRendering() {
                this._super();

                // Do we have options?
                var options = this.options;
                if (options) {
                    // We need to update the value silently so we don't trigger the task call.
                    this.value = options[this.idx].v;
                }
            }
        }
    );

}());
(function(){
    mstrmojo.requiresCls(
            "mstrmojo.Table",
            "mstrmojo.SelectBox",
            "mstrmojo._CanValidate");

    /***
     * Metric Condition Selector Utility
     */
mstrmojo.MCSUtil = mstrmojo.provide(
        "mstrmojo.MCSUtil",
        {
            // Function types
            _GENERIC: 1,
            _RANK: 2,
            _PERCENT: 3,

            //Operators ID
            OP: {
                _EQUALS: 0,
                _NOT_EQUALS: 1,
                _GREATER: 2,
                _GREATER_EQUAL: 3,
                _LESS: 4,
                _LESS_EQUAL: 5,
                _BETWEEN: 6,
                _NOT_BETWEEN: 7,
                _IN: 8,
                _NOT_IN: 9,
                _IS_NULL: 10,
                _IS_NOT_NULL: 11
            },

            //Qualify On ID
            Q: {
                _G: 0,//Generic
                _RT: 1,//Rank top
                _RB: 2, //Rank bottom
                _PT: 3,//Percent Top
                _PB: 4 // Percent Bottom
            },

            MRPFN : {
                    'TOP' :1,
                    'BOTTOM' :2,
                    'BETWEEN' :3,
                    'EXCLUDETOP' :4,
                    'EXCLUDEBOTTOM' :5,
                    'NOTBETWEEN' :6,
                    'EQUALS' :7,
                    'DIFFERENTFROM' :8,

                    //Descending:
                    'EQUALSDESCENDING': 15,
                    'NOTEQUALSDESCENDING': 16,  //MRPFunctionDifferentFromDescending
                    'GREATERTHANDESCENDING': 4,  //MRPFunctionExcludeTop
                    'GREATERTHANEQUALSDESCENDING': 18,
                    'LESSTHANDESCENDING': 20,
                    'LESSTHANEQUALSDESCENDING': 1,   //WebMRPFunctionTop
                    'BETWEENDESCENDING': 13,
                    'NOTBETWEENDESCENDING': 14,
                    'INDESCENDING': 22,
                    'NOTINDESCENDING': 24,

                    //Ascending - these correspond to MRP Functions without 'Dscending' suffix:
                    'EQUALSASCENDING': 7,      //WebMRPFunctionEquals
                    'NOTEQUALSASCENDING': 8,    //MRPFunctionDifferentFrom
                    'GREATERTHANASCENDING': 5, //WebMRPFunctionExcludeBottom
                    'GREATERTHANEQUALSASCENDING': 17,
                    'LESSTHANASCENDING': 19,
                    'LESSTHANEQUALSASCENDING': 2,  //WebMRPFunctionBottom
                    'BETWEENASCENDING': 3,      //WebMRPFunctionBetween
                    'NOTBETWEENASCENDING': 6,   //WebMRPFunctionNotBetween
                    'INASCENDING': 21,
                    'NOTINASCENDING': 23
            },

            FN : {
                    'EQUALS' :6,
                    'NOTEQUALS' :7,
                    'GREATERTHAN' :8,
                    'GREATERTHANEQUALS' :10,
                    'LESSTHAN' :9,
                    'LESSTHANEQUALS' :11,
                    'BETWEEN' :17,
                    'NOTBETWEEN' :44,
                    'ISNULL' :54,
                    'ISNOTNULL' :55,
                    'IN' :22,
                    'NOTIN' :57,
                    'CONTAINS' :76,
                    'NOTCONTAINS' :79,
                    'BEGINSWITH' :77,
                    'NOTBEGINSWITH' :80,
                    'ENDSWITH' :78,
                    'NOTENDSWITH' :81,
                    'LIKE' :18,
                    'NOTLIKE' :43,
                    'AND' :19,
                    'OR' :20,
                    'NOT' :21,
                    'RANK' :23,
                    'RANKPERCENT' :59,
                    'TUPLE' :1000
            },

            F: [
                [6, 7, 8, 10, 9, 11, 17, 44, 22, 57, 54, 55], //Generic function IDs;
                [15, 16, 4, 18, 20, 1, 13, 14, 22, 24], //highest
                [7, 8, 5, 17, 19, 2, 3, 6, 21, 23] //lowest
            ],

            getQuaByFunc: function(f, ft) {
                var $F = this.F,
                $Q = this.Q,
                $A = mstrmojo.array;

                var isTop = function(f) {
                    if ($A.indexOf($F[1], f) !== -1) {
                        return true;
                    } else {
                        return false;
                    }
                };

                if (ft === undefined || ft == this._GENERIC) {
                    return $Q._G;
                    } else {
                    if (isTop(f)) {
                        return (ft == this._RANK)? $Q._RT : $Q._PT;
                    } else {
                        return (ft == this._RANK)? $Q._RB : $Q._PB;
                    }
                }
            },

            getFuncInfo: function(operator, qualify) {
                var ft, f;
                switch(qualify) {
                case  this.Q._G:
                    ft = this._GENERIC;
                    f = 0;
                    break;

                case this.Q._RT:
                    ft = this._RANK;
                    f = 1;
                    break;

                case this.Q._RB:
                    ft = this._RANK;
                    f = 2;
                    break;

                case this.Q._PT:
                    ft = this._PERCENT;
                    f = 1;
                    break;

                case this.Q._PB:
                    ft = this._PERCENT;
                    f = 2;
                    break;

                default:
                    return {};
                }

                return {
                    ft: ft,
                    f: this.F[f][operator]
                };

            },

            /***
             * Get the operator ID by function ID.
             */
            getOpIdxByfunc: function(f, ft) {
                if (!f || !ft) { return -1; }//0 is reserved.

                var $F = this.F,
                $Q = this.Q,
                $A = mstrmojo.array,
                r = -1;

                switch(ft) {
                case  this._GENERIC:
                    r = $A.indexOf($F[0], f);
                    break;

                case this._RANK:
                case this._PERCENT:
                    r =  $A.indexOf($F[1], f);
                    if (r == -1) {
                        r = $A.indexOf($F[2], f);
                    }
                    break;

                }
                return r;
            },

            getIncludeByOp: function(op){
                var o = this.OP;
                switch(op){
                case o._EQUALS:
                case o._GREATER_EQUAL:
                case o._LESS_EQUAL:
                case o._BETWEEN:
                case o._IN:
                    return true;
                }
                return false;
            },

            formatNumber: function(qlfy, num, numFmts) { //same as editable mode
                if (qlfy == $M.Q._G)  {
                    var $N = mstrmojo.num;
                    return (numFmts.fm)? $N.formatByMask(numFmts.fm, num) : $N.format(numFmts.cat, numFmts.dp, numFmts.curr, num);
                } else if(qlfy == $M.Q._RB || qlfy == $M.Q._RT) {
                    return parseInt(num);
                } else if (qlfy == $M.Q._PB || qlfy == $M.Q._PT ) {
                    return parseFloat(num) + '%';
                }
            }
        });

var $M = mstrmojo.MCSUtil,
$V = mstrmojo.validation,
$E = mstrmojo.expr,
$NM = mstrmojo.num,
allOprs =   [{n: mstrmojo.desc(2795, "Equals"), v:$M.OP._EQUALS},
          {n: mstrmojo.desc(2796, "Does not equals"), v: $M.OP._NOT_EQUALS},
          {n: mstrmojo.desc(521, "Greater than"), v: $M.OP._GREATER},
          {n: mstrmojo.desc(522, "Greater than or equal to"), v:$M.OP._GREATER_EQUAL},
          {n: mstrmojo.desc(523, "Less than"), v: $M.OP._LESS},
          {n: mstrmojo.desc(524, "Less than or equal to"), v: $M.OP._LESS_EQUAL},
          {n: mstrmojo.desc(519, "Between (enter value1;value2)"), v: $M.OP._BETWEEN},
          {n: mstrmojo.desc(614, "Not between (enter value1;value2)"), v: $M.OP._NOT_BETWEEN},
          {n: mstrmojo.desc(898, "In (enter value1;value2; ...;valueN)"), v: $M.OP._IN},
          {n: mstrmojo.desc(2394, "Not In (enter value1;value2; ...;valueN)"), v: $M.OP._NOT_IN},
          {n: mstrmojo.desc(2202, "Is null"), v: $M.OP._IS_NULL},
          {n: mstrmojo.desc(2203, "Is not null"), v: $M.OP._IS_NOT_NULL}],
oprs = allOprs.slice(0, 10),
cellCss = "padding:2px 2px 2px 2px",
oprsNull = allOprs.slice(10, 12);



/***
 * validate input value
 */
var checkRange = function(v, r, isPercent, unary, category) {
    if (category == 2) return r; // no validate for date category

    var vs = String(v).split(";"),
    invalid = $V.STATUSCODE.INVALID_VALIDATOR,
    valid = $V.STATUSCODE.VALID;

    if (unary && vs && vs.length >1) {
        r.code = invalid;
    } else {
        for (var i = 0; i < vs.length; i++) {
            var _v = parseFloat(vs[i], 10);
            if ( isNaN(_v) ||
                    (isPercent && ( (vs[i].match(/^\d+(\.\d+)?%$/) == null && vs[i].match(/^\d+(\.\d+)?$/) == null) || _v < 0 || _v > 100) ) ||
                    (!isPercent && vs[i].match(/\d+$/) == null)) {
                r.code = invalid;
            }
            if (r.code != valid) break;
        }
    }

    if (r.code != valid) {
        r.msg = mstrmojo.desc(6103, "Please fix any invalid data");
    }
    return r;
};

var calcTxtWidth = function(fs){
    fs = parseFloat(fs);
    if(isNaN(fs)){
        return "54px";
    }else{
        return (fs * 72 / 16) + "pt;";
    }
},
txtFontChange = function(me){
    if (me.hasRendered) {
        var s = me.domNode.style;
        s.font = me.font;
        s.width = calcTxtWidth(s.fontSize);
    } else {
        var m = me.font.match(/[^\s]*?pt/) || [];
        me.cssText = me.cssText + " font:" + me.font + "; width:" + calcTxtWidth(m[0]);
    }
},
isNumericDT = function(dt){
    if((dt >= 8 && dt <= 16) || (dt >= 23 && dt <= 25) || dt == 30){
        return false;
    }
    return true;
};

 mstrmojo.MetricQualification = mstrmojo.declare(
         //superclass
         mstrmojo.Table,
         //mixins
         null,
         {
             scriptClass: "mstrmojo.MetricQualification",
             cssClass: "qs",
             cssText: "width:100%",
             markupMethods: {
                 onvisibleChange: function() { this.domNode.style.display = this.visible ? mstrmojo.css.DISPLAY_TABLE : 'none'; }
             },

             getClientHeight: function getClientHeight(){
                 return this.domNode.clientHeight + 2;//include border width.
             },

             rows: 1,
             cols: 4,
             layout: [{cells: [{cssText: "width:100%"}, {cssText: "width:56px"}, {cssText: "width:56px"}, {cssText: "width:18px"}]}],
             init: function(props) {
                 if (this._super)
                     this._super(props);

                 this._init();
             },

             _init: function(reset) {
                 switch(this.qua) {
                 case 0:
                     this.low = (this.da && this.da.low) || 0;
                     this.high = (this.da && this.da.high) || 0;
                     break;

                 case 1:
                 case 2:
                     this.low = 1;
                     this.high  = (this.da && this.da.cnt) || 0;
                     break;

                 case 3:
                 case 4:
                     this.low = 0;
                     this.high = 100;
                     break;
                 }


                 if (reset) {
                     this.cs = [];
                     this.f = this.ft = null;
                 }
                 var op=  $M.getOpIdxByfunc(this.f, this.ft),
                     opId;
                 if(this.qua == 0 || this.dt == 30){
                     opId = (op == $M.OP._IS_NOT_NULL || isNumericDT(this.dt)) ? (op == -1) ? $M.OP._GREATER_EQUAL : op : $M.OP._IS_NULL;
                 }else{
                     opId = (op == -1) ? $M.OP._GREATER_EQUAL : op;
                 }


                 this.set("opId", opId);

                 var in_cs = (this.cs && this.cs.length > 0)? $NM.toLocaleString(this.cs[0].v) : "";

                 if (this.opId ==  $M.OP._IN || this.opId ==  $M.OP._NOT_IN) {
                     for (var i = 1; i < this.cs.length; i++){
                         in_cs += ";" + $NM.toLocaleString(String(this.cs[i].v));
                     }
                 } else {
                     this.set("cs2", (this.cs && this.cs.length >1)? $NM.toLocaleString(this.cs[1].v) : "");
                 }
                 this.set("cs1", in_cs);

                 this.vldTbL.validate();
                 this.vldTbH.validate();

                 this.changeQual = false;
             },
             updateData: function udtDt(da, props){
                 this.da = da;

                 //TQMS 467964: some properties moved from def block to data block.
                 // TODO: need to refactoring the object structure in the future.
                 this.updateExpr(props);
             },

             updateExpr: function udtEp(props) {
                 if (props) {
                     this.cs = props.cs;
                     this.f = props.f;
                     this.ft = props.ft;
                     this.qua = props.qua;
                 }
                 this._init();
             },

             onquaChange: function onqChg(evt){
                 this._init(true);
                 this.func.items = (this.qua!=0)? oprs : isNumericDT(this.parent.dt) ? allOprs : oprsNull;
                 this.func.refresh();
                 this.changeQual = true;
                 this.onchange();
             },

             children: [{
                 slot: "0,0",
                 alias:"func",
                 scriptClass: "mstrmojo.SelectBox",
                 cssText: "width:100%",
                 size:1,
                 bindings: {
                     sv: "this.parent.opId",
                     font: "this.parent.font"
                 },

                 onfontChange:function(){
                     if (this.hasRendered) {
                         this.domNode.style.font = this.font;
                     } else {
                         this.cssText = "width:100%;font:" + this.font;
                     }
                 },
                 onsvChange: function(){
                     if (this.sv !== null && this.sv !==undefined){
                         this.set('selectedItem', {v:this.sv});
                     }
                 },
                 postCreate: function(){
                     if (mstrmojo.dom.isIE) {
                         this.itemDisplayField = 'n';
                         this.showItemTooltip = true;
                     }
                     this.items = (this.parent.qua!=0)? oprs: isNumericDT(this.parent.dt) ? allOprs : oprsNull;
                 },
                 onchange: function() {
                     var p = this.parent,
                     itm = this.selectedItem;
                     if (itm && itm.v !== null && itm.v !== undefined) {
                         p.set("opId", itm.v);
                     }

                     if(mstrApp.isMobile && (itm.v === $M.OP._IS_NULL || itm.v == $M.OP._IS_NOT_NULL)) {
                         if(p.onchange) {
                             p.onchange();
                         }
                     }
                 }

                 }, {
                 slot: "0,1",
                 alias: "vldTbL",
                 scriptClass : "mstrmojo.ValidationTextBox",
                 required: true,
                 dtp: $E.DTP.VARCHAR,
                 constraints: {
                     trigger: $V.TRIGGER.ALL,
                     validator: function(v){
                         var  r = {id: this.id, code: $V.STATUSCODE.VALID, msg: '' },
                         p = this.parent;
                         checkRange(v, r, (p.qua==3||p.qua==4),  (p.opId != 8 && p.opId !=9), (p.numFmts && p.numFmts.cat));
                         return r;
                     }
                 },
                 bindings: {
                     visible: "this.parent.opId!=10&&this.parent.opId!=11",
                     value: "this.parent.cs1",
                     font: "this.parent.font"
                 },

                 onfontChange:function(){
                     txtFontChange(this);
                 },

                 onValid: function() {
                     var p = this.parent,
                         box = this.domNode;
                     p.set("cs1", this.value);

                     if(box && box.value.length > 6){
                         box.title = box.value;
                     }else if(box){
                         box.title = "";
                     }

                 },
                 onvisibleChange: function() {
                     if(!this.visible){
                         this.parent.set("cs1", "");
                     }
                 },
                 onkeyup: function(evt){
                     var hWin = evt.hWin,
                         e = evt.e || hWin.event,
                         p = this.parent,
                         box = evt.src.domNode;
                     if (e.keyCode === 13 && p.apply && p.apply.enabled){
                         p.apply.onclick();
                     }

                 }

             }, {
                 slot: "0,2",
                 alias: "vldTbH",
                 scriptClass : "mstrmojo.ValidationTextBox",
                 required: true,
                 dtp: $E.DTP.VARCHAR,
                 constraints: {
                     trigger: $V.TRIGGER.ALL,
                     validator: function(v){
                         var  r = {id: this.id, code: $V.STATUSCODE.VALID, msg: '' },
                         p = this.parent;
                         checkRange(v, r, (p.qua==3||p.qua==4),  (p.opId != 8 && p.opId !=9), (p.numFmts &&p.numFmts.cat));
                         return r;
                     }
                 },
                 bindings : {
                     visible : "this.parent.opId ==7 ||this.parent.opId ==6", // 'Between' and 'Not Between'
                     value: "this.parent.cs2",
                     font: "this.parent.font"
                 },

                 onfontChange:function(){
                     txtFontChange(this);
                 },

                 onValid: function() {
                     this.parent.set("cs2", this.value);

                     var box = this.domNode;

                     if(box && box.value.length > 6){
                         box.title = box.value;
                     }else if(box){
                         box.title = "";
                     }
                 },
                 onvisibleChange: function() {
                     if(!this.visible){
                         this.parent.set("cs2", "");
                     }
                 },
                 onkeyup: function(evt){
                     var hWin = evt.hWin,
                         e = evt.e || hWin.event,
                         p = this.parent;
                     if (e.keyCode === 13 && p.apply && p.apply.enabled){
                         p.apply.onclick();
                     }
                 }

             },  {
                    slot: "0,3",
                    alias: "apply",
                    title: mstrmojo.desc(2164, "Apply"),
                    scriptClass : "mstrmojo.Button",
                    cssClass : 'icn apply',
                    bindings: {
                        enabled: "(!this.parent.vldTbL.visible ||!this.parent.vldTbL.validationStatus.code)"+
                        "&& (!this.parent.vldTbH.visible||!this.parent.vldTbH.validationStatus.code)"
                   },

                    onclick: function(){
                        var p = this.parent,
                        isPercent = (p.qua == $M.Q._PT || p.qua == $M.Q._PB);
                        p.cs = [];

                        var toPrcnt = function(v){
                            return v + ((isPercent && !String(v).match(/^\d+%$/))? '%' : '');
                        };

                        var type = function(cat, qua){
                            return ((cat == 2 || cat == 3) && qua == 0)? 14 : 5;
                        };

                        if (p.opId == $M.OP._IN || p.opId == $M.OP._NOT_IN){
                            var _cs = String(p.cs1).split(";");
                            for (var i = 0; i < _cs.length; i++) {
                                if(!mstrmojo.string.isEmpty(_cs[i])) p.cs.push({dtp:5, v: toPrcnt(_cs[i])});
                            }
                        }  else {
                            if (p.vldTbL.visible) p.cs.push({dtp: type((p.numFmts && p.numFmts.cat), p.qua), v: toPrcnt(p.cs1)});
                            if (p.vldTbH.visible)  p.cs.push({dtp:  type((p.numFmts && p.numFmts.cat), p.qua), v: toPrcnt(p.cs2)});
                        }

                        if (p.onchange) {
                            p.onchange();
                        }

                        if (p.makeSelection) {
                        	p.makeSelection();
                        }
                    }
             }]
         });
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.android.SimpleList");

    /**
     * An Android specific list box selector.
     *
     * @class
     * @extends mstrmojo.SimpleList
     */
    mstrmojo.android.selectors.ListBox = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        null,

        /**
         * @lends mstrmojo.android.selectors.ListBox.prototype
         */
        {
            scriptClass: "mstrmojo.android.selectors.ListBox",

            init: function init(props) {
                this._super(props);

                // Reset cssClass.
                mstrmojo.css.addWidgetCssClass(this, [ 'selector-listbox' ]);
            },

            postBuildRendering: function postBuildRendering() {
                // Does the list have a fixed height?
                var h = parseInt(this.height, 10);
                if (h) {
                    var itemsContainerNode = this.itemsContainerNode,
                        listHeight = itemsContainerNode.offsetHeight;

                    // Is the height of the items container less than the fixed list height?
                    if (listHeight < h) {
                        // Calculate line-height for each item.
                        var cnt = this.items.length,
                            lineHeight = Math.round(h / this.items.length) + 'px',
                            i = 0;

                        // Iterate items.
                        for (i = 0; i < cnt; i++) {
                            // Set line-height to calculated value so that items will fill entire selector height.
                            itemsContainerNode.childNodes[i].style.lineHeight = lineHeight;
                        }
                    }
                }

                return this._super();
            }

        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.android.SimpleList",
                         "mstrmojo.css");

    var $CSS = mstrmojo.css,
        clsGlow = 'glow',
        $DOM = mstrmojo.dom,
        $TRANS_DURATION = $DOM.$TRANS_DURATION,
        itemMarkup;

    /**
     * Applies a temporary "glow" effect to the passed element.
     *
     * @param {HTMLElement} el The element that should glow.
     *
     * @private
     */
    function doGlow(el) {
        var style = el.style;

        // Apply glow effect.
        style[$TRANS_DURATION] = 0;
        $CSS.addClass(el, clsGlow);

        // Set timeout and...
        window.setTimeout(function () {
            // Remove glow effect.
            style[$TRANS_DURATION] = '300ms';
            $CSS.removeClass(el, clsGlow);
        }, 100);
    }

    /**
     * Widget for displaying a list of checkbox (or radio) items that are Mobile "Touch" enabled to support selection and scrolling.
     *
     * @class
     * @extends mstrmojo.android.SimpleList
     */
    mstrmojo.ui.MobileCheckList = mstrmojo.declare(

        mstrmojo.android.SimpleList,

        null,

        /**
         * @lends mstrmojo.ui.MobileCheckList.prototype
         */
        {
            scriptClass: "mstrmojo.ui.MobileCheckList",

            /**
             * Override to default to multi-select.
             *
             * @ignore
             * @see mstrmojo._ListSelections
             */
            multiSelect: true,

            /**
             * @ignore
             * @see mstrmojo.android.SimpleList
             */
            hasEvenRows: true,

            /**
             * Whether item glows when user touches it.
             *
             * @type boolean
             * @default false
             */
            glow: true,

            /**
             * Overridden to disable touch bubbling.
             *
             * @ignore
             */
            allowTouchBubble: false,

            listHooks: {
                select: function (el, item, idx) {
                    // Should item glows and should we NOT skip this event?
                    if (this.glow && !this.skipEvent) {
                        // Apply glow to selected element.
                        doGlow.call(this, el);
                    }
                },

                unselect: function (el, item, idx) {
                    // Should item glows, does the list support multi select and should we NOT skip this event?
                    if (this.glow && this.multiSelect && !this.skipEvent) {
                        // Apply glow to unselected element.
                        doGlow.call(this, el);
                    }
                }
            },

            getItemMarkup: function (item) {
                // Have we NOT generated the markup?
                if (!itemMarkup) {
                    // Get the markup from the super and add extra elements.
                    itemMarkup = this._super(item).replace('{@n}', '<div><h3>{@n}</h3></div>');
                }

                // Return cached markup.
                return itemMarkup;
            },

            /**
             * Override to add necessary CSS classes to cssClass property.
             *
             * @ignore
             */
            init: function init(props) {
                this._super(props);

                // Update css class property.
                var cls = [ 'mobile-checklist' ];

                // Do we support multi-select?
                if (this.multiSelect) {
                    // Add multi class.
                    cls.push('multi');
                }

                // Reset cssClass.
                mstrmojo.css.addWidgetCssClass(this, cls);
            }


        }
    );

}());
(function() {

    mstrmojo.requiresCls("mstrmojo.TextBox");

    /**
     * A multiline text box.  Represents a native HTML &lt;textarea&gt;.
     * 
     * @class
     * @extends mstrmojo.TextBox
     */
    mstrmojo.TextArea = mstrmojo.declare(
        // superclass
        mstrmojo.TextBox,
        
        // mixins
        null,
        
        /**
         * @lends mstrmojo.TextArea.prototype
         */
        {
            /**
             * @ignore 
             */
            scriptClass: 'mstrmojo.TextArea',
                                                
            markupString: '<textarea id="{@id}" class="mstrmojo-TextArea {@cssClass}"  style="{@cssText}" '
                                + 'title="{@tooltip}" '
                                + 'placeholder="{@placeholderText}" '
                                + 'rows="{@rows}" cols="{@cols}" maxlength="{@maxLength}" index="{@tabIndex}"' +
                                ' mstrAttach:focus,keydown,keyup,blur ' +                              
                              '></textarea>',
                          
            /**
             * <p>Maximum number of characters allowed in the &lt;TextArea&gt; </p>
             * @param {Integer}
             * @default 256
             */
            maxLength: 256,
            
            markupSlots: {
                inputNode: function(){ return this.domNode; }
            },
            
            postCreate: function() {
                this.markupMethods = mstrmojo.hash.copy(this.markupMethods);
                this.markupMethods.oncssClassChange = function() { 
                    this.domNode.className = "mstrmojo-TextArea " + (this.cssClass||'');
                    };
            },
            
            onkeydown: function(e) {
                var strLen = (this.value && this.value.length) || 0;

                if (this.maxLength <= strLen) {
                    //BackSpace, Delete, or Arrow keys
                    this.isDeleteKeys = e.e.keyCode === 8 || e.e.keyCode === 46;
                    this.isArrowKeys = e.e.keyCode === 37 || e.e.keyCode === 38 || e.e.keyCode === 39 || e.e.keyCode === 40;
                    
                    //flag to indicate whether there is selection in the <textArea> 
                    var hasSelection = (this.domNode.selectionEnd !== undefined) ? (this.domNode.selectionEnd - this.domNode.selectionStart) > 0 :
                                       document.selection.createRange().text.length > 0;

                    if (!this.isDeleteKeys && !this.isArrowKeys && !hasSelection) {

                        //IE7 and 8 to stop adding input to the <textAre>
                        if (mstrmojo.dom.isIE7 || mstrmojo.dom.isIE8) {
                            var dn = this.domNode;
                            dn.blur();

                            window.setTimeout(function(){dn.focus();}, 1);
                        }

                        mstrmojo.dom.preventDefault(window, e.e);
                        return false;
                    }
                 }
             }
        }
      );
        
})();
(function() {

    mstrmojo.requiresCls("mstrmojo.TextBox","mstrmojo._CanValidate");

    var _C = mstrmojo.css,
        _V = mstrmojo.validation,
        _TR = _V.TRIGGER,
        _SC = _V.STATUSCODE,
        _MK = mstrmojo.TextBox.prototype.markupMethods;
    
    /**
     * A text box control that can validate its value.
     * 
     * @class
     * @extends mstrmojo.TextBox
     */
    mstrmojo.ValidationTextBox = mstrmojo.declare(
        // superclass
        mstrmojo.TextBox,
        
        // mixins
        [mstrmojo._CanValidate],
        
        /**
         * @lends mstrmojo.TextBox.prototype
         */
        {
            scriptClass: 'mstrmojo.ValidationTextBox',
            
            validationDelay: 500,
            
            markupMethods: {
                onvisibleChange: _MK.onvisibleChange,
                onvalueChange: _MK.onvalueChange,
                onenabledChange: _MK.onenabledChange,
                onreadOnlyChange: _MK.onreadOnlyChange,
                ontooltipChange: _MK.ontooltipChange,                
                onvalidationStatusChange: function(){
		            var vs = this.validationStatus;
		            if(!vs) {
		                return;
		            }
		            var it = this.inputNode,
		                isInvalid = (vs.code > _SC.VALID),
		                css = this.constraints.invalidCssClass;   
		                
		            _C.toggleClass(it, css ? css : ['mstrmojo-TextBox-ErrValidation'], isInvalid);
		            if(isInvalid){
		                it.setAttribute('title', vs.msg);
		            }else{
		                if (this._original_tooltip !== undefined && this._original_tooltip !== null) {
		                    it.setAttribute('title', this._original_tooltip);
		                }
		            }                   
		        }
            },

            /**
             * Override to attach event handlers. 
             */
            postBuildRendering: function pstBR(){
                if(this._super) {
                    this._super();
                }
                
                //store original tooltip
                this._original_tooltip = this.inputNode.title;  
            },
            
            /**
             * Handler for keyup event to validate after some delay if configured.  
             */
            prekeyup: function pku(evt) {
                if(this._super){
                    this._super(evt);   
                }
                var tri = (this.constraints.trigger & _TR.ONKEYUP) > 0;
                if(tri){
                    if (this.validationDelay > 0){
                        if(this._valDelayTimer){
                            window.clearTimeout(this._valDelayTimer);
                        }
                        
                        if(!this._validateHandler){
                            var me = this;
                            this._validateHandler = function(){
                                me.validate();      
                                if(me._valDelayTimer){
                                    window.clearTimeout(me._valDelayTimer);
                                    delete me._valDelayTimer;
                                }                        
                            };
                        }
                        
                        this._valDelayTimer = window.setTimeout(this._validateHandler, this.validationDelay);
                    }else{
                        this.validate();
                    }
                }
            },
            
            preinput: function(evt) {
                if(this._super){
                    this._super(evt);   
                }
                var tri = (this.constraints.trigger & _TR.ONKEYUP) > 0;
                if(tri){
                    this.validate();   
                }
            },
            
            /**
             * Handler for blur event to validate the input if configured. 
             */
            preblur: function pb(evt) {
                if(this._super){
                    this._super(evt);   
                }
                var tri = (this.constraints.trigger & _TR.ONBLUR) > 0;
                if(tri){
                    this.validate();   
                }
            },

            /**
             * Provide this method to clear validation status/appearance. 
             */
            clearValidation: function clearValidation(){
                if(this._super){
                    this._super();   
                }
                var it = this.inputNode,
                    css = this.constraints.invalidCssClass;
                _C.removeClass(it, css ? css : ['mstrmojo-TextBox-ErrValidation']);
                it.title = this._original_tooltip; 
            }            
        });
})();            
(function () {

    mstrmojo.requiresCls("mstrmojo.Popup",
                         "mstrmojo._HasBuilder",
                         "mstrmojo._IsAnchorable",
                         "mstrmojo.dom");

    var BASE_TIP_CLS = 'mstrmojo-DocInfoWindow-tip',
        DARK_BORDER_WIDTH = 1,
        $D = mstrmojo.dom;

    function _toggleLockInfoWins(anchor, lock) {
        // find the container widget of the anchor
        var w = $D.findWidget(anchor) || (anchor && anchor.w);

        // lock\unlock all parent info wins
        while (w) {
            if (w.autoCloseLocked !== undefined) {
                w.autoCloseLocked = lock;
            }

            w = w.parent;
        }
    }

    function _getContent(me) {
        var m = me.model;
        return m.getLayoutDataCache(m.getCurrentLayoutKey())[me.psId]
    }

    mstrmojo.DocInfoWindow = mstrmojo.declare(
        // superclass
        mstrmojo.Popup,

        // mixins,
        [ mstrmojo._HasBuilder, mstrmojo._IsAnchorable ],

        // instance props+methods
        {
            scriptClass: "mstrmojo.DocInfoWindow",

            markupString: '<div class="mstrmojo-DocInfoWindow-wrapper">' +
                              '<div id="{@id}" class="mstrmojo-DocInfoWindow"></div>' +
                              '<div class="' + BASE_TIP_CLS + ' top"></div>' +
                              '<div class="mstrmojo-DocInfoWindow-curtain" mstrAttach:click></div>' +
                          '</div>',

            markupSlots: {
                infoNode: function () { return this.domNode.firstChild; },
                tipNode: function () { return this.domNode.childNodes[1]; },
                curtainNode: function () { return this.domNode.lastChild; },
                containerNode: function () { return this.domNode.firstChild; }
            },

            boundaryNodeName : "boundary",

            popupNodeName : 'infoNode',

            baseTipClass : BASE_TIP_CLS,

            anchorOffset : 1,

            anchorOrientation : 'h',

            anchor: null,

            boundary: null,

            closeOnClick : true,

            autoCloseLocked: false,

            tipNodeColor: '',

            ontouchstart: function ontouchstart() {
                this.close();
            },

            close: function close(){
                // #678275. if it's locked, just return
                if (this.autoCloseLocked)
                    return;

                // raise 'infoWindowClosed' event on docModel
                // #658842: Removed the dependence of the parent widget requiring to have a model. The DocInfoWindow
                // widget has a reference to the doc model.
                this.model.raiseEvent({
                    name: 'infoWindowClosed',
                    psKey:this.psKey
                });

                // unlock all parent info windows
                var me = this;
                window.setTimeout(function () {
                    if (me.anchor) _toggleLockInfoWins(me.anchor, false);
                }, 0);

                if(this._super){
                    this._super();
                }

                // unhighlight the anchor node
                this.clearAnchorHilites();

                $D.detachEvent(document, $D.isFF ? 'DOMMouseScroll' : 'mousewheel', this.mw);
                $D.attachEvent(document, 'scroll', me.mw);
            },

            clearAnchorHilites: function clearAnchorHilites() {
                var zn = mstrmojo.dom.findWidget(this.anchor);
                if(zn && zn.clearHilites) {
                    zn.clearHilites(zn.hiliteKey);
                    delete zn.hiliteKey;
                }
            },

            prepareAnchor: function prepareAnchor() {
                if(this.children && this.children[0]) {
                var infoNodeStyle = this.infoNode.style,
                    contentChild = this.children[0],
                    contentChildNode = contentChild.dimNode || contentChild.domNode,
                    ifwWidth = contentChildNode.offsetWidth,
                    ifwHeight = contentChildNode.offsetHeight;

                // Set InfoWindow's size bigger than so that the background color will be visible.
                infoNodeStyle.width = (ifwWidth + 2 * DARK_BORDER_WIDTH) + 'px';
                infoNodeStyle.height = (ifwHeight + 2 * DARK_BORDER_WIDTH) + 'px';
                }
            },

            nudge: function nudge() {
                this.positionDialog();
                this.model.raiseEvent({name: 'infoWindowRendered',
                                       id: this.id   // info window widget id
                                      });
            },

            onRender: function onRender() {
                this.open(this.opener);
            },

            /**
             * Extend the open method in mstrmojo.Popup to ensure that the right panel is opened.
             *
             * @see mstrmojo.Popup
             */
            open: function open(opener, config) {
                // If the child panel stack is set up to reset to first panel - let's do it, now.
                var ps = mstrmojo.all[this.psId];

                // Is this info window targetting a panel stack?
                if (ps) {
                    var showFirstPanel = ps.defn.sfp,
                        currentPanelIdx = ps.selectedIdx;

                    // Have we set the first panel to be selected every time the info window is opened?
                    // And is it not currently on it...
                    if (showFirstPanel && currentPanelIdx !== 0) {
                        // Ask the panel stack to switch to the first panel.
                        ps.switchToPanel(0, 0);

                        // Set the current Panel to not be selected.
                        ps.children[currentPanelIdx].set('selected', false);
                    }
                }

                // Call super.
                if (this._super) {
                    this._super(opener, config);
                }

                // lock all parent info windowns
                if (this.anchor) _toggleLockInfoWins(this.anchor, true);

                // #717316 don't use the curtain node to close on android devices
                if(mstrApp.isTablet && mstrApp.isTablet()) {
                    var touchManager = mstrmojo.touchManager,
                        id = this.id,
                        infoWindowNode = this.domNode;
                    this._tchHandler = touchManager.attachEventListener('touchesBegin', id, function (evt) {

                        // #721073 do not close this info window and do not un register. autoCloseLocked is true when child infoWindow is open
                        if(this.autoCloseLocked) {
                            return;
                        }

                        // Is the source of the touch event NOT this widget?
                        var isTappingOnInfoWindow = mstrmojo.dom.contains(infoWindowNode, evt.touch.target, true);

                        // #757187: HeatMap puts it's tooltip DOM node out of the DOM node of itself
                        var infoboxes = document.getElementsByClassName('heatmap-infobox'),
                            len = (infoboxes && infoboxes.length) || 0,
                            i,
                            target = evt.touch.target,
                            isTappingOnHeatMapTooltip = false;
                        for(i = 0; i < len; i++) {
                            if(mstrmojo.dom.contains(infoboxes[i], target, true)){
                                isTappingOnHeatMapTooltip = true;
                                break;
                            }
                        }

                        if (!isTappingOnInfoWindow && !mstrApp.hasOpenDialog() && !isTappingOnHeatMapTooltip) { // 721072 make sure another dialog is not opened
                            this.closeOnTablet();
                        }
                    });
                }

                // #692936. dismiss IW on mousewheel event
                var me = this;
                me.mw = me.mw || function(e) {
                	// #756510. do not dismiss IW if mousewheel event is in it.
                    if (me.autoCloses &&
                    		!$D.contains(me.domNode, $D.eventTarget(self, e), true, document.body)) {
                        me.close();
                    }
                };
                $D.attachEvent(document, $D.isFF ? 'DOMMouseScroll' : 'mousewheel', me.mw);
                $D.attachEvent(document, 'scroll', me.mw);
            },


            getChildren: function getChildren() {
                return [_getContent(this)];
            },

            preBuildRendering: function preBuildRendering() {
                var c = _getContent(this),
                    f = c.defn.fmts;

                // Override positioning format of child.
                f.left = DARK_BORDER_WIDTH + 'px';
                f.top = DARK_BORDER_WIDTH + 'px';


                if (f.border) { // #709485. if border is defined, use the matching color for tip node
                    var tmp = f.border.split(' ');
                    if (tmp.length >= 3) {
                        this.tipNodeColor = tmp[2];
                    }
                }

                if (this._super) this._super();
            },

            postBuildRendering: function postBuildRendering() {
                // #837302, display DocInfoWindow during initial rendering, so children's rendering size can
                // be computed properly during the initial rendering.
                this.set('visible', true);

                if (this._super) this._super();

                // if closeOnClick is false, don't display the curtain node.
                // users can directly click on the widgets behind the Info Window
                if (!this.closeOnClick) {
                    this.curtainNode.style.display = 'none';
                }
            },

            /**
             * Close the InfoWindow, and detach the 'touchesBegin' event from touchManager if existing.
             */
            closeOnTablet: function closeOnTablet() {
                this.close();
                if (this._tchHandler) {
                    this._tchHandler.clear();
                }
            }
        }
    );

    var factory = mstrmojo.DocInfoWindow;
    factory.PLACEMENT = {
        AUTO: 1,
        FIXED: 2,
        ABOVE: 3,
        BELOW: 4,
        LEFT: 5,
        RIGHT: 6
    };

}());
/*global mstrmojo:false, window:false, document:false */

(function(){

    mstrmojo.requiresCls("mstrmojo.dom",
        "mstrmojo.Widget",
                         "mstrmojo.tooltip",
                         "mstrmojo.string",
                         "mstrmojo.array");

    /**
     * Counter to make sure every image map name is unique.
     * 
     * @private
     */
    var mapIdx = 0,
        $ARR = mstrmojo.array,
        $STR = mstrmojo.string;
    
    /**
     * Sets the current graph src or displays a message to the user if unable to display graph. 
     * 
     * @private
     */
    function configureDisplay() {
        var tn = this.textNode,
            img = this.imgNode;
        
        // Is this an empty graph?
        if (this.eg != null) {
            // Hide the graph image.
            img.style.display = 'none';
            
            // Display the message (or empty string).
            tn.innerHTML = this.eg || '';
            
            // Make sure the text node is visible.
            tn.style.display = 'block';
            
        } else {
            // Hide the message.
            tn.style.display = 'none';
            
            // Display the image node.
            img.style.display = 'block';
            
            // TQMS 926633: add tooltip information
            if (this.tooltip) {
                img.setAttribute("ttl", this.tooltip);
            }
            
            // Load the image.
            var fmts = this.getFormats();
            this.retrieveGraphSrc(fmts.height, fmts.width);
        }
    }
    
    /**
     * Map to hold area code to shape conversion values.
     * 
     * @type Object
     * @private
     */
    var areaShapeMap = {
        6: 'poly',
        7: 'rect',
        100: 'circle'
    };

    /**
     * <p>This method generates the image map used for mouseover tooltips.</p>
     *
     * <p>If the widget is already rendered it will replace the map within the dom node.  If not rendered, it will set properties on the widget
     * that will be inserted into the markup during rendering.
     *
     * @private
     */
    function generateImageMap() {
        // Cache server generated area data.
        var areaData = this.as,
            len = areaData && areaData.length;

        // Do we have any area data?
        if (!len) {
            // Nothing to do.
            return;
        }

        var widgetId = this.id,
            mapId = widgetId + '_map' + mapIdx++,
            buf = [],                               // String buffer for map areas.
            x = -1,                                 // Buffer counter.
            i;                                      // Iterator counter.
        
        // Iterate areas.
        for (i = 0; i < len; i++) {
            // Cache single area.
            var area = areaData[i];
            
            // Add dynamic properties to area.
            area.id = widgetId;                                                 // Widget id.
            area.aid = i;                                                       // Area index.
            area.tooltip = $STR.multiReplace(area.tooltip || '', {              // Tooltip (with new line "&#13" replaced by "<br />", and space "&#32" replaced by ' ').
                '&#13': '<br />',
                '&#32': ' '
            });

            // Has the shape NOT been converted already?
            if (!isNaN(area.shape)) {
                // Convert the shape code to a name.
                area.shape = this.getAreaShapeName(area.shape);
            }

            // Is the graph acting as a selector?
            if (area.tks || area.tks === '' || area.tty === 1) {
                // Add href attribute to get the hand cursor on area hover.
                area.extra = ' href="#" ';
            }

            // Add area to buffer.
            buf[++x] = $STR.apply(this.areaMarkup, area);
        }

        // Create whole map markup.
        var mapMarkup = '<map id="' + mapId + '" name="' + mapId + '">' + buf.join('') + '</map>';

        // Have we not rendered yet?
        if (!this.domNode) {
            // Add markup and attribute for render.
            this.att = 'usemap="#' + mapId + '" ';
            this.map = mapMarkup;
        } else {
            // Create element from markup and replace existing map.
            //#593793 - restore this code from 921m branch (which was overridden by merge from Wisdom branch)
            
            var newMap = document.createElement("div");
            newMap.innerHTML = mapMarkup;

            if (this.mapNode) {
                newMap = newMap.firstChild;
                this.mapNode.innerHTML = newMap.innerHTML; //#519390 - only update innerHTML for <area> nodes
            } else {
                this.imgNode.setAttribute("usemap", '#' + mapId);
                this.mapNode = this.domNode.appendChild(newMap.firstChild);            
            } 
        }
    }
    
    /**
     * <p>The widget for a single MicroStrategy Graph control.</p>
     * 
     * @class
     * @extends mstrmojo.Widget
     */
    var graphBase = mstrmojo.GraphBase = mstrmojo.declare(
        // superclass
        mstrmojo.Widget,
        
        // mixins,
        null,
        
        /** 
         * @lends mstrmojo.GraphBase.prototype
         */
        {
            scriptClass: "mstrmojo.GraphBase",
            
            cssClassPrefix: "mstrmojo-GraphBase",
            
            markupString: '<div id="{@id}" class="{@cssClassPrefix} {@cssClass}" title="{@tooltip}" style="{@domNodeCssText};">' +
                              '<div class="{@cssClassPrefix}-txt"></div>' +
                              '<img {@att}src="../images/1ptrans.gif" class="{@cssClassPrefix} {@cssImageClass}"/>' +
                              '{@map}' +
                          '</div>',
                          
            /**
             * This property stores the attributes required for the image node.
             * 
             * @type String
             * @default ''
             */
            att: '',
            
            /**
             * This property stores the calculated map markup string based on the areas property provided 
             * in the data.
             * 
             * @type String
             * @default ''
             */
            map: '',
            
            /**
             * Denotes the currently highlighted area. -1 denotes that no area is selected.
             * 
             * 
             */
            cAreaIdx: -1, // current mouse on area index. when it is -1 means no area is pointed by mouse
            
            /**
             * This property denotes whether the graph uses richly styled tooltips
             * 
             * @type Boolean
             * @default true
             */
            useRichTooltip: true,
            
            markupSlots: {
                imgNode: function(){ return this.domNode.childNodes[1]; },
                mapNode: function() {return this.domNode.childNodes.length > 2 ? this.domNode.childNodes[2] : null;},
                textNode: function() { return this.domNode.firstChild; }
            },
        
            markupMethods: {
                onvisibleChange: function(){ this.domNode.style.display = (this.visible) ? 'block' : 'none'; }
            },
            
            preBuildRendering: function preBuildRendering() {
                // Generate markup and properties for image map use.
                generateImageMap.call(this);

                return this._super();
            },

            postBuildRendering: function postBuildRendering() {
                // Configure whether we need to show an error message or show the graph.
                configureDisplay.call(this);
                
                //Call super.
                return this._super();
            },
            
            setModel: function setModel(model) {
                this.model = model;
            },
            
            /**
             * Positions tooltip correctly according to current slider's position and style (horizontal/vertical).
             * Updates tooltip content to current selection.
             * 
             * @param {HTMLAreaElement} elem The DOM Element for which the tooltip needs to updated.
             * @param {Object} ep An object with the x and y coordinates of the screen event (mouse or touch)
             * @param {boolean} [useGivenCoords=false] Optional argument if set to true do not compute the object position but use the given coords in ep object
             * @private
             */
            updatingTooltipHelper: function updatingTooltipHelper(elem, ep, useGivenCoords) {
                var aid = elem && elem.getAttribute('aid'),
                    ttl = elem && elem.getAttribute('ttl'),
                    borderColor = elem.getAttribute('SC'),
                    ttN = {
                            refNode : this.domNode,
                            posType: mstrmojo.tooltip.POS_BOTTOMLEFT,
                            contentNodeCssClass: 'gp-tooltip'
                        },
                    zoom = (this.model.zf || 1) + 'em';
                
                // Is the mouse over the currently visible tooltip area?
                if (aid == this.cAreaIdx) {
                    // Nothing to do.
                    return;
                }
                
                // update current focused area index
                this.cAreaIdx = aid;
                
                // update tooltip content
                ttN.content = ttl;
                var cssText = 'font-size:' + zoom + ';';

                // update font-size for zoom if area has color property set the border color of tooltip to be the same
                if (borderColor) { // #502810
                    cssText += 'border-color:#' + borderColor;
                }

                ttN.contentNodeCssText = cssText;
                
                // calculate tooltip position
                var c = elem.getAttribute("coords"),
                    x = 99999,
                    y = 99999;
    
                if (!useGivenCoords) { //# 502818,502857,502719
                if (c && c.length > 0) {
                    c = c.split(",");
                    
                    var i = 0;
                    while (i + 1 < c.length) {
                        x = Math.min(x, parseInt(c[i++], 10));
                        y = Math.min(y, parseInt(c[i++], 10));
                    }
                }                    
                }

                if (x === 99999) {
                    x = ep.x;
                }
                if (y === 99999) {
                    y = ep.y;
                }
                
                // show tooltip
                ttN.top = y;
                ttN.left = x;
                
                this.richTooltip = null;
                
                this.set('richTooltip', ttN);
            },
            
            /**
             * Rather than rebuild the graph we can just replace the image source (using a preLoader to avoid flashing).
             * 
             * @see mstrmojo.Widget
             * @ignore
             */
            refresh: function refresh() {
                // Have we not rendered already?
                if (!this.hasRendered) {
                    // Nothing to do.
                    return;
                }

                // Configure the slots for current display.
                configureDisplay.call(this);

                // Do we have a map and is the widget not minimized?
                var f = this.getFormats();
                if (f.height && f.width) {
                    // Refresh the map.
                    this.refreshMap();
                }
            },

            /**
             * Regenerates the image map associated with the image.
             * 
             */
            refreshMap: function refreshMap() {
                // Regenerate the map.
                generateImageMap.call(this);
            },

            /**
             * This method returns the name of the shape as understood by the browser, based on the shape type returned 
             * from the server.
             * 
             * @param {Integer} shapeType The integer code for the shape type.
             *
             * @return String The type of area shape.
             */
            getAreaShapeName: function getAreaShapeName(shapeType) {
                return areaShapeMap[parseInt(shapeType, 10)] || 'default';
            }
        }
    );

    var tooltipCls = graphBase.tooltipCLS = "mstrmojo-mobileGraph-Tooltip-content",
        canvasCls = graphBase.canvasCLS = "mobile-graph-highlight-canvas";

    graphBase.hideTooltips = function () {
        // Hide all the tooltips if present.
        $ARR.forEach(document.getElementsByClassName(tooltipCls), function (tooltip) {
            tooltip.style.display = 'none';
        });

        // Clear any markers drawn on the highlight canvas.
        $ARR.forEach(document.getElementsByClassName(canvasCls), function (canvas) {
            canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
            canvas.width = canvas.width;
        });
    };

}());
(function() {
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.registry", "mstrmojo.tooltip");
    var $D = mstrmojo.dom;
    var $R = mstrmojo.all;

    /**
     * <p>This is a mixin for Drag and Drop Framework. </p>
     *
     * <p>All its logics are delegated to 'dnd' component.
     *
     * @class
     * @public
     */
    mstrmojo._HasDnD = {
            // after building the widget, wire up DnD functionality
            postBuildRendering: function postBuildRendering() {
                if (this._super) {
                    this._super();
                }

                // DnD logics are all in 'dnd' namespace.
                var id = this.id;
                this.dnd = new mstrmojo._DnDComponent({
                    target: this
                });
                this.__mouseDownEvt = function (e) {
                    $R[id].dnd.onmousedown(e);
                    return true;
                };
                $D.attachEvent(this.dndNode, 'mousedown', this.__mouseDownEvt);
            },

            unrender: function unrender() {
                // Destroy the dom event handler.
                if (this.__mouseDownEvt && this.dndNode) {
                    $D.detachEvent(this.dndNode, 'mousedown', this.__mouseDownEvt);
                }
                
                // reset the min and max to the default value
                this.min = 0;
                this.max = (this.items && this.items.length - 1) || 0;

                this.dnd && this.dnd.clearListeners();
                this._super();
            }

    };
    /**
     * <p>The DnD component which will be used by mstrmojo._HasDnD mixin. </p>
     *
     * This component will be created and initiated for each component that needs DnD support.
     * It expects the client to setup a property called <b>'dndNode'</b> before _HasDnD.postBuildRendering() is called.
     * DnD feature will listen to the mousedown event of this <b>'dndNode'</b> to start to drag.
     * It has three empty functions which expect client to plugin real implementation:</p>
     * <ul>
     * <li>afterDragStart -- will be called just before dragging starts;</li>
     * <li>duringDrag    -- will be called for each mouse move during the drag;</li>
     * <li>afterDragEnd -- will be called after mouse up, and drag stops.</li>
     * </ul>
     *
     * @class
     */
    mstrmojo._DnDComponent = mstrmojo.declare(
        // super class
        null,
        // mixin
        null,
        // instance members
        {
                scriptClass: "mstrmojo._DnDComponent",
                //draggable: true,
                isDragging: null,

                // an object which client can use it to record initial dragging state.
                initD: null,
                // The event starts whole DnD sequence.
                startE: null,
                // abstract methods for client to implement
                afterDragStart: null,
                duringDrag: null,
                afterDragEnd: null,

                // reference back to the object using DnD
                target: null,

                // the number of mouse move before dragging start
                mousemoveBuffer: 1,

                // private properties
                _mousemoveCounter: 0,
                /**
                 * Constructor for DnD component
                 */
                init: function init_DnDComp(props) {

                    // Apply the given properties to this instance.
                    mstrmojo.hash.copy(props, this);    // Optimization: use copy rather than mixin, unless truly needed.
                },
                /**
                 * Call back for mousedown to start monitoring mouse move.
                 */
                onmousedown: function onmousedown(e) {
                    // For an FF bug. When attempting to drag, the icon changes to a circle with a slash through it.
                    // Firefox has behavior where it allows you to drag images off to other windows, or on to the desktop. This is likely interfering with the drag operation.
                    // The solution in Firefox is to call event.preventDefault() in the onmousedown event handler to cancel the default image handling.
                    if (e && e.preventDefault) {
                        e.preventDefault();
                    }

                    if (this.dragging) {
                        return true;
                    }



                    var id = this.target.id;
                    if (!this._mousemoveCallback) {
                        this._mousemoveCallback = function(e) {
                            $R[id].dnd.onmousemove(e);
                            return true;
                        };
                    }
                    this._mousemoveCounter = 0;

                    this.startE = mstrmojo.hash.copy(e);

                    $D.attachEvent(document.body, 'mousemove', this._mousemoveCallback);

                    if (!this._cancelCallback) {
                        this._cancelCallback = function(e) {
                            $R[id].dnd.ondragcancel(e);
                            return true;
                        };
                    }

                    $D.attachEvent(document.body, 'mouseup', this._cancelCallback);
                },
                /**
                 * Call back for mouse up after mouse down but before mouse move. So, basically cancel the drag action
                 */
                ondragcancel: function ondragcancel(e) {
                    // This gets called only if you mousedown but never start a drag.
                    $D.detachEvent(document.body, 'mousemove', this._mousemoveCallback);
                    $D.detachEvent(document.body, 'mouseup', this._cancelCallback);

                    if (this.afterDragCancel) {
                    	this.afterDragCancel.apply(this.target, [e]);
                    }
                },
                /**
                 * Call back for mouse move. When mousemove exceed the limit, then start dragging
                 */
                onmousemove: function onmousemove(e) {
                    if (this.dragging) {
                        return;
                    }
                    this._mousemoveCounter++;
                    if (this._mousemoveCounter > this.mousemoveBuffer) {
                        $D.detachEvent(document.body, 'mousemove', this._mousemoveCallback);
                        $D.detachEvent(document.body, 'mouseup', this._cancelCallback);

                        this.initDrag(e);
                    }
                },
                /**
                 * Initialize dragging.
                 */
                initDrag: function initDrag(e) {
                    this.dragging = true;
                    var id = this.target.id;
                    if (!this._dragCallback) {
                        this._dragCallback = function(e) {
                            $R[id].dnd.ondrag(e);
                            return true;
                        };
                    }

                    $D.attachEvent(document.body, 'mousemove', this._dragCallback);

                    if (!this._dragEndCallback) {
                        this._dragEndCallback = function(e) {
                            $R[id].dnd.ondragend(e);
                            return true;
                        };
                    }
                    $D.attachEvent(document.body, 'mouseup', this._dragEndCallback);

                    // hookup
                    if (this.afterDragStart) {
                        this.afterDragStart.apply(this.target, [e]);
                    }

                    this._dragCallback(e);
                },
                /**
                 * The call back to handle real dragging action.
                 */
                ondrag: function ondrag(e) {
                    // hookup
                    if (this.duringDrag) {
                        this.duringDrag.apply(this.target, [e]);
                    }
                },
                /**
                 * The call back when dragging ends.
                 */
                ondragend: function ondragend(e) {
                    this.dragging = false;
                    $D.detachEvent(document.body, 'mousemove', this._dragCallback);
                    $D.detachEvent(document.body, 'mouseup', this._dragEndCallback);
                    // hook up
                    if (this.afterDragEnd) {
                        this.afterDragEnd.apply(this.target, [e]);
                    }
                },

                clearListeners: function clearListeners() {
                    // clear all the listeners if still registered
                    if(this._mousemoveCallback) {
                        $D.detachEvent(document.body, 'mousemove', this._mousemoveCallback);
                        delete this._mousemoveCallback;
                    }

                    if(this._cancelCallback) {
                        $D.detachEvent(document.body, 'mouseup', this._cancelCallback);
                        delete this._cancelCallback;
                    }


                    if(this._dragCallback) {
                        $D.detachEvent(document.body, 'mousemove', this._dragCallback);
                        delete this._dragCallback;
                    }

                    if(this._dragEndCallback) {
                        $D.detachEvent(document.body, 'mouseup', this._dragEndCallback);
                        delete this._dragEndCallback;
                    }
                }
        }
    );

    mstrmojo.requiresCls("mstrmojo.Widget", "mstrmojo._HasDnD", "mstrmojo._ListSelections");
    /**
     * Helper object for single slider calculations.
     *
     * @private
     * @ignore
     */
    function SingleSlider(sl) {
        this.getUnit = function getUnit() {
            return sl._effLen / (sl.items.length - 1) || 1;
        };

        this.calcMinMax = function (pxMin, pxMax) {
            var p = Math.round((pxMin / sl.unit + pxMax / sl.unit) / 2);
            return {
                min: p,
                max: p
            };
        };

        this.preUpdateThumb = function () {
            sl.start = Math.min(sl.min * sl.unit, sl._effLen) + 'px';
            sl.sdCssText += sl.orCfg.posCssP + ':' + sl.start + ';';
        };

        this.updateThumb = function () {
            sl.containerNode.style[sl.orCfg.posCssP] = sl.start = Math.min(sl.min * sl.unit, sl._effLen) + 'px';
        };
    }

    /**
     * Helper object for multi-slider calculations.
     *
     * @private
     * @ignore
     */
    function MultiSlider(sl) {
        this.getUnit = function () {
            return sl._effLen / sl.items.length; // ?? if length == 0 ??
        };

        this.calcMinMax = function (pxMin, pxMax) {
            return {
                min: Math.floor(pxMin / sl.unit + 0.5),
                max: Math.floor(pxMax / sl.unit - 0.5)
            };
        };

        this.preUpdateThumb = function () {
            sl.start = (sl.min * sl.unit) + 'px';
            sl.length = Math.max(Math.round((sl.max - sl.min + 1) * sl.unit - sl.gap), 0) + 'px';
            sl.sdCssText += sl.orCfg.posCssP + ':' + sl.start + ';' + sl.orCfg.lenCssP + ':' + sl.length + ';';
        };

        this.updateThumb = function () {
            sl.start = sl.min * sl.unit + 'px';
            sl.containerNode.style[sl.orCfg.posCssP] = (sl.min * sl.unit) + 'px';
            sl.length = Math.max(Math.round((sl.max - sl.min + 1) * sl.unit - sl.gap), 1) + 'px';
            sl.containerNode.style[sl.orCfg.lenCssP] = sl.length;
        };
    }
    var _tooltipMarkup = '<span>{@content}</span>';
    /**
     * <p>The widget for vertical Slider.</p>
     *
     * @class
     * @extends mstrmojo.Widget
     */
    mstrmojo.Slider = mstrmojo.declare(
            // super class
            mstrmojo.Container,

            // mixins
            [mstrmojo._HasDnD, mstrmojo._ListSelections],

            /**
             * @lends mstrmojo.Slider.prototype
             */
            {
                scriptClass: "mstrmojo.Slider",

                markupString: '<div class="mstrmojo-Slider {@cssClass} {@clsType} {@clsOrientation}" style="{@cssText}" >' +
                                '<div class="cont">' +
                                	'<div class="bk" style="{@bkCssText}"></div>' +
                                	'<div class="sdc" style="position:absolute;{@sdcCssText}">' +
	                                    '<div class="sd" style="{@sdCssText}">' +
	                                        '<div class="t1"></div>' +
	                                        '<div class="t2"></div>' +
	                                        '<div class="t3"></div>' +
	                                    '</div>' +
                                    '</div>' +
                                '</div>' +
                            '</div>',

                sdCssText: '',

                cssClass: 'sc',

                clsType: 'sc2',

                clsOrientation: 'sc-v',

                /**
                 * Private object to hold orientation configuration parameters.
                 *
                 * @private
                 * @type Object
                 */
                orCfg: null,

                /**
                 * An object that the slider uses for calculating thumb positions.
                 *
                 * @private
                 * @type Object
                 */
                typeHelper: null,
                /**
                 * How to position the tooltip. refer to mstrmojo.Tooltip.posType
                 *
                 * @type Integer
                 * @private
                 */
                _tooltip_pos: 0,

                useRichTooltip: true,

                init: function init(p) {
                    this._super(p);

                    // Setup orientation based configuration parameters.
                    if (p.isHoriz) {
                        this.orCfg = {
                            posCssP : 'left',
                            marginCssP: 'marginLeft',
                            lenCssP : 'width',
                            lenP : 'clientWidth',
                            opPosCssP: 'top',
                            thickP: 'clientHeight',
                            offsetP: 'x'
                        };

                        this.clsOrientation = ' sc-h';
                        this._tooltip_pos = mstrmojo.tooltip.POS_BOTTOMLEFT;
                    } else {
                        this.orCfg = {
                            posCssP : 'top',
                            marginCssP: 'marginTop',
                            lenCssP: 'height',
                            lenP : 'clientHeight',
                            opPosCssP: 'left',
                            thickP: 'clientWidth',
                            offsetP: 'y'
                        };
                        this._tooltip_pos = mstrmojo.tooltip.POS_TOPRIGHT;
                    }
                    // TQMS 394889
                    this._exRoom = this.thumbWidth;
                    if (this.multiSelect) {
                        this._exRoom *= 2;
                    }

                    // Change type class if multi-select.
                    if (p.multiSelect) {
                        this.typeHelper = new MultiSlider(this);
                    } else {
                        this.clsType = 'sc1';

                        this.typeHelper = new SingleSlider(this);
                    }
                },

                markupSlots: {
                    dndNode: function() {return this.domNode.childNodes[0];},    // dndNode needed by DnD feature
                    bgNode: function() {return this.domNode.childNodes[0].childNodes[0];},
                    sdcNode: function() {return this.domNode.childNodes[0].childNodes[1];},
                    containerNode: function() {return this.domNode.childNodes[0].childNodes[1].childNodes[0];},
                    frontNode: function() {return this.domNode.childNodes[0].childNodes[1].childNodes[0].childNodes[0];},
                    thumbNode: function() {return this.domNode.childNodes[0].childNodes[1].childNodes[0].childNodes[1];},
                    endNode: function() {return this.domNode.childNodes[0].childNodes[1].childNodes[0].childNodes[2];},
                    tooltipNode: function(){return this.domNode.childNodes[0].childNodes[1];}
                },

                markupMethods: {
                    onvisibleChange: function(){ this.domNode.style.display = this.visible ? 'block' : 'none'; }
                },

                start: '50px',    // thumb start position

                length: '30px',    // thumb middle part length

                min: 0,            // lower index of current selection

                max: 0,            // upper index of current selection

                gap: 1,         // the extra -1 is an extra, so our thumb actually is a little bit shorter than the slot on the slider allocated for a unit

                ghost: null,    // the ghost image of the dragging thumb

                thumbWidth: 11,

                /**
                 * The border width for the slider track element (css rule 'bk').
                 */
                cssBkBW: 1,

                //========================= Rendering ============================================================
                preBuildRendering: function preBuildRendering() {


                    // Add the length of the slider track to the css text property.
                    var d = this.orCfg.lenCssP,
                        v = this[d],
                        len = parseInt(v);

                    this._effLen = isNaN(len) ? 0 : (len - this._exRoom);

                    if (v) {
                        this.bkCssText = d + ':' + Math.max(parseInt(v, 10) - (2 * this.cssBkBW), 0) + 'px;';
                        this.sdcCssText = d + ':' + this._effLen + ';' + this.orCfg.posCssP + ':' + this._exRoom /2 + 'px;' + this.orCfg.opPosCssP + ':0px;';

                    }

                    // selection related calculation
                    var idx = this.selectedIndices;
                    if (!mstrmojo.hash.isEmpty(idx)) {
                        this.min = this.items.length - 1;
                        this.max = 0;


                        // Calculate min and max values.
                        for (var i in idx) {
                            if (idx[i]) {
                                this.min = Math.min(this.min, i);
                                this.max = Math.max(this.max, i);
                            }
                        }
                    }
                    this.unit = this.typeHelper.getUnit();
                    this.typeHelper.preUpdateThumb();
                },

                postBuildRendering: function postBuildRendering() {
                    if (this._super) {
                        this._super();
                    }

                    if (this.items.length > 1 && this.dnd) {
                        // set up DnD
                        this.dnd.afterDragStart = this.initDrag;
                        this.dnd.duringDrag = this.ondrag;
                        this.dnd.afterDragEnd = this.ondrop;
                        this.dnd.afterDragCancel = this.cancelDrag;
                    }
                },

                //======================= Drag and Drop ======================================
                _initGhost: function _initGhost() {
                    if (!this.ghost) {
                        var cn = this.containerNode.cloneNode(true);
                        mstrmojo.css.addClass(cn, ['gh']);

                        // MH: These names are kind of long, especially 'containerNode'.
                        this.ghost = {
                            containerNode: cn,
                            frontNode: cn.childNodes[0],
                            thumbNode: cn.childNodes[1],
                            endNode: cn.childNodes[2]
                        };

                        this.sdcNode.appendChild(cn);
                    }

                    // initialize the ghost to be the same look and feel as the item it's ghosting.
                    var gSty = this.ghost.containerNode.style,
                        cnSty = this.containerNode.style,
                        oc = this.orCfg;

                    gSty[oc.posCssP] = cnSty[oc.posCssP];
                    gSty[oc.lenCssP] = cnSty[oc.lenCssP];
                    gSty.display = 'block';

                    return this.ghost;
                },

                initDrag: function initDrag(e, hWin) {
                    hWin = hWin || window;

                    // create ghost
                    var g = this._initGhost(),
                        oc = this.orCfg;

                    // calculate initial state
                    this.dnd.initD = {
                            tP: parseInt(this.start, 10),                        // start position
                            sL: this._effLen,                 // slider length
                            contL: g.containerNode[oc.lenP],                     // container length
                            offset: $D.getMousePosition(this.dnd.startE, hWin)[oc.offsetP]     // mouse start offset
                        };

                        this.dnd.initD.td = $D.eventTarget(hWin, this.dnd.startE);
                },

                ondrag: function ondrag(/*DomEvent*/ e, hWin){
                    hWin = hWin || window;

                    var initD = this.dnd.initD,
                        g = this.ghost,
                        cn = g.containerNode,
                        minPx,
                        maxPx,
                        lenPx,
                        min = this.min,
                        max = this.max,
                        oc = this.orCfg;

                    // mouse position offset from initial state
                    var diff = $D.getMousePosition(e, hWin)[oc.offsetP] - initD.offset;
                    switch (initD.td) {
                        case this.thumbNode:    // move
                            minPx = Math.max(Math.min(initD.tP + diff, initD.sL - initD.contL), 0);
                            maxPx = minPx + initD.contL;

                            cn.style[oc.posCssP] = minPx + 'px';

                            var minmax = this.typeHelper.calcMinMax(minPx, maxPx);
                            min = minmax.min;
                            max = minmax.max;
                            break;

                        case this.frontNode:    // stretch forward
                            minPx = Math.max(Math.min(initD.tP + diff, initD.tP + initD.contL), 0);
                            lenPx = Math.max(Math.min(initD.contL - diff, initD.tP + initD.contL), 0);

                            cn.style[oc.posCssP] =  minPx + 'px';
                            cn.style[oc.lenCssP] =  lenPx + 'px';

                            min = Math.min(Math.floor(minPx / this.unit + 0.5), this.max);
                            break;

                        case this.endNode:        // stretch backward
                            lenPx = Math.max(Math.min(initD.contL + diff, initD.sL - initD.tP), 0);
                            maxPx = initD.tP + lenPx;

                            cn.style[oc.lenCssP] =  lenPx + 'px';

                            max = Math.max(Math.floor(maxPx / this.unit - 0.5), this.min);
                            break;

                        default:
                            return;

                    }

                    // update this.min and this.max according to newly calculated min/max
                    if (min !== this.min || max !== this.max) {
                        this.min = min;
                        this.max = max;

                        // update thumb
                        this.typeHelper.updateThumb();
                    }

                    this._updateTooltip();
                },

                ondrop: function ondrop(/*DomEvent*/ e){
                    // update real thumb
                    this.typeHelper.updateThumb();

                    // hide ghost
                    if (this.ghost) {
                        this.ghost.containerNode.style.display = "none";
                    }

                    // hide tooltip
                    this.hideTooltip();

                    // update selection
                    if (this.items && this.items.length){ // TQMS 397884
                    var sel = [];
                    for (var i = this.min; i <= this.max; i ++) {
                        sel.push(i);
                    }

                    this.select(sel);
                    }
                    // remove temporary data
                    this.dnd.initD = null;
                },

                cancelDrag: function cancelDrag(e, hWin) {
                	if (this.makeSelection) {
                		hWin = hWin || window;
                		var td = $D.eventTarget(hWin, this.dnd.startE);
                		this.makeSelection({
                			selItem: td
                		});
                	}
                },

                //======================= Tooltip ===================================================
                showTooltip: function showTooltip(e, win) {
                    this._updateTooltip();
                    this._super(e, win);
                },

                hideTooltip: function hideTooltip(e, win) {
                    // if still dragging, return, we need to keep the tooltip
                    if (this.dnd && this.dnd.dragging) {
                        return;
                    }
                    this._super(e, win);
                },
                /**
                 * Positions tooltip correctly according to current slider's position and style (horizontal/vertical).
                 * Updates tooltip content to current selection.
                 *
                 * @private
                 */
                _updateTooltip: function _updateTooltip() {

                    var oc = this.orCfg,
	                    tt = {
	                            contentNodeCssClass: 'sc-tooltip',
	                            refNode: this.domNode,
	                            posType: this._tooltip_pos // can be mstrmojo.Tooltip.POS_BOTTOMLEFT or mstrmojo.Tooltip.POS_TOPRIGHT
	                        },
                    	ref = (this.ghost) ? this.ghost.containerNode : this.containerNode;

                    //@TODO length depends on _updateThumb to be called first.
                    tt[oc.opPosCssP] = 0; // this.domNode[oc.thickP];
                    tt[oc.posCssP] = ref.style[oc.posCssP];

                    if (this.items && this.items.length) { // TQMS 397884
	                    var min = this.getItemTooltip(this.items[this.min]);
                    var txt;
                    if (this.min === this.max) {
	                        txt = min;
                    } else {
	                        txt = mstrmojo.desc(146, "From:") + " \'" +
	                            min +
	                            "\' " + mstrmojo.desc(147, "To:") + " \'" +
	                            this.getItemTooltip(this.items[this.max]) + '\'';
	                    }

	                    tt.content = _tooltipMarkup.replace(/\{@content\}/g, txt);
                    } else {
                    	tt.content = '';
                    }
                    // this will trigger tooltip widget to refresh itself. if tooltip has already been rendered.
                    this.set('richTooltip', tt);
                },

                /**
                 * Returns the tooltip for an item. Default implementation return the n property of the item within single quote
                 */
                getItemTooltip: function(item) {
                    return "'" + (item ? item.n : "") + "'";
                },

                unrender: function unrender(ignoreDOM) {
                    this.ghost = null;
                    this.dnd && (this.dnd.dragging = false);
                    this.hideTooltip();
                    this._super(ignoreDOM);
                },

                //======================= Event handling for selection change =========================
                onselectionChange: function onselChg(evt) {
                    // A hook for custom behavior
                    if (this.onchange) {
                        this.onchange();
                    }

                	if (this.makeSelection && this.dnd && this.dnd.initD) {
                		this.makeSelection({
                			selItem: this.dnd.initD.td
                		});
                	}
                }
            }
    );
    mstrmojo.Slider.SINGLE_HANDLE_WIDTH = 11;
    mstrmojo.Slider.SCROLLHANDLEWIDTH = 11;

})();
(function() {
    mstrmojo.requiresCls("mstrmojo.dom", "mstrmojo.registry", "mstrmojo.tooltip","mstrmojo.HBox");
    var $D = mstrmojo.dom,
        $C = mstrmojo.css,
        VALIGN_TOP = 1,
        VALIGN_MIDDLE = 2,
        VALIGN_BOTTOM = 3,
        getVerticalAlign = function(dom) {
            var va = $C.getStyleValue(dom, 'verticalAlign');
            return {'top': VALIGN_TOP, 'bottom': VALIGN_BOTTOM, 'middle': VALIGN_MIDDLE}[va] || VALIGN_TOP; //default is always top
        };
    
    mstrmojo.SliderBox = mstrmojo.declare(
        mstrmojo.Container,
        
        null,
        
        {
            scriptClass: 'mstrmojo.SliderBox',

            markupString: '<div id="{@id}" class="{@cssClass}" style="{@cssText}" tabindex="{@tabIndex}" >' +
                              '<div class="valuePart" style="{@valueCssText}">' +
                                  '<span class="valueLabel">{@valueLabel}</span>' +
                                  '<span class="valueText">{@valueText}</span>' +
                              '</div>' +
                              '<table class="sliderPart" style="{@sliderCssText}">' +
                                  '<tbody><tr>' + 
                                      '<td class="minText">{@min}</td>' +
                                      '<td class="sliderWrapper"></td>' +
                                      '<td class="maxText">{@max}</td>' +
                                  '</tr></tbody>' + 
                              '</table>' +
                          '</div>',

            markupSlots: {
                valuePartNode: function(){ return this.domNode.firstChild; },
                valueLabelNode: function(){ return this.domNode.firstChild.firstChild; },
                valueTextNode: function(){ return this.domNode.firstChild.lastChild; },
                sliderPartNode: function() { return this.domNode.lastChild; },
                minTextNode: function(){ return this.domNode.lastChild.rows[0].cells[0]; },
                maxTextNode: function(){ return this.domNode.lastChild.rows[0].cells[2]; },
                sliderNode: function(){ return this.domNode.lastChild.rows[0].cells[1]; }
            },
            
            markupMethods: {
                onmaxChange: function(){ this.maxTextNode.innerHTML = this.max; },
                onminChange: function(){ this.minTextNode.innerHTML = this.min; },
                onvalueTextChange: function(){ this.valueTextNode.innerHTML = this.valueText; },
                onunsetChange: function() {
                    var sliderNode = this.sliderBar.domNode;
                    if (sliderNode){
                        mstrmojo.css.toggleClass(sliderNode, 'unset', this.unset); 
                    }
                }
            },
            
            tabIndex: -1,
            
            sliderRef: null,
            
            valueLabel: mstrmojo.desc(4104, 'Value:'),
            
            valueText: '',
            
            min: '',
            
            max: '',
            
            interval: 0,
            
            isSequential: false, //Whether the values are sequential

            unset: false,
            
            cssClass: 'mstrmojo-SliderGroup',
            
            postCreate: function postCreate() {
                //add the slider reference class object as its child
                if(!this.sliderRef) {
                    this.sliderRef = {
                        scriptClass: 'mstrmojo.Slider', 
                        isHoriz: true, 
                        ontitleChange: function() {
                            if(this.domNode && this.title) {
                                this.domNode.setAttribute('title', this.title);
                            }
                        },
                        onselectionChange: function() {
                            if(!this.hasRendered) {
                                return ;
                            }
                            var v = this.items[this.selectedIndex] && this.items[this.selectedIndex].n,
                                w = this.parent;
                            
                            if (w.unset){
                                w.unset = false;
                                $C.removeClass(this.domNode, 'unset');
                            }
                            
                            w.set('valueText', v);
                            w.set('value', v);
                            this.typeHelper.updateThumb();
                        }
                    };
                }
                
                this.sliderRef.slot = 'sliderNode'; 
                this.sliderRef.alias = 'sliderBar';
                this.addChildren(this.sliderRef);
            },
            
            preBuildRendering: function(){
                this._super();
                
                var min = this.min, 
                    max = this.max, 
                    v = mstrmojo.num.parseNumeric(this.value), 
                    items = this.items,
                    idx,
                    sliderBar = this.sliderBar;
                
                if (this.isSequential){
                    //Try to locate the nearest spot inside the range. Mark it unset if out of the range
                    idx = Math.floor((Math.max(Math.min(v, max), min) - min) / this.interval);
                    if(isNaN(v) || v < min || v > max) {
                        this.unset = true;
                    }
                }else{
                    //If the value is not found in the items collection, mark it unset
                    idx = mstrmojo.array.find(items, 'v', String(v));
                    if (idx == -1){
                        this.unset = true;
                        idx = 0;
                    }
                }
                
                sliderBar.set('items', items);
                sliderBar.select(idx || 0);
            },
            
            postBuildRendering: function(){
                this._super();
                
                if (this.unset){
                    $C.addClass(this.sliderBar.domNode, 'unset');
                }
            },
            
            //align the value and position of slider 
            alignSlider: function(baseNode, height) {

                var va = getVerticalAlign(baseNode),
                    ws, wv;

                //if not rendered yet
                if(!this.valuePartNode) {
                    wv = this.valueCssText || '';
                    ws = this.sliderCssText || ''; 
                    
                    if(va === VALIGN_TOP) {
                        this.valueCssText = 'top:0;' + wv;
                        this.sliderCssText = 'top:0;' + ws;
                    }else if(va === VALIGN_BOTTOM) {
                        this.valueCssText = 'bottom:0;' + wv;
                        this.sliderCssText = 'bottom:0;' + ws;
                    } else {
                        this.valueCssText = 'height: 100%; line-height: ' + height + 'px;' + wv;
                        this.sliderCssText = 'height: 100%;' + ws;
                    }
                
                //if already rendered
                } else {
                    ws = this.sliderPartNode.style;
                    wv = this.valuePartNode.style;
                    
                    //vertical align
                    if(va) {
                        if(va === VALIGN_TOP) {
                            ws.top = wv.top ='0';
                        } else if(va === VALIGN_BOTTOM) {
                            ws.bottom = wv.bottom = '0';
                        } else {
                            wv.height = ws.height = '100%';
                            wv.lineHeight = inlineHeight + 'px';
                        }
                    }
                }
            }
        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.DocLayoutViewer",
                         "mstrmojo._Formattable",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.dom");

    //TQMS 618291.
    function checkLinks(checkAll) {
        var links,
            newLinks = this._newLinks,
            allLinks = mstrmojo.hash.copy(newLinks, this._allLinks),
            links = checkAll ? allLinks : newLinks;
        
        this._newLinks = {};
        
        // Re-check this condition here because this function can be called asynchronously
        // so the state can change between then and now.
        if ( mstrMobileApp.isOnline() ) {
            return;
        }

        // Build link requests to check which ones can be fulfilled via caches.
        var controller = this.controller,
            i,
            lnk,
            linkRequests = [],
            cacheableLinks = [],
            req;

        for (i in links) {
            lnk = links[i];
            req = controller.getLinkRequest(lnk);
            if (req) {
                linkRequests.push(req);
                cacheableLinks.push(lnk);
            }
        }

        // Submit requests
        var count = linkRequests.length;
        if (count) {
            // On request completion enable/disable links.
            var fnSuccess = function (res) {
                for (i = 0; i < count; i++) {
                    lnk = cacheableLinks[i];
                    lnk.src.setLinkEnabled(res[i]);
                }
            };

            if (mstrApp.isHosted()) {
                /*/DEBUG
                window.setTimeout(function () {
                    fnSuccess([true]);
                },100); //*/

            } else {
                this.model.getDataService().checkCachedLinkTargets(linkRequests, {
                    success: fnSuccess,
                    failure: mstrmojo.emptyFn
                });
            }
        }
    }
    
    function applyChildDimensions() {
        var ch = this.children,
        i,
        len;

        // Iterate children and set their slot dimensions.
        for (i = 0, len = (ch && ch.length) || 0; i < len; i++) {
            var child = ch[i],
                slot = child.slot;

            // Do we have a slot?
            if (slot) {
                // Apply final slot dimensions.
                this.setSlotDimensions(slot, child.height, child.width);
            }
        }
    }

    /**
     * The widget used to display a MicroStrategy Report Services Layout on a mobile device.
     *
     * @class
     * @extends mstrmojo.DocLayoutViewer
     */
    mstrmojo.MobileDocLayoutViewer = mstrmojo.declare(
        // superclass
        mstrmojo.DocLayoutViewer,

        // mixins,
        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        /**
         * @lends mstrmojo.MobileDocLayoutViewer.prototype
         */
        {
            scriptClass: "mstrmojo.MobileDocLayoutViewer",

            layoutConfig: {
                h: {
                    groupBy: '0',
                    fixedHeaderNode: 'auto',
                    layout: '100%',
                    fixedFooterNode: 'auto',
                    incFetchNode: '0'
                },
                w: {
                    layout: '100%'
                }
            },

            formatHandlers: {
                domNode: [ 'background-color' ]
            },

            scrollerConfig: {
                vScroll: false,
                hScroll: false,
                bounces: false,
                showScrollbars: false
            },
            

            usesTouches: true,
            
            init: function init(params) {
                this._super(params);
                this._newLinks = {};
                this._allLinks = {};
                
            },
            
            postBuildRendering: function postBuildRendering() {
            	this._super();

                // #716067 for docked footer if height can grow or shrink we need to adjust the dimensions of all the children objects
                if(this.fixedFooterNode.clientHeight > 0) {
                    applyChildDimensions.call(this);
                }
            },

            preBuildRendering: function preBuildRendering() {
                this._super();

                this._scrollCssText = 'overflow:' + ((!mstrmojo.dom.isWinPhone) ? 'hidden' : 'auto');

                var id = this.id,
                    updateScroller = this.updateScroller;

                // TQMS 490160 We need to update scroller after incremental rendering as real document size can change.
                if (!this.afterScrollSubscr) {
                    this.afterScrollSubscr = this.docLayout.attachEventListener('afterScroll', id, function () {
                        this.updateScroller();
                        checkLinks.call(this);
                    });

                    // We need to update the scroller even after a partial update has been completed.
                    this.model.attachEventListener('partialUpdate', id, updateScroller);
                }
            },
            //array of vis that requires special handling for beforeViewHidden
            mapID:null,
            setMapID: function setMapID(id) {
                this.mapID = id;
            },
            
            beforeViewHidden: function beforeViewHidden(isBack) {
                if (!this.mapID) return;
                var c = mstrmojo.all[this.mapID];
                if (c && c.beforeViewHidden) {
                    c.beforeViewHidden(isBack);
                }
                this.mapID = null;
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this.scrollerConfig,
                    layoutNode = this.docLayout.containerNode;

                if (layoutNode) {
                    var docLayout = this.docLayout,
                        xOffset = {
                            start: 0,
                            end: Math.max(docLayout.getWidth() - this.scrollboxWidth, 0)
                        },
                        yOffset = {
                            start: 0,
                            end: Math.max(docLayout.getHeight() - this.scrollboxHeight, 0)
                        },
                        vScroll = (yOffset.start !== yOffset.end),
                        hScroll = (xOffset.start !== xOffset.end),
                        offset;

                    // Can we scroll in either the vertical or horizontal direction?
                    if (vScroll || hScroll) {
                        // Create the offset object.
                        offset = {
                            x: xOffset,
                            y: yOffset
                        };
                    } else {
                        // If we can't scroll in either direction and if the user might have previously scrolled - reposition the document correctly.
                        cfg.origin = {
                            x: 0,
                            y: 0
                        };
                    }

                    // Update the scroller config with new values.
                    mstrmojo.hash.copy({
                        scrollEl: this.scrollboxNode.firstChild,    // The DocLayout domNode.
                        offset: offset,
                        vScroll: vScroll,
                        hScroll: hScroll,
                        showScrollbars: false
                    }, cfg);

                    // If we don't have an origin yet, then create one.
                    if (!cfg.origin) {
                        cfg.origin = this._origin = {
                            x: 0,
                            y: 0
                        };
                    }

                    //Add a scroll rendering buffer so that the scrolling experience isn't so choppy
                    docLayout.scrollBuffer = parseInt(mstrApp.rootView.getContentDimensions().h, 10);
                }

                return this._super();
            },

            /**
             * Overridden to attach an event listener to the scroller for scrollDone to notify scroll listeners.
             *
             * @ignore
             */
            initScroller: function initScroller(scroller) {
                this._super(scroller);

                // Attach an event listener to hear when scrolling is done.
                scroller.attachEventListener('scrollDone', this.id, function (evt) {
                    // Update the origin.
                    this._origin = {
                        x: evt.x,
                        y: evt.y
                    };

                    // Notify listeners that we've scrolled.
                    this.notifyScrollListeners(evt);
                });
            },

            touchBegin: function touchBegin(touch) {
                var p = this.parent;
                // is our parent busy displaying another layout?
                if (p && p.isAnimating && p.isAnimating()) {

                    // YES - stop the touch from bubbling
                    touch.stop();

                    // and ignore all touches until done.
                    return false;
                }
                return this._super(touch);
            },

            // #717921 if we are not in the scrollabe area return true
            shouldTouchBubble: function shouldTouchBubble(touch) {
            	if(mstrmojo.dom.contains(this.scrollboxNode, touch.target, true, this.domNode)) {
            		return this._super(touch);
            	}
            	
            	return true;
            },
            
            touchSwipeBegin: function touchSwipeBegin(touch) {
                // Is the layout selector style set to swipe AND should we bubble the touch event?
                if (this.shouldTouchBubble(touch)) {
                    var parent = this.parent,
                    	parentCanScroll = parent.canScroll && parent.canScroll(touch);

                    // Can the parent (MobileDoc) scroll in this direction?
                    if (parentCanScroll) {
                        // Cache that we are allowing the parent to scroll.
                        this._parentScrolling = true;

                        // Tell parent to begin scroll.
                        parent.beginScroll(touch);
                    }
                    
                    return parentCanScroll;
                }

                this._super(touch);
            },

            touchSwipeMove: function touchSwipeMode(touch) {
                // Is the parent scrolling?
                if (this._parentScrolling) {
                    // Pass to parent.
                    this.parent.scroll(touch);

                    return;
                }

                this._super(touch);
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                // Mark the event as handled.
                touch.evt.handled = true;

                // Is the parent scrolling?
                if (this._parentScrolling) {
                    // Kill parent scrolling flag.
                    delete this._parentScrolling;

                    // Pass to parent.
                    this.parent.endScroll(touch);

                    return;
                }

                this._super(touch);
            },

            touchTap: function touchTap() {
                // Does the controller have a viewTap method?
                var ctrl = this.controller;
                if (ctrl && ctrl.viewTap) {
                    // Call it.
                    ctrl.viewTap();
                }
            },

            /**
             * Overridden to update scroller after children are rendered.
             *
             * @ignore
             */
            renderChildren: function rnCh() {
                this._super();

                // We have to wait until the children are rendered before we can populate the scroller.
                this.updateScroller();
            },

            /**
             * @see mstrmojo._HasMarkup
             */
            unrender: function unrender() {
                //Delete any lingering references to the scroller origin to ensure that we scroll back to the top of the document.
                delete this.scrollerConfig.origin;
                var scroller = this._scroller;
                if (scroller) {
                    delete scroller.origin;
                }
                if (this.subscr) {
                    mstrmojo.publisher.unsubscribe(this.subscr);
                    delete this.subscr;
                }
                if (this.afterScrollSubscr) {
                    mstrmojo.publisher.unsubscribe(this.afterScrollSubscr);
                    delete this.afterScrollSubscr;
                }
                //Call super.
                this._super();
            },

            //TQMS 618291.
            addLinkInfo: function addLinkInfo(id, linkInfo) {
                this._newLinks[id] = linkInfo;
            },
            
            /*
            removeLinkInfo: function removeLinkInfo(id) {
                delete this._links[id];
            },
            */
            onRender: function onRender() {
                this._super();

                //TQMS 618291.
                //Subscribe to connectivity events
                if (!this.subscr) {
                    var publisher = mstrmojo.publisher;
                    this.subscr = publisher.subscribe(publisher.NO_SRC, publisher.CONNECTIVITY_CHANGED_EVENT, function (isOnline) {
                        // We add the connectivity listener only if we have links. So we don't need
                        // to check here if this._links is not null.
                        if (isOnline) {
                            //Enable all disabled links
                            var links = this._allLinks,
                                i,
                                widget;

                            for (i in links) {
                                widget = links[i].src;
                                if (!widget.linkEnabled) {
                                    widget.setLinkEnabled(true);
                                }
                            }

                        } else {
                            checkLinks.call(this, true);
                        }
                    }, this.id);
                }

                // Check links when all rendering is done.
                if ((mstrApp.useBinaryFormat || mstrApp.isHosted()) && !mstrMobileApp.isOnline() ) {
                    var me = this;
                    window.setTimeout(function () {
                        checkLinks.call(me);
                    }, 100);
                }
            },
            
            setSlotDimensions: function setSlotDimensions(slot, h, w) {
                if (slot === 'layout') {
                    //based on the dimensions of docked header and footer need to adjust the dimension of layout
                    var winHeight = parseInt(this.height, 10),
                        headerHeight = this.fixedHeaderNode.clientHeight,
                        footerHeight = this.fixedFooterNode.clientHeight,
                        height = parseInt(h, 10),
                        actHeight = winHeight - headerHeight - footerHeight;

                    // if combined height of docked header and footer is bigger than the screen than make the slot height to zero
                    if(headerHeight + footerHeight >= winHeight) {
                        h = 0;
                    } else if( height != actHeight){
                        h = actHeight + 'px';
                    }
                }

                this._super(slot, h, w);
            },
            
            getCaptureDimensions: function getCaptureDimensions() {
            	return this.docLayout.getCaptureDimensions();
            }
        }
    );
}());
(function(){

	mstrmojo.requiresCls(
		"mstrmojo.Container",
		"mstrmojo.HBox",
		"mstrmojo._HasBuilder",
		"mstrmojo._CanMeasureChildren");
	
	/**
	 * Private mixin to shared rendering code among the mstrmojo.DocSection and mstrmojo.DocSectionHoriz.
	 * 
	 * @private
	 */
	var _IsDocSection = {
        
		postBuildRendering: function postBldRndr() {
			return (this.renderMode != 'scroll') ? this._super() : true;
		},

		childRenderOnAddCheck: function(children) {
			return (this.renderMode != 'scroll') ? this._super(children) : false;
		},

		preserveChildDomOrder: false
	};

	function _refresh(me) {
        if (!me.hasRendered) {
            return;
        }
                            
        var c = me.children || [];
        for (var i = c.length - 1; i >= 0; i--) {
            c[i].refresh && c[i].refresh();
        }
	}
	
	/**
	 * Document Section.
	 * @class
	 * 
	 * @extends mstrmojo.Container
	 * 
     * @borrows mstrmojo._HasBuilder#postBuildRendering as #postBuildRendering
     * @borrows mstrmojo._HasBuilder#buildChildren as #buildChildren
     * 
     * @borrows mstrmojo._CanMeasureChildren#height as #height
     * @borrows mstrmojo._CanMeasureChildren#width as #width
	 */
	mstrmojo.DocSection = mstrmojo.declare(
		// superclass
		mstrmojo.Container,
		
		// mixins,
        [ mstrmojo._HasBuilder, _IsDocSection, mstrmojo._CanMeasureChildren ],
		
		/**
		 * @lends mstrmojo.DocSection.prototype
		 */
		{
			scriptClass: "mstrmojo.DocSection",
			
			markupString: '<div id="{@id}" class="mstrmojo-DocSection"></div>',
			
			markupSlots: {
				containerNode: function() { return this.domNode; }
			},
            
			/**
			 * Overrides borrowed width (from {@link mstrmojo._CanMeasureChildren}) so that we only measure the width of the first subsection.
			 * 
			 * @ignore
			 */
			width: function width(count) {
				return this._super(1);
			},
			
            refresh: function refresh() {
				_refresh(this);
            }
		}
	);
	
	
	/**
	 * A Document Section for horizontally repeating data.
	 * @class
	 * 
	 * @extends mstrmojo.HBox
	 * 
     * @borrows mstrmojo._HasBuilder#postBuildRendering as #postBuildRendering
     * @borrows mstrmojo._HasBuilder#buildChildren as #buildChildren
     * 
     * @borrows mstrmojo._CanMeasureChildren#height as #height
     * @borrows mstrmojo._CanMeasureChildren#width as #width
	 */
	mstrmojo.DocSectionHoriz = mstrmojo.declare(
		// superclass
		mstrmojo.HBox,
		
		// mixins,
		[ mstrmojo._HasBuilder, _IsDocSection, mstrmojo._CanMeasureChildren ],
		
		/**
		 * @lends mstrmojo.DocSectionHoriz.prototype
		 */
		{
			scriptClass: "mstrmojo.DocSectionHoriz",
			
			/**
			 * Overrides borrowed height (from {@link mstrmojo._CanMeasureChildren}) so that we only measure the height of the first subsection.
			 * 
			 * @ignore
			 */
			height: function height(count) {
				return this._super(1);
			},
			
			refresh: function refresh() {
				_refresh(this);
			}
		}
	);	
	
})();
 (function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo.func",
                         "mstrmojo.array",
                         "mstrmojo.Button",
                         "mstrmojo.HBox",
                         "mstrmojo.dom",
                         "mstrmojo.Box");

    var $FNC = mstrmojo.func.composite,
        $D = mstrmojo.dom;


    /**
     * Dialog is a modal dialog that has title bar, a collection of buttons and can contain other controls within it.
     *
     * @class
     * @extends mstrmojo.Container
     */
    mstrmojo.Dialog = mstrmojo.declare(

        mstrmojo.Container,

        null,

        /**
         * @lends mstrmojo.Dialog.prototype
         */
        {
            scriptClass: "mstrmojo.Dialog",

            /**
             * An optional title for the dialog.
             *
             * @type String
             */
            title: '',

            /**
             * An optional array of {@link mstrmojo.Button} configuration objects.
             *
             * @type Object[]
             */
            buttons: null,

            /**
             * Alignment of the dialog. Default to center. can also be 'top', 'left', 'right', 'bottom'
             */
            alignment: 'center',

            /**
             * <p>The alignment of the buttons.</p>
             *
             * <p>Possible values are "left" (default) or "right".</p>
             *
             * @type String
             */
            btnAlignment: 'right',

            /**
             * The zIndex used by this popup.
             * In general, if this is a modal popup, the curtain used by this popup would be 1 less than zIndex here.
             */
            zIndex: 10,

            /**
             * Indicate whether the editor is modal or modalless.
             */
            modal: true,

            markupString: '<div id="{@id}" class="mstrmojo-Dialog {@cssClass}" tabindex="0" mstrAttach:click>' +
                              '<div class="win mstrmojo-Editor" style="{@cssText}">' +
                                  '<div class="mstrmojo-Editor-titlebar"><div class="mstrmojo-Editor-title">{@title}</div></div>' +
                                  '<div class="mstrmojo-Editor-content"></div>' +
                                  '<div class="mstrmojo-Editor-buttons"></div>' +
                              '</div>' +
                              '<div class="mstrmojo-Editor-curtain"></div>' +
                              '<div class="mstrmojo-Editor-tip"></div>' +
                          '</div>',

            markupSlots: {
                editorNode: function () { return this.domNode.firstChild; },
                curtainNode: function () { return this.domNode.childNodes[1]; },
                titleNode: function () { return this.domNode.firstChild.firstChild; },
                containerNode: function () { return this.domNode.firstChild.childNodes[1]; },
                buttonNode: function () { return this.domNode.firstChild.lastChild; },
                tipNode: function () { return this.domNode.lastChild; }
            },

            markupMethods: {
                onzIndexChange: function () {
                    this.editorNode.style.zIndex = this.zIndex;
                    this.curtainNode.style.zIndex = this.zIndex - 1;
                },
                onwidthChange: function () {
                    this.editorNode.style.width = this.width || 'auto';
                },
                onvisibleChange: function (init) {
                    if (init) {
                        return;
                    }

                    var v = this.visible,
                        d = v ? 'block' : 'none';

                    this.editorNode.style.display = d;

                    if (this.modal) {
                        this.curtainNode.style.display = d;
                    }
                },
                onleftChange: function () { this.editorNode.style.left = this.left || ''; },
                ontopChange: function () { this.editorNode.style.top = this.top || ''; },
                ontitleChange: function () { this.titleNode.firstChild.innerHTML = this.title || ''; }
            },

            preBuildRendering: function preBuildRendering() {
                var b;

                // Do we have buttons AND do we not already have a button box (TQMS #687264)?
                var buttons = this.buttons;
                if (buttons && !this.btnHbox) {

                    //Add needed base cssclass
                    for (b in buttons) {
                        buttons[b].cssClass = 'mstrmojo-Editor-button';
                    }

                    // An an HBox with the buttons as children.
                    this.addChildren([{
                        scriptClass: 'mstrmojo.HBox',
                        cssText: 'float:' + this.btnAlignment,
                        slot: 'buttonNode',
                        alias: 'btnHbox',
                        children: buttons
                    }, {
                        scriptClass: 'mstrmojo.Label',
                        cssClass: 'mstrmojo-clearMe',
                        slot: 'buttonNode'
                    }]);
                }

                // Is this a modal editor?
                if (this.modal) {
                    // Add 'modal' css class.
                    this.cssClass += ' modal';
                }

                // Call the super.
                return this._super();
            },

            buildRendering: function buildRendering() {
                // Get a reference to the placeholder (since it will be blown away in the _super).
                var ph = this.placeholder;
                
                // Call super.
                if (this._super()) {
                	// Do we not have a parent and did we not have a placeholder?
                    if (!this.parent && !ph) {
                        // Insert the domNode as a child of the body tag.
                        document.body.appendChild(this.domNode);
                    }
                    
                    return true;
                }

                return false;
            },

            // #659420  added function that returns method to resize overwritten in android dialog
            getResizeHandler: function getResizeHandler() {
                var id = this.id;
                return function () {
                    var dialog = mstrmojo.all[id];
                    dialog.resizeDialog();
                    dialog.positionDialog();
                };
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                // Is the dialog model?
                if (this.modal && this.visible) {
                    // Change curtainNode style to block.
                    this.curtainNode.style.display = 'block';
                }

                // Do we NOT have a resize handler yet?
                if (!this._resizeHandler) {
                    // Create handler function.
                    var fn  = this._resizeHandler = this.getResizeHandler();

                    // Attach event listener to window object to hear when window size changes.
                    $D.attachEvent(window, 'resize', fn);
                }

                // resize and position dialog.  #659420 do not call resize Handler since it is overwritten in android and will cause an infinite loop.
                this.resizeDialog();
                this.positionDialog();

                //#576707 - take focus to avoid key event being received by document
                this.domNode.focus();

                return true;
            },

            /**
             * Called during rendering (and after window resizing) to adjust the size of the dialog.
             *
             */
            resizeDialog: function resizeDialog() {
                // Is the dialog modal?
                if (this.modal) {
                    // Resize the curtain.
                    this.resizeCurtain();
                }
            },

            /**
             * Function to resize the curtain when the editor is attached to body.
             * @param {HTMLElement} w the dialog widget.
             */
            resizeCurtain: function resizeCurtain() {
                var w = this,
                	curtainNode = w.curtainNode,
                    body = document.body,
                    docElement = document.documentElement,
                    cs = curtainNode.style,
                    curtainPosition = w.curtainPosition;

                // Set width and height.
                cs.width = Math.max(body.clientWidth, docElement.scrollWidth) + 'px';
                
                if (curtainPosition && curtainPosition.h) {
                	cs.height = curtainPosition.h + 'px';
                } else {
                	cs.height = Math.max(body.clientHeight, docElement.scrollHeight) + 'px';
                }
                
                if (curtainPosition && curtainPosition.y) {
                	cs.top = curtainPosition.y + 'px';
                }
                
                w.raiseEvent({name: 'resizeCurtain'});
            },

            /**
             * Called during rendering (and after window resizing) to position the dialog.
             *
             */
            positionDialog: function positionDialog() {
                // Is the editor not positioned?
                if (!this.left || !this.top) {
                    var editor = this.editorNode;

                    // Center the editor node within browser.
                    $D.center(editor);

                    // Should the editor be aligned with the top?
                    if (this.alignment === 'top') {
                        // Move editor node to top.
                        editor.style.top = '10px';
                    }
                }
            },

            destroy: function (ignoreDom) {
                // Do we have a window resize handler?
                var fn = this._resizeHandler;
                if (fn) {
                    // Detach the handler.
                    $D.detachEvent(window, 'resize', fn);
                }

                this._super(ignoreDom);
            }
        }
    );

    // Do we need to override config and alert with complex dialogs?
    if (window.mstrConfig && !window.mstrConfig.simpleDialog) {

        /**
         * Overrides default {@link mstrmojo.config} method to use mstrmojo.Dialog for displaying a message to the user with configurable buttons.
         *
         * @param {String} msg The message to display.
         * @param {Object[]|mstrmojo.Button[]} buttons An array of type {@link mstrmojo.Button} or an array of configuration objects that will become {@link mstrmojo.Button} when inserted.
         * @param {String} [title="MicroStrategy Web"] An optional title for the dialog.
         *
         * @memberOf mstrmojo
         * @overrides
         */
        mstrmojo.confirm = function confirm(msg, buttons, title) {
            var id = 'mojoConfirmx9',
                fnDestroy = function () {
                    mstrmojo.all[id].destroy();
                };

            // Add code to each button to destroy the dialog.
            mstrmojo.array.forEach(buttons, function (btn) {
                var fn = btn.onclick;
                btn.onclick = fn ? $FNC([ fnDestroy, fn ]) : fnDestroy;
            });

            // Show the dialog.
            mstrmojo.insert({
                scriptClass: 'mstrmojo.Dialog',
                id: id,
                title: title || mstrmojo.desc(3610),
                width: '475px',
                buttons: buttons,
                children: [{
                    scriptClass: 'mstrmojo.Label',
                    text: msg
                }]
            }).render();
        };

        /**
         * Overrides default {@link mstrmojo.config} method to use mstrmojo.Dialog for displaying a message to the user with a single 'Ok' button.
         *
         * @param {String} msg The message to display.
         * @param {Function} [fn] An optional function to be executed after the 'Ok' button is clicked.
         * @param {String} [title="MicroStrategy Web"] An optional title for the dialog.
         *
         * @memberOf mstrmojo
         * @overrides
         */
        mstrmojo.alert = function alrt(msg, fn, title) {

            var id = 'mojoAlertx9';

            try {
                // There are some scenarios where the alert is being rendered twice
                // and causing an error on id duplication, try to destroy it first.
                mstrmojo.all[id].destroy();
            } catch (e) { }

            mstrmojo.insert({
                scriptClass: 'mstrmojo.Dialog',
                id: id,
                title: title || mstrmojo.desc(3610),     // MicroStrategy Web
                width: '475px',
                buttons: [ mstrmojo.Button.newInteractiveButton(mstrmojo.desc(1442), function () {       // OK
                    mstrmojo.all.mojoAlertx9.destroy();
                    if (fn) {
                        fn();
                    }
                }, '#666666')],
                children: [{
                    scriptClass: 'mstrmojo.Label',
                    text: msg
                }]
            }).render();
        };

        /**
         * A toast message appears on the surface of the screen for a moment. It does not take focus and cannot accept user input.
         *
         * @param {String} msg The toast text to display.
         * @param {Integer} [duration=3000] The length the toast message should linger.
         *
         * @static
         */
        mstrmojo.toast = function toast(msg, duration) {

            var id = 'mojoToast9',
                dom,
                time = duration || 3000;
            //remove previous toast message
            try {
                mstrmojo.all[id].destroy();
            } catch (e) { }

            mstrmojo.insert({
                id: id,
                scriptClass: 'mstrmojo.Label',
                cssClass: 'toastCss',
                text: msg
            }).render();

            dom = mstrmojo.all[id].domNode;

            //append it to document
            document.body.appendChild(dom);
            $D.bottomCenter(dom);

            window.setTimeout(function () {
                mstrmojo.all[id].destroy();
            }, time);
        };
        
        mstrmojo.mask = {};
        
        mstrmojo.mask.show = function () {
        	mstrmojo.mask.win = mstrmojo.insert({
        		scriptClass: 'mstrmojo.Box',
        		cssClass: 'fullscreen-mask'
             });
        	mstrmojo.mask.win.render();
            document.body.appendChild(mstrmojo.mask.win.domNode);
        };

        mstrmojo.mask.hide = function() {
             mstrmojo.mask.win.destroy();
        };
    }

}());
(function(){

	mstrmojo.requiresCls("mstrmojo.css", "mstrmojo._HasBuilder");
	
	mstrmojo.ToolBar = mstrmojo.declare(
		// superclass
		mstrmojo.HBox,
		// mixins
		[mstrmojo._HasBuilder],
		// instance members
		{
			scriptClass: "mstrmojo.ToolBar",
			
			cellCssClass: "mstrmojo-ToolBar-cell",

			markupString: '<table id="{@id}" class="mstrmojo-ToolBar {@cssClass}" style="{@cssText}" cellspacing="0" cellpadding="0"><tr><td class="mstrmojo-ToolBar-outercell">' +
						      '<table class="mstrmojo-ToolBar-innertable" cellspacing="0" cellpadding="0"><tr>{@tableHtml}</tr></table>' +
						  '</td></tr></table>',
									
			markupSlots: {
				containerNode: function(){ return this.domNode.rows[0].cells[0].firstChild.rows[0]; }
			},
			
			markupMethods: {
				onvisibleChange: function(){ this.domNode.style.display = this.visible ? mstrmojo.css.DISPLAY_TABLE : 'none'; }
			},
			
			/**
			 * Extends the inherited method in order to initialize the "buildConfig" property,
			 * which is used by the _HasBuilder mixin.
			 */
			buildChildren: function bldChd(){
				var cfg = this.buildConfig;
				if (!cfg) {
					this.buildConfig = {};
					cfg = this.buildConfig;
				}
				cfg.target = this.target;
				
				return this._super();
			}
		}
	);

})();
(function () {
    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo.Container",
                         "mstrmojo.num",
                         "mstrmojo.HBox",
                         "mstrmojo._IsInputControl",
                         "mstrmojo._TouchGestures");

    var $D = mstrmojo.dom,
        $DAE = $D.attachEvent,
        $DDE = $D.detachEvent,
        $C = mstrmojo.css,
        _DTP = mstrmojo.expr.DTP,
        _BTN = 'mstrmojo.Button',
        _N = mstrmojo.num,
        _TR = mstrmojo.validation.TRIGGER,
        HOLD_INTERVAL = 50,
        HOLD_THRESHOLD = 500,
        DECIMAL_NUM = 10;

    function attachWinEvts() {
        var me = this;
        $DAE(window, $D.TOUCHSTART, me._evtHandler, true);
        me.isActive = true;
    }
    
    function detachWinEvts() {
        var me = this;
        $DDE(window, $D.TOUCHSTART, me._evtHandler, true);
        me.isActive = false;
    }

    function decimalFormat(v) {
        return v ? parseFloat(v.toFixed(DECIMAL_NUM)) : v;
    }

    function minusCalc() {
        var v = this.numericValue,
            max = this.max,
            min = this.min,
            itv = this.itv;

            if (!isNaN(v)) {
                if (max !== undefined && v - itv > max) {
                    this.set('numericValue', max);
                } else if (min === undefined || v - itv >= min) {
                    this.set('numericValue', decimalFormat(v - itv));
                } else if (v > min && v - itv < min) {
                    this.set('numericValue', min);
                }
            }
    }

    function plusCalc() {
        var v = this.numericValue,
            max = this.max,
            min = this.min,
            itv = this.itv;

        if (!isNaN(v)) {
            if(min !== undefined && v + itv < min) {
                this.set('numericValue', min);
            } else if (max === undefined || v + itv <= max) {
                this.set('numericValue', decimalFormat(v + itv));
            } else if (v < max && v + itv > max) {
                this.set('numericValue', max);
            }
        }
    }

    function processEvent(isPlus) {
        if (isPlus) {
            plusCalc.call(this);
        } else {
            minusCalc.call(this);
        }
    }

    function startStepperInterval(isPlus) {
        var me = this;
        this._holdTimer = setInterval(function () {
            processEvent.call(me, isPlus);
        }, HOLD_INTERVAL);
    }

    function stopStepperInterval() {
        if (this._holdTimer) {
            clearInterval(this._holdTimer);
            delete this._holdTimer;
        }
    }

    function startStepperTimeout(isPlus) {
        var me = this;
        if (!this._holdTimer && !this._startHoldTimer) {
            this._startHoldTimer = setTimeout(function () {
                delete me._startHoldTimer;
                startStepperInterval.call(me, isPlus);
            }, HOLD_THRESHOLD);
        }
    }

    function stopStepperTimeout() {
        if (this._startHoldTimer) {
            clearTimeout(this._startHoldTimer);
            delete this._startHoldTimer;
        }
        stopStepperInterval.call(this);
    }

    function isTapOnPlus(evt) {
       var v = evt.target;
       return (this.plusNode && this.plusNode == v);
    }

    function isTapOnMinus(evt) {
        var v = evt.target;
        return (this.minusNode && this.minusNode == v);
    }

    function applayChange() {
        var v = this.numericValue;
        if (!isNaN(v) && v >= this.min && v <= this.max && v != this.value) {
            this.set('value', v);
        }
    }
    
    function addTouchedClass(el) {
        $C.addClass(el, 'touched');
    }

    function createDICWidget(dic) {
        var max = dic.max,
            min = dic.min,
            itv = dic.itv;

        return {
            scriptClass: 'mstrmojo.HBox',
            alias: 'hBox',
            cssText: 'margin:auto',

            children: [{
                scriptClass: _BTN,
                alias: 'minus',
                cssClass: 'mstrmojo-StepperDIC-Operator minus',
                bindings: {
                    enabled: function() { return this.parent.parent.numericValue > min;}
                }
            }, {
                scriptClass: 'mstrmojo.ValidationTextBox',
                cssClass: 'mstrmojo-DataInputControl',
                dtp: _DTP.DOUBLE,
                required: true,
                alias: 'textInput',

                constraints: {
                    trigger: _TR.ONKEYUP | _TR.ONBLUR,
                    max: max,
                    min: min
                },

                bindings: {
                    value: 'this.parent.parent.numericValue'
                },

                onblur: function onblur(evt) {
                    var di = this.parent.parent,
                        value = _N.parseNumeric(this.value);

                    if (!di.isActive) {
                        applayChange.call(this.parent.parent);
                    }

                    this._super && this._super(evt);
                },

                onValid: function() {
                    this.parent.parent.set('numericValue', parseFloat(this.value));
                }
            }, {
                scriptClass: _BTN,
                alias: 'plus',
                cssClass: 'mstrmojo-StepperDIC-Operator plus',

                bindings: {
                    enabled: function() { return this.parent.parent.numericValue < max; }
                }
            }]
        };
    }

    /**
     * Stepper data input control for the android app.
     *
     * @extends mstrmojo.Container
     * @borrows mstrmojo._IsInputControl
     * @borrows mstrmojo._TouchGestures
     *
     * @class
     */
    mstrmojo.android.inputControls.StepperDIC = mstrmojo.declare(
        /**
         * superclass
         */
        mstrmojo.Container,
        /**
         * mixins
         */
        [ mstrmojo._IsInputControl, mstrmojo._TouchGestures ],
        /**
         * mstrmojo.android.inputControls.StepperDIC.prototype
         */
        {
            scriptClass: 'mstrmojo.android.inputControls.StepperDIC',

            cssClass: 'mstrmojo-StepperDIC',

            isActive: false,

            markupString: '<div id="{@id}" class="{@cssClass}" style="{@cssText}"></div>',

            markupSlots: {
                containerNode: function() { return this.domNode; }
            },

            markupMethods: {
                onvisibleChange: function() { this.domNode.style.display = this.visible ? 'block' : 'none'; }
            },

            init: function init(props) {
                this._super && this._super(props);

                this.max = this.dic.max;
                this.min = this.dic.min;
                this.itv = this.dic.itv;

                var _v = parseFloat(this.value);
                this.set('numericValue', isNaN(_v) ? (this.min||0) : _v);

                this.set('children', createDICWidget(this.dic));

                this.plus = this.hBox && this.hBox.plus;
                this.minus = this.hBox && this.hBox.minus;

                var me = this;
                this._evtHandler = this._evtHandler || function(evt) {
                    var t = evt.target;
                    if (!$D.contains(me.domNode, t)) {
                        $D.stopPropogation(evt.view, evt);
                        detachWinEvts.call(me);
                        applayChange.call(me);
                    }
                }
            },

            postBuildRendering: function postBuildRendering () {
                this._super();
                this.plusNode = this.plus && this.plus.domNode;
                this.minusNode = this.minus && this.minus.domNode;
            },

            touchTap: function (touch){
                if (!this.isActive) {
                    attachWinEvts.call(this);
                }
                if (isTapOnPlus.call(this, touch)) {
                    addTouchedClass(this.plusNode);
                    processEvent.call(this, true);
                } else if (isTapOnMinus.call(this, touch)) {
                    addTouchedClass(this.minusNode);
                    processEvent.call(this, false);
                }
            },

            touchBegin: function touchBegin(touch) {
                if (!this.isActive) {
                    attachWinEvts.call(this);
                }
                if (isTapOnPlus.call(this, touch)) {
                    addTouchedClass(this.plusNode);
                    startStepperTimeout.call(this, true);
                } else if (isTapOnMinus.call(this, touch)) {
                    addTouchedClass(this.minusNode);
                    startStepperTimeout.call(this, false);
                }
            },

            touchEnd: function touchEnd(touch) {
                stopStepperTimeout.call(this);
            },

            unrender: function unrender(ignoreDom) {
                if (this.isActive) {
                    detachWinEvts.call(this);
                }
                stopStepperTimeout.call(this);
                this._super(ignoreDom);
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                mstrmojo.css.addClass(this.domNode.firstChild || d, 'tx-active');
            }
        }
    );
}());
(function(){
    mstrmojo.requiresCls('mstrmojo.Box', 
            'mstrmojo.ListBase', 
            'mstrmojo._IsList');
    
    var DELIM = ',';
    
    /**
     * The widget will render the list items into the following table style.
     * ---------------------------------------------------------------------
     * | Left end title | Title       | Title       | ... | Right end title |
     * | Left end title | Item widget | Item Widget | ... | Right end title |
     * ...
     * | Left end title | Item widget | Item Widget | ... | Right end title |
     * ----------------------------------------------------------------------
     */
    
    mstrmojo.TableLayoutList = mstrmojo.declare (

        mstrmojo.ListBase,
        
        [mstrmojo._IsList],
        
        {
            scriptClass: 'mstrmojo.TableLayoutList',
            
            cssClass: 'mstrmojo-TableLayoutList',
            
            styleCssClass: '',
            
            itemIdField: 'v',
            
            allowUnlistedValues: false,
            
            tableLayoutCssStyle: 'auto',
            
            multiSelect: false,
            
            titleItems: null,
            
            /**
             * List items
             */
            items: null,
            
            /**
             * Items per row. 0 means all the items will be horizontal aligned.
             * Otherwise, each row will contain a fixed number of items.
             */
            itemsPerRow: 0,
            
            /**
             * Gets the left end title. Should be subclassed if there is any left end title.
             * @param {Integer} idx The item index.
             */
            getLeftEndTitle: function getLeftEndTitle(idx) {
                return '';
            },
            
            /**
             * Gets the left end title. Should be subclassed.
             * @param {Integer} idx The item index.
             */            
            getRightEndTitle: function getRightEndTitle(idx) {
                return '';
            },
            
            getTitleRowMarkup: function getTitleRowMarkup() {
                var titleItems = this.titleItems;
                if (titleItems) {
                    var _tr = '<tr><td class="left_text">' + this.getLeftEndTitle(-1) + '</td>',
                        len = titleItems.length,
                        i = 0,
                        t;
                    for (; i < len; i++) {
                        t = titleItems[i];
                        _tr += '<td class="item_title" title="' + t + '">' + t + '</td>';
                    }
                    _tr += '<td class="left_text">' + this.getRightEndTitle(-1) + '</td></tr>';
                    return _tr;
                }
                return '';
            },
            
            _markupPrefix: function() {
                //Render table shell.The left end normally contains the min value text. For example, in likert scale list, the left end is the minimum value text, and the right end is the maximum value text 
                //The title for items for likert scale would 1, 2, 3, 4, (or not likely, likely, very likely etc)
                return '<table class="tableLayoutList" style="table-layout:' + this.tableLayoutCssStyle + '" cellspacing="0" cellpadding="0"><tbody>' + this.getTitleRowMarkup();
            },
            
            _markupSuffix: function() {
                return  '</tbody></table>';
            },
            
            getItemMarkup: function(item, idx) {
                var markup = '<{@tag} class="item {@cls}" idx="{@idx}" title="{@n}" style="{@style}">{@n}</{@tag}>',
                lt = this.getLeftEndTitle(idx),
                rt = this.getRightEndTitle(idx),
                ipr = this.itemsPerRow;

                lt = '<td class="left_text" title="' + lt + '">' + lt + '</id>',
                rt = '<td class="right_text" title="' + rt + '">' + rt + '</id>',
                ipr = this.itemsPerRow;

                if (ipr > 0) {
                    // start a new table row when # of items per row
                    // has reached.
                    markup = (idx % ipr === 0 ? '<tr>' + lt : '') + '<td>' + markup + '</td>' + ((idx + 1) % ipr === 0 ? rt + '</tr>' : '');
                } else {
                    markup = '<td><div class="item_wrapper" idx="' + idx + '">' + markup + '</div></td>';
                    if (!idx) {
                        markup = '<tr>' + lt + markup;
                    } else if (idx === this.items.length - 1) {
                        markup = markup + rt + '</tr>';
                    }
                }
                return markup;
            },
            
            _getItemNode: function(idx) {
                var itemsTableNode = this.itemsNode,
                    ipr = this.itemsPerRow,
                    rowIdx = (this.titleItems ? 1 : 0) + ((ipr > 0) ? parseInt(idx/ipr, 10) : 0),
                    colIdx = 1 + ((ipr > 0) ? (idx%ipr) : idx);

                //need to count the top row and left end title column 
                return itemsTableNode.rows[rowIdx].cells[colIdx].firstChild;
            },            
            
            init: function(props) {
                this._super(props);
                mstrmojo.css.addWidgetCssClass(this, this.styleCssClass);
            },
            
            onchange: function onchange(){
                var newValue, s = [];
                
                //if not multiple selection, assign the value to this.value
                if (!this.multiSelect){
                    newValue = this.selectedItem.v;
                //otherwise, use delimitor to join the values together as a string to set this.value
                }else{
                    for (var i in this.selectedIndices) {
                        s.push(this.items[i].v);
                    }
                    newValue = s.join(this.delim || DELIM);
                }
                this.set('value', newValue);
            },
            
            postBuildRendering: function postBuildRendering() {
                this._super();
                
                //find selected items
                var selItems = [];
                if (this.multiSelect){
                    var vs = this.value.split(DELIM);
                    
                    for (var i = 0; i < vs.length; i++){
                        selItems.push({v: vs[i]});
                    }
                }else{
                    selItems.push({v: this.value});
                }
                
                this.setSelectedItems(selItems);
            }
        }
    );
}());
(function() {
    
    mstrmojo.requiresCls("mstrmojo.Box", "mstrmojo._HasLayout");
    
    /** 
     * Overlay widget is used as the container to build to build layout info window
     */
    mstrmojo.Overlay = mstrmojo.declare(
        mstrmojo.Box,
        [mstrmojo._HasLayout],
        {
            markupMethods: {
                onvisibleChange: function(){ this.domNode.style.display = this.visible? 'block' : 'none'; },
                onheightChange: function() { this.domNode.style.height = this.height ? this.height : ''; },
                onwidthChange: function() { this.domNode.style.width = this.width ? this.width: ''; }
            },
            
            layoutConfig: {
                h: {
                    containerNode: '100%'
                },
                w: {
                    containerNode: '100%'
                }
            },
            
            scriptClass: "mstrmojo.Overlay"
        }
    );
    
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.DocPanel",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo._CanGrowOrShrink",
                         "mstrmojo.hash");

    /**
     * For info windows the width or height may exceed the actual panel width or height so we need to adjust to the info window dimensions.
     *
     * @private
     */
    function adjustForInfoWindow() {
        // Do we have a container node, meaning that we've rendered?
        var containerNode = this.containerNode;
        if (containerNode) {
            // Calculate max dimension size based on formats and parent size.
            var fmts = this.getFormats(),
                parentSize = this._parentSize,
                h = Math.max((parseInt(fmts.height, 10) || 0), parentSize.height),
                w = Math.max((parseInt(fmts.width, 10) || 0), parentSize.width),
                containerNodeStyle = containerNode.style;

            // TQMS #646150: Make sure the panel container node has the correct dimensions.
            containerNodeStyle.width = w + 'px';
            containerNodeStyle.height = h + 'px';
        }
    }

    /**
     * Report Services Android Document Panel.
     *
     * @class
     * @extends mstrmojo.DocPanel
     */
    var androidPanel = mstrmojo.android.AndroidDocPanel = mstrmojo.declare(
        // superclass
        mstrmojo.DocPanel,

        // mixins,
        [ mstrmojo._CanGrowOrShrink, mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        /**
         * @lends mstrmojo.AndroidDocPanel.prototype
         */
        {
            scriptClass: "mstrmojo.AndroidDocPanel",

            /**
             * Setup the scrollers to be setup in a timeout fired after 0ms.
             */
            scrollerSetupDelay: 0,

            postBuildRendering: function postBuildRendering() {
                // Is this a panel within an info window?
                if (this._isInfWin) {
                    // Adjust for info window size.
                    adjustForInfoWindow.call(this);
                }

                return this._super();
            },

            /**
             * Updates the dimensions and position of the panel.
             *
             * @param {Integer} left The left position of the panel.
             * @param {Integer} height The height of the panel.
             * @param {Integer} width The width of the panel.
             * @param {Boolean} isInfoWindow Indicates whether the panel is contained within an info window.
             */
            updatePanelDimensions: function updatePanelDimensions(left, height, width, isInfoWindow) {
                // Cache the parent size.
                this._parentSize = {
                    height: height,
                    width: width
                };

                var px = 'px';

                // Is this an info window?
                if (isInfoWindow) {
                    // Cache that this is a panel within an info window.
                    this._isInfWin = true;

                    // Adjust for info window size.
                    adjustForInfoWindow.call(this);
                }

                // Replace the cssText property with the new values.
                this.cssText = 'left:' + left + 'px;top:0;height:' + height + px + ';width:' + width + px + ';';

                // Have we already rendered?
                if (this.hasRendered) {
                    // Grab the style collection from the domNode.
                    var ps = this.domNode.style;

                    // Set left height and width for the panel to the new values.
                    ps.left = left + px;
                    ps.height = height + px;
                    ps.width = width + px;

                    this.updateScroller();
                }
            },

            /**
             * Updates the DocTextField data that may change due to a selector action.
             *
             * @param {Object} node The widget node.
             */
            update: function update(node) {
                // Overwrite scroller config for re-renders.
                this.scrollerConfig = {
                    bounces: false,
                    showScrollbars: false
                };
            },

            /**
             * Calls performCanGrowCanShrink for the single child that was just rendered.
             *
             * @param {mstrmojo.Event|mstrmojo.Width} obj
             * @ignore
             */
            onchildRenderingChange: function onchildRenderingChange(obj) {
                this._super(obj);

                // Does the panel scroll?
                if (this.getFormats().overflow === 'auto') {
                    // Call performCanGrowCanShrink.
                    this.performCanGrowCanShrink([ (obj && obj.src) || obj ], (!!this._isInfWin && !mstrApp.isTablet())); // #723067
                }
            },

            touchTap: function touchTap() {
                // Does the controller have a viewTap method?
                var ctrl = this.controller;
                if (ctrl && ctrl.viewTap) {
                    // Call it.
                    ctrl.viewTap();
                }
            },

            getCanGrowShrinkNode: function getCanGrowShrinkNode() {
                return this.containerNode;
            },

            afterCanGrowShrink: function canGrowShrinkPerformed() {
                // Make sure the scroller is in sync with the new dimensions.
                this.updateScroller();
            },

            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super();

                // Has the overflow value been specifically set to auto - then calculate the offsets
                if (this.getFormats().overflow === 'auto') {
                    var scrollEl = this.containerNode,
                        widgetSize = this._parentSize,
                        iterator = {
                            'Height': {
                                a: 'y',
                                s: 'v'
                            },
                            'Width': {
                                a: 'x',
                                s: 'h'
                            }
                        },
                        offset = {};

                    // Add the scrollEl to the scroll config.
                    cfg.scrollEl = scrollEl;

                    mstrmojo.hash.forEach(iterator, function (info, dimension) {
                        // Get widget size for this dimension.
                        var size = widgetSize[dimension.toLowerCase()];

                        // Calculate offset end (scroll element node dimension size minus widget dimension size).
                        var offsetEnd = Math.max(scrollEl['offset' + dimension] - size, 0),
                            enableDimensionScroll = cfg[info.s + 'Scroll'] = (offsetEnd !== 0);

                        // Can we scroll in this dimension?
                        if (enableDimensionScroll) {
                            // Add offset value for appropriate axis.
                            offset[info.a] = {
                                start: 0,
                                end: offsetEnd
                            };
                        }
                    });

                    // Add computed offset to config.
                    cfg.offset = offset;

                    // Add origin, initializing to 0,0 if we don't have one.
                    cfg.origin = cfg.origin || {
                        x: 0,
                        y: 0
                    };
                }

                return cfg;
            }
        }
    );

    // Add height and width to the container node format handlers for this class.
    var formatHandlers = androidPanel.prototype.formatHandlers,
        nodeName = 'containerNode';

    formatHandlers[nodeName] = formatHandlers[nodeName].concat('D');

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocLayout");

    /**
     * When in an horizontal layout we need to set the height of all subsections to be
     * equals to the taller subsection of the current horizontal sections group, for each
     * group of horizontal sections get the taller subsection and resize the siblings
     *
     * @private
     * @ignore
     */
    function resizeForSharedHeight(me) {
        var mh = -1,
            c = me.children,
            sec,
            six,
            ssix,
            subsec,
            subsecArr = [],
            resizeSection = function () {
                var ci;
                for (ci in subsecArr) {
                    var subsec = subsecArr[ci];
                    if (subsec._fixedHeight !== mh) {
                        subsec._fixedHeight = mh;
                        if (subsec.domNode) { //If it exceeds the width of the doc, might not be rendered yet
                            subsec.domNode.style.height = mh + 'px';
                        }
                    }
                }
                mh = -1;
                subsecArr = [];
            };

        for (six in c) {
            sec = c[six];
            if (sec.node.data.bh && mh > -1) {
                //we are starting a new horizontal section, if the max height is
                //valid resize the previous horizontal group
                resizeSection();
            }
            if (sec.defn.horiz) {
                //look for all horizontal sections
                for (ssix in sec.children) {
                    //get the max height of the subsections on this section
                    subsec = sec.children[ssix];
                    mh = Math.max(subsec._fixedHeight || 0, mh);
                    //keep track of the current horizontal group sections
                    subsecArr[subsecArr.length] = subsec;
                }
            }
        }
        resizeSection();
    }

    /**
     * The widget for a single MicroStrategy Report Services document layout, which contains horizontally repeating data.
     *
     * @class
     * @extends mstrmojo.DocLayout
     */
    mstrmojo.DocLayoutHoriz = mstrmojo.declare(
        // superclass
        mstrmojo.DocLayout,

        // mixins,
        null,

        /**
         * @lends mstrmojo.DocLayoutHoriz.prototype
         */
        {
            scriptClass: "mstrmojo.DocLayoutHoriz",

            markupString: '<div id="{@id}">' +
                              '<div class="mstrmojo-DocLayout {@cssClass}" style="{@domNodeCssText}">' +
                              '</div>' +
                          '</div>',

            markupSlots: {
                containerNode: function () { return this.domNode.firstChild; }
            },

            getWidth: function getWidth() {
                // #560050
                return this.containerNode.offsetWidth;
            },

            getHeight: function getHeight() {
                // #577401
                return this.containerNode.offsetHeight;
            },

            _renderSection: function _renderSection(sec, index) {

                // Should we begin horizontal data?
                if (sec.node.data.bh) {

                    // Create the container.
                    var d = document.createElement('div');
                    d.className = 'mstrmojo-DocLayout-HBox';

                    // Create a table...
                    var t = document.createElement('table');
                    t.className = 'mstrmojo-DocLayout-HBox-HorizContainerTable';

                    // with one row...
                    this._hRow = t.insertRow(-1);

                    // and append it to the container.
                    d.appendChild(t);

                    // Append the hbox container to the container node.
                    this.containerNode.appendChild(d);
                }

                // Is this widget horizontal?
                if (sec.defn.horiz) {
                    // Create the slot name.
                    var slotName = 'hi' + index;

                    // Set the child widgets slot.
                    sec.slot = slotName;

                    // Create the slot node on the cached hRow.
                    var td = this._hRow.insertCell(-1);

                    // Set vertical align (can't use setAttribute because it fails in IE7).
                    td.vAlign = 'top';

                    // Store in slots collection and indicate that a slot was added..
                    var slots = {};
                    slots[slotName] = td;
                    this.addSlots(slots);
                }
                this._super(sec, index);
            },
            /**
             * If the layout is set to auto width, we need to set the layout width at least
             * the size of the visible sections, and a little more in case we have un-rendered
             * sections so the scrolling of the viewport will trigger the rendering and this
             * method will be called again to calculate again the current width.
             *
             * @ignore
             */
            getLayoutMinWidth: function getLayoutMinWidth() {
                var minWidth = 0,              // Minimum width of all horizontal section groups.
                    currentMinWidth = 0,       // Minimum width of the current group of horizontal sections.
                    children = this.children,
                    len = children.length,
                    i,
                    k;

                // Iterate trough the children of the horizontal layout (hl), sections.
                for (i = 0; i < len; i++) {

                    var sec = children[i],
                        secNode = sec && sec.node,
                        secNodeData = secNode && secNode.data,
                        begin = secNodeData && (String(secNodeData.bh) === 'true' || String(secNodeData.bv) === 'true');

                    // If begining of horizontal or vertical section, store the max width and start again
                    if (begin) {
                        minWidth = Math.max(minWidth, currentMinWidth);
                        currentMinWidth = 0;
                    }

                    if (sec.children) {
                        // If the section has children it is rendered, so try to get the subsections and their widths
                        for (k in sec.children) {
                            currentMinWidth += sec.children[k].width();
                        }
                    } else {
                        // If the section is not rendered, add 10 pixels to the max width so the viewport can do its job when
                        // scrolled to that point.
                        currentMinWidth += 10;
                        break;
                    }
                }

                // Return greater value.
                return Math.max(minWidth, currentMinWidth);
            },


            /**
             * For DocLayoutHoriz, we need to resize for its height, in addition to its width when finishing rendering/updating
             * its 'Fit to Content' children.
             */
            resizeOrReposition: function resizeOrReposition() {
                if (this._super) {
                    this._super();
                }

                resizeForSharedHeight(this);
            },


            /**
             * Adjust the width of the containerNode to account for any 'Fit to Content' objects.
             *
             * @ignore
             * @see mstrmojo._CanRenderDocOnScroll
             */
            renderCtrlsInViewport: function renderCtrlsInViewport() {
                this._super();
                resizeForSharedHeight(this);
            }

        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo.DocTextfield");


    var $DOM = mstrmojo.dom,
        $CSS = mstrmojo.css,
//        DPST_NOT_BUTTON = 0,
        DPST_CAPTION_ONLY = 1,
        DPST_ICON_ONLY = 2,
        DPST_ICON_LEFT = 3,
        DPST_ICON_RIGHT = 4,
        DPST_ICON_TOP = 5,
        DPST_CUSTOM = 6,
//        FE_FLAT = 0,
        FE_GLOSSY = 1,
        dpstCssClass = [ '', 'CaptionOnly', 'IconOnly', 'IconLeft', 'IconRight', 'IconTop', 'Custom' ];
    
    // Create button icon spacing and caption size configurations.
    var btnCfg = [];
    btnCfg[DPST_CAPTION_ONLY] = btnCfg[DPST_ICON_ONLY] = btnCfg[DPST_CUSTOM] = {
        minsp: 0,
        mincs: 0
    };
    
    btnCfg[DPST_ICON_LEFT] = btnCfg[DPST_ICON_RIGHT] = {
        minsp: 10,
        mincs: 5
    };
    
    btnCfg[DPST_ICON_TOP] = {
        minsp: 4,
        mincs: 5
    };

    /**
     * Align DOM node centrally to its parent DOM node (or additional inner box).
     * 
     * @param {HTMLElement} e The DOM node that needs alignment
     * @param {Boolean} isH Whether to align centrally in horizontal
     * @param {Boolean} isV Whether to align centrally in vertical
     * @param {Object} innerBox Actually box inside parent node to align, use format {t,r,b,l} to indicate relative positions to parent: Top,Right,Bottom,Left.(Can be all or partially empty)
     * @param {Boolean cutoff Whether to cut off element if its size is larger than box's size
     * 
     * @private
     */
    function centerAlign(e, isH, isV, innerBox, cutoff) {
        var pos = $DOM.position(e),                     // Current element's size and position
            ppos = $DOM.position(e.parentElement),      // Parent element's size and position
            es = e.style;
        innerBox = innerBox || {};
        innerBox = {'t':innerBox.t||0, 'r':innerBox.r||0, 'b':innerBox.b||0, 'l':innerBox.l||0};    // Init inner box
        innerBox.h = ppos.h-innerBox.t-innerBox.b;      // Height
        innerBox.w = ppos.w-innerBox.l-innerBox.r;      // Width
        if (cutoff) {
            if (pos.h > innerBox.h) es.height = innerBox.h + 'px';
            if (pos.w > innerBox.w) es.width  = innerBox.w + 'px';
            pos = $DOM.position(e);                     // Recalculate current element's size and position
        }
        if (isH) {
            es.top = ((innerBox.h - pos.h)/2 + innerBox.t) + 'px';
        }
        if (isV) {
            es.left = ((innerBox.w - pos.w)/2 + innerBox.l) + 'px';
        }
    }

    /**
     * Append an image under given DOM node, and then align it centrally.
     *
     * @param {HTMLElement} e The DOM node that needs alignment
     * @param {String} src Image source url.
     * @param {String} className Image css class name.
     * 
     * @private
     */
    function appendAndCentralizeImg(e, src, className) {
        var img = document.createElement('img'),
            imgsty = img.style;
        e.appendChild(img);
        $DOM.attachEvent(img, 'load', function () {
            var disp = imgsty.display;
            imgsty.display = 'block'; // As highlight image is set none display as default, first force to display for center align
            centerAlign(img, true, true);
            imgsty.display = disp;
        }, true);
        img.className = className;
        img.src = src;
    }   

    /**
     * <p>The widget for a single MicroStrategy Report Services Button.</p>
     *
     * @class
     * @extends mstrmojo.DocTextField
     */
    mstrmojo.DocButton = mstrmojo.declare(
        // superclass
        mstrmojo.DocTextfield,

        // mixins,
        null,

        /**
         * @lends mstrmojo.DocButton.prototype
         */
        {
            scriptClass: "mstrmojo.DocButton",

            pressed: false,

            markupString: '<div id="{@id}" class="mstrmojo-DocButton {@cssClass}" title="{@tooltip}" style="{@domNodeCssText}">' +
                              '<div class="mstrmojo-DocButton-Container" mstrAttach:click,mousedown>' +
                                  '<div class="mstrmojo-DocButton-IconNode"></div>' +
                                  '<div class="mstrmojo-DocButton-ValueNode" style="{@valueNodeCssText}">{@v}</div>' +
                              '</div>' +
                              '<div class="mstrmojo-DocButton-EffectOverlay"></div>' +
                              '{@buttonNodeMarkup}' +
                          '</div>',

            markupSlots: {
                iconNode: function () { return this.domNode.firstChild.firstChild; },
                valueNode: function () { return this.domNode.firstChild.lastChild; },
                buttonContainerNode: function () { return this.domNode.firstChild; }
            },

            markupMethods: {
                onpressedChange: function () {
                    var isPressed = !!this.pressed,
                        defn = this.defn,
                        domNode = this.domNode,
                        fmts = this.fmts;

                    // Toggle pressed class on DOM node.
                    $CSS.toggleClass(domNode, 'pressed', isPressed);

                    // Add (or removed) pressed state styling.
                    this.setBackgroundColor();
                    this.valueNode.style.color = isPressed ? defn.fhlc : (fmts.color || '');
                },
				onvisibleChange: mstrmojo.Widget.visibleMarkupMethod
            },

            formatHandlers: {
                domNode:  [ 'T', 'z-index', 'D', 'B', 'P', 'background-color' ],
                valueNode: [ 'font', 'fx', 'color', 'white-space', 'overflow' ]
            },
            
            setBackgroundColor: function setBackgroundColor() {

                this.domNode.style.backgroundColor = (!!this.pressed) ? this.defn.bhlc : (this.fmts['background-color'] || '');
            },

            /**
             * Support for info windows.
             * 
             * @ignore
             */
            getAnchor: function getAnchor() {
                return this.domNode;
            },

            getDPI: function getDPI() {        
                return this.model.dpi;
            }, 
            
            buildRendering: function buildRendering() {
                this._super();

                var defn = this.defn,
                    dm = this.domNode,
                    bc = this.buttonContainerNode,
                    ic = this.iconNode,
                    vl = this.valueNode,
                    dpst = parseInt((defn && defn.dpst) || 1, 10),    // Display Style
                    px = 'px';

                $CSS.toggleClass(dm, dpstCssClass[dpst], true);

                // Set cannot be selected(text)(FF use css) and dragged(image/text)
                // Drag will cause 'mouseup' event not fired
                dm.onselectstart = dm.ondragstart = function () {
                    return false;
                };

                var fmts = this.getFormats(),
                    innerBorderWidth = parseInt($CSS.getComputedStyle(bc).borderWidth, 10) * 2;     // Total border width of button container node.

                // Is there NO inner border width?
                if (isNaN(innerBorderWidth)) {
                    // Use zero.
                    innerBorderWidth = 0;
                }
                    
                var w = parseFloat(fmts.width) - innerBorderWidth,    // Inner width of button
                    h = parseFloat(fmts.height) - innerBorderWidth,   // Inner height of button
                    cfg = btnCfg[dpst],
                    minsp = cfg.minsp,             // Minimal spacing between icon
                    mincs = cfg.mincs,             // Minimal caption size (in pixel)
                    icsize,                        // Size of icon square
                    ics = ic.style,                // Icon Node style
                    vls = vl.style;                // Value Node style

                function setIcsize(s) {            // Set Icon Size
                    ics.height = ics.width = s + px;
                }

                // Fix dimensions of button container node.
                var buttonContainerNodeStyle = bc.style;
                buttonContainerNodeStyle.height = h + px;
                buttonContainerNodeStyle.width = w + px;

                switch (dpst) {
                case DPST_ICON_TOP:
                    var dpi = this.getDPI(),
                        outerHeight = h + $CSS.getBorderWidths(fmts['border-width'], dpi).h + $CSS.getPaddings(fmts.padding, dpi).h;
                    icsize = Math.max(0, Math.min(w, h - minsp - mincs, outerHeight * 0.6)); 
                    setIcsize(icsize);
                    centerAlign(ic, false, true);
                    centerAlign(vl, true, false, {'t':icsize+minsp}, true);
                    break;

                case DPST_ICON_LEFT:
                case DPST_ICON_RIGHT:
                    icsize = Math.max(0, Math.min(h, w - minsp - mincs));
                    setIcsize(icsize);
                    centerAlign(ic, true, false);
                    vls[(dpst === DPST_ICON_LEFT) ? 'left' : 'right'] = (icsize + minsp) + px;
                    centerAlign(vl, true, false);
                    break;

                case DPST_CAPTION_ONLY:
                    centerAlign(vl, true, false);
                    break;

                case DPST_ICON_ONLY:
                case DPST_CUSTOM:
                    // Already locate and size icon in css file
                    break;
                }

                if (FE_GLOSSY === parseInt(defn.fe, 10)) {
                    $CSS.addClass(dm, 'gloss');
                }

                // Load normal and highlight images
                appendAndCentralizeImg(ic, defn.nmurl, 'normal');
                appendAndCentralizeImg(ic, defn.hlurl || defn.nmurl, 'hilight');

                // Add a mask on top of icon canvas to handle clicks on image.
                var icMaskNode = document.createElement('div');
                $CSS.addClass(icMaskNode, 'mstrmojo-DocButton-IconMaskNode');
                ic.appendChild(icMaskNode);
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls(
            "mstrmojo.GridBase",
            "mstrmojo.Grid");

    /**
     * <p> XtabZone Widget is responsible for displaying a zone in the MicroStrategy Xtab (e.g. Titles, Row Headers, Col Headers, Metric Values) . <p>
     *
     *  <p> An Xtab rendered through mstrmojo.Xtab is essentially a container with four separate zones (TopLeft, TopRight, BottomLeft, BottomRight).
     *  These zones are essentially Grids (HTML Tables). Based on the lock header setting,  a zone would render either Titles, Column Headers, Row Headers or Metric Values
     *  OR a combination of those e.g. for Both lock headers ON, TopLeft zone renders Xtab Titles as a grid, TopRight zone renders ColHeaders, BottomLeft renders RowHeaders and BottomRight renders Metric Values.
     *  For Lock Row Headers only, BottomLeft zone renders Xtab Titles + Row Headers as a grid, BottomRight zone renders ColHeaders + Metric Values while the top zones are rendered empty.
     *
     *  @class
     *  @extends mstrmojo.OndemandGrid
     */
    mstrmojo.XtabZone = mstrmojo.declare(
        // superclass
        mstrmojo.Grid,

        // mixins
        null,

        /**
         * @lends    mstrmojo.XtabZone
         */
        {
            /**
             * Script Class
             * @type String
             */
            scriptClass: "mstrmojo.XtabZone",

            /**
             * Markup
             * @type String
             */
            markupString: '<div id="{@id}" class="mstrmojo-XtabZone" style="position:relative;{@cssText}"></div>',

            /**
             * Markup Slots. We define the container node for the Grid here.
             * @type String
             */
            markupSlots: {
                gridContainerNode: function(){ return this.domNode; }
            }
        }   // close - instance methods block.
    );

}());

(function(){

    /**
     * <p> XtabCP represents the base Content Provider for an XtabZone. </p>
     *
     * <p> The role of Xtab Content Provider is to act as an adaptor between XtabZone and Grid Data. So, the presentation layer (XtabZone) doesn't need to know the internals of Grid JSON Data. It simply
     * works off a simple content provider interface that essentially answers queries like how many rows does the grid has, how many columns, their widths, cells for a given row. </p>
     *
     * <p> Having an adapter like XtabCP helps particularly for Xtab rendering as the original Grid Data (JSON packet generated by the transform) makes heavy use of lookup mechanisms to keep
     * the JSON size compact (e.g. element definitions are shared and headers use lookup indices to avoid duplicating the data). So XtabZone doesn't need to worry about
     * things like how to resolve the header names, tracing parent headers (used for sorting, hyperlinks), managing interactivity related hooks. </p>
     *
     *  @class
     */
    mstrmojo.XtabCP = mstrmojo.declare(
        null,

        // mixins
        null,

        /**
         * lends mstrmojo.XtabCP
         */
        {
            /**
             * Script Class
             * @type String
             */
            scriptClass: "mstrmojo.XtabCP",

            /**
             * Base Node in the Grid JSON Data from where to retrieve the contents for this content provider. e.g. If this content provider needs to represent row headers,
             * this variable needs to be refer to the ghs.rhs node in the Grid JSON.
             * @type JSON Node
             */
            base:null,

            /**
             * <p> Base Lookup Node in the Grid JSON Data from where to retrieve the element definitions. </p>
             *
             * <p> To keep Grid JSON compact we don't include element definitions within the header nodes. Instead they have lookup indices. This configuration property
             * helps Content Provider to resolve the lookup indices as it points it to the subtree (e.g. gts.row) where it find the definitions </p>
             *
             * <p> This field would be used only for headers. </p>
             * @type JSON Node
             */
            lookupBase:null,

            /**
             * Column widths for the (grid) zone represented by this Content Provider. This property is used by XtabZone to render the HTML table widths.
             * @type Array
             */
            colWidths:null,

            /**
             * When set to true, this property implies that rows corresponding to this content provider should ignore fixed height.
             * @type Boolean
             */
            forceAutoRowHeight:false,

            /**
             * Since Content Providers (CP) can be aggregated, each CP typically represents a block of rows within the XTab. For purposes like stitching this internal counter is used to know
             * the starting position (row index) that this Content Provider represents.
             * @type Integer
             */
            startIndexInContainer:0,

            /**
             * An object records the rows that contains change
             * @type Object
             */
            updatedRows: null,

            /**
             * When the new data structure is completely unmatched (e.g. cell row spans are different), we need to preserve the updated rows
             * @type Boolean
             */
            preServeUpdatedRows: true,

            /**
             *
             * @constructs
             * @param {Object} props A hash of property names/values. Typically this Content Provider expects the following properties
             * <ul>
             * <li>gridData:Grid JSON</li>
             * <li>type:Integer enum representing the content provider type</li>
             * <li>base:Grid JSON Node that serves as the base node for the content provider</li>
             * <li>interactiveCellsArray:Array where the Content Provider will add cells that it realizes are interactive. See mstrmojo.Xtab#interactiveCellsArray for more details</li>
             * </ul>
             */
            init:function init(/* JSON */ props) {
                mstrmojo.hash.copy(props, this);
            },

            /**
             * Initializes the content information e.g. row count, column widths and caches them as instance properties.
             * This method should be called before we start rendering a grid.
             * @param {Integer} startIndexInContainer An optional parameter that indicates the index of the first row represented by this Content Provider. This property is only used internally
             * when Content Providers are aggregated.
             * @refactoring can we move some/all of this logic to init.
            */
            initContent: function initContent(/* Integer */ startIndexInContainer) {
                this.startIndexInContainer = startIndexInContainer || this.startIndexInContainer || 0;
                var s = this.base.show,
                items = this.base.items;
                this.rc =  s && items ? items.length : 0;
                this.colWidths = s && this.base.cws || [];
                this.isDownloading = false;
                this.isDownloaded = true;
                this.invalidData = false;
            },

            /**
             * Indicates whether Grid Rows specified are available or need to be downloaded from IServer.
             * @param {Integer} startRow Start Row.
             * @param {Integer} endRow End Row.
             * @returns (Boolean) whether grid rows specified are available or need to be downloaded.
            */
            isDataAvailable:function isDataAvailable(/* Integer */ startRow, /* Integer */ endRow) {
                return !this.invalidData;
            },

            /**
             * Triggers downloading of specified Grid Rows from IServer. Note that this is an asynchronous call so that the rendering widget is not blocked. When we have downloaded
             * the corresponding block of data from IServer, Xtab would ensure that it notifies the necessary zones (XtabZone).
             * @param {Integer} startRow Start Row.
             * @param {Integer} endRow End Row.
            */
            download:function download(/* Integer */ startRow, /* Integer */ endRow) {
                if(!this.isDownloaded && !this.isDownloading && this.dataSource) {
                    this.isDownloading = true;
                    this.dataSource.download(0);
                }
            },

            invalid:function invalid() {
                this.invalidData = true;
                this.isDownloading = false;
                this.isDownloaded = false;
                this.preServeUpdatedRows = true;
                if(this.gridData) {
                    this.oldGridData = this.gridData;
                    this.oldBase = this.base;
                    this.updatedRows = {};
                }
            },

            /**
             * Get the row height for a given type. Should be subclassed.
             */
            getRowHeight: function getRowHeight() {
                return this.gridData.rh;
            },
            
            /**
             * Returns the number of initial rows that need to be rendered in Auto mode. This is bit of a hackish solution to support the case that Titles/ColHeaders in XTab are rendered as auto height.
             * They don't use fixed height. So, the idea is that xtabzone can ask the provider and figure, if any of the initial rows need to be rendered in auto height. This way xtabzone still doesn't need
             * to know specifics about Xtab (titles, col headers etc.). It continues to work off a generic content provider paradigm. Still more ideal solution would be to have a more generic API like getRowHeightConfig
             * that returns a JSON representing a map of rowheights and rowBlocks. For simplicity sake we limit the solution to this API for now. Eventually we should evaluate the generic API
             */
            getNumAutoHeightRows: function () {
                return this.forceAutoRowHeight ? this.rc : 0;
            },

            /**
             * Returns the number of rows that are available/downloaded.
             * @return {Integer} number of rows that are downloaded.
             */
            getAvailableRowsCount: function getAvailableRowsCount() {
                return this.rc;
            },

            getUpdatedRows: function getUpdatedRows() {
                return this.updatedRows;
            },

            /**
             * Returns cells for a given row.
             * @param {Integer} ri Row Index
             * @returns {Array} Grid JSON Cell objects that include the following properties used by the XtabZone
             * <ul>
             * <li>rs:Row Span</li>
             * <li>cs:Column Span</li>
             * <li>v:Value
             * <li>css:Css class names</li>
             * <li>_ei:Extra Info. This property value is rendered in the HTML generated for the <td> as "ei" attribute. This is effetively a means for ContentProviders to ask widget to render information that features like
             *  interactivity would need.</li>
             * </ul>
             */
            getRowCells: function (/*Integer*/ ri) {
                var bi = this.base.items,
                    r = bi[ri],             // row.
                    cells = r.items,
                    lb = this.lookupBase,
                    ics = this.interactiveCellsArray,
                    cssBase = this.gridData.css,
                    e = null,
                    totalSet = false,
                    oldGd, oldBase, oldItems, oldCells;

                if(this.oldGridData) {
                    oldGd = this.oldGridData;
                    oldBase = this.oldBase;
                    oldItems = oldBase && oldBase.items;
                    oldCells = oldItems[ri] && oldItems[ri].items;
                }

                for (var ci=0, len=cells && cells.length || 0; ci<len; ci++) {
                    var cell = cells[ci];
                    if (cell) {
                        cell.v = cell.v || cell.n;
                        if (lb && !cell._e) {
                            var unit = lb[cell.tui];
                            e = unit && unit.es[cell.idx];
                            if (e) {
                                cell.v = cell.v || e.n; //we need to first check cell.v because the cell's v value has higher priority than the name of the look up element
                                if(e.rv) {
                                    cell.rv = e.rv;
                                }
                                // if we found the element object for the cell, attach it to the cell too. This will be useful during actions (looking up element ID) - especially for cases where there are multiple grid data blocks.
                                cell._e = e;
                            }
                        }
                        if(!cell.css) {
                            cell.css = cssBase[cell.cni].n;
                        }

                        //Transactions: check whether there is any data in the row gets changed
                        if(!cell._d && oldCells && this.preServeUpdatedRows) {
                            var oldCell = oldCells[ci];
                            if(!oldCell || (oldCell.rs !== cell.rs)) {
                                this.preServeUpdatedRows = false;
                                this.updatedRows = {};
                            } else if((oldCell.v && cell.v !== oldCell.v)) {
                                data = {};
                                if(cell.v !== oldCell.v) {
                                    data.v = oldCell.v;
                                }
                                if(cell.css !== oldCell.css) {
                                    data.css = oldCell.css;
                                }
                                cell._d = data;
                                //save the row number into the updatedRows object
                                this.updatedRows[this.startIndexInContainer + ri] = true;
                            }
                        }

                        // Debug Info....
                        //cell._di = (this.blockNum || 0) + "_" + ri + "_" +ci;

                        //TQMS 465449 465725, need to remember the reference to the grid data to find the proper title
                        //XZ: assign a reference to the block index so that when reading titles, we can find the proper data block
                        cell._gd = this.gridData._bidx || 0;

                        // is the cell interactive ? do we have an interactiveCellsArray setup (by xtab) ?
                        if(cell.at > 0 && ics) {
                            // add the cell to the interactive cells cache. Get the lookup index and add it to the cell as extraInfo (this attribute will be picked up by the table renderer during onclick).Avoid adding twice (due to stitching).
                            if(cell._ei === undefined || ics[cell._ei] !== cell) {
                                cell._ei = ics.push(cell) - 1;
                            }

                        }
                        // store the axis information. This can come in the JSON also, but, this should be more efficient. than repeating the information in JSON several times.
                        if(this.axis) {
                            cell.axis = this.axis;
                        }

                        // also update the parent reference.
                        var parentIndices = cell.pi;
                        if(parentIndices) {
                            // for headers, the parent indices would be passed directly (rowIndex, cellIndex)
                            if(parentIndices.ri !== undefined && parentIndices.ci !== undefined) {
                                // parent reference. Go to the items of the previous row and look for cell with index -> pi.
                                cell._p = bi[parentIndices.ri].items[parentIndices.ci];
                            } else {
                                // metric values. Left and Top indices.
                                var ghs = this.gridData.ghs,
                                        leftPi = parentIndices.left,
                                        topPi = parentIndices.top;

                                // if left parent indices are present, update the left parent reference on the cell.
                                if(leftPi) {
                                    cell._lp = ghs.rhs.items[leftPi.ri].items[leftPi.ci];
                                }

                             // and if top parent indices are present, update the that parent reference on the cell.
                                if(topPi) {
                                    cell._tp = ghs.chs.items[topPi.ri].items[topPi.ci];
                                }
                            }
                        }

                    }
                }

                return cells;
            },

            /**
             * Gets the missing cells for the give row.  In merged header case, the cells are merged across rows.
             * For a given row, the first data item might not be the first cell displayed in the row. This function
             * will find the missing cells at the beginning of the given row that are missing.
             * @returns {Array} The array of the "missing" cell object. The new row span of the "missing" cell should
             * be its (parent's) original row span minus the offset of the current row to its parent.
             */
            getUnmergedCells: function getUnmergedCells(/*Integer*/ri) {
                var ac = [],
                    rows = this.base.items,
                    cssBase = this.gridData.css,
                    cell = rows[ri].items[0], // start inspecting the first cell
                    pi = cell && cell.pi, // get the parent index node
                    r = pi && pi.ri, // row number for the parent node
                    c = pi && pi.ci; // column number for the parent node

                while(pi && r > -1 && c > -1) {
                    // get the parent of selected cell
                    cell = cell._p || rows[r].items[c];
                    var _c = {};
                    // make a copy of the parent
                    mstrmojo.hash.copy(cell, _c);
                    if(!_c.css) {
                        _c.css = cssBase[_c.cni].n;
                    }
                    // adjust its row span as it the cell start from the current row
                    _c.rs = cell.rs - ri + r; //cell.rs - (ri - r)
                    // put it to the top of the array
                    ac.splice(0, 0, _c);
                    // find the next parent
                    pi = cell && cell.pi;
                    r = pi && pi.ri;
                    c = pi && pi.ci;
                }

                return ac;
            }
        }
    );
})();

(function(){
    /**
     * <p>XtabVACP represents a vertical aggregation of content providers.</p>
     *
     * <p> It essentially aggregates the rows of a number of Content Providers. As a result rows from different Content Providers
     * end up being rendered within a single XtabZone (HTML) table </p>
     *
     * <p> While basic content providers represent single zones (e.g. titles, headers), aggregated Content Provider can aggregate zones of a xtab e.g. for .
     * for lock row headers (only) case it would help aggregate the titles & rowHeaders Content providers. So, titles and row headers rows end up rendering in a single table (XtabZone) as against
     * lock header BOTH case where they need to be rendered in separate tables</p>
     *
     *  @class
     *  @extends mstrmojo.XtabCP
     */
    mstrmojo.XtabVACP = mstrmojo.declare(
        // superclass
        mstrmojo.XtabCP,

        // mixins
        null,

        /**
         * @lends mstrmojo.XtabVACP
         */
        {
            scriptClass: "mstrmojo.XtabVACP",

            /**
             * Represents the Content Providers that this object aggregates.
             * @type Array
             */
            cps:[],

            initContent: function initContent(/* Integer */ startIndexInContainer) {
                this.startIndexInContainer = startIndexInContainer || 0;
                this.rc = 0;
                this.type = 0;
                this.colWidths = [];
                for(var i=0;i<this.cps.length;++i) {
                    var cp = this.cps[i];
                    // pass on to the CP its starting index within the container.
                    cp.initContent(this.startIndexInContainer + this.rc);
                    this.rc += cp.rc;
                    this.type |= cp.type;
                    var cws = cp.colWidths;
                    // we can't really rely on any one CPs colWidths - since there may be some that don't really have any (e.g. hidden titles, OnDemand CPs). So, we just pick the one that has max col widths set.
                    if(cws && (cws.length > this.colWidths.length)) {
                        this.colWidths = cws;
                    }
                }
            },

            getNumAutoHeightRows: function () {
                // The API is used to to provide the initial rows that need to be set to Auto (e.g. Titles, colheaders zone). We are doing small cheat here - since none of our Vert/Horiz Content providers
                // would need to force Auto Row Height for 2nd content provider (it would be rowHeaders, values or H ACP(rowHeaders, values) which always honor the fixed row height), we just query
                // the top content provider.
                return this.cps[0].getNumAutoHeightRows();
            },

            /**
             * Get the row height for a given type.
             */
            getRowHeight: function getRowHeight() {
                return this.cps[0].getRowHeight();
            },            
            
            /**
             * Returns cells for a given row.
             */
            getRowCells: function (/*Integer*/ ri) {
                var i = 0,
                cp = this.cps[i];

                // we need to find the content provider corresponding to the row index passed.
                while(ri >= cp.rc) {
                    // go to the next content provider and update the row index.
                    ri -= cp.rc;
                    cp = this.cps[++i];
                }
                return cp.getRowCells(ri);
            },

            // todo: should we refactor the code since it has duplicated code to find the proper cp.
            // but if we do that, the number of function calls will get increased.
            getUnmergedCells: function(ri) {
                var i = 0,
                cp = this.cps[i];

                while(ri >= cp.rc) {
                    ri -= cp.rc;
                    cp = this.cps[++i];
                }

                return cp.getUnmergedCells(ri);
            },

            isDataAvailable:function isDataAvailable(/* Integer */ startIndex, /* Integer */ endIndex) {
                var targetCPs = this._getCPs(startIndex, endIndex);

                for(var i=0;i<targetCPs.length;++i) {
                    if(!targetCPs[i].isDataAvailable(startIndex, endIndex)) {
                        return false;
                    }
                }

                return true;
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                var rowDownloaded = 0;

                for(var i=0;i<this.cps.length;++i) {
                    var cp = this.cps[i];
                    if(cp.isDataAvailable()) {
                        rowDownloaded += cp.getAvailableRowsCount();
                    }
                }

                return rowDownloaded;
            },

            _getCPs: function getCPs(/* Integer */ startIndex, /* Integer */ endIndex) {
                var i = 0,
                cp = this.cps[i],
                si = cp && cp.startIndexInContainer,
                targetCPs = [];

                // reset the offse of the start and end index
                if(cp) {
                    startIndex -= si;
                    endIndex -= si;
                }

                // what CP corresponds to the start ?
                while(cp && startIndex >= cp.rc) {
                    // since our index is past the current CP, we will update the index.
                    startIndex -= cp.rc;
                    endIndex -= cp.rc;

                    // go to the next content provider.
                    cp = this.cps[++i];
                }

                // now keep adding CPs till we reach the end index.
                while(cp && endIndex >= cp.rc) {
                    endIndex -= cp.rc;
                    targetCPs.push(cp);
                    // go to the next content provider.
                    cp = this.cps[++i];
                }

                // add the last CP.
                if(cp) {
                    targetCPs.push(cp);
                }

                return targetCPs;
            },

            invalid: function invalid() {
                for(var i=0;i<this.cps.length;++i) {
                    var tcp = this.cps[i];
                    tcp.invalid();
                }
                this.updatedRows = {};
            },

            getUpdatedRows: function getUpdatedRows() {
                var v = {};
                for(var i=0;i<this.cps.length;++i) {
                    var tcp = this.cps[i];
                    if(!tcp.preServeUpdatedRows) {
                        return {};
                    } else {
                        mstrmojo.hash.copy(tcp.getUpdatedRows(), v);
                    }
                }
                this.updatedRows = v;
                return v;
            },

            download: function download(/* Integer */ startIndex, /* Integer */ endIndex) {
                var targetCPs = this._getCPs(startIndex, endIndex);

                for(var i=0;i<targetCPs.length;++i) {
                    var tcp = targetCPs[i];
                    tcp.download(startIndex, endIndex);
                }
            }
        }
    );
})();

(function(){
    /**
     * <p>XtabHACP represents a horizontal aggregation of content providers.</p>
     *
     * <p> It essentially aggregates the columns of a number of Content Providers. As a result columns from different Content Providers
     * end up being rendered within a single XtabZone (HTML) table </p>
     *
     * <p> While basic content providers represent single zones (e.g. titles, headers), aggregated Content Provider can aggregate zones of a xtab e.g. for .
     * for lock col headers (only) case it would help aggregate the titles & colHeaders Content providers. So, titles and col headers end up rendering as a single table (XtabZone) as against
     * lock header BOTH case where they need to be rendered in separate tables</p>
     *
     *  @class
     *  @extends mstrmojo.XtabCP
     */
    mstrmojo.XtabHACP = mstrmojo.declare(
        // superclass
        mstrmojo.XtabCP,

        // mixins
        null,

        /**
         * @lends mstrmojo.XtabHACP
         */
        {
            scriptClass: "mstrmojo.XtabHACP",

            /**
             * Represents the Content Providers that this object aggregates.
             * @type Array
             */
            cps:[],

            initContent: function initContent(/* Integer */ startIndexInContainer) {
                this.startIndexInContainer = startIndexInContainer || 0;
                this.type = 0;
                this.colWidths = [];

                for(var i=0;i<this.cps.length;++i) {
                    this.cps[i].initContent(this.startIndexInContainer);
                    this.type |= this.cps[i].type;

                    var cw = this.cps[i].colWidths;

                    // col widths for HACP is a concatenation of individual CPs. However, we may have ONDemand CPs that
                    // won't have a col width (TQMS:39040) and we don't want to account those.
                    if(cw) {
                        this.colWidths = this.colWidths.concat(cw);
                    }
                }

                this.rc = Math.max(this.cps[0].rc, this.cps[1].rc);

                // col widths should be the same for both providers as they are vertically stacked.
                //this.colWidths = [].concat(this.cps[0].colWidths).concat(this.cps[1].colWidths);
            },

            getNumAutoHeightRows: function () {
                return Math.max(this.cps[0].getNumAutoHeightRows(), this.cps[1].getNumAutoHeightRows());
            },

            getRowCells: function (/*Integer*/ ri) {
                var cps = this.cps,
                    cells = [];
                for (var i=0,len=cps.length; i<len; i++) {
                    // TQMS 429142, 466955 if the aggregator's rc has no data in the rows, that means the cp do not contain the rows we are expecting
                    // This happens when the row headers are set to be hidden
                    if (cps[i].getAvailableRowsCount() > 0 && cps[i].rc > ri) {
                        var tmp = cps[i].getRowCells(ri);
                        if (tmp) {
                            cells = cells.concat(tmp);
                        }
                    }
                }
                return cells;
            },

            /**
             * Get the row height for a given type.
             */
            getRowHeight: function getRowHeight() {
                return this.cps[0].getRowHeight();
            },            
            
            getUnmergedCells: function(/*Integer*/ri) {
                return this.cps[0].getUnmergedCells(ri);
            },

            isDataAvailable:function isDataAvailable(/* Integer */ startIndex, /* Integer */ endIndex) {
                // we assume incremental fetch only on rows. So, we can just check the first content provider here. Its not possible to have row headers ready and not metrics (or vice versa).
                return this.cps[1].isDataAvailable(startIndex, endIndex);
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                return Math.max(this.cps[0].getAvailableRowsCount(), this.cps[1].getAvailableRowsCount());
            },

            invalid: function invalid() {
                var i, len, cp;
                for(i=0,len=this.cps.length; i<len; ++i) {
                    cp = this.cps[i];
                    cp.invalid();
                }
                this.updatedRows = {};
            },

            getUpdatedRows: function getUpdatedRows() {
                var v = {};
                for(var i=0;i<this.cps.length;++i) {
                    var tcp = this.cps[i];
                    if(!tcp.preServeUpdatedRows) {
                        return {};
                    } else {
                        mstrmojo.hash.copy(tcp.getUpdatedRows(), v);
                    }
                }
                this.updatedRows = v;
                return v;
            },

            download: function download(/* Integer */ startIndex, /* Integer */ endIndex) {
                var cp = this.cps[1];
                cp.download(startIndex, endIndex);
            }
        }
    );
})();

(function(){

    /**
     * <p>XtabTitles acts as the content provider for the titles zone of a Xtab. </p>
     *
     *  <p>While we can have generic content providers for Row Headers, Col Headers and Metric Value zones, we need a dedicated one for Titles Zone since the
     *  grid JSON for Titles Zone doesn't come in an exact tabular format that we can pass on to XtabZone as XtabCP does. For Titles, Grid JSON essentially represents
     *  the template structure (e.g. what titles below to a given axis) and properties like whether titles need to be shown, whether we want to remove the extra column.
     *  XtabTitlesCP pre processes this information and finally by conforming to the XtabCP interface it makes sure that the Titles information in Grid JSON is abstracted from the
     *  XtabZone </p>
     *
     *  @class
     *  @extends mstrmojo.XtabCP
     */
    mstrmojo.XtabTitlesCP = mstrmojo.declare(
        // superclass
        mstrmojo.XtabCP,

        // mixins
        null,

        /**
         * @lends mstrmojo.XtabTitlesCP
         */
        {
            scriptClass: "mstrmojo.XtabTitlesCP",

            init:function init(/* JSON */ props) {
                this._super(props);
            },

            download:function download(/* Integer */ startRow, /* Integer */ endRow) {
            },

            initContent: function initContent(/* Integer */ startIndexInContainer) {
                this.startIndexInContainer = 0;
                
                //Cache the original grid data that we get from the server.
                if (!this.cts) {
                    this.cts = mstrmojo.hash.clone(this.gridData.gts.col);
                }
                
                // adapt our base to the the titles tree in the grid data.
                var gts = this.gridData.gts,
                    isLockHeaders = (this.gridData.lhv !== 0),
                    rts = gts.row || [],
                    dataCts = gts.col || [],
                    s = gts.show,
                    rec = gts.rec,                  // remove extra column.
                    cts = this.cts || [],
                    nRts = rts.length,              // number of row titles.
                    nCts = cts.length,              // number of col titles.
                    cssBase = this.gridData.css;    // Css class name cache.

                this.base = {
                    items:[]
                };

                // number of rows for this zone would be the number of col titles.
                this.rc = s && cts.length || 0;

                if (this.rc === 0 && s) {
                    // case with no items on the col axis.
                    this.rc = nRts > 0 ? 1 : 0;
                }

                this.colWidths = s && gts.cws || [];

                // no row count. Just return;
                if(!this.rc) {
                    return;
                }

                // cache the row cells.
                var cells = {items:[]},
                    lrs = 1,
                    lastCell,               // Cache for the last cell title with a rowspan greater than 1.
                    i;

                // add all but last row titles.
                for(i = 0; i < nRts; ++i) {
                    rts[i].axis = 1;                    // we don't ship axis information in the JSON. todo - maybe for Titles, we should?
                    rts[i].ui = i;
                    cells.items.push(rts[i]);
                }

                // Add first col title.
                if (nCts > 0) {
                    cts[0].axis = 2;                    // we don't ship axis information in the JSON.
                    cts[0].ui = 0;
                    dataCts[0].axis = 2;               //apply the change on the data model
                    dataCts[0].ui = 0;
                    
                    lrs = cts[0].rs || 1;

                    // Are the headers locked and does this title have a rowspan greater than 1?
                    if (isLockHeaders && lrs > 1) {
                        // This will result in empty rows so use a rowspan of 1 instead, and...
                        cts[0].rs = 1;
                        
                        // create a dummy cell that will be inserted once for each extra row span value.
                        lastCell = mstrmojo.hash.clone(cts[0], {});

                        // reset the 'n' value of the dummy cell so no text will appear...
                        lastCell.n = '&nbsp;';
                        
                        // change the class for the original cell to include the first stitching rule.
                        cts[0].cni = cssBase.push({
                            n: (cssBase[cts[0].cni].n || '') + ' fsbp_1'
                        }) - 1;
                    }

                    cells.items.push(cts[0]);
                }

                var bi = this.base.items;
                bi.push(cells);

                // subsequent rows are just column titles. Note - loop starts at 1 since we have already added the first col in the first row.
                for(i = 1; i < nCts; ++i) {
                    // Did the last title have a rowspan greater than 1?
                    if (lrs > 1) {
                       // If headers are locked the cell for each row has to be cloned from the last title.
                       var cnt = lrs;

                       // Insert a row for each extra row span.
                        while(cnt-- > 1) {
                            // Are headers locked?
                            if (isLockHeaders) {
                                //Create a clone of the last cell.
                                var clone = mstrmojo.hash.clone(lastCell, {});

                                // Need to append css class names for stitching.
                                clone.cni = cssBase.push({
                                    n: (cssBase[clone.cni].n || '') + ' fsbp_' + ((cnt == 1) ? '3' :  '2')
                                }) - 1;
                                
                                //Push the clone cell into the base
                                bi.push({
                                    items: [ clone ]
                                });
                            } else {
                                //In the non-locked header case, push an empty array.
                                bi.push({items:[]});
                            }
                        }
                    }
                    
                    cts[i].axis = 2;
                    cts[i].ui = i;
                    dataCts[i].axis = 2;             //apply the change on the data model
                    dataCts[i].ui = i;
                    
                    lrs = cts[i].rs || 1;

                    // Are headers locked and does the current title have a rowspan?
                    if (isLockHeaders && lrs > 1) {
                        // This will result in empty rows so use a rowspan of 1 and cache the title for later use.
                        cts[i].rs = 1;
                        lastCell = mstrmojo.hash.clone(cts[i], {});
                        lastCell.n = '&nbsp;';
                        
                        // Append the top stitching css to the top most cell.
                        cts[i].cni = cssBase.push({
                            n: (cssBase[cts[i].cni].n || '') + ' fsbp_1'
                        }) - 1;
                    }

                    bi.push({items:[cts[i]]});
                }

                this.rc = bi.length;

                // handle removeExtraCol case.
                if(rec) {
                    this._removeExtraColumn(rts, cts);
                }
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                return this.rc;
            },

            isDataAvailable:function isDataAvailable(/* Integer */ startRow, /* Integer */ endRow) {
                return true;
            },

            /**
            * Converts base so that we don't have extra column any more.
            */
            _removeExtraColumn: function removeExtraColumn(rts, cts) {
                var nRts = rts && rts.length,
                         nCts = cts && cts.length,
                         gts = this.gridData.gts,
                         mRts = gts.row || [],
                         mCts = gts.col || [],
                         mnRts = mRts.length,
                         mnCts = mCts.length;

                // do we have both row and col titles ? If not, we don't need to remove any column.
                if(!nRts || !nCts) {
                    // we have a single col title.
                    if(nCts === 1) {
                        // in this case if Metrics is the only title, we should hide it. #395126

                        // last col title.
                        var lct = cts[nCts-1];

                        if(lct.otp == -1) {
                            // Flag the metrics to be hidden so that the individual metrics head will have the pivot button enabled
                            //TQMS 523817 set the hidden property to the grid data model instead of the cell clones in the base
                            if(mnCts > 0) {
                                mCts[mnCts-1]._hid = true;
                            }

                            // we have effectively no titles to show. So, clear the collection and update the row count.
                            this.base.items=[];
                            this.rc = 0;
                        }
                    }
                    return;
                }

                var lrt = rts[nRts-1], // get the last row title.
                    rc = this.rc, // cache the row count
                    bi = this.base.items; // cache base items

                // Within the base array, move this rowTitle so that it overrides the last col title. So, essentially we are removing the last colTitle.
                // todo1 - we should not override if the last rowTitle is Metrics.
                if(lrt) {
                    // If the last element is "Metrics", we should remove it from the base
                    if(lrt.otp == -1) {
                        // Flag the metrics to be hidden so that the individual metrics head will have the pivot button enabled
                        if(mnRts > 0) {
                            mRts[mnRts-1]._hid = true;
                        }
                        bi[0].items.splice(nRts-1, 1);
                    } else {
                        // First we update (override) the col title.

                        // Our colTitle to replace (last col title) would exist in the base [1] either as the last item in the 1st row, [2] or the last item in the last row depending on the number of col titles.
                        // find the row index index where our colTitle is.
                        var idx = rc > 1 ? rc -1 : 0,
                                r = bi[idx],
                                len = r.items.length;

                        // Flag the current last unit to be hidden;
                        if(len > 0 && mnCts > 0) {
                            mCts[mnCts-1]._hid = true;
                        }

                        // Data field 'fix' is the attribute form index, starting from 1
                        var afi = lrt.fix;
                        // Check whether the last row title is an attribute form
                        if(afi) {
                            // if the last cell is an attribute form, we should replace the colTitle with the attribute form row titles
                            for(var i = 0; i < afi; i++) {
                                r.items[len - 1 + i] = rts[nRts - afi + i];
                            }
                        } else {
                            // replace the colTitle with the last row title.
                            r.items[len-1] = lrt;
                        }

                        // If we remove the extra column, all the column title span on the top of
                        // the last column title should have the same column span, either the same as the last column title (it could be the merged title for multiple attribute forms)
                        // or the column span is the number of the last index of the attribute form (if the last column titles are attribute forms)
                        for(var j = 0, iLen = nCts -1; j < iLen; j++) {
                            cts[j].cs = afi ? afi : lrt.cs;
                        }

                        // now remove the last rowTitle.
                        // In our base array the last row title would figure in the first row, the number of row title to remove is either 1 or the number of attribute forms.
                        var rm = afi ? afi : 1;
                        bi[0].items.splice(nRts- rm, rm);
                    }
                }
                return;
            }
        }
    );
})();

(function(){
    /**
     * <p>XtabOnDemandCP represents content provider for each block of Grid data that needs to be downloaded incrementally from IServer as user scrolls to view them.
     * These Xtab rows weren't downloaded as part of the RWD JSON that was used to render this Xtab </p>
     *
     *  <p>XtabOnDemandCP is used for Incremental Fetch cases where we download and render Xtab data transparently ONLY as user scrolls them into the viewport. These content providers
     *  essentially represent 2 states. Initially they are dummy content providers that represent a row count corresponding to Incremental Fetch settings but no data rows (since they haven't been
     *  downloaded yet). However, once you trigger download on such providers they fetch the grid data asynchronously. Once data is downloaded
     *  they then initialize their content and act as a normal XtabCP</p>
     *
     *  @class
     *  @extends mstrmojo.XtabCP
     */    mstrmojo.XtabOnDemandCP = mstrmojo.declare(
            // todo2 - do we need this inheritance ?
            mstrmojo.XtabCP,

        // mixins
        null,

        /**
         * @lends XtabOnDemandCP
         */
        {
            scriptClass: "mstrmojo.XtabOnDemandCP",

            /**
             * Represents the block number. This value will be used during incremental fetch download.
             * @type Integer
             */
            blockNum:0,

            listeners: null,

            initContent: function initContent(/* Integer */ startIndexInContainer) {
                if(startIndexInContainer !== undefined) {
                    this.startIndexInContainer = startIndexInContainer;
                }
                this.isDownloaded = (this.base !== null);
                this.isDownloading = false;

                if(this.base) {
                    this._super(this.startIndexInContainer);
                    this.notifyListeners();
                }
            },

            addCPListener: function addCPListener(cp) {
                if(!this.listeners) {
                    this.listeners = [];
                }

                this.listeners.push(cp);
            },

            notifyListeners: function notifyListeners() {
                var i, cps = this.listeners,
                    count = (cps && cps.length) || 0;

                for(i = 0; i < count; i++) {
                    if(cps[i] && cps[i].onDemandDataReady) {
                        cps[i].onDemandDataReady(this);
                    }
                }
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                return this.isDownloaded ? this.rc : 0;
            },

            download:function() {
                if(!this.isDownloaded && !this.isDownloading) {
                    this.isDownloading = true;
                    this.dataSource.download(this.blockNum);
                }
            },

            invalid: function() {
                if(this._super) {
                    this._super();
                }
                this.isDownloaded = false;
                this.isDownloading = false;
            },

            isDataAvailable:function isDataAvailable(/* Integer */ startRow, /* Integer */ endRow) {
                return this.isDownloaded;
            }
        }
    );
})();


(function(){

    /**
     * Bitwise enumerations for Content Provider Types.
     * @private
     * @ignore
     */
    var TITLE = 1,
        COL_HEADERS = 2,
        ROW_HEADERS = 4,
        VALUES = 8,        
        STACK_TOP = 1,
        STACK_MIDDLE = 2,
        STACK_BOTTOM = 3,
        NO_STACK = 4,
        FULL_STACK = 5,
        GROUPING_SECTION = 6,
        TITLE_ROW = 7,
        RHMAP = {},
        DPICONVERSION = {
            120: 0.75,
            240: 1,
            320: 1.5
        },
        RHConstants = {
            1: 30, //stack top
            2: 26, //stack middle
            3: 20, //stack bottom
            4: 70, //no stack
            5: 40, //full stack
            6: 34, //grouping section
            7: 40 //title row
        },        
        BASEFORM_PICTURE = 4,
        SUBTOTAL = 1,
        CSS = {
            TITLE: 'ig-title',
            GROUPING: 'iggroup',
            BANDING: 'igbanding',
            RIGHT_ALIGN: 'rtAlign',
            LEFT_ALIGN: 'leftAlign',
            TOTAL_ROW: 'total'
        },
        $H = mstrmojo.hash,
        $A = mstrmojo.array;
    
    /**
     * This method checks if the containing CPs require grouping sections.
     * The grouping sections are only required for the Row Headers, if there are
     * two attribute forms on it.
     *
     * @param (Object) cps The collection of aggregated content providers in this HACP.
     * @param (Object) gd The grid json data object.
     *
     */
    function hasGroupingEnabled(cps, gd) {
        var cp = cps[0],
            gts = gd.gts,
            gridTitleCount = gts.cws.length;

        return (gd.vp.gr === '1' && (gridTitleCount > 1));

    }

    /**
     * This method updates the CSS class of the grid cell with any other special css to provide
     * for the Interactive Grid specific styling.
     *
     * @param (Object) cell The model representation of the Xtab cell
     * @param (Object) info An info object that allows the function to determine which css classes to append to the cell.
     * 
     * @param (Integer) info.type       The type of the Content Provider that the cell belongs to.
     * @param (Object)  info.col        The column in the IG's visualization properties that the cell belongs to.
     * @param (Array)   info.extraCss   Additional CSS Classes to be added to the cell. 
     */
    function updateCellCSS(cell, info) {
        var applyCSS = function(cell, css) {
            if (css && cell && cell.css && cell.css.indexOf(css) < 0) {
                cell.css += ' ' + css;
            }
        };

        //Make the column length account for a grouping column.
        var type = info.type,
            col = info.col,
            colCount = (col && col.cl) || 0,
            isTitle = (type === COL_HEADERS || type === TITLE);

        //Force alignment based on the type of cell it is. 
        if (type === COL_HEADERS || type === VALUES) {
            applyCSS(cell, CSS.RIGHT_ALIGN);
        } else if (type === TITLE || type === ROW_HEADERS) {
            applyCSS(cell, CSS.LEFT_ALIGN);
        }
        
        //Are we updating the css for the title rows?
        if (isTitle) {
            
            // Does the column have toggle enabled and are there multiple columns for the user to toggle?
            if (col && col.tg && colCount > 1) {
                
                // Have we already updated the toggle headers.
                if (!cell._v) {
                    
                    //Cache the cell value to another variable.
                    cell._v = cell.v;
                    
                    // Add an encasing span so as to place the metric toggle button close to the Header value.
                    cell.v = "<span class='toggleHeader'>" + cell.v + "</span>";
                }
            }
            
            //The col header zone or the title zome make up the title bar for interactive grids. We want to display different colors for them.
            // 521117 Zhang Hongchao 2013-06-03
            // delete 'color' attribute in css class 'ig-title' and 'mstrmojo.interactiveGrid.black .ig-title' to make the title has the same 'color' behavior with the value
            // The color behavior is:
            //if (no setting color) {
            //	use default color: #25396e;
            //} else if (has setting color) {
            //	if (set color is differenct from the theme) {
            //		use set color;
            //	} else if (set color is the same with the theme) {
            //		use default color: #e18a07;
            //	}
            //}
            applyCSS(cell, CSS.TITLE);
        }
        
        //Append any additional css class names that the cell may require. If null, the function will ignore it.
        $A.forEach(info.extraCss, function(css) {
            applyCSS(cell, css);
        });
    }

    function findAttributeCPIndex(cg) {
        return 0;
    }

    /**
     * Find out how many cells are stacked in one row by checking the visualization property
     * @param {Object} cols cols property in the visualization property
     * @returns v Row stack level in Integer
     */
    function getStackLevel(cols) {
        var i, cg = cols.cg, len = cg && cg.cgc, v = 1;
        for(i = 0; i < len; i++) {
            //loop through the cgs, and found the max cl
            if(cg && cg[i] && !cg[i].tg && cg[i].cl > v) {
                v = cg[i].cl;
            }
        }
        return v;
    }
    /**
     * Returns the stack position (top, middle, of bottom) of a give row.
     * @param {Integer} index The current row index
     * @param {Integer} stackLevel The stack level of Interactive Grid
     * @returns {Integer} STACK_TOP, STACK_MIDDLE, STACK_BOTTOM, or NO_STACK
     */
    function getStackPos(index, stackLevel) {
        //set default to be no stack. when stack level is less than 1, we will return NO_STACK
        var pos = NO_STACK;
        if(stackLevel > 1) {
            if(index === 0) {
                pos = STACK_TOP;
            } else if (index === stackLevel - 1) {
                pos = STACK_BOTTOM;
            } else {
                pos = STACK_MIDDLE;
            }
        }
        return pos;
    }
    
    /**
     * The function return the cell's column index. The cell is colStacks[ciis][index]. This cell must be 
     * in the colStacks, that is, it cann't be an empty cell
     * @param {Array} colStacks The colStacks array that stores the stacked row cells array.
     * @param {Integer} ciis column index in colStacks.
     * @param {Integer} index Current row index in the stack.
     * @param {object} vp visualization property
     * @returns {integer} column index of cell colStacks[ciis][index] 
     */
    function getColumnIndex(/*Array*/colStacks, /*integer*/ciis, /*integer*/index, /*object*/vp) {
    	var cg = vp && vp.cols && vp.cols.cg,
    		i,
    		totalIndex = 0,
    		sum = 0;
    	if (cg) {
    		for (i=0; i<ciis; i++) {
    			if (colStacks[i]) {
    				totalIndex += colStacks[i].length;
    			}
    		}
    		totalIndex += (index+1);
    		for (i=0; i<cg.cgc; i++) {
    			sum += cg[i].cl;
    			if (sum >= totalIndex) {
    				return i;
    			}
    		}
    	}
    	return -1;
    }

    /**
     * The function go through colStacks array, and find the cells that are on the same row. For example, the colStacks array
     * can have array: [ [A, B, C], [D, E], [F] ]. If the stackLevel is three, the function will
     * return [A, D, F] as the first row, [B, E, F'] as the second row, and [C, E', F'] as the third row.
     * The E' and F' means that it is an copy of E or F but with no value text.
     * @param {Array} colStacks The colStacks array that stores the stacked row cells array.
     * @param {Integer} index Current row index in the stack.
     * @param {Integer} stackLevel The stack level.
     * @param {object} vp visualization property
     * @returns {Array} An array of cell for a given row 
     */
    function getStackedRow(/*Array*/colStacks, /*Integer*/index, /*Integer*/stackLevel, /*object*/vp) {
        var a = [], c, i, len, size;

        for(i = 0, len = colStacks.length; i < len; i++) {
            //if only one row in the stack, we need to handle a special case when there is a picture element
            //the image cell need to
            if(colStacks[i].length === 1) {
                //set the cell to be top row item
                c = colStacks[i][0];
                //set the stack position
                c.rowType = (c.rowType !== TITLE_ROW) ? getStackPos(index, stackLevel) : TITLE_ROW;

                // Store a flag on the cell saying that it is the only element in the column.
                c.singleStack = (stackLevel > 1);
                
                // Now we're changing the data model, so make a copy.
                c = $H.copy(c);
                
                //if the cell is a image
                if(c.ts === BASEFORM_PICTURE) {
                    //on the stack top
                    if(stackLevel === 1) {
                        c.rowType = NO_STACK;
                        // add column index of the table cell
                        c.colIdx = getColumnIndex(colStacks, i, index, vp);
                    } else if(!index) {
                        //only set it to be full stack when there is one picture element in the stacked cells
                    	//Zhang Hongchao donot set rowType to FULL_STACK, so as to set proper image cell's max-width and max-height
                        //c.rowType = FULL_STACK;
                    	c.colIdx = getColumnIndex(colStacks, i, index, vp);
                    } else {
                        //if the image is not on the stack top, we should not send the cell as image type
                        delete c.ts;
                        c.v = '';
                    }
                //if not on the stack top and not a picture element
                } else if(index) {
                    c.v = '';
                }
            } else {
                //get the cell in the colStack array
                c = colStacks[i][index];
                if(!c) {
                    //if we need to generate a empty cell to fill the stack, the cell should be a copy
                    //of the available cell on the stack bottom
                    size = colStacks[i].length;
                    c = $H.copy(colStacks[i][size-1], {});
                    c.v = '';
                    if (c.hasOwnProperty('ts')) {
                    	delete c.ts;
                    }
                } else if (c.ts ===BASEFORM_PICTURE) {
                	c.colIdx = getColumnIndex(colStacks, i, index, vp);
                }
                //set the stack position
                c.rowType = (c.rowType !== TITLE_ROW) ? getStackPos(index, stackLevel) : TITLE_ROW;
            }
            a.push(c);
        }
        return a;
    }

    /**
     * Returns the row index on the original content provider before stacking or grouping.
     * @param {Integer} ri The current row index (after grouping or stacking).
     * @returns {Integer} The row index on the original content provider.
     */
    function getOriginRowIndex(ri) {
        if(ri === 0) {
            return 0;
        }
        //check how many sections above the row
        var sc = this.sectionMap[ri - 1] || 0;
        //the current row index minus the number of sections above the row is the row count for stacked rows.
        //divide the stack levels to get correct row count
        return Math.floor((ri - sc)/this.stackLevels);
    }


    /**
     * Returns the sectionInfo for the given offset value. If the offset value is within the section header, returns the corresponding sectionInfo object.
     * @param offset The scrollTop offset from of the grid.
     * @return {Object} sectionInfo object.
     */
    function getSectionInfo(offset) {
        var i, s, si = this.sectionInfo,
            len = si.length,
            rh = this.srh,
            ls = this.lastSectionIndex;

        //find the last section info object
        s = si[ls];
        if(offset >= s.rs && offset < (s.rs + rh)) {
            return s;
        }
        //if the offset is not reached to the last section, that means we need look back of the sections to find it
        if(offset < s.rs) {
            //get the previous section
            i = ls-1;
            if(i <= 0) {
                this.lastSectionIndex = 0;
                return null;
            }

            do {
                s = si[i];
                if(offset > s.rs && offset <= (s.rs + rh)) {
                    this.lastSectionIndex = i;
                    return s;
                }
            } while(offset < s.rs && --i > 0);

            this.lastSectionIndex = i;
            return s;
        //otherwise, whether the current offset exceeds the next section boundary?
        } else {
            i = ls+1; //get the next section. Because index use zero based, the ls happens to be the next section index
            if(i >= len) {
                this.lastSectionIndex = len - 1;
                return null;
            }

            do {
                s = si[i];
                if(offset > s.rs && offset <= (s.rs + rh)) {
                    this.lastSectionIndex = i;
                    return s;
                }
            } while(offset > (s.rs + rh) && ++i < len);

            this.lastSectionIndex = i-1;
            return null;
        }
    }
    
    /**
     * Add extra column cells to the right end of the grid. The cell is used to place an arrow image '>' to indicate 
     * whether the whole row have some default action.
     * @param {Array} cells The cells for a given row.
     * @param {Integer} tgcc The toggled column count. By default the value is 1. 
     * @param {Integer} [ei] The interactive cell index.
     * @param {Integer} [rh] The row hight of the stacked/unstacked row.
     */
    function addExtraColumnCell(cells, tgcc, ei, rh) {
        var c = cells[0],
            i, len = cells.length,
            rt = c && c.rowType,
            nc = {v: '', css: 'empty-igcell', rowType: rt};

        if(ei !== undefined && c && (rt === STACK_TOP || rt === NO_STACK || rt === FULL_STACK)) {
            nc = {
                v: '<div><div class="IG-ActionArrow-IMG" style="height:' + rh + 'px;top:-' + (0.5*RHMAP[rt]) + 'px;"></div></div>', 
                css: 'IG-ActionArrow',
                _ei: ei
            };
        }
        
        //find all the last columns, especially those columns are toggled
        for(i = len - 1; i >= len - tgcc; i--) {
            c = cells && cells[i];
            if(c) {
                c.css += ' IG-lastdatacolumn';
            }
        }
        cells.push(nc);
    }
    
    /**
     * This method converts the column widths from percentage values to pixel values based on the width available to
     * the Interactive Grid. The default value of gridWidth for content provider is 480px.
     */    
    function calculateCWS(vp, width, isTdWidths) {
        var cols = vp.cols,
            cg = cols.cg,
            extraColumn = [{w: '0px'}];

        //Check if we need to adjust the Column widths and we haven't already done so..
        if (cols && width) {
            var cws = cols.cws,
                cwsInPx = [],
                len = cws.length,
                excludeWidth = 0,
                autoColWidth = (parseInt(vp.ar, 10) === 1) ? (width / len) : -1,
                w, cw, unsignedcol = false, excludeCol = 0,
                adjustedWidth = width,
                totalW = 0,
                i;
    
            //Check for messy data when we have no column width specified.
            for (i = 0; i < len; i++) {
                cw = cwsInPx[i] = cws[i];
                w = cw.w;
                if(w === "") {
                    unsignedcol = true;
                } else if(cw.xc) {
                    excludeWidth += parseInt(w);
                    adjustedWidth -= excludeWidth;
                    excludeCol++;
                } else {
                    totalW += parseFloat(w, 10);
                }
            }
            
            if(unsignedcol || totalW < 100) {
                autoColWidth = adjustedWidth/(len-excludeCol);
            }

            for (i = 0; i < len; i++) {
                cw = cws[i];
                if(cw.xc) {
                    //keep the cwsInPx original value
                    continue;
                //Has the user specified fixed column widths for each of the columns?
                } else if (autoColWidth === -1) {
                    //Convert from % values to pixel values.
                    w = parseInt(cw.w, 10) * adjustedWidth / 100;
    
                    //If the width is undefined, then split the column widths evenly based on the column count.
                    if (!w && w !== 0) {
                        w = parseInt(adjustedWidth / cg.cgc, 10);
                    }
                } else {
                    //Auto col width case - we'll use the same column width for all columns.
                    w = (parseInt(cw.w, 10) < 0) ? 0 : autoColWidth;
                }
    
                //Change the cws property to the new pixel values.
                cwsInPx[i] = {w: w + 'px'};
            }
            
            if (isTdWidths) {
            	// if we are calculating the table td widths
            	return cwsInPx;
            }
            
            var newCWS = [],
                cnt = 0;
            
            //Once we've calculated the column widths, we want to adjust it so that we can account for the toggleable columns.
            for (i = 0; i < len; i ++) {
                var c = cg[i],
                    //If we don't have stacking - get the column length or else initialize to 1
                    count = c.tg ? c.cl : 1, 
                    j = 0;
                
                //Check if we have a toggleable column.
                for (j = 0; j < count; j++) {
                    var wi = '0px';
                    
                    if (j === c.cc) {
                        wi = cwsInPx[i].w;
                    }
                    
                    newCWS[cnt+j] = {w: wi};
                }
                
                //Increment the count so we know 
                cnt += count;
            }
            return newCWS.concat(extraColumn);
        } else {
        	if (isTdWidths) {
        		// if we are calculating table td widths
        		return null;
        	} else {
        		return cp.cws.concat(extraColumn);
        	}            
        }
    }
    
    function clearStackCols () {
        delete this.lastStackCols;
        delete this.lastAttRow;
        delete this.lastMtxRow;
    }
    
    /**
     * <p>XtabHACP represents a horizontal aggregation of content providers.</p>
     *
     * This is a special HACP for the Interactive Grid visualization.
     *
     *  @class
     *  @extends mstrmojo.XtabHACP
     */
    mstrmojo.InteractiveGridHACP = mstrmojo.declare(
        // superclass
        mstrmojo.XtabHACP,

        // mixins
        null,

        /**
         * @lends InteractiveGridXtabHACP
         */
        {
            scriptClass: "mstrmojo.InteractiveGridHACP",

            /**
             * This object is a map that calculates the location at which the interactive grid needs to be
             * broken down into different sections.
             */
            sectionMap: [],

            /**
             * how many cells are stacked on top of each other for a given row
             */
            stackLevels: 1,

            gridWidth: 480,
            
            tdWidths: null,
            
            lastSectionIndex: 0,

            adjustCPMaps: function adjustCPMaps() {
                var cps = this.cps,
                    attCP = this.cps[0],
                    rc = Math.max(cps[0].rc, cps[1].rc);

                //Creates the sectionMap and row height map only if we are not deal with titles and column headers
                if(attCP.type !== TITLE) {
                    var gd = this.gridData,
                        getParentElement = function(cp, n) {
                            var items = cp.base.items,
                                es = cp.lookupBase[0].es,
                                tgt = items[n].items[0],
                                cell = es && es [tgt.idx];
                            return (cell && cell.n) || ((tgt.pi && es[tgt.pi.ri || 0]) || '');
                        },
                        i, j, sc = 1, count, lastSection, curP,
                        start = 0, end = -1,
                        m, cpc, lastRow = 0,
                        shouldGroupEls = this.groupEnabled;

                    for(m = 0, i = 0, cpc = attCP.cps ? attCP.cps.length : 1; m < cpc; m++) {
                        var cp = attCP.cps ? attCP.cps[m] : attCP,
                            cprc = cp.rc;
                        //check whether the data is available
                        start = end + 1;
                        end = start + cprc - 1;
                        //set up the section info object and section map only for cp with data
                        if(cp.isDataAvailable(start, end)) {
                            //if the cp has been processed
                            if(cp.lastRow) {
                                lastRow = cp.lastRow;
                                lastSection = cp.lastSection;
                            } else {
                                i = lastRow || 0;
                                for(j = 0, sc = this.sectionMap[i-1] || 0; j < cprc; j++) {
                                    var stackLevel = this.stackLevels;

                                    curP = getParentElement(cp, j);
                                    //if it is a start of new section
                                    if(shouldGroupEls && curP !== lastSection) {
                                        lastSection = curP;
                                        this.sectionInfo.push({
                                            sn: curP, //section name
                                            rs: this.srh*sc + this.stackedRh*Math.floor((i-sc)/this.stackLevels) //row start
                                        });
                                        this.sectionMap[i] = ++sc;
                                        i++;
                                    }
                                    //if we have stacks
                                    while(stackLevel) {
                                        this.sectionMap[i] = sc;
                                        stackLevel--;
                                        i++;
                                    }
                                }
                                //if the cp has been iterated for generating the maps, set the flag so that next time we do not go through it again
                                lastRow = cp.lastRow = i;
                                //save the last section header name
                                cp.lastSection = curP;
                            }
                        } else {
                            //we should not continue is the one of the cp is missing data
                            break;
                        }
                    }
                    //Calculate the row count based on the grid structure
                    this.rc = (this.stackLevels > 1 ? rc * this.stackLevels : rc) + (shouldGroupEls ? sc : 0);
                }
            },

            onDemandDataReady: function onDemandDataReady() {
                this.adjustCPMaps();
            },

            initContent: function initContent(/* Integer */ startIndexInContainer) {
                var cps = this.cps,
                    gd = this.gridData = cps[0].gridData || cps[0].cps[0].gridData,
                    vp = gd.vp = this.gridVp = this.gridVp || gd.vp, // TQMS 642868: only update "vp" on grid if it's not existed
                    daf = vp.daf && vp.daf.split(":"),
                    cols = vp.cols,
                    cg = cols.cg,
                    cws = cols.cws,
                    attCP = cps[findAttributeCPIndex(cg)],
                    attLB = gd.gts.row,
                    gts = gd.gts,
                    grouping = hasGroupingEnabled(cps, gd),
                    notTitleCP = attCP.type !== TITLE,
                    i, len, _c, vcps, cf, cp, igcp,
                    dpi = mstrApp.isTablet() ? 240 : mstrMobileApp.getDeviceDPI();
                
                // Update the row height for every specific dpi
                $H.forEach(RHConstants, function(h, rowType) {
                    RHMAP[rowType] = h * DPICONVERSION[dpi];
                });
                
                //if not title cp, we need to modify the vp properties and grid title display properties before calling the super
                if(notTitleCP) {
                    if (vp.dafIdx === undefined && daf) {
                        //Figure out the index of the default action form on the actual grid data. Loop through all the attributes and find our
                        //attribute that has the default action form.
                        for (i = 0; i < attLB.length; i++) {
                            //Compare the attribute id and it's form id to find the attribute marked as the default form.
                            if (attLB[i].id === daf[0] && attLB[i].fid === daf[1]) {
                                //Cache the default action in the vp
                                vp.dafIdx = i;
                                break;
                            }
                        }                        
                    }
                }
                
                //if no toggle is defined, remove titles and col headers
                for(i = 0; i < cg.cgc; i++) {
                    if(cg[i] && cg[i].tg) {
                        //if toggle is enabled
                        break;
                    }
                }
                //if all the column group does not have toggle, we should hide the titles and col headers
                if(i === cg.cgc) {
                    gd.gts.show = false;
                    gd.ghs.chs.show = false;
                }
                

                this._super(startIndexInContainer);
                
                this.colWidths = calculateCWS(vp, this.gridWidth);
                
                this.tdWidths = calculateCWS(vp, this.gridWidth, true);
                
                //if it is not title cp, set up IG grouping or stacking properties
                if(notTitleCP) {
                    //Set the stack levels, the maximum number of attribute forms/metrics stack on top of each other
                    this.stackLevels = getStackLevel(cols);

                    //Initialize the row heights for section row height (srh), minimum row height (mrh), stacked row height (stackedRh), and regular row height
                    if(this.stackLevels > 1) {
                        //Sticky section header row height
                        this.srh = RHMAP[GROUPING_SECTION];
                        // regular row height, min row height
                        this.rh = RHMAP[NO_STACK];
                        // minimum row height for stacked rows
                        this.mrh = RHMAP[STACK_BOTTOM];
                        // adjusted row height
                        this.stackedRh = RHMAP[STACK_TOP] + (this.stackLevels - 2)*RHMAP[STACK_MIDDLE] + RHMAP[STACK_BOTTOM];
                    } else {
                        this.srh = RHMAP[GROUPING_SECTION];
                        this.rh = this.stackedRh = this.mrh = RHMAP[NO_STACK];
                    }
                    
                    //init row height map, and set up sectionMap
                    if(grouping || this.stackLevels > 1) {
                        //Initialize the section map
                        this.sectionMap = [];

                        //Initialize the sectionInfo map
                        this.sectionInfo = [];

                        //Set the grouping property
                        this.groupEnabled = grouping;

                        //Initilialize the sectionMap, and adjust row counts
                        this.adjustCPMaps();
                        
                        //Add listener (interactive grid cp) to the onDemandCP.
                        vcps = this.cps[0].cps;
                        if(vcps) {
                            igcp = this;
                            //loop through all the ondemand content providers.
                            for(i = 0, len = vcps.length; i < len; i++) {
                                cp = vcps[i];
                                //add interactive grid cp as the listener
                                if(cp && cp.addCPListener) {
                                    cp.addCPListener(igcp);
                                }
                            }
                        }                                                
                    }
                }
            },

            getUnmergedCells: function(ri) {
                return;
            },

            /**
             * Returns a cell with resolved name and css name for group header. The css name includes 'iggroup' for the section header.
             * The row number and column number has to be within the range of the grid data.
             * @param {Integer} r Row number
             * @param {Integer} c Column number
             * @returns {Object} An cell object with at least name and css name.
             */
            getResolvedGroupHeader: function(r, c) {
                var gd = this.gridData,
                    es = gd.gts.row[c].es,
                    cell = gd.ghs.rhs.items[r].items[c];

                if(cell) {
                    if(!cell.css) {
                        cell.css = gd.css[cell.cni].n + ' iggroup';
                        cell.n = es[cell.idx].n;
                    }
                } else {
                    return { css: ' iggroup', n: ''};
                }

                return cell;
            },

            getRowCells: function (/*Integer*/ ri) {
                var cps = this.cps,
                    cells = [],
                    gd = this.gridData,
                    vp = gd.vp,
                    cg = vp.cols.cg,
                    attCP = cps[findAttributeCPIndex(cg)],
                    enableGrouping = this.groupEnabled,
                    showBanding = vp.bn === "1",
                    stackCols = [],
                    oi = getOriginRowIndex.call(this, ri),
                    eiDfa, //default form action ei
                    eiInteractiveRow,
                    lastToggledColumn = 1,
                    onTotalRow,
                    totalCell,
                    rowCells,
                    i, j, len, c, 
                    tc;

                //Are we grouping elements for this content provider?
                if (enableGrouping && (this.sectionMap[ri] !== this.sectionMap[ri-1])) {
                        //Does this Content Provider require grouping? and..
                        //Are we on a new grouping row?
                        var cell = $H.copy(attCP.getRowCells(oi)[0], {});

                        //update the colspan
                        cell.cs = this.colWidths.length;

                        //update cell row type
                        cell.rowType = GROUPING_SECTION;

                        //Apply the grouping section CSS class on the cell.
                        updateCellCSS(cell, {
                            col: null,
                            type: attCP.type,
                            extraCss: [CSS.GROUPING]
                        });

                        return [cell];
                }

                //TQMS 507190 for the first row, always clear the caches
                if(!ri) {
                    clearStackCols.call(this);
                }
                
                //get the (cached) row cells from attribute cp and metric cp
                this.lastAttRow = this.lastAttRow || (cps[0].rc ? cps[0].getRowCells(oi) : []);
                this.lastMtxRow = this.lastMtxRow || (cps[1].rc ? cps[1].getRowCells(oi) : []);

                //if the row is a total row
                rowCells = this.lastAttRow;
                len = rowCells.length;
                if (len > 0 && rowCells[0].stt) {
                    onTotalRow = true;
                    for(i = 0; i < len; i++) {
                        c = rowCells[i];
                        if(c.stt === SUBTOTAL) {
                            totalCell = c;
                            break;
                        }
                    }
                }
                
                if(!this.lastStackCols) {
                    
                    $A.forEach([this.lastAttRow, this.lastMtxRow], function(row){
                        for (i = 0; i < row.length; i++) {
                            if (row[i]._ei !== undefined) {
                                //Get the cell with the default form action.
                                if (vp.dafIdx >= 0) {
                                    tc = attCP.getRowCells(oi)[vp.dafIdx];
                                }

                                //Give the default form action value a default empty string or if default form action is set up
                                eiDfa = (vp.dafIdx >= 0) ? (tc && tc._ei) : "";
                                
                                //Returning false causes a break;
                                return false;
                            }
                        }
                    }, this);

                    //reuseable function to add css binding and default form action
                    var addInfo = function(cell, cp) {
                        if (cell && (cp.type === TITLE || cp.type === COL_HEADERS)) { 
                            if(colGroup.tg === false) {
                                cell.n = cell.v = "";
                            }
                            cell.rowType = TITLE_ROW;
                        }
                        
                        
                        
                        // Update the cell's css property.
                        updateCellCSS(cell, {
                            col: colGroup,
                            type: cp.type,
                            extraCss: [((cp.type === VALUES || cp.type === ROW_HEADERS) && showBanding && (oi % 2 === 1)) ? CSS.BANDING : null, onTotalRow ? CSS.TOTAL_ROW : null]
                        });
                        
                        if(cell) {
                            //TQMS:512405 set column span of IG cells to be 1
                            cell.cs = 1;
                            
                            //Ensure that set the default attribute form's action on cells that don't have an action associated with them.
                            if (cell._ei===undefined && vp.dafIdx !== undefined) {
                                cell._ei = eiDfa;
                            }
                        }

                    };

                    this.lastRowIndex = 0;
                    for (j = 0; j < cg.cgc; j++) {
                        var colGroup = cg[j],
                            mCol = colGroup['mix' + colGroup.cc],
                            isMetric = mCol !== undefined,
                            cp = cps[isMetric ? 1 : 0],
                            k, p, ci, 
                            trc = {n:'', stt: SUBTOTAL, css: 'xtab-td'};
                            arr = [];

                        //if the column contains the toggle cells
                        if(colGroup.tg) {
                            
                            for (var i = 0; i < colGroup.cl; i ++) {
                                arr = [];
                                
                                //Get the current column index. If we have an extra attribute to support grouping, adjust the column index appropriately.
                                ci = isMetric ? colGroup['mix' + i] : colGroup.attForms[i].idx;
                                
                                //Get the cell we want to display
                                var rowCells = isMetric ? this.lastMtxRow : this.lastAttRow;
                                
                                //Get make a copy of the toggleable column.
                                c = rowCells[ci];
                                
                                //If we do not find a cell, then we need a copy of it
                                if(onTotalRow) {
                                    if(!c) {
                                        c = trc;
                                    } else if(c && c.stt === SUBTOTAL) {
                                        //first copy the total cell content into trc
                                        //and then assign the copied content to c 
                                        c =$H.copy(totalCell, trc);
                                    } else {
                                        c = $H.copy(c, {});
                                    }
                                } else {
                                    c = $H.copy(c, {});
                                }
    
                                //add css, rowType, etc
                                addInfo(c, cp);
    
                                arr.push(c);
                                
                                stackCols.push(arr);
                            }
                            
                            //if the toggled column group is the last column
                            if(j+1 === cg.cgc) {
                                lastToggledColumn = colGroup.cl;
                            }

                        //otherwise, the cells should stack to each
                        } else {
                            for(k = 0, len =colGroup.cl; k < len; k++) {
                                //if metric, get the value from metric row
                                if(isMetric) {
                                    p = colGroup['mix' + k];
                                    if(p!== undefined) {
                                        c = this.lastMtxRow[p];
                                    }
                                //else get the data from attribute row by using the attForms index
                                } else {                                                                        
                                    p = colGroup.attForms[k];
                                    if(p) {
                                        c = this.lastAttRow[p.idx];
                                    }
                                    
                                    //If this is the total row, we only render the first cell
                                    if (onTotalRow && !c){
                                        c = trc;
                                    }

                                }

                                //add css, rowType, etc
                                addInfo(c, cp);

                                arr.push(c);
                            }
                            
                            stackCols.push(arr);
                        }
                    }
                    this.lastStackCols = stackCols;
                }

                cells = getStackedRow(this.lastStackCols, this.lastRowIndex++, this.stackLevels, vp);

                if(this.lastRowIndex >= this.stackLevels) {
                    clearStackCols.call(this);
                }

//                //check whether the new row cells contains interactive cells
//                for(i = 0, len = cells.length; i < len; i++) {
//            		/**
//            		 * 752423 Zhang Hongchao 2013-06-04
//            		 * The right arrow indicates drill only.
//            		 * TODO: For stacked row, this only check the stack-top row. We need to check the whole row
//            		 * at: action type, Bitwise value that represents the the action type. 
//            		 * Its possible values are:
//            		 * - STATIC (0)
//            		 * - DRILLING (0x1)
//            		 * - SELECTOR_CONTROL (0x2)
//            		 * - HYPERLINK (0x4)
//            		 * - SORT (0x8)
//            		 * - PIVOT (0x10)
//            		 * - EDIT (0x20)
//            		 */
//                    if(parseInt(cells[i]._ei, 10) >= 0 && cells[i].at === 1) {
//                        eiInteractiveRow = eiDfa;
//                        break;
//                    }
//                }
                
                /**
        		 * 752423 Zhang Hongchao 2013-06-04
        		 * Instead of checking the whole row, we check the document definition once and for all
        		 * 2013-06-06 comment addExtraColumnCell to disable right arrow in any situation
        		 */
//                // if has Drill action, set eiInteractiveRow to draw right arrow
//                if (hasDrill) {
//                	eiInteractiveRow = 1;
//                }
//
//                
//                //put the extra column that holding the right arrow image
//                addExtraColumnCell(cells, lastToggledColumn, eiInteractiveRow, this.stackedRh);
                
                
                return cells;
            },

            /**
             * Returns the row height for specific row type
             */
            getRowHeight: function getRowHeight(type) {
                var rh = RHMAP[NO_STACK];
                return RHMAP[type] || rh;
            },

            isDataAvailable:function isDataAvailable(/* Integer */ startRow, /* Integer */ endRow) {
                if(!this.onDemandIF || !this.cps[1].cps) {
                    return true;
                } else {
                    var maxRow = this.sectionMap.length, s;
                    //if no stacking or grouping
                    if(!maxRow) {
                        return this.cps[1].isDataAvailable(startRow, endRow);
                    }
                    //else
                    if(endRow > maxRow) {
                        if(startRow < maxRow) {
                            s = getOriginRowIndex.call(this, startRow);
                            return this.cps[1].isDataAvailable(s, s + (endRow-startRow));
                        } else {
                            return false;
                        }
                    } else {
                        return this.cps[1].isDataAvailable(getOriginRowIndex.call(this, startRow), getOriginRowIndex.call(this, endRow));
                    }
                }
            },

            download: function download(/* Integer */ startIndex, /* Integer */ endIndex) {
                var si = getOriginRowIndex.call(this, startIndex),
                    ei = si + Math.ceil((endIndex - startIndex)/this.stackLevels),
                    cp = this.cps[0], i, tcp,
                    targetCPs = !cp.cps? [cp] : this.cps[0]._getCPs(si, ei);

                for(i=0;i<targetCPs.length;++i) {
                    tcp = targetCPs[i];
                    tcp.download(si, ei);
                }
            },

            /**
             * Gets the section information object for the current row.
             */
            getRowCellInfo: function (offset) {
                //get the section info object if the view is scrolled some offset
                //as the section header can take space for one row, the total offset should include the section row height
                var sectionInfo = getSectionInfo.call(this, offset + this.srh),
                    lastSection, i = this.lastSectionIndex;
                if(sectionInfo) {
                    lastSection = this.sectionInfo[i - 1]; //i-1 is the current sectionInfo index, and i-2 is the previous section
                    return {
                        rowStart: sectionInfo.rs,
                        isNextRowNewSection: true,
                        sectionName: lastSection && lastSection.sn //previous section name
                    };
                } else {
                    return {
                        isNextRowNewSection: false,
                        sectionName: this.sectionInfo[i].sn
                    };
                }
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.ToggleDIC",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.url",
                         "mstrmojo.array");

    mstrmojo.android.inputControls.ToggleDIC = mstrmojo.declare(

        mstrmojo.ToggleDIC,

        [ mstrmojo._TouchGestures, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: 'mstrmojo.android.inputControls.ToggleDIC',

            useAnimation: false,

            init: function init(props) {
                this._super(props);

                //TQMS 614563: Convert relative image path to absolute image path
                mstrmojo.array.forEach(this.dic.vls, function (v) {
                    v.n = mstrmojo.url.getAbsoluteURL(v.n, mstrApp.getConfiguration().getCurrentProjectWebServerUrl());
                });
            },

            touchTap: function touchTap() {
                this.onclick();
            },

            onclick: function onclick() {
                this._super();
                this.applyChanges();
            },

            //override to force change applied upon each touch tap
            onblur: mstrmojo.emptyFn
        }
    );
}());
(function() {
    mstrmojo.requiresCls("mstrmojo.TristateCheckBox", "mstrmojo._IsInputControl");
    
    /** 
     * Inline only
     */
    mstrmojo.CheckBoxDIC = mstrmojo.declare(
        mstrmojo.TristateCheckBox,
        
        [mstrmojo._IsInputControl],
        
        {
            scriptClass: 'mstrmojo.CheckBoxDIC',
            
            markupString: '<div id="{@id}" class="mstrmojo-Label {@cssClass}" style="{@cssText}" tabindex="1" mstrAttach:click,keydown></div>',
            
            cssText: 'width: 0; margin:0 auto; max-height: 18px; cursor: pointer;',
            
            onclick: function() {
                //if the status changed from unset to set, we immediately check the checkbox, to set the checked to be true 
                //because initial value was false, so oncheckedChange will get triggered.
                if (this.grayed) {
                    this.set('grayed', !this.grayed);
                    this.set('checked', true);
                } else {
                    this.set('checked', !this.checked);
                }
            },                        
            
            oncheckedChange: function(e) {
                this.set('value', this[this.checked ? 'onValue' : 'offValue']); 
            },
            
            preBuildRendering: function(){
                this._super();
                
                var vls = this.dic.vls;
                this.offValue = vls[0].v;
                this.onValue = vls[1].v;
                
                this.grayed = (this.onValue !== this.value) && (this.offValue !== this.value);
                this.checked = (this.onValue === this.value);
            },
            
            postBuildRendering: function(){
                this._super();
                
                this.domNode.style.height = this.openerStyle.ih + 'px';
            },
            
            onkeydown: function(evt){
                var hWin = evt.hWin, 
                    e = evt.e || hWin.event;
                
                if (e.keyCode === mstrmojo.Enum_Keys.SPACE){ //Space key
                    mstrmojo.dom.preventDefault(hWin, e);
                    this.onclick();
                }
            },
            
            focus: function(){
                this.domNode.focus();
            }
        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.CheckBoxDIC",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var MIN_HEIGHT_MDPI = 24,
        MIN_HEIGHT_HDPI = 36,
        MIN_HEIGHT_XHDPI = 48,
        MIN_HEIGHT = {160: MIN_HEIGHT_MDPI,
                      213: MIN_HEIGHT_MDPI,
                      240: MIN_HEIGHT_HDPI,
                      320: MIN_HEIGHT_XHDPI},
        SCROLLER_OFFSET_X = {160: 48,
                             213: 48,
                             240: 73,
                             320: 98},
        SWITCH_DURATION = 300,
        $C = mstrmojo.css,
        $D = mstrmojo.dom;

    function toggleBtn(isOn) {
        this.btnNode.innerHTML = isOn ? this.onText : this.offText;
        $C.toggleClass(this.btnNode, 'on', isOn);
        $C.toggleClass(this.btnNode, 'off', !isOn);
    }

    function clearAnimationTimeout() {
        if (this._animHandle) {
            window.clearTimeout(this._animHandle);
            delete this._animHandle;
        }
    }

    // apply transfrom manually if the button is not stop at two ends or user just tap the button.
    function applyTransform(duration, value) {
        this._scroller.origin.x = value;

        if (!duration) return;

        var style = this.scrollNode.style,
            me = this;

        this._isAnimating = true;
        style[$D.CSS3_TRANSITION_DURATION] = duration + 'ms';
        style[$D.CSS3_TRANSFORM] = $D.createTranslateString(-value);

        this._animHandle = window.setTimeout(function() {
            if (me._isAnimating) { me._isAnimating = false; }
            clearAnimationTimeout.call(me);
        }, duration * 3);
    }
    /**
     * Check box data input control for the Android app.
     *
     * @extends mstrmojo.CheckBoxDIC
     * @borrows mstrmojo._TouchGestures
     * @borrows mstrmojo._HasTouchScroller
     * @borrows mstrmojo.android._HasPreviewButton
     *
     * @class
     */
    mstrmojo.android.inputControls.CheckBoxDIC = mstrmojo.declare(

        mstrmojo.CheckBoxDIC,

        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller, mstrmojo.android._HasPreviewButton ],

        /**
         * @lends mstrmojo.android.inputControls.CheckBoxDIC.prototype
         */
        {
            scriptClass: 'mstrmojo.android.inputControls.CheckBoxDIC',
            cssText: 'cursor:pointer;',
            cssDisplay: 'inline-block',

            onText: 'ON',
            offText: 'OFF',

            isSwitchStyle: false,

            // remove 'tabIndex' attribute since an orange background will flash when user click the widget
            markupString: '<div id="{@id}" class="mstrmojo-Label mstrmojo-CheckBoxDIC {@cssClass}" style="{@cssText}" mstrAttach:click,keydown>' +
                    '<div class="checkBox-android-wrapper">' +
                        '<div class="checkBox-android-scrollable">' +
                            '<div class="checkBox-androidMobile-button off"></div>' +
                            '<div class="checkBox-label-text"></div>' +
                        '</div>' +
                    '</div>' +
                '</div>',

            markupSlots: {
                scrollNode: function () { return this.domNode.firstChild.firstChild; },
                textNode: function () { return this.domNode.firstChild.firstChild.lastChild; },
                btnNode: function () { return this.domNode.firstChild.firstChild.firstChild; }
            },

            //override ontextChange function, changing text node from domNode to textNode
            markupMethods: mstrmojo.hash.copy({
                ontextChange: function () { this.textNode.innerHTML = (this.text != null) ? this.text : ''; }
            }, mstrmojo.hash.copy(mstrmojo.CheckBoxDIC.prototype.markupMethods)),

            init: function init(props) {
                this._super && this._super(props);
                if (this.dic.stl == 0) {
                    this.isSwitchStyle = true;
                    var dpi = mstrMobileApp.getDeviceDPI();

                    this.maxOffsetX = SCROLLER_OFFSET_X[dpi];
                    this.scrollerConfig = {
                        showScrollbars: false,
                        showIndicators: false,
                        vScroll: false,
                        hScroll: true,
                        bounces: false,
                        useTranslate3d: false,
                        offset: { x: {end: this.maxOffsetX, start: 0},
                                 scrollPast: false
                        }
                    };
                    this.minHeight = MIN_HEIGHT[dpi] || MIN_HEIGHT_MDPI;
                }
            },

            updateScrollerConfig: function updateScrollerConfig() {
                if (!this.isSwitchStyle) return;
                var cfg = this._super(),
                    originX = this.checked ? 0 : (this.maxOffsetX || 0);
                mstrmojo.hash.copy({
                    scrollEl: this.scrollNode,
                    origin: {
                        x: originX,
                        y: 0
                    }
                }, cfg);
                return cfg;
            },

            updateScroller: function updateScroller(noScrollToOrigin, duration) {
                if (!this.isSwitchStyle) return;
                this._super(noScrollToOrigin, duration);
            },

            initScroller: function initScroller(scroller) {
                if (!this.isSwitchStyle) return;
                this._super(scroller);

                var me = this;
                //Attach an event listener when scroller is moving.
                scroller.attachEventListener('scrollMoved', this.id, function (evt) {
                    this._translateX = evt.x; //cache scroll's translate in x axis
                    toggleBtn.call(me, (evt.x < me.maxOffsetX / 2));
                });
            },

            oncheckedChange: function oncheckedChange(e) {
                if (this.isSwitchStyle) {
                    if (this.checked && this._scroller.origin.x !== 0) {
                        applyTransform.call(this, SWITCH_DURATION, 0);
                    } else if (!this.checked && this._scroller.origin.x !== this.maxOffsetX) {
                        applyTransform.call(this, SWITCH_DURATION, this.maxOffsetX);
                    }
                    toggleBtn.call(this, this.checked);
                }
                this._super && this._super(e);
            },

            preBuildRendering: function preBuildRendering() {
                this.cssClass = this.isSwitchStyle ? 'Android-tristate-mobile' : 'Android-tristate';
                // Default alignment is left.
                var alignment;

                // Is there a text-align value?
                switch (this.owner.getFormats()['text-align']) {
                case 'center':
                    // Text align center.
                    alignment = '50%';
                    break;

                case 'right':
                    // Text align right.
                    alignment = '100%';
                    break;
                }

                // Is there a non-default text align value?
                if (alignment) {
                    // Set background position of check to match.
                    this.cssText += 'background-position:' + alignment + ' 50%;';
                }

                return this._super();
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                if (this.isSwitchStyle) {
                    toggleBtn.call(this, this.checked);
                    //Direct-child's top attribute is calculated according to its height, so if 'ih' is less than 'min-height',
                    //we should set its height to min-height
                    this.domNode.style.height = (this.openerStyle.ih > this.minHeight ? this.openerStyle.ih : this.minHeight) + 'px';
                 }
            },

            touchTap: function touchTap(touch) {
                this.onclick();
            },

            touchBegin: function touchBegin(touch) {
                if (!this.isSwitchStyle) return;
                if (this._isAnimating) {
                    touch.stop();
                    return false;
                }
                return this._super(touch);
            },

            touchSwipeEnd: function(touch) {
                if (!this.isSwitchStyle) return;
                // Mark the event as handled so the touchEnd event used can be ignored by other components
                touch.evt.handle = true;
                var posX = this._translateX,
                    isOn = (posX < this.maxOffsetX / 2),
                    value = isOn ? posX : (this.maxOffsetX - posX),
                    duration = value * SWITCH_DURATION / this.maxOffsetX;
                applyTransform.call(this, duration, isOn ? 0 : this.maxOffsetX);
                this.set('checked', isOn);
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                if (this.isSwitchStyle) {
                    mstrmojo.css.addClass(this.domNode.firstChild || d, 'tx-active');
                } else {
                    this._super(c, d);
                }
            }
        }
    );
}());
(function () { 

    var ROW_AXIS = 1;
    var COL_AXIS = 2;   
    
    var CP_ROW_HEADERS = 4;
    var CP_VALUES = 8;  
    
    /**
     * Returns whether the grid has more data to display.
     * 
     * @param gd The Grid's JSON data
     * @param isDox Whether the grid is within a document.
     */
    function _moreData(gd, isDoc) {
        var rw = gd.rw;
        
        //If the grid data does not have the result window, it does not have any more data. 
        if (!rw) {
            return false;
        }
        
        return isDoc ? (rw.row.bb + rw.row.bc < rw.row.tc) : (rw.wsr + rw.wmr < rw.tr);
    }    
    
    /**
     * <p>A mixin that implements the seamless incremental fetch.
     * 
     * @class
     * @public
     */
    mstrmojo._XtabSeamlessIncrementalFetch = mstrmojo.provide(
            
        "mstrmojo._XtabSeamlessIncrementalFetch",   
        /**
         * @lend mstrmojo._XtabSeamlessIncrementalFetch #
         */
        {
            /**
             * The mixin name.
             */
            _mixinName: 'mstrmojo._XtabSeamlessIncrementalFetch',
            
            /**
             * Allows the consumer to decide whether they want to use seamless incremental fetch.
             */
            useSeamlessIncFetch: true,
            
            preBuildRendering: function preBuildRendering() {
                var rtn = true;
                if (this._super) {
                    rtn = this._super();
                }
                
                if (this.useSeamlessIncFetch) {
                    //setup incremental fetch button
                    this.currentPageNum = 0;
                    this.currentPageNum = this.loadingPageNum = 0;
                    this.endFetching = !_moreData(this.gridData, this.isDocXtab);
                }
            },                
            
            /**
             * Aggregate content providers and re-initialize the zones
             * 
             *  @param cp Content provider
             *  @param rc CP_ROW_HEADERS or CP_VALUES
             *  @param zone The Xtab zone.
             */
            aggregateCP: function aggregateCP(cp, rc, zone) {
                
                var scp = (rc === CP_ROW_HEADERS) ? this.rhsCP : this.valuesCP;
                
                // Is the content provider an aggregated one?
                if (scp.scriptClass !== "mstrmojo.XtabVACP") { // yes, can only be vertical aggregated content provider
                    scp = mstrmojo.hash.clone(scp);
                    var tcp = new mstrmojo.XtabVACP();
                    tcp.cps = [scp, cp];
                    mstrmojo.hash.copy(tcp, (rc === CP_ROW_HEADERS) ? this.rhsCP : this.valuesCP);
                } else {
                    // incremental fetch. We need to wrap the CPs in side a VACP. 
                    scp.cps.push(cp);
                }
                
                // Re-initialize the content providers as we now get new data
                if (zone) {
                    zone.cp.initContent();
                }
            },
            
            onScrolledToLastRow: function onScrolledToLastRow() {
                if (this.useSeamlessIncFetch) {
                    var cp = this.currentPageNum,
                        lp = this.loadingPageNum;
                    
                    // Are we requiring some page that is in fetching?
                    if (lp <= cp && !this.endFetching) { // No, because the loading page number is not bigger than the current one
                        this.loadingPageNum = cp + 1;
                        this.download(1 + cp);            
                    }
                }
            },
            
            /**
             * Downloads new data from service
             * 
             * @param blockNum The block number of the grid data to be downloaded
             */
            download: function download(blockNum) {
                // get the result window.
                var rw = this.gridData.rw,
                    rwRow = rw.row,
                    rwCol = rw.col,
                    maxRows = rwRow.bc;
                
                // The download we are about to trigger will feed multiple areas (row headers and values). So, we mark both of them. That way we will avoid double data fetch. 
                this._isDownloading = this.rhsCP.isDownloading = this.valuesCP.isDownloading = true; 
                
                // if max rows is zero or undefined, nothing to download really. 
                if (maxRows) {
                    var memo = {
                            blockNum: blockNum
                        };
                    
                    // note the start row index is 1 (not 0).
                    this.controller.onDownloadGridData(this, this.model.getDownloadAction(blockNum * maxRows + 1, maxRows, rwCol.bb, rwCol.bc, this.id, memo));
                }
            },            
            
            /**
             * Initializes content providers and generates new HTML content to the bottom zones.
             * 
             * @param {Object} node The new json data node.
             * @param {Object} memo 
             */
            dataDownloaded: function dataDownloaded(node, memo) {
                // Are we decelerating?
                if (this._isDecelerating) {
                    // Cache this download and...
                    this._cachedDownload = {
                        node: node,
                        memo: memo
                    };
                    
                    // wait for scrollDone.
                    return;
                }
                
                // Do we already have a cached download waiting for rendering?
                var cachedDownload = this._cachedDownload;
                if (cachedDownload) {
                    // Was a new node passed in?
                    if (node) {
                        // FAIL: We missed a download.
                        alert('Missed download');
                    }
        
                    // Use cached values.
                    node = cachedDownload.node;
                    memo = cachedDownload.memo;
                    
                    // Clear the download.
                    delete this._cachedDownload;
                }
                
                var gd = node.data, 
                    z = this.zones;
                
                // Cache the firstRowHeight so we only have to measure once.
                this._firstRowHeight = this._firstRowHeight || this.contentNode.rows[0].offsetHeight;
                
                var rhsCP = this.initCP(gd, this.interactiveCellsArray, CP_ROW_HEADERS, gd.ghs.rhs, gd.gts.row, ROW_AXIS),
                    valuesCP = this.initCP(gd, this.interactiveCellsArray, CP_VALUES, gd.gvs);
                
                this.aggregateCP(rhsCP, CP_ROW_HEADERS, z._BL);
                this.aggregateCP(valuesCP, CP_VALUES, z._BR);
        
                // Calculate start and end row values.
                var start = rhsCP.startIndexInContainer,
                    end = start + rhsCP.rc - 1;
                
                var appGrid = function (zone) {
                    if (zone) {
                        // Set the start and end so that the block of new rows will be appended.
                        zone.start = start;
                        zone.end = end;
                        
                        // Append new grid content data instead of replacing whole table.
                        zone.renderGrid(true);                                                
                    }
                };
                
                // We need to put the rest in a timeout because for some reason setting innerHTML fails if the user scrolled out.
                var id = this.id;
                window.setTimeout(function () {
                    var w = mstrmojo.all[id];
                    
                    appGrid(z._BL);
                    appGrid(z._BR);
                    
                    // Do we not have anymore data to fetch?
                    if (!_moreData(gd, w.isDocXtab)) {
                        // Set flag.
                        w.endFetching = true;                    
                    }
        
                    //Tell the scrollers to update their offsets.
                    w.setOffsets();
                    w.currentPageNum++;
        
                    // Clear the downloading flag.
                    w._isDownloading = false;
                }, 0);
            }   
        }
    );
}());
(function () {

    mstrmojo.requiresCls(
        "mstrmojo.dom",
        "mstrmojo.array",
        "mstrmojo.hash",
        "mstrmojo.StickySections",
        "mstrmojo.VisTextTooltip"
    );

    var $D = mstrmojo.dom,
        $H = mstrmojo.hash,
        $A = mstrmojo.array,
        $THEMES = [ 'white', 'black', 'transparent', 'gray'],
        $SELECTED_ROW = "ig-selected-row";

    /**
     * Returns whether the Interactive Grid is displayed as a fullscreen widget. As of now, IG on a layout and reports set up
     * as IG are displayed full screen.
     */
    function isIGFullscreen() {
        return (this.isFullScreenWidget || !this.isDocXtab);
    }


    /**
     * Helper function to clean up the metrics that could've been unorganized due to potential metric selectors.
     */
    function cleanUpMXVP() {
        var gd = this.gridData,
            chs = gd.ghs.chs;

        // If the interactive grid does not have any metrics on it's template, there's nothing to clean-up.
        if (chs.items && chs.items.length) {
            var mx = gd.ghs.chs.items[0].items,
                vp = gd.vp,
                cols = vp.cols,
                cg = cols.cg,
                cws = cols.cws,
                cgc = cg.cgc,
                i, j,
                hasMx = false,
                remove = [];

            for (i = 0; i < cgc; i++) {
                var col = cg[i],
                    mxCount = -1;

                $H.forEach(col, function (v, k) {
                    if (/[mMiIxX]([0-9])+$/.test(k)) {
                        for (j = 0; j < mx.length; j++) {
                            if (mx[j].mix == v) {
                                col[k] = j;
                                mxCount++;
                                break;
                            }
                        }
                        if (mx[col[k]] === undefined || j === mx.length) {
                            delete col[k];
                            return;
                        }
                        hasMx = true;
                    }
                });

                if (hasMx) {
                    var lastEmpty = [];
                    for (j = 0; j < col.cl; j++) {
                        if (col['mix' + j] === undefined) {
                            lastEmpty.push(j);
                        } else if (lastEmpty.length > 0) {
                            col['mix' + lastEmpty.splice(0, 1)] = col['mix' + j];
                            delete col['mix' + j];
                        }
                    }
                    col.cl = ++mxCount;

                    // Remember the empty columns to be deleted later.
                    if (col.cl === 0) {
                        remove.push(i);
                    }
                } else if (!col.attForms) {
                    // Empty col due to metric selector.
                    remove.push(i);
                }

                hasMx = false;
            }

            for (i = remove.length - 1; i >= 0; i--) {
                // Delete the column in question
                delete cg[remove[i]];

                // Adjust all subsequent columns to adjust for the deleted column.
                for (j = remove[i]; j < cgc; j++) {
                    cg[j] = cg[j + 1];
                }

                // Delete the last column.
                delete cg[j-1];

                // Adjust the column count and the widths.
                cws.splice(remove[i], 1);
                cg.cgc--;
            }
        }
    }


    /**
     * If the Interactive Grid does not have default properties set on it, we need to create default properties. By default, we'll
     * always have two columns. One for the attributes and one for the metrics.
     */
    function setupDefaultProps() {
        var DAF_DELIMITER = ":",
            gd = this.gridData,
            gts = gd.gts,
            chs = gd.ghs.chs,
            row = gts.row,
            firstTitle = row[0],
            hasMetrics = gts.col && gts.col.length > 0,
            vp = {
                // Banding property - Defaults to false
                bn: "0",

                // Grouping property - Defaults to false*
                gr: "0",

                // Automatic Column Resiging - Defaults to true
                ar: "1",

                // Color Theme - Defaults to Black
                ct: "1",

                // Default Attribute form in the form of [title id + ":" + title form id] - Defaults to the first title.
                daf: firstTitle.id + DAF_DELIMITER + firstTitle.fid,

                // The columns property which refers to how the columns on the Interactive Grid are grouped.
                cols: {
                    //Default column widths
                    cws: [ { w: "100"} ],
                    cg: { cgc: 1 }
                }
            },
            gdAxis = ['row'],
            gdES = [gts.row],
            idx,
            len;

        //if IG contains metrics, reset the gdAxis, gdES, and vp.cols
        if(hasMetrics) {
            //add second columns for metrics
            gdAxis = ['row', 'col'];
            gdES = [gts.row, chs.items[0].items];

            //two columns, each take 50% of the width
            vp.cols = {
                cws: [ { w: "50" }, { w: "50" } ],
                cg: { cgc: 2 }
            }
        }
        cg = vp.cols.cg;

        //loop through column group count, can be 1 or 2, to set up default vp.cols.cg property
        for(idx = 0, len = cg.cgc; idx < len; idx++) {
            var axis = gdAxis[idx],
                i;

            //Set the default column properties.
            cg[idx] = {
                //Is the column toggleable? Defaults to true.
                tg: true,

                //Set the number of elements would we have in the column?
                cl: gdES[idx].length,

                //The current column shown in the interactive grid.
                cc: 0,

                //Default show headers to true.
                sh: true
            };

            //For metrics we need to provide the metrics index.
            if (axis === 'col') {
                for (i = 0; i < gdES[idx].length; i++) {
                    cg[idx]['mix' + i] = gdES[idx][i].mix;
                }
            } else {
                cg[idx].attForms = [];
                for (i = 0; i < gdES[idx].length; i++) {
                    cg[idx].attForms[i] = {idx: i, n: ''};
                }
            }
        }

        //Set the column groups
        this.gridData.vp = vp;
    }

    /**
     * Returns the table rows that belongs to the same stacked row
     */
    function findStackedCells(tr, trs) {
        var c, i, iLen, cn,
            //using directions to get the tr siblings to find the stacked row css
            findTR = function (direction, row, collection) {
                var j, jLen, r = row[direction + 'Sibling'], cell;
                if (r) {
                    for (j = 0, jLen = r.cells.length; j < jLen; j++) {
                        cell = r.cells[j];
                        if ((direction === 'next' && /stack-bottom/.test(cell.className)) || (direction === 'previous' && /stack-top/.test(cell.className))) {
                            collection.push(r);
                            return;
                        }
                    }

                    collection.push(r);
                    findTR(direction, r, collection);
                }
            };

        //always save the starting tr into the array
        trs.push(tr);
        for (i = 0, iLen = tr.cells.length; i < iLen; i++) {
            c = tr.cells[i];
            cn = c.className;
            //if we have stack css
            if (/stack/.test(cn)) {
                //if the td cell has stack-top css, search next sibling until hits next stack-top
                if (/stack-top/.test(cn)) {
                    findTR('next', tr, trs);
                    break;
                //if the td cell has stack-bottom css, search previous sibling until hits next stack-bottom
                } else if (/stack-bottom/.test(cn)) {
                    findTR('previous', tr, trs);
                    break;
                //if stack-middle, search both directions.
                } else if (/stack-middle/.test(cn)) {
                    findTR('next', tr, trs);
                    findTR('previous', tr, trs);
                    break;
                }
            }
        }

        return trs;
    }

    function addSelection(rows) {
        $A.forEach(rows, function (row) {
            //Add a selected CSS class to the row.
            mstrmojo.css.addClass(row, $SELECTED_ROW);
        });
    }

    function removeSelection() {
        //Remove the selection from the other cells after a 100ms
        var rows = $H.copy(document.getElementsByClassName($SELECTED_ROW));

        $A.forEach(rows, function (row) {
            mstrmojo.css.removeClass(row, $SELECTED_ROW);
        });
    }



    /**
     * Helper method to perform action on the interactive grid
     *
     * @param target The HTML node being targeted by the user
     *
     * @return Boolean Whether or not we've handled the action.
     */
    function handleAction(target) {
        // Find the cell that was clicked on
        var td = $D.findAncestorByAttr(target, 'ei', true, this.domNode),
            node = td && td.node,
            cell = this.getCellForNode(node);

        //Is it a grouping section? Then we should ignore it. Return true so we don't process it anymore.
        if (node && node.className.indexOf('iggroup') > 0) {
            return true;
        }

        //Is this is an Interactive Grid? Then check if the user wants to toggle
        if (this.isInteractiveGrid() && this.igToggle(cell)) {
            //If yes, then the user clicked on a toggle-able cell.
            return true;
            //If not, we want to continue what we were doing ...
        }

        // another solution for 516528 Zhang Hongchao 2013-06-04
        // check current cell whether it has some action...
        // If yes, hilight current row and do action; if no, do nothing.
        if (!cell) {
        	return true;
        }

        //Show the selected animation for cell within the data part of the interactive grid.
        if ($D.contains(this._BR, target)) {
            //Remove and lingering selections.
            removeSelection();

            var row = $D.findAncestorByName(target, 'tr', true);
            // Make sure the <tr> is also in the grid
            if ($D.contains(this._BR, row)) {
                //Select the corresponding IG row.
                addSelection(findStackedCells(row, []));
            }
        }

        return false;
    }

    /**
     * This mixin adds as an add-on to mstrmojo.MobileXtab where it converts the regular looking Xtab to an interactive grid.
     * It cannot be used by itself and has to be mixed in to any mobile flavor of Xtab.
     *
     * @class
     * @public
     */
    mstrmojo._IsInteractiveGrid = mstrmojo.provide(
        "mstrmojo._IsInteractiveGrid",
        /**
         * @lends mstrmojo._IsInteractiveGrid
         */
        {
            _mixinName: 'mstrmojo._IsInteractiveGrid',

            /**
             * Custom Class for Interactive Grid.
             */
            cssClass: 'mstrmojo-InteractiveGrid',

            /**
             * Should not show magnifier on interactive grid.
             */
            enableMagnifier: false,

            /**
             * Overwrite the scrollerConfig property to ensure we can't scrollPast.
             */
            scrollerConfig: {
                scrollPast: false
            },

            /**
             * This method denotes whether the current grid has has an Interactive Grid visualization
             * set on it.
             *
             *  @return boolean If it is an interactive grid.
             */
            isInteractiveGrid: function () {
                return (this.gridData.vp && this.gridData.vp.cols) ? true : false; // TODO: we should check for the actual vis name as cols can be empty
            },

            preBuildRendering: function preBuildRendering() {
                //if the grid is empty grid, skip the interactive grid configurations.
                if (this.gridData.eg) {
                    return this._super();
                }

                //If we do not have the interactive grid's viz properties, we need to setup default properties that create a default structure.
                if (!this.isInteractiveGrid()) {
                    setupDefaultProps.call(this);
                }

                // Some cases with metric selectors in the document might cause invalid column info.
                cleanUpMXVP.call(this);

                var me = this,
                    parent = this.parent,
                    setProp = function (propName) {
                        me[propName] = me[propName] || ((parent && parent[propName]) ? parent[propName] : 480);
                    };

                //Set the correct height and width...
                setProp('height');
                setProp('width');

                //Reflect on the Color theme set on the Interactive Grid
                var theme = isNaN(this.gridData.vp.ct) ? 1 : parseInt(this.gridData.vp.ct, 10);

                //Update the cssClass to address the interactive grid's theme.
                this.cssClass = "mstrmojo-InteractiveGrid " + $THEMES[theme];

                //Set the overflow
                this.scrollboxNodeOverflow = 'overflow:hidden;';

                var returnVal = (this._super ? this._super() : true);

                this.cssDefault = (this.cssDefault === "") ? "r-cssDefault" : "";

                return returnVal;
            },

            /**
             * Returns the Xtab's view key if the Interactive Grid visualization is set at the layout level.
             *
             * @returns the Xtab's key.
             */
            getKey: function getKey() {
                return this.gridData.k;
            },

            /**
             * Extends (mstrmojo.Container)
             *
             * This method calculates the column widths for Interactive Grids before calling the Container's render children
             * and then creates a new sticky section widget if the Interactive Grid has grouping sections.
             */
            renderChildren: function renderChildren() {
                //Calculate the column widths based on the widget width...
                this.prepareCWSCalculation();

                //Render children...
                if (this._super) {
                    this._super();
                }

                //Creates sticky sections if we have grouping rows...
                this.createStickySections();

                //TQMS: height selected rows
                var BR = this.zones._BR,
                    hilitedCells = BR.hiliteCellsMap,
                    rows = {}, trs = [];
                //find all the hilited cells, and unhilit them, remember the row index
                $H.forEach(hilitedCells, function(cell, key){
                    $A.forEach(cell.pos, function(ro) {
                        BR.clearHilites(key);
                        rows[ro.row] = ro.row;
                    });
                });
                //if there is any rows should be hilighted
                if(!$H.isEmpty(rows)) {
                    //go through it and and the dom nodes
                    $H.forEach(rows, function(v){
                        trs.push(BR.domNode.firstChild.rows[v]);
                    });
                    //find the hilite rows, and hilite them
                    addSelection(findStackedCells(trs[0], []));
                }
            },

            /**
             * Extends MobileXtab method to enable use dom to calculate offsets when grouping is enabled.
             */
            useDomToCalculateOffsets: function useDomToCalculateOffsets() {
                var cp = this.zones._BR.cp;
                if (cp && (cp.groupEnabled || cp.stackLevels > 1)) {
                    return true;
                } else {
                    return (this._super || this._super()) || false;
                }
            },

            /**
             * The method set the gridWidth property on the zones' content providers
             */
            prepareCWSCalculation: function prepareCWSCalculation() {
                var fmts = this.getFormats && this.getFormats(),
                    //For interactive grid visualization set at the template level in documents, we want to retreive the width from the formats.
                    width = (!isIGFullscreen.call(this)) ? parseInt(fmts.width, 10) : parseInt(this.width, 10);

                //Set the column width to the adjusted column width.
                this.zones._BR.cp.gridWidth = width;
                this.zones._TR.cp.gridWidth = width;
            },

            /**
             * This method creates a new sticky section widget (mstrmojo.StickySections) on the Interactive Grid's TopRight zone only if it has grouping sections
             * That is if there are more than 2 attributes in the row headers.
             */
            createStickySections: function createStickySections() {
                var gd = this.gridData,
                    fmts = this.getFormats && this.getFormats();

                //Do we have grouping sections?
                if (this.isInteractiveGrid() && (gd.vp.gr === '1' && gd.gts.cws.length > 1)) {
                    //Dynamically add the file.
                    mstrmojo.requiresCls("mstrmojo.StickySections");

                    //Yes, then we need a new child which will provide the sticky sections functionality..
                    var node = this._TR,
                        slotName = 'stickySections';

                    //Add a slot for out new widget..
                    this.addSlots({ stickySections: node });

                    //Have we not already created the widget?
                    if (!this.ss) {
                        var cell = this.zones._BR.cp.getResolvedGroupHeader(0, 0),
                            cssClass = "iggroup xtab-td",
                            DPICONVERSION = {
                                    320: -52
                                },
                            marginBottom = DPICONVERSION[mstrMobileApp.getDeviceDPI()] || -33,
                            //marginBottom = -22,
                            //For interactive grid visualization set at the template level in documents, we want to retreive the width from the formats.
                            width = (!isIGFullscreen.call(this)) ? (parseInt(fmts.width, 10) + 'px') : '100%',
                            cssText = "width: " + width + ";z-index: 2; position: relative;margin-bottom:" + marginBottom + "px;";

                        //Create a new sticky section widget...
                        this.ss = new mstrmojo.StickySections({
                            currentSectionTitle: cell.n || cell.v,
                            cssClass: cssClass,
                            slot: slotName,
                            cssText: cssText
                        });

                        this.addChildren(this.ss);
                    }
                }
            },

            /**
             * Overrides the performAction method. See (mstrmojo.MobileXtab)
             *
             * It lets the grid toggle through it's column headers in addition to what the
             * MobileXtab allows.
             *
             * @return boolean True if it performed the toggle action, false if it did not and wants the
             * child to handle the default action.
             */
            performAction: function performAction(touch) {
                //Handle the action.
                return handleAction.call(this, touch && touch.target) || (this._super && this._super(touch));
            },

            /**
             * This method performs the toggle action for Interactive Grids. It performs the action
             * only on coloumn headers which are metrics (and if they can be toggle-able). It takes
             * in a cell parameter which is a Javascript Object that represents the cell being clicked.
             *
             * @param {Object} cell An Object represenation of the clicked cell.
             *
             * @return boolean True if it performed the toggle action, false if it did not and wants the
             * child to handle the default action.
             */
            igToggle: function igToggle(cell) {
                //Is it an interactive grid?
                if (!this.isInteractiveGrid() || !cell) {
                    return false;
                }

                var e = cell && cell._e,
                    otp = (cell && cell.otp) || (e && e.otp);

                if (otp) {
                    var i,
                        j,
                        cols = this.gridData.vp.cols,
                        cg = cols.cg,
                        mix = cell.mix,
                        OBJECT_TYPE_METRIC = 4,
                        OBJECT_TYPE_ATTR = 12,

                        /**
                         * This function grabs the collection of columns associated with a single column group and adjusts the column widths
                         * accordingly in order to simulate a toggle effect.
                         */
                        adjCol = function (currentCol, colPos) {
                            var _return = false;

                            //Do we have toggle enabled on the column? We want to goggle only if the clicked column group has more than one column
                            if (currentCol.tg && currentCol.cl > 1) {
                                var cc = currentCol.cc,
                                    cur = currentCol.cc,
                                    start = 0,
                                    end = currentCol.cl,
                                    diff = currentCol.cc = (++cur >= (end + start)) ? start : cur,
                                    colgroup = [this._TR.getElementsByTagName('COLGROUP')[0], this._BR.getElementsByTagName('COLGROUP')[0]];

                                //Loop through colgroup tag nodes in the TopRight and BottomRight zones
                                $A.forEach(colgroup, function (c) {
                                    var wPx = c.childNodes[colPos + cc].style.width;

                                    c.childNodes[colPos + cc].style.width = '0';
                                    c.childNodes[colPos + diff].style.width = wPx;
                                });

                                _return = true;
                            }

                            return _return;
                        },
                        currentCol,
                        attFm,
                        count = 0,
                        returnVal = false;

                    if (cell && cell.otp === OBJECT_TYPE_ATTR) {
                        for (i = 0; i < cg.cgc; i++) {
                            currentCol = cg[i];
                            attFm = currentCol.attForms;

                            //Find the proper column group where the cell belongs to.
                            if (attFm) {
                                for (j = 0; j < currentCol.cl; j++) {
                                    if (attFm[j] && (attFm[j].idx === (cell.ci || cell.ui))) {
                                        // Update the return value based on whether we adjusted the columns;
                                        returnVal = adjCol.call(this, currentCol, count);
                                    }
                                }
                            }

                            //Update the col position.
                            count += currentCol.tg ? currentCol.cl : 1;
                        }

                    //Are we clicking a metric header?
                    } else if (e && e.otp === OBJECT_TYPE_METRIC) {
                        for (i = 0; i < cg.cgc; i++) {
                            currentCol = cg[i];

                            //Is the clicked cell part of the column's current cell.
                            if (currentCol['mix' + currentCol.cc] === mix) {
                                //Update the return value based on whether we adjusted the columns;
                                returnVal = adjCol.call(this, currentCol, count);
                            }

                            //Update the col position.
                            count += currentCol.tg ? currentCol.cl : 1;
                        }
                    }

                    return returnVal;
                }

                //If we didn't click on a metric header, let the normal code flow continue.
                return false;
            },

            /**
             * Extends (mstrmojo.XtabBase)
             *
             * @return (mstrmojo.InteractiveGridHACP) Returns a new Horizontally aggregated InteractiveGrid content provider.
             */
            getHACP: function getHACP() {
                //Create the right HACP. The condition check is just a safety measure - this mixin should/will only be mixed in for interactive grids.
                var hacp = (this.isInteractiveGrid()) ? new mstrmojo.InteractiveGridHACP() : this._super();

                //Set the on demand incremental fetch flag on the interactive grid hacp.
                hacp.onDemandIF = !!(this.onDemandIF && this.gridData.rw);

                return hacp;
            },

            /**
             * Callback wwhen the IG's height changes. We need to adjust the scrollbox correctly.
             */
            onheightChange: function onheightChange() {
                if (isIGFullscreen.call(this) && this.scrollboxNode) {
                    // Since IG is always fullscreen mode, set the height of the scrollbox node to be total - TR's height (headers).
                    this.scrollboxNode.style.height = (parseInt(this.height, 10) - this._TR.clientHeight) + 'px';
                }

                // Call super to adjust offsets.
                if (this._super) {
                    this._super();
                }
            },

            /**
             * Callback when the viewport's dimensions change. Whenever the viewport changes dimension, we need to unrender and rerender
             * the grid so we can fit it correctly.
             */
            onwidthChange: function onwidthChange() {
                if (isIGFullscreen.call(this)) {
                    // Cache the old width;
                    var w = this.width;

                    //Check if the Interactive Grid has rendered.
                    if (this.hasRendered) {
                        // If this interactive grid is rendered in the full screen mode, we need to re-render it to fit contents.
                        this.unrender();

                        //On unrender, the width properties get unset, we need to update the width
                        this.width = w;

                        // Render the grid
                        this.render();
                    }

                } else if (this._super) {
                    this._super();
                }
            },

            /**
             * @see mstrmojo.XtabBase
             */
            defaultAction: function defaultAction(td, tCell) {
                var _returnVal = false;

                if (this._super) {
                    _returnVal = this._super(td, tCell);
                }

                // Since we're handling the selections for the interactive grid, we don't want the doc xtab to highlight cells.
                this.model.sti = null;

                return _returnVal;
            },

            /**
             * FOR DEBUGGING PURPOSES ONLY!
             */
            onclick: function onclick(evt) {
                // Are we in the hosted environment?
                if (!mstrApp.isTouchApp()) {
                    var e = evt.e;

                    // Handle the action.
                    return handleAction.call(this, $D.findAncestorByName(e.target, 'td', true)) || (this._super && this._super(evt));
                }
            },



            touchSelectBegin: function touchSelectBegin(touch) {
                var tch = touch;

                var touchTd = mstrmojo.dom.findAncestorByName(touch.target, 'td', true, this.domNode);
                var hasImg = this.hasImgTag(touchTd);
                var touchArea = mstrmojo.dom.findAncestorByAttr(touch.target, 'trType', true, this.domNode);
                if (touchTd && touchArea && !hasImg) {
                	var textWidth = this.getTextWidth(touchTd, touchTd.className);
                    if (textWidth > touchTd.offsetWidth - 30) {
                    	// as the touchTd has paddingLeft=15px and paddingRight=15px, so we use touchTd.offsetWidth - 30
                   	 // The reason that we can use offsetWidth here is that: there is no border for the td cell
                    	if (!this.visTextTooltip) {
                    		var ph = document.createElement('div');
                    		this.domNode.appendChild(ph);
                        	this.visTextTooltip = new mstrmojo.VisTextTooltip({placeholder: ph, targetDiv: touchTd, boundary: this.domNode, touchAreaType: touchArea.value});
                            this.visTextTooltip.render();
                            this.visTextTooltip.updateContent(touchTd, touchArea.value, touchTd.innerText);
                        } else {
                        	this.visTextTooltip.targetDiv = touchTd;
                        	this.visTextTooltip.touchAreaType = touchArea.value;
                        	this.visTextTooltip.updateContent(touchTd, touchArea.value, touchTd.innerText);
                        }
                    }
                }

            },

            touchSelectEnd: function touchSelectEnd(touch) {
            	var tch = touch;

            	if (this.visTextTooltip && this.visTextTooltip.domNode) {
            		this.visTextTooltip.toggle(false);
            	}

            },

            // check if the given touchTd has img tag in it
            // specific use for IG image threshold
            hasImgTag: function hIT(touchTd) {
            	var child = touchTd && touchTd.childNodes.length>0 && touchTd.childNodes[0];
            	if (child && child.nodeName.toLowerCase() === 'div') {
            		var grandChild = child.childNodes.length>0 && child.childNodes[0];
            		if (grandChild && grandChild.nodeName.toLowerCase() === 'div') {
            			var img = grandChild.childNodes.length>1 && grandChild.childNodes[1];
            			if (img && img.nodeName.toLowerCase() === 'img') {
            				return true;
            			}
            		}
            	}

            	return false;

            },

            getTextWidth : function gtw(dom, className, fontName, fontSize, fontSizeUnit, bold) {
            	var childNodes = dom.childNodes;
            	var table = null,
            		selfTextDom = null;
            	if (childNodes.length>0 && childNodes[0].nodeName.toLowerCase() === '#text') {
            		table = document.createElement('table');
            		selfTextDom = document.createElement('td');
            		table.appendChild(selfTextDom);
            	} else if (childNodes.length>0 && childNodes[0].nodeName.toLowerCase() === 'span') {
            		selfTextDom = document.createElement('span');
    				selfTextDom.style = "z-index:-10;visibility:hidden;-webkit-text-size-adjust: none;";
            	} else {
            		return -1;
            	}

				if(selfTextDom.className !== className || "")
					selfTextDom.className = className || "";
				if(selfTextDom.style.fontFamily !== fontName || "")
					selfTextDom.style.fontFamily = fontName || "" ;

				var fsUnit = fontSizeUnit || "pt"

				if(fontSize){
					selfTextDom.style.fontSize = fontSize + fsUnit;
				}else{
					selfTextDom.style.fontSize = '';
				}

				if(bold){
					if(selfTextDom.style.fontWeight !== 'bold')
						selfTextDom.style.fontWeight = 'bold';
				}else{
					if(selfTextDom.style.fontWeight!=='')
						selfTextDom.style.fontWeight = '';
				}

				selfTextDom.innerHTML = dom.innerText;

				var ret = -1;
				if (table) {
					this.domNode.appendChild(table);
					ret = selfTextDom.offsetWidth - 30; // paddingLeft=15px, paddingRight=15px
					this.domNode.removeChild(table);
				} else {
					this.domNode.appendChild(selfTextDom);
					//selfTextDom.style.display = 'inline';
					ret = selfTextDom.offsetWidth;
					this.domNode.removeChild(selfTextDom);
				}


				return ret;
			},

            /**
             * Override the unrender method.
             *
             * @see mstrmojo._HasMarkup
             */
            unrender: function unrender(ignoreDom) {
            	// delete visTextTooltip if unrender
            	if (this.visTextTooltip && this.visTextTooltip.destroy) {
               		this.visTextTooltip.destroy();
               		delete this.visTextTooltip;
               	}

                var stickySection = this.ss;

                //Have we created sticky sections for this interactive grid, then destroy it.
                if (stickySection) {
                    // Remove the sticky section child silently.
                    this.removeChildren(stickySection, true);

                    // Then destroy the widget and remove any references to it.
                    stickySection.destroy();
                    delete this.ss;
                }

                //Call super.
                this._super(ignoreDom);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Button",
                         "mstrmojo.XtabZone",
                         "mstrmojo.DICFactory",
                         "mstrmojo.DynamicClassFactory");

    /**
     * DataInput Type:
     * 1. Textbox
     * 2. Switch
     * 3. List
     * 4. Slider
     * 5. Calendar
     * 6. TimePicker
     */
    var MARKROW = 102,
//        TEXTAREA = 8,
        ROW_HEADER_MERGED = 1,
//        TX_DEFAULT = 1, //transaction type: EnumDSSXMLRWNodeTransactionChangeType.DssXmlRWNodeTransactionChangeTypeDefault
        TX_MARK = 2, //transaction type: EnumDSSXMLRWNodeTransactionChangeType.DssXmlRWNodeTransactionChangeTypeMark
//        EDIT = 32,
        $C = mstrmojo.css,
        $D = mstrmojo.dom,
        $H = mstrmojo.hash,
        $CFC = mstrmojo.DynamicClassFactory.newComponent,
        CP_TITLE = 1,
        CP_COL_HEADERS = 2,
        CP_ROW_HEADERS = 4,
        COL_AXIS = 2,
        TX_ELEM_ATT_FORM = 1,
        TX_ELEM_METRIC = 2,
        MARK_ROW = 1, //manipulation type for mark row
        CHANGE_DATA = 2, //manipulation type for grid cell change
        MR_MANIPULATION_UNSET = 1,
        MR_MANIPULATION_SELECT = 2,
        DATA_DRIVEN_CONTROL = 2,
        XTAB = 1,
        getGroupIdx = function (cell) {
            if (cell) {
                return cell.tui >= 0 ? ('h_' + cell.tui + '_' + cell.fi + '_' + cell.axis) : ('m_' + cell.mix);
            }
            return '';
        };

//    //converting em, pt, etc. style value into px
//    var convert2Px = function (dom, v) {
//        if ($D.isIE && !/px$/.test(v)) {
//            var img = document.createElement('img');
//            img.style.zIndex = -1;
//            img.style.left = v;
//
//            dom.appendChild(img);
//
//            //get the pixel value
//            var pl = img.style.pixelLeft;
//            dom.removeChild(img);
//
//            return pl;
//        }
//        return parseInt(v, 10);
//    };

    /**
     * Apply changes to the target cell
     * @param {Object} c Cell object including the values
     * @param {Integer} k The index of expected the node map
     * @param {Object} vo The new value object
     * @returns {Object} the DOMNode object of the target cell
     */
    function applyChange(c, k, vo) {
        var t = this.nm[k],
            v = vo.v,
            dv = vo.dv;

        c.rv = v;
        c.v = dv;
        c.mdf = 1;
        //if the cell has the reference to the unmerged cell, that means the cell is a copy of unmerged cell
        //we set the new value to the original unmerged cell so that when it is unmerged again, we can see the changes.
        if (c._src) {
            c._src.rv = v;
            c._src.v = dv;
            c._src.mdf = 1;
        }

        // retrieve the related input control widget attached with this grid cell
        var dicWidget = this.dicGroupMap[getGroupIdx(c)].widgetsMap[c._ei];

        // Update the cell content only if it's a popup dic without preview.
        if (!dicWidget.showByDefault) {
            if (dicWidget.hasPreview) {
                dicWidget.renderPreview();
            } else {
                //TQMS 529617: In IE7, if the applied value is empty, the grid cell will lose its border.
                if ($D.isIE7 && mstrmojo.string.isEmpty(v)) {
                    v = ' ';
                }
                t[t.innerText !== undefined ? 'innerText' : 'textContent'] = v;
            }
        }
        return t;
    }

    /**
     * Check whether the row is on the total row or not. Return true if it is on total row.
     */
    function onTotalRow(cp, o, rs) {
        if (rs[o] === 0) {
            return true;
        }

        if (cp && rs[o] === undefined) {
            try {
                var cells = cp.getRowCells(o),
                    c = cells && cells[0];
                if (c && c.o === o) {
                    if (c.sst) {
                        rs[o] = 0;
                    }
                    return !!c.stt;
                }

                if (c && c.o) {
                    return onTotalRow(cp, o + o - c.o, rs);
                }

                return false;
            } catch (ex) {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * Update selected rows
     * @param {Array} marked An array object contains a list of object describing which row is marked
     * @returns {Object} A map object contains the row ordinal as the name, and 1 as the value
     */
    function updateSelectedRows(marked, rs) {
        mstrmojo.array.forEach(marked, function (m) {
            rs[m.o] = 1;
        });
    }

    /**
     * Clear the merged header marker map
     */
    function clearMergedHeaderMarks(gd) {
        if (gd.mgh && (gd.mgh & ROW_HEADER_MERGED)) {
            this.mghMarks = {};
        }
    }
    
    /**
     * Clear existing mark row selections in the range of a block
     * @param {Object} selections existing mark row selections
     * @param {Object} block block information containing the block begin position, rows of each block and total count
     */
    function clearSelectedRowsForBlock(selections, block) {
          var begin = block.bb - 1, // row position in block starts with 1, not 0
              end = Math.min(begin + block.bc, block.tc),
              row;
          $H.forEach(selections, function(v, idx) {
              row = Number(idx);
              if (row !== NaN && row >= begin && row < end) {
                  delete selections[idx];
              }
          });
    }

    /**
     * Mark the dirty row for a dirty cell.
     *
     * rowIdx param is optional.
     */
    function markDirtyRows(c, rowIdx) {
        var rs = this.editing ? 1 : (c.rs || 1),
            i;

        for (i = 0; i < rs; i++) {
            this.dirtyRows[rowIdx + i] = 1;
        }
    }

    /**
     * Is it a data driven DIC?
     */
    function isDataDrivenDIC(di) {
    	return di && parseInt(di.ipt, 10) === DATA_DRIVEN_CONTROL; 
    }

    
    /**
     * Returns the row index from the cell
     * @param cell {HTMLElement} the interactive cell
     * @returns row index
     */
    function getRowIndex(cell) {
        var _BR = this.zones._BR,
            _BL = this.zones._BL;
        
        // If we don't have BL zone, always use BR zone to find the row index
        if(!_BL) {
            return _BR.getRowIdxByCell(cell);
        } else {
            // check the _BR first to see whether the cell is inside that zone.
            if(_BR.posMap && _BR.posMap[cell._ei]) {
                return _BR.getRowIdxByCell(cell);
            // otherwise, check the BL zone
            } else {
                return _BL.getRowIdxByCell(cell);
            }
        }
    }    
    
    mstrmojo._IsEditableGridCP = {

        _mixinName: "mstrmojo._IsEditableGridCP",

        /**
         * @param {Integer} startIndexInContainer
         */
        initContent: function initContent(startIndexInContainer) {
            this._super(startIndexInContainer);

            //if the grid is Interactive Grid, we need to change the 'vp' property to reflecting the newly added column
            //So we must change:
            //1. for each attribute forms, change the idx to increase value 1 because the index is the column index used to find the attribute
            //2. insert a new column group property into the vp.cols.cg; As the cg is an object, we need to shift the existing items to the next slot by copying and replacing
            //3. insert a column width property to the vp.cols.cws; The default width for the checkbox is set to be 60px.
            var gd = this.gridData,
                vp = gd && gd.vp,
                i,
                j,
                fm,
                size,
                cg,
                cl,
                cws,
                rt;
            if (((this.type === CP_TITLE) || (this.type === CP_ROW_HEADERS)) && vp && vp.cols && !vp._adjusted) {
                cg = vp.cols.cg;
                cws = vp.cols.cws;
                //for column group property
                if (cg && cg.cgc > 0) {
                    for (i = cg.cgc; i > 0; i--) {

                        cg[i] = $H.copy(cg[i - 1], {});
                        cl = cg[i];
                        var fms = cl.attForms;
                        if (fms) {
                            for (j = 0, size = fms.length; j < size; j++) {
                                fm = fms[j];
                                //increase index by one because we insert a new column
                                fm.idx += 1;
                            }
                        }
                    }
                    //new column group property
                    cg[0] = {tg: false, cc: 0, cl: 1, attForms: [{n: '', idx: 0}]};
                    //increase the column group count by one
                    cg.cgc += 1;
                }
                //add the column width for the new column
                if (cws) {
                    cws.splice(0, 0, {w: '60px', xc: true});
                }
                //increase default form action index by one
                if (vp.dafIdx !== undefined) {
                    vp.dafIdx += 1;
                }

                rt = gd.gts.row;
                for (i = 0, size = rt.length; i < size; i++) {
                    rt[i].ci = i + 1; //set column index
                }

                //only adjust once
                vp._adjusted = true;
            }

            //extra column
            this.colWidths = [{w: ''}].concat(this.colWidths);
            this.unmergedCells = [];
        },

        getUnmergedCells: function getUnmergedCells() {
            return null;
        },

        /**
         * @param {Integer} ri
         */
        getRowCells: function getRowCells(ri) {
            var cells = this._super(ri),
                cell = cells[0], // start inspecting the first cell
                o = (cell && cell.o) || 0,
                isTtl = (this.tp === CP_TITLE),
                ics = this.interactiveCellsArray,
                fc = {
                    css: '',
                    v: ''
                },
                umc = [],
                ncs = [],
                i,
                len;

            if (!isTtl) {
                var rows = this.base.items,
                    lb = this.lookupBase,
                    cssBase = this.gridData.css,
                    pi = cell && cell.pi, // get the parent index node
                    r = pi && pi.ri, // row number for the parent node
                    c = pi && pi.ci, // column number for the parent node
                    otr = cell.stt > 0;
                while (pi && r > -1 && c > -1) { //has left parent
                    cell = cell._p || rows[r].items[c];
                    //create a copy of unmerged cell
                    var _c = $H.copy(cell, {});
                    //save the reference of the unmerged cell
                    _c._src = cell;
                    if (!_c.css) {
                        _c.css = cssBase[_c.cni].n;
                    }

                    var unit = lb[cell.tui],
                        e = unit && unit.es[cell.idx];
                    if (e) {
                        _c.v = cell.v || e.n; //we need to first check cell.v because the cell's v value has higher priority than the name of the look up element
                        // if we found the element object for the cell, attach it to the cell too. This will be useful during actions (looking up element ID) - especially for cases where there are multiple grid data blocks.
                        _c._e = e;
                    }
                    _c.rs = 1;
                    if (otr) {
                        _c.at &= ~32;
                    }
                    if (o > -1) {
                        _c.o = o;
                    }
                    if (!_c.axis && this.axis) {
                        _c.axis = this.axis;
                    }
                    _c._ei = ics.push(_c) - 1;
                    umc.splice(0, 0, _c);

                    // find the next parent
                    pi = cell && cell.pi;
                    r = pi && pi.ri;
                    c = pi && pi.ci;
                }

                for (i = 0, len = cells.length; i < len; i++) {
                    var nc = cells[i];
                    if (nc.rs > 1) {
                        var tc = $H.copy(nc, {});
                        tc.rs = 1;
                        nc = tc;
                    }
                    ncs.push(nc);
                }

            } else {
                ncs = cells;
                if (ri > 0) {
                    return cells;
                }
            }

            if (ncs[0]) {
                fc = $H.copy(ncs[0], {});
                fc.rv = fc.v = '';
                if (this.tp === CP_TITLE) {
                    fc.n = fc.v = '';
                    fc.markAll = true;
//                    fc._ei = -1;
                } else {
                    fc.n = '';
                }
                fc._ei = ics.push(fc) - 1;
                fc.at = 32;
                fc.cs = 1;
                fc.mark = true; // row mark flag
                fc.mix = 'x';
                //TQMS 608226: The cell format of mark row checkbox is inherited from the leftmost cell when the xtab is not expanded.
                //It might not be the same one when user expands the xtab. We need to consider those merged cells as well.
                fc.css = (umc[0] && umc[0].css) || fc.css;
                delete fc.ui;
                delete fc.tui;
                delete fc.fs;
                delete fc.mdf;
            }

            return [fc].concat(umc.concat(ncs));
        }
    };    

    /**
     * Editable grid widget.
     *
     * @class
     * @extends mstrmojo.EditableXtab
     */
    mstrmojo._IsEditableXtab =
        {
            _mixinName: "mstrmojo._IsEditableXtab",

            /**
             * Update
             */
            update: function update(node) {
                var marks,
                    gd = node.data;

                if (this._super) {
                    this._super(node);
                }

                this.kc = {};
                this.rs = {};
                this.rsDelta = {};

                clearMergedHeaderMarks.call(this, gd);

                //empty grid
                if (gd.eg !== undefined) {
                    return;
                }

                //row marked info
                marks = node.data.marked;
                if (marks) {
                    updateSelectedRows(marks, this.rs);
                }

                if (!gd.rw) {
                    var rc = gd.gvs.items.length;
                    gd.rw = {
                        row: {
                            bb: 1,
                            bc: rc,
                            tc: rc
                        },
                        col: {
                            bb: -1,
                            bc: -1,
                            tc: 0
                        }
                    };
                }
            },

            /**
             * Overrides the super function in order to replace the Content provider with editable grid content provider
             *
             * @param {GridJSON} gd
             * @param {Object[]} interactiveCellsArray
             * @param {Integer } tp
             * @param {JSONNode} base
             * @param {JSONNode} lkpBase
             * @param {Integer } ax
             * @param {ContentProvider} cp
             *
             * @ignore
             */
            initCP: function initCP(gd, interactiveCellsArray, tp, base, lkpBase, ax, cp) {
                var props = {
                    gridData: gd,
                    type: tp,
                    interactiveCellsArray: interactiveCellsArray
                };

                props.base = base || props.base;
                props.lookupBase = lkpBase || props.lookupBase;
                props.axis = ax || props.axis;
                props.dataSource = this;

                if (!cp) {
                    // are we in mark rows mode AND is the mode enabled ?
                    if (this.tca === TX_MARK && this.editing) {
                        if (tp === CP_TITLE) {
                            mstrmojo.EditableXtabTitlesCP = $CFC(mstrmojo.XtabTitlesCP, [mstrmojo._IsEditableGridCP], {scriptClass: "mstrmojo.EditableXtabTitlesCP", tp: CP_TITLE});
                            cp = new mstrmojo.EditableXtabTitlesCP(props);
                        } else if (tp === CP_ROW_HEADERS) {
                            mstrmojo.EditableXtabCP = $CFC(mstrmojo.XtabCP, [mstrmojo._IsEditableGridCP], {scriptClass: "mstrmojo.EditableXtabCP"});
                            cp = new mstrmojo.EditableXtabCP(props);
                        } else {
                            cp = new mstrmojo.XtabCP(props);
                        }
                    } else {
                        if (tp === CP_TITLE) {
                            cp = new mstrmojo.XtabTitlesCP(props);
                        } else {
                            cp = new mstrmojo.XtabCP(props);
                        }
                    }
                } else {
                    $H.copy(props, cp);
                }

                return cp;
            },

            /**
             * Gets the OnDemand CP
             * @ignore
             */
            createOnDemandCP: function createOnDemandCP(blockNum, rc, zone) {
                var cp;

                // are we in mark rows mode AND is the mode enabled ?
                if (this.tca === TX_MARK && this.editing && zone === CP_ROW_HEADERS) {
                    mstrmojo.EditableXtabOnDemandCP = $CFC(mstrmojo.XtabOnDemandCP, [mstrmojo._IsEditableGridCP], {scriptClass: "mstrmojo.EditableXtabOnDemandCP"});
                    cp = new mstrmojo.EditableXtabOnDemandCP();
                } else {
                    cp =  new mstrmojo.XtabOnDemandCP();
                }

                cp.dataSource = this;
                cp.blockNum = blockNum;
                cp.rc = rc;
                return cp;
            },

            preBuildRendering: function preBuildRendering() {
                var txi = this.defn.txi;

                if (this._super) {
                    this._super();
                }

                this.txar = txi.txar;
                //show changed icon
                this.sci = txi.sci;
                this.tca = txi.tca;

                // make sure editing is disabled, if tca doesn't support mark - rows
                if (this.tca !== TX_MARK) {
                    this.editing = false;
                } else {
                    if (mstrApp.isMobile) {
                    // If mark-rows is enabled on android device, the check box should always be displayed.
                        this.editing = this.alwaysEditing = true;
                    }
                }
                //reset node DOM map each rendering time
                this.nm = {};
                this.ko = {};

                this.dirtyRows = {}; //value: row index, value: 1
                this.requiredCellsMap = {}; //key: row index, value: cell obj

                this.dicGroupMap = {};
                this.lastIndex = 0;
                this.lastHeaderIndex = 0;
                this.columnNames = {};
            },

            postBuildRendering: function postBuildRendering() {
                if (this._super) {
                    this._super();
                }

                //if empty grid or template is not default, render the expand button
                if (this.tca === TX_MARK && this.gridData.eg === undefined) {
                    var t = Math.max(-16, -this.domNode.offsetTop), //16 is the height of the button
                        me = this;

                    if (!this.alwaysEditing) {
                        var dn = mstrmojo.Button.newIconButton(mstrmojo.desc(8324, 'Mark rows'), 'mstrmojo-EditButton', function () {
                                if (!me.recalculating) {
                                    me.editing = !me.editing;
                                    me.refresh();
                                }
                            }),
                            btn = new mstrmojo.Button(mstrmojo.hash.copy({
                                cssText: 'top:' + t + 'px;'
                            }, dn));

                        btn.render();
                        this.domNode.appendChild(btn.domNode);


                        if (this.editing) {
                            this.domNode.style.zIndex = 1000;
                            //this.viewport.onclick = null;
                            $C.addClass(btn.domNode, 'close');
                        } else {
                            $C.removeClass(btn.domNode, 'close');
                        }
                    }
                }
            },

            dataDownloadErr: function dataDownloadErr() {
                if (this.txar && this.recalculating) {
                    var z = this.zones;
                    if (z._BL) {
                        z._BL.isDownloading = false;
                    }
                    z._BR.isDownloading = false;

                    this.rhsCP.initContent();
                    this.valuesCP.initContent();

                    //clear the mask if any
                    $C.removeClass(this.maskNode, 'wait');
                    this.recalculating = false;
                }
            },

            /**
             * @param {RWJSONDataNode} node
             * @param {Object} memo
             */
            dataDownloaded: function dataDownloaded(node, memo) {
                var gd = node.data;
                if (this.txar) {
                    var idx = memo.blockNum, zn = this.zones, ica;

                    if (this.recalculating) {
                        memo.recalculating = true;
                        this.interactiveCellsArray = [];
                        this.requiredCellsMap = {};
                        this.dirtyRows = {};
                        this.lastIndex = 0;
                        this.lastHeaderIndex = 0;
                        this.kc = {};
                        this.nm = {};
                        this.updatedCellsMap = {};
                        this.recalculating = false;
                        this.destroyDICs();
                    } else {
                        memo.recalculating = false;
                    }

                    //for the first block of data, we need to update the Xtab's gridData so that we can get the latest data when rerender the grid
                    if (idx === 0) {
                        this.gridData = gd;
                    }

                    //TQMS 511405 if fetches an empty grid, we will skip initializing the cp and refresh the xtab
                    //to render an empty grid
                    if (gd.eg) {
                        this.refresh();
                        return;
                    }

                    ica = this.interactiveCellsArray;
                    this.initCP(gd, ica, CP_TITLE, null, null, null, this.titlesCP);
                    this.initCP(gd, ica, CP_COL_HEADERS, gd.ghs.chs, gd.gts.col, COL_AXIS, this.chsCP);
                    this.titlesCP.initContent();
                    this.chsCP.initContent();

                    //TQMS 507486 Once we are doing the auto-recalculating, the interactive arrays is cleared.
                    //So the interactive cells on the headers can be lost if they are locked (especially for interactive grid).
                    //The headers needs to be re-rendered once we clear the interactive cells.
                    if (ica && ica.length === 0) {
                        if (zn._TR) {
                            zn._TR.refresh();
                        }
                        if (zn._TL) {
                            zn._TL.refresh();
                        }
                    }
                }

                if (this._super) {
                    this._super(node, memo);
                }

                //clear the marked merge header map
                clearMergedHeaderMarks.call(this, gd);

                // add clear logic before reset the selected rows
                clearSelectedRowsForBlock(this.rs, gd.rw.row); 
                
                if (gd.marked) {
                    updateSelectedRows(gd.marked, this.rs);
                    this.rsDelta = {};
                }
            },

            closeDownloadStatus: function closeDownloadStatus() {
                if (this._super) {
                    this._super();
                }
                mstrmojo.css.removeClass(this._STATUS, 'recalculate');
            },


            /**
             * Key context map
             */
            kc: null,

            /**
             * Key context with row ordinal map
             */
            ko: null,

            /**
             * DOM node map
             */
            nm: null,

            /**
             * Row selection
             */
            rs: null,

            /**
             * created DICs.
             */
            dicGroupMap: null,

            /**
             * index of last processed editable cell in grid.posMap
             */
            lastIndex: 0,

            /**
             * index of last processed editable header in grid.thPosMap
             */
            lastHeaderIndex: 0,

            /**
             * column names of the grid
             */
            columnNames: null,

            /**
             * Gets the data info object
             * @param {Object} cell
             * @param {String} widx
             * @returns {Object} The data input info object
             */
            getDataInputInfo: function getDataInputInfo(cell, widx) {
                var k = cell._ei, o,
                    defn = this.node.defn,
                    data = this.gridData;

                if (cell.mark) {
                    o = cell.o;
                    if (cell.stt) {
                        this.rs[o] = 0; //set the row to be unmarkable
                        return;
                    }
                    this.ko[o] = k;
                    cell.rv = cell.v = this.rs[o] || -1;
                    this.kc[k] = {rowop: true};
                    return {
                        key: k,
                        t: MARKROW,
                        vls: [{
                            'v': -1
                        }, {
                            'v': 1
                        }],
                        wm: 1,
                        w: 22,
                        hm: 1,
                        h: 16,
                        dm: 1
                    };
                }

                var titleInfo = this.model.getCellTitleInfo(cell, this.dataBlocks[cell._gd]),
                    title = titleInfo && titleInfo.title,
                    es = title && title.es,
                    mti = (cell.mti !== undefined) ? cell.mti : cell.mix,
                    isMtx = (cell.mix !== undefined),
                    dic = defn.txi.dic,
                    di;

                di = !isMtx ? dic.att && title && dic.att[title.id] && dic.att[title.id][title.fs[cell.fi].id] : dic.mtx && dic.mtx[es[mti].oid];

                if (!di) {
                    return null;
                }

                // Save the column name
                if (this.columnNames[widx] === undefined) {
                	this.columnNames[widx] = !isMtx ? title.n : es[mti].n;
                }

                // If the data input control is data driven
                if (isDataDrivenDIC(di)) {
                	di.vls = (data.dcv && data.dcv[di.k]) || [];
                }

                // cache the title related information into key context map
                if (k >= 0 && !this.kc[k]) {
                    var isMv = !cell.axis,
                        t = {
                            isMv: isMv
                        };

                    if (isMv) {
                        var pi = cell.pi,
                            tp = pi && pi.top;
                        t.co = (tp && tp.ci) || 0;
                        t.metric_id = es[mti].oid;
                        cell.o = t.o = (cell._lp && cell._lp.o) || 0;
                        t.tp = TX_ELEM_METRIC;
                    } else {
                        t.ax = cell.axis;
                        t.atid = title.id;
                        t.form_id = title.fs[cell.fi].id;
                        t.o = cell.o;
                        t.tp = TX_ELEM_ATT_FORM;
                        t.fi = cell.fi;
                        t.ui = cell.ui;
                        t.tui = cell.tui;
                        t.rs = cell.rs;
                    }

                    t.dt = di.dt;
                    if (isDataDrivenDIC(di)) {
                    	t.vls = di.vls;
                    	t.k = di.k;
                    }

                    this.kc[k] = t;
                }

                di.key = k;

                if (di.dm) {
                    di.dm = parseInt(di.dm, 10);
                }

                return di;

            },

            isEditableHeader: function isEditableHeader(cell) {
                var defn = this.node.defn,
                    dic = defn.txi.dic;

                if (cell.sst || !dic) {
                    return false;
                }

                if (cell.id !== undefined && dic.att) { //attribute
                    return !!(dic.att[cell.id] && (cell.fix ? dic.att[cell.id][cell.fid] : dic.att[cell.id]));
                }

                if (cell.tui !== undefined && cell.mix !== undefined && dic.mtx) { //column header
                    return !!(dic.mtx[cell._e.oid]);
                }

                return false;
            },

            /**
             * Once the data changed, we save the target DOM into node map
             */
            dataChanged: function dataChanged(k, r, v, d) {
                if (!this.recalculating) {
                    if (d) {
                        this.nm[k] = d;
                    }

                    if (this._super) {
                        this._super(k, r, v, d);
                    }
                }
            },

            /**
             *  Applies the new value to the grid data
             *  @param {Integer} k The key of the interactiveCellsArray
             *  @param {Object} v The new value object
             *  @returns {Boolean} True if the grid needs to be refreshed, otherwise returns false
             */
            updateValue: function updateValue(k, vo) {
                if (this._super) {
                    this._super(k, vo);
                }

                var c = this.interactiveCellsArray[k],
                    v = vo.v,
                    t,
                    rowIdx = getRowIndex.call(this, c);

                this.lmr = null; //clear the last marked row always.

                // TQMS 610775: if we changed one unmerged cell of a orignal merged cells, it will write back the new
                // value to the first cell of the original merged cells. If we leave the lines below there, if user
                // modifies this first cell later on, no modification flag would show up.
                // We need to comment the lines below to avoid this problem.
//                if (c.v === v) {
//                    //nothing changed since last update
//                    return;
//                }

                t = applyChange.call(this, c, k, vo);
                if (c.r !== v) {
                    if (!c.mark) {
                        // set the modified flag
                        c.mdf = 1;

                        // clear the "required" css class if any (it might be set on by the last submit)
                        mstrmojo.css.removeClass(t, 'required');

                        markDirtyRows.apply(this, [c, rowIdx]);

                        // mark the cell itself as dirty
                        this.flagDirtyUnit(t);
                    }
                } else {
                    this.clearDirtyUnit(t);
                }

                // if the template has Mark-rows enabled, we should mark the rows if any cell get changed
                if (this.tca === TX_MARK) {
                    //is the change from row marker checkbox?
                    if (c.mark) { //yes, we should use the current checkbox value
                        var ordinal = c.markAll ? -1 : c.o,
                            rsDelta = this.rsDelta;

                        this.rs[ordinal] = v;

                        // TODO: For android, ordinal will always be >= 0 as changes in android.MarkRowDIC haven't been made.
                        // We need backend work on this first.
                        this.lmr = {r: ordinal, v: v}; //last marked row

                        if (c.markAll) {
                            // remove all previous records
                            rsDelta = this.rsDelta = {};
                            rsDelta[ordinal] = v;
                            this.mghMarks = {};
                        } else if (rsDelta[ordinal] && rsDelta[ordinal] !== v) {
                            //if the delta already contains the value, and the value is the opposite value of the changing one
                            //that means we need to cancel the previous manipulation in the delta
                            delete rsDelta[ordinal];
                        } else if (rsDelta[-1] !== v) {
                            // do not update delta if trying to (un)mark the row when (un)mark all flag is true.
                            rsDelta[ordinal] = v;
                        }
                    } else { //no, we need mark the row as selected.
                        if (this.rs[c.o] !== 0) {
                            this.rs[c.o] = 1;
                        }

                        //if the grid is not in unmerged status, and if the grid contains merged row headers, and the change is made on row heaers
                        if (!this.editing && this.mghMarks && (c.mix === undefined)) {
                            // TQMS 754881 if there are two merged headers at the same row, the bigger rs one should overwrite the smaller one
                            // if the merged header is never recorded before, save it.
                            if(!this.mghMarks[c.o] || this.mghMarks[c.o].rs < c.rs) {
                                //add merged header mark
                                this.mghMarks[c.o] = {o: c.o, rs: c.rs, k: k};
                            }
                            //changing the merged header can affect individual unmarked operations stored in delta,
                            //so loop through delta to find the marked/unmarked rows inside merged headers, and delete them
                            var sro,
                                sco,
                                me = this;
                            $H.forEach(this.rsDelta, function (mv, ro) {
                                sro = parseInt(ro, 10);
                                sco = parseInt(c.o, 10);
                                if (sro >= sco && sro <= (sco + c.rs)) {
                                    delete me.rsDelta[ro];
                                }
                            });
                        } else {
                            //if not merged header, or change on metrics, save the change to delta
                            this.rsDelta[c.o] = 1;
                        }

                        //if the row span of the cell is more than 1, we need mark all the rows within the span
                        //we do this only when the xtab is collapsed
                        if (!this.editing && c.rs > 1) {
                            var o = c.o + 1;
                            while (o - c.o < c.rs) {
                                if (!onTotalRow(this.rhsCP, o, this.rs)) {
                                    this.rs[o] = 1;
                                }
                                o += 1;
                            }
                        }
                        //TQMS 610772: we should mark the row even when auto-recalculation is on.
                        if (this.editing) {
                            var w = this.dicGroupMap.m_x.widgetsMap[this.ko[c.o]];
                            if (w) {
                                w.set('checked', true);
                            }
                        }
                    }
                }

                //check whether auto refresh is enabled. If it is, we should execute the auto refresh code (set invalid pages, call onscroll etc) except for one case
                //that is, if the user check/uncheck the row marker checkbox, we should not auto refresh.
                if (this.txar && !c.mark) {
                    return true;
                }

                return false;
            },

            autoRefresh: function autoRefresh() {
                //notify pages to re-download blocks
                var z = this.zones;
                if (z._BL) {
                    z._BL.invalidAllPages();
                }
                z._BR.invalidAllPages();
                //invalid row headers and values
                this.rhsCP.invalid();
                this.valuesCP.invalid();

                //set new css to disable the previous status bar been displayed
                $C.addClass(this._STATUS, 'recalculate');

                //trigger _BR onscroll to fetch new data
                z._BR.onscroll(true); //set the mask
                this.recalculating = true;
            },

            /**
             * Get the cached update related title information object
             * @param {Integer} The key of the interactiveCellsArray
             * @returns {Object} An object contains title information such as column number, ordinal, metric id, form_id etc
             */
            getKeyContext: function getKeyContext(key) {
                return this.kc[key];
            },

            /**
             * Returns the transaction updates in JSON object. The object is used for task parameters
             * @returns {Object} Transaction update object.
             */
            getUpdateObject: function getUpdateObject() {
                var cs = [], j, udvs, udv, lmr = this.lmr, v, ddicObj = {};

                if (lmr) { //row marked?
                    //TQMS 518625 and 518622 clear the last marked row so that mark row requests will not be sent repeatedly.
                    this.lmr = null;
                    return {
                        manipulation: MARK_ROW,
                        actionType: (lmr.v === -1) ? MR_MANIPULATION_UNSET : MR_MANIPULATION_SELECT,
                        rowOrdinal: lmr.r, //always use the first item since we can only have one marked row change at a time
                        nodeKey: this.k,
                        sliceId: this.sid
                    };
                }

                // data cell changed?
                udvs = this.getUpdatedValues();

                // TQMS 595731: need to skip the updated records for mark row operation.
                for (j = 0; j < (udvs && udvs.length); j++) {
                    if (!udvs[j].rowop) {
                        udv = udvs[j];
                        break;
                    }
                }

                if (udv) {
                    //encode the value, convert it to string
                    v = mstrmojo.string.encodeXMLAttribute(String(udv.v));

                    if (udv.k !== undefined && udv.vls) {
                        ddicObj = {
                            controlKey: udv.k,
                            elementId: udv.vls[mstrmojo.array.find(udv.vls, 'v', udv.v)].eid
                        };
                    }

                    if (!!udv.isMv) {
                        cs.push($H.copy(ddicObj, {
                            rowOrdinal: udv.o,
                            colOrdinal: udv.co,
                            newValue: v,
                            dataType: udv.dt
                        }));
                    } else {
                        cs.push($H.copy(ddicObj, {
                            rowOrdinal: udv.o,
                            attId: udv.atid,
                            formId: udv.form_id,
                            unitIndex: udv.tui || udv.ui, //AE binary still needs this parameter
                            newValue: v,
                            dataType: udv.dt
                        }));
                    }
                }

                return {
                    manipulation: CHANGE_DATA,
                    nodeKey: this.k,
                    sliceId: this.sid,
                    cells: cs,
                    //TQMS 610777: We should only set "autoRefresh" flag to true if the auto-recalculation is enabled.
                    autoRefresh: this.txar
                };
            },

            /**
             * Gets the update xml for the Xtab
             * @returns {String} update XML string
             */
            getUpdates: function getUpdates() {
                var w = this, j, udv,
                    udvs = w.getUpdatedValues(),
                    srs = this.rsDelta,
                    eg = [], gd = [], udt = false, k = '';


                eg.push('<gr rw_tree_type="' + w.treeType + '" rw_node_key="' + w.k + '" slice_id="' + w.sid + '">');
                for (j in udvs) {
                    if (udvs.hasOwnProperty(j)) {
                        udv = udvs[j];
                        if (!udv.rowop) {
                            //encode the value, convert it to string
                            var v = mstrmojo.string.encodeXMLAttribute(String(udv.v));

                            //DDIC controls, we need pass element id for selection
                            if (udv.k && udv.vls) {
                                var m = mstrmojo.array.find(udv.vls, 'v', udv.v);
                                k = 'rw_control_key="' + udv.k + '" element_id="' + udv.vls[m].eid + '" ';
                            }

                            if (!!udv.isMv) {
                                gd.push('<cli cordinal="' + udv.co + '" metric_id="' + udv.metric_id + '"><updt types="' + udv.tp + '" rordinal="' + udv.o + '" ' + k + 'value="' + v + '" dt="' + udv.dt + '"/></cli>');
                            } else {
                                //for (i = 0, len = parseInt(udv.rs) || 1; i < len; i++) {
                                //    gd.push('<cli ax="' + udv.ax + '" attribute_id="' + udv.atid + '" form_id="' + udv.form_id + '"><updt types="' + udv.tp +'" ordinal="' + (udv.o + i) + '" ' + k + 'value="' + v + '" dt="' + udv.dt + '"/></cli>');
                                //}
                                gd.push('<cli ax="' + udv.ax + '" attribute_id="' + udv.atid + '" form_id="' + udv.form_id + '"><updt types="' + udv.tp + '" ordinal="' + udv.o + '" ' + k + 'value="' + v + '" dt="' + udv.dt + '"' + (this.mghMarks ? ' flags="1"' : '') + '/></cli>');
                            }
                            udt = true;
                        }
                    }
                }

                //add merged header row mark changes
                if (!$H.isEmpty(this.mghMarks)) {
                    var me = this;
                    $H.forEach(this.mghMarks, function (v, ro) {
                        k = me.getKeyContext(v.k);
                        gd.push('<mark rordinal="' + ro + '" types="4" flags="1" attribute_id="' + k.atid + '" form_id="' + k.form_id + '"/>');
                    });
                }

                //if there is any updates, send the mark operations
                if (srs && !$H.isEmpty(srs)) {
                    udt = true;
                    $H.forEach(srs, function (v, o) {
                        if (v === 1) {
                            gd.push('<mark rordinal="' + o + '" types="4"/>');
                        } else {
                            gd.push('<mark rordinal="' + o + '" types="5"/>');
                        }
                    });
                }

                eg.push(gd.join(''));
                eg.push('</gr>');

                //if we don't have any update, we should get an empty string
                if (!udt) {
                    eg = [];
                }
                return eg.join('');
            },

            /**
             * Set the target DOM node a dirty flag on it.
             * Should be overrided by subclass if needed.
             * @param {HTMLElement} t the target DOM node
             */
            flagDirtyUnit: function flgDtUnt(t) {
                if (t && this.sci) {
                    if (this._super) {
                        this._super(t);
                        return;
                    }

                    var v = document.createElement('div'),
                        df,
                        tf = false,
                        trans3d = $C.getStyleValue(this.domNode, $D.CSS3_TRANSFORM),
                        isTDRelative;
                    v.className = "flag-container";
                    v.innerHTML = '<div class="dirty-cell"/>';
                    if (t.insertBefore) {
                        t.insertBefore(v, t.firstChild);
                        isTDRelative = (v.offsetParent === t);
                    }
                    tf = mstrmojo.string.isEmpty(trans3d) || trans3d === "none";
                    //we need to adjust the top and left
                    df = v.firstChild;
                    df.style.top = ((!tf || isTDRelative) ? (-v.offsetTop) : (t.offsetTop - v.offsetTop)) + 'px';
                    df.style.left = (t.clientWidth + ((!tf || isTDRelative) ? (-v.offsetLeft) : (t.offsetLeft - v.offsetLeft)) - 8) + 'px';
                }
            },

            /**
             * Clear the dirty flag on the target DOM node.
             * Should be overrided by subclass if needed.
             * @param {HTMLElement} t the target DOM node
             */
            clearDirtyUnit: function clrDtUnt(t) {
                if (this._super) {
                    this._super(t);
                    return;
                }

                var c = t.firstChild;
                if (t) {
                    if (c && c.className && c.className === 'flag-container') {
                        t.removeChild(c);
                    }
                }
            },

            onvisibleChange: function onvisChg() {
                if (this.visible === true) {
                    var me = this;

                    // do it in a timeout because the domNode has not become visible yet at this moment
                    setTimeout(function () {
                        me.configureActions();
                    }, 10);
                }
            },

            /**
             * Process the editable cells / headers on the grid.
             */
            configureActions: function cfgAct() {
                if (this.visible === false) {
                    return;
                }

                var zone = '_BR',
                    grid = this.zones[zone],
                    rowLocked = !!this.zones['_BL'],
                    posMap = grid.posMap,
                    thPosMap = grid.thPosMap,
                    ics = this.interactiveCellsArray,
                    dicGroupMap = this.dicGroupMap,
                    dirtyNodes = [],
                    ei,
                    len,
                    i,
                    k,
                    cell,
                    pos,
                    node,
                    widx,
                    rowIdx,
                    currentRow,
                    config,
                    dicGroup,
                    me = this,
                    flagDirtyNodes = function (dns) {
                        var jLen = dns.length,
                            j;
                        for (j = 0; j < jLen; j++) {
                            me.flagDirtyUnit(dns[j]);
                        }
                    };

                for (ei = this.lastIndex, len = ics.length; ics[ei] && ei < len; ei++) {
                    cell = ics[ei];
                    pos = posMap && posMap[ei];
                    
                    //TQMS#720313 If current zone does not contain the cell, flip zone to see whether the cell is from the other zone
                    if(!pos && rowLocked) {
                        zone = (zone === '_BR') ? '_BL' : '_BR'; //flip zone
                        grid = this.zones[zone]; //reset grid
                        posMap = grid && grid.posMap; //reset posMap
                        thPosMap = grid && grid.thPosMap; //reset thPosMap
                        pos = posMap && posMap[ei];
                    }

                    if (pos && ((cell.at & 32) > 0)) {
                        node = grid.getNodeByPosition(pos);
                        //#466957. Current approach is to overwrite the other action type (for link and drilling).
                        //A better solution in the future should be use dropdown context menu for all possible actions.
                        cell.at = 32;

                        if (cell.rv == null) {
                            cell.rv = isNaN(cell.mix) ? cell._e.n : cell.v;
                        }

                        widx = getGroupIdx(cell);
                        config = this.getDataInputInfo(cell, widx);
                        dicGroup = this.dicGroupMap[widx];

                        if (config) {
                            if (!dicGroup) {
                                dicGroup = dicGroupMap[widx] = mstrmojo.DICFactory.createDICGroup({
                                    gk: widx,
                                    dic: config,
                                    owner: this,
                                    openerType: XTAB
                                });
                            }

                            // TQMS 690312: Add popupTitle property, support to display the name of column for fields
                            // when invoking their respective data input controls for grids.
                            var dicProps = {
                                    value: (cell.rv === undefined) ? (cell.v || cell.n) : (typeof cell.rv === 'string' ? mstrmojo.string.decodeHtmlString(cell.rv) : cell.rv),
                                    dv: cell.v || cell.n,
                                    ts: cell.ts,
                                    markAll: cell.markAll,
                                    openerNode: node,
                                    k: cell._ei,
                                    ownerCell: cell,
                                    popupTitle: this.columnNames[widx]
                                },
                                stackedRh = grid.cp.stackedRh;

                            // We want to vertically the DIC if it's the only cell in a stacked row.
                            if (stackedRh && cell.singleStack && (mstrmojo.DICConfig.showDICByDefault(config, 1) || mstrmojo.DICConfig.hasDICPreview(config, 1))) {
                                var tdHeight = node.offsetHeight;

                                // Add the css
                                node.className += ' igDIC';
                                node.style.cssText = 'height:' + tdHeight + 'px;';

                                mstrmojo.hash.copy({
                                    inlineExtraCssText: 'position:absolute;' + 'top:' +  parseInt(stackedRh / 2 - tdHeight / 2 + 1, 10) + 'px;'

                                }, dicProps);
                            }

                            dicGroup.addDIC(cell._ei, dicProps);

                            rowIdx = pos.page * grid.rowsPerPage + pos.row;

                            if (config.req) {
                                //TQMS 637212: when mark row is enabled, there would no cell has row span > 1
                                for (k = 0; k < (this.editing ? 1 : (cell.rs || 1)); k++) {
                                    currentRow = this.requiredCellsMap[rowIdx + k];
                                    if (!currentRow) {
                                        this.requiredCellsMap[rowIdx + k] = currentRow = [];
                                    }
                                    currentRow.push(cell);
                                }
                            }

                            //remember dirty cells and flag them later
                            if (cell.mdf) {
                                dirtyNodes.push(node);

                                markDirtyRows.apply(this, [cell, rowIdx]);
                            }
                        }
                    }
                }
                this.lastIndex = ei;

                //render inline DICs
                for (widx in dicGroupMap) {
                    dicGroupMap[widx].render();
                }

                //flag the modified cells
                //TQMS 595732: Need to do this in a timeout so that the html struture is stable enough for us to calculate the position of dirty flags.
                // we had a timeout in _HasXtabTouchScroll mixin to setup the scroller for xtab which would affect the calculation.
                setTimeout(function () {
                    flagDirtyNodes(dirtyNodes);
                }, 25);

                //render editable column headers
                for (i = this.lastHeaderIndex, len = thPosMap.length; i < len; i++) {
                    pos = thPosMap[i];
                    node = grid.getNodeByPosition(pos);
                    cell = pos.obj;

                    if (this.isEditableHeader(cell)) {
                        node.innerHTML = '<div class="editable-column">' + node.innerHTML + '</div>';
                    }
                }
                this.lastHeaderIndex = i;

                this.registerTxWidget();

                if (this._super) {
                    this._super();
                }
            },

            showPopupDIC: function showPopupDIC(target) {
                var tn = target && $D.findAncestorByAttr(target, 'ei', true, this.viewport);

                if (tn) {
                    var td = tn.node,
                        cell = this.getCellForNode(td),
                        group = this.dicGroupMap[getGroupIdx(cell)];

                    if (group) {
                        group.showPopupDIC(cell._ei);
                        return true;
                    }
                }

                return false;
            },

            /**
             * If the clicked cell has a popup DIC attached, create and render it
             * @override XtabBase.onclick
             */
            onclick: function onclick(e) {
                var target = mstrmojo.dom.eventTarget(window, e.e);

                if (!this.showPopupDIC(target) && this._super) {
                    this._super(e);
                }
            },

            unrender: function unrender() {
                if (this._super) {
                    this._super();
                }
                this.destroyDICs();
            },

            destroyDICs: function destroyDICs() {
                var dicGroupMap = this.dicGroupMap;
                this.dicGroupMap = {};

                //delay the destroy process so that it won't freeze the UI
                setTimeout(function () {
                    var i;
                    for (i in dicGroupMap) {
                        dicGroupMap[i].destroy();
                    }
                }, 10);
            },

            /**
             * Validate all the transaction required columns of the xtab
             * @return {Boolean} false if a cell is required and on a dirty row but has no modification
             */
            checkRequiredObjects: function checkRequiredObjects() {
                if (this.hasRendered && !(this.isInteractiveGrid && this.isInteractiveGrid()) && !this.gridData.eg) {
                    var grid = this.zones._BR,
                        posMap = grid.posMap,
                        row,
                        me = this,
                        rowSelections = this.rs,
                        validFlag = true,
                        // r {Integer} row idx (1-based).
                        // hilite {Boolean} if true means we are going to check all the required cells on this row and highlight them if not modified.
                        //                  if false means the row is valid, we are going to clear highlights on any invalid cell.
                        processRow = function (r, hilite) {
                            var valid = true,
                                cells = me.requiredCellsMap[r],
                                len = (cells && cells.length) || 0,
                                i;

                            for (i = 0; i < len; i++) {
                                // if cell is not modified
                                if (!cells[i].mdf) {
                                    // highlight it
                                    $C.toggleClass(grid.getNodeByPosition(posMap[cells[i]._ei]), 'required', hilite);
                                    // if any cell gets highlighted, the valid result is false.
                                    valid = !hilite;
                                }
                            }

                            return valid;
                        };

                    // if mark row is enabled (no matter whether mark row checkbox is visible),
                    if (this.tca === TX_MARK) {
                        // we need to validate the rows that have been marked and clear the highlights for rows that have been unmarked.
                        for (row in rowSelections) {
                            validFlag = processRow(parseInt(row, 10) + 1, rowSelections[row] > 0) && validFlag;
                        }
                    } else {
                        // otherwise, we go through rows that have modified cells.
                        for (row in this.dirtyRows) {
                            validFlag = processRow(row, true) && validFlag;
                        }
                    }

                    return validFlag;
                }
                return true;
            },

            /**
             * Open/Focus on the input control on the grid cell next to the current cell.
             * @param {Integer} k the idx of cell current being edited
             */
            editNext: function editNext(k) {
                // Don't do this if auto-recalculation is going on.
                if (this.recalculating) {
                    return false;
                }

                var ics = this.interactiveCellsArray,
                    len = ics.length,
                    i = k + 1,
                    nextCell,
                    dicWidget;

                do {
                    // if we are at the end, go back to the first one.
                    if (i >= len) {
                        i %= len;
                    }

                    // if the cursor goes back to the current one, it means that there's no IC to advance to
                    if (i === k) {
                        return false;
                    }

                    nextCell = ics[i];
                    var group = this.dicGroupMap[getGroupIdx(nextCell)];

                    // If the dic group exists
                    if (group) {
                        // Is the input control navigable?
                        if (mstrmojo.DICConfig.isKeyNavigable(group.dic)) {

                            // open popup DIC
                            if (!group.showByDefault) {
                                group.showPopupDIC(i);
                            } else {
                                dicWidget = group.widgetsMap[i];

                                // The navigable IC must be focusable, throw a error if it isn't.
                                dicWidget.focus();
                            }

                            return true;
                        }
                    }
                    i++;
                } while (true);
                // It should never reach here.
            }
        };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._HasScrollbox",
                         "mstrmojo.XtabZone",
                         "mstrmojo._ShowsStatus",
                         "mstrmojo.boxmodel",
                         "mstrmojo.dom");


    var ROW_AXIS = 1;
    var COL_AXIS = 2;
    var LOCK_OFF = 0;
    var LOCK_ROW = 1;
    var LOCK_COL = 2;
    var LOCK_BOTH = 3;

    /**
     * Bitwise enumerations for Content Provider Types.
     * @private
     * @ignore
     */
    var CP_TITLE = 1;
    var CP_COL_HEADERS = 2;
    var CP_ROW_HEADERS = 4;
    var CP_VALUES = 8;

    var $D = mstrmojo.dom,
        UNSET;

    function onDemandCPAgg(cpList) {
        var vCP = null;
        if (cpList && cpList.length > 1) {
            // incremental fetch. We need to wrap the CPs in side a VACP.
            vCP = new mstrmojo.XtabVACP();
            vCP.cps = cpList;
        }
        return vCP;
    }

    function repaint(node) {
        var img = document.createElement('img');
        node.appendChild(img);
        node.removeChild(img);
    }

    function convertEmtoPx(dom, v) {
        if ($D.isIE) {
            return mstrmojo.boxmodel.convert2px(dom, v);
        }
        return v;
    }

    /**
     * Creates OnDemand CPs for row header CP list and values CP list using the result window size
     *
     * @param {Objet} rw JSON ResultWindow
     */
    function addOnDemandCPs(rw) {
        if (!rw || this._onDemandCP) {
            return;
        }

        // have we fetched lesser rows than the total number of rows ?
        var blockCount = rw.bc,
            totalRows = rw.tc,
            rowsRemaining = totalRows - blockCount,
            numCPs = Math.ceil(rowsRemaining / blockCount),
            rhsCPList = [],
            valuesCPList = [],
            i;

        // we assume that grid is sent initially by iserver with the first block always, as against say starting from 100th row.
        for (i = 0; i < numCPs; ++i) {
            // what would be the row count for the new content provider.
            var rc = Math.min(rowsRemaining, blockCount);

            // create the content providers.
            // AND push our onDemand content providers in the corresponding kust for reference during download.
            rhsCPList.push(this.createOnDemandCP(i + 1, rc, CP_ROW_HEADERS));
            valuesCPList.push(this.createOnDemandCP(i + 1, rc, CP_VALUES));

            // update the rows remaining.
            rowsRemaining -= blockCount;
        }

        this._onDemandCP = {rhs: rhsCPList, vls: valuesCPList};
        return this._onDemandCP;
    }


    /**
     * Xtab is a crosstabbed data grid display.
     */
    /**
     * <p>The widget for a single MicroStrategy Report Services Crosstabbed data grid display.</p>
     *
     * <p>Or at least, that's how it appears.  It is actually a container with up to 4 child widgets, each of which is a XtabZone instance.  The HTML of
     * the Xtab is typically a 2x2 HTML table, whose cells contain the HTML of each XtabZone.  The 2x2 HTML table of the Xtab is wrapped in a
     * non-scrolling div, called the "viewport" of the Xtab.  The viewport node does not scroll; however, the bottom-right cell of the 2x2
     * table does have a scrolling div (called the "scrollboxNode" of the Xtab), which contains the HTML of the bottom-right XtabZone width.
     * This HTML arrangement allows us to produce a "locked headers" effect.</p>
     *
     * @class
     * @extends mstrmojo.Container
     */
    mstrmojo.XtabBase = mstrmojo.declare(
        // superclass
        mstrmojo.Container,

        // mixins
        [ mstrmojo._HasScrollbox, mstrmojo._ShowsStatus ],

        /**
         * @lends mstrmojo.Xtab.prototype
         */
        {
            scriptClass: "mstrmojo.XtabBase",

            /**
             * Sets the renderMode of the "BOTTOMRIGHT" and "BOTTOMLEFT" XtabZones. This property value
             * is simply passed down to the child widgets; it does not affect the rendering of the
             * Xtab widget itself.
             */
            dataRenderMode: "vscroll",

            /**
             * True to listen for click events on interative cells.
             *
             * @type boolean
             * @default true
             */
            handleClicks: function handleClicks() {
                return true;
            },

            markupString: '<div id="{@id}" class="mstrmojo-Xtab {@cssClass}" title="{@tooltip}" style="{@domNodeCssText}">' +
                            '<div style="display: none;{@msgNodeCssText}"><div>&nbsp;</div></div>' +    // Need this dummy div or IE won't see the style tag.
                            '<div class="mstrmojo-Xtab-overlay"></div>' +
                            '<div class="mstrmojo-Xtab-content {@cssDefault}" title="{@tooltip}" style="{@viewportCssText}" mstrAttach:click,selectstart>' +
                                '<table cellspacing="0" cellpadding="0">' +
                                    '<tr trType="title">' +
                                        '<td style="vertical-align:top;padding:0px"></td>' +    // These 2x2 cells shouldn't inherit metadata formatting from the table.
                                        '<td class="xtab-tr" style="vertical-align:top;padding:0px;"></td>' +
                                    '</tr><tr trType="content">' +
                                        '<td class="xtab-bl" style="vertical-align:top;padding:0px;"></td>' +
                                        '<td class="xtab-br" style="vertical-align:top;padding:0px">' +
                                            '<div class="mstrmojo-progress" style="display:none">' +
                                                '<div class="mstrmojo-progress-barbg">' +
                                                    '<div class="mstrmojo-progress-bar"></div>' +
                                                '</div>' +
                                                '<div class="mstrmojo-progress-text"></div>' +
                                                '</div>' +
                                            // The scrollboxNode needs an id so we can use mstrmojo.dom.attachBufferedEvent on it
                                            // overflow macro to account for Grid Clip setting. We could have folded this macro into scrollboxNodeCssText too, but since this one is programmatically
                                            // controlled (also is the most core style setting for this div) we have it listed separately.
                                            '<div id="{@id}_scrollbox" style="position:relative;{@scrollboxNodeCssText};{@scrollboxNodeOverflow}"></div>' +
                                        '</td>' +
                                    '</tr>' +
                                '</table>' +
                            '</div>' +
                        '</div>',

            markupSlots: {
                overlayNode: function () { return this.domNode; },
                msgNode: function () { return this.domNode.firstChild; },
                maskNode: function () { return this.domNode.childNodes[1]; },
                viewport: function () { return this.domNode.lastChild; },
                contentNode: function () { return this.domNode.lastChild.firstChild; },
                scrollboxNode: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].lastChild; },

                // ZONES,
                _TL: function () { return this.domNode.lastChild.firstChild.rows[0].cells[0]; },                                                    // TOP LEFT
                _TR: function () { return this.domNode.lastChild.firstChild.rows[0].cells[1]; },                                     // TOP RIGHT
                _BL: function () { return this.domNode.lastChild.firstChild.rows[1].cells[0]; },                                 // BOTTOM LEFT
                _BR: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].lastChild; },                          // BOTTOM RIGHT

                // areas used towards resizing/aligning headers
                _T_ROW: function () { return this.domNode.lastChild.firstChild.rows[0]; },                              // TOP ROW
                _B_ROW: function () { return this.domNode.lastChild.firstChild.rows[1]; },                              // BOTTOM ROW
                _BR_CELL: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1]; },                // BOTTOM ROW CELL

                // slots for progress bar
                // ToDo - figure a way to reuse the markup string since DocLayoutViewer has this too.
                _STATUS: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].firstChild;  },
                _STATUS_TXT: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].firstChild.lastChild; },
                _STATUS_BAR: function () { return this.domNode.lastChild.firstChild.rows[1].cells[1].firstChild.firstChild.firstChild; }
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? 'block' : 'none'; }
            },

            /**
             * Hashtable of child widgets (XtabZone instances), keyed by slot name.  This is a convenient lookup
             * alternative to searching for a XtabZone within the "children" property.
             */
            zones: null,

            /**
             * Specifies lock header setting.
             */
            lockHeadersCase: LOCK_BOTH,

            /**
             * Represents a (array) list of all interactive cells that we are rendering.
             */
            interactiveCellsArray: null,

            /**
             * Titles content provider.
             */
            titlesCP: null,

            /**
             * Column headers content provider.
             */
            chsCP: null,

            /**
             * Row headers content provider.
             */
            rhsCP: null,

            /**
             * Value content provider.
             */
            valuesCP: null,

            /**
             * Whether the ondemand incremental fetch in enabled.
             *
             * @type boolean
             * @default true
             */
            onDemandIF: true,

            /**
             * When the incremental fetch is on and the grid height is set to fit to content, we use the first page of the grid
             * to set the xtab height. The boolean value is used to indicate the case.
             */
            numRowFixed: false,

            /**
             * Use the variable to limit the height of the visible area of xtab.
             */
            heightLimit: 0,

            /**
             * The xtab viewport height
             */
            height: 0,

            /**
             * Use this variable to limit the width of the visible area of the xtab. If the widthLimit is 0, that means
             * the grid width is fit to content. With new pages of the grid is rendered, the width can grow.
             */
            widthLimit: 0,

            /**
             * The xtab viewport width
             */
            width: 0,

            useTouchScrolling: false,

            /**
             * The "_HasScrollbox" mixin allows Xtab to be notified of scroll events in its scrollboxNode.
             * This notification allows Xtab to keep its locked headers (if any) aligned with the data as
             * the data scrolls.
             * The mixin allows the widget to specify a delay before the notification by setting a "scrollInterval"
             * property. A long delay may look wrong to the end-user who does not suspect that the headers & values
             * are actually stored in separate HTML <tables>.
             */
            scrollInterval: 0,

            /**
             * Data structure that stores the selected table cell DOM node. It is a two-level hashmap.
             * On the first level, the key is cell title ID which is built by XtabBase#getCellTitleId. And the value
             * is the second level map whose key is unit index of the cell built by XtabBase#getCellUnitIndex.
             * And its value is an DOM node array as each unit may have multiple attribute forms.
             * It can be illustrated as following:
             * TitleId    Unit Index    Array of DOMNodes
             *  1A2   --->    2    ---> [td, td]
             *        --->    3    ---> [td, td]
             *        --->    4    ---> [td, td]
             *  2A3   --->   10    ---> [td]
             *        --->   11    ---> [td]
             */
            selections: null,

            /**
             * Reference to the data block map (BLOCK_ID and gridData pair). For example, it can look like:
             * [
             *    0: {...} //the first block of data
             *    3: {...} //the fourth block of data
             * ]
             */
            dataBlocks: null,

            /**
             * The return value will be used as the second-level key of the XtabBase.selections.
             * For a header value, return its ordinal value, and for a metric value, return its unique index of the interactive array.
             *
             * @param {Object} cell
             */
            getCellUnitIndex: function getCellUnitIndex(cell) {
                return (cell.o !== undefined) ? cell.o : cell._ei;
            },

            /**
             * The return value will used as the first-level key of the XtabBase.selections.
             * For header values, it's built by axis and ui property, and for metric values, it's built by mix property.
             *
             * @param {Object} cell
             */
            getCellTitleId: function getCellTitleId(cell) {
                var rtn = '';

                if (cell.axis && cell.ui !== undefined) {
                    rtn = cell.axis + 'A' + (cell.ui + 1);

                } else if (cell.mix !== undefined) {
                    rtn = '0A' + cell.mix;
                }

                return rtn;
            },

            /**
             * Updates the XTab data that may change due to a selector action.
             *
             * @param {Object} node The widget node.
             */
            update: function update(node) {
                if (this._super) {
                    this._super(node);
                }

                this.set('gridData', node.data[0] || node.data); // interactive grid visualization contain a collection of grids so we use the first one

                var defn = this.defn || node.defn;
                this.sid = this.gridData.sid;
                this.treeType = (defn && defn.tt) || 1;
                this.interactiveCellsArray = [];
            },

            /**
             *  Factory method to get content providers initialized with necessary properties. If a non-null content provider (CP) is passed this method would initialize it,
             *  otherwise it would create a new one.
             *
             *  @param {Object} gd Grid data in JSON format.
             *  @param {Object[]} interactiveCellsArray
             *  @param {Integer} tp
             *  @param {Object} base JSON
             *  @param {Object} lkpBase JSON
             *  @param {Integer} ax Axis
             *  @param {Object} cp Content provider.
             *
             * @private
             */
            initCP: function initCP(gd, interactiveCellsArray, tp, base, lkpBase, ax, cp) {
                var props = {
                    gridData: gd,
                    type: tp,
                    interactiveCellsArray: interactiveCellsArray
                };

                props.base = base || props.base;
                props.lookupBase = lkpBase || props.lookupBase;
                props.axis = ax || props.axis;

                if (!cp) {
                    if (tp === CP_TITLE) {
                        cp = new mstrmojo.XtabTitlesCP(props);
                    } else {
                        cp = new mstrmojo.XtabCP(props);
                    }
                } else {
                    mstrmojo.hash.copy(props, cp);
                }
                return cp;
            },


            preBuildRendering: function preBuildRendering() {
                var gd = this.gridData;

                // lock headers setting
                this.lockHeadersCase = parseInt(gd.lhv, 10);
                this.selections = {};

                this.cssDefault = (this.lockHeadersCase === LOCK_OFF || !this.k) ? "" : "r-cssDefault" + (this.k ? "_" + this.k : "");

                // If the grid is in auto fit to content mode and the incremental fetch is on, the xtab will be rendered with fixed numbers of rows
                // on the first page and use this page height as the xtab height. The remaining rows will be ondemand and can be fetched when user scrolls the scrollbar.
                // The numRowFixed is used as the flag to record this special auto fit to content case when we need a scrollbar.  The flag is true only when there are rows needs to be downloaded on demand,
                // that is, the total row count larger than the incremental fetch block size
                this.numRowFixed = !!(!this.height && gd.rw && gd.rw.row && (gd.rw.row.bc < gd.rw.row.tc));
                this.rw = gd.rw;
                this._onDemandCP = null;

                //if the width is assigned, set the widthLimit to the same value. Same for the height.
                if (this.width) {
                    this.widthLimit = parseInt(this.width, 10);
                }
                if (this.height) {
                    this.heightLimit = parseInt(this.height, 10);
                }

                // trigger the parent's prebuild rendering.
                return (this._super) ? this._super() : true;
            },

            /**
             * The function renders the empty grid. XtabBase will render the empty grid message and hide the viewport.
             */
            renderEmptyGrid: function renderEmptyGrid() {
                var gd = this.gridData,
                    msgNode = this.msgNode,
                    viewport = this.viewport;

                // render empty grid/template message
                msgNode.firstChild.innerHTML = gd.eg;
                msgNode.style.display = "block";
                msgNode.style.overflow = "hidden";
                msgNode.className = 'mstrmojo-message';
                viewport.style.display = "none";

                return (this._super) ? this._super() : true;
            },

            /**
             * This method extends the rendering life-cycle inherited from Container in order to
             * trigger the intialization of the child widgets (GridBase or XtabZones) and their content providers
             * BEFORE the rendering of children is started, and
             * This extended processing is done only after a rendering has produced a BOTTOMRIGHT slot; presumably,
             * a rendering that omits that slot doesn't want to show data.
             */
            postBuildRendering: function postBldRndr() {
                // Need XtabZones for this rendering?
                var gd = this.gridData,
                    bInitZones = !!this._BR && gd,
                    msgNode = this.msgNode,
                    viewport = this.viewport,
                    rtn;

                if (gd.eg === undefined) {
                    // render grid normally
                    if (msgNode.style.display === "block") {
                        msgNode.style.display = "none";
                        viewport.style.display = "block";
                    }
                } else {
                    return this.renderEmptyGrid();
                }

                // clear the interactive cells collection.
                if (!this.interactiveCellsArray) {
                    this.interactiveCellsArray = [];
                }

                if (bInitZones) {
                    this._setupZones(gd);
                    this._setupCPs(gd);
                    // Add the newly created XtabZones as children of this widget now that they have their content providers. Attaches event listeners, sets child.parent, etc.
                    // Check if we've already done this before. If this is a re-render, we don't need to repeat this; the zones are already our children.
                    var zs = this.zones,
                        n;

                    for (n in zs) {
                        var z = zs[n];
                        if (z.parent !== this) {
                            this.addChildren(this.zones[n]);
                        }
                    }

                    // Pre-processing to setup the scrollbox and zones before calling renderChildren().
                    if (this.scrollboxNode) {
                        // Performance optimization: cache a boolean flag to let our zones
                        // know whether or not this scrollbox node has a fixed height.
                        var h = this.heightLimit;
                        this.scrollboxHeightFixed = !isNaN(h) && (h > 0);
                        if (this.scrollboxHeightFixed) {
                            this.scrollboxHeight = h; // Assumes pixels. TO DO: support inches.
                        }
                        this.scrollboxLeft = this.scrollboxTop = 0; // WARNING: what if browser tries to autoscroll to previous position?

                        // If we have any locked headers, wire the scrollboxNode to our onscroll handler.
                        if (this.lockHeadersCase) {
                            this.connectScrollbox(this);
                        }
                    }
                }

                this.renderChildren();
                rtn = this._super();

                //Special Case: This is the case where we have fit to contents and we default to the first page size as the viewport size. (for IF)
                if (this.numRowFixed) {
                    //Do we not have a height property fixed?
                    if (!this.height) {
                        //Calculate the viewport size from the zone's page height.
                        this.heightLimit = this.zones._BR.getPageHeight(0) + (this._TR ? this._TR.offsetHeight : 0);

                        //Update the height property
                        this.height = this.heightLimit + 'px';

                    } else {
                        //Do we have a height, that must be our viewport size.
                        this.heightLimit = parseInt(this.height, 10);
                    }
                }

                // Once the zones are rendered, we need to adjust the scrollbox height in two cases:
                // 1. In lock header case, the scrollbox height should be the xtab height - title height
                // 2. In number of row fixed case, we need to reset the scrollbox size from an estimated value to the proper value
                if ((this.lockHeadersCase && bInitZones && this.scrollboxNode) || this.numRowFixed) {
                    // Post-processing to initialize scrollboxNode's size.  The size will be set to fit within the available viewport space leftover by the header
                    // zones.  Therefore, this call needs to happen AFTER the child widgets have rendered.
                    // We don't need to resize the scrollbox because the Xtab's markup string & format handler initial set the size of the scrollboxNode to match the size of Xtab's viewport.
                    this.resizeScrollBox($D.isIE);
                }

                //update width value after rendering
                this.onGridWidthChanged(true);

                //#481842 - adjust scrollbox min-height when there is horizontal scrollbar
                //#666851,687707 - add checking on heightMode - only do this for height-fit-to-content
                if ($D.isIE7 && !this.scrollboxHeightFixed && this.scrollboxNode && this.scrollboxNode.scrollWidth > this.scrollboxNode.offsetWidth) {
                    this.scrollboxNode.style.height = this.scrollboxNode.offsetHeight + 17 + 'px';
                }

                return rtn;
            },

            onclick: function onclick(e, hWin) {

				// Do we have NO interactive cells?
				if (!this.interactiveCellsArray.length) {
					this.isSelectingText = false;
					return;
				}

                e = e.e || e;

                // Find the targeted table cell, if any.
                var $D = mstrmojo.dom,
                    target = $D.eventTarget(hWin, e),
                    clickedCell = target && $D.findAncestorByName(target, 'td', true, this.viewport);

                if (target.nodeName.toLowerCase() === 'a' && clickedCell.getAttribute('ei')) {
                    try {
                        var att = this.interactiveCellsArray[parseInt(clickedCell.getAttribute('ei'), 10)];
                        var DssXmlBaseFormHTMLTag = 7;
                        if (att && att.ts === DssXmlBaseFormHTMLTag) { // HTML tag
                            target.href = mstrmojo.addCSRFTokenToURL(target.href);
                        }
                    } catch (er) {
                        //ignore
                    }
                }

                // Did we find a clicked TD cell?
                if (clickedCell) {
                    // Find the span that contains the cell.
                    var a = $D.findAncestorByName(target, 'span', true, clickedCell);

                    if (a && !$D.shiftKey(hWin, e) && !$D.ctrlKey(hWin, e)) {
                        // Check if we should fire an action in response to this click.
                        // TO DO: move action handler into a delegate object, which can be loaded on-demand.
                        this.defaultAction(clickedCell);

                    } else {
                        this.doSelection(e, hWin, clickedCell);
                        if (!this.isSelectingText) {
                            $D.clearBrowserHighlights();
                        }
                    }
                }

                if (this.isSelectingText) {
                    this.isSelectingText = false;
                }
            },

            ontouchend: function ontouchend(e, hWin) {
                this.onclick(e, hWin);
            },

            onselectstart: function onselectstart() {
            	this.isSelectingText = true;
                return false;
            },

            /**
             * This handler is the callback that is notified whenever the end-user scrolls the Xtab's scrollboxNode.
             * [The event listening is setup by the _HasScrollbox mixin.]  It calls a method that align our zones if headers are locked.
             */
            onscroll: function onscroll() {
                this._alignHeaders();
            },

            /**
             * This method responds to changes in height/width of the viewport by computing a new size for the scrollboxNode (if any).  After this is done, the scrollboxNode may have unwittingly
             * changed its scroll position, so we also manually perform a scroll syncronization as well. The size of the scrollboxNode will be set to fit within the Xtab's viewport, taking up
             * whatever space is left available by the header zones.  If lock headers is OFF, then the scrollboxNode will be resized to occupy the entire viewport's new size.
             * @param {Boolean} bForceRepaint IE has a quirk whereby the rendering gets positioned incorrectly the very first time we do the resize.  As a workaround, we must
             * force IE to do a repaint (even if not needed) the first time we do the resize.  Thus we pass in a flag indicating whether or not the workaround is required.
             *
             * @param {Boolean} bForceRepaint
             */
            resizeScrollBox: function resizeScrollBox(bForceRepaint) {

                // Do we have a scrollboxNode and a viewport? If not, exit.
                var sb = this.scrollboxNode,
                    ss = sb && sb.style,
                    br = this._B_ROW,
                    brc = this._BR_CELL;
                if (!ss || !br || !brc) {
                    return;
                }

                // Now resize the scrollbox to fit within the div. We need the size of the grid div for this calculation.
                // Read our current height & width properties. Assume that values are in pixels; null or non-numeric values are considered "auto".
                // TO DO: enhance to support percents or other units.
                var width = this.widthLimit,
                    // If numRowFixed is true, the first page of the _BR zone is rendered. We need the value to reset the scrolbar height because it was an estimated value.
                    height = this.heightLimit;
                // If the height or width was just set to auto, then we'll need to measure it.
                if (!width || !height) {
                    // But before we measure it, we must remove any fixed size from our scrollbox so it can expand and the grid div can also expand to accomodate it.
                    if (!width) {
                        ss.width = 'auto';
                    }
                    if (!height) {
                        ss.height = 'auto';
                        this.scrollboxHeightFixed = false;
                    }
                }

                if (height) {
                    // Optimization: If the TOP RIGHT  zone has no data rows, don't bother measuring its height.
                    var top = (this.zones._TR && this.zones._TR.cp.rc) ? br.offsetTop : 0,
                        newHeight = height - top;
                    if (newHeight > 0) {
                        ss.height = newHeight + 'px';
                        this.scrollboxHeight = newHeight;
                        this.scrollboxHeightFixed = true;

                        // When numRowFixed is true, the xtab does not have a fixed height value. The table can grow based on the height of its content
                        // Because lock header case the row header zone can be longer than the scrollbar height, that will cause the xtab to have a big
                        // margin under the grid. We need to set the xtab size as big as the scrollbox height + title rows height to avoid the blank space.
                        if ((this.lockHeadersCase !== LOCK_OFF) && this.numRowFixed) {
                            this.viewport.style.height = this.overlayNode.style.height = (newHeight + top) + 'px';
                        }
                    }
                }

                if (!this.useTouchScrolling) {
                    //#465070 - always set fixed width on scrollBox node to avoid unnecessary horizontal scrollbar :
                    // If 'width' is not defined in 'formats', then find it from the container cell. :
                    // Moved down this code block after 'height' setting so to get the scrollbox's v-scrollbar info correctly.

                    // How much room is left for the scrollbox? We assume the scrollbox's parentNode <td> has no padding, so the
                    // origin of the scrollbox and that <td> parentNode are the same. If the headers take up all the room in the scrollbox, do nothing in order to avoid incurring performance overhead.
                    // Optimization: If the BOTTOM LEFT zone has no data rows, don't bother measuring its width.
                    var left = (this.zones._BL && this.zones._BL.cp.rc) ? brc.offsetLeft : 0;

                    //if the r-cssDefault is applied to the Xtab, it might have extra padding and border width applied to the xtab-content div.
                    //we should remove the extra width applied to the xtab so that it can fit inside its container.
                    var adjustSum = 0;
                    if (this.lockHeadersCase !== LOCK_OFF) {
                        //adjust the new width with grid border width and paddings
                        var vp = this.viewport,
                            cs = mstrmojo.css.getComputedStyle(vp),
                            metrics = ['paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth'];
                        if (cs) {
                            mstrmojo.array.forEach(metrics, function (v) {
                                adjustSum += parseFloat(convertEmtoPx(vp, cs[v]));
                            });
                        }
                        //decrease the extra width brought to the Xtab due to the r-cssDefault css
                        if (this.width) {
                            this.viewport.style.width = (parseFloat(this.width) - (adjustSum || 0)) + 'px';
                        }
                    }

                    //Get real width in pixel:
                    var newWidth = (this.widthLimit && (this.widthLimit - left)) || (mstrmojo.dom.isIE7 ? brc.scrollWidth + 1 : (brc.scrollWidth + (sb.offsetWidth - sb.clientWidth))); //#467211 - add IE7 case.
                    if (newWidth && (newWidth > 0)) {
                        newWidth -= adjustSum;
                        ss.width = newWidth + 'px';
                    }

                    // Resizing the scrollboxNode may have caused it scroll position to change, due to a browser quirk.  So we must align the headers with the latest scroll position.
                    this._alignHeaders(bForceRepaint);
                }

                // Did we set a height or width on the scroll box?
                var finalHeight = ss.height,
                    finalWidth = ss.width;
                if (finalHeight || finalWidth) {
                    // Get a reference to the container ancestor responsible for  can grow/shrink.
                    var container = mstrmojo.findAncestor(this, 'fixedSizeCanGrowShrink', null, mstrmojo.DocSection);
                    if (container) {
                        // Notify the container that this widget has at least one fixed dimension.
                        container.fixedSizeCanGrowShrink(this, finalHeight, finalWidth);
                    }
                }

            },

            _resizeScrollBoxWidth: function _resizeScrollBoxWidth() {
                // Do we have a scrollboxNode and a viewport? If not, exit.
                var sb = this.scrollboxNode,
                    ss = sb && sb.style,
                    br = this._B_ROW,
                    brc = this._BR_CELL;
                if (this.useTouchScrolling || !ss || !br || !brc) {
                    return;
                }

                // Now resize the scrollbox to fit within the div. We need the size of the grid div for this calculation.
                // Read our current height & width properties. Assume that values are in pixels; null or non-numeric values are considered "auto".
                // TO DO: enhance to support percents or other units.
                var width = this.widthLimit;
                // If the height or width was just set to auto, then we'll need to measure it.
                if (!width) {
                    ss.width = 'auto';
                }

                var fnUpdatetWidth = function() {
                    //Get real width in pixel:
                    var newWidth = (mstrmojo.dom.isIE7 ? brc.scrollWidth + 1: (brc.scrollWidth + (sb.offsetWidth - sb.clientWidth))); //#467211 - add IE7 case.
                    //#475879 only if the inner table width is larger than or equal to the scrollbox node width, we need to adjust the width so that scrollbar can display properly
                    //AND we should not allow the adjusted width exceed the format width
                    if ((newWidth && (newWidth > 0)) && (!width || (width && (newWidth < width))) && (sb.firstChild.firstChild.offsetWidth >= sb.clientWidth)) {
                        ss.width = newWidth + 'px';
                    }
                };

                //Fix to #467876 set timeout after meanusring newWidth but just delay the apply which does not seem correct now, so we try to set timeout for measuring instead.
                if (mstrmojo.dom.isIE7) {
                    window.setTimeout(function(){fnUpdatetWidth();}, 1);
                } else {
                    fnUpdatetWidth();
                }

            },

            /**
             * The function responses the width change of the xtab. The boolean value indicates whether the scroll box needs to be updated.
             * If the boolean is not set, we need to resize the scroll box width.
             *
             * @param {Boolean} noScrollBoxChange
             */
            onGridWidthChanged: function onGridWidthChange(noScrollBoxChange) {

                //#475923 update scrollbox width only when lock is off
                if (this.lockHeadersCase === LOCK_OFF && !noScrollBoxChange) {
                    this._resizeScrollBoxWidth();
                }

                // Get a reference to the container ancestor responsible for  can grow/shrink.
                var container = mstrmojo.findAncestor(this, 'fixedSizeCanGrowShrink', null, mstrmojo.DocSection),
                    widthLimit = this.widthLimit;

                //once grid width is changed and if the grid width is fit to content, we need to reset the width
                //we set an unset value here in order to delay setting the value. The value is set when we need to read it
                if (!widthLimit) {
                    this.width = UNSET;

                    // Did we find a container for can grow and shrink?
                    if (container) {
                        // Tell the container to perform dynamic can grow and shrink.
                        container.performCanGrowCanShrink([ this ], true);
                    }
                } else if (container) {
                    // Notify the container that this widget has at least one fixed dimension.
                    container.fixedSizeCanGrowShrink(this, null, widthLimit);
                }
            },

            /**
             * Get the current Grid dimension. To avoid performance impact, we set the value when we need to read it.
             * We don't need the similar function for grid height because once the grid height is set, it stays.
             *
             * @param {Integer} dimension An enumeration which refers to the number 1 as height and 2 as width.
             */
            getGridDimension: function getGridDimension(dimension) {
                var DIM_HEIGHT = 1, /* DIM_WIDTH = 2 */
                    dim = dimension === DIM_HEIGHT ? 'Height' : 'Width',
                    dimLC = dim.toLowerCase(),
                    limit = this[dimLC + 'Limit'];

                if (!limit && (this[dimLC] === UNSET || this[dimLC] === 0)) {
                    limit = this.viewport['offset' + dim];
                    this[dimLC] = limit + 'px';
                    return limit;
                }

                return limit || parseInt(this[dimLC], 10);
            },

            /**
             * Implements the illusion of "locked" headers for rows and/or columns by aligning the header XtabZone children (if any) with our scrollbox's
             * current scroll position.
             *
             * @param {Boolean} bForceRepaint
             */
            _alignHeaders: function syncHeaders(bForceRepaint) {
                // For lock headers OFF case, we shouldn't need this.
                // and if we are using touch scrolling, we should not change scrollbox values to align the zones.
                if (this.lockHeadersCase === LOCK_OFF || this.useTouchScrolling) {
                    return;
                }

                // Assume the current scroll coordinates have been cached to local properties on this widget (thanks to the _HasScrollbox mixin).
                var left = this.scrollboxLeft,
                    top = this.scrollboxTop,
                    zs = this.zones,
                    trz = zs._TR,
                    blz = zs._BL;

                /**
                 * Now adjust the position of the header zones to align properly.
                 * This method will be used to apply a style property to each zone's domNode.
                 *
                 * @param {mstrmojo.XtabZone} zone
                 * @param {String} prop
                 * @param {Integer} v
                 *
                 * @inner
                 */
                function set(zone, prop, v) {
                    var el = zone && zone.domNode,
                        s = el && el.style;
                    if (!s) {
                        return;
                    }
                    s[prop] = -v + "px";
                }

                // Sync the topRight slot.
                if (trz && trz.rc) {
                    set(trz, 'left', left);
                }
                // Sync the bottomLeft slot.
                if (blz && blz.rc) {
                    set(blz, 'top', top);
                }

                // TQMS 393836. IE has some problem rendering the grid when the container has overflow:hidden and the inner div has position:relative.
                // Force to repaint to enable the grid to be displayed. We removed some force repaint code which used to re-adjust the position.
                // If the following force repaint code cannot solve the browser quirk problem for IE, we might rollback our changes.
                if (bForceRepaint) {
                    repaint(this._BL);
                }
            },

            /**
             * Performs the default action (if any) on the given cell. In the event that the cell is not provided, it will
             * get the cell from the td {HTMLTableCell} element.
             *
             * @param {HTMLTableCell} td The table cell used to trigger the default action.
             * @param {HTMLTableCell} tCell The actual cell node from the JSON.
             *
             * @returns Boolean True if an action was performed, False if not.
             */
            defaultAction: function defaultAction(td, tCell) {
                // Retrieve the action from the model.
                var cell = tCell || this.getCellForNode(td),
                    //TQMS 754231. We cannot rely on the _currentSelectedTD because grid can be
                    //re-loaded due to some selection actions.
                    isReselectingTD = td && td.className.indexOf('sc_') > 0,
                    action = this.model.getAction(this.getActionCells(cell), td, isReselectingTD),
                    handler = action && action.h;

                // Remember the last selected id
                this._currentSelectedTD = td;

                // Do we have a handler and does our controller support this handler?
                if (handler && this.controller[handler]) {
                    // Call the handler (passing in the action).
                    this.controller[handler](this, action.a);
                    return true;
                }

                // Return false to indicate that an action was not performed.
                return false;
            },

            createZone: function createZone(cfg) {
                return new mstrmojo.XtabZone(cfg || {});
            },

            /**
             * This method is called from postRender to initialize the Xtab's children and prepare
             * them for rendering.  The children are assumed to be 4 XtabZones.
             * TO DO: support for re-render; we'll probably need to destroy or re-use existing children.
             */
            _setupZones: function _setupZones(gd) {
                // Initialize a new "zones" lookup hash.
                // We'll populate it with the newly instantiated XtabZone children.
                var oldsz = this.zones;

                // reset zones now.
                this.zones = {};

                // shared variable for closure function below.
                var zs = this.zones,
                    l = this.lockHeadersCase,
                    zIndex = 'z-index:';

                var me = this;
                /**
                 * This function will be used to instantiate the new child widgets.
                 *
                 * @param {Integer} rm
                 * @param {String} style
                 * @param {String} slot
                 * @param {String} oldsz
                 *
                 * @inner
                 */
                function newz(rm, style, slot, oldsz) {
                    var zone = (oldsz && oldsz[slot]) || me.createZone({
                        renderMode: rm,
                        cssText: style,
                        slot: slot
                    });

                    zs[slot] = zone;
                    // pass the row height.
                    zone.rh = gd.rh;
                }

                // if lock headers is OFF, pass on the CSS class to the zones also so that the inner table (bottom right) would have it to.
                // todo2 - what about lock header cases ? would we need to split the border settings among different tables ?

                // Create the zones; only the ones needed, depending upon lock headers setting.
                newz(this.dataRenderMode, zIndex + '1;', "_BR", oldsz);
                if (l & LOCK_ROW) {
                    newz(this.dataRenderMode, zIndex + '3;', "_BL", oldsz);
                }
                if (l & LOCK_COL) {
                    newz(null, zIndex + '3;', "_TR", oldsz);
                }
                if (l === LOCK_BOTH) {
                    newz(null, zIndex + '4;', "_TL", oldsz);
                }

                // For lock headers OFF, set up the autoFitToWindow.
                if (l === LOCK_OFF) {
                    this.zones._BR.autoFitWindow = !!gd.afw;
                    this.zones._BR.tableCssClass = "r-cssDefault" + (this.k ? "_" + this.k : '');
                }

                //#491704,#501565 - gab between textbox and grid
                if (mstrmojo.dom.isIE7) {
                    if (l & LOCK_ROW || l & LOCK_COL || l === LOCK_BOTH) {
                        this._T_ROW.style.display = 'block';
                    } else if (l === LOCK_OFF) {
                        this._T_ROW.style.display = 'none';
                    }
                }

                var bz = zs._BL || zs._BR;
                if (bz) { // set numColumnCanMerge for the grid
                    bz.numColumnCanMerge = gd.gts.cws.length - 1;
                }
            },

            getHACP: function getHACP() {
                return (this._super && this._super()) || new mstrmojo.XtabHACP();
            },

            /**
             * Instantiates content providers for each zone, and assigns them to the corresponding zone.
             * Assumes zones have already been instantiated.
             *
             * @param {Object} gd Grid JSON.
             */
            _setupCPs: function _setupCPs(gd) {
                // Create the four non-aggregate content providers, one per zone.
                var titlesCP = this.titlesCP = this.getTitleCP(gd),
                    chsCP = this.chsCP = this.getColumnHeadersCP(gd),
                    rhsCP = this.rhsCP = this.getRowHeadersCP(gd),
                    valuesCP = this.valuesCP = this.getValuesCP(gd);

                // forceAutoHeight for titles and colHeader sections, if there is a fixed row height.
                titlesCP.forceAutoRowHeight = chsCP.forceAutoRowHeight = gd.rh;

                // Now create any aggregate content providers, if needed, to support locked headers.
                // Then assign a content provider to each zone.
                var zs = this.zones;

                switch (this.lockHeadersCase) {
                case LOCK_OFF:
                    // create two horizontal aggregated content providers. And an aggregated vertical provider on top of them.
                    var vacp = new mstrmojo.XtabVACP();

                    // titles and col headers for first one.
                    var hacpTop = this.getHACP();
                    hacpTop.cps = [titlesCP, chsCP];
                    vacp.cps = [hacpTop];

                    var hacpBottom = this.getHACP();
                    hacpBottom.cps = [rhsCP, valuesCP];
                    vacp.cps.push(hacpBottom);

                    // associate aggregate content provider with the values zone.
                    zs._BR.cp = vacp;
                    break;

                case LOCK_ROW:
                    // create two vertical aggregated content providers.
                    var acpLeft = new mstrmojo.XtabVACP();
                    var acpRight = new mstrmojo.XtabVACP();

                    // titles and row headers for first one.
                    acpLeft.cps = [titlesCP, rhsCP];

                    // col headers and values on the other one.
                    acpRight.cps = [chsCP, valuesCP];

                    // associate aggregate content provider with the values zone.
                    zs._BL.cp = acpLeft;
                    zs._BR.cp = acpRight;
                    break;

                case LOCK_COL:
                    // create two horizontal aggregated content providers.
                    var acpTop = this.getHACP();
                    var acpBottom = this.getHACP();

                    // titles and col headers for first one.
                    acpTop.cps = [titlesCP, chsCP];

                    // row headers and values on the other one.
                    acpBottom.cps = [rhsCP, valuesCP];

                    // associate aggregate content provider with the values zone.
                    zs._TR.cp = acpTop;
                    zs._BR.cp = acpBottom;
                    break;

                case LOCK_BOTH:
                    zs._TL.cp = titlesCP;
                    zs._TR.cp = chsCP;

                    zs._BL.cp = rhsCP;
                    zs._BR.cp = valuesCP;
                    break;

                }
            },

            ongridDataChange: function ongridDataChange() {
                // Do we have a model?
                var m = this.model;
                if (m) {
                    // Cascade the data to the model.
                    m.set('data', this.gridData);

                    if (!this.dataBlocks) {
                        this.dataBlocks = [];
                    }
                    this.dataBlocks[0] = this.gridData;
                }
            },

            gridPagesRendered: mstrmojo.emptyFn,

            /**
             * Get the title content provider
             */
            getTitleCP: function getTitleCP(gd) {
                return this.initCP(gd, this.interactiveCellsArray, CP_TITLE);
            },

            /**
             * Get the column headers content provider
             */
            getColumnHeadersCP: function getColumnHeadersCP(gd) {
                return this.initCP(gd, this.interactiveCellsArray, CP_COL_HEADERS, gd.ghs.chs, gd.gts.col, COL_AXIS);
            },

            /**
             * Get the row headers content provider
             */
            getRowHeadersCP: function getRowHeadersCP(gd) {
                var rhsCP = this.initCP(gd, this.interactiveCellsArray, CP_ROW_HEADERS, gd.ghs.rhs, gd.gts.row, ROW_AXIS);

                // If we allow incremental fetch and result window is not empty
                if (this.onDemandIF && this.rw) {
                    if (!this._onDemandCP) {
                        addOnDemandCPs.call(this, this.rw && this.rw.row); // the function will prepare both rhsCPList and valuesCPList
                    }
                    this.rhsCPList = [rhsCP].concat(this._onDemandCP.rhs);
                    return onDemandCPAgg(this.rhsCPList) || rhsCP;
                }

                return rhsCP;
            },

            /**
             * Get the metric value content provider
             */
            getValuesCP: function getValuesCP(gd) {
                var valuesCP = this.initCP(gd, this.interactiveCellsArray, CP_VALUES, gd.gvs);

                // if we allow incremental fetch, then we need to set up ondemand content providers
                if (this.onDemandIF && this.rw) {
                    // If we have incremental fetch and content provider list is empty
                    if (!this._onDemandCP) {
                        addOnDemandCPs.call(this, this.rw && this.rw.row);
                    }
                    this.valuesCPList = [valuesCP].concat(this._onDemandCP.vls);

                    return onDemandCPAgg(this.valuesCPList) || valuesCP;
                }

                return valuesCP;
            },

            /**
             * Creates on demand content provider
             *
             * @param {Integer} blockNum block number
             * @param {Integer} rc row count
             * @param {Integer} zone CP_ROW_HEADERS or CP_VALUES
             * @returns {Object} OnDemandCP
             */
            createOnDemandCP: function createOnDemandCP(blockNum, rc, zone) {
                var cp =  new mstrmojo.XtabOnDemandCP();
                cp.dataSource = this;
                cp.blockNum = blockNum;
                cp.rc = rc;
                return cp;
            },

            /**
             * @param {Object} node RW JSON Data Node.
             * @param {Object} memo
             */
            dataDownloaded: function dataDownloaded(node, memo) {
                // find our on demand content providers.
                var idx = memo.blockNum,
                    rhsCP = this.rhsCPList[idx],
                    valuesCP = this.valuesCPList[idx],
                    gd = node.data;

                gd._bidx = idx;
                this.dataBlocks[idx] = gd;

                if (!rhsCP || !valuesCP) {
                    return;
                }

                // initialize the CP with the necessary grid data nodes and properties.
                this.initCP(gd, this.interactiveCellsArray, CP_ROW_HEADERS, gd.ghs.rhs, gd.gts.row, ROW_AXIS, rhsCP);
                this.initCP(gd, this.interactiveCellsArray, CP_VALUES, gd.gvs, null, null, valuesCP);

                // trigger initContent on the CP (this will ensure that properties like rowCount, colWidths are initialized on the CP using the newly downloaded data).
                rhsCP.initContent();
                valuesCP.initContent();

                // update the status bar, if visible.
                this.numRowsDownloaded += parseInt(rhsCP.rc, 10);
                this.updateStatus(mstrmojo.desc(8301, "Retrieving Data ..."), this.numRowsDownloaded * 100 / this.numRowsToDownload);

                var zs = this.zones,
                    bl = zs && zs._BL,
                    br = zs && zs._BR;

                // our bottom left and bottom right are the only downloadable zones. So, we just ask the ones present (non null or undefined) to handle the download.
                if (bl) {
                    bl.dataDownloaded();
                }
                if (br) {
                    br.dataDownloaded();
                }
            },

            // todo1 - status bar code needs to be cleaned !!!!
            /**
             * @param {Integer} numRowsToDownload
             */
            showDownloadStatus: function shwRndrSts(numRowsToDownload) {
                // if numRowsToDownload is 0, we should not do anything
                if (!numRowsToDownload) {
                    return;
                }

                // if already showing status, it means there are new rows to download.
                if (this.showingStatus) {
                    this.numRowsToDownload += numRowsToDownload;
                } else {
                    // otherwise this is a fresh set of rows to download.
                    this.numRowsToDownload = numRowsToDownload;

                    // initialize the variable indicating number of downloaded rows.
                    this.numRowsDownloaded = 0;
                }

                if (this.showStatus) {
                    this.showStatus(true, mstrmojo.desc(8301, "Retrieving Data ..."), this.numRowsDownloaded * 100 / this.numRowsToDownload);
                }
            },

            closeDownloadStatus: function closeSts() {
                this.numRowsToDownload = 0;
                if (this.showStatus) {
                    this.showStatus(false);
                }
            },

            /**
             * @param {Integer} blockNum
             */
            download: function download(blockNum) {
                // get the result window.
                var rw = this.gridData.rw,
                    rwRow = rw.row,
                    rwCol = rw.col,
                    maxRows = rwRow.bc;

                // The download we are about to trigger will feed multiple areas (row headers and values). So, we mark both of them. That way we will avoid double data fetch.
                this.rhsCPList[blockNum].isDownloading = this.valuesCPList[blockNum].isDownloading = true;

                // if max rows is zero or undefined, nothing to download really.
                if (maxRows) {
                    // note the start row index is 1 (not 0).
                    this.controller.onDownloadGridData(this, this.model.getDownloadAction(blockNum * maxRows + 1, maxRows, rwCol.bb, rwCol.bc, this.id, {
                        blockNum: blockNum
                    }));
                }
            },

            unrender: function unrender(ignoreDom) {
                //Reset the height, width properties
                this.width = this.widthLimit = this.height = this.heightLimit = 0;

                // detach listeners to scrollboxNode, if any; that allows us
                // to reattach to a new scrollboxNode after a re-render later.
                this.disconnectScrollbox(this);
                this._super(ignoreDom);
            },

            /**
             * Returns the interactivity data (if any) for a given HTML table cell DOM node.
             *
             * @param {HTMLElement} td The table cell in question.
             *
             * @returns {Object} An interactive cells object containing information about the cell.
             */
            getCellForNode: function getCellForNode(td) {
                var idx = td && td.getAttribute('ei');
                if (isNaN(idx)) {
                    return null;
                }
                var t = this.interactiveCellsArray[parseInt(idx, 10)];
                return t;
            },

            /**
             * Returns an array of selected cells.
             *
             * @param {object} cell The interactive cell that initiated the action
             * @returns {Array} An array of selected cells.
             */
            getActionCells: function getActionCells(cell) {
                var cells = [],
                    selections = this.selections;

                var titleId = cell.axis + 'A' + (cell.ui + 1),
                    selTitle = selections[titleId],
                    i;

                if (selTitle && selTitle[cell.o]) {
                    for (i in selTitle) {
                        var sc = this.getCellForNode(selTitle[i][0]); //In multiple form case, we only need to add it once
                        cells.push(sc);
                    }
                } else {
                    cells.push(cell);
                }
                return cells;
            },

            setModel: function setModel(model) {
                this.model = model;
                if (model.data) {
                    this.set('gridData', model.data);
                }
            },

            destroy: function destroy() {
                var model = this.model;
                if (model && model.destroy) {
                    model.destroy();
                }
                this._super();
            }

        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocButton",
                         "mstrmojo._HasDrillLinks",
                         "mstrmojo.ui.MobileCheckList",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.dom",
                         "mstrmojo.array");

    /**
     * Updates the pressed state.
     *
     * @param {Boolean} isPressed True if button state should be pressed.
     *
     * @private
     */
    function setPressedState(isPressed) {
        // Change pressed state.
        this.set('pressed', isPressed);
    }
    
    /**
     * Convert hex color code to RGBA color code with alpha parameter.
     *
     * @param {String} hex color code to be parsed.
     * @param {Number} alpha value.
     *
     * @private
     */
    function hexToRgba(hex, alpha) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ?  
            "rgba(" + 
            parseInt(result[1], 16) + "," +
            parseInt(result[2], 16) + "," +
            parseInt(result[3], 16) + "," +
            alpha + ")"
            : '';
    }

    /**
     * Execute the supplied link on the document model.
     *
     * @param {String} link The URL of the link to execute.
     *
     * @private
     */
    function executeLink(link) {
        this.model.executeLink(link, this.target, this);
    }

    /**
     * <p>Displays the list of links associated with this button.</p>
     *
     * <p>If there is only one link it will directly execute that link.</p>
     *
     * @private
     */
    function showLinkList() {
        var drillLinks = this.drillLinkItems,
            id = this.id;

        // Do we have only one link?
        if (drillLinks.length === 1) {
            // Make sure pressed state doesn't linger.
            setPressedState.call(this, false);
            
            // Execute it.
            executeLink.call(this, drillLinks[0].url);
            return;
        }

        // Set flag to indicate list is open.
        this._linksOpen = true;

        // Muliple links so show the list.
        mstrApp.showDialog({
            title: this.defn.n,
            children: [{
                scriptClass: 'mstrmojo.ui.MobileCheckList',
                items: drillLinks,
                multiSelect: false,
                isElastic: true,
                hasEvenRows: true,
                postselectionChange: function (evt) {
                    // Close the dialog.
                    mstrApp.closeDialog();

                    // Execute selected link.
                    executeLink.call(mstrmojo.all[id], drillLinks[evt.added[0]].url);
                }
            }],
            onClose: function () {
                var btn = mstrmojo.all[id];

                // Set pressed state to false.
                setPressedState.call(btn, false);

                // Clear open flag.
                delete btn._linksOpen;
            },
            buttons: [ mstrmojo.android.ui.Button.newButton(mstrmojo.desc(221, 'Cancel')) ]
        });
    }
    
    /**
     * <p>The widget for a single MicroStrategy Report Services Button within the Express mode application.</p>
     *
     * @class
     *
     * @extends mstrmojo.DocButton
     * @borrows mstrmojo._HasDrillLinks
     */
    var $BTN = mstrmojo.android.ui.DocButton = mstrmojo.declare(
        mstrmojo.DocButton,

        [ mstrmojo._HasDrillLinks ],

        /**
         * @lends mstrmojo.android.ui.DocButton.prototype
         */
        {
            scriptClass: "mstrmojo.android.ui.DocButton",

            touchBegin: function touchBegin() {
                // Is the link disabled?
                if (!this.linkEnabled) {
                    // Return false to cancel this touch.
                    return false;
                }

                // Change pressed state.
                setPressedState.call(this, true);

                return true;
            },

            touchTap: function touchTap() {
                if(this.ifw) {
                    this.model.showInfoWin(this.ifw, (this.getAnchor && this.getAnchor()) || this.domNode, 'v');
                    return;
                }
                
                var dl = this.drillLinkItems,
                	length = (dl && dl.length) || 0;
                
	            if(length > 0) {
	                // Display the list of links.
	                showLinkList.call(this);
	            }
            },

            touchSelectBegin: function touchSelectBegin() {
                this.touchTap();
            },

            touchEnd: function touchEnd() {
                // Is the link dialog NOT open?
                if (!this._linksOpen) {
                    // Clear pressed state.
                    setPressedState.call(this, false);
                }
            },
            
            setBackgroundColor: function setBackgroundColor() {
                var isPressed = !!this.pressed,
                defn = this.defn,
                domNode = this.domNode,
                fmts = this.fmts,
                containerNodeStyle = this.buttonContainerNode.style,
                domNodeStyle = this.domNode.style,
                containerColor = isPressed ? defn.bhlc : (fmts['background-color'] || ''),
                domColor = isPressed ? hexToRgba(defn.bhlc, 0.4) : '';
                
                containerNodeStyle.backgroundColor = containerColor;
                containerNodeStyle.borderColor = containerColor;
                domNodeStyle.borderColor = domColor;
                domNodeStyle.backgroundColor = domColor;
            },

            
            getDPI: function getDPI() {        
                return mstrMobileApp.getDeviceDPI();
            }
        }
    );

    // Strip "mstrAttach" event handler tokens from markup string.
    $BTN.prototype.markupString = $BTN.prototype.markupString.replace(new RegExp(' mstrAttach:[a-zA-Z,]*'), '');

    // Strip out padding and border format handlers for DOM node.
    $BTN.prototype.formatHandlers.domNode = mstrmojo.array.filter([].concat($BTN.prototype.formatHandlers.domNode), function (prop) {
        return (prop !== 'P' && prop !== 'B');
    });
}());
(function() {
    mstrmojo.requiresCls("mstrmojo.TableLayoutList");

    /**
     * <p>A mixin for adding specific behavior to subclasses of {@link mstrmojo._TableLayoutList}.</p>
     *
     * @class
     * @public
     */
    mstrmojo._IsTableLayoutListDIC = mstrmojo.provide(

        "mstrmojo._IsTableLayoutListDIC",
        /**
         * @lengs mstrmojo._IsTableLayoutListDIC.prototype
         */
        {
            _mixinName: 'mstrmojo._IsTableLayoutListDIC',

            icnCss: 'dicContainer',
            
            tableLayoutCssStyle: 'fixed',
            
            // provide setDirtyFlag function for TableLayoutList DICs on FG
            setDirtyFlag: function(c, d) {
                if (c.className !== 'flag-container') {
                    var f = document.createElement('div'), w = this.itemsNode
                            && this.itemsNode.clientWidth - 8;
                    f.className = 'flag-container';
                    f.style.left = (w > 0 ? w : 0) + 'px';
                    f.innerHTML = '<div class="dirty-cell"/>';
                    d.insertBefore(f, c);
                }
            }
        });
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo.ToolBar",
                         "mstrmojo.boxmodel",
                         "mstrmojo.array",
                         "mstrmojo.EnumRWUnitType",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var MOVE_FMTS = ['background-color',
                  'border',
                  'border-color',
                  'border-left',
                  'border-style',
                  'border-top',
                  'border-width',
                  'filter',
                  'top',
                  'left',
                  'z-index',
                  'fx',
                  'normWidth',
                  'normHeight',
                  'normZIndex',
                  'normTop',
                  'normLeft',
                  'tbborder',
                  'lrborder',
                  'ttl'],
        COPY_FMTS = ['width', 'height'],
        P_FMTS = 'p_fmts';

    var $PX = 'px';

    /**
     * Embedded Title Strategy.
     */
    var ETS = {
        /**
         * parameters:
         * h for height available for contente without considering title
         * f the format for the portlet
         */
        getContentHeight: function (h, f) {
            var th = f.ttl && f.ttl.height;
            if (h && th && !this.floatingToolbar) {
                // Reduce domNode height by title height (minimum of zero).
                return Math.max(parseInt(h, 10) - parseInt(th, 10), 0) + $PX;
            }

            return '';
        },

        getPortletMinHeight: function (f) {
            return f.ttl.height;
        },

        adjustTitleCss: function (ptlt) {
            return;
        }
    };

    /**
     * Floating Title Strategy.
     */
    var FTS = {
        getContentHeight: function (h, f) {
            return h;
        },
        getPortletMinHeight: function () {
            return 0;
        },
        adjustTitleCss: function (ptlt) {
//                var avail = parseInt(ptlt.getFormats().top, 10),
//                    min = ptlt.floatingTitleHeight;
//                ptlt.titlebarNodeCssText += 'top:-' + (avail > min ? min: 0) + 'px;' + 'height:' + min + 'px;' + 'z-index:' + ptlt.getFormats()['z-index'];
            ptlt.titlebarNodeClass += ' floating';
            return;
        }
    };

    /**
     * Passes the key to the parent if the parent implements the indicated method.
     *
     * @param {String} method Either "add" or "remove".
     * @param {String} key The key of the dirty (or clean) child.
     *
     * @private
     */
    function passDirtyKey(method, key) {
        var parent = this.parent,
            methodName = method + 'DirtyKey';

        if (parent[methodName]) {
            parent[methodName](key);
        }
    }


    function updateTitle() {
        // Default title.
        var title = this.title;

        // Is there more than one?
        if (this.count) {
            // Add count to title.
            title += ' ' + this.count;
        }

        // Replace title bar content with new title.
        this.toolbarTitleTextNode.innerHTML = title;
    }

    function retrieveFilterPanel() {
        // Get parent and parent definition.
        var parent = this.parent,
            parentDefn = parent && parent.defn;

        // Do we have a parent and is it a panel?
        if (parentDefn && parseInt(parentDefn.t, 10) === mstrmojo.EnumRWUnitType.PANEL) {
            // Get panel stack and panel stack definition.
            var panelStack = parent.parent,
                panelStackDefn = panelStack.defn;

            // Is the panel stack definition "ifp" property true?
            if (panelStackDefn && panelStackDefn.ifp) {
                // Panel stack is filter panel.
                return panelStack;
            }
        }

        return null;
    }

    var $HASH = mstrmojo.hash,
        ITEM_SPA = 2;

    mstrmojo.DocPortlet = mstrmojo.declare(
        // super
        mstrmojo.Container,

        // mixin
        [mstrmojo._Formattable],

        // instance properties and methods
        {
            scriptClass: 'mstrmojo.DocPortlet',
            /**
             * Whether the title bar should be floating or not.
             */
            floatingTitle: false,
            /**
             * To support floating title, this widget needs to know the height of the title bar.
             * Of type of integer, unit in pixels.
             */
            floatingTitleHeight: 30,
            /**
             * To correctly place title (espectially for the long title), we need to correctly size the buttons toolbar.
             * Of type of integer, unit in pixels.
             */
            buttonWidth: 17,

            markupString:
                '<div class="mstrmojo-portlet {@borderCss}" style="{@portletNodeCssText}">' +
                    '<div class="mstrmojo-portlet-slot-shadow" style="{@shadowNodeCssText}"></div>' +
                    '<div class="mstrmojo-portlet-container" style="{@portletContainerNodeCssText}">' +
                        '<div class="mstrmojo-portlet-titlebar {@titlebarNodeClass}" style="{@titlebarNodeCssText}">' +
                            '<table style="height:100%;width:100%" class="mstrmojo-portlet-titlebar-table" cellspacing="0" cellpadding="0">' +
                            '<tr>' +
                                '<td class="mstrmojo-portlet-slot-toolbar-left {@leftToolbarNodeClass}" style="{@leftToolbarNodeCssText}"></td>' +
                                    '<td class="mstrmojo-portlet-title" style="{@titleNodeCssText}"><div style="overflow: hidden;">{@title} {@count}</div></td>' +
                                '<td class="mstrmojo-portlet-slot-toolbar {@toolbarNodeClass}" style="{@rightToolbarNodeCssText}"></td>' +
                                '</tr>' +
                            '</table>' +
                        '</div>' +
                        '<div class="mstrmojo-portlet-buttonbar {@buttonbarNodeClass}" style="{@buttonbarNodeCssText}"></div>' +
                        '<div class="mstrmojo-portlet-slot-content" style="{@contentNodeCssText}"></div>' + //Xtab/Graph/PanelStack/StackContainer goes here.
                    '</div>' +
                '</div>',

            rightToolbarNodeCssText: '',
            leftToolbarNodeCssText: '',
            titleNodeCssText: '',
            titlebarNodeClass: '',
            titlebarNodeCssText: '',
            contentNodeCssText: '',
            borderCss: 'no-border',
            buttonbarNodeClass: '',
            buttonbarNodeCssText: '',
            markupSlots: {
                containerNode: function () {return this.domNode.lastChild; }, // TODO check with GB whether this is right
                portletNode: function () {return this.domNode; },
                portletContainerNode: function () {return this.domNode.lastChild; },
                dimNode: function () {return this.domNode.lastChild; }, // the node really carry the dimension information, sub section needs this information to perform auto shrink/grow.
                shadowNode: function () { return this.domNode.firstChild; },
                titleNode: function () {return this.domNode.lastChild.childNodes[0]; },
                buttonbarNode: function() {return this.domNode.lastChild.childNodes[1];},
                toolbarNode: function () { return this.domNode.lastChild.firstChild.childNodes[0].rows[0].cells[2]; }, // actually this is right toolbar
                toolbarTitleTextNode: function () { return this.domNode.lastChild.firstChild.childNodes[0].rows[0].cells[1].firstChild; },
                leftToolbarNode: function () { return this.domNode.lastChild.firstChild.childNodes[0].rows[0].cells[0]; },
                contentNode: function () { return this.domNode.lastChild.lastChild; }
            },

            markupMethods: {
                ontitleChange: function(){
                    updateTitle.call(this);
                },
                oncountChange: function () {
                    updateTitle.call(this);
                },
                onfcChange: function () {
                    if (this.fc && this.content) {
                        this.updateContentHeight();
                    }
                }
            },

            formatHandlers: {
                //portletNode : ['T', 'z-index'],
                portletContainerNode: [ 'RW', 'B'], // must contains D, since contained widget would have absolute position, which can not tell correct size.
                shadowNode: [ 'RW', 'B', 'fx', 'background-color' ], // must contains D, since contained widget would have absolute position, which can not tell correct size.
                titlebarNode: {
                        src: 'ttl',
                        props: ['F', 'B', 'background-color', 'height', 'fx', 'text-align', 'vertical-align']
                    },
                titleNode : {
                    src: 'ttl',
                    props: ['vertical-align', 'P', 'text-decoration']
                },
                buttonbarNode: {
                     src: 'ttl',
                     props: ['background-color']
                }
            },

            /**
             * Flag to indicate whether content widget is in Fixed or Fit-to-Content height mode.
             * If Fixed height mode, 'height' comes from 'fmts';
             * If Fit-to-content mode, use content's dimNode to find content height, and set this property to '1' to update portlet container & ahadow nodes.
             */
            fc: false, //Fix height mode

            /**
             * Property points to content widget.
             *
             */
            content: null,
            /**
             * Property points to the default toolbar widget.
             */
            rightToolbar: null,
            /**
             * Property points to the left toolbar widget.
             */
            leftToolbar: null,
            /**
             * Property indicates whether the toolbar should be embedded in the portlet or floating outside it
             */
            floatingToolbar: false,
            /**
             * The strategy for title related dimension calculation.
             */
            _ts: ETS,
            /**
             * Override getCacheKey to make portlet css cache do not collapse with embedded widget's css cache
             */
            getCacheKey: function getCacheKey(w){
                return this._super(w) + '-portlet';
            },
            /**
             * Override getFormats to return the formats, which we piggy back on content's formats collection
             */
            getFormats: function getFormats() {
                var c = this.content,
                f = c && c.getFormats();

                return f && f[P_FMTS];
            },

            updateContentHeight: function updateContentHeight(bHide) {
                var pf = this.getFormats(),
                    cnt = this.content,
                    node = cnt.dimNode  || cnt.domNode,
                    h = ((pf.ttl && parseInt(pf.ttl.height, 10)) || 0);

                if (node){
                    if (!bHide) {
                        h += ((this.fc || this.isInFilterPanel()) ? node.offsetHeight : (pf.height ? parseInt(pf.height, 10) : 0));
                    }

                    this.containerNode.style.height = h + $PX;
                    this.shadowNode.style.height = h + $PX;
                }
            },


            /**
             * @see mstrmojo.Obj
             */
            init: function init(props) {
                //Call super
                this._super(props);

                var content = this.content;

                // Do we have a content node and does it have a formatting object? Have we not created the portlet's formatting object?
                // This cannot be done in preBuil Rendering because when we're incrementally rendering documents, we need the formats to determine whether the portlet is in the viewport.
                if (content && content.getFormats() && !this.getFormats()) {
                    // 1. build portlet's formats, if have not done.
                    this._createFormats();
                }
            },

            /**
             * In preBuildRendering, we are going to adjust width/height for content widget before it gets rendered
             */
            preBuildRendering: function preBuildRendering() {
                // Choose title related dimension calculation strategy.
                var ts = this._ts = (this.floatingTitle) ? FTS : ETS;

                //Call super
                this._super();

                // Adjust title appearance.
                ts.adjustTitleCss(this);

                var displayNone = "display:none;";

                if (this.isInFilterPanel()) {
                    var f = $HASH.clone(this.formatHandlers);
                    f.portletContainerNode = ['z-index', 'height', 'B', 'backgroud-color'];
                    f.shadowNode = ['z-index', 'height', 'B', 'fx', 'background-color'];
                    this.formatHandlers = f;
                }

                if (!this.leftToolbar){
                    this.leftToolbarNodeCssText += displayNone;
                }

                if (!this.toolbar){
                    this.toolbarNodeCssText += displayNone;
                }

                // Does the portlet have left, top or right border?
                var borderWidths = mstrmojo._Formattable.getBorderWidths(this);
                if (borderWidths.l || borderWidths.t || borderWidths.r) {
                    // Change border css to indicate that this portlet have a border.
                    this.borderCss = 'has-border';
                }
             },

            /**
             * If this has floating title, we need to move it to under the body node. TQMS #394036
             */
            postBuildRendering: function postBuildRendering() {
                    // attach event listener to mouse over/out the portlet node
                    var dom = mstrmojo.dom,
                        css = mstrmojo.css,
                        d = this.contentNode,
                        t = this.titleNode,
                        me = this;

                if (this.titleNode) {
                    if (this.floatingTitle) {
                        // move whole title under <body>
                        document.body.appendChild(this.titleNode);


                    if (!this._onhover){
                        // hover for toolbar
                        this._onhovertt = function() {
                            // make it visible
                            css.addClass(me.titleNode, ['visible']);
                            me._onflt = true;
                            return true;
                        };
                        // hover off for toolbar
                        this._onhoverofftt = function() {
                            css.removeClass(me.titleNode, ['visible']);
                            me._onflt = false;
                            return true;
                        };
                        // hover for portlet
                        this._onhover = function () {
                            var t = me.titleNode;
                            // make it visible
                            css.addClass(t, ['visible']);
                            // adjust position first
                            var p = dom.position(me.contentNode, true);
                            t.style.top = (p.y - t.clientHeight + 2) + $PX; // plus 2 to make sure the toolbar connects to the portlet, so moving to toolbar would not close it
                            t.style.left = p.x + $PX;
                            return true;
                        };
                        // hover off for portlet
                        this._onhoveroff = function () {
                            css.removeClass(me.titleNode, ['visible']);
                            return true;
                        };
                    }
                    dom.attachEvent(d, 'mouseover', this._onhover);
                    dom.attachEvent(d, 'mouseout', this._onhoveroff);
                    // attach listener for toolbar
                    dom.attachEvent(t, 'mouseover', this._onhovertt);
                    dom.attachEvent(t, 'mouseout', this._onhoverofftt);
                }

                    //attach contextmenu event
                    if (this.attachContextMenuEvent) {
                        // Handles rightclick to open context menu popup associated to the menuButton on the toolbar.
                        this._oncontextmenu = function (/*DomEvent*/ e, /*DomWindow*/ hWin) {
                            var btn = me.rightToolbar && me.rightToolbar.btnMenu;

                            if (btn) {
                                btn.cmPos = dom.getMousePosition(e, hWin);
                                btn.openPopupMenu();
                                btn.cmPos = null;

                                dom.preventDefault(hWin, e);
                            }
                        };
                        dom.attachEvent(t, 'contextmenu', this._oncontextmenu);
                    }
                }

                if (this._super) {
                    this._super();
                }

                //If content widget is in Fit-to-content height mode, use content height to solve background-color and shadow issue:
                var pf = this.getFormats();
                this.set('fc', pf && !pf.height);

                if (this.isInFilterPanel() && !this.isHorizFP()) {
                    var portletContainerNodeStyle = this.portletContainerNode.style,
                        shadowNodeStyle = this.shadowNode.style,
                        parent = this.parent;
                    portletContainerNodeStyle.width = shadowNodeStyle.width = '99%';
                    portletContainerNodeStyle.top = shadowNodeStyle.top = parent.topStart + $PX;
                    portletContainerNodeStyle.left = shadowNodeStyle.left = ITEM_SPA + $PX;
                }
                //#611526 - add some space bewteen portlets in horizontal filterPanel
                else if (this.isInFilterPanel() && this.isHorizFP()) {
                    ITEM_SPA = 8;

                    this.portletContainerNode.style.left = this.shadowNode.style.left = parseInt(pf.left) + ITEM_SPA * this.orgPos + $PX;
                }
                //TQMS#635977: fit the filter panel inside portlet by reducing its height by the height of the 'apply' button.
                else if (this.defn.ifp){
                	this.adjustFPHeight2Fit();
                }
            },
            adjustFPHeight2Fit: function(){
            	var dom = mstrmojo.dom,
            		ttl = dom.position(this.titleNode),
        			btn_h = dom.position(this.contentNode).y - ttl.y - ttl.h;
            	this.content.domNode.style.height = parseInt(this.defn.fmts.height) - btn_h + 'px';
            },
            /**
             * When unrender, we need to detach the event listerners we attached to DOM node.
             */
            unrender: function unrender(ignoreDom) {

                if (this.floatingTitle && this.titleNode) {
                    var d = this.domNode,
                        t = this.titleNode,
                    dom = mstrmojo.dom;

                    if (d && this._onhover){
                        dom.detachEvent(d, 'mouseover', this._onhover);
                    }
                    if (d && this._onhoveroff) {
                        dom.detachEvent(d, 'mouseout', this._onhoveroff);
                    }
                    // attach listener for toolbar
                    if (t && this._onhovertt) {
                        dom.detachEvent(t, 'mouseover', this._onhovertt);
                    }
                    if (t && this._onhoverofftt) {
                        dom.detachEvent(t, 'mouseout', this._onhoverofftt);
                    }
                    if (t && this._oncontextmenu) {
                        dom.detachEvent(t, 'contextmenu', this._oncontextmenu);
                    }

                    if(t) {
                        document.body.removeChild(t);
                    }
                }
                if (this._super) {
                    this._super(ignoreDom);
                }
            },

            updateStyle: function (h, w) {
                var snStyle = this.shadowNode.style,
                    cnStyle = this.containerNode.style;
                snStyle.height = cnStyle.height = h;
                snStyle.width = cnStyle.width = w;
            },

            /**
             * Builds portlet formats collection and adjusts content's formats collection
             *
             * @private
             */
            _createFormats: function _createFormats() {
                var c_f = this.content && this.content.getFormats(),
                    f;
                // create collection, which is piggy back on content's formats collection
                f = c_f.p_fmts = {};
                var i, p;
                // move certain properties
                for (i in MOVE_FMTS) {
                    p = MOVE_FMTS[i];
                    if (p in c_f) {
                        f[p] = c_f[p];
                        delete c_f[p];
                    }
                }
                // copy certain properties
                for (i in COPY_FMTS) {
                    p = COPY_FMTS[i];
                    if (p in c_f) {
                        f[p] = c_f[p];
                    }
                }
                // Q: Do we need to set top/left to 0?

                // adjust content height because of title
                c_f.height = this._ts.getContentHeight(c_f.height, f);

                // TQMS 392517, IE shows transparent shadow when the shadow does not have a background color.
                // if shadow exists but no background color, we set a default one on it
                if (mstrmojo.dom.isIE&&f.fx && f.fx.ds && !f['background-color']){
                    f['background-color'] = '#ffffff';
                }
            },

            /**
            * Manually calls refresh on all panels within this portlet.
            * @see mstrmojo.Widget
            */
            refresh: function refresh() {
                if (!this.hasRendered) {
                    return;
                }

                // Manually call refresh on all children rather than rebuild html for PanelStack.
                var c = this.children,
                    i;
                for (i = c.length - 1; i >= 0; i--) {
                    c[i].refresh();
                }
                // #727357. do not call refresh on parent class, otherwise it'll render all its
                // children one more time.
                // this._super();
            },

            isInFilterPanel: function isInFilterPanel() {
                return (retrieveFilterPanel.call(this) !== null);
            },

            isHorizFP: function(){
                if(this.isInFilterPanel()){
                    var fp = this.getFilterPanel();
                    return fp && fp.defn && fp.defn.fds == 2;
                }else{
                    return false;
                }
            },

            getFilterPanel: function getFilterPanel() {
                return retrieveFilterPanel.call(this);
            },

            getContainerHeight: function getContainerHeight() {
                return this.containerNode.clientHeight;
            },

            relocate: function relocate(top, width) {
                if (this.isInFilterPanel() && !this.isHorizFP()) {
                    this.portletContainerNode.style.top = this.shadowNode.style.top = top + $PX;
                }
            },

            /**
             * <p>Resizes the DocPortlet for the new dimensions.</p>
             *
             * <p>NOTE: This method will modify the passed in dimensions to remove size for borders and titlebar.
             *
             * @param {Object} d The new dimensions (with "h" property for height and "w" property for width).
             */
            setInfoWindowDimensions: function setInfoWindowDimensions(d) {
                var domNodeStyle = this.domNode.style,
                    shadowStyle = this.shadowNode.style,
                    containerStyle = this.portletContainerNode.style,
                    borderWidths = mstrmojo._Formattable.getBorderWidths(this);

                // Adjust dimensions for borders.
                d.h -= borderWidths.h;
                d.w -= borderWidths.w;

                // Set adjust dimensions onto the shadow, container and dom node.
                shadowStyle.height = containerStyle.height = domNodeStyle.height = d.h + $PX;
                shadowStyle.width = containerStyle.width = domNodeStyle.width = d.w + $PX;

                // Remove title bar from dimension height.
                d.h -= this.titleNode.offsetHeight;

                // Hide close button.
                this.toolbarNode.style.display = 'none';
            },

            /**
             * Passes key to parent if parent implements addDirtyKey.
             *
             * @param {String} key The key of the dirty widget.
             */
            addDirtyKey: function addDirtyKey(key) {
                passDirtyKey.call(this, 'add', key);
            },

            /**
             * Passes key to parent if parent implements removeDirtyKey.
             *
             * @param {String} key The key of the clean widget.
             */
            removeDirtyKey: function removeDirtyKey(key) {
                passDirtyKey.call(this, 'remove', key);
            },

            /**
             * Passes command to content widget if that widget implements this method.
             *
             */
            setDirtyChildren: function setDirtyChildren() {
                // Do we have a content child AND does it implement the setDirtyChildren method?
                var contentChild = this.content;
                if (contentChild && contentChild.setDirtyChildren) {
                    // Pass arguments to child's implementation.
                    contentChild.setDirtyChildren.apply(contentChild, arguments);
                }
            }
        }
    );

    /**
     * State constants for interactive title bars.
     *
     * @private
     * @ignore
     */
    var ST_RESTORE = 0,
        ST_MIN = 1,
        ST_MAX = 2;

    /**
     * <p>Updates window state information in definition.</p>
     *
     * <p>This would inform any portlet which listens to 'ds' change event about the changed window state, then in turn invoke their onWindowStateChange() handler,
     * which would update their size according to the new state.</p>
     *
     * @private
     */
    function updateWindowState(v, oh, ow, evt) {

        // 3. Save new properties
        var w = this.content,
            key = w.k,
            px = mstrmojo.boxmodel.px2Inches,
            m = w.model.docModel || w.model,
            f = this.getFormats(),
            callback = {},
            me = this,
            fnUpdateDS = function () {
                var defn = me.content && me.content.defn;
                if (defn) {
                    defn.set('ds', v);      // this will trigger ds_change event.
                }
            },
            propValues = {                  // Default property values.
                ZIndex: f['z-index'],
                WindowState: v
            },
            props = {};

        props[key] = propValues;

        // Create the rw unit properties parameters.
        if (oh !== undefined && ow !== undefined) {
            // Add additional properties to properties value collection.
            $HASH.copy({
                OldHeight: px(m, oh),
                OldWidth: px(m, ow),

                //// component height in saved property includes title height, which we reduced in preBuildRendering
                Height: px(m, parseInt(f.height, 10)),      //(ns === ST_MIN) ? 0 : px(m, parseInt(f.height, 10) + ttlH + borderH),
                Width: px(m, parseInt(f.width, 10))         //px(m, parseInt(f.width, 10) + borderW),
            }, propValues);

            // Create callback for after task is executed.
            callback.success = function (res) {
                // Did we receive data back?
                var data = res && res.data;
                if (data) {
                    // Load partial data.
                    w.model.loadPartialData(data, key);
                }

                // 1. Update window state in definition.
                fnUpdateDS();

                // Can the parent adjust section size?
                var p = me.parent;
                if ('adjustSectionSize' in p) {
                    // Tell parent to adjust section size.
                    p.adjustSectionSize();
                }
            };

            // Save the new properties to the server.
            m.saveRWProps(key, props, 1, this.loadDataOnResize, callback, true);

        } else {
            // For selector portlet, we can expand/collapse the portlet directly without waiting for task response.
            fnUpdateDS();
            if (!(evt && evt.all)) {
                m.saveRWProps(key, props, 1, this.loadDataOnResize, callback, true);
            }
        }

        return props;
    }

    /**
     * Handles resizing portlet and its content when window state changed.
     *
     * @private
     */
    function onWindowStateChange() {
        // When window state change, the portlet, which change originated
        // from, has made changes to both portlet's and content's formats.

        // 1. Here we need to resize DOM node corresponding to portlet and content.
        // This portlet maybe and maybe not the portlet which originated the change.
        var content = this.content;
        if (!content) {
            // if there is no content, we do not have formats collection to
            // inform the change.
            return;
        }

        var fnUpdateBtnState = function (children) {
                // Iterate the toolbar children.
                mstrmojo.array.forEach(children, function (child) {
                    // Does the child have a 'ds' property?
                    if ('ds' in child) {
                        // Child is a button so set visible property based on whether the ds property matches the ds from the content definition.
                        child.set('visible', (child.ds !== content.defn.ds));
                    }
                });
            },
            toolbar;

        // Is this a filter panel DocPortlet?
        if (this.isInFilterPanel()) {

            // 2. Adjust the content visiblity and height.
            var isRestore = (parseInt(this.defn.ds, 10) === ST_RESTORE);
            content.set('visible', isRestore);
            this.updateContentHeight(!isRestore);

            // 3. Update toolbar buttons' state
            toolbar = this.leftToolbar;
            fnUpdateBtnState(toolbar && toolbar.children);

            // 4. Refresh the filter panel.
            var p = this.parent;
            if (p.refreshFP) {
                p.refreshFP();
            }

        } else {
            // Resize the dom node to the new values.
            var c_f = content.getFormats(),                     // Content formats.
                p_f = this.getFormats(),                        // Portlet formats.
                ps = this.portletContainerNode.style,
                ss = this.shadowNode.style,
                cs = this.contentNode.firstChild.style;

            // Adjust content dimensions.
            cs.height = c_f.height;
            cs.width = c_f.width;

            // Adjust shadow and portlet dimensions.
            ss.height = ps.height = p_f.height;
            ss.width = ps.width = p_f.width;
            ss.top = ps.top = p_f.top;
            ss.left = ps.left = p_f.left;

            // Is there a specified z-index?
            if ('z-index' in p_f) {
                // Adjust shadow and portlet z-index.
                ss.zIndex = ps.zIndex = p_f['z-index'];
            }

            // Update th etoolbar button state.
            toolbar = this.rightToolbar;
            fnUpdateBtnState(toolbar && toolbar.children);

            // Does the content have a resize method?
            if (content.resize) {
                // Tell content to resize.
                content.resize();
            }
        }
    }

    mstrmojo.DocResizablePortlet = mstrmojo.declare(
            // super
            mstrmojo.DocPortlet,

            // mixin
            null,

            // instance properties and methods
            {
                scriptClass : 'mstrmojo.DocResizablePortlet',

                /**
                 * Indicates whether load data on resize task
                 */
                loadDataOnResize: false,

                /**
                 * Overrides to keep some format information relates to min/max/restore actions.
                 */
            _createFormats: function _createFormats() {
                    // call super
                    this._super();

                    var f = this.getFormats();

                    // record normal state value
                var ds = parseInt(this.defn.ds, 10);    // WindowState

                    // For min/max mode, the width/height/top/left come in as normWidth/normHeight/normTop/normLeft
                    // Is the current WindowState 'Normal'?
                    if (ds === ST_RESTORE) {
                        // Cache current formatting values for after the portal is maximized or minimized client-side, then restored again.
                        f.normHeight = f.height;
                        f.normWidth = f.width;
                        if (f['z-index'] !== null && f['z-index'] !== undefined) {
                            f.normZIndex = f['z-index'];
                        }
                    }

                    // Is the current WindowState NOT 'Maximized'?
                    if (ds !== ST_MAX) {
                        f.normTop = f.top;
                        f.normLeft = f.left;
                    }
                },

                /**
                 * Maximizes the portlet and its children.
                 */
            onmaximize: function onmaximize() {

                    var p = this.parent,
                        c = this.content,
                        c_f = c && c.getFormats(),
                        f = this.getFormats(),
                        oh = f.height,
                        ow = f.width,
                        bw = mstrmojo._Formattable.getBorderWidths(this);

                    this.clearCache();
                    c.clearCache();

                    // portlet height = parent height - component top/bottom border height
                f.height = (parseInt(p.height(), 10) - bw.h) + $PX;
                    // component height = parent height - title bar height - component top/bottom border height
                    c_f.height = this._ts.getContentHeight(f.height, f);
                    // portlet/component width = parent width - component left/right border width
                f.width = c_f.width = (p.width() - bw.w) + $PX;
                    f.top = f.left = 0;
                    f['z-index'] = p.getMaxZIndex() + 1;

                    // updates window state
                updateWindowState.call(this, ST_MAX, oh, ow);
                },
                /**
                 * Minimizes the portlet and its children, only leaves title bar visible if title bar was visible.
                 */
            onminimize: function onminimize() {

                    var c = this.content,
                    node = c.dimNode  || c.domNode,
                        c_f = c && c.getFormats(),
                        f = this.getFormats(),
                    oh = f.height || node.offsetHeight,
                        ow = f.width;

                    this.clearCache();
                    c.clearCache();

                    // portlet's and components' width = normal width
                    f.width = c_f.width = f.normWidth;
                    // portlet's top = normal top
                    f.top = f.normTop;
                    // portlet's lef = normal left
                    f.left = f.normLeft;
                    // portlet's z-index = normal z-index
                    if (f.normZIndex !== null && f.normZIndex !== undefined) {
                        f['z-index'] = f.normZIndex;
                    }

                    // component's height = 0
                    c_f.height = 0;
                    // portlet's height = title bar's height
                    f.height = this._ts.getPortletMinHeight(f);

                    // updates window state
                updateWindowState.call(this, ST_MIN, oh, ow);
                },
                /**
                 * Restores the portlet and its children from maximized state or minimized state.
                 */
            onrestore: function onrestore() {

                    var c = this.content,
                        c_f = c && c.getFormats(),
                        f = this.getFormats(),
                        oh = f.height,
                        ow = f.width;

                    this.clearCache();
                    c.clearCache();

                    // portlet's normal height
                    f.height = f.normHeight;
                    // component's normal height = portlet's height - title bar height
                    c_f.height = this._ts.getContentHeight(f.height, f);
                    // portlet's and components' width = normal width
                    f.width = c_f.width = f.normWidth;
                    // portlet's top = normal top
                    f.top = f.normTop;
                    // portlet's lef = normal left
                    f.left = f.normLeft;
                    // portlet's z-index = normal z-index
                    if (f.normZIndex !== null && f.normZIndex !== undefined) {
                        f['z-index'] = f.normZIndex;
                    }

                    // updates window state
                updateWindowState.call(this, ST_RESTORE, oh, ow);
                },
                /**
             * Collapse the portlet, special used for selector
             */
            oncollapse: function oncollapse(evt) {
                return updateWindowState.call(this, ST_MIN, undefined, undefined, evt);
            },
            /**
             * Expand the portlet, special used for selector
             */
            onexpand: function onexpand(evt) {
                // updates window state
                return updateWindowState.call(this, ST_RESTORE, undefined, undefined, evt);
            },

                /**
                 * Sets event listeners to hear when the definition WindowState changes as well as whenever one of the interactive title bar buttons is clicked.
                 *
                 * @ignore
                 * @see mstrmojo._HasMarkup
                 */
                postBuildRendering: function postBuildRendering() {
                    // Set an event listener to hear when the portal state changes in the definition.
                    if (!this._sub_dsChange) {
                    this._sub_dsChange = this.defn.attachEventListener('dsChange', this.id, onWindowStateChange);
                    }

                    this._super();

                    // #657509: updateContentHeight should not be called for Portlets with fixed height/width. It's only for Fit-to-content Portlets
                    // If we want to use it for portlets within filter panels, we should add a check.
                    if (this.isInFilterPanel()) {
                    // #601218. update the height after rendering
                    var isRestore = (parseInt(this.defn.ds, 10) === ST_RESTORE);
                	this.updateContentHeight(!isRestore);
                    }
                }
            }
        );
}());
(function(){
    mstrmojo.requiresCls("mstrmojo.Dialog",
                         "mstrmojo._IsAnchorable",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasTouchScroller");
    
    var $D = mstrmojo.dom;
    
    function fnCloseDialog(){
        mstrApp.closeDialog();
    }
    
    /**
     * Info Viewer class
     */
    mstrmojo.Magnifier = mstrmojo.declare(
        
        mstrmojo.Dialog,
        
        [mstrmojo._IsAnchorable, mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],
        
        {
            scriptClass: "mstrmojo.Magnifier",
            
            cssClass: 'mstrmojo-magnifier anchor',

            markupString: '<div id="{@id}" class="mstrmojo-Dialog {@cssClass}">' +
                            '<div class="win mstrmojo-Editor" style="{@cssText}">' +
                                '<div class="mstrmojo-InfoViewer-Title"><div class="mstrmojo-Editor-title">{@title}</div></div>' +
                                '<div class="mstrmojo-InfoViewer-Content"></div>' + 
                                '<div class="mstrmojo-InfoViewer-Buttons"></div>' + 
                            '</div>' +
                            '<div class="mstrmojo-Editor-curtain"></div>' + 
                            '<div class="mstrmojo-Editor-tip"></div>' +
                         '</div>',
            
            anchorOrientation : 'h',
            
            anchorOffset: 0,
            
            baseTipClass: '',

            // cached screen dimension
            screenDim: null,
            
            width: 'auto',
            
            /**
             * Hide the dialog, do some cleanup and destroy it.
             */
            close: function close() {
                if (this.onClose) {
                    this.onClose();
                }
                
                $D.detachEvent(window, 'resize', fnCloseDialog);
                               
                this.destroy();
            },
            
            touchBegin: function touchBegin(touch) {
                // Show glowing effect when user taps on certain nodes 
                this.helper.glowOnTap(touch.target);
            },
            
            touchTap: function touchTap(touch) {
                var target = touch.target;
                
                if (target === this.curtainNode) {
                    // close the dialog if click outside
                    mstrApp.closeDialog();
                }else {
                    // let helper class to handle the touch events
                    this.helper.handleTouchTap(target);
                }
            },
            
            touchSwipeEnd: function touchSwipeEnd(touch){
                this.helper.handleTouchSwipe(touch);
                this._super(touch);
            },
            
            preBuildRendering: function preBldRdr(){
                this._super();
                
                var dim = this.screenDim = mstrApp.getScreenDimensions(),
                    w = dim.w,
                    h = dim.h;
                
                if (mstrApp.isTablet()){
                    this.width = 'auto';
                }else{
                    // On phones, the magnifier width is proportional to screen width
                    // The proportion is 60% in portrait mode and 40% in landscape mode. 
                    this.width = (w > h ? (w * 0.4) : (w * 0.6)) + 'px';
                }
            },
            
            /**
             * @override mstrmojo.Dialog.postBuildRendering
             */
            postBuildRendering: function(){
            	this._super();
                
                // The info viewer needs to be closed if device orientation gets changed.
                $D.attachEvent(window, 'resize', fnCloseDialog);                
            },
            
            /**
             * Update the content displayed in the magnifier. Called when the magnified node changes.
             */
            updateContent: function () {
                var helper = this.helper;
                // populate tabs
                helper.createTitle(this.titleNode);
                // populate contents
                helper.createContent(this.containerNode);
            },
            
            /**
             * Resize and adjust the position according to the tapped position
             * 
             * @param {Boolean} anchorPos The position that we should place the info viewer around. If not provided, we would move the
             *                            info viewer only if it cannot fit in current viewport. 
             */
            resizeAndPosition: function(anchorPos){
                var contentHeight = this.helper.getContentHeight(),
                    titleHeight = this.helper.titleHeight,
                    dim = this.screenDim,
                    totalHeight  = dim.h - 30, pos;

                // the height should not exceed the screen boundaries
                this.height = Math.min(contentHeight, totalHeight - titleHeight);
                this.containerNode.style.height = this.height + 'px';
                
                this.updateScroller();
                
                if (anchorPos){
                    this.moveTo(anchorPos);
                }else{
                    pos = $D.position(this.editorNode);

                    // check the boundary of the info viewer. If it's not completely inside the view port, move it.
                    if (!(pos.x > 0 && pos.x + pos.w < dim.w && pos.y > 0 && pos.y + pos.h < dim.h)){
                        this.positionDialog();
                    }
                }
                
                window.setTimeout(function() {
                    mstrMobileApp.forceRepaint();
                }, 0);
            },
            
            /**
             * Move the info viewer according to the given position.
             * @param anchorPosition
             */
            moveTo: function(anchorPosition) {
                this.anchorPosition = anchorPosition;
                this.positionDialog();
            },
            
            /**
             * Configure the vertical scroller.
             * 
             * @override mstrmojo._HasTouchScroller.updateScrollerConfig
             */
            updateScrollerConfig: function updateScrollerConfig() {
                var cfg = this._super(),
                    idx = this.helper.currentTabIndex,
                    scrollEl = this.containerNode.children[idx];

                cfg.bounces = false;

                if (scrollEl){
                    // Add the scrollEl to the scroll config.
                    cfg.scrollEl = scrollEl;
    
                    // Initialize origin to 0,0 (if not already there).
                    cfg.origin = cfg.origin || {
                        x: 0,
                        y: 0
                    };
    
                    // no horizontal scroll indicator
                    cfg.noVScroll = cfg.noHScroll = true;
                    
                    // Calculate offset end (items container node height minus widget height).
                    var offsetEnd = Math.max(this.helper.getContentHeight() - this.height, 0);
    
                    // Should we be able to vertically scroll?
                    var enableScroll = cfg.vScroll = (offsetEnd !== 0);
                    if (enableScroll) {
                        // Add the computed offset.
                        cfg.offset = {
                            y: {
                                start: 0,
                                end: offsetEnd
                            }
                        };
                    }
                }

                return cfg;
            }
        });
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo.fx",
                         "mstrmojo.Dialog",
                         "mstrmojo._IsPopup",
                         "mstrmojo._HasPopup",
                         "mstrmojo._IsMovable");

    var $D = mstrmojo.dom;

    /**
     * Editor is a dialog that has title bar with title and content area.
     *
     * <p> Users can drag and move the editor through the title bar, which contains other shortcut buttons, such as
     * close, help or menu.</p>
     *
     * <p> Like mstrmojo.Popup, mstrmojo.Editor is also a Popup. However, compared to Popup, Editor is more complicated and offer couple more
     * configurable features. First, an editor can have a title bar(showTitle is used to configured whether or not show a title bar).
     * Secondly, it can be dragged and moved around using title bar. Thirdly, an editor can also be configured to have curtain to avoid end users to interact while
     * it is popup/open, using parameter 'modal'. An editor can also be associated with a help topic and auto-closed.</p>
     *
     * @class
     * @extends mstrmojo.Container
     */
    mstrmojo.Editor = mstrmojo.declare(

        mstrmojo.Dialog,

        [ mstrmojo._IsPopup, mstrmojo._HasPopup, mstrmojo._IsMovable ],

        /**
         * @lends mstrmojo.Editor.prototype
         */
        {
            scriptClass: "mstrmojo.Editor",

            /**
             * An optional title for the editor.
             *
             * @type String
             */
            title: '',

            /**
             * The help topic this editor is associated with.
             */
            help: '',

            /**
             * Whether or not autoClose this editor when clicking any place other than the editor.
             */
            autoClose: false,

            /**
             * Whether or not show the title bar.
             */
            showTitle: true,

            /**
             * Effect used to show the curtain and editor when opening them.
             * Note that this effect shall handle showing of both curtain and editor.
             * In the case of curtain, the modal of editor has to be considered as well.
             */
            openEffect: null,

            /**
             * Effect used to close the curtain and editor when closing them.
             * Note that this effect shall handle closing of both curtain and editor.
             * In the case of curtain, the modal of editor has to be considered as well.
             */
            closeEffect: null,

            markupString: '<div id="{@id}" class="mstrmojo-Editor-wrapper">' +
                            '<div class="mstrmojo-Editor {@cssClass}" style="z-index:{@zIndex};{@cssText}" mstrAttach:mousedown>{@titlebarHTML}' +
                                '<div class="mstrmojo-Editor-content"></div>' +
                                '<div class="mstrmojo-Editor-buttons"></div>' +
                            '</div>' +
                            '<div class="mstrmojo-Editor-curtain"></div>' +
                          '</div>',

            titleMarkupString: '<div style="position:absolute;width:100%;"><table cellspacing="0" cellpadding="0" class="mstrmojo-Editor-titlebar"><tr>' +
                          '<td class="mstrmojo-Editor-titleCell"><div class="mstrmojo-Editor-title"></div></td>' +
                          '<td><a href="#" target="_new" class="mstrmojo-Editor-help"><img class="mstrmojo-Editor-help" src="../images/1ptrans.gif" title="' + mstrmojo.desc(1143, "help") + '"></img></a></td>' +
                          '<td><div class="mstrmojo-Editor-close" title="' + mstrmojo.desc(2102, "Close") + '"></div></td>' +
                     '</tr></table></div><div class="mstrmojo-Editor-titleSpacer"></div>',

            markupSlots: {
                editorNode: function () { return this.domNode.firstChild; },
                titlebarNode: function () { return this.showTitle ? this.domNode.firstChild.firstChild.firstChild : null; },
                titleNode: function () { return this.showTitle ? this.domNode.firstChild.firstChild.firstChild.rows[0].cells[0].firstChild : null; },
                helpNode: function () { return this.showTitle ? this.domNode.firstChild.firstChild.firstChild.rows[0].cells[1].firstChild : null; },
                closeNode: function () { return this.showTitle ? this.domNode.firstChild.firstChild.firstChild.rows[0].cells[2].firstChild : null; },
                containerNode: function () { return this.domNode.firstChild.childNodes[2]; },
                buttonNode: function () { return this.domNode.firstChild.childNodes[3]; },
                curtainNode: function () {return this.domNode.lastChild; }
            },

            markupMethods: {
                ontitleChange: function () {
                    if (this.showTitle) {
                        this.titleNode.innerHTML = this.title;
                    }
                },

                onzIndexChange: function () {
                    var zIndex = this.zIndex;
                    this.editorNode.style.zIndex = zIndex;
                    this.curtainNode.style.zIndex = zIndex - 1;
                },

                onvisibleChange: function (init) {
                    if (init) {
                        return;
                    }

                    var v = this.visible,
                        fx = 'closeEffect',
                        d = 'none';

                    if (v) {
                        fx = 'openEffect';
                        d = 'block';
                    }

                    if (this[fx]) {
                        this.playEffect(fx);

                    } else {
                        this.editorNode.style.display = d;
                        if (this.modal) {
                            this.curtainNode.style.display = d;
                        }
                    }
                },

                onhelpChange: function () {
                    if (this.showTitle) {
                        if (this.help === null) {
                            this.helpNode.style.display = 'none';
                        }

                        this.helpNode.href = (mstrApp.helpUrl || '../help/')  + 'WebUser/WebHelp/Lang_' + (mstrApp.helpLocaleId ? mstrApp.helpLocaleId : mstrApp.localeId) +
                            '/'+(mstrApp.userHelpPage || 'MicroStrategy_Web_Help.htm')+'#' + (this.help || '');
                    }
                },

                onleftChange: function () { this.editorNode.style.left = this.left || ''; },
                ontopChange: function () { this.editorNode.style.top = this.top || ''; }
            },

            /**
             * Override to handle showTitle parameter.
             */
            preBuildRendering: function preBuildRendering() {
                if (!this.slot && !this.placeholder) {
                    this.placeholder = document.body.appendChild(document.createElement('div'));
                    this._curtain_to_body = true;
                }

                this.titlebarHTML = (this.showTitle) ? this.titleMarkupString : '<div></div><div></div>';

                return this._super();
            },

            getMovingHandle: function getMovingHandle() {
                return this.titlebarNode;
            },

            getMovingTarget: function getMovingTarget() {
                return this.editorNode;
            },

            /**
             * Override this to add logic handling data before calling close()
             * 
             * @return true - close editor
             *         false - leave editor open
             */
            onPreClose: function() {
                return true;
            },
            
            premousedown: function premousedown(evt) {
                var target = $D.eventTarget(evt.hWin, evt.e);
                if (target === this.closeNode) {
                 
                    if (this.onPreClose()) {
                        this.close();
                    }
                }
            },

            /**
               * Custom setter in order to set up handlers for resize curtain, center editor and auto close editor.
               */
            _set_visible: function _set_visible(n, v) {
                // Is the new value different?
                var bChanged = (this[n] !== v);
                if (bChanged) {
                    // Update value.
                    this[n] = v;

                    var closeHandler = this._close_handler;

                    // Is the editor visible?
                    if (v) {
                        if (this._curtain_to_body) {
                            this.resizeDialog();
                            this.positionDialog();
                        }

                        // Auto close.
                        if (this.autoClose) {
                            var me = this;

                            closeHandler = this._close_handler = closeHandler || function (evt) {
                                var t = $D.eventTarget(self, evt); //TQMS 416177: somehow IE7 would return t as an empty object as event target.
                                if (t && t.parentNode && !$D.contains(me.editorNode, t, true, document.body)) {
                                    me.close();
                                }
                            };

                            $D.attachEvent(document.body, 'mousedown', closeHandler);
                        }
                    } else {
                        var curtainHandler = this._curtain_handler;

                        // Do we have a curtain handler?
                        if (curtainHandler) {
                            // Detach curtain handler.
                            $D.detachEvent(window, 'resize', curtainHandler);
                        }

                        // Do we have a close handler?
                        if (closeHandler) {
                            // Detach close handler.
                            $D.detachEvent(document.body, 'mousedown', closeHandler);
                        }
                    }
                }

                return bChanged;
            }
        }
    );

    mstrmojo.Editor.openEffect_fadeIn = {
        scriptClass: 'mstrmojo.fx.AnimateProp',
        slot: 'curtainNode',
        props: {
            backgroundColor: {
                start: 255,
                stop: 0,

                //ease: mstrmojo.ease.cos,
                fn: function (v) {
                    v = Math.round(v);
                    return ['rgb(', v, ',', v, ',', v, ')'].join('');
                }
            }
        },

        preStart: function () {
            var target = this.target,
                widget = this.widget;

            widget.editorNode.style.display = 'block';

            if (!widget.modal) {
                return false;
            }

            target.style.display = 'block';
            mstrmojo.css.setOpacity(target, 60);

            return true;
        }
    };

    mstrmojo.Editor.closeEffect_fadeOut = {
        scriptClass: 'mstrmojo.fx.FadeOut',
        slot: 'curtainNode',
        start: 0.6,
        stop: 0,
        preStart: function () {
            var widget = this.widget;
            widget.editorNode.style.display = 'none';

            return !!widget.modal;
        }
    };
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Dialog",
                         "mstrmojo.array",
                         "mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo._IsAnchorable"
    					);
    
    var $DOM = mstrmojo.dom,
        $ARR = mstrmojo.array;
    
    /**
     * An extension of {@link mstrmojo.Dialog} designed for the Mobile platform.
     * 
     * @class
     * @extends mstrmojo.Dialog
     */
    
    
    
    // xiawang: this is to define pop up panel class
    mstrmojo.VisHeatMapPopupPanel = mstrmojo.declare(
    	mstrmojo.Container,
    	
		null,
    	
	{
		scriptClass: "mstrmojo.VisHeatMapPopupPanel",

		title: "",


		markupString: '<div id="{@id}" class="heatmap-popup-panel" style="{@cssText}">' +
					       '</div>',

			markupSlots: {
				containerNode: function () { return this.domNode;}
			},
			
			initialized: false,
			
			naviAction: null // a function that will be called when navigate to that panel
    	}
    );
    
	mstrmojo.VisHeatMapAnimation = (function () { // a helper function for animation. Make it public and expose only one method that is animate()
		var animationSet = []; // we keep a set of animation nodes to handle conflict animation case. Use sparse array
		return {
				animate: function (node, propName, orgStyle, targetStyle, duration, callback) { // for every animation, we need to get the vars independently // each style contains {r: g: b: a:}
					var thisObj;
					var emptyPos = animationSet.length;
					for (var i = 0, len = animationSet.length; i < len; i++) {
						if (!animationSet[i]) { // if that object does not exist, mark the position
							emptyPos = i;
							continue;
						}
						if (animationSet[i].node === node && animationSet[i].propName === propName) {
							// found!
							(animationSet[i].finalize(false)); // call finalize to stop animation immediately but not remove the node
							thisObj = animationSet[i];
							break;
						}
					}
					if (!thisObj) { // if not ever set
						thisObj = {};
						thisObj.node = node;
						thisObj.index = emptyPos;
						thisObj.propName = propName;
						animationSet[emptyPos] = thisObj;
					}
					var startTime = (new Date()).getTime();
					var duration = duration || 500; // animation duration, default to 2 seconds
					var interval = 20; // every 20ms a frame, that is 50fps
					
					var timer = null;
					thisObj.finalize = function (/*bool*/ removeNode) {
						// clearTimer
						clearInterval(timer);
						timer = null;
						
						// finalize the style
						if (targetStyle.r !== undefined) { // rgba or rgb type
							targetStyle.a = targetStyle.a || 1;
							// node.style[propName] = "rgba(" + targetStyle.r + "," + targetStyle.g + "," + targetStyle.b + "," + targetStyle.a + ")";
							// delete color style to return to transparent instead
							node.style[propName] = "";
						} else if (targetStyle.px !== undefined) { // px type;
							node.style[propName] = targetStyle.px + "px";
						}
						
						// remove the node if specified
						if (removeNode) {
							delete animationSet[this.index];
						}
						
						// if has call back function, run it
						if (callback) {
							callback();
						}
					};
					
					function setStyle () {
						// console.log("frame:" +  frame);
						var curStyle = {};
						var curTime = (new Date()).getTime();
						var timeDiff = curTime - startTime;
						if (timeDiff >= duration) {
							// node.style[propName] = null;
							thisObj.finalize(true); // remove the node from animation set
							return;
						}
						
						for (var prop in orgStyle) {
							curStyle[prop] = (targetStyle[prop] - orgStyle[prop]) * timeDiff / duration + orgStyle[prop]; // get the current style
							if (prop !== "a") {
								curStyle[prop] = Math.round(curStyle[prop]);
							}
						};
						
						if (curStyle.r) { // rgba or rgb type
							curStyle.a = curStyle.a || 1;
							node.style[propName] = "rgba(" + curStyle.r + "," + curStyle.g + "," + curStyle.b + "," + curStyle.a + ")";
						} else if (curStyle.px) { // px type;
							node.style[propName] = curStyle.px + "px";
						}
					}
					timer = setInterval(setStyle, interval);
				}
			};
	})();
    
    
    // xiawang: this is to define pop up class
    mstrmojo.VisHeatMapPopup = mstrmojo.declare(

    	mstrmojo.Container,

    	//[mstrmojo._HasTouchScroller],
		null,
        
        /**
         * @lends mstrmojo.android.Popup.prototype
         */
        {
            scriptClass: "mstrmojo.VisHeatMapPopup",
            
            /**
             * Indicates whether the dialog should fade when it is closed, or close immediately. Defaults to false because Android devices 
             * do not have hardware acceleration for CSS transitions. We can enable it if this statement is no longer true.
             * 
             * @type Boolean
             * @default false
             */
            fadeOnClose: false,
            
            /**
             * True if the dialog should close when the user touches outside the dialog.
             * 
             * @type Boolean
             * @default true
             */
            autoClose: true,
            
            
            markupString:'<div style="display: -webkit-box; -webkit-box-align: start; -webkit-box-pack: center;position:absolute; left:0px; top:0px; z-index:100000; width: 100%; height:100%;"  id={@id} mstrAttach:mouseup,touchend>' + 
	            			'<div id={@id} style=" position:relative; left: 0px; top: 0px; width:{@width}; background-color:#F5F5F5;z-index:100001;border:2px solid rgba(0, 0, 0, 0.1);-webkit-box-shadow:rgba(0, 0, 0, 0.45) 2px 2px 8px;">' +
	        						'<div  class="heatmap-popup-panel-title" style="display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: center;position:relative; -webkit-box-sizing: border-box; margin-bottom:6px; padding-right: 25%; height:65px; width:100%; line-height:65px;vertical-align:bottom;color:#33b5e5;">' +
	        							//'<div style="-webkit-box-sizing:border-box; padding-right:1px; position:absolute;width:50%;height:6px;bottom:0px;background-color:#33b5e5;left:0px;"></div>' +
	        						'</div>' +
	        						'<div style="height: 2px;width:100%;background-color:#33b5e5">' +
	        						'</div>' +
	        						'<div style="width:100%; height:auto; position:relative;overflow:hidden; display: -webkit-box; -webkit-box-orient: horizontal">' +
	        						'</div>' +
	    					'</div>' +
	    					'<div style="position:absolute;z-index:100000;top:0px;left:0px;width:100%;height:100%;background: rgba(0, 0, 0, 0.5);">' +
	    					'</div>' +
    					'</div>',

			markupSlots: {
				contentNode: function () {return this.domNode.firstChild;},
				titleNode: function () {return this.domNode.firstChild.firstChild;},
				//titleHilightNode: function () {return this.domNode.firstChild.firstChild.firstChild;},
				containerNode: function () {return this.domNode.firstChild.lastChild;},
				curtainNode: function () {return this.domNode.lastChild;}
			},
         
			baseTipClass: "heatmap-editor-tip",
			
			
			anchorOffset: 42,
			
			
			hasCloseButton: true,

            goBack: function () {
                    //this.domNode.style.display = "none";
                    return this.close();
            },
			
			
            // #731511, always close the dialog
			close: function () {
                    this.domNode.style.webkitTransform = 'translate(-100000px,0px)';
                    this.destroy();
                    //this.domNode.style.display = "none";
                    return true;
			},

            destroy: function() {
                    this.onClose();
                    if(this._super){
                            this._super();
                    }
            },

			postBuildRendering: function () {
				this._super();

				
				//this.titleBackNode.style.display = "none";
				
				for (var i = 0, len = this.panels.length; i < len; i++) {
					// for each title, we need to render a title div in the node;
					if (i !== 0) {
						// insert a "|" first
						var div = document.createElement("div");
						div.style.cssText = "position:relative;width:1px;color:grey;height:35px;text-align:center;background-color:grey;"; // an offset for 1 pixel
						// div.innerText = "";
						this.titleNode.appendChild(div);
					}
					var div = document.createElement("div");
					div.style.cssText = "-webkit-box-flex:1; line-height:65px;text-align:center; display: -webkit-box; -webkit-box-align: center; -webkit-box-pack: center; height:100%;";
                    if(i==0)
                            div.style.cssText += 'margin-left:16px;';
                    else
                            div.style.cssText += 'margin-right:16px;';
					div.setAttribute("panel", i);
					div.innerText = this.panels[i].title;
					this.titleNode.appendChild(div);
				}
				
				var that = this;
				document.body.appendChild(this.domNode);
				
				this.panelStack = 0;
				this.navigateTo(0);
                this.contentNode.style.marginTop = parseInt((document.body.offsetHeight - this.contentMaxHeight - this.titleNode.offsetHeight) / 2) + 'px';
			},			
			
			
			onmouseup: function (event) {
				if (event.e.target === this.curtainNode) {
					this.close();
					return;
				}
				var title = mstrmojo.dom.findAncestorByAttr(event.e.target, "panel", true, this.domNode);
				if (!title) {
					return;
				}

				//var pos = mstrmojo.boxmodel.offset(title.node, this.titleNode);
				//this.titleHilightNode.style.left = pos.left + "px";
				
				title.node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
				var callback = function () {
					mstrmojo.VisHeatMapAnimation.animate(title.node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
				};
				var that = this;
				setTimeout(function () {
    		   		setTimeout(function () {
    		   			that.navigateTo(title.value);
    		   			callback();
    		   		}, 0);
    		   },0); // use two level setTimeout so that we make sure the dom get refreshed first
				
			},
			
			ontouchend: function (event) {
				this.onmouseup(event);
			},

            highlightTitle: function (titleIndex) {
                    titleIndex =  2*parseInt(titleIndex);
                    if(isNaN(titleIndex))
                            return;
                    var titles = this.titleNode.childNodes,
                        len = titles.length;
                    for( var i = 0; i < len; i+=2){
                        if(i != titleIndex){
                               titles[i].style.borderBottom = '';
                        }else{
                                titles[i].style.borderBottom = 'solid 6px #33b5e5';
                        }
                    }
            },
			
            
            panelStack: 0, // this refers to current panel index
            
			
			navigateTo: function (panelIndex) {
                this.highlightTitle(panelIndex);

				var newPanel = this.panels[panelIndex];
				var curPanel = this.panelStack;
			    var oldPanel = this.panels[curPanel];
                //make sure that no other panel is being displayed so that the newly rendered panel has a right height
                if(panelIndex != curPanel){
                        if(oldPanel.hasRendered){
                                oldPanel.domNode.style.display = 'none';
                        }
                }
				if (!newPanel.hasRendered) {
					this.panels[panelIndex] = new mstrmojo.VisHeatMapPopupPanel(this.panels[panelIndex]);
					var newPanel = this.panels[panelIndex];
					this.addChildren(newPanel);
					this.renderChildren();
					// newPanel.domNode.style.left = "-1000px";
					//newPanel.domNode.style.display = "none";
				}
                newPanel.domNode.style.display = 'block';
				if (newPanel.naviAction) {
					newPanel.naviAction(); // if has custom action, call it. This is used in Delete Tree to give it chance to update delete tree
				}

				// calculate previous panel
				
				if (curPanel === panelIndex) {
					// no need to navigate animation in this case;
					// newPanel.domNode.style.left = "0px";
					// newPanel.domNode.style.display = "block";
					delete newPanel.domNode.style["webkitTransform"];
				} else {
					// animate previous panel
					var oldWidth = oldPanel.domNode.offsetWidth + "px";
					var newWidth = newPanel.domNode.offsetWidth + "px";

					
					// xiawang: since we use percent based sizing, we use maximum width to do animation
					var maxWidth = Math.max(parseInt(oldWidth), parseInt(newWidth));
					
					delete newPanel.domNode.style["webkitTransition"];
					var newStyle = "";
					var oldStyle = "";
					if (curPanel < panelIndex) { // put new panel to the right
						newStyle = "translate(-" + maxWidth + "px,0px)";
						// nav old panel to left
						oldStyle = "translate(-" + maxWidth + "px,0px)";
					} else { // put nwe panel to the left
						newStyle = "translate(" + maxWidth + "px,0px)";
						// nav old panel to right
						oldStyle = "translate(" + maxWidth + "px,0px)";
					}
					//newPanel.domNode.style["webkitTransform"] = newStyle;
					//newPanel.domNode.style.display = "block";
					// animation using own animation class
					/*
					var oldPanelTargetLeft;
					var newPanelSourceLeft;
					if (curPanel < panelIndex) { // put new panel to the right
						newPanelSourceLeft = maxWidth;
						oldPanelTargetLeft = -maxWidth;
					} else { // put new panel to the left
						newPanelSourceLeft = -maxWidth;
						oldPanelTargetLeft = maxWidth;
					}
					mstrmojo.VisHeatMapAnimation.animate(oldPanel.domNode, "left", {px: 0}, {px: oldPanelTargetLeft}, 300);
					mstrmojo.VisHeatMapAnimation.animate(newPanel.domNode, "left", {px: newPanelSourceLeft}, {px: 0}, 300);
					*/
                    
					this.panelStack = panelIndex;

					/*var that = this;
					setTimeout(function() {
						that.animation(newPanel, oldPanel, oldStyle);
					}, 1); // pause 1ms then do the animation 
                   */
				}
				//this.containerNode.style.height = this.panels[panelIndex].domNode.offsetHeight + 'px';
				//this.set("width", newPanel.width);
				//this.containerNode.style.height = this.panels[panelIndex].height;
				//this.set("width", newPanel.width);
				// this.titleTextNode.innerText = this.panels[panelIndex].title;
				//this.positionDialog(); // after panel transition, we should re position the dialog
				// this.previousPanel = panelIndex;
			},
			
            animation: function (newPanel, oldPanel, oldStyle) {
            	// according to new spec. We should disable the animation
            	//oldPanel.domNode.style["webkitTransition"] = "-webkit-transform 0.3s ease-out";
				oldPanel.domNode.style["webkitTransform"] = oldStyle;
            	//newPanel.domNode.style["webkitTransition"] = "-webkit-transform 0.3s ease-out";
				newPanel.domNode.style["webkitTransform"] = oldStyle;//"translate(0px,0px)";
				/*var that = this;
				setTimeout(function() {
					oldPanel.domNode.style.display = "none";
					that.titleBackNode.onclick = function () {that.navigateBack();};
				}, 500);*/
            },
			
			/*positionDialog: function () {
				var h = window.innerHeight, w = window.innerWidth;
				h = h > 0? h: 0;
				w = w > 0? w: 0;
				this.contentNode.style.left = (window.innerWidth - this.contentNode.offsetWidth) / 2 + "px";
				if (!this.contentNode.style.top) { // the top property is set only once
					var topPos = (window.innerHeight - this.contentNode.offsetHeight) / 2;
					if (topPos > 75) { // push the dialog higher than center but allocate at least 25 pixels for top
						topPos -= 50;
					}
					this.contentNode.style.top = topPos + "px";
				}
			},*/
			
			dummy: true
        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Dialog",
                         "mstrmojo.array",
                         "mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo._IsAnchorable");

    var $DOM = mstrmojo.dom,
        $ARR = mstrmojo.array;

    /**
     * An extension of {@link mstrmojo.Dialog} designed for the Mobile platform.
     *
     * @class
     * @extends mstrmojo.Dialog
     */
    mstrmojo.android.Popup = mstrmojo.declare(

        mstrmojo.Dialog,

        [mstrmojo._IsAnchorable],

        /**
         * @lends mstrmojo.android.Popup.prototype
         */
        {
            scriptClass: "mstrmojo.android.Popup",

            /**
             * Indicates whether the dialog should fade when it is closed, or close immediately. Defaults to false because Android devices
             * do not have hardware acceleration for CSS transitions. We can enable it if this statement is no longer true.
             *
             * @type Boolean
             * @default false
             */
            fadeOnClose: false,

            /**
             * True if the dialog should close when the user touches outside the dialog.
             *
             * @type Boolean
             * @default true
             */
            autoClose: true,

            /**
             * Overridden to calculate width and max-height based on screen dimensions for phones and set values for tablets.
             *
             * @ignore
             */
            init: function init(props) {
                // Call super to initialize.
                this._super(props);

                // Is this an anchored popup?
                if (this.anchor) {
                    mstrmojo.css.addWidgetCssClass(this, 'anchor');
                }
            },

            addChildren: function addChildren(children, idx, silent) {
                this._super(children, idx, silent);

                // Iterate the children.
                $ARR.forEach(this.children, function (child) {
                    // Is this the elastic child?
                    if (child.isElastic) {
                        // Cache the child on the instance.
                        this._elasticChild = child;

                        // Can only have one elastic child so return false to halt iteration.
                        return false;
                    }
                }, this);
            },

            resizeDialog: function resizeDialog() {
                // Calculate width and max height.
                var editorNode = this.editorNode,
                    app = mstrApp,
                    dimensions = app.getScreenDimensions(),
                    mh = Math.round(dimensions.h * 0.9),
                    w = dimensions.w,
                    contentHeight;

                // Adjust available width.
                w = w * 0.85;

                // Is this a tablet device?
                if (app.isTablet()) {
                    var popDimensions = this.popDimensions || {},
                        tabletDimensions = mstrApp.getScreenDimensions();

                    // Calculate max dialog sizes.
                    mh = popDimensions.h || Math.min(Math.round(tabletDimensions.h * 0.6), mh);
                    w = popDimensions.w ||  Math.min(Math.round(tabletDimensions.w * (mstrApp.isLandscape() ? 0.43 : 0.65)), w);
                }

                // Add unit.
                w += 'px';

                // Do we have an elastic child?
                var elasticChild = this._elasticChild;
                if (elasticChild) {
                    // Does the child already have an elastic height?
                    var elasticHeight = elasticChild.elasticHeight;
                    if (elasticHeight) {
                        // Use cached height.
                        contentHeight = elasticHeight;

                    // Does the elasticChild have a method for calculating it's height?
                    } else if (elasticChild.getItemsContainerHeight) {
                        // Use calculated height.
                        contentHeight = elasticChild.getItemsContainerHeight();
                    }
                }

                // Is content height still undefined?
                if (contentHeight === undefined) {
                    // Set to available space.
                    contentHeight = this.getAvailableContentSpace();

                    // TQMS #716699 if the content contains fixed height elements, 
                    // the content height may be larger than our maxHeight. take the larger value.
                    mh = Math.max( mh, contentHeight + (this.titleNode.offsetHeight + this.buttonNode.offsetHeight) );
                    
                } else {
                    // Constrain content height to the max height minus the titlebar height.
                    contentHeight = Math.min(contentHeight, mh - (this.titleNode.offsetHeight + this.buttonNode.offsetHeight));
                }

                // Do we already have an editor node?
                if (editorNode) {
                    // Add max height to editor node.
                    editorNode.style.maxHeight = mh + 'px';

                    // Use set for width.
                    this.set('width', w);
                } else {
                    // Set width and add max-height to cssText. 
                    this.width = w;
                    this.cssText = (this.cssText || '') + 'max-height:' + mh + 'px;';
                }

                // Raise an event to let all listeners know that the Dialog has resized.
                this.raiseEvent({
                    name: 'popupResized',
                    maxheight: mh,
                    height: contentHeight,
                    width: parseInt(w, 10)
                });

                // Do we have an elastic child?
                if (elasticChild) {
                    // Does the child have a non auto (or default) height?
                    var h = elasticChild.height;
                    if (h !== undefined && h !== 'auto') {
                        // Set the childs height to auto so that we don't constrain it prematurely.
                        elasticChild.set('height', 'auto');
                    }

                    // Set height of child to available content height.
                    elasticChild.set('height', contentHeight + 'px');

                    // TQMS 467398: Does the child have a scroller?
                    // Is there a better place to do this?
                    if (elasticChild.updateScroller) {
                        // Update the scroller to correspond to the new height.
                        elasticChild.updateScroller();
                    }
                }

                this._super();
            },

            getAvailableContentSpace: function getAvailableContentSpace() {
            	// TQMS #716699 take the larger value of the current containerNode height or the
            	// editor node height minus the adornments.
                return Math.max(this.containerNode.offsetHeight, this.editorNode.clientHeight - this.titleNode.offsetHeight - this.buttonNode.offsetHeight);
            },

            close: function close() {
                // Do we have a custom close handler?
                if (this.onClose) {
                    // Call the custom hook.
                    this.onClose();
                }

                // Should this popup fade when it's closed?
                if (this.fadeOnClose) {
                    // Attach one time event to destroy dialog after it closes - only if we are still rendered
                    var domNode = this.domNode;
                    if (domNode) {
                        var id = this.id;

                        if (!$DOM.isWinPhone) {

                            $DOM.attachOneTimeEvent(domNode, $DOM.CSS3_TRANSITION_END, function () {
                                mstrmojo.all[id].destroy();
                            });

                            // Fade the dialog.
                            domNode.style.opacity = 0;

                        } else {

                            (new mstrmojo.fx.FadeOut({
                                onEnd: function () {
                                    mstrmojo.all[id].destroy();
                                },
                                target: domNode,
                                duration: 400
                            })).play();

                        }
                    }
                } else {
                    this.destroy();
                }
            },

            onclick: function onclick(evt) {
                // Do we support auto close and did the user click (or touch) the curtain?
                if (this.autoClose && evt.e.target === this.curtainNode) {
                    // Close the dialog.
                    this.close();
                }
            },

            ontouchend: function ontouchend(evt) {
                // Simulate a click.
                this.onclick(evt);
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls("mstrmojo.MobileDocLayoutViewer");
    
    var $CFC = mstrmojo.DynamicClassFactory.newComponent;
    
    // Create a mobile version of the map info layout viewer that fills the entire window.  On mobile, this is desired
    // as the map info windows are displayed in their own WebView
    mstrmojo.maps.MobileMapInfoWindowLayoutViewer = mstrmojo.declare(
        mstrmojo.MobileDocLayoutViewer, 
        null, 
        {
            scriptClass: 'mstrmojo.maps.MobileMapInfoWindowLayoutViewer',
            
            preBuildRendering: function preBuildRendering() {
                //TQMS:508164 set dimension to make the inner content fit to the outside container 
                this.setDimensions(this.height, this.width);
                
                this.set('visible', true);       
            
                return this._super ? this._super() : true;
            }
        }
    );
    
    /**
     * Widget for displaying map info windows.  This class is used in the HOSTED mobile environment only.  It's sole function
     * is to provide a height and width to the layout viewer.  This is necessary because the layout viewer is the root widget
     * and has no parent to provide sizing.
     */
     
    mstrmojo.maps.MapInfoWindowLayoutViewer = mstrmojo.declare(
        // superclass
        mstrmojo.MobileDocLayoutViewer,
        
        // mixins,
        null,
        
        /**
         * @lends mstrmojo.DocLayoutViewer.prototype
         */
        {
            scriptClass: "mstrmojo.maps.MapInfoWindowLayoutViewer",
            
            preBuildRendering: function preBuildRendering() {            
                
                this.set('visible', true);
                
                return this._super ? this._super() : true;
            }        
        }
    );
    
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.SliderBox",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.ui.MobileSlider",
                         "mstrmojo.num");

    var INPUT_VALUES_MANUAL = 1,
        $NUM = mstrmojo.num;

    mstrmojo.android.inputControls.SliderDIC = mstrmojo.declare(
        mstrmojo.SliderBox,

        [ mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: "mstrmojo.android.inputControls.SliderDIC",

            popupStyle: 1,

            init: function init(props) {
                //as MobileSlider uses min, max interval to set the slider, we
                //set the values based on the items of manual input values.
                var sbMin, sbMax, sbItv, sb;

                this._super(props);
                this.items = this.getItems();

                this.cssClass = this.showByDefault ? 'mstrmojo-SliderGroup' : 'mstrmojo-PopupSlider';

                if (this.dic.ipt !== INPUT_VALUES_MANUAL) {
                    this.isSequential = true;
                    sbMax = this.max = this.dic.max;
                    sbMin = this.min = this.dic.min;
                    sbItv = this.interval = this.dic.itv;
                } else {
                    sbMin = 1;
                    sbMax = this.items.length;
                    sbItv = 1;
                }

                sb = this.sliderBar;
                if (sb) {
                    sb.min = sbMin;
                    sb.max = sbMax;
                    sb.interval = sbItv;
                }
            },

            preBuildRendering: function preBuildRendering() {
                //set display value as the value text
                var dic = this.dic,
                    ldw = (dic.ldw != null) ? dic.ldw / 100 : 0.4,
                    os;

                this.valueText = this.dv;
                this._super();

                //if inline, we need to adjust value part width and slider bar width
                if (this.showByDefault) {
                    //to solve the problem, we set the sliderbox width as the container width * slider bar width percentage
                    //then move the text left to the sliderbox
                    os = this.openerStyle;
                    //set the value part, the left should be the text area percentage * container width
                    this.valueCssText = 'left:-' + os.iw * ldw + 'px;width:' + os.iw * ldw + 'px';
                    this.cssText = 'width:' + os.iw * (1 - ldw) + 'px';

                    this.alignSlider(this.openerNode, os.ih);
                }
            },

            onpopupResized: function onpopupResized() {
                var sb = this.sliderBar;
                if (sb) {
                    sb.refresh();
                }
            },

            /**
             * Create MobileSlider as the child of SliderBox
             */
            sliderRef: {
                scriptClass: "mstrmojo.ui.MobileSlider",
                onslidingValueChange: function () {
                    if (this.hasRendered) {
                        this.selectedIdx = parseInt((this.slidingValue - this.min) / this.interval, 10) || 0;
                        this.parent.selectedIdxChanged(this.selectedIdx);
                    }
                },
                //use selectedIdx to cache the value
                selectedIdx: 0,
                //create select function to set the slidingValue
                select: function (v) {
                    this.selectedIdx = v || 0;
                    this.slidingValue = this.value = this.min + v * this.interval;
                }
            },

            /**
             * When the inner slider selected index gets changed, update value and displayed value text.
             */
            selectedIdxChanged: function selectedIdxChanged(v) {
                var item = this.items[v],
                    sv = item && item.n;
                //TQMS 503056: need to localize the selected value
                this.set('value', $NUM.toLocaleString(sv));
                this.set('valueText', $NUM.toLocaleString(sv));
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.Slider",
                         "mstrmojo.MetricQualification",
                         "mstrmojo.expr",
                         "mstrmojo.ValidationTextBox",
                         "mstrmojo.array",
                         "mstrmojo.hash");

    mstrmojo.requiresDescs(8153, 8154, 8155, 8156, 8157, 8158, 8159, 8160, 8161, 8162, 8163, 8164, 8165, 8166, 8167, 8168, 8169, 8170, 7839, 587, 2204, 2202, 2203, 7576, 7575, 7622);

    var $D = mstrmojo.dom,
        $HASH = mstrmojo.hash,
        $M = mstrmojo.MCSUtil,
        $DESC = mstrmojo.desc,
        $C = mstrmojo.css,
        $NM = mstrmojo.num,
        $MATH = Math,
        $MATH_MAX = $MATH.max,
        $MATH_MIN = $MATH.min,
        $MATH_FLOOR = $MATH.floor,
        $MATH_ROUND = $MATH.round;

    /**
     * Positions handles, thumb and upper and lower range for a {@link mstrmojo.MetricSlider} or it's ghost.
     *
     * @param {mstrmojo.MetricSlider} slider The metric slider.
     * @param {Object} ui The object that contains the nodes to position (could be a slider or ghost).
     * @param {Integer} handle1 The position of the first handle.
     * @param {Integer} handle2 The position of the second handle.
     *
     * @private
     */
    function positionSliderElements(slider, ui, handle1, handle2) {
        var px = 'px',
            effectiveLength = slider._length,                   // Effective slider length.
            handleSize = slider.handleSize,
            orCfg = slider.orCfg,
            position = orCfg.posCssP,
            length = orCfg.lenCssP;

        // Make sure handle positions do not exceed boundaries.
        handle1 = $MATH_MAX(handle1, -1);
        handle2 = $MATH_MIN(handle2, effectiveLength);

        // Calculate thumb and upper range length.
        var min = $MATH_MIN(handle1, handle2),
            max = $MATH_MAX(handle1, handle2),
            thumbLength = max - min,
            upperLength = $MATH_MAX(parseInt(slider[length], 10) - (2 * slider.cssBkBW) - (max + handleSize), 0);   // Total length minus summed border widths, max value and handle size.

        // Has the slider already rendered?
        if (slider.hasRendered) {

            // Set thumb node positions.
            ui.handle1Node.style[position] = handle1 + px;
            ui.handle2Node.style[position] = handle2 + px;

            var lowerStyle = ui.lowerRange.style,
                thumbStyle = ui.thumbNode.style,
                upperStyle = ui.upperRange.style;

            // Set range positions.
            lowerStyle[position] = 0;
            thumbStyle[position] = (min + handleSize) + px;
            upperStyle[position] = (max + handleSize) + px;

            // Set range lengths.
            lowerStyle[length] = $MATH_MAX(min, 0) + px;
            thumbStyle[length] = thumbLength + px;
            upperStyle[length] = upperLength + px;

        } else {
            // Slider is not rendered so convert to css text settings.
            px += ';';
            position += ':';
            length += ':';

            // Set thumb node positions.
            slider.handle1CssText = position + handle1 + px;
            slider.handel2CssText = position + handle2 + px;

            // Set position and length for thumb and each range.
            slider.lowerRangeCssText = length + $MATH_MAX(min, 0) + px;
            slider.thumbCssText = position + (min + handleSize) + px + length + thumbLength + px;
            slider.upperRangeCssText =  position + (max + handleSize) + px + length + upperLength + px;
        }

        // Return current handle values.
        return {
            handle1: handle1,
            handle2: handle2
        };
    }

    /**
     * Helper object for metric slider calculations and utilities.
     *
     * @private
     * @ignore
     */
    function MetricSlider(sl) {
        /**
         * Get how many px for one item
         */
        this.getUnit = function () {
            return sl._length / $MATH_MAX((sl.items.length - 1), 1);
        };

        this.calcMinMax = function (pxMin, pxMax) {
            var unit = sl.unit;
            return {
                min: $MATH_FLOOR(pxMin / unit + 0.5),
                max: $MATH_FLOOR(pxMax / unit + 0.5)
            };
        };

        this.calcPxIdx = function (px) {
            return $MATH_FLOOR(px / sl.unit + 0.5);
        };

        /***
         * Get step between each item value
         * @return
         */
        this.getStep = function () {
            var rng = sl.high - sl.low,
                cat = parseInt(sl.numFmts.cat, 10),
                adjust = (cat === 4) ? 2 : (cat === 5) ? 4 : 0;

            rng = (rng === 0) ? 1 : rng;
            if (rng > 1) {
                return (rng > (sl._length - 2)) ? Number(Number(rng / (sl._length - 2)).toFixed(sl.numFmts.dp + adjust)) : 1;
            }

            return rng / (sl._length - 2);
        };

        /***
         * Get the item index with the nearest value for input value
         *  @param len
         * @return
         */
        this.getIdx = function (vl) {
            return $MATH_MIN($MATH_MAX($MATH_ROUND((vl - sl.low) / sl.step), 0), sl.items.length - 1);
        };

        /**
         * Initialize metric slider
         */
        this.initialMetricSlider = function initialMetricSlider() {
            var notNull = function (v) {
                    return v !== undefined && v !== null;
                },
                validateData = function (sl) {
                    return (notNull(sl.da) && notNull(sl.da.low) && notNull(sl.da.high) &&
                            notNull(sl.da.cnt) && notNull(sl.f) && notNull(sl.ft) && notNull(sl.qua));
                },
                displayInvalid = function (sl) {
                    var gen = true,
                        rp = true;

                    //the display for in, not in, null or not null should be as unset
                    if (sl.ft == $M._GENERIC) {
                        gen = sl.f != $M.FN.ISNULL && sl.f != $M.FN.ISNOTNULL && sl.f != $M.FN.NOTIN && sl.f != $M.FN.IN;
                    } else if(sl.ft == $M._PERCENT || sl.ft == $M._RANK) {
                        rp = sl.f != $M.MRPFN.INASCENDING && sl.f != $M.MRPFN.INDESCENDING && sl.f != $M.MRPFN.NOTINDESCENDING && sl.f != $M.MRPFN.NOTINASCENDING;
                    }

                    return !gen || !rp;
                },
                adjust = 0;

            sl.include = sl.parent.include;
            sl.clsType = 'scm ';

            sl.staticStatus = !(notNull(sl.da) && notNull(sl.da.low) && notNull(sl.da.high)&& notNull(sl.da.cnt)&& notNull(sl.qua));
            if (sl.staticStatus) { // set default value , hard code
               sl.da.low = 1;
               sl.da.high = 7;
               sl.ft = $M._GENERIC;
               sl.f = $M.FN.BETWEEN;
               sl.qua = $M.Q._G;
               sl.cs = [{n: '', v: 1}, {n: '', v: 7}];
               sl.numFmts = {cat: 9, dp: 0, fm: ''};
            }

            //initial qualify on
            switch (sl.qua) {
            case 0:
                var cat = sl.numFmts.cat;
                adjust = cat == 4 ? 2 : cat == 5 ? 4 : 0;
                sl.low = Number(Number(sl.da.low ).toFixed(sl.numFmts.dp + adjust));
                sl.high = Number(Number(sl.da.high).toFixed(sl.numFmts.dp + adjust));
                break;
            case 1:
            case 2:
                sl.low = 1;
                sl.high = sl.da.cnt;
                break;
            case 3:
            case 4:
                sl.low = 0;
                sl.high  = 100;
                break;
            }

            var ept = !sl.staticStatus && !sl.da.nov && sl.dt != 30;
            sl.set('lowText', ept? $M.formatNumber(sl.qua, sl.low, sl.numFmts) : "");
            sl.set('highText', ept? $M.formatNumber(sl.qua, sl.high, sl.numFmts) : "");

            //initial step
            sl.step = (sl.qua == 1 || sl.qua == 2)? 1 : this.getStep();

            sl.low -= sl.step;
            sl.high += sl.step;

            //initial cs
            sl.cs1Vl = sl.low;
            sl.cs2Vl = sl.high;

            //initial items array
            var l = sl.low,
                h = sl.high,
                itms = [],
                len = 0;

            if ( notNull(l) && notNull(h) && sl.dt != 30) {
                for (var i = 0, j = l; j <= h; i ++, j += sl.step) {
                    itms[i] = {n : $M.formatNumber(sl.qua, j, sl.numFmts), v: Number(Number(j).toFixed(sl.numFmts.dp + adjust))};
                }
                len = itms.length;
                if (len > 0 && itms[len -1].v != h){  itms[len-1] = {n: $M.formatNumber(sl.qua, h, sl.numFmts), v: h}; }
            }

            len = itms.length;
            if(len >= 2 ) {
                itms[0].n = itms[len -1].n = $DESC(7622);
            }

            sl.items = itms;

            //update cs index by parsing constants.
            var $O = $M.OP,
            cs = sl.cs,
            c1 = (cs && cs.length > 0)? $NM.parseNumeric(String(cs[0].v).replace('%', '')) : l,
            c2 = (cs && cs.length >1)? $NM.parseNumeric(String(cs[1].v).replace('%', '')) : h;

            if(c1 < sl.low) { sl.frtUst = true;}
            if(c2 > sl.high) {sl.ndUst = true;}

            sl.opId = (sl.f != null && sl.ft != null)? $M.getOpIdxByfunc(sl.f, sl.ft) : $O._BETWEEN;

            switch (sl.opId){
            case  $O._EQUALS :
            case $O._NOT_EQUALS:
                sl.cs1Vl = sl.cs2Vl = c1;
                break;
            case $O._LESS_EQUAL:
            case $O._GREATER:
                sl.cs1Vl = l;
                sl.cs2Vl = c1;
                break;
            case $O._GREATER_EQUAL:
            case $O._LESS:
                sl.cs1Vl = c1;
                sl.cs2Vl = h;
                break;
            case $O._IN:
            case $O._NOT_IN:
            case $O._IS_NULL:
            case $O._IS_NOT_NULL:
                break;
            default:
                sl.cs1Vl = c1;
                sl.cs2Vl = c2;
                break;
            }

            sl.cs1Idx = this.getIdx(sl.cs1Vl);
            sl.cs2Idx = this.getIdx(sl.cs2Vl);

            if (sl.dt != 30) {
               //Try to use the constant, the constant holds the correct value of the expression,
               //the items collection contains only an approximate value
               sl.cs1Nm = notNull(sl.cs1Vl) ? $M.formatNumber(sl.qua, sl.cs1Vl, sl.numFmts) : sl.items[sl.cs1Idx].n;
               sl.cs2Nm = notNull(sl.cs2Vl) ? $M.formatNumber(sl.qua, sl.cs2Vl, sl.numFmts) : sl.items[sl.cs2Idx].n;
            }

            sl.unit = this.getUnit();

            sl.set('unSet', (sl.dt == 30 || !validateData(sl) || displayInvalid(sl) || (!sl.cs || sl.cs.length == 0)) && !sl.staticStatus);
        };

        /**
         * Update operator and constant list
         */
        this.updateOpCs = function () {
            //update operator
            var i = (sl.cs1Vl > sl.cs2Vl)? sl.cs2Vl : sl.cs1Vl,
                a = (sl.cs1Vl > sl.cs2Vl)? sl.cs1Vl : sl.cs2Vl,
                l = sl.low,
                h = sl.high,
                il = sl.include,
                $O = $M.OP,
                isPercent = (sl.qua == $M.Q._PT || sl.qua == $M.Q._PB),
                unset,
                cs = [];

            if ((i >= l && a <= h) || i < l || a > h) { sl.opId = (il)? $O._BETWEEN : $O._NOT_BETWEEN;}
            if (i == a) { sl.opId = (il)? $O._EQUALS : $O._NOT_EQUALS;}
            if (i == l && a < h ) { sl.opId = (il)? $O._LESS_EQUAL : $O._GREATER;}
            if (i > l && a == h) {sl.opId = (il)? $O._GREATER_EQUAL : $O._LESS;}

            unset = l == i && a == h;
            if(!unset){
                //update cs
                switch (sl.opId){
                case $O._BETWEEN:
                case $O._NOT_BETWEEN:
                    cs.push({dtp:5, v: $NM.toLocaleString(i) + (isPercent? '%' : '')});

                case $O._EQUALS:
                case $O._NOT_EQUALS:
                    cs.push({dtp:5, v: $NM.toLocaleString(a) + (isPercent? '%' : '')});
                    break;
                 default:
                     if (i > l) { cs.push({dtp:5, v: $NM.toLocaleString(i) + (isPercent? '%' : '')});}
                     if (a < h) { cs.push({dtp:5, v: $NM.toLocaleString(a) + (isPercent? '%' : '')});}
                }
            }
            sl.cs = cs;

            //Update the parent constants as well
            sl.parent.node.data.cs = cs;
            sl.set('unSet', unset);
        };

        /**
         * Updates the position for all slider elements (handles, thumb and ranges).
         *
         */
        this.updateThumb = function () {
            var cs1Idx = sl.cs1Idx,
                cs2Idx = sl.cs2Idx;

            // Do we have cs1 and cs2 index values?
            if (cs1Idx !== undefined && cs2Idx !== undefined) {
                var unit = sl.unit,
                    gap = sl.gap;

                // Position all slider elements and copy return handle values onto the slider.
                $HASH.copy(positionSliderElements(sl, sl, $MATH_ROUND(cs1Idx * unit - gap), $MATH_ROUND(cs2Idx * unit - gap)), sl);
            }
        };

        this.joinConst = function () {
            var cs = sl.cs;
            if (cs) {
                var constValues = [],
                    i;

                for (i in cs){
                    constValues.push(cs[i].v);
                }

                return constValues.join(',');
            }
        };
    }

    var tooltipMarkup = '<span {@ttpCssText}>{@content}</span>';

    /**
     * Initializes and synchronizes the ghost with the source widget.
     *
     * @private
     */
    function initGhost() {
        // Does this slider have a static status?
        if (this.staticStatus) {
            // Nothing to do.
            return null;
        }

        // Have we NOT created the ghost already?
        var ghost = this.ghost;
        if (!ghost) {
            // Clone the container node.
            var cn = this.containerNode.cloneNode(true),
                cnc = cn.childNodes;

            // Add ghost class.
            $C.addClass(cn, [ 'gh' ]);

            // Create ghost object.
            ghost = this.ghost = {
                containerNode: cn,
                lowerRange: cnc[0],
                handle1Node: cnc[1],
                thumbNode: cnc[2],
                handle2Node: cnc[3],
                upperRange: cnc[4]
            };

            // Append the ghost container node.
            this.sdcNode.appendChild(cn);
        }

        var orCfg = this.orCfg,
            position = orCfg.posCssP,
            length = orCfg.lenCssP,
            id = this.id;

        // Iterate the nodes that need to be synchronized.
        mstrmojo.array.forEach([ 'lowerRange', 'containerNode', 'thumbNode', 'upperRange' ], function (nodeName, idx) {
            // Get the widget node style and ghost node style.
            var slider = mstrmojo.all[id],
                widgetNodeStyle = slider[nodeName].style,
                ghostNodeStyle = ghost[nodeName].style;

            // Is this not the lowerRange node?
            if (idx) {
                // Set the ghost position to match the widget node position.
                ghostNodeStyle[position] = widgetNodeStyle[position];
            }

            // Set the ghost length to match the widget node length;
            ghostNodeStyle[length] = widgetNodeStyle[length];
        });

        // Display the ghost container.
        ghost.containerNode.style.display = 'block';

        return ghost;
    }

    /**
     * <p>The widget for vertical Slider.</p>
     *
     * @class
     * @extends mstrmojo.Widget
     */
    mstrmojo.MetricSlider = mstrmojo.declare(
        // super class
        mstrmojo.Slider,

        // mixins
        [ mstrmojo._HasPopup ],

        /**
         * @lends mstrmojo.Slider.prototype
         */
        {
            scriptClass: "mstrmojo.MetricSlider",

            markupString: '<div>' +
                            '<div class="mstrmojo-Slider-summary"></div>'+
                            '<div class="mstrmojo-Slider {@cssClass} {@clsType} {@clsOrientation}" style="{@cssText}" >' +
                                '<div class="cont" style="position:absolute;">' +
                                    '<div class="bk" style="margin-top: 2px;{@bkCssText}"></div>' +
                                    '<div class="sdc" style="position:absolute;{@sdcCssText}">' +
                                        '<div class="sd" style="{@sdCssText}">' +
                                            '<div class="bk" style="{@lowerRangeCssText}"></div>' +
                                            '<div class="t1" style="{@handle1CssText}" mstrAttach:mouseover,mouseout,click></div>' +
                                            '<div class="t2 bk" style="{@thumbCssText}"></div>' +
                                            '<div class="t3" style="{@handel2CssText}" mstrAttach:mouseover,mouseout,click></div>' +
                                            '<div class="bk" style="{@upperRangeCssText}"></div>' +
                                        '</div>' +
                                    '</div>' +
                                    '<div class="mstrmojo-Label" style="margin-top:5px;float:left;"></div>' +
                                    '<div class="mstrmojo-Label" style="margin-top:5px;float:right;"></div>' +
                                '</div>' +
                            '</div>'+
                        '</div>',

            markupSlots: {
                summaryNode: function() {return this.domNode.childNodes[0];},
                dndNode: function() {return this.domNode.childNodes[1].childNodes[0];},
                bgNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[0];},
                sdcNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1];},
                containerNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0];},
                lowerRange: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[0];},
                handle1Node: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[1];},
                thumbNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[2];},
                handle2Node: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[3];},
                upperRange: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[1].childNodes[0].childNodes[4];},
                tooltipNode: function(){return this.domNode.childNodes[1].childNodes[0].childNodes[1];},
                lowNode: function(){return this.domNode.childNodes[1].childNodes[0].childNodes[2];},
                highNode: function() {return this.domNode.childNodes[1].childNodes[0].childNodes[3];},
                editValueNode: function(){return this.domNode;}
            },

            markupMethods: {
                onlowTextChange: function (){ this.lowNode.innerHTML = this.lowText || ''; },
                onhighTextChange: function (){ this.highNode.innerHTML = this.highText || ''; },
                onfontChange: function () { this.lowNode.style.font = this.highNode.style.font = String(this.font); },
                onunSetChange: function () { $C.toggleClass(this.domNode.childNodes[1], 'invalid', this.unSet); }
            },

            init: function init(p) {
                this._super(p);

                this.handleSize = mstrmojo.MetricSlider.METRICSLIDERTHUMBWIDTH;

                this.clsType = 'scm';
                this.typeHelper = new MetricSlider(this);
                this.useRichTooltip = false;
            },

            //========================= Rendering ============================================================

            unSet : false, //this flag will be set to true when because of some combination of value the slider needs to be set to "unset" state

            preBuildRendering: function preBuildRendering() {
                // Setup orientation based configuration parameters.
                var orCfg = this.orCfg,
                    isHoriz = this.isHoriz;

                orCfg.cPosCssP = (isHoriz) ? 'right' : 'bottom';
                orCfg.cLenCssP = (isHoriz) ? 'height' : 'width';

                var dimension = orCfg.lenCssP,
                    rawLength = this[dimension],
                    length = parseInt(rawLength, 10),
                    handleSize = this.handleSize;

                var effectiveLength = this._length = (isNaN(length)) ? 0 : (length - handleSize);
                if (effectiveLength <= 0) {
                    effectiveLength = this._length = mstrmojo.MetricSlider.METRICSLIDERDEFAULTWIDTH - handleSize;   //default value
                }

                if (rawLength) {
                    this.bkCssText = dimension + ':' + $MATH_MAX(length - (2 * this.cssBkBW), 0) + 'px;';
                    this.sdcCssText =  orCfg.posCssP + ':0px;' + dimension + ':' + effectiveLength + 'px;' + orCfg.opPosCssP + ':0px;';
                }

                this.typeHelper.initialMetricSlider();
                this.typeHelper.updateThumb();
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                if (!this.staticStatus && !this.da.nov) {
                    var ln = this.lowNode,
                        fos = parseInt(ln.style.fontSize, 10);

                    ln.style.fontSize = this.highNode.style.fontSize = $MATH_ROUND((isNaN(fos) ? 8 : fos) * this.parent.model.zf) + 'pt';

                    this.updateSummary();
                }
            },

            onmouseover: function onmouseover(evt) {
                this.showTooltip(evt.e, self);
            },

            onmouseout: function onmouseout(evt) {
                this.hideTooltip(evt.e, self);
            },

            summaryLabels: {
                db : $DESC(8153, "Between ## and ###"),
                dnb: $DESC(8154,"Not between ## and ###"),
                din: $DESC(587,"In"),
                dnin: $DESC(2204,"Not in"),
                dnull: $DESC(2202,"Is Null"),
                dnnull: $DESC(2203,"Is not Null"),

                req: $DESC(8155,"Rank ="),
                rneq: $DESC(8156,"Rank <>").replace("<>", String.fromCharCode(0x2260)),
                rexb: $DESC(8157,"Rank exclude bottom"),
                rext: $DESC(8158,"Rank exclude top"),
                rb: $DESC(8159,"Rank bottom"),
                rt: $DESC(8160,"Rank top"),
                rbt: $DESC(8161,"Rank between ## and ###"),
                rnbt: $DESC(8162,"Rank not between ## and ###"),
                rin: $DESC(8163,"Rank in"),
                rnin: $DESC(8164,"Rank not in"),

                peq: $DESC(8165,"Percent ="),
                pneq: $DESC(8166,"Percent <>").replace("<>", String.fromCharCode(0x2260)),
                pexb: $DESC(8167,"Exclude bottom"),
                pext: $DESC(8168,"Exclude top"),
                pb: $DESC(7576,"Bottom"),
                pt: $DESC(7575,"Top"),
                pbt: $DESC(8153,"Between ## and ###"),
                pnbt: $DESC(8154,"Not between ## and ###"),
                pin: $DESC(8169,"Percent in"),
                pnin: $DESC(8170,"Percent not in")
            },

            updateSummary: function updateSummary() {
                /**
                 * IMPORTANT
                 * if this method is modified please modify mstrScrollerImpl.js so the summary on mojo and dhtml match.
                 *
                 **/

                if (this.summaryNode && !this.staticStatus) {
                    var f  = this.f,  //mstr.Enum.Nodes.FUNCTION.* || mstr.Enum.Nodes.MRPFUNCTION.*
                        ft = this.ft, //mstr.Enum.Nodes.FUNCTIONTYPE.RANKPERCENT || mstr.Enum.Nodes.FUNCTIONTYPE.RANK ||  mstr.Enum.Nodes.FUNCTIONTYPE.DEFAULT
                        fte = $M,
                        fe = $M.FN,
                        fmrpe = $M.MRPFN,
                        txt = "",
                        fl = (this.cs1Vl < this.cs2Vl)? this.cs1Nm : this.cs2Nm,
                        fr = (this.cs1Vl > this.cs2Vl)? this.cs1Nm : this.cs2Nm,
                        th = this.typeHelper,
                        s = this.summaryLabels,
                        specialCase = (ft == fte._GENERIC && (f == fe.ISNULL || f == fe.ISNOTNULL || f == fe.NOTIN || f == fe.IN)) ||
                                        ((ft == fte._PERCENT || ft == fte._RANK) && (f == fmrpe.INASCENDING || f == fmrpe.INDESCENDING || f == fmrpe.NOTINDESCENDING || f == fmrpe.NOTINASCENDING));

                    //remove the summary if the selector is being updated to unset
                    if(!this.unSet || specialCase){
                        switch(ft){
                            case  fte._GENERIC:
                                switch(f){
                                case fe.EQUALS:
                                    txt = "= " + fl;
                                    break;
                                case fe.NOTEQUALS:
                                    txt = String.fromCharCode(0x2260) + " " + fl;
                                    break;
                                case fe.GREATERTHAN:
                                    txt = "> " + fr;
                                    break;
                                case fe.GREATERTHANEQUALS:
                                    txt = String.fromCharCode(0x2265) + " " + fl;
                                    break;
                                case fe.LESSTHAN:
                                    txt = "< " + fl;
                                    break;
                                case fe.LESSTHANEQUALS:
                                    txt = String.fromCharCode(0x2264) + " " + fr;
                                    break;
                                case fe.BETWEEN:
                                    txt = s.db.replace("##",fl).replace("###",fr);
                                    break;
                                case fe.NOTBETWEEN:
                                    txt = s.dnb.replace("##",fl).replace("###",fr);
                                    break;
                                case fe.ISNULL:
                                    txt = s.dnull;
                                    break;
                                case fe.ISNOTNULL:
                                    txt = s.dnnull;
                                    break;
                                case fe.IN:
                                    txt = s.din + " " + th.joinConst();
                                    break;
                                case fe.NOTIN:
                                    txt = s.dnin + " " +th.joinConst();
                                    break;
                                }
                                break;
                            case fte._PERCENT:
                            case fte._RANK:

                                var pr = "r";
                                if(ft == fte._PERCENT) pr = "p";

                                switch(f){
                                case fmrpe.EQUALSDESCENDING:
                                case fmrpe.EQUALSASCENDING:
                                    txt = s[pr + "eq"] + " " + fl;
                                    break;
                                case fmrpe.NOTEQUALSDESCENDING:
                                case fmrpe.NOTEQUALSASCENDING:
                                    txt = s[pr + "neq"] + " " + fl;
                                    break;
                                case fmrpe.GREATERTHANEQUALSASCENDING:
                                    txt = s[pr + "exb"] + " " + fl;
                                    break;
                                case fmrpe.GREATERTHANASCENDING:
                                    txt = s[pr + "exb"] + " " + fr;
                                    break;
                                case fmrpe.GREATERTHANEQUALSDESCENDING:
                                    txt = s[pr + "ext"] + " " + fl;
                                    break;
                                case fmrpe.GREATERTHANDESCENDING:
                                    txt = s[pr + "ext"] + " " + fr;
                                    break;
                                case fmrpe.LESSTHANASCENDING:
                                    txt = s[pr + "b"] + " " + fl;
                                    break;
                                case fmrpe.LESSTHANEQUALSASCENDING:
                                    txt = s[pr + "b"] + " " + fr;
                                    break;
                                case fmrpe.LESSTHANDESCENDING:
                                    txt = s[pr + "t"] + " " + fl;
                                    break;
                                case fmrpe.LESSTHANEQUALSDESCENDING:
                                    txt = s[pr + "t"] + " " + fr;
                                    break;
                                case fmrpe.BETWEENDESCENDING:
                                case fmrpe.BETWEENASCENDING:
                                    txt = s[pr + "bt"].replace("##",fl).replace("###",fr);
                                    break;
                                case fmrpe.NOTBETWEENASCENDING:
                                case fmrpe.NOTBETWEENDESCENDING:
                                    txt = s[pr + "nbt"].replace("##",fl).replace("###",fr);
                                    break;
                                case fmrpe.INASCENDING:
                                case fmrpe.INDESCENDING:
                                    txt = s[pr + "in"] + " " + th.joinConst();
                                    break;
                                case fmrpe.NOTINDESCENDING:
                                case fmrpe.NOTINASCENDING:
                                    txt = "";
                                    txt = s[pr + "nin"] + " " + th.joinConst();
                                    break;
                                }
                                break;
                        }
                    }

                    var summaryNode = this.summaryNode,
                        margin = (txt !== '') ? '' : 0;     // TQMS #556491: Margin needs to be zero if there is no summary.

                    // Set the summary text and margin.
                    summaryNode.innerHTML = txt;
                    summaryNode.style.margin = margin;

                    if (this.hasRendered && this.height == null){
                        this.parent.updateHeight();
                     }

                }
            },

            getClientHeight: function getClientHeight(){
                return this.dndNode.clientHeight + this.summaryNode.clientHeight + 15;//include padding from CSS.
            },

            //======================= Drag and Drop ======================================
            initDrag: function initDrag(e, hWin) {
                if (!this.staticStatus && !this.da.nov) {
                    hWin = hWin || window;

                    //
                    var td = $D.eventTarget(hWin, this.dnd.startE);
                    if (td === this.handle1Node || td === this.handle2Node) {

                        var ghost = initGhost.call(this),
                            oc = this.orCfg,
                            dnd = this.dnd;

                        dnd.initD = {
                            handle1: parseFloat(this.handle1, 10),
                            handle2: parseFloat(this.handle2, 10),
                            length: this._length,
                            contL: ghost.containerNode[oc.lenP],
                            offset: $D.getMousePosition(this.dnd.startE, hWin)[oc.offsetP]
                        };

                        dnd.initD.td = td;

                        $C.removeClass(this.domNode.childNodes[1], ['invalid']);
                    }
                }
            },

            ondrag: function ondrag(e, hWin){
                if (!this.staticStatus) {
                    hWin = hWin || window;

                    var initD = this.dnd.initD;
                    if (initD) {
                        var ghost = this.ghost,
                            cs1Px = initD.handle1,
                            cs2Px = initD.handle2,
                            cs1Idx = this.cs1Idx,
                            cs2Idx = this.cs2Idx,
                            unit = this.unit,
                            gap = this.gap,
                            length = initD.length;

                        // mouse position offset from initial state.
                        var diff = $D.getMousePosition(e, hWin)[this.orCfg.offsetP] - initD.offset;
                        switch (initD.td) {
                            case this.handle1Node:
                                cs1Px = $MATH_MAX($MATH_MIN($MATH_MAX(initD.handle1 + diff, 0), length) - gap, -1);
                                cs1Idx = $MATH_MAX($MATH_FLOOR(cs1Px / unit + 0.5), 0);
                                break;

                            case this.handle2Node:
                                cs2Px = $MATH_MAX($MATH_MIN($MATH_MAX(initD.handle2 + diff, 0), length) - gap, -1);
                                cs2Idx = $MATH_MAX($MATH.ceil(cs2Px / unit + 0.5), 0);  // TQMS #595207: use ceil() to make sure it gets to right-most position.
                                break;

                            default:
                                return;
                        }

                        // Position slider elements.
                        positionSliderElements(this, ghost, cs1Px, cs2Px);

                        var items = this.items,
                            itemCount = (items && items.length) || 0;

                        if (itemCount && cs1Idx >= 0 && cs1Idx < itemCount && cs2Idx >= 0 && cs2Idx < itemCount) {
                            var _changed = false;
                            if (cs1Idx !== this.cs1Idx) {
                                this.cs1Idx = cs1Idx;
                                var itm = this.items[cs1Idx];
                                this.cs1Vl = itm.v;
                                this.cs1Nm = itm.n;
                                _changed = true;
                            }
                            if (cs2Idx !== this.cs2Idx) {
                                this.cs2Idx = cs2Idx;
                                var itm = this.items[cs2Idx];
                                this.cs2Vl = itm.v;
                                this.cs2Nm = itm.n;
                                _changed = true;
                            }

                            if (_changed) {
                                // update thumb and tooltip
                                this.typeHelper.updateThumb();
                                this._updateTooltip(initD.td);
                            }
                        }
                    }
                }
            },

            ondrop: function ondrop(/*DomEvent*/ e){
                if (!this.staticStatus && !this.da.nov) {
                    this.typeHelper.updateThumb();

                    var ghost = this.ghost;
                    if (ghost) {
                        ghost.containerNode.style.display = "none";
                    }

                    this.hideTooltip(e, self);

                    if (this.items && this.items.length){
                        this[($D.eventTarget(self, e) === this.ghost.handle1Node)? 'frtUst' : 'ndUst'] = false;
                        this.selectRange();
                    }

                    this.dnd.initD = null;
                }
            },

            //======================= Select range change ======================================
            selectRange : function slctrng(onlyInclude, changeQual, updateUnset) {
                var T = this.typeHelper,
                    c1 = this.cs1Vl,
                    c2 = this.cs2Vl,
                    q = this.qua,
                    nf = this.numFmts;

                this.cs1Idx = T.getIdx(c1);
                this.cs2Idx = T.getIdx(c2);

                var isEdge = function(idx, itms) {
                        var its = itms || [];
                        return idx == 0 || idx == its.length -1;
                    },
                    unsetStr = $DESC(7622);

                this.cs1Nm = isEdge(this.cs1Idx, this.items) && !this.frtUst ? unsetStr : $M.formatNumber(q, c1, nf);
                this.cs2Nm = isEdge(this.cs2Idx, this.items) && !this.ndUst ? unsetStr : $M.formatNumber(q, c2, nf);

                T.updateOpCs();

                //send only the include flag manipulation
                this.onlyInclude = !!onlyInclude;
                this.changeQual = !!changeQual;
                this.unSet = !!updateUnset || this.unSet;

                this.updateSummary();
                this.onselectionChange();
             },

             onincludeChange : function incChange(){
                 if (!this.staticStatus) {
                     this.selectRange(true);
                 }
             },

            //======================= Tooltip ===================================================
            showTooltip: function showTooltip(e, win) {
                 var tgt = $D.eventTarget(win, e);
                 this._updateTooltip(tgt);
                 mstrmojo.tooltip.open(this, e, win);
            },

            /**
             * Positions tooltip correctly according to current slider's position and style (horizontal/vertical).
             * Updates tooltip content to current selection.
             *
             * @private
             */
            _updateTooltip: function _updateTooltip(tgt) {
                var oc = this.orCfg,
                    ps = oc.posCssP,
                    txt,
                    tt = {
                        contentNodeCssClass: 'scm-tooltip',
                        refNode: this.domNode.childNodes[1],
                        posType: this._tooltip_pos
                    };

                tt[oc.opPosCssP] = - parseInt(this.font)/2;
                tt[ps] = tgt.style[ps];

                if (this.unSet) {
                    txt = $DESC(7622);
                } else {
                    txt = String((tgt === this.handle1Node) ? this.cs1Nm: this.cs2Nm);
                }

                tt.content = tooltipMarkup.replace(/\{@content\}/g, txt);

                this.set('richTooltip', tt);
            },

            //======================= Event handling for click on thumbs=========================
            onclick: function onclick(evt) {
                if (!this.staticStatus && !this.da.nov) {
                    var tgt = $D.eventTarget(evt.hWin || window, evt.e);
                    
                    this.dnd.initD = {
                    		makeMetricSilderSelectionByClick: true,
                    		td: ((tgt===this.handle1Node) ? this.handle1Node : ((tgt=== this.handle2Node) ? this.handle2Node : null))
                    };
                    
                    this.openEditValue({
                        isfrt: (tgt === this.handle1Node),
                        tgt: tgt
                    });

                    if (this._onThumb) {
                        // A hook for custom behavior
                        this._onThumb(evt);
                    }
                }
            },
            
            onselectionChange: function onselChg(evt) {
            	this._super(evt);
            	
            	// Remove temporary data
        		if (this.dnd.initD && this.dnd.initD.makeMetricSilderSelectionByClick){
        			this.dnd.initD = null;
        		}
            },

            onquaChange: function onqChg(evt){
                var oldf = mstrmojo.MCSUtil.getFuncInfo(this.opId, evt.valueWas),
                    newf = mstrmojo.MCSUtil.getFuncInfo(this.opId, evt.value),
                    u;

                if (oldf.ft != newf.ft) {
                    if (!this.staticStatus) {
                        this.items = [];
                        this.cs = [];
                        this.f = this.ft = null;
                        this.refresh();
                        u = true;
                    }
                } else {
                    this.f = mstrmojo.MCSUtil.getFuncInfo(this.opId, evt.value).f;
                    u = false;
                }

                this.selectRange(false, true, u);
            },

            updateData: function udtDt(da, props){
                this.da = da;

                //TQMS 467964: some properties moved from def block to data block.
                // TODO: need to refactoring the object structure in the future.
                this.updateExpr(props);

            },

            updateExpr: function udtEp(props) {
                if (props) {
                    this.cs = props.cs;
                    this.f = props.f;
                    this.ft = props.ft;
                    this.qua = props.qua;
                }
                this.refresh();
            },

            editValueRef:{
                cssClass: "edvl",
                slot: "editValueNode",
                scriptClass: "mstrmojo.Popup",
                locksHover: true,
                onOpen: function() {
                    if (this.tgt) {
                        this.set("left", $MATH_MIN($MATH_MAX(parseInt(this.tgt.style.left, 10), 0), parseInt(this.opener.width, 10) - 90) + 'px');
                        this.set("top", this.tgt.style.top);
                    }
                    var op = this.opener,
                    cld = this.children[0];
                    if (op) {
                        var v = this.isfrt ? op.cs1Vl : op.cs2Vl;
                        if (this.isfrt){
                            if ((op.cs1Vl <= op.low || op.cs1Vl >= op.high) && !op.frtUst){
                                v = '';
                            }
                        } else {
                            if((op.cs2Vl <= op.low || op.cs2Vl >= op.high) && !op.ndUst){
                                v = '';
                            }
                        }
                        cld.edt.set('value', $NM.toLocaleString(v));
                    }
                },
                children:[{
                  scriptClass : "mstrmojo.Table",
                  rows:1,
                  cols: 2,
                  layout: [{
                      cells: [{
                          cssText: "width: 40px; padding: 3px;"
                      }, {
                          cssText: "width: 16px;padding: 3px;"
                      }]
                  }],
                  children : [{
                        slot: "0,0",
                        scriptClass : "mstrmojo.ValidationTextBox",
                        alias: "edt",
                        cssText: "color:black",
                        dtp: mstrmojo.expr.DTP.NUMERIC,
                        constraints: {
                            trigger: mstrmojo.validation.TRIGGER.ALL
                        },
                        onValid: function() {
                            if (this.parent.apply) {
                                this.parent.apply.set("enabled", String(this.value).length != 0);
                            }
                        },
                        onInvalid: function() {
                            if (this.parent.apply) {
                                this.parent.apply.set("enabled", false);
                            }
                        },
                        onkeyup: function(evt) {
                            if (this.parent.apply.enabled) {
                                var hWin = evt.hWin,
                                    e = evt.e || hWin.event;
                                if (e.keyCode === 13){
                                    this.parent.apply.onclick();
                                }
                            }
                        }
                    }, {
                        slot: "0,1",
                        scriptClass : "mstrmojo.Button",
                        cssClass : 'icn apply',
                        alias: "apply",
                        onclick : function() {
                            var p = this.parent.parent,
                                op = p.opener,
                                v = this.parent.edt.value;

                            if (p && op && String(v).length > 0) {
                                op[p.isfrt ? 'cs1Nm' : 'cs2Nm'] = v;
                                v = $NM.parseNumeric(v);
                                op[p.isfrt ? 'cs1Vl' : 'cs2Vl'] = v;
                            }

                            op[p.isfrt? 'frtUst' : 'ndUst'] = true;
                            op.selectRange();

                            op.typeHelper.updateThumb();
                            p.close();
                        }
                    }]
                }]
            },

            openEditValue: function(/*Object*/ config) {
                this.openPopup("editValueRef", config);
            }
        }
    );

    mstrmojo.MetricSlider.METRICSLIDERTHUMBWIDTH = 14;
    mstrmojo.MetricSlider.METRICSLIDERDEFAULTWIDTH = 95;

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.GraphBase",
                         "mstrmojo._Formattable",
                         "mstrmojo._HasWaitIcon",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo.tooltip");

    var $D = mstrmojo.dom;

    /**
     * Utility function to set the graph height to the height of the rwunit minus the height of the titlebar.
     * 
     * @param {mstrmojo.DocXtabGraph} w The graph widget.
     */
    function adjustGraphHeight(w) {
        var f = w.getFormats();
        if (!f.width && 'gp' in f) {
            f = f.gp;
        }
        w.resizeForDisplayState(parseInt(f.height, 10), parseInt(f.width, 10), false);
    }

    function _getEventPos(e) {
        //        var d = ('layerX' in e) ? 'layer' : 'offset'; 
//        return {
//            x: e[d + 'X'],
//            y: e[d + 'Y']
//        };
        
        var domNodePosition = $D.position(this.domNode),        // Position of the dom node.
            mousePosition = $D.getMousePosition(e);             // position of the mouse
        return {
            x: parseInt(mousePosition.x - domNodePosition.x, 10),
            y: parseInt(mousePosition.y - domNodePosition.y, 10)
        };
    }
    
    /**
     * get items that are overlapped with the target of mouse event
     */
    function getOverlappedItems(e, win) {
    	var t = $D.eventTarget(win, e),
			p = t && t.parentNode,
			c = p && p.children,
			as = [],
			coords = t.getAttribute("coords");
		if (c && !!coords) {
			for (var i = 0; i < c.length; ++i) {
				if (c[i] && c[i].getAttribute && c[i].getAttribute("coords") == coords) {
					as.push(c[i]);
				}
			}
		}
		return as;
    }

    /**
     * <p>The widget for a single MicroStrategy Report Services Graph control.</p>
     * 
     * @class
     * @extends mstrmojo.GraphBase
     * 
     * @borrows mstrmojo._Formattable#formatHandlers as #formatHandlers
     * @borrows mstrmojo._Formattable#getFormats as #getFormats
     * 
     * @borrows mstrmojo._IsSelectorTarget#setDirty as #setDirty
     */
    mstrmojo.DocXtabGraph = mstrmojo.declare(
        // superclass
        mstrmojo.GraphBase,

        // mixins,
        [ mstrmojo._Formattable, mstrmojo._HasWaitIcon, mstrmojo._IsSelectorTarget ],

        /** 
         * @lends mstrmojo.DocXtabGraph.prototype
         */
        {
            scriptClass: "mstrmojo.DocXtabGraph",

            cssClassPrefix: "mstrmojo-DocXtabGraph",

            areaMarkup: '<area shape="{@shape}" coords="{@coords}" ttl="{@tooltip}" aid="{@aid}" onclick="mstrmojo.all[\'{@id}\'].onClickArea(this, event);" onmousemove="mstrmojo.all[\'{@id}\']._updateTooltip(event, self);" {@extra}/>',

            _att: '',

            markupSlots: {
                imgNode: function () { return this.domNode.childNodes[1]; },
                mapNode: function () { return this.domNode.childNodes.length > 2 ? this.domNode.childNodes[2] : null; },
                textNode: function () { return this.domNode.firstChild; }
            },

            formatHandlers: {
                domNode: [ 'RW', 'B', 'background-color', 'fx' ]
            },

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? 'block' : 'none'; }
            },

            onClickArea: function onClickArea(elem, e) {
                e = e || window.event;

                var ep = _getEventPos.apply(this, [e]),                               // Position of mouse click.
                    defn = this.defn,
                    domNodePosition = $D.position(this.domNode),        // Position of the dom node.
                    area = this.as[elem.getAttribute('aid')],
                    key = this.k,
                    x = ep.x,
                    y = ep.y,
                    anchor = {                                            // Simulate an anchor for info windows (ignored for drill).
                       getBoundingClientRect: function () {
                        var left = domNodePosition.x + x,
                            top = domNodePosition.y + y;

                        return {
                            left: left,
                            top: top,
                            right: left + 1,
                            bottom: top + 1
                        };
                       }, 
                       
                       w: this // the container widget of this anchor
                	};
                
                this.showInfoWin(area.tks, anchor);

                // Slice.
                this.model.slice({
                    type: parseInt(defn.t, 10) || mstrmojo.EnumRWUnitType.GRAPH,
                    src: key,
                    ck: defn.ck,
                    gk: key,
                    tks: area.tks,
                    cks: area.cks,
                    sid: this.node.data.sid,
                    x: x,
                    y: y,
                    anchor: anchor,
                    tty: area.tty
                });
            },
            
            showInfoWin: function showInfoWin(tks, anchor) {
            	var m = this.model,
            		ifws = tks && m.getTargetInfoWin(tks);
            	if (ifws && ifws.length) {
            		for (var i = 0;i < ifws.length; i++) {
            			m.showInfoWin(ifws[i], anchor, 'h');
            		}
            	}
            },

            showTooltip: function showTooltip(e, win) {
                this._updateTooltip(e, win);
                var items = getOverlappedItems(e, win);
                if (items && items.length > 1) {
                	// TQMS 762074: need to show multiple tooltips
                	mstrmojo.DocXtabGraph.multiTooltip.open(this, e, win, items);
                } else {
                	this._super(e, win);
                }
            },

            /**
             * Positions tooltip correctly according to current slider's position and style (horizontal/vertical).
             * Updates tooltip content to current selection.
             * 
             * @private
             */
            _updateTooltip: function _updateTooltip(evt, win) {
                this.updatingTooltipHelper($D.eventTarget(win, evt), _getEventPos.apply(this, [evt]));
            },

            hideTooltip: function hideTooltip(e, win) {
                var elem = $D.eventTarget(win, e);
                if (elem.getAttribute('aid') === this.cAreaIdx) {
                    // reset current focused area index to -1, since un-focus current area
                    this.cAreaIdx = -1;

                    // hide tooltip
                    var items = getOverlappedItems(e, win);
                    if (items && items.length > 1) {
                    	// TQMS 762074: need to close multiple tooltips
                    	mstrmojo.DocXtabGraph.multiTooltip.close(this, e, win, items);
                    } else {
                    	this._super(e, win);
                    }
                }
            },

            /**
             * Updates the DocXtabGraph data that may change due to a selector action.
             * 
             * @param {Object} node The widget node.
             * @ignore
             */
            update: function update(node) {
                this.node.data = node.data;
                // Grab the tooltip and selector areas.
                this.as = node.data.as;

                // Update target keys based on control group bys.
                var sep = '\u001E',
                    m = this.model,
                    cgbm = m.getCGBMap && m.getCGBMap(),
                    as = this.as || [],
                    i,
                    j;

                for (i = 0; i < as.length; i++) {
                    var a = as[i],
                        cgb = a && a.tgbs;

                    if (cgb) {
                        var cgbs = cgb.split(sep);
                        var keys = {};
                        for (j = 0; j < cgbs.length; j++) {
                            var k = cgbm && cgbm[cgbs[j]];
                            if (k) {    // control key
                                keys[k] = true;
                            } else {    // target key
                                keys[cgbs[j]] = true;
                            }
                        }
                        a.tks = mstrmojo.hash.keyarray(keys).join(sep);
                    }
                }

                // Grab the empty graph descriptor.
                this.eg = node.data.eg;
            },

            /**
             * Retrieves graph image source from server.
             * 
             * @param {Integer|String} h The height of the requested graph image.
             * @param {Integer|String} w The width of the requested graph image.
             */
            retrieveGraphSrc: function retrieveGraphSrc(h, w) {
                // Create graph source URL.
                var src = mstrConfig.taskURL + '?taskId=getRWGraphImage&taskEnv=xhr&__ts__=' + (new Date().getTime()) + '&messageID=' + this.model.mid + '&nodeKey=' + this.k + '&sliceID=' + parseInt(this.node.data.sid, 10) + '&imgType=4' + '&width=' + parseInt(w, 10) + '&height=' + parseInt(h, 10) + '&sessionState=' + mstrApp.sessionState,
                    imgNode = this.imgNode;

                // Is the src different from the original source?
                if (imgNode.src !== src) {
                    // Set new src.
                    imgNode.src = src;
                }
            },

            resize: function () {
                adjustGraphHeight(this);
            },

            /**
             * Called when the graph dimensions change due to user interaction with the title bar.
             * 
             *  @param {Integer} h The height of the available image space.
             *  @param {Integer} w The width of the available image space.
             *  @param {Boolean} [doDom] Indicates whether to resize/reposition the domNode as well as the imgNode.
             */
            resizeForDisplayState: function resizeForDisplayState(h, w, doDom) {
                var f = this.getFormats(),
                    imgNode = this.imgNode;

                // Does the domNode position/size need to be adjusted?
                if (doDom) {
                    var dns = this.domNode.style;

                    // Size and reposition domNode.
                    dns.top = f.top;
                    dns.left = f.left;
                    dns.height = f.height;
                    dns.width = f.width;
                }

                // The height of the graph is fixed (due to the title bar) so we need to manually adjust it.
                if (imgNode) {
                    imgNode.style.height = h + 'px';
                }

                // Do we have a valid graph?
                if (!this.eg) {
                    // Load a newly sized image.
                    this.retrieveGraphSrc(h, w);
                    if (h) {
                        this.refreshMap();
                    }
                }
            }
        }
    );

    
    /**
     * get width of element that trigger the tooltip
     */
    function getTargetWidth(a) {
    	if (a && a.getAttribute) {
    		var c = a.getAttribute("coords");
    		c = c && c.split(",");
    		if (c && c.length >= 3) {
    			return c[2] - c[0];
    		}
    	}
    	return 0;
    }
    
    /**
     * get positions for multiple tooltips
     */
    function getMultiPosition(targetWid) {
    	var p = [],
    		docw = document.body.offsetWidth,
    		doch = document.body.offsetHeight,
    		maxw = 0,
    		maxh = 0,
    		x = ttpList[0] && ttpList[0].domNode ? ttpList[0].domNode.offsetLeft : 0,
    		y = ttpList[0] && ttpList[0].domNode ? ttpList[0].domNode.offsetTop : 0,
    		line = Math.ceil(ttpList.length / 2),
    		margin = 5,
    		originalX = function(x, tpWid) {
				if (x + targetWid + tpWid + margin > docw) {
		    		// right of tooltip is out of screen, need to move left
		    		return docw - targetWid - tpWid - margin;
		    	} else if (ttpList.length > 1 && x - tpWid - margin < 0) {
		    		// left of tooltip is out of screen, need to move right
		    		return tpWid + margin;
		    	}
				return x;
			},
			originalY = function(y, tpHeight, line) {
				// set y to the top of target, not top of tooltip
				y += tpHeight;
		    	// half of height of all tooltips. if there is only one line tooltip, then should show this line top of target
				var toph = line == 1 ? tpHeight : (line * tpHeight + (line - 1) * margin) / 2;
		    	if (toph > y) {
		    		// top of tooltip is out of screen, need to move down
		    		return 0;
		    	} else if (toph + y > doch) {
		    		// bottom of tooltip is out of screen, need to move up
		    		return doch - toph * 2;
		    	} else {
		    		return y - toph;
		    	}
			};
		// get max height and width of tooltips
    	for (var i = 0; i < ttpList.length; ++i) {
    		maxw = Math.max(maxw, ttpList[i].containerNode.offsetWidth);
    		maxh = Math.max(maxh, ttpList[i].containerNode.offsetHeight);
    	}
    	x = originalX(x, maxw);
    	y = originalY(y, maxh, line);
    	for (var i = 0; i < ttpList.length; ++i) {
    		if (i % 2 == 0) {//tooltip on the right side
        		p.push({l: x + targetWid + margin, t: y});
    		} else {//tooltip on the left side
    			p.push({l: x - ttpList[i].containerNode.offsetWidth - margin, t: y});
    			y += maxh + margin;
    		}
    	}
    	return p;
    }

    var ttpList = [];
    mstrmojo.DocXtabGraph.multiTooltip = {
    		_posMultiTp: function(multiPos) {
        		for (var i = 0; i < ttpList.length; ++i) {
        			ttpList[i].domNode.style.left = multiPos[i].l + 'px';
        			ttpList[i].domNode.style.top = multiPos[i].t + 'px';
        		}
    		},
    		
            open: function(opener, e, win, as, config) {                
                if (!config) {
                    config = {};
                }
                config.e = e;
                config.win = win;
                var tw = 0;
                if (as && as.length) {
                	tw = getTargetWidth(as[0]);
                }

                for (var i = 0; i < as.length; ++i) {
                	var tp = ttpList[i];
                	if (!tp || !mstrmojo.all[tp.id]) {
                		tp = new mstrmojo.Tooltip();
                		var count = 0,
                			me = this;
                		// set positions for tooltips
                		tp.optimizePos = function() {
                        	count++;
                        	if (count >= ttpList.length) {
                        		count = 0;
                        		me._posMultiTp(getMultiPosition(tw));
                        	}	
                		}; 
                		ttpList.push(tp);
                	}
                	opener.richTooltip.content = as[i] && as[i].getAttribute('ttl');
                	tp.open(opener, config);
                }
            },
            
            close: function() {
            	for (var j = ttpList.length - 1; j >= 0; --j) {
            		ttpList[j].close();
            	}
            	ttpList = [];
            }
    };

}());
/**
  * _CanvasGraph.js
  * Copyright 2011 MicroStrategy Incorporated. All rights reserved.
  *
  * @fileoverview <p>Mixin that provides all the code to support HTML5 canvas graphs.</p>
  * @author <a href="mailto:dhill@microstrategy.com">Doug Hill</a>
  * @version 1.0
  */
(function () {
    mstrmojo.requiresCls("mstrmojo.graph._MobileGraphAreaHelper",
                         "mstrmojo.GraphBase",
                         "mstrmojo.dom");

    /**
     * Animation Constants
     */
    var ANIMATION_DURATION = 0,
        INITIAL_TIME = 0,
        //Enumeration for the different instruction types...
        InsUndefined = 0,
        InsSaveState = 1,
        InsRestoreState = 2,
        InsClip = 11,
        InsScale = 12,
        InsRotate = 13,
        InsNewPath = 101,
        InsClosePath = 102,
        InsMoveTo = 111,
        InsLineTo = 112,
        InsBezierCurveTo = 113,
        InsAddRect = 121,
        InsAddArc = 122,
        InsAddNeedle = 131,
        InsAddGaugeMarker = 132,
        InsAddString = 201,
        InsSetLineDash = 301,
        InsSetLineWidth = 302,
        InsSetLineJoin = 303,
        InsSetFontSize = 311,
        InsSetRGBAFillColor = 321,
        InsSetRGBAStrokeColor = 322,
        InsFillPath = 401,
        InsStrokePath = 402,
        InsFillSimple = 501,
        InsFillPattern = 502,
        InsFillGradient = 503,
        InsFillEdgeType = 511,
        InsFillDonutOrSphere= 512,
        InsFillRadientGradient = 513,
        InsFillDonut2Rect= 514,
        InsFillBorderMetallic = 515,
        InsMakeDarker = 521,
        InsRestoreColor = 522,
        InsApplyLineFormat = 601,
        InsAddFormatedText = 701,
        InsApplyBeveledFrameToRectangle = 801;
    var GradientReserved = 0,
        GradientCircular = 9,
        GradientRectangular = 10,
        GradientLinear = 14;
    var FillBevelNone = 0,
        FillBevelSmoothEdge = 1,
        FillBevelChiselEdge = 2,
        FillBevelDonut = 3,
        FillBevelSphere = 4;
    var RGPieSlice = 0,
        RGRing = 1,
        RG_BORDERRING = 2;
    var BSS_METALLIC_OUTER_RING = 2,
        BSS_METALLIC_MIDDLE_RING = 3;
    var FillSimple = 0,
        FillWash = 3,
        FillPicture = 4,
        FillUserPicture = 6,
        FillBrush = 13,
        FillAdvancedWash = 14,
        FillPattern = 101;
    var LineJoinMiter = 0,
        LineJoinBevel = 1,
        LineJoinRound = 2;
    var PI = 3.14159265;
    var startPoint,endPoint;
    var MS_Rectangle = 0,
        MS_XShape = 1,
        MS_PlusSymbolthin = 2,
        MS_PlusSymbolthick = 3,
        MS_Circle = 4,
        MS_Diamond = 5,
        MS_Triangle = 6,
        MS_Square = 7,
        MS_Star = 8,
        MS_Area = 9;
    var gLocalMarkerSize = 100;
    var gMarkerShapes = [
        [-100, -100, 100, -100, 100, 100, -100, 100],
        [-80, -100, 0, -20, 80, -100, 100, -80, 20, 0, 100, 80, 80, 100, 0, 20, -80, 100, -100, 80, -20, 0, -100, -80],
        [-33, -100, 33, -100, 33, -33, 100, -33, 100, 33, 33, 33, 33, 100, -33, 100, -33, 33, -100, 33, -100, -33, -33, -33],
        [-50, -100, 50, -100, 50, -50, 100, -50, 100, 50, 50, 50, 50, 100, -50, 100, -50, 50, -100, 50, -100, -50, -50, -50],
        [],
        [0, -100, 100, 0, 0, 100, -100, 0],
        [0, -100, 100, 100, -100, 100],
        [-100, -100, 100, -100, 100, 100, -100, 100],
        [0, -100, 23, -31, 95, -31, 36, 12, 59, 81, 0, 38, -59, 81, -36, 12, -95, -31, -23, -31],
        [0, -60, 100, -100, 100, 100, -100, 100, -100, -100, 0, -60, 0, 100]
    ];

    function drawWithContext(context, progress, unit, formatList){
        var insList = unit.InstructionList,
            insCount = insList.length,
            ins, j, x, y, h, w, format, color, formatIndex,
            gradient, startColor, endColor,
            rect, finalGradient, bevel, isCircularShape, darker;

        for (j = 0; j < insCount; j++)
        {
            //Get the current instruction...
            ins = insList[j];

            //Do we not have an instruction...
            if (typeof(ins) === 'undefined') {
                //alert(j + " " + insCount);
                continue;
            }

            //Switch case to draw on the canvas based on the instruction
            switch (ins.Ins) {
                case InsUndefined:
                    //alert('Instruction Undefined');
                    break;
                case InsSaveState:
                    context.save();
                    break;
                case InsRestoreState:
                    context.restore();
                    break;
                case InsClip:
                    context.clip();
                    break;
                case InsScale:
                    context.scale(ins.X, ins.Y);
                    break;
                case InsRotate:
                    if (ins.Radian !== 0) {
                        context.translate(ins.Anchor.X, ins.Anchor.Y);
                        context.rotate(ins.Radian);
                        context.translate(-ins.Anchor.X, -ins.Anchor.Y);
                    }
                    break;
                case InsNewPath:
                    context.beginPath();
                    break;
                case InsClosePath:
                    context.closePath();
                    break;
                case InsMoveTo:
                    if (unit.IsAnimated === 0) {
                        context.moveTo(ins.X, ins.Y);
                    } else {
                        if (ins.CA[0] == 0) {
                            x = ins.X[0] * (1 - progress) + ins.X[1] * progress;
                            y = ins.Y[0] * (1 - progress) + ins.Y[1] * progress;
                            context.moveTo(x, y);
                        } else {
                            var r1 = Math.sqrt((ins.X[0]-ins.BPX[0])*(ins.X[0]-ins.BPX[0]) + (ins.Y[0]-ins.BPY[0])*(ins.Y[0]-ins.BPY[0]));
                            var r2 = Math.sqrt((ins.X[1]-ins.BPX[0])*(ins.X[1]-ins.BPX[0]) + (ins.Y[1]-ins.BPY[0])*(ins.Y[1]-ins.BPY[0]));
                            var d = Math.sqrt((ins.X[0]-ins.X[1])*(ins.X[0]-ins.X[1]) + (ins.Y[0]-ins.Y[1])*(ins.Y[0]-ins.Y[1]));
                            var de = Math.acos((r1*r1+r2*r2-d*d)/(2*r1*r2));

                            // 497580, clark, handle the case when rotating angle is >= 180 degrees
                            var lDest = (ins.X[0]-ins.BPX[0]) * Math.cos(de) - (ins.Y[0]-ins.BPY[0]) * Math.sin(de) + ins.BPX[0] - ins.X[1];
                            if (lDest < -0.01 || lDest > 0.01)
                                de = 2*PI - de;

                            x = (ins.X[0]-ins.BPX[0]) * Math.cos(progress*de) - (ins.Y[0]-ins.BPY[0]) * Math.sin(progress*de) + ins.BPX[0];
                            y = (ins.Y[0]-ins.BPY[0]) * Math.cos(progress*de) + (ins.X[0]-ins.BPX[0]) * Math.sin(progress*de) + ins.BPY[0];
                            context.moveTo(x, y);
                        }
                    }
                    break;
                case InsLineTo:
                    if (unit.IsAnimated === 0) {
                        context.lineTo(ins.X, ins.Y);
                    } else {
                        if (ins.CA[0] == 0) {
                            x = ins.X[0] * (1 - progress) + ins.X[1] * progress;
                            y = ins.Y[0] * (1 - progress) + ins.Y[1] * progress;
                            context.lineTo(x, y);
                        } else {
                            var r1 = Math.sqrt((ins.X[0]-ins.BPX[0])*(ins.X[0]-ins.BPX[0]) + (ins.Y[0]-ins.BPY[0])*(ins.Y[0]-ins.BPY[0]));
                            var r2 = Math.sqrt((ins.X[1]-ins.BPX[0])*(ins.X[1]-ins.BPX[0]) + (ins.Y[1]-ins.BPY[0])*(ins.Y[1]-ins.BPY[0]));
                            var d = Math.sqrt((ins.X[0]-ins.X[1])*(ins.X[0]-ins.X[1]) + (ins.Y[0]-ins.Y[1])*(ins.Y[0]-ins.Y[1]));
                            var de = Math.acos((r1*r1+r2*r2-d*d)/(2*r1*r2));
                            
                            // 497580, clark, handle the case when rotating angle is >= 180 degrees
                            var lDest = (ins.X[0]-ins.BPX[0]) * Math.cos(de) - (ins.Y[0]-ins.BPY[0]) * Math.sin(de) + ins.BPX[0] - ins.X[1];
                            if (lDest < -0.02 || lDest > 0.02)
                                de = 2*PI - de;
                                
                            x = (ins.X[0]-ins.BPX[0]) * Math.cos(progress*de) - (ins.Y[0]-ins.BPY[0]) * Math.sin(progress*de) + ins.BPX[0];
                            y = (ins.Y[0]-ins.BPY[0]) * Math.cos(progress*de) + (ins.X[0]-ins.BPX[0]) * Math.sin(progress*de) + ins.BPY[0];
                            context.lineTo(x, y);
                        }
                    }
                    break;
                case InsBezierCurveTo:
                    if (unit.IsAnimated === 0) {
                        context.bezierCurveTo(ins.CP1X, ins.CP1Y, ins.CP2X, ins.CP2Y, ins.X, ins.Y);
                    } else {
                        cp1x = ins.CP1X[0] * (1 - progress) + ins.CP1X[1] * progress;
                        cp1y = ins.CP1Y[0] * (1 - progress) + ins.CP1Y[1] * progress;
                        cp2x = ins.CP2X[0] * (1 - progress) + ins.CP2X[1] * progress;
                        cp2y = ins.CP2Y[0] * (1 - progress) + ins.CP2Y[1] * progress;
                        x = ins.X[0] * (1 - progress) + ins.X[1] * progress;
                        y = ins.Y[0] * (1 - progress) + ins.Y[1] * progress;
                        context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                    }
                    break;
                case InsAddRect:
                    if (unit.IsAnimated === 0) {
                        context.rect(ins.X, ins.Y, ins.W, ins.H);
                    } else {
                        x = ins.X[0] * (1 - progress) + ins.X[1] * progress;
                        y = ins.Y[0] * (1 - progress) + ins.Y[1] * progress;
                        w = ins.W[0] * (1 - progress) + ins.W[1] * progress;
                        h = ins.H[0] * (1 - progress) + ins.H[1] * progress;
                        context.rect(x, y, w, h);
                    }
                    break;
                case InsAddArc:
                    if (unit.IsAnimated === 0) {
                        if (ins.EndAngle == 6.283) // 497606, clark, more precise
                         ins.EndAngle = 2*PI;
                        context.arc(ins.X, ins.Y, ins.Radius, ins.StartAngle, ins.EndAngle, ins.AntiClockwise);
                    } else {
                        if (ins.EndAngle[0] == 6.283) // 497606, clark, more precise
                         ins.EndAngle[0] = 2*PI;
                        if (ins.EndAngle[1] == 6.283) // 497606, clark, more precise
                         ins.EndAngle[1] = 2*PI;

                        context.arc(ins.X[0] * (1 - progress) + ins.X[1] * progress,
                                    ins.Y[0] * (1 - progress) + ins.Y[1] * progress,
                                    ins.Radius[0] * (1 - progress) + ins.Radius[1] * progress,
                                    ins.StartAngle[0] * (1 - progress) + ins.StartAngle[1] * progress,
                                    ins.EndAngle[0] * (1 - progress) + ins.EndAngle[1] * progress,
                                    ins.AntiClockwise[0]);
                    }
                    break;
                case InsAddGaugeMarker:
                    if (unit.IsAnimated == 1)
                    {
                        var angle = ins.Angle[0] * (1 - progress) + ins.Angle[1] * progress;
                        var lSize = ins.NeedleSize[0];
                        var bPX = ins.BPX[0];
                        var bPY = ins.BPY[0];
                        var markerSize = ins.MarkSize[0];
                        var markerShape = ins.MarkShape[0];

                        var lMarkerPostion = {X:lSize*Math.cos(angle)+bPX, Y:lSize*Math.sin(angle)*-1+bPY};
                        var lPolygon = hGetClockwisePolygon(markerShape, lMarkerPostion, markerSize);
                        hDrawPolygon(context, lPolygon, false, false);
                        //var mark
                    }
                    break;
                case InsAddString:
                case InsSetLineDash:
                    // To do
                    break;

                case InsSetLineWidth:
                    context.lineWidth = ins.LineWidth;
                    break;

                case InsSetLineJoin:
                    switch(ins.Type)
                    {
                    case LineJoinMiter:
                        context.lineJoin = 'miter';
                        break;
                    case LineJoinBevel:
                        context.lineJoin = 'bevel';
                        break;
                    case LineJoinRound:
                        context.lineJoin = 'round';
                        break;
                    }
                    break;
                case InsSetFontSize:
                case InsSetRGBAFillColor:
                case InsSetRGBAStrokeColor:
                    // To do
                    break;

                case InsFillPath:
                    context.fill();
                    break;

                case InsStrokePath:
                    context.stroke();
                    break;

                case InsFillSimple:
                    formatIndex = ins.Format;
                    format = formatList[formatIndex];
                    if(ins.HEP == 1)
                      color = ins.FC;
                    else
                        color = format.SimpleColor;
                    context.fillStyle = "RGBA(" + Math.round(color.R * ins.DarkerFactor) + ", " + Math.round(color.G * ins.DarkerFactor) + ", " + Math.round(color.B * ins.DarkerFactor) + ", " + format.Alpha / 255.0 + ");";
                    context.fill();
                    break;

                case InsFillPattern:
                    break;
                case InsFillGradient:
                    if (unit.IsAnimated === 0) {
                        rect = ins.BoundingRect;
                        darker = ins.DarkerFactor;
                    }
                    else {
                        rect = ins.BoundingRect[0];
                        darker = ins.DarkerFactor[0];
                        var rect2 = ins.BoundingRect[1];
                        rect.X = rect.X * (1-progress) + rect2.X * progress;
                        rect.Y = rect.Y * (1-progress) + rect2.Y * progress;
                        rect.Width = rect.Width * (1-progress) + rect2.Width * progress;
                        rect.Height = rect.Height * (1-progress) + rect2.Height * progress;
                    }
                    if (rect.Width < 1 || rect.Height < 1)
                        continue;

                    rect.Width = Math.floor(rect.Width);
                    rect.Height = Math.floor(rect.Height);

                    var format = formatList[ins.Format];
                    // The logic in "else" is time consuming. To make the animation smooth, use the logic in
                    // "if" when progress < 1.
                    if (format.Bevel.FillBevelType != FillBevelSphere || progress < 1)
                    {
                        fillGradient(context, format, rect, darker);
                    }
                    else
                    {
                        // Combine gradient with bevel sphere.
                        addCompensativeLayer(context, format);
                        //alert(rect.X+','+ rect.Y+','+ rect.Width+','+ rect.Height)
                        //var lImageData1 = context.getImageData(rect.X, rect.Y, rect.Width, rect.Height);
                        //context.clearRect(rect.X, rect.Y, rect.Width, rect.Height);
                        fillGradient(context, format, rect, darker);
                        /*var lImageData2 = context.getImageData(rect.X, rect.Y, rect.Width, rect.Height);

                        var lCenterPoint = {x : rect.Width / 2.0, y : rect.Height / 2.0};
                        var lpData = lImageData2.data;
                        var lHorizontalStep = 256 /lCenterPoint.x;
                        var lVerticalStep = 256 /lCenterPoint.y;
                        var lVerticalDistance = 0;
                        var lMidPointX = parseInt(lCenterPoint.x);
                        var lMidPointY = parseInt(lCenterPoint.y);
                        var lMidPointDistanceX = (rect.Width - lMidPointX - 1) * lHorizontalStep;
                        var lMidPointDistanceY = (rect.Height - lMidPointY - 1) * lVerticalStep;
                        var lIndex = 0;
                        for (var col = 0; col < lMidPointY; ++col)
                        {
                            var lHorizontalDistance = 0;
                            for (var row = 0; row < lMidPointX; ++row)
                            {
                                var lAlpha = hGetRadialAlpha(lVerticalDistance, lHorizontalDistance);
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lHorizontalDistance += lHorizontalStep;
                            }
                            lHorizontalDistance = lMidPointDistanceX;
                            for (var row = lMidPointX; row < rect.Width; ++row)
                            {
                                var lAlpha = hGetRadialAlpha(lVerticalDistance, lHorizontalDistance);
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lHorizontalDistance -= lHorizontalStep;
                            }
                            lVerticalDistance += lVerticalStep;
                        }
                        lVerticalDistance = lMidPointDistanceY;
                        for (var col = lMidPointY; col < rect.Height; ++col)
                        {
                            var lHorizontalDistance = 0;
                            for (var row = 0; row < lMidPointX; ++row)
                            {
                                var lAlpha = hGetRadialAlpha(lVerticalDistance, lHorizontalDistance);
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lHorizontalDistance += lHorizontalStep;
                            }
                            lHorizontalDistance = lMidPointDistanceX;
                            for (var row = lMidPointX; row < rect.Width; ++row)
                            {
                                var lAlpha = hGetRadialAlpha(lVerticalDistance, lHorizontalDistance);
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lpData[lIndex] = lIndex[lIndex] * lAlpha + lImageData1.data[lIndex] * (1 - lAlpha);
                                lIndex++;
                                lHorizontalDistance -= lHorizontalStep;
                            }
                            lVerticalDistance -= lVerticalStep;
                        }
                        context.putImageData(lImageData2, rect.X, rect.Y);*/
                    }

                    break;
                case InsFillEdgeType:
                    // clark, add fill edge type support
                    format = formatList[ins.Format];
                    bevel = format.Bevel;

                    lPolygon = hRemoveZeroEdgeInPolygon(ins.Polygon);

                    var lInitialPolygonSize = lPolygon.length;
                    var lInitialPolygon = [];
                    for (var i = 0; i < lInitialPolygonSize; i++)
                        lInitialPolygon.push(lPolygon[i]);

                    while(true)
                    {
                        lInitialPolygonSize = lInitialPolygon.length;
                        if (lInitialPolygonSize < 3)
                            break;

                        var lFirstPolygon = [];
                        var lSecondPolygon = [];
                        var lDivided = false;
                        if(lInitialPolygonSize > 3)
                        {
                            var lIntersectionPoint = { X:0, Y:0 };

                            for(var i = 0; ((i < (lInitialPolygonSize - 2)) && (!lDivided)); ++i)
                            {
                                for(var k = i + 2; k < (lInitialPolygonSize - 1); ++k)
                                {
                                    var rt = hLineInterSection(lInitialPolygon[i], lInitialPolygon[i+1], lInitialPolygon[k], lInitialPolygon[k+1], lIntersectionPoint, false);
                                    lIntersectionPoint = rt.interSection;
                                    if(rt.val == 1)
                                    {
                                        lDivided = true;
                                        //first part
                                        for(m = 0; m <= i; ++m)
                                        {
                                            if (!hIsFPointsEqual(lInitialPolygon[m], lIntersectionPoint))
                                                lFirstPolygon.push(lInitialPolygon[m]);
                                        }
                                        lFirstPolygon.push(lIntersectionPoint);
                                        for(m = k + 1; m < lInitialPolygonSize; ++m)
                                        {
                                            if (!hIsFPointsEqual(lInitialPolygon[m], lIntersectionPoint))
                                                lFirstPolygon.push(lInitialPolygon[m]);
                                        }
                                        //second part
                                        lSecondPolygon.push(lIntersectionPoint);
                                        for(m = k; m > i; --m)
                                        {
                                            if (!hIsFPointsEqual(lInitialPolygon[m], lIntersectionPoint))
                                                lSecondPolygon.push(lInitialPolygon[m]);
                                        }
                                        break;
                                    }
                                }

                                //deal with last edge
                                if((i != 0) && (!lDivided))
                                {
                                    var rt = hLineInterSection(lInitialPolygon[i], lInitialPolygon[i+1], lInitialPolygon[0], lInitialPolygon[lInitialPolygonSize-1], lIntersectionPoint, false);
                                    lIntersectionPoint = rt.interSection;
                                    if(rt.val == 1)
                                    {
                                        for(m = 0; m <= i; ++m)
                                            lFirstPolygon.push(lInitialPolygon[m]);
                                        lFirstPolygon.push(lIntersectionPoint);
                                        //second part
                                        lSecondPolygon.push(lIntersectionPoint);
                                        for(m = lInitialPolygonSize - 1; m > i; --m)
                                            lSecondPolygon.push(lInitialPolygon[m]);
                                        lDivided = true;
                                    }
                                }
                            }
                        }

                        if(!lDivided)
                            lFirstPolygon = lInitialPolygon;

                        //get the depth
                        var lDepth = 0.0;
                        var lRt = hGetAreaDepth(lFirstPolygon, lDepth);
                        lDepth = lRt.depth;
                        if (!lRt.mark)
                            break;
                        lDepth *= bevel.Depth * 0.01;
                        //get the normal line point
                        var lNormalStart = [];//it should be the inner area point
                        var lNormalEnd = [];
                        var lFirstPolygonSize = lFirstPolygon.length;
                        for(var i = 0; i < lFirstPolygonSize; ++i)
                        {
                            var lPointStart;
                            var lPointEnd;
                            var lRt = hGetAngularBisectorIntersectionPoint(lFirstPolygon[(i+lFirstPolygonSize-1) % lFirstPolygonSize], lFirstPolygon[i],
                                        lFirstPolygon[(i+1) % lFirstPolygonSize], lDepth);
                            lPointStart = lRt.start;
                            lPointEnd = lRt.end;

                            lNormalStart.push(lPointStart);
                            lNormalEnd.push(lPointEnd);
                        }//end of for loop

                        //now we have all the normal line point and the inner point
                        //we will compute the lightness of the surfaces and draw then
                        for(var i = 0; i < lFirstPolygonSize; ++i)
                        {
                            var lVectorNormalLine = {X:lNormalEnd[i].X - lNormalStart[i].X, Y:lNormalEnd[i].Y - lNormalStart[i].Y};
                            var lLengthNormalLine = Math.sqrt(hLengthSquared(lVectorNormalLine));
                            var lVectorUnitNormalLine = {X:lVectorNormalLine.X / lLengthNormalLine, Y:lVectorNormalLine.Y / lLengthNormalLine};
                            //opposite direction
                            var lAngleReflectedLight = degreeToRadian((540 - bevel.LightAngle) % 360);
                            var lVectorUnitLight = {X:Math.cos(lAngleReflectedLight), Y:Math.sin(lAngleReflectedLight)};
                            var lTemp = hInnerProduct(lVectorUnitNormalLine, lVectorUnitLight);

                            var lColorRGB = 0.0;
                            var lTransparency = 0.0;
                            //factor could be adjust
                            var lFactor = 0.1;
                            var lTransparencyFactor = 0.2;
                            if(lTemp < -0.01)//dark
                            {
                                lColorRGB = (1.0 + lTemp) * lFactor;
                                lTransparency = (1.0 + Math.abs(lTemp)) * lTransparencyFactor * bevel.Intensity * 0.01;
                            }
                            else
                            {
                                lColorRGB = (1.0 - lFactor) + lTemp * lFactor;
                                lTransparency = ((1.0 - lTransparencyFactor) + lTemp * lTransparencyFactor) * bevel.Intensity * 0.01;
                            }
                            var lNext = i + 1;
                            if(lNext == lFirstPolygonSize)
                                lNext -= lFirstPolygonSize;

                            context.beginPath();
                            context.moveTo(lFirstPolygon[i].X, lFirstPolygon[i].Y);
                            context.lineTo(lFirstPolygon[lNext].X, lFirstPolygon[lNext].Y);
                            context.lineTo(lNormalStart[lNext].X, lNormalStart[lNext].Y);
                            context.lineTo(lNormalStart[i].X, lNormalStart[i].Y);
                            context.closePath();

                            var R = Math.round(lColorRGB*255);
                            if (isNaN(R))  // 507686, clark, check whether this is a number. if not, then continue
                                continue;

                            if(bevel.FillBevelType == FillBevelSmoothEdge)
                            {
                                context.save();
                                context.clip();
                                var lLinearGrad = context.createLinearGradient(lNormalEnd[i].X, lNormalEnd[i].Y, lNormalStart[i].X, lNormalStart[i].Y);


                                lLinearGrad.addColorStop(0, 'rgba(' + R + ',' + R +',' + R +',' + lTransparency + ')');
                                lLinearGrad.addColorStop(1, 'rgba(' + R + ',' + R +',' + R +',' + 0 + ')');

                                 context.fillStyle = lLinearGrad;
                                 context.fill();
                                 context.restore();
                            }
                            else
                            {
                                context.fillStyle = "RGBA(" + R + ", " + R + ", " + R + ", " + lTransparency + ");";
                                context.fill();
                            }


                        }
                        if(lDivided)
                        {
                            lInitialPolygon = lSecondPolygon;
                        }
                        else
                            break;
                    }

                    // clark, restore path if the current path is not empty
                    if (lPolygon.length != 0)
                    {
                        context.beginPath();
                        context.moveTo(lPolygon[0].X, lPolygon[0].Y);
                        for (var i = 1; i < lPolygon.length; ++i)
                        {
                            context.lineTo(lPolygon[i].X, lPolygon[i].Y);
                        }
                        context.closePath();
                    }
                    break;
                case InsFillDonutOrSphere:
                    format = formatList[ins.Format];
                    bevel = format.Bevel;
                    if (unit.IsAnimated === 0) {
                        rect = ins.BoundingRect;
                        isCircularShape = ins.IsCircularShape;
                    }
                    else {
                        var rect1 = ins.BoundingRect[0];
                        var rect2 = ins.BoundingRect[1];
                        rect = {X : 0, Y : 0, Width:0, Height:0};
                        rect.X = rect1.X * (1-progress) + rect2.X * progress;
                        rect.Y = rect1.Y * (1-progress) + rect2.Y * progress;
                        rect.Width = rect1.Width * (1-progress) + rect2.Width * progress;
                        rect.Height = rect1.Height * (1-progress) + rect2.Height * progress;

                    }

                    if (bevel.FillBevelType === FillBevelDonut)
                    {
                        var factor = 0.2;
                        var lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                        var lStop = 1.0 - bevel.Depth * 0.01;

                        finalGradient = context.createLinearGradient(rect.X, rect.Y, rect.X + rect.Width, rect.Y);

                        startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                        endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                        finalGradient.addColorStop(0, startColor);
                        finalGradient.addColorStop(lStop * factor, startColor);
                        finalGradient.addColorStop(lStop, endColor);
                        finalGradient.addColorStop(1, startColor);
                    }
                    else
                    {
                        startColor = format.SimpleColor;
                        var lCenterPoint = {x: rect.X + rect.Width / 2, y : rect.Y + rect.Height / 2};

                        startPoint = {x : 0, y : 0};
                        endPoint = {x : 0, y : 0};
                        hRatioInRectangle(rect, bevel.LightAngle, lCenterPoint); // Calculate startPoint and endPoint.

                        var lFillAlpha = format.Alpha / 255.0;
                        var lNewAlpha = lFillAlpha;
                        if (format.FillType != FillSimple)
                        {
                            lFillAlpha *= 0.8;
                            lNewAlpha *= 0.5;
                            startColor = {R : 128, G : 128, B : 128};
                        }

                        var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                        lLinearGrad.addColorStop(0, 'rgba(255,255,255,' + lFillAlpha + ')');
                        lLinearGrad.addColorStop(0.05 + bevel.Intensity * 0.001, 'rgba(255,255,255,' + 9 * lFillAlpha / (10 - lFillAlpha) + ')');
                        lLinearGrad.addColorStop(0.5, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',' + lNewAlpha + ')');
                        lLinearGrad.addColorStop(0.85 + (1.0 - bevel.Intensity * 0.01) * 0.05, 'rgba(0,0,0,' + 9 * lFillAlpha / (10 - lFillAlpha) + ')');
                        lLinearGrad.addColorStop(1, 'rgba(0,0,0,' + lFillAlpha + ')');

                        context.fillStyle = lLinearGrad;
                        context.fill();

                        if (format.FillType != FillSimple)
                            continue;

                        var lRadius = Math.max(rect.Width, rect.Height) * 0.5 * (2.0 - bevel.Intensity * 0.01);
                        lRadius *= isCircularShape ? 0.75 : 2;

                        // clark, 488169, we should use the radial gradient here
                        finalGradient = context.createRadialGradient(lCenterPoint.x, lCenterPoint.y, 0, lCenterPoint.x, lCenterPoint.y, lRadius);

                        finalGradient.addColorStop(0, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',' + lFillAlpha + ')');
                        finalGradient.addColorStop(0.5, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',' + lFillAlpha / 2 + ')');
                        finalGradient.addColorStop(0.8, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',' + lFillAlpha / 10 + ')');
                        finalGradient.addColorStop(1, 'rgba(' + startColor.R + ',' + startColor.G +',' + startColor.B +',0)');
                    }
                    context.fillStyle = finalGradient;
                    context.fill();

                    break;
                case InsFillBorderMetallic:
                    format = formatList[ins.Format];
                    bevel = format.Bevel;

                    var CX = ins.CX;
                    var CY = ins.CY;
                    var mRadius = ins.Radius;
                    var lRadius;
                    var lAlpha;

                    switch(ins.BorderUse)
                    {
                        case BSS_METALLIC_OUTER_RING:
                            lAlpha = 0.4;
                            startPoint = {x : CX + mRadius * Math.cos(PI * 1.25), y : CY + mRadius * Math.sin(PI * 1.25)};
                            endPoint = {x : CX + mRadius * Math.cos(PI * 0.25), y : CY + mRadius * Math.sin(PI * 0.25)};

                            context.save();
                            context.clip();
                            var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                            lLinearGrad.addColorStop(0, 'rgba(0,0,0,' + lAlpha + ')');
                            lLinearGrad.addColorStop(1, 'rgba(255,255,255,' + lAlpha + ')');

                            context.fillStyle = lLinearGrad;
                            context.fill();
                            context.restore();

                            lAlpha = 0.4;
                            lRadius = mRadius * 0.3;
                            color = format.SimpleColor;
                            startPoint = {x : CX + lRadius * Math.cos(PI * 0.75), y : CY + lRadius * Math.sin(PI * 0.75)};
                            endPoint = {x : CX + lRadius * Math.cos(PI * 1.75), y : CY + lRadius * Math.sin(PI * 1.75)};

                            context.save();
                            context.clip();
                            var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                            lLinearGrad.addColorStop(0, 'rgba(' + color.R + ',' + color.G +',' + color.B +',' + 0.0 + ')');
                            lLinearGrad.addColorStop(0.2, 'rgba(' + color.R + ',' + color.G +',' + color.B +',' + 1.0 + ')');
                            lLinearGrad.addColorStop(0.8, 'rgba(' + color.R + ',' + color.G +',' + color.B +',' + 1.0 + ')');
                            lLinearGrad.addColorStop(1, 'rgba(' + color.R + ',' + color.G +',' + color.B +',' + 0.0 + ')');

                            context.fillStyle = lLinearGrad;
                            context.fill();
                            context.restore();
                            break;
                        case BSS_METALLIC_MIDDLE_RING:
                            lAlpha = 0.6;
                            lRadius = mRadius* 0.2;
                            var lStop = 0.3;
                            startPoint = {x : CX + lRadius * Math.cos(PI * 1.25), y : CY + lRadius * Math.sin(PI * 1.25)};
                            endPoint = {x : CX + mRadius * Math.cos(PI * 0.25), y : CY + mRadius * Math.sin(PI * 0.25)};

                            context.save();
                            context.clip();
                            var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                            lLinearGrad.addColorStop(0, 'rgba(255,255,255,' + lAlpha + ')');
                            lLinearGrad.addColorStop(lStop, 'rgba(0,0,0,' + lAlpha + ')');
                            lLinearGrad.addColorStop(1, 'rgba(255,255,255,' + lAlpha + ')');

                            context.fillStyle = lLinearGrad;
                            context.fill();
                            context.restore();
                            break;
                        default:
                            lAlpha = 0.4;
                            lRadius = mRadius- ins.Thickness;
                            startPoint = {x : CX + lRadius * Math.cos(PI * 1.25), y : CY + lRadius * Math.sin(PI * 1.25)};
                            endPoint = {x : CX + lRadius * Math.cos(PI * 0.25), y : CY + lRadius * Math.sin(PI * 0.25)};

                            context.save();
                            context.clip();
                            var lLinearGrad = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                            lLinearGrad.addColorStop(0, 'rgba(0,0,0,' + lAlpha + ')');
                            lLinearGrad.addColorStop(1, 'rgba(255,255,255,' + lAlpha + ')');

                            context.fillStyle = lLinearGrad;
                            context.fill();
                            context.restore();
                            break;
                    }
                    break;
                case InsFillRadientGradient:
                    format = formatList[ins.Format];
                    bevel = format.Bevel;

                    var lAlpha;
                    var lStop;
                    var CX;
                    var CY;
                    var innerRadius;
                    var outerRadius;
                    var lUsage;
                    var lExtraPara;
                    var lExtraDepth;
                    var lExtraIntensity;

                    if (unit.IsAnimated === 0) {
                        CX = ins.CX;
                        CY = ins.CY;
                        innerRadius = ins.InnerRadius;
                        outerRadius = ins.OuterRadius;
                        lUsage = ins.RGUsage;
                        lExtraPara = ins.HEP;
                        if (lExtraPara == 1)
                        {
                            lExtraDepth = ins.ExtraDepth;
                            lExtraIntensity = ins.ExtraIntensity;
                        }
                    } else {
                        CX = ins.CX[0] * (1 - progress) + ins.CX[1] * progress;
                        CY = ins.CY[0] * (1 - progress) + ins.CY[1] * progress;
                        innerRadius = ins.InnerRadius[0];
                        outerRadius = ins.OuterRadius[0];
                        lUsage = ins.RGUsage[0];
                        lExtraPara = ins.HEP[0];
                        if (lExtraPara == 1)
                        {
                            lExtraDepth = ins.ExtraDepth[0];
                            lExtraIntensity = ins.ExtraIntensity[0];
                        }
                    }

                    switch(lUsage)
                    {
                        case RGPieSlice:
                            lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                            lStop = 1.0 - bevel.Depth * 0.01;
                            finalGradient = context.createRadialGradient(CX, CY, innerRadius, CX, CY, outerRadius);
                            startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                            endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                            finalGradient.addColorStop(0, startColor);
                            finalGradient.addColorStop(lStop, endColor);
                            finalGradient.addColorStop(1, startColor);

                            context.fillStyle = finalGradient;
                            context.fill();
                            break;
                        case RGRing:
                            lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                            finalGradient = context.createRadialGradient(CX, CY, innerRadius, CX, CY, outerRadius);
                            startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                            endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                            finalGradient.addColorStop(0, startColor);
                            finalGradient.addColorStop(1, endColor);

                            context.fillStyle = finalGradient;
                            context.fill();
                            break;
                        case RG_BORDERRING:
                            if (lExtraPara == 0)
                            {
                                lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                                lStop = bevel.Depth * 0.01;
                            }
                            else
                            {
                                lAlpha = lExtraIntensity * 0.01 * format.Alpha / 255.0;
                                lStop = lExtraDepth * 0.01;
                            }
                            finalGradient = context.createRadialGradient(CX, CY, innerRadius, CX, CY, outerRadius);
                            startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                            endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                            finalGradient.addColorStop(0, startColor);
                            finalGradient.addColorStop(lStop, endColor);
                            finalGradient.addColorStop(1, startColor);

                            context.fillStyle = finalGradient;
                            context.fill();
                            break;
                    }
                    break;
                case InsFillDonut2Rect:
                    format = formatList[ins.Format];
                    bevel = format.Bevel;
                    lAlpha = bevel.Intensity * 0.01 * format.Alpha / 255.0;
                    lStop = 1.0 - bevel.Depth * 0.01;

                    startColor = 'RGBA(0,0,0,' + lAlpha + ');';
                    endColor = 'RGBA(255,255,255,' + lAlpha + ');';
                    finalGradient = context.createLinearGradient(ins.StartPoint.X, ins.StartPoint.Y, ins.EndPoint.X, ins.EndPoint.Y);
                    finalGradient.addColorStop(0, startColor);
                    finalGradient.addColorStop(lStop, endColor);
                    finalGradient.addColorStop(1, startColor);

                    context.save();
                    context.clip();
                    context.fillStyle = finalGradient;
                    context.fill();
                    context.restore();
                    break;
                case InsMakeDarker:
                case InsRestoreColor:
                    // To do
                    break;

                case InsApplyLineFormat:
                    formatIndex = ins.Format;
                    format = formatList[formatIndex];
                    color = format.Color;
                    context.strokeStyle = "RGBA(" + color.R + ", " + color.G + ", " + color.B + ", " + format.Alpha / 255.0 + ");";
                    context.stroke();
                    break;
                case InsAddFormatedText:
                    formatIndex = ins.Format;
                    format = formatList[formatIndex];
                    color = format.Color;
                    // The font size should be in "px" instead of "pt". 96 pixels = 72 pt.
                    context.font = format.Size + "px " + format.Name;
                    if (format.Style & 0x02)    // Italic
                    {
                        context.font = "italic " + context.font;
                    }
                    if (format.Style & 0x01)    // Bold
                    {
                        context.font = "bold " + context.font;
                    }
                    context.fillStyle = "RGBA(" + color.R + ", " + color.G + ", " + color.B + ", " + format.Alpha / 255.0 + ");";
                    context.fillText(ins.Text, ins.StartPoint.X, ins.StartPoint.Y);
                    if (format.Style & 0x0C) // Underline and/or StrikeThrough
                    {
                        context.beginPath();
                        var textSize = context.measureText(ins.Text);
                        if(format.Style & 0x04) // Underline
                        {
                            context.moveTo(Math.round(ins.StartPoint.X), Math.round(ins.StartPoint.Y));
                            context.lineTo(Math.round(ins.StartPoint.X + textSize.width), Math.round(ins.StartPoint.Y));
                        }
                        if(format.Style & 0x08) // StrikeThrough
                        {
                            context.moveTo(Math.round(ins.StartPoint.X), Math.round(ins.StartPoint.Y - format.Size * 0.5));
                            context.lineTo(Math.round(ins.StartPoint.X + textSize.width), Math.round(ins.StartPoint.Y - format.Size * 0.5));
                        }
                        context.strokeStyle = "RGBA(" + color.R + ", " + color.G + ", " + color.B + ", " + format.Alpha / 255.0 + ");";
                        context.lineWidth = Math.round(Math.max(1, format.Size * 3 / 40));
                        context.stroke();
                    }
                    break;

                case InsApplyBeveledFrameToRectangle: // clark, 488730, support bevel effect for legend text

                    var lRect;
                    if (unit.IsAnimated === 0) {
                        lRect = ins.Rect;
                    }
                    else {
                        lRect = ins.Rect[0];
                        var rect2 = ins.Rect[1];
                        lRect.X = lRect.X * (1-progress) + rect2.X * progress;
                        lRect.Y = lRect.Y * (1-progress) + rect2.Y * progress;
                        lRect.Width = lRect.Width * (1-progress) + rect2.Width * progress;
                        lRect.Height = lRect.Height * (1-progress) + rect2.Height * progress;
                    }

                    var lRotationAngle = ins.RotationAngle;
                    var llBevelDepth = ins.BevelDepth;
                    var lrLTColor = ins.LTColor;
                    var lLTAlpha = ins.LTAlpha;
                    var lrRBColor = ins.RBColor;
                    var lRBAlpha = ins.RBAlpha;
                    var lDeviceAnchor ={X:lRect.X + lRect.Width / 2, Y:lRect.Y + lRect.Height / 2};
                    var lInnerRect = {X:0, Y:0, Width:0, Height:0};
                    lInnerRect.X =  lRect.X;
                    lInnerRect.Y = lRect.Y;
                    lInnerRect.Width = lRect.Width;
                    lInnerRect.Height = lRect.Height;
                    hImplode(lInnerRect, llBevelDepth, llBevelDepth);

                    var lOutterPolygon = [];

                    lOutterPolygon.push(hRotateAndClone({X:lRect.X, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    lOutterPolygon.push(hRotateAndClone({X:lRect.X + lRect.Width, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    lOutterPolygon.push(hRotateAndClone({X:lRect.X + lRect.Width, Y:lRect.Y + lRect.Height}, lDeviceAnchor, lRotationAngle));
                    lOutterPolygon.push(hRotateAndClone({X:lRect.X, Y:lRect.Y + lRect.Height},lDeviceAnchor, lRotationAngle));

                    var lInnterPolygon = [];
                    lInnterPolygon.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lInnterPolygon.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lInnterPolygon.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));
                    lInnterPolygon.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));

                    //    Left top area
                    var lLeftTop = [];
                    lLeftTop.push(hRotateAndClone({X:lRect.X, Y:lRect.Y + lRect.Height}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lRect.X + lRect.Width, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    lLeftTop.push(hRotateAndClone({X:lRect.X, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    hDrawPolygon(context, lLeftTop, false, false);
                    context.fillStyle = "RGBA(" + lrLTColor.R + ", " + lrLTColor.G + ", " + lrLTColor.B + ", " + lLTAlpha / 255.0 + ");";
                    context.fill();

                    //    Right bottom area
                    var lRightBottom = [];
                    lRightBottom.push(hRotateAndClone({X:lRect.X, Y:lRect.Y + lRect.Height}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lInnerRect.X, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y + lInnerRect.Height}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lInnerRect.X + lInnerRect.Width, Y:lInnerRect.Y}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lRect.X + lRect.Width, Y:lRect.Y}, lDeviceAnchor, lRotationAngle));
                    lRightBottom.push(hRotateAndClone({X:lRect.X + lRect.Width,Y:lRect.Y + lRect.Height}, lDeviceAnchor, lRotationAngle));
                    hDrawPolygon(context, lRightBottom, false, false);
                    context.fillStyle = "RGBA(" + lrRBColor.R + ", " + lrRBColor.G + ", " + lrRBColor.B + ", " + lRBAlpha / 255.0 + ");";
                    context.fill();

                    context.strokeStyle = "RGBA(230, 230, 230, " + lLTAlpha*0.5 / 255.0 + ");";
                    context.lineWidth = 1;
                    hDrawPolygon(context, lOutterPolygon, true, true);
                    context.stroke();
                    hDrawPolygon(context, lInnterPolygon, true, true);
                    context.stroke();
                    break;
            }
        }
    }

    function hGetRadialAlpha(rr, cc)
    {
        return 1 - ( Math.sqrt((cc - 256) * (cc -  256) + (rr -  256) * (rr -  256)) / (1.5 * 256) );
    }

    function hMoveTo(context, iX, iY, iIsLinePath, iIsLineWidthOdd)
    {
        var lOffset = (iIsLinePath && iIsLineWidthOdd) ? 0.5 : 0.0;
        context.moveTo(iX + lOffset, iY + lOffset);
    }

    function hLineTo(context, iX, iY, iIsLinePath, iIsLineWidthOdd)
    {
        var lOffset = (iIsLinePath && iIsLineWidthOdd) ? 0.5 : 0.0;
        context.lineTo(iX + lOffset, iY + lOffset);
    }

    function hDrawPolyLine(context, irPoints, iIsLinePath, iIsLineWidthOdd)
    {
        var lNumberOfPoints = irPoints.length;
        if(lNumberOfPoints<=0)
            return;
        context.beginPath();
        hMoveTo(context, irPoints[0].X, irPoints[0].Y, iIsLinePath, iIsLineWidthOdd);
        var lPreviousIndex = 0;
        for(i = 1; i < lNumberOfPoints; ++i)
        {
            // If the current point is not the last point and is on a vertical or horizontal segement formed by the prevous and the next point,
            // do not put it into the path.
            //if ((i + 1 == lNumberOfPoints) || irPoints[i].IsOnVerOrHorSegment(irPoints[lPreviousIndex], irPoints[i + 1]) == false)
            //{
                hLineTo(context, irPoints[i].X, irPoints[i].Y, iIsLinePath, iIsLineWidthOdd);
                lPreviousIndex = i;
            //}
        }
    }

    function hGetMarkerShape(iMarkerShape)
    {
        var opPoints = gMarkerShapes[iMarkerShape];
        var opPointNumber = opPoints.length/2;

        return {number:opPointNumber, points:opPoints};
    }


    function hGetClockwisePolygon(iMarkerShape, mpos, iMarkerSize)
    {
        var mPolygon = [];

        if (iMarkerShape == MS_Circle)
        {
            mPolygon.push({X:mpos.X - iMarkerSize, Y:mpos.Y - iMarkerSize});
            mPolygon.push({X:mpos.X + iMarkerSize, Y:mpos.Y - iMarkerSize});
            mPolygon.push({X:mpos.X + iMarkerSize, Y:mpos.Y + iMarkerSize});
            mPolygon.push({X:mpos.X - iMarkerSize, Y:mpos.Y + iMarkerSize});
            return mPolygon;
        }

        var lPointNumber;
        var lPoints;

        var rt = hGetMarkerShape(iMarkerShape);
        lPointNumber = rt.number;
        lPoints = rt.points;

        for (var i = 0; i < lPointNumber; i++)
        {
            var lx = (lPoints[2 * i]) * iMarkerSize / gLocalMarkerSize + mpos.X;
            var ly = (lPoints[2 * i + 1]) * iMarkerSize / gLocalMarkerSize + mpos.Y;
            mPolygon.push({X:lx, Y:ly});
        }

        return mPolygon;
    }

    function hDrawPolygon(context, irPoints, iIsLinePath, iIsLineWidthOdd)
    {
        var lNumberOfPoints = irPoints.length;
        if(lNumberOfPoints < 3)
            return;

        context.beginPath();
        if (iIsLinePath && iIsLineWidthOdd)
        {
            var lAdjustedPoints = [];
            for(var i = 0; i < lNumberOfPoints; ++i)
            {
                lAdjustedPoints.push(irPoints[i]);
            }

            var lPreviousIndex = lNumberOfPoints - 1;
            for(var i = 0; i < lNumberOfPoints; ++i)
            {
                lNextIndex = (i + 1 == lNumberOfPoints) ? 0 : i + 1;
                if (irPoints[i].X == irPoints[lPreviousIndex].X || irPoints[i].X == irPoints[lNextIndex].X)
                {
                    lAdjustedPoints[i].X += 0.5;
                }
                if (irPoints[i].Y == irPoints[lPreviousIndex].Y || irPoints[i].Y == irPoints[lNextIndex].Y)
                {
                    lAdjustedPoints[i].Y += 0.5;
                }
                lPreviousIndex = i;
            }
            hDrawPolyLine(context, lAdjustedPoints, false, iIsLineWidthOdd);
        }
        else
        {
            hDrawPolyLine(context, irPoints, false, iIsLineWidthOdd);
        }
        context.closePath();
    }

    function hRotate(point, irAnchor, iRadian)
    {
        var lXDist = point.X - irAnchor.X;
        var lYDist = point.Y - irAnchor.Y;

        point.X = irAnchor.X + Math.cos(iRadian) * lXDist - Math.sin(iRadian) * lYDist;
        point.Y = irAnchor.Y + Math.sin(iRadian) * lXDist + Math.cos(iRadian) * lYDist;
        return point;
    }

    function hRotateAndClone(point, irAnchor, iRadian)
    {
        return hRotate(point, irAnchor, iRadian);
    }

    function hImplode(rect, iXOffset, iYOffset)
    {
        if (iXOffset * 2 > rect.Width)
        {
            iXOffset = rect.Width / 2;
        }
        if (iYOffset * 2 > rect.Height)
        {
            iYOffset = rect.Height / 2;
        }

        return hExplode(rect, -iXOffset, -iYOffset);
    }

    function hExplode(rect, iXOffset, iYOffset)
    {
        rect.X -= iXOffset;
        rect.Y -= iYOffset;
        rect.Width += (iXOffset*2);
        rect.Height += (iYOffset*2);
        return rect;
    }

    function hGetTriangleAreaDouble(vectorA, vectorB, vectorC)
    {
        return hCrossProduct(vectorA,vectorB) + hCrossProduct(vectorB, vectorC) + hCrossProduct(vectorC, vectorA);
    }

    function hDistance(vectorA, vectorB)
    {
        return Math.sqrt((vectorA.X - vectorB.X) * (vectorA.X - vectorB.X)
            + (vectorA.Y - vectorB.Y) * (vectorA.Y - vectorB.Y));
    }

    //iCurrent angle is greater than 180 degree
    function hGetNewPolygon(polygon, iCurrent, oPolygon)
    {
        var rtPolygon = oPolygon;

        var lSize = polygon.length;
        var i = iCurrent;
        var lPointA = polygon[(i + lSize - 1) % lSize];
        var lPointC = polygon[(i + 1) % lSize];
        //AB
        var lIndexAB = 0;
        var lIntersectionAB = {X:0, Y:0};
        var lVectorAB = {X: polygon[iCurrent].X - polygon[(iCurrent + lSize - 1) % lSize].X,
            Y:polygon[iCurrent].Y - polygon[(iCurrent + lSize - 1) % lSize].Y};

        for(var k = (i+2) % lSize; k != i; k = (k + 1) % lSize)
        {
            var j = k - 1;
            if(j < 0)
                j += lSize;
            var lVectorBJ = {X:polygon[j].X - polygon[i].X, Y:polygon[j].Y - polygon[i].Y};
            var lVectorBK = {X:polygon[k].X - polygon[i].X, Y:polygon[k].Y - polygon[i].Y};
            if(hCrossProduct(lVectorAB, lVectorBJ) < 0.01 && hCrossProduct(lVectorAB, lVectorBK) > 0.01)
            {
                // cross(AB, BJ) <= 0, cross(AB, BK) > 0.
                var rt = hLineInterSection(lPointA, polygon[i], polygon[j], polygon[k], lIntersectionAB, false);
                lIntersectionAB = rt.interSection;
                lIndexAB = k;
                break;
            }
        }

        //CB
        var lIndexCB = 0;
        var lIntersectionCB = {X:0, Y:0};
        var lVectorCB = { X:polygon[iCurrent].X - polygon[(iCurrent + 1) % lSize].X, Y:polygon[iCurrent].Y - polygon[(iCurrent+1) % lSize].Y };
        for(var k = (i + lSize - 2) % lSize; k != i; k = (k - 1 + lSize) % lSize)
        {
            var j = k + 1;
            if(j >= lSize)
                j -= lSize;
            var lVectorBJ = {X:polygon[j].X - polygon[i].X, Y:polygon[j].Y - polygon[i].Y};
            var lVectorBK = {X:polygon[k].X - polygon[i].X, Y:polygon[k].Y - polygon[i].Y};
            if(hCrossProduct(lVectorCB, lVectorBJ) > -0.01 && hCrossProduct(lVectorCB, lVectorBK) < -0.01)
            {
                // cross(CB, BJ) >= 0, cross(CB, BK) < 0.
                var rt = hLineInterSection(lPointC, polygon[i], polygon[j], polygon[k], lIntersectionCB, false);
                lIntersectionCB = rt.interSection;
                lIndexCB = k;
                break;
            }
        }
        rtPolygon.push(polygon[i]);
        rtPolygon.push(lIntersectionAB);
        for(m = lIndexAB; ; m = (m + 1) % lSize)
        {
            rtPolygon.push(polygon[m]);
            if (m == lIndexCB)
                break;
        }
        rtPolygon.push(lIntersectionCB);

        return rtPolygon;
    }

    //polygon[0] is the current point
    function hGetNewAreaDepth(polygon, orMaxDepth)
    {
        var lSize = polygon.length;
        if(lSize == 3)
        {
            var lRt = hGetAreaDepth(polygon, orMaxDepth);
            return lRt;
        }
        else
        {
            //A---irPolygon.size()-1
            //B---0
            //C---1
            var lPointA = polygon[lSize - 1];
            var lVectorBC = {X:polygon[1].X - polygon[0].X, Y:polygon[1].Y - polygon[0].Y};
            var lVectorCB = {X:-lVectorBC.X, Y:-lVectorBC.Y};
            var lVectorBA = {X:lPointA.X - polygon[0].X, Y:lPointA.Y - polygon[0].Y};
            var lVectorAB = {X:-lVectorBA.X, Y:-lVectorBA.Y};

            var lIsValid = false;
            var lDepth = 1e10; // initialize to a very big value
            //next we will get all depth of <ABC
            for(var i = 2; i < lSize; ++i)
            {
                var j = i - 1;
                var lVectorJI = {X:polygon[i].X - polygon[j].X, Y:polygon[i].Y - polygon[j].Y};
                if (hCrossProduct(lVectorCB, lVectorJI) < -0.01)
                {
                    // Direction of JI is compatible with CB
                    var lPoint = {X:0, Y:0};
                    //get intersection point of BC and ji
                    var rt = hLineInterSection(polygon[0], polygon[1], polygon[j], polygon[i], lPoint, false);
                    lPoint = rt.interSection;
                    if(rt.val > 0)
                    {
                        var lVectorBIntersection = {X:lPoint.X - polygon[0].X, Y:lPoint.Y - polygon[0].Y};
                        //see if (B,C) is the same direction with (B,intersectionPoint)
                        if(hInnerProduct(lVectorBC, lVectorBIntersection) > 0.01)
                        {
                            // same direction
                            var lTempPoint = {X:lPoint.X + lVectorJI.X, Y:lPoint.Y + lVectorJI.Y};
                            var lBisectorPoint = {X:0, Y:0};
                            var lTemp;

                            var lRt = hGetBisectorPointAndDepth(lPointA, polygon[0], lPoint, lTempPoint, lBisectorPoint, lTemp);
                            lBisectorPoint = lRt.point;
                            lTemp = lRt.val;
                            if (lRt.mark)
                            {
                                lIsValid = true;
                                if((lTemp < lDepth) && hPointInRange(lBisectorPoint, polygon[j-1], polygon[j], polygon[i], polygon[(i+1)%lSize]))
                                {
                                    lDepth = lTemp;
                                }
                            }
                        }
                    }
                }
                else if(hCrossProduct(lVectorAB, lVectorJI) < -0.01)
                {
                    // Direction of JI is compatible with AB
                    var lPoint = {X:0, Y:0};
                    //get intersection point of AB and ji
                    var rt = hLineInterSection(polygon[0], lPointA, polygon[j], polygon[i], lPoint, false);
                    lPoint = rt.interSection;
                    if(rt.val > 0)
                    {
                        var lVectorBIntersection = {X:lPoint.X - polygon[0].X, Y:lPoint.Y - polygon[0].Y};
                        //see if (B,A) is the same direction with (B,intersectionPoint)
                        if(hInnerProduct(lVectorBA, lVectorBIntersection) > 0.01)
                        {
                            //same direction
                            var lTempPoint = {X:lPoint.x - lVectorJI.x, Y:lPoint.y - lVectorJI.y};
                            var lBisectorPoint = {X:0, Y:0};
                            var lTemp;

                            var lRt = hGetBisectorPointAndDepth(lTempPoint, lPoint, polygon[0], polygon[1], lBisectorPoint, lTemp);
                            lBisectorPoint = lRt.point;
                            lTemp = lRt.val;
                            if (lRt.mark)
                            {
                                lIsValid = true;
                                if((lTemp < lDepth) && hPointInRange(lBisectorPoint, polygon[j-1], polygon[j], polygon[i], polygon[(i+1)%lSize]))
                                {
                                    lDepth = lTemp;
                                } // end if
                            }
                        } // end if
                    } // end if
                } // end else if
            } // end for
            return {mark:lIsValid, depth:lDepth};
        } // end else
    }

    function hLengthSquared(vectorA)
    {
        return vectorA.X * vectorA.X + vectorA.Y * vectorA.Y;
    }

    function hGetAngularBisectorIntersectionPoint(vectorA, vectorB, vectorC, depth)
    {
        var lVectorBA = {X:vectorA.X - vectorB.X, Y:vectorA.Y - vectorB.Y};
        var lVectorBC = {X:vectorC.X - vectorB.X, Y:vectorC.Y - vectorB.Y};
        var lLengthBA = Math.sqrt(hLengthSquared(lVectorBA));
        var lLengthBC = Math.sqrt(hLengthSquared(lVectorBC));
        var lVectorUnitBA = {X: lVectorBA.X / lLengthBA, Y:lVectorBA.Y / lLengthBA};
        var lVectorUnitBC = {X:lVectorBC.X / lLengthBC, Y:lVectorBC.Y / lLengthBC};
        var lLength = 0.0;
        if(Math.abs(lVectorUnitBA.X - lVectorUnitBC.X) < 0.01)//X equals
        {
            lLength = depth * (lVectorUnitBC.X + lVectorUnitBA.X) / (lVectorUnitBA.Y - lVectorUnitBC.Y);
        }
        else//X diffs
        {
            lLength = depth * (lVectorUnitBC.Y + lVectorUnitBA.Y) / (lVectorUnitBC.X - lVectorUnitBA.X);
        }
        var oPointEnd = { X:0, Y:0 };
        var oPointStart = { X:0, Y:0 };
        oPointEnd.X = vectorB.X + lLength * lVectorUnitBC.X;
        oPointEnd.Y = vectorB.Y + lLength * lVectorUnitBC.Y;
        oPointStart.X = oPointEnd.X + depth * (-lVectorUnitBC.Y);
        oPointStart.Y = oPointEnd.Y + depth * lVectorUnitBC.X;

        return {start:oPointStart, end:oPointEnd};
    }

    function hIncludedAngle(vectorA, vectorB)
    {
        var lTemp = hInnerProduct(vectorA, vectorB) / (Math.sqrt(hLengthSquared(vectorA) * hLengthSquared(vectorB)));
        lTemp = (lTemp > 1.0) ? 1.0 : lTemp;
        lTemp = (lTemp < -1.0) ? -1.0 : lTemp;
        return Math.acos(lTemp);
    }

    function hPointInRange(irPoint, vectorA, vectorB, vectorC, vectorD)
    {
        //whether in range of <ABC
        var lVectorBA = {X:vectorA.X - vectorB.X, Y:vectorA.Y - vectorB.Y};
        var lVectorBC = {X:vectorC.X - vectorB.X, Y:vectorC.Y - vectorB.Y};
        var lAngleABC = radianToDegree(hIncludedAngle(lVectorBA, lVectorBC));
        if(hCrossProduct(lVectorBC, lVectorBA) < -0.01)
            lAngleABC = 360 - lAngleABC;
        var lVectorBPoint = {X:irPoint.X - vectorB.X, Y:irPoint.Y - vectorB.Y};
        var lAnglePointBC = radianToDegree(hIncludedAngle(lVectorBPoint,lVectorBC));
        if(hCrossProduct(lVectorBC, lVectorBPoint) < -0.01)
            lAnglePointBC = 360 - lAnglePointBC;
        if(2 * lAnglePointBC > lAngleABC)
            return false;

        //whether in range of <BCD
        var lVectorCB = {X:-lVectorBC.X, Y:-lVectorBC.Y};
        var lVectorCD = {X:vectorD.X - vectorC.X, Y:vectorD.Y - vectorC.Y};
        var lAngleBCD = radianToDegree(hIncludedAngle(lVectorCB, lVectorCD));
        if(hCrossProduct(lVectorCD, lVectorCB) < -0.01)
            lAngleBCD = 360 - lAngleBCD;
        var lVectorCPoint = {X:irPoint.X - vectorC.X, Y:irPoint.Y - vectorC.Y};
        var lAngleBCPoint = radianToDegree(hIncludedAngle(lVectorCB, lVectorCPoint));
        if(hCrossProduct(lVectorCPoint, lVectorCB) < -0.01)
            lAngleBCPoint = 360 - lAngleBCPoint;
        if(2 * lAngleBCPoint > lAngleBCD)
            return false;
        //in both range, ok
        return true;
    }

    function hLength(vectorA)
    {
        return Math.sqrt(hLengthSquared(vectorA));
    }

    function hGetBisectorPointAndDepth(vectorA, vectorB, vectorC, vectorD, orBisectorPoint, orDistance)
    {
        var val;
        var mark;

        var lVectorAB = {X:vectorB.X - vectorA.X, Y:vectorB.Y - vectorA.Y};
        var lVectorCD = {X:vectorD.X - vectorC.X, Y:vectorD.Y - vectorC.Y};
        var lVectorBC = {X:vectorC.X - vectorB.X, Y:vectorC.Y - vectorB.Y};
        var lLengthBC = Math.sqrt(hLengthSquared(lVectorBC));
        var lABCrossCD =  hCrossProduct(lVectorAB, lVectorCD);
        if (lABCrossCD > 0.01 || lABCrossCD < -0.01)
        {
            // In this case, ABC + BCD != 180
            // E: Intersection point of AB and CD
            var lE = {X:0, Y:0};
            var rt = hLineInterSection(vectorA, vectorB, vectorC, vectorD, lE, false);
            lE = rt.interSection;
            var lLengthBE = hDistance(vectorB, lE);
            var lLengthCE = hDistance(vectorC, lE);
            if (lABCrossCD < -0.01)
            {
                // In this case, ABC + BCD < 180
                var lP = lLengthBC + lLengthBE + lLengthCE;
                orBisectorPoint.X = (lLengthCE * vectorB.X + lLengthBE * vectorC.X + lLengthBC * lE.X) / lP;
                orBisectorPoint.Y = (lLengthCE * vectorB.Y + lLengthBE * vectorC.Y + lLengthBC * lE.Y) / lP;
                val = hGetTriangleAreaDouble(vectorB, vectorC, lE) / lP;
                mark = true;
            }
            else // lABCrossCD > gModuleMainPtr->mTolerance
            {
                // In this case, ABC + BCD > 180
                var lP = lLengthBE + lLengthCE - lLengthBC;
                if(lP < 0.01)//==0.0, one of them is 180
                {
                    var lDepth = 0.0;
                    if(Math.abs(hCrossProduct(lVectorAB, lVectorBC)) < 0.01)// <ABC = 180
                    {
                        var lVectorCBUnit = {X:-lVectorBC.X / lLengthBC, Y:-lVectorBC.Y / lLengthBC};
                        var lLengthCD = Math.sqrt(hLengthSquared(lVectorCD));
                        var lVectorCDUnit = {X:lVectorCD.X / lLengthCD, Y:lVectorCD.Y / lLengthCD};
                        lDepth = (lVectorCBUnit.Y - lVectorCDUnit.Y) * lLengthBC / (lVectorCBUnit.X + lVectorCDUnit.X);
                        orBisectorPoint.X = vectorB.X + lDepth * lVectorCBUnit.Y;
                        orBisectorPoint.Y = vectorB.Y + lDepth * (-lVectorCBUnit.X);
                    }
                    else// <BCD = 180
                    {
                        var lVectorBCUnit = {X:lVectorBC.X / lLengthBC, Y:lVectorBC.Y / lLengthBC};
                        var lLengthAB = hLength(lVectorAB);
                        var lVectorBAUnit = {X:-lVectorAB.X / lLengthAB, Y:-lVectorAB.Y / lLengthAB};
                        lDepth = (lVectorBAUnit.Y - lVectorBCUnit.Y) * lLengthBC / (lVectorBAUnit.X + lVectorBCUnit.X);
                        orBisectorPoint.X = vectorC.X + lDepth * (-lVectorBCUnit.Y);
                        orBisectorPoint.Y = vectorC.Y + lDepth * lVectorBCUnit.X;
                    }
                    val = lDepth;
                    mark = true;
                    return {val:val, mark:mark, point:orBisectorPoint};
                }
                orBisectorPoint.X = (lLengthCE * vectorB.X + lLengthBE * vectorC.X - lLengthBC * lE.X) / lP;
                orBisectorPoint.Y = (lLengthCE * vectorB.Y + lLengthBE * vectorC.Y - lLengthBC * lE.Y) / lP;
                val = hGetTriangleAreaDouble(vectorB, lE, vectorC) / lP;
                mark = true;
            }
        }
        else
        {
            // In this case, ABC + BCD = k * 180, k = 1, 2.

            //A, B, C, D are in the same line.
            if(Math.abs(hCrossProduct(lVectorAB, lVectorBC)) < 0.01)
            {
                mark = false;
                return {val:val, mark:mark, point:orBisectorPoint};
            }
            var lLengthAB = Math.sqrt(hLengthSquared(lVectorAB));
            var lUnitVectorBA = {X:-lVectorAB.X / lLengthAB, Y:-lVectorAB.Y / lLengthAB };
            orBisectorPoint.X = (vectorB.X + vectorC.X + lLengthBC * lUnitVectorBA.X) / 2;
            orBisectorPoint.Y = (vectorB.Y + vectorC.Y + lLengthBC * lUnitVectorBA.Y) / 2;
            val = hCrossProduct(lVectorBC, lUnitVectorBA) / 2;
            mark = true;
        }

        return {val:val, mark:mark, point:orBisectorPoint};
    }


    function hGetAreaDepth(polygon, orMaxDepth)
    {
        var val = false;

        var lPolygonSize = polygon.length;
        if(lPolygonSize == 3)
        {
            //triangle
            var lLengthA = hDistance(polygon[0], polygon[1]);
            var lLengthB = hDistance(polygon[1], polygon[2]);
            var lLengthC = hDistance(polygon[2], polygon[0]);
            var lP = lLengthA + lLengthB + lLengthC;
            orMaxDepth = hGetTriangleAreaDouble(polygon[0], polygon[1], polygon[2]) / lP;
            val = true;
        }
        else
        {
            var lIsValid = false;
            var lDepth = 1e10; // initialize to a very big value
            for(var i = 0; i < lPolygonSize; ++i)
            {
                var lPointB = polygon[i];
                //get the former and latter point
                var lPointA = polygon[(i + lPolygonSize - 1) % lPolygonSize];
                var lPointC = polygon[(i + 1) % lPolygonSize];
                var lPointD = polygon[(i + 2) % lPolygonSize];


                var lVectorBA = {X:lPointA.X - lPointB.X, Y:lPointA.Y - lPointB.Y};
                var lVectorBC = {X:lPointC.X - lPointB.X, Y:lPointC.Y - lPointB.Y};
                var lVectorCB = {X:-lVectorBC.X, Y:-lVectorBC.Y};
                var lVectorCD = {X: lPointD.X - lPointC.X, Y:lPointD.Y - lPointC.Y};
                var lBACrossBC = hCrossProduct(lVectorBA, lVectorBC);
                if(lBACrossBC < 0.01) //current angle is less than or equal to 180 degree
                {
                    if(hCrossProduct(lVectorCB, lVectorCD) < 0.01)//the next angle is less than 180 degree
                    {
                        var lTempPoint = {X:0, Y:0};
                        var lTemp = 0.0;

                        var lRt = hGetBisectorPointAndDepth(lPointA, lPointB, lPointC, lPointD, lTempPoint, lTemp);
                        lTempPoint = lRt.point;
                        lTemp = lRt.val;
                        if (lRt.mark)
                        {
                            lIsValid = true;
                            lDepth = (lDepth > lTemp) ? lTemp : lDepth;
                        }
                    }
                    // Do nothing if the next angle is greater 180 degree.
                }
                else if(lBACrossBC > 0.01)//current angle is greater than 180 degree
                {
                    var lPolygon = [];
                    lPolygon = hGetNewPolygon(polygon, i, lPolygon);

                    var lRt = hGetNewAreaDepth(lPolygon, lTemp);
                    var lTemp = lRt.depth;
                    if (lRt.mark)
                    {
                        lIsValid = true;
                        lDepth = (lDepth > lTemp) ? lTemp : lDepth;
                    }
                }
                // Do nothing if current angle is equal to 180 degree.
            }//end of for loop
            orMaxDepth = lDepth;
            val = lIsValid;
        }//end of else

        return {mark:val, depth:orMaxDepth};
    }//end of function

    function hIsFPointsEqual(vectorA, vectorB)
    {
        return (Math.abs(vectorA.X - vectorB.X) < 0.01 && Math.abs(vectorA.Y - vectorB.Y) < 0.01);
    }

    function hRemoveZeroEdgeInPolygon(polygon)
    {
        var lPolygon = [];
        lPolygon.push(polygon[0]);

        pcount = polygon.length;
        for(var i = 1; i < pcount; i++)
        {
            if (polygon[i-1].X == polygon[i].X && polygon[i-1].Y == polygon[i].Y)
                continue;
            lPolygon.push(polygon[i]);
        }

        var lFinalPolygon = new Array();
        pcount = lPolygon.length;
        for(var i = 0; i < pcount; i++)
        {
            if (i === pcount - 1)
            {
                if (lPolygon[i].X == lPolygon[0].X && lPolygon[i].Y == lPolygon[0].Y)
                    continue;
            }
            lFinalPolygon.push(lPolygon[i]);
        }

        return lFinalPolygon;
    }

    function hIsOnSegment(vectorA, vectorB, vectorC, bExclude)
    {
        var lTolerance = 0.01;
        if (bExclude === false)
            lTolerance = -0.01;

        if (Math.abs(vectorB.X - vectorC.X) < 0.01)
        {
            if (vectorA.Y - vectorB.Y > lTolerance && vectorC.Y - vectorA.Y > lTolerance)
                return true;
            if (vectorA.Y - vectorC.Y > lTolerance && vectorB.Y - vectorA.Y > lTolerance)
                return true;
        }
        else
        {
            if (vectorA.X - vectorB.X > lTolerance && vectorC.X - vectorA.X > lTolerance)
                return true;
            if (vectorA.X - vectorC.X > lTolerance && vectorB.X - vectorA.X > lTolerance)
                return true;
        }

        return false;
    }


    function hLineInterSection(vectorA, vectorB, vectorC, vectorD, vectorSection, bExclude)
    {
        var vectorAB = {X : vectorB.X - vectorA.X, Y : vectorB.Y - vectorA.Y};
        var vectorCD = {X : vectorD.X - vectorC.X, Y : vectorD.Y - vectorC.Y};

        if (Math.abs(hCrossProduct(vectorAB, vectorCD)) < 0.01)
        {
            var vectorAC = {X : vectorC.X - vectorA.X, Y : vectorC.Y - vectorA.Y};
            if (Math.abs(hCrossProduct(vectorAB, vectorAC)) < 0.01)
               return { val:-1, interSection:vectorSection };
            else
               return { val:0, interSection:vectorSection };
        }
        else
        {
            var vectorCA = {X : vectorA.X - vectorC.X, Y : vectorA.Y - vectorC.Y};
            var lS = hCrossProduct(vectorCD, vectorCA)/hCrossProduct(vectorAB, vectorCD);
            vectorSection.X = vectorA.X + lS*vectorAB.X;
            vectorSection.Y = vectorA.Y + lS*vectorAB.Y;
            if (hIsOnSegment(vectorSection, vectorA, vectorB, bExclude)
                    && hIsOnSegment(vectorSection, vectorC, vectorD, bExclude))
                return { val:1, interSection:vectorSection };
            else
                return { val:2, interSection:vectorSection };
        }
    }

    function hRatioInRectangle(rect, angle, anchor)
    {
        var lAngle = angle;
        while (lAngle < 0)
        {
            lAngle += 360;
        }
        while (lAngle >= 360)
        {
            lAngle -= 360;
        }

        var lEdgeRight = rect.X + rect.Width - anchor.x;
        var lEdgeUp = anchor.y - rect.Y;
        var lEdgeLeft = anchor.x - rect.X;
        var lEdgeDown = rect.Y + rect.Height - anchor.y;
        var lRadianAngle = degreeToRadian(lAngle);

        // Flip y-coordinate to make angle increase counterclockwise.
        var lUnitVectorAngle = {x : Math.cos(lRadianAngle), y : -Math.sin(lRadianAngle)};

        // A: Upper left corner
        // B: Upper right corner
        // C: Lower right corner
        // D: Lower left corner
        // E: Start Point
        // F: End Point
        // O: Anchor point
        var lLengthOF;
        var lNegLengthOE;
        if (lAngle >= 0 && lAngle < 90)
        {
            var lVectorOB = {x : lEdgeRight, y : -lEdgeUp};
            var lVectorOD = {x : -lEdgeLeft, y : lEdgeDown};
            lLengthOF = innerProduct(lVectorOB, lUnitVectorAngle);
            lNegLengthOE = innerProduct(lVectorOD, lUnitVectorAngle);
        }
        else if (lAngle >= 90 && lAngle < 180)
        {
            var lVectorOA = {x : -lEdgeLeft, y : -lEdgeUp};
            var lVectorOC = {x : lEdgeRight, y : lEdgeDown};
            lLengthOF = innerProduct(lVectorOA, lUnitVectorAngle);
            lNegLengthOE = innerProduct(lVectorOC, lUnitVectorAngle);
        }
        else if (lAngle >= 180 && lAngle < 270)
        {
            var lVectorOB = {x : lEdgeRight, y : -lEdgeUp};
            var lVectorOD = {x : -lEdgeLeft, y : lEdgeDown};
            lLengthOF = innerProduct(lVectorOD, lUnitVectorAngle);
            lNegLengthOE = innerProduct(lVectorOB, lUnitVectorAngle);
        }
        else // (iAngle >= 270 && iAngle < 360)
        {
            var lVectorOA = {x : -lEdgeLeft, y : -lEdgeUp};
            var lVectorOC = {x : lEdgeRight, y : lEdgeDown};
            lLengthOF = innerProduct(lVectorOC, lUnitVectorAngle);
            lNegLengthOE = innerProduct(lVectorOA, lUnitVectorAngle);
        }

        endPoint.x = anchor.x + lLengthOF * lUnitVectorAngle.x;
        endPoint.y = anchor.y + lLengthOF * lUnitVectorAngle.y;
        startPoint.x = anchor.x + lNegLengthOE * lUnitVectorAngle.x;
        startPoint.y = anchor.y + lNegLengthOE * lUnitVectorAngle.y;
        var lAnchorPercent = -lNegLengthOE / (lLengthOF - lNegLengthOE);
        if (lAnchorPercent < 0)
        {
            lAnchorPercent = 0;
        }
        else if (lAnchorPercent > 1)
        {
            lAnchorPercent = 1;
        }
        return lAnchorPercent;
    }

    function degreeToRadian(degree)
    {
        return degree * PI / 180;
    }

    function radianToDegree(radian)
    {
        return radian * 180 / PI;
    }

    function innerProduct(vector1, vector2)
    {
        return (vector1.x * vector2.x + vector1.y * vector2.y);
    }

    function hInnerProduct(vector1, vector2)
    {
        return (vector1.X * vector2.X + vector1.Y * vector2.Y);
    }

    function hCrossProduct(vector1, vector2)
    {
        return (vector1.X * vector2.Y - vector1.Y * vector2.X);
    }

    function fillGradient(context, format, rect, darkerFactor)
    {
        var gradient = format.Gradient;

        var startColor = "RGBA(" + Math.round(darkerFactor * gradient.StartGraphColor.R) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.G) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.B) + ", " + format.Alpha / 255.0 + ");";
        var endColor = "RGBA(" + Math.round(darkerFactor * gradient.EndGraphColor.R) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.G) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.B) + ", " + gradient.EndAlpha / 255.0 + ");";
        var finalGradient;

        switch (gradient.GradientType)
        {
        case GradientLinear:
            {
                var lHOffset = gradient.HorizontalOffset;
                if ((gradient.Angle > 90 && gradient.Angle < 180) || gradient.Angle > 270)
                {
                    // #370782, for backward compatibility.
                    lHOffset = 100 - lHOffset;
                }

                var lAnchorPoint = {x : rect.X + rect.Width * lHOffset / 100,
                        y : rect.Y + rect.Height * gradient.VerticalOffset / 100};
                startPoint = {x : 0, y : 0};
                endPoint = {x : 0, y : 0};
                var lAnchorPercent = hRatioInRectangle(rect, gradient.Angle, lAnchorPoint);

                finalGradient = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                finalGradient.addColorStop(0, endColor);
                finalGradient.addColorStop(lAnchorPercent, startColor);
                finalGradient.addColorStop(1, endColor);

                context.fillStyle = finalGradient;
                context.fill();
            }
            break;

        case GradientCircular:
            {
                var lAnchorPoint = {x : rect.X + rect.Width * gradient.HorizontalOffset / 100,
                        y : rect.Y + rect.Height * gradient.VerticalOffset / 100};
                var lScale = rect.Width * 1.0 / rect.Height;
                lAnchorPoint.y *= lScale;

                finalGradient = context.createRadialGradient(lAnchorPoint.x, lAnchorPoint.y, 0, lAnchorPoint.x, lAnchorPoint.y, rect.Width * 2);
                finalGradient.addColorStop(0, startColor);
                finalGradient.addColorStop(0.5, endColor);
                finalGradient.addColorStop(1, endColor);
                context.fillStyle = finalGradient;

                context.save();
                context.scale(1.0, 1 / lScale);
                context.fill();
                context.restore();
            }
            break;

        case GradientRectangular:
            {
                var lAnchorPoint = {x : rect.X + rect.Width * gradient.HorizontalOffset / 100,
                        y : rect.Y + rect.Height * gradient.VerticalOffset / 100};
                var lAngle = gradient.Angle % 90;
                var lRectAngle = radianToDegree(Math.atan(rect.Height / rect.Width));
                var lTempAngle = 2 * lAngle - lRectAngle * lAngle / 45 + 90 + lRectAngle;

                startPoint = {x : 0, y : 0};
                endPoint = {x : 0, y : 0};
                var lAnchorPercent = hRatioInRectangle(rect, lTempAngle, lAnchorPoint);

                var lGradient = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                startColor = "RGBA(" + Math.round(darkerFactor * gradient.StartGraphColor.R) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.G) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.B) + ", " + format.Alpha / (255.0 * 2 - format.Alpha) + ");";
                endColor = "RGBA(" + Math.round(darkerFactor * gradient.EndGraphColor.R) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.G) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.B) + ", " + gradient.EndAlpha / (255.0 * 2 - gradient.EndAlpha) + ");";
                lGradient.addColorStop(0, endColor);
                lGradient.addColorStop(lAnchorPercent, startColor);
                lGradient.addColorStop(1, endColor);
                context.fillStyle = lGradient;
                context.fill();

                lTempAngle = lRectAngle * lAngle / 45 + 90 - lRectAngle;
                lAnchorPercent = hRatioInRectangle(rect, lTempAngle, lAnchorPoint);

                finalGradient = context.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
                startColor = "RGBA(" + Math.round(darkerFactor * gradient.StartGraphColor.R) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.G) + ", " + Math.round(darkerFactor * gradient.StartGraphColor.B) + ", " + format.Alpha / (255.0 * 2) + ");";
                endColor = "RGBA(" + Math.round(darkerFactor * gradient.EndGraphColor.R) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.G) + ", " + Math.round(darkerFactor * gradient.EndGraphColor.B) + ", " + gradient.EndAlpha / (255.0 * 2) + ");";
                finalGradient.addColorStop(0, endColor);
                finalGradient.addColorStop(lAnchorPercent, startColor);
                finalGradient.addColorStop(1, endColor);
                context.fillStyle = finalGradient;
                context.fill();
            }
            break;
        }
    }

    function addCompensativeLayer(context, format)
    {
        // Add this layer to make sure that the combine alpha value of non-simple layer and bevel-sphere layer is at least mAlpha.
        // The alpha value of 3 layers are a/(2-a), 0<=b<=1, and a/2.
        // The combine alpha is 1-(1-a/2)*(1-b)*(1-a/(2-a))=1-(1-b)*(1-a)>=1-(1-a)=a.
        var lFillAlpha = format.Alpha / 255.0;
        context.fillStyle = 'rgba(255,255,255,' + format.Alpha / 255.0 + ')';
        context.fill();
    }


    /**
     * This method clears the rectangle covering the entire context on the canvas.
     *
     * @param context The HTML5 Canvas' context object
     */
    function clearCanvas(context) {
        //Grab the canvas object from the context
        var canvas = context.canvas;

        //Clear the rectangle convering the entire canvas.
        context.clearRect(0, 0, canvas.width, canvas.height);
    }

    function draw(widget) {
        INITIAL_TIME = (new Date()).getTime();
        drawEx(widget);// 479089 Use a helper method to support animation.
    }

    function drawEx(widget) {
        var data = widget.graphData,
            unitList = data.UnitList,
            unitCount = unitList.length,
            formatList = data.FormatList,
            cn = widget.graphNode,
            hcn = widget.highlightNode,
            hcontext = hcn.getContext('2d'),
            scn = widget.selectionNode,
            scontext = scn.getContext('2d'),
            context = cn.getContext('2d');

        //Before we start, clear the canvas completely
        clearCanvas(context);
        clearCanvas(hcontext);
        clearCanvas(scontext);

        // Use normalized time (eset the time to the max if we get the last animation cycle past the animation duration).
        var t = Math.min(((new Date()).getTime() - INITIAL_TIME) / ANIMATION_DURATION, 1),
            x = (1 - t),
            i;

        /**
         * Use Bezier curve function for progress to achieve ease in and out effect.
         * Reference: http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/Animation_Types_Timing/Articles/Timing.html
         * Control points for ease in and out:[(0, 0), (0,25, 0.1), (0.75, 0.9), (1, 1)].
         * progress = (1-t)^3 * 0 + 3 * (1-t)^2 * t * 0.1 + 3 * (1-t) * t^2 * 0.9 + t * t * t * 1
         */
        var progress = 0.3 * t * x * x + 2.7 * x * t * t + t * t * t;

        var isAnimated = 0;
        for (i = 0; i < unitCount; i++) {
            drawWithContext(context, progress, unitList[i], formatList);
            if (unitList[i].IsAnimated !== 0)
            {
                isAnimated = 1;
            }
        }

        //If we haven't reached our animation threshold...
        if (t < 1.0 && isAnimated === 1) {
            // Call draw again after 20 milliseconds.
            setTimeout(function() {
                drawEx(widget);
            }, 20);
        }
    }

    /**
     * A mixin to add canvas graph rendering abilities to normal image graph widgets.
     *
     * @class
     * @public
     */
    mstrmojo.graph._CanvasGraph = mstrmojo.provide(
        "mstrmojo.graph._CanvasGraph",

        /**
         * @lends mstrmojo.graph._CanvasGraph
         */
        {
            markupString: '<div class="{@cssClassPrefix} {@cssClass}" title="{@tooltip}" style="{@domNodeCssText};">' +
                              '<div class="{@cssClassPrefix}-txt"></div>' +
                              '<canvas id="{@id}" height="{@height}" width="{@width}">' +
                                  '{@unsupportedError}' +
                              '</canvas>' +
                              '{@map}' +
                              '<canvas id="{@id}-highlight" class="mobile-graph-selection-canvas" height="{@height}" width="{@width}" style="position:absolute;top:0;left:0">' +
                              '</canvas>' +
                              '<canvas id="{@id}-highlight" class="' + mstrmojo.GraphBase.canvasCLS + '" height="{@height}" width="{@width}" style="position:relative;top:0;left:0">' +
                              '</canvas>' +
                          '</div>',

            unsupportedError: "This text is displayed if your browser does not support HTML5 Canvas element.",

            markupSlots: {
                graphNode: function () { return this.domNode.childNodes[1]; },
                imgNode: function () { return this.domNode.childNodes[1]; },        // Non-canvas graphs need this slot.
                mapNode: function () { return null; },                              // Canvas case should not have a map node
                textNode: function () { return this.domNode.firstChild; },
                selectionNode: function () { return this.domNode.lastChild.previousSibling;},
                highlightNode: function () { return this.domNode.lastChild; }
            },

            /**
             * The data for this graph (must be supplied by the consumer of this mixin).
             *
             * @type Object
             */
            graphData: null,

            retrieveGraphSrc: function retrieveGraphSrc(h, w) {
                var graphNode = this.graphNode,
                    highlightNode = this.highlightNode,
                    selectionNode = this.selectionNode,
                    graphData = this.graphData,
                    data = (graphData && graphData.data);

                if(data && data.eg) {
                    var tn = this.textNode,
                        img = this.imgNode;

                    // Hide the graph image.
                    img.style.display = 'none';
                    highlightNode.style.display = 'none';
                    selectionNode.style.display = 'none';

                    // Display the message (or empty string).
                    tn.innerHTML = data.eg || '';

                    // Make sure the text node is visible.
                    tn.style.display = 'block';
                    // set the class name to set the background properly
                    tn.className = 'mstrmojo-message';
                } else {
                    // Set the size of the canvas.
                    var height = graphData.GH ||  parseInt(h, 10),
                        width = graphData.GW || parseInt(w, 10);

                    graphNode.setAttribute('height', height);
                    graphNode.setAttribute('width', width);

                    highlightNode.style.display = 'block';
                    highlightNode.setAttribute('height', height);
                    highlightNode.setAttribute('width', width);

                    highlightNode.style.top = -height + 'px';

                    selectionNode.style.display = 'block';
                    selectionNode.setAttribute('height', height);
                    selectionNode.setAttribute('width', width);

                    // hide the tooltips in case of refresh
                    this.displayTooltips([], 0, 0);
                    // Draw the graph.
                    
                    draw(this);

                    if (graphData.Selected) {
                        this.highlightAreaInInit(selectionNode, graphData.Selected);
                    }
                }
            },
            
            unrender: function unrender(ignoreDom) {

                //TQMS 581802, set the parameter ignoreDom to false in order to hide memory leak of related classes. We may need to figure out where the problem is in the future events.
                this._super(false);
                
            },
          
            invalidate: function invalidate() {
                //TQMS #555940: Clear the canvas when the graph is invalidated.
                var graphNode = this.graphNode;
                if(graphNode) { // TQMS #560854 make sure that the graphNode is present
                    clearCanvas(graphNode.getContext('2d'));
                }
            },
            
            getCaptureDimensions: function getCaptureDimensions() {
            	var graphNode = this.graphNode,
            	    position = mstrmojo.dom.position(this.domNode, true);
            	
            	position.w = graphNode.width;
            	position.h = graphNode.height;
            	
            	return position;
            }
        }
    );

}());
(function() {
    mstrmojo.requiresCls("mstrmojo.ValidationTextBox", "mstrmojo._IsInputControl", "mstrmojo.dom", "mstrmojo.num");
    
    var _VAL = mstrmojo.validation,
        SC = _VAL.STATUSCODE,
        _VALIDATOR = _VAL.VALIDATOR,
        _DTP = mstrmojo.expr.DTP,
        NO_VALIDATION = 0,
        PHONE_NO = 1,
        EMAIL_ADDRESS = 2,
        ZIP_CODE = 3,
        SOCIAL_SECURITY_NO = 4,
        REG_EXP = 5;
    
    /**
     * Popup only
     */
    mstrmojo.TextFieldDIC = mstrmojo.declare(
            
        mstrmojo.ValidationTextBox,
        
        [mstrmojo._IsInputControl],
        
        {
            scriptClass: 'mstrmojo.TextFieldDIC',
            
            cssClass: 'mstrmojo-TextFieldDIC',
            
            dtp: _DTP.VARCHAR,
            
            validationDelay: 0, // do validation immediately
            
            getInputNode: function(){
                return this.inputNode;
            },
            
            focus: function() {
                this.validate();
                mstrmojo.dom.setCaret(this.domNode, (this.value && this.value.length || 0));
            },
            
            init: function(props) {
                if (this._super){
                    this._super(props);
                }
                
                this.constraints = mstrmojo.hash.copy()
                
                var di = props.dic, 
                    c = this.constraints = {trigger: mstrmojo.validation.TRIGGER.ONKEYUP}, //each instance needs a own copy  
                    dt = di.dt;
                
                if(di.ml) {
                    this.maxLength = di.ml;
                }
                
                //Mask text (password)
                if(di.psw) {
                    this.type = 'password';
                    //reset the value to show nothing in the text field DIC
                    this.value = this.lv = '';
                    this.owner.applyPasswordMask && this.owner.applyPasswordMask();
                }
                
                // We only validate for the integer, numeric or string data type.
                if (_VAL.isNumeric(dt) || _VAL.isInt(dt) || _VAL.isString(dt)){
                    this.dtp = dt;
                }
                
                switch (di.vm){//Validation method
                case PHONE_NO: 
                        c.validator = _VALIDATOR.VALIDATE_PHONENO;
                        break;
                case EMAIL_ADDRESS: 
                        c.validator = _VALIDATOR.VALIDATE_EMAIL;
                        break;
                case ZIP_CODE:
                        c.validator = _VALIDATOR.VALIDATE_ZIPCODE;
                        break;
                case SOCIAL_SECURITY_NO: 
                        c.validator = _VALIDATOR.VALIDATE_SSN;
                        break;
                case REG_EXP: 
                        c.regExp = new RegExp('^'+di.rgx+'$');
                        break;
                }
                
                c.min = di.emin ? di.min : null;
                c.max = di.emax ? di.max : null;
                
                c.maxLen = (di.ml !== undefined) ? di.ml : null;
                c.minLen = (di.mnl !== undefined) ? di.mnl : null;
                
                if (di.req || di.emin){
                    this.required = true;
                }
            },
            
            /**
             * If it contains invalid input, we should make the popup modal so that anything below the popup won't respond to user's action.
             */
            onInvalid: function(){
                if(this.popup) {
                    this.popup.set('hasInvalidData', true);
                }
            },
            
            onValid: function(){
                if(this.popup) {
                    this.popup.set('hasInvalidData', false);
                }
            },
            
            /**
             * @override mstrmojo._IsInputControl.applyChanges
             */
            applyChanges: function(){
                this.validate();
                
                if(this.isValid()){
                    this._super();
                }else{
                    this.handleInvalid();
                    return false;
                }
                
                return true;
            },
            
            handleInvalid: function(){
                if (mstrmojo.all.mojoConfirmx9){
                    // the error dialog is still there
                    return;
                }
                
                var me = this;
                mstrmojo.confirm(this.validationStatus.msg + '<br>(' + mstrmojo.desc(9199) + ')',  
                                //Click OK button to continue the modification or Cancel button to revert back to the original value.
                                [{
                                    scriptClass: 'mstrmojo.Button',
                                    text: mstrmojo.desc(1442), // 'OK'
                                    onclick: function(){
                                        me.focus();
                                    }
                                },{
                                    scriptClass: 'mstrmojo.Button',
                                    text: mstrmojo.desc(221), // 'Cancel'
                                    onclick: function(){
                                        me.popup.onCancel();
                                    }
                                }], mstrmojo.desc(7548)); // 'Validation Error'
            },
            
            cancelChanges: function(){
                this.inputNode.blur();
                this.value = this.lv;
                this.clearValidation();
            }
        });
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.TextArea",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $DOM = mstrmojo.dom,
        $C = mstrmojo.css,
        BASEFORM_URL = 5,
        BASEFORM_EMAIL = 6,
        INTEGER = 1,
        FLOAT = 7, //EnumDSSXMLDataType.DssXmlDataTypeFloat
        BIGDECIMAL = 30; //EnumDSSXMLDataType.DssXmlDataTypeBigDecimal

    function reApplyWebkitTransform(dom) {
        if (dom.style) {
            var trans = mstrmojo.css.getStyleValue(dom, $DOM.CSS3_TRANSFORM);
            if (trans !== 'none') {
                dom.style[$DOM.CSS3_TRANSFORM] =  trans;
            }
        }
    }

    function convert3dTransform(dom) {
        var i,
            len = dom.childNodes.length;
        for (i = 0; i < len; i++) {
            var c = dom.childNodes[i];
            convert3dTransform(c);
            reApplyWebkitTransform(c);
        }
    }

    mstrmojo.android.inputControls.TextAreaDIC = mstrmojo.declare(

        mstrmojo.TextArea,

        [mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton],

        {
            scriptClass: "mstrmojo.android.inputControls.TextAreaDIC",

            cssDisplay: 'block',

            init: function init(props) {
                this._super(props);

                this.maxLength = this.dic.ml;

                if (!this.showByDefault) {
                    this.cssClass = 'mstrmojo-TextAreaDIC-Popup';
                    this.rows = 7;
                }
            },

            focus: function focus() {
                $DOM.setCaret(this.domNode, (this.value != null && String(this.value).length) || 0);
            },

            onfocus: function onfocus() {
                //TQMS 568674: force repaint the webview to fix the screen flickering problem.
                window.setTimeout(function () {
                    mstrMobileApp.forceRepaint();
                }, 0);
            },

            onvalueChange: function onvalueChange() {
                if (!this.showByDefault) {
                    this._super();
                }
            },

            onblur: function onblur() {
                if (this.showByDefault) {
                    this.applyChanges();
                }
            },

            applyChanges: function applyChanges() {
                //TQMS 506312: for Chinese or Korean input, the virtual keyboard can input values without triggering
                //key up, therefore, the value will not get changed. So calling the domNode blur function to force the
                //input box value applied to widget value.
                this.domNode.blur();
                var dt = parseInt(this.dic.dt, 10);
                if ((dt >= INTEGER && dt <= FLOAT) || dt === BIGDECIMAL) {
                    this.value = parseFloat(this.value);
                }
                this._super();
            },

            cancelChanges: function cancelChanges() {
                this.domNode.blur();
                this._super();
            },

            postBuildRendering: function postBuildRendering() {
                this._super();

                if (this.showByDefault) {
                    // TQMS716716: for inline textarea in Android, the textarea can set width and height to be 100% fit to fit insize the textfield container
                    // then we shoud not worry about the paddings and possible clips from the containers.
                    this.domNode.style.width = '100%';
                    this.domNode.style.height = '100%';

                    // We have two issues 568319 and 568326 about the abnormality of inline text area DIC on phones.
                    // They are caused by the CSS 3D transform which is not well supported on android 2.x devices.
                    // We used 3D transform rather than 2D transform because it has much better user experience.
                    // So, we need to work around the issue with the following approach:
                    // We would need to re-apply the computed style of webkitTransform which would be in 2D matrix form.
                    // And we also need to apply this fix to all the document objects rather than the ancestors of the inline text area DIC.
                    if (!mstrApp.isTablet()) {
                        // Previously, we did this in the handler of focus event. However, it still causes the crash while dragging cursor on Samsung phones.
                        // This is because, the keyboard pops up after the focus event fired and screen is resized. At the same time, some dom Node would be
                        // translated again with 3d transform. We need to redo our fixes when user taps textarea again to show the draggable cursor.
                        $DOM.attachEvent(this.domNode, 'click', function () {
                            convert3dTransform(document.body);
                        }, false);
                    }

                    //TQMS 612345: If user tries to type something in text input node when it's not visible(not in the viewport),
                    // it will automatically fire "scrollIntoView" method on the input node to let it be visible. It's implemented by
                    // changing the scrollTop on one of its ancestor dom nodes. However, it would interfere with our mojo scrolling because
                    // we use css transform to do scrolling.
                    // So to get rid of issues like this one, we need to manually fix the scrollTop when the text input node loses focus.
                    var me = this;
                    $DOM.attachEvent(this.domNode, 'blur', function () {
                        var d = me.domNode;
                        while (d != null) {
                            if (d.scrollTop > 0) {
                                d.scrollTop = 0;
                                break;
                            }
                            d = d.parentNode;
                        }
                    }, false);
                }
            },

            renderPreview: function renderPreview() {
                var dic = this.dic,
                    v = this.value,
                    dv = (this.dv == null) ? '' : String(this.dv),
                    prefix = '',
                    reg4URL = /(.*href=['"])(.*)(['"].*>)(.*)(<.*)/i;

                if (!dv || !dic.sp) { // if value is empty or not show preview text
                    this.dv = dic.siwc ? '&nbsp;' : (dv || '&nbsp;');
                } else {
                    // if show preview, cut off the overflow part of the display text
                    v = (v.length > dic.pl) ? (v.substring(0, dic.pl) + '&hellip;') : v;

                    // build up the email or url link if necessary
                    switch (this.ts) {
                    case BASEFORM_EMAIL:
                        prefix = 'mailto:';
                        // fall through
                    case BASEFORM_URL:
                        if (!dv) {
                            dv = '<a href="mailto:"></a>';
                        }
                        dv = dv.replace(reg4URL, '$1' + prefix + this.value.replace(/\$/g, '$$$$') + '$3' + v.replace(/\$/g, '$$$$') + '$5');
                        break;
                   default:
                        dv = (dv.length > dic.pl) ? (dv.substring(0, dic.pl) + '&hellip;') : dv;
                    }
                    this.dv = dv;
                }

                this.renderPreviewButton(this.openerNode, this.dv);

                $C.toggleClass(this.openerNode.firstChild, 'filled', !this.dicChanged && this.value != null && String(this.value).length > 0);

            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.ui.MobileCheckList",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.android._IsIncFetchList",
                         "mstrmojo.array");

    var BLOCK_SIZE = 50;

    function createIncFetchDataHelper() {
        return {
            next: function (cb) {
                var newEnd = Math.min(this.blockEnd + BLOCK_SIZE, this.totalSize);

                cb.success(null, this.items.slice(this.blockEnd, newEnd));

                this.blockEnd = newEnd;
            },

            init: function (begin, end, items) {
                this.blockBegin = begin;
                this.blockEnd = end;
                this.totalSize = items.length;
                this.items = items;
            }
        };
    }

    mstrmojo.android.inputControls.PullDownDIC = mstrmojo.declare(
        mstrmojo.ui.MobileCheckList,

       [mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton, mstrmojo.android._IsIncFetchList],

        {
            scriptClass: 'mstrmojo.android.inputControls.PullDownDIC',

            multiSelect: false,

            isElastic: true,

            supportsIncFetch: false,

            init: function init(props) {
                this._super(props);

               this._items = this.getItems();

                if (this._items.length > BLOCK_SIZE) {
                    this.ifDataHelper = createIncFetchDataHelper();
                    this.supportsIncFetch = true;
                }
            },

            postselectionChange: function postselectionChange(evt) {
                var idx = evt.added[0];
                if (idx < this.items.length) {
                    this.set('value', this.items[idx].v);
                }
            },

            preBuildRendering: function preBuildRendering() {
                this._super();

                var value = this.value,
                    ust = this.dic.ust || '',
                    items = this._items,
                    idx = mstrmojo.array.find(items, 'v', value);

                // if we have an unset option
                if (idx === -1) {
                    // add unset option
                    items = [{
                        n: ust,
                        v: value
                    }].concat(items);
                    idx = 0;
                }

                if (this.supportsIncFetch) {
                    // set up incremental fetch helper
                    this.ifDataHelper.init(0, BLOCK_SIZE, items);
                    // set the items to be rendered
                    items = items.slice(0, BLOCK_SIZE);
                }

                this.items = items;
                this.set('selectedIndex', idx);
            },

            postBuildRendering: function postBuildRendering() {
                this._super();
                //reset the scroller position
                this._scroller.scrollTo(0, 0);
            },

            /**
             * Render the preview button for the list dic
             */
            renderPreview: function renderPreview() {
                // Call _HasPreviewButton mixin function to render the button.
                var idx = mstrmojo.array.find(this._items, 'v', this.value),
                    label = (idx >= 0) ? this._items[idx].n : (this.dic.ust !== undefined ? this.dic.ust : this.dv);

                this.renderPreviewButton(this.openerNode, this.dicChanged ? label : this.dv);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DateTimePicker",
                         "mstrmojo.ui.MobileStepper",
                         "mstrmojo._TouchGestures");
    
    var dateTimeScriptClass = 'mstrmojo.ui.MobileStepper';
        
    /**
     * Widget for allowing the user to pick time using a stepper style.
     * 
     * @class
     * @extends mstrmojo.Container
     */
    mstrmojo.ui.MobileDateTimePicker = mstrmojo.declare(
        /**
         * Super Class
         */
        mstrmojo.DateTimePicker,
            
        /**
         * Mixins
         */
        [mstrmojo._TouchGestures],
            
        {

            scriptClass: "mstrmojo.ui.MobileDateTimePicker",
            
            stepperClass: 'mstrmojo.ui.MobileStepper',
            
            /**
             * Onclick event handler for non-touch enabled devices.
             */
            onclick: function(evt) {
                this.touchTap(evt.e);
            },
            
            /**
             * Event handler when the user taps on a touch enabled device
             * 
             * @see mstrmojo._TouchGestures
             */
            touchTap: function(touch) {
                if (touch.target === this.meridiemNode) {
                    //adjust the meridiem
                    this.set('meridiem', !this.meridiem);
                    this.updateTime();
                }
            },
            
            touchBegin: function(touch){
                if (touch.target == this.meridiemNode){
                    mstrmojo.css.addClass(touch.target, 'glow');
                }
            },
            
            touchEnd: function(touch){
                if (touch.target == this.meridiemNode){
                    mstrmojo.css.removeClass(touch.target, 'glow');
                }
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.ui.MobileDateTimePicker",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.android._HasPreviewButton",
                         "mstrmojo.date",
                         "mstrmojo.expr",
                         "mstrmojo.locales");

    mstrmojo.requiresDescs(2052, 2170, 7656);

    var $D = mstrmojo.date,
        $DESC = mstrmojo.desc,
        CALENDAR = 5,
        TIMEPICKER = 6,
        DTP = mstrmojo.expr.DTP;

    mstrmojo.android.inputControls.DateTimePickerDIC = mstrmojo.declare(
        mstrmojo.ui.MobileDateTimePicker,

        [ mstrmojo._IsInputControl, mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: "mstrmojo.android.inputControls.DateTimePickerDIC",

            cssText: '',

            valueField: 'dtValue',

            /**
             * The title to be shown on the DIC popup
             */
            popupTitle: '',

            init: function init(props) {
                var dic = props.dic;

                if (dic.min !== undefined) {
                    props.min = $D.parseDateAndOrTime(dic.min);
                }
                if (dic.max !== undefined) {
                    props.max = $D.parseDateAndOrTime(dic.max);
                }

                props[this.valueField] = $D.parseDateAndOrTime(props.value);

                // This input control corresponds to two control style: calendar and timepicker.
                if (dic.t === CALENDAR) {
                    props.dtp = dic.ict ? DTP.TIMESTAMP : DTP.DATE;
                    props.popupTitle = dic.ict ? $DESC(7656, 'Date and Time') : $DESC(2052, 'Date');
                } else if (dic.t === TIMEPICKER) {
                    props.dtp = DTP.TIME;
                    props.minuteInterval = props.dic.itv;
                    props.popupTitle = $DESC(2170, 'Time');
                }

                this._super(props);
            },

            /**
             * @param forDisplay {Boolean} if true, return display value which is consistent with the configured dic type
             */
            getCurValue: function getCurValue(forDisplay) {
                var oldDateTime = this[this.valueField] || {},
                    date = this.getDate() || oldDateTime.date || {year: 1970, month: 1, day: 1},
                    time = this.getTime() || oldDateTime.time || {hour: 0, min: 0, sec: 0},
                    config = this.dic,
                    dt = parseInt(config.dt, 10),
                    LD = mstrmojo.locales.datetime,
                    timeFormat = LD.TIMEOUTPUTFORMAT,
                    dateFormat = LD.DATEOUTPUTFORMAT,
                    displayDate = $D.formatDateInfo(date, dateFormat),
                    displayTime = $D.formatTimeInfo(time, timeFormat);

                if (forDisplay) {
                    if (config.t === CALENDAR) {
                        return config.ict ? (displayDate + ' ' + displayTime) : displayDate;
                    }

                    return displayTime;
                }

                if (dt === DTP.TIMESTAMP) {
                    return displayDate + ' ' + displayTime;
                }

                if (dt === DTP.TIME) {
                    return displayTime;
                }

                return displayDate;
            },

            // TQMS #638080: While rendering previews for TIMESTAMP values, we should check the configured input control type (Calendar or Timepicker)
            // to determine which part (Date or Time?) to be shown.
            renderPreview: function renderPreview() {
                // Call _HasPreviewButton mixin method to render the button.
                this.renderPreviewButton(this.openerNode, this.getCurValue(true));
            }
        }
    );
}());

(function () {

    mstrmojo.requiresCls("mstrmojo.TextFieldDIC",
                         "mstrmojo.android._HasPreviewButton");

    mstrmojo.android.inputControls.TextFieldDIC = mstrmojo.declare(

        mstrmojo.TextFieldDIC,

        [ mstrmojo.android._HasPreviewButton ],

        {
            scriptClass: 'mstrmojo.android.inputControls.TextFieldDIC',

            cssClass: 'mstrmojo-TextFieldDIC',

            cssDisplay: 'block',

            //override to use the fixed size;
            onfontChange: mstrmojo.emptyFn,

            /**
             * @override mstrmojo.TextFieldDIC.applyChanges
             */
            applyChanges: function applyChanges() {
                //TQMS 506312: for Chinese or Korean input, the virtual keyboard can input values without triggering
                //key up, therefore, the value will not get changed. So calling the domNode blur function to force the
                //input box value applied to widget value.
                this.domNode.blur();
                return this._super();
            },

            /**
             * @override mstrmojo.TextFieldDIC.handleInvalid
             */
            handleInvalid: function handleInvalid() {
                //Only show the warning but do not revert to the old value
                mstrmojo.alert(this.validationStatus.msg);
            },

            cancelChanges: function cancelChanges() {
                this.domNode.blur();
                this._super();
            },

            /**
             * Overrides the focus function so that the setCaret function will not get called for android
             */
            focus: function focus() {
                this.validate();
            },

            onfocus: function onfocus() {
                // TQMS 687721: clear value and set placeholder when initial value's string length is larger than maxLength
                if (this.value != undefined && this.maxLength != undefined && String(this.value).length > this.maxLength) {
                    this.set('value', '');
                }
                //TQMS 633091: force repaint the webview to fix the screen flickering problem.
                window.setTimeout(function () {
                    mstrMobileApp.forceRepaint();
                }, 0);
            },

            renderPreview: function renderPreview() {
                var openerNode = this.openerNode,
                    group = this.group || this,
                    showFullPreview = (group.openerType === 2) || !!this.dic.dm || this.dicChanged;   // Default to full preview if opener type is field group OR not inline OR has changed.

                var displayValue = this.type === "password" ? '********' : this.dv;
                this.renderPreviewButton(openerNode, showFullPreview ? displayValue : openerNode.innerHTML);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocXtabGraph",
                         "mstrmojo.TouchScroller",
                         "mstrmojo.graph._MobileGraphAreaHelper",
                         "mstrmojo._TouchGestures");

    var $DOM = mstrmojo.dom;

    /**
     * Invokes the tooltip helper method on mstrmojo.GraphBase and provides it the element being hovered on and the location where it's at.
     *
     * @param graph (mstrmojo.MobileDocXtabGraph)
     * @param x, y The coordinates of the area element for which the user wants to see the tooltips.
     */
    function updateTooltip(graph, x, y) {
        var dpos = mstrmojo.dom.position(graph.domNode, false),
            left = 0,
            top = 0,
            node = graph.node;

        if (dpos) {
            left = dpos.x;
            top = dpos.y;
        }

        graph.model.getDataService().handleUserSingleTap(node.data.sid, node.k, x - left, y - top, false, {
            success: function (res) {
                graph.displayTooltips(res.Areas, left, top);
            }
        });

    }

    //current groupby key for graph caching.

    /**
     * Returns the current groupby key. Used for graph caching key in iphone.
     * The key is in the format
     *      $currentlayoutKey_$x where $x is
     *      $x = $groupbyKey:$groupbyLevel:$groupbyunitSelectedIndex_$x; (recursive for each group by)
     *
     */
    function getGbKey(model) {
        var gbkey = '',
            gba = [],
            currKey,
            layouts,
            currlayout,
            l,
            index,
            gb;

        if (!model) {
            return gbkey;
        }

        currKey = model.currlaykey;
        gbkey = currKey + '_';
        layouts = model.data && model.data.layouts;
        for (index = 0; index < (layouts.length || 0); index++) {
            l = layouts[index];
            if (l.k === currKey) {
                currlayout = l;
                break;
            }
        }

        if (currlayout) {
            if (currlayout.gbys) {
                gba = currlayout.gbys.groupbys;
                for (index = 0; index < (gba.length || 0); index++) {
                    gb = gba[index];
                    gbkey = gbkey + gb.k + ':' + gb.lvl;
                    if (gb.unit) {
                        gbkey = gbkey + ':' + gb.unit.idx;
                    }
                    gbkey = gbkey + '_';
                }
            }
        }
        return gbkey;
    }

    function applySelectionChange(touch) {
        //always hide the tooltip on tap
        this.displayTooltips([], 0, 0);

        var me = this,
            dataService = this.model.getDataService(),
            pos = mstrmojo.dom.position(this.domNode, true),
            x = touch.pageX - pos.x,
            y = touch.pageY - pos.y,
            anchor = {                                            // Simulate an anchor
                    getBoundingClientRect: function () {
                     var left = touch.pageX,
                         top = touch.pageY;

                     return {
                         left: left,
                         top: top,
                         right: left + 1,
                         bottom: top + 1
                     };
                    }
                 },
            callback = {
                success: function (res) {
                    var areas = res.Areas,
                        defn = me.defn,
                        k = me.k,
                        tks = res.tks;
                    
                    if (areas && areas.length > 0) {
                        if (areas[0].Selectable === 1) {
                            // highlight the selected areas
                            me.highlightArea(me.selectionNode, areas);

                        } else if(areas[0].Selectable === -1) { // #721065 showall case will return selectable to -1 which means unselect the highlighted area
                            // reset all the selected highlighted areas
                            me.highlightedAreas = [];
                            
                            // clear the canvas of highlighted areas
                            me.clearHighlightArea(me.selectionNode);
                        }
                        
                        if(tks) {
                        	me.showInfoWin(tks, anchor);
                        }
                    } else {
                        // reset all the selected highlighted areas
                        me.highlightedAreas = [];
                        
                        // clear the canvas of highlighted areas
                        me.clearHighlightArea(me.selectionNode);
                    }
                    
                    window.setTimeout(function () { // #730885 force repaint and call slice in timeout to make sure info window if any is rendered properly
                        mstrMobileApp.forceRepaint();

                        // always make the slice call if nothing is selected than backend should send selection data as all is selected
                        me.model.slice({
                        	type: parseInt(defn.t, 10) || mstrmojo.EnumRWUnitType.GRAPH,
                        	src: k,
                        	ck: defn.ck,
                        	gk: k,
                        	sid: me.node.data.sid,
                        	x: x, // area.Point.X,
                        	y: y,  // area.Point.Y
                        	tks:tks,
                        	anchor: anchor
                        });
                    
                    }, 0);
                }
            };

        dataService.handleUserSingleTap(me.node.data.sid, me.k, x, y, true, callback);

    }

    /**
     * Sets the source of the imgNode to the supplied source value.
     * 
     * @param {String} src The new source of the image.
     * 
     * @private
     */
    function setImageNodeSrc(src) {
        var imgNode = this.imgNode;

        // Is the response different then the current src on the image node?
        if (imgNode.src !== src) {
            // Change it.
            imgNode.src = src;

            // Translate to force repaint.
            $DOM.translate(imgNode, 0, 0, 0);
        }
    }

    /**
     * <p>The widget for a single MicroStrategy Report Services Graph control on a mobile device.</p>
     *
     * @class
     * @extends mstrmojo.DocXtabGraph
     */
    mstrmojo.MobileDocXtabGraph = mstrmojo.declare(
        mstrmojo.DocXtabGraph,

        [ mstrmojo._TouchGestures, mstrmojo.graph._MobileGraphAreaHelper ],

        /**
         * @lends mstrmojo.MobileDocXtabGraph.prototype
         */
        {
            scriptClass: "mstrmojo.MobileDocXtabGraph",

            /**
             * This string denotes the markup of each area dom node in the image map.
             *
             * @type String
             */
            areaMarkup: '<area shape="{@shape}" coords="{@coords}" ttl="{@tooltip}" aid="{@aid}" {@extra}/>',

            retrieveGraphSrc: function retrieveGraphSrc(h, w) {
                var  id = this.id,
                    model = this.model;
                

                // We don't want to make a call for information if we don't have a viewable height or width.
                if (parseInt(h, 10) > 0 && parseInt(w, 10) > 0) {
                    model.getDataService().getRWGraphImage({
                        w: w,
                        h: h,
                        k: this.k,
                        sid: this.node.data.sid,
                        gbk: getGbKey(model)
                    }, model.newCallback({
                        success: function (res) {
                            // Set the image node source to the response.
                            setImageNodeSrc.call(mstrmojo.all[id], res);
                        }
                    }));
                }
            },

            invalidate: function invalidate() {
                // TQMS #555940: Clear the image node source because when this graph is shown again, it likely won't be the same anymore.
                setImageNodeSrc.call(this, '');
            },

            /**
             * @see mstrmojo._HasTooltip.
             */
            showTooltip: function showTooltip() {
                //Don't do anything. This method is triggered onmouseover and causes the tooltips to show up
                //when we don't need it.
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                // Detach the browser's default touches so we can perform our own touches.
                this.restoreDefaultTouches(false);

                // Update the tooltip
                updateTooltip(this, touch.pageX, touch.pageY);
            },

            touchSelectMove: function touchSelectMove(touch) {
                //Detach the browser's default touches so we can perform our own touches.
                this.restoreDefaultTouches(false);

                //Update the tooltip as we move.
                updateTooltip(this, touch.pageX, touch.pageY);
            },

            touchTap: function touchTap(touch) {
                //Detach the browser's default touches so we can perform our own touches.
                this.restoreDefaultTouches(false);

                applySelectionChange.call(this, touch);
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.android.Popup",
                         "mstrmojo.array",
                         "mstrmojo.android.TextArea",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.ui.Button",
                         "mstrmojo.dom",
                         "mstrmojo.css",
                         "mstrmojo.hash");

    mstrmojo.requiresDescs(1442);

    var $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom,
        $ARR = mstrmojo.array,
        $HASH = mstrmojo.hash;

    /**
     * A generic dialog for the Android mobile platform.
     *
     * @class
     * @extends mstrmojo.android.Popup
     */
    var $DIALOG = mstrmojo.android.Dialog = mstrmojo.declare(

        mstrmojo.android.Popup,

        [ mstrmojo._TouchGestures ],

        /**
         * @lends mstrmojo.android.Dialog.prototype
         */
        {
            scriptClass: "mstrmojo.android.Dialog",

            autoClose: false,

            /**
             * Indicates whether the dialog buttons should be visible.
             *
             * @type Boolean 
             * @default true
             */
            btnVisible: true,

            init: function init(props) {
                this._super(props);

                var css = [ 'dialog' ];

                if (this.title) {
                    css.push('has-ttl');
                }

                // Is this dialog anchored?
                if (props.anchor) {
                    // TQMS #719668: Add a curtain position so the dialog will not overlap the title bar.
                    this.curtainPosition = mstrApp.getContentPosition();
                }

                $CSS.addWidgetCssClass(this, css);
            },

            /**
             * Add default click handler to all buttons to call close method.
             *
             * @ignore
             */
            preBuildRendering: function preBuildRendering() {
                // Do we have buttons AND do we not already have a button box (TQMS #687264)?
                var buttons = this.buttons;
                if (buttons && !this.btnHbox) {

                    // Create default click handler.
                    var ths = this,
                        id = this.id,
                        fn = function () {
                            // Does this button NOT close the editor itself?
                            if (!ths.manualClose) {
                                // Close the editor.
                                window.setTimeout(function () { //#528431
                                    var dialog = mstrmojo.all[id];
                                    if (dialog) {
                                        dialog.close();
                                    }
                                }, 50);
                            }
                        };

                    // Iterate buttons.
                    $ARR.forEach(buttons, function (btn) {
                        // Store current click function in expando property.
                        btn.origFn = btn.onclick;

                        // Set new click handler.
                        btn.onclick = function (event) {
                            // Does this button have an original click handler?
                            if (this.origFn) {
                                // Call it, and test the result.  Does it return EXACTLY false?
                                if (this.origFn() === false) {
                                    // Exit without closing dialog.
                                    return;
                                }
                            }

                            // Call common close function.
                            fn();

                            //TQMS 513045 Prevent event propagating
                            event.e.stopPropagation();
                            event.e.cancelBubble = true;
                        };
                    });
                }

                this._super();
            },

            postBuildRendering: function postBuildRendering() {
                // Do we have an onTitleClick handler?
                if (this.onTitleClick) {
                    // Attach event listener to hear when title node is clicked.
                    var id = this.id;
                    $DOM.attachEvent(this.titleNode, 'click', function (evt) {
                        mstrmojo.all[id].onTitleClick(evt);
                    });
                }

                return this._super();
            },

            // overwritten method for #659420 only refresh is the workaround for Samsung Galaxy SIII phone for page by dialogs
            getResizeHandler: function getResizeHandler() {
                var id = this.id,
                    fn = function () {
                        var dialog = mstrmojo.all[id];
                        if (dialog.dialogRefresh) {
                            dialog.dialogRefresh();
                        } else {
                            dialog.resizeDialog();
                            dialog.positionDialog();
                        }
                    };

                return fn;
            },

            resizeDialog: function resizeDialog() {
                this._super();

                // Do we have buttons?
                var buttonCnt = this.buttons && this.buttons.length;
                if (buttonCnt) {
                    // Are buttons hidden?
                    var buttonNode = this.buttonNode,
                        btnVisible = this.btnVisible;

                    // Are the buttons currently hidden?
                    if (!btnVisible) {
                        // Make sure they are visible so we can measure them.
                        this.set('btnVisible', true);
                    }

                    // Get computed styles for both slot and first button.
                    var btns = this.btnHbox.children,
                        $CS = $CSS.getComputedStyle,
                        slotStyle = $CS(buttonNode),
                        btnStyle = $CS(btns[0].domNode);

                    // Calculate available width for buttons, amount of button devoted to padding and border, and amount of space available for button content width.
                    var availWidth = buttonNode.clientWidth - parseInt(slotStyle.paddingLeft, 10) - parseInt(slotStyle.paddingRight, 10),
                        btnOffset = parseInt(btnStyle.paddingLeft, 10) + parseInt(btnStyle.paddingRight, 10) + parseInt(btnStyle.borderLeftWidth, 10) + parseInt(btnStyle.borderRightWidth, 10),
                        btnSpace = availWidth - (buttonCnt * btnOffset);

                    // Calculate actual button content width.
                    var buttonWidth = Math.floor(btnSpace / buttonCnt);

                    // Iterate buttons...
                    $ARR.forEach(btns, function (btn) {
                        // and assign width.
                        btn.set('width', buttonWidth + 'px');
                    });

                    // Restore button visible value.
                    this.set('btnVisible', btnVisible);
                }
            },

            /**
             * Function to resize the curtain when the editor is attached to body.
             * @param {HTMLElement} w the dialog widget.
             */
            resizeCurtain: function resizeCurtain() {
                var curtainNode = this.curtainNode,
                    body = document.body,
                    cs = curtainNode.style,
                    curtainPosition = this.curtainPosition;

                // Set width and height.
                cs.width = body.scrollWidth + 'px';
                
                if (curtainPosition && curtainPosition.h) {
                	cs.height = curtainPosition.h + 'px';
                } else {
                	// TQMS #716699 use scrollHeight for height of curtain to handle the case where clientHeight has
                	//				been changed due to the Android soft keyboard being displayed.
                	cs.height = body.scrollHeight + 'px';
                }
                
                if (curtainPosition && curtainPosition.y) {
                	cs.top = curtainPosition.y + 'px';
                }
                
                this.raiseEvent({name: 'resizeCurtain'});
            },
            
            setButtonVisibility: function setButtonVisibility(isVisible) {
                this.buttonNode.style.display = isVisible ? 'block' : 'none';
            },

            createTitleBarButton: function createTitleBarButton(className, fn, title) {
                var bl = document.createElement('div');
                bl.className = className;
                bl.setAttribute('title', title || '');
                //TQMS 556535. We shall use ontouchend for touch devices.
                bl[(mstrApp.isTouchApp()) ? 'ontouchend' : 'onclick'] = fn;

                this.titleNode.appendChild(bl);
            }
        }
    );

    // Add btnVisible markup method.
    var markupMethods = $HASH.copy($DIALOG.prototype.markupMethods);
    markupMethods.onbtnVisibleChange = function () {
        this.buttonNode.style.display = (this.btnVisible) ? 'block' : 'none';
    };
    $DIALOG.prototype.markupMethods = markupMethods;

    // Do we need to override config and alert with complex dialogs?
    if (window.mstrConfig && !window.mstrConfig.simpleDialog) {

        var fnGetLabelChild = function (msg) {
            return [{
                scriptClass: 'mstrmojo.android.TextArea',
                text: msg,
                cssClass : 'mstrmojo-androidAlert',
                isElastic: true
            }];
        };

        /**
         * Overrides default {@link mstrmojo.config} method to use mstrmojo.Dialog for displaying a message to the user with a single 'Ok' button.
         *
         * @param {String} msg The message to display.
         * @param {Function} [fn] An optional function to be executed after the 'Ok' button is clicked.
         * @param {String} [title="MicroStrategy Web"] An optional title for the dialog.
         *
         * @memberOf mstrmojo
         * @overrides
         */
        mstrmojo.alert = function alrt(msg, fn, title) {
            mstrApp.showDialog({

                title: title || "MicroStrategy Mobile",
                buttons: [ mstrmojo.android.ui.Button.newButton(mstrmojo.desc(1442, 'OK'), function () {
                    if (fn) {
                        fn();
                    }
                })],
                children: fnGetLabelChild(msg)
            });

        };

        /**
         * Overrides default {@link mstrmojo.config} method to use mstrmojo.Dialog for displaying a message to the user with configurable buttons.
         *
         * @param {String} msg The message to display.
         * @param {Object[]|mstrmojo.Button[]} buttons An array of type {@link mstrmojo.Button} or an array of configuration objects that will become {@link mstrmojo.Button} when inserted.
         * @param {String} [title="MicroStrategy Web"] An optional title for the dialog.
         *
         * @memberOf mstrmojo
         * @overrides
         */
        mstrmojo.confirm = function confirm(msg, buttons, title) {
            // Show the dialog.
            mstrApp.showDialog({
                title: title || 'MicroStrategy Mobile',
                buttons: buttons,
                children: fnGetLabelChild(msg)
            });
        };

        /**
         * Overrides default {@link mstrmojo.toast) method to show a toast notification to the screen.
         */
        mstrmojo.toast = function toast(msg, duration) {
            mstrApp.showToastNotification(msg, duration || 3500);
        };

        /**
         * Overrides default mask showing hiding methods
         */
        mstrmojo.mask = {
            show: function show(msg) {
                mstrMobileApp.showProgress([ msg || ''], false );
            },

            hide: function hide() {
                mstrMobileApp.hideProgress();
            }
        };
    }
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.string",
                         "mstrmojo._HasPopup",
                         "mstrmojo.ListBase",
                         "mstrmojo.Editor",
                         "mstrmojo.SuggestionList");

    /**
     * Steps the suggestion popup one item in the indicated direction.
     *
     * @param {Boolean} isForward Whether the list should be incremented or decremented.
     * @private
     */
    function stepSelect(isForward) {
        var list = this.list,
            idx = list.selectedIndex,
            len = list.items.length,
            clearTarget = (isForward) ? len - 1 : 0;

        if (idx === clearTarget) {
            list.clearSelect();
            return;
        }

        if (idx === null || idx < 0) {
            idx = (isForward) ? 0 : len - 1;
        } else {
            idx += (isForward) ? 1 : -1;
        }

        list.singleSelect(idx);
    }

    /**
     * This mixin class provides common functions related to search suggestion.
     *
     */
    mstrmojo._HasSuggestion = mstrmojo.provide(
        "mstrmojo._HasSuggestion",

        mstrmojo.hash.copy(mstrmojo._HasPopup, {
            blockBegin: 1,

            blockCount: -1,

            /**
             * The maximum number of suggestion items to show at one time.
             */
            suggestCount: 15,

            autoSelect: true,

            /**
             * The display field of suggestion items.
             */
            itemField: 'n',

            /**
             * A set of candidates for suggestion.
             */
            candidates: null,

            /**
             * Whether the suggestion is shown or not.
             */
            suggestionShown: false,

            /**
             * The list of suggestion items to display.
             */
            suggestionItems: null,

            /**
             * Caching last hit for performance purpose.
             */
            _last_hit: null,

            /**
             * The search pattern used by the requesting call for suggestion candidates.
             */
            _request_pattern: null,

            /**
             * Whether to shown a browse... item at the end of the suggestion. If this is set to true, usually we need to also set
             * folderLinksContextId and browsableTypes to be proper values.
             */
            browseItemVisible: false,

            /**
             * Folder context for the object browser.
             */
            folderLinksContextId: 25,

            /**
             * List of object types exposed by object browser, separated by comma.
             */
            browsableTypes: '1,8',


            /**
             * The threshold to trigger a call to server side to retrieve more candidates.
             */
            REQUEST_THRESHOLD: 20,

            noCache: false,

            /**
             * Override this method to make task calls to server to return the list of suggestion candidates
             * based on parameters(pattern: t, blockBegin: 1, blockCount: -1, isSuggest: true).
             *
             * @param {Object} params An object with call parameters (pattern: t, blockBegin: 1, blockCount: -1, isSuggest: true).
             * @param {Object} callbacks An object with request callbacks.
             *
             */
            getCandidatesThroughTaskCall: mstrmojo.emptyFn,

            /**
             * Call back to implement when a suggestion item is selected by mouse click or keyboard(ENTER or TAB).
             * The default behavior is to close the suggestion. Customization implementation shall try to do
             * something before closing the suggestion.
             */
            onSuggestionItemSelect: function onSuggestionItemSelect(item) {
                this.hideSuggestion();
            },

            /**
             * Override to return the name pattern for search.
             */
            getSearchPattern: function getSearchPattern() {
                return '';
            },

            /**
             * Override to return the position where the suggestion popup will show up.  The position shall be an object, with values for left and
             * top coordinate, for example, {'left': '100px', 'top': '100px'}.
             */
            getSuggestionPos: function getSuggestionPos() {
                return {
                    left: '100px',
                    top: '100px'
                };
            },

            /**
             * Return the target of the suggestion. By default, it is the widget itself. However, for some widget, ObjectInputBox for example,
             * the target could be dynamically changed.
             */
            getSuggestionTarget: function getSuggestionTarget() {
                return this;
            },

            
            /**
             * This is the method to call when the widget needs to pop up a suggestion based on certain name pattern.
             */
            showSuggestion: function showSuggestion(pattern) {
                var its = this.getSuggestion(pattern);

                //when it needs to request from server, return value above will be -1 so we do not updateSuggestion here because the request callback will do it
                if (!this.noCache && its !== -1) {
                    this.updateSuggestion(its);
                }
            },

            /**
             * This is the method to call when the widget needs to close the suggestion.
             */
            hideSuggestion: function hideSuggestion() {
                this.suggestionShown = false;
                if (this.suggestionPopup.visible) {
                    this.suggestionPopup.close();
                }
            },

            /**
             * This is the method to call to get the selected suggestion item.
             */
            getSelected: function getSelected() {
                return (this.suggestionShown) ? this._lastOpened.getSelected() : null;
            },

            /**
             * This is the method to call to move the suggestion highlight to next item.
             */
            nextHighlight: function nextHighlight() {
                if (this.suggestionShown) {
                    this._lastOpened.nextHighlight();
                }
            },

            /**
             * This is the method to call to move the suggestion highlight to previous item.
             */
            preHighlight: function preHighlight() {
                if (this.suggestionShown) {
                    this._lastOpened.preHighlight();
                }
            },


            /**
             * Return all suggestion based on the pattern (which is what user types). The default implementation is to return the
             * first n candidates that meet pattern (n = suggestCount).
             *
             * This method shall be overrode if this default implementation is not desirable for specific scenario.
             */
            getSuggestion: function getSuggestion(t) {
                var c = this.candidates,
                    its = c && c.items,
                    ic = c && c.isComplete,
                    lh = this._last_hit;

                if (!this.noCache && (c || lh)) {
                    var fcs = this.filterCandidates(its, t, this.REQUEST_THRESHOLD),
                        len = fcs.length,
                        sc = this.suggestCount,
                        hit = false;

                    //add items from last hit
                    if (!ic && len < sc) {
                        var p = lh && lh.pattern;
                        if (lh && p && (t.indexOf(p) > -1)) {
                            hit = true;
                            var lhc = this.filterCandidates(lh.items, t, this.REQUEST_THRESHOLD),
                                llen = lhc && lhc.length,
                                A = mstrmojo.array,
                                ifd = this.itemField,
                                i;

                            for (i = 0; i < llen; i++) {
                                if (A.find(fcs, ifd, lhc[i][ifd]) === -1) {
                                    fcs.push(lhc[i]);
                                }
                            }

                            len = fcs.length;
                        }
                    }


                    //shall make new request if 1) the number of character is 3 or more but the suggestion is not greater than REQUEST_THRESHOLD;
                    // 2) if the suggestion is smaller than suggestCount
                    if (!ic && ((t.length > 2 && len < this.REQUEST_THRESHOLD) || (len < sc))) {
                        this.requestCandidates(t);
                        
                        return -1;//special flag indicating not to update suggestion through updateSuggestion()
                    }

                    return (len < sc) ? fcs : fcs.slice(0, sc);
                }



                //no candidates, make a request for them, and return null
                this.requestCandidates(t);
                return -1;  //special flag indicating not to update suggestion through updateSuggestion()
            },

            requestCandidates: function requestCandidates(t) {
                this._request_pattern = t;

                var me = this,
                    targetWas = this.getSuggestionTarget(),
                    callbacks = {
                        success: function (res) {
                            if (!res) {
                                return;
                            }

                            var target = me.getSuggestionTarget();
                            if (!target || (targetWas !== target)) { //no target or target changed, do not use it
                                return;
                            }

                            var newPattern = target.getSearchPattern(),
                                its = res.items;

                            me._last_hit = {
                                items: its,
                                pattern: t
                            };
                            me.sz = res.sz;

                            //#716639- concat with cached candidates to get complete list of matched items
                            //#717985 - append to candidates if cache is enabled
                            if (!me.noCache && its) {
                                var c = me.candidates && me.candidates.items|| [],
                                    _its = [].concat(its); //make a copy to help manipulation
                                for (var i = 0, len = its.length; i < len; i ++) {
                                    var it = _its[i];

                                    if (mstrmojo.array.indexOf(c, it) > -1) {
                                        mstrmojo.array.removeItem(its, it);
                                    }
                                }
                                
                                if (me.candidates) {
                                    me.candidates.items = c.concat(its);
                                }
                            }

                            if (newPattern && newPattern.indexOf(t) > -1) {
                                var fcs = me.filterCandidates(its, newPattern);
                                me.updateSuggestion(fcs);
                            }
                        },

                        failure: function (res) {
                            mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
                        }
                    };

                this.getCandidatesThroughTaskCall({
                    pattern: t,
                    blockBegin: this.blockBegin,
                    blockCount: this.blockCount,
                    isSuggest: true
                }, callbacks);
            },


            filterCandidates: function filterCandidates(its, t, max) {
                max = max || this.suggestCount;
                t = mstrmojo.string.regEscape(t);

                var itf = this.itemField,
                    fcs = mstrmojo.array.filter(its, function (it) {
                        return (new RegExp('\\s' + t + '|^' + t, 'i')).test(it[itf]);
                    }, {
                        max: max
                    });

                return fcs;
            },
            
            getHighlightedText: function getHighlightedText(pattern, n) {
                if (!this.highlightPattern || mstrmojo.string.isEmpty(pattern)) {
                    return n;
                }

                try {
                    if (!this.nameWildcards || mstr.$A.find([2, 32], parseInt(this.nameWildcards, 10)) > -1) { //default: 2, Exactly - 2, Begin With Phrase - 32
                        n = n.replace(new RegExp('(^|\\s)('+ pattern + ')', 'gi'), '$1<b>' + '$2' + '</b>');
                    } else {
                        var words = pattern.split(' '),
                            i,
                            len;

                        for (i = 0, len = words.length; i < len; i++) {
                            if (words[i] !== '') { // 587815 should not try to highlight when empty string is encountered
                                n = n.replace(new RegExp('(' + words[i] + ')', 'gi'), '<b>' + '$1' + '</b>');
                            }
                        }
                    }
                } catch (e) {} // #588436 ignore regular expression error

                return n;
            },

            updateSuggestion: function updateSuggestion(items) {
                var len = items && items.length,
                    canBrowseItems = this.browseItemVisible;

                if (len || canBrowseItems) {
                    if (canBrowseItems) {
                        items = items || [];
                        items.push({
                            n: 'Browse...',
                            t: -99,
                            cssClass: ((len) ? 'br' : 'bro')
                        });
                    }

                    // Update suggested items.
                    this.set('suggestionItems', items);

                    // Are suggestions already shown?
                    if (this.suggestionShown) {
                        // Can we nudge the popup?
                        var popup = this._lastOpened;
                        if (popup && popup.nudge) {
                            popup.nudge();
                        }

                    } else {
                        this.openPopup('suggestionPopup', this.getSuggestionPos());
                        this.suggestionShown = true;
                    }

                } else {
                    this.hideSuggestion();

                }
            },

            ob: {
                scriptClass: "mstrmojo.Editor",
                title: mstrmojo.desc(5298, "Select an Object"),
                help: "Select_Objects_dialog_box_.htm",
                onClose: function () {
                    var o = this.opener;
                    if (o && o.onBrowserClose) {
                        o.onBrowserClose();
                    }
                },
                onOpen: function () {
                    var o = this.opener;
                    if (o && o.onBrowserOpen) {
                        o.onBrowserOpen();
                    }
                },
                children: [{
                    scriptClass : "mstrmojo.ObjectBrowser",
                    alias: "browser",
                    cssText: "width:200px;",
                    fishEyeVisible: false,
                    closeable: false,
                    closeOnSelect: false
                }]
            },

            onBrowserClose: function onBrowserClose() {
                this.browserShown = false;
            },

            handleSuggestionItemSelect: function handleSuggestionItemSelect(it) {
                // Is browsing allowed and is this the browsing item?
                if (this.browseItemVisible && it.t === -99) {
                    // Make sure suggestions are closed.
                    this.hideSuggestion();

                    // TQMS #573388: Load ObjectBrowser dynamically so it's not included in OIVM JavaScript bundle.
                    mstrmojo.requiresCls("mstrmojo.ObjectBrowser");

                    // Open object browser popup.
                    var zIndex = this.zIndex;
                    this.openPopup('ob', {
                        zIndex: (zIndex && (zIndex + 10)) || 110
                    });

                    // Tell object browser what to browse.
                    this.ob.browser.browse({
                        folderLinksContextId : this.folderLinksContextId,
                        onSelectCB: [this, 'onSuggestionItemSelect'],
                        browsableTypes: this.browsableTypes
                    });

                    this.browserShown = true;

                } else {
                    this.onSuggestionItemSelect(it);
                }
            },

            /**
             * Highlight the searchPattern string in given suggestion item text
             * @param pattern {String} pattern Text to highlight
             * @param n {String} Suggestion item name text
             */
            highlightPattern: true,

            suggestionPopup: {
                scriptClass: 'mstrmojo.Editor',
                cssClass: 'mstrmojo-ObjectInputBox-suggest',
                showTitle: false,
                modal: false,
                autoClose: true,
                nextHighlight: function () {
                    stepSelect.call(this, true);
                },

                preHighlight: function () {
                    stepSelect.call(this, false);
                },

                getSelected: function getSelected() {
                    var list = this.list;
                    return list.items[list.selectedIndex];
                },

                onOpen: function onOpen() {
                    var o = this.opener;
                    if (o && o.autoSelect) {
                        this.list.singleSelect(0);
                    }
                },

                onClose: function onClose() {
                    this.list.clearSelect();
                    if (this.opener) {
                        this.opener.suggestionShown = false;
                    }
                }
            },

            /**
             * The name of the class to be used by the suggestion popup for displaying the suggestion list.
             *
             * @type String
             * @default mstrmojo.SuggestionList
             */
            suggestionListClass: 'mstrmojo.SuggestionList',

            postApplyProperties: function postApplyProperties() {
                this.suggestionPopup.children = [{
                    scriptClass: this.suggestionListClass,
                    alias: 'list',
                    cssClass: 'mstrmojo-suggest-list'
                }];
            }
        })
    );
}());
(function() {
    
    mstrmojo.requiresCls("mstrmojo.Magnifier",
    					 "mstrmojo.hash");
    
    var SELECTED_CELL_CSS = 'xtab-selected-cell';

    /**
     * _HasMagnifier mixin
     */
    mstrmojo._HasMagnifier = {
            
        scriptClass: 'mstrmojo._HasMagnifier',
        
        magnifiedNode: null,
        
        magnifier: null,

        /**
         * In order to use magnifier feature, you need to specific a helper to be responsible for creating contents, handle events
         * Please refer to mstrmojo.XtabMagnifierHelper for the interfaces required. 
         */
        magnifierHelper: null,
        
        onmagnifiedNodeChange: function(evt){
            var oldNd = evt.valueWas,
                newNd = evt.value;
            
            if (oldNd){
                mstrmojo.css.removeClass(oldNd, SELECTED_CELL_CSS);
            }
            if (newNd){
                mstrmojo.css.addClass(newNd, SELECTED_CELL_CSS);
            }
        },
        
        displayMagnifier: function dspMgnf(touch, config) {
            var helper = this.magnifierHelper,
                touchObj = helper.resolveTouchEvent(touch), 
                info, anchor, anchorPos;
            
            // If we've tapped a valid domNode(i.e. a cell on xtab)
            if (touchObj){
                anchor = touchObj.cell;
                anchorPos = touchObj.pos;
                
                // the magnified node is changed
                if (anchor != this.magnifiedNode){
                    // resolve the information for the touch 
                    info = helper.resolveInfoToDisplay(touchObj);
                
                    // if information could be resolved
                    if (info){
                        this.set('magnifiedNode', anchor);
                        
                        // create a magnifier if not existed
                        if (!this.magnifier){
                            var me = this;
                            this.magnifier = mstrApp.showPopup(
                            	mstrmojo.hash.copy({
	                                scriptClass: 'mstrmojo.Magnifier',
	                                onClose: function(){
	                                    me.magnifier = null;
	                                    me.set('magnifiedNode', null);
	                                },
	                                helper: helper
                            	}, config), anchor
                            );
                        }
                        
                        // populate its content and update its appearance
                        this.magnifier.updateContent();
                        this.magnifier.resizeAndPosition(anchorPos);
                    }else {
                        // the cell doesn't have related info, close the magnifier
                        if (this.magnifier){
                            this.magnifier.close();
                        }
                    }
                }else {
                    // move the magnifier if existed
                    if (this.magnifier){
                        this.magnifier.moveTo(anchorPos);
                    }
                }
            }
        }
    };
})();
(function() {

	var prevWidth,
		prevHeight;

	mstrmojo.requiresCls("mstrmojo.Container", "mstrmojo.DocPortlet");

	var FMTS = {'top':'top',
	            'left':'left',
	            'z-index':'zIndex',
	            'width':'width',
	            'height':'height'};

    /**
     * A visualization control
     * @class
     * @extends mstrmojo.Widget
     */
    mstrmojo.Vis = mstrmojo.declare(

        // superclass
        mstrmojo.Container,

        // mixins
        [mstrmojo._HasLayout],

        /**
         * @lends mstrmojo.Vis.prototype
         */
        {
            /**
             * @ignore
             */
            scriptClass: 'mstrmojo.Vis',

            offsetTop:0,

            offsetLeft:0,

            isAndroid: window.navigator.userAgent.indexOf('Android') != -1,

            updated: false,

            reRenderOnDimensionChg: true,

            getFormats: function() {
                // this is called when rendering a document on Express Mode
                return this.fmts;
            },

            isVis: function() {
            	return true;
            },

            setModel: function setModel(model) {

            	this.set('model', model);

            	// this is called in android
                if (model.data) {
                    this.set('model', model.data);
                }
            	this.xtabModel = model;

                    // Make request for page by data.
            	if (typeof (this.controller.getPageByTree) != 'undefined') {

                    this.controller.getPageByTree(false);
                }
            },

            destroy: function destroy() {
            	this._super();

            	var xtab = this.xtabModel;
            	if (xtab && xtab.destroy) {
            		xtab.destroy();
            		//delete this.xtabModel, as to remove the circular reference
            		delete this.xtabModel;
            	}

            },

            setDimensions: function setDimensions(h, w) {
            	var dimensionChanged = this._super(h, w);
            	if (dimensionChanged && this.hasRendered && this.reRenderOnDimensionChg ) {
            		this.reRender();
            	}
            	return dimensionChanged;
            },

            reRender: function reRender() {
            	this.unrender();
            	this.render();
            },

            getWidth: function getWidth() {
            	return parseInt(this.width, 10); // remove the px if present
            },

            getHeight: function getHeight() {
            	return parseInt(this.height, 10); // remove the px if present
            },

//            preBuildRendering: function preBR(){
//            	/*
//            	 * To fix the title bar issue:
//            	 * in createPortlet, it will update the fmts info by reduce the title bar height and move the left and top value.
//            	 * So we need to update it from fmts.
//            	 * When the vis is in full screen mode, the height and width is set to vis instead of set in fmts.
//            	 * In order not to overwrite the height and width when fullScreen, we only update from fmts if the dimension is undefined or 'auto'
//            	 */
//
//            	var fmts = this.fmts;
//            	if(fmts){
//            		for(var k in FMTS){
//                    	v = FMTS[k];
//                    	if(k in fmts && (!this[v] || this[v] == 'auto')){
//                    		this[v] = fmts[k];
//                    	}
//                    }
//            	}
//            	// do not need this as the DocPorlet will remove this info
////				if (this.parent instanceof mstrmojo.DocPortlet) { // In this case, the offset is handled by its parent
////				delete this.left;
////				delete this.top;
////			}
//                if(this._super){
//                    this._super();
//                }
//            },

            buildRendering: function bldRn() {

            	if (!this.updated) {
            		this.update();
            	}

                // do not need this as the DocPorlet will remove this info
                if (this.parent instanceof mstrmojo.DocPortlet) { // In this case, the offset is handled by its parent
                    delete this.left;
                    delete this.top;
                    this.height = this.fmts && this.fmts.height;
                }

            	// Call the inherited method to do the DOM construction.
            	this._super();
            },

            postBuildRendering: function postBR(){
            	prevWidth = this.width;
            	prevHeight = this.height;

            	this.adjustWidgetOffsets();

            	//call super to have children rendered
            	this._super();
            },

            adjustWidgetOffsets: function adjustWidgetOffsets() {
            	var dn = this.domNode,
            	offset = {
            			top: 0,
            			left: 0
            	};

            	if (typeof(mstr) != 'undefined') {
            		offset.top = mstr.utils.BoxModel.getElementSumOffsetTop(dn);
            		offset.left = mstr.utils.BoxModel.getElementSumOffsetLeft(dn);
            	} else if (typeof(mstrmojo) != 'undefined') {
            		offset = mstrmojo.boxmodel.offset(dn);
            	}

            	this.offsetTop = offset.top;
            	this.offsetLeft = offset.left;
            },

        	/**
			 * This function will read the properties defined in vis properties editor and than
			 * set the properties accordingly
			 */
			initFromVisProps: function initFromVisProps(vp) {},

            update: function update(node) {
                node = node || this.node;
                if (node) { // called from docs
                	if (node.data) {
                	    this.set('model', node.data);
						//TQMS:702824 ,since during partial update the tks is not sent, we will use the 'cgb' to retrieve
						//tks and update the grid json otherwise , the selections wont work in express mode
						if(this.xtabModel && this.xtabModel.set){
							this.xtabModel.set('data',node.data);
						}
                		this.model = node.data;
                		if (this.model.layoutModel) this.layoutModel = this.model.layoutModel;
                		if (this.model.layoutNode) this.layoutNode = this.model.layoutNode;

                        // Pull extra properties from extProps to the root class level.
                        mstrmojo.hash.copy(node.data.extProps, this);
                	}

            	 	this.fmts = node.defn.fmts || node.defn.units[this.model.k].fmts;

                    var fmts = this.fmts;
                    if(fmts){
                        for(var k in FMTS){
                            v = FMTS[k];
                            if(k in fmts){
                                this[v] = fmts[k];
                            }
                        }
                    }
                }

                if (this.model) {
                    this.initFromVisProps(this.model.vp);
                }
                this.updated = true;
            },

            getModel: function getModel(k) {
            	if (k) {
            		var m = mstrmojo.Vis.getVisGrid(this.layoutModel, this.layoutNode, k);
            		if (m) {
            			return m.data;
            		} else {
            			alert(mstrmojo.desc(8427,"Incorrect visualization properties encountered.  Data may be inconsistent.  Please reset your properties."));
            		}
            	} else {
            		return this.model;
            	}
            },

            getDataParser: function getDataParser(key) {
            	return new mstrmojo.Vis.DataParser(this.getModel(key));
            },

            /**
             * Renders an error message replacing the entire DOM node
             */
            renderErrorMessage: function renderErrorMessage(msg) {
            	this.domNode.innerHTML = "<div class=\"mstrmojo-message\">" + msg + "</div>";
            },

            getMessageID: function getMessageID() {
                return this.model.mid && this.model.mid || this.xtabModel && this.xtabModel.docModel && this.xtabModel.docModel.mid;
            },

            /*
             * Return whether we have selection target that are not info window
             * Used to decide whether we clear the highlight when the info window is closed
             */
            hasNoninfowindowTarget: function hasNoninfowindowTarget(actionObj) {
            	var xtabModel = this.xtabModel,
		    		docModel = (xtabModel && xtabModel.docModel);

            	var result = false;
				if (docModel) {
					var layouts = docModel.defn && docModel.defn.layouts,
						layout = null;
					var i;
					// for document which has multiple layouts
					if (layouts) {
						for(i in layouts) {
							if (layouts[i].loaded) {
								layout = layouts[i];
								break;
							}
						}
					}

					var units = layout && layout.units;
					this.selectorTargets = {};
					if (units && actionObj.scObjList) {
						for(var i = 0; i < actionObj.scObjList.length; i++){
		        			var scObj = actionObj.scObjList[i];
		        			/*
		        			 * The targets is
		        			 */

		        			var tksList = scObj.sc.tks.split("\x1E");
		        			for(var j = 0; j < tksList.length; j++){
		        				var unit = units[tksList[j]];
		        				if (unit) {
		        					this.selectorTargets[tksList[j]] = unit;
		        					if (!this.isChildOfIfw(units, unit)) {
		        						result = true;
		        					}
		        				}
		        			}
		        		}
					}
				}

				return result;
            },

            isChildOfIfw: function isChildOfIfw(units, unit){
            	while(unit){
            		if(unit.ifw){
            			return true;
            		}
                	unit = units[unit.pnk];
            	}
            	return false;
            },

            performAction: function performAction(actionObj){
            	var action = this.xtabModel.getAction(actionObj),
            		handler = action && action.h;
            	if(handler && this.controller[handler]){
            		this.controller[handler](this, action.a);
            		return true;
            	}
            	return false;
			}
        }
    );

    // find the visualization grid
    mstrmojo.Vis.getVisGrid = function(m /*model*/, n /*node*/, k /*key*/) {
    	var origN = n;
    	var chldn = m.getChildren(n, false);
    	for (var i=0; i < chldn.length; i++) {
    		var c = chldn[i];
    		if (c.k == k) {
    			return c;
    		} else {
    			var g = mstrmojo.Vis.getVisGrid(m, c, k);
    			if (g) {
    				n = origN; // repoint to original object
    				return g;
    			}
    		}
    	}
    };

    mstrmojo.Vis.DataParser = function (m /*model*/) {
    	var ns = mstrmojo.Vis;

            	return {
            		getRowTitles: function() {
	            		return new ns.Titles(m, true);
	            	},

            		getColTitles: function() {
	            		return new ns.Titles(m, false);
	            	},

	            	findMetricValue: function(rvIdx /* an array with the row value indices*/, c /* col value index*/) {
	            		var rhs = m.ghs.rhs.items;
	            		for (var e in rhs) {
	            			var row = rhs[e].items;
	            			var found = true;
	            			for (var i in rvIdx) {
	            				if (rvIdx[i] != row[i].idx) {found = false; break;}
	            			}
	            			if (found) {
	            				return new mstrmojo.Vis.MetricValue(m.gvs.items[e].items[c]);
	            			}
	            		}
	            	},

	            	getTotalRows: function getTotalRows() {
	            		return m.eg ? 0 : m.ghs.rhs.items.length;
	            	},

            getTotalColHeaderRows : function getTotalColHeaderRows(){
                return (!m.ghs.chs.items ? 0: m.ghs.chs.items.length);
            },

        	getTotalCols: function getTotalCols() {
        		return this.getColHeaders(0).size();
        	},

        	getRowHeaders: function getRowHeaders(pos /*position*/) {
        		return new ns.Headers(m, pos, true);
        	},

        	getColHeaders: function getColHeaders(pos /*position*/) {
        		return new ns.Headers(m, pos, false);
        	},

        	getMetricValue: function getMetricValue(row, col) {
                return new ns.MetricValue(m, m.gvs.items[row].items[col]);
            },

            getColumnHeaderCount : function getColumnHeaderCount(){
                return m.gvs.items[0].items.length;
            },

            getCSSString : function getCSSString()
            {
                return m.cssString;
            }


    	};
    };

    mstrmojo.Vis.Titles = function (m, isRow) {
    	var t = (isRow) ? m.gts.row : m.gts.col;
    	return {
    		size: function size() {return t.length;},
            getTitle: function getTitle(pos) {return new mstrmojo.Vis.Title(t[pos]);},
            getCSS : function getCSS(pos) {return m.css[t[pos].cni].n;}
    	};
    };

    mstrmojo.Vis.Headers = function (m /*Model*/, i /*position*/, isRow /*row or column*/) {
    	var t = (isRow) ? m.gts.row : m.gts.col;
    	var hs = (isRow) ? m.ghs.rhs : m.ghs.chs;
    	var h = hs.items && hs.items[i].items;

    	return {
    		size: function size() {return (!h ? 0: h.length);},
    		getHeader: function getHeader(pos) {
                return h && h[pos] && new mstrmojo.Vis.Header(h[pos], isRow ? t[pos] : t[i]);
            },
            getCSS : function getCSS(pos) {
                return h && m.css[h[pos].cni].n;
            },
            getHeaderCell : function(pos)
            {
                return h && h[pos];
            }

    	};
    };

    mstrmojo.Vis.Title = function (t /*Title JSON */) {
    	return {
    		/**
    		 * Bitwise value that represents the the action type.
    		 * Its possible values are:
    		 * - STATIC (0)
    		 * - DRILLING (0x1)
    		 * - SELECTOR_CONTROL (0x2)
    		 * - HYPERLINK (0x4)
    		 * - SORT (0x8)
    		 * - PIVOT (0x10)
    		 * - EDIT (0x20)
    		 */
    		getActionType: function() {return t.at;},
    		/**
    		 * An Object that represents the Drill Paths
    		 */
    		getDrillPath: function() {return t.dp;},
    		getHeaderValues: function getHeaderValues() {return t.es;},
    		getHeaderName: function getHeaderValue(pos) {return t.es[pos].n;},
    		getHeaderId: function getHeaderValue(pos) {return t.es[pos].id;},
    		getForms: function getForms() {return t.fs;},
    		getFormId: function() {return t.fid;},
    		getFormType: function() {return t.ftp;},
    		getUnitId: function() {return t.id;},
    		/**
    		 * A Map that represents the Links defined for Link Drilling
    		 */
    		getLinkMap: function() {return t.lm;},
    		getName: function() {return t.n;},
            getUnitDssType: function() {return t.otp;},
            getSelectorControl : function() {return t.sc;}
    	};
    };

    mstrmojo.Vis.Header = function (h /*Header JSON */, t /*Title JSON*/) {
    	return {
    		getName: function getName() {
                return (h.idx === -1) ? "" :t.es[h.idx].n;
            },
            getElementId : function getElementId(){
                return (h.idx === -1) ? "" : t.es[h.idx].id;
            },
            getObjectId: function getId() {
                return (h.idx === -1) ? "" : t.es[h.idx].oid;
            },
            getElementIndex : function getElementIndex(){
                return h.idx;
            },
            getActionType : function getActionType(){
                return h.at;
            },
            isTotal : function isTotal(){
               return h.otr === 1;
            }
        };
    };

    mstrmojo.Vis.MetricValue = function (m, jsonObj) {
    	var v = jsonObj;
    	return {
            getValue: function getValue() {return v.v;},
            getThresholdType : function getThresholdType() { return v.ty;},
            getRawValue : function getRawValue() { return v.rv;},
            getCSS : function getCSS() { return m.css[v.cni].n;},
            getThresholdValue : function getThresholdValue(defaultValue)
            {
                if (v.ti == undefined) {
                    return defaultValue;
                }

                return m.th[v.ti].n;
            },
			getFillColor : function getFillColor(defaultValue)
            {
                if (v.ci == undefined) {
                    return defaultValue;
                }

                return m.fc[v.ci].n;
            }
    	};
    };
})();
(function() {
    mstrmojo.requiresCls("mstrmojo.TableLayoutList",
                         "mstrmojo._IsTableLayoutListDIC",
                         "mstrmojo._IsInputControl",
                         "mstrmojo.css");

    /**
     * Radio List input control for the android app
     *
     * @extends mstrmojo.TableLayoutList
     * @borrows mstrmojo._IsTableLayoutListDIC
     * @borrows mstrmojo._IsInputControl
     *
     * @class
     */
    mstrmojo.android.inputControls.RadioListDIC = mstrmojo.declare(
        /**
         * superclass
         */
        mstrmojo.TableLayoutList,
        /**
         * mixins
         */
        [ mstrmojo._IsTableLayoutListDIC, mstrmojo._IsInputControl ],
        /**
         * mstrmojo.android.inputControls.RadioListDIC.prototype
         */
        {
            scriptClass: 'mstrmojo.android.inputControls.RadioListDIC',

            styleCssClass: 'radio',

            init: function (props) {
                this._super(props);
                this.items = this.getItems();
                this.itemsPerRow = this.dic.ipr || 0;
            },

            ontouchend: function (evt) {
                this.onclick(evt);
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                mstrmojo.css.addClass(this.itemsNode || d, 'tx-active');
            }
        }
    );
}());
(function(){
    mstrmojo.requiresCls("mstrmojo._IsInputControl",
                         "mstrmojo.TableLayoutList",
                         "mstrmojo._IsTableLayoutListDIC",
                         "mstrmojo.dom",
                         "mstrmojo.css");

    var $D = mstrmojo.dom,
        $C = mstrmojo.css,
        STYLES_LIST = {
            0: 'default',
            1: 'stars_dots'
        };

    mstrmojo.RatingDIC = mstrmojo.declare(
        /**
         * superclass
         */
        mstrmojo.TableLayoutList,
        /**
         * mixin
         */
        [mstrmojo._IsTableLayoutListDIC, mstrmojo._IsInputControl],
        /**
         * mstrmojo.RatingDIC.prototype
         */
        {
            scriptClass: 'mstrmojo.RatingDIC',

            styleCssClass: 'rate',

            markupString: '<div id="{@id}" class="mstrmojo-ListBase {@cssClass}" style="{@cssText}" mstrAttach:click,mouseover,mouseout>' +
                              '<div class="{@icnCss}" style="{@icnCssText}">{@itemsHtml}</div>' +
                          '</div>',

            lastIdx: null,

            init: function (props) {
                this._super(props);
                this.items = this.getItems();
                this.starCount = this.items && this.items.length;
                $C.addWidgetCssClass(this, STYLES_LIST[this.dic.stl || 0]);
            },

            setRating: function (idx) {
                var i = 0,
                    starCount = this.starCount,
                    leCss = 'less_equal';
                if (this.lastIdx == undefined || this.lastIdx != idx){
                    for (; i < starCount; i++) {
                        if (i <= idx) {
                            $C.addClass(this._getItemNode(i), leCss);
                        } else {
                            $C.removeClass(this._getItemNode(i), leCss);
                        }
                    }
                    this.lastIdx = idx;
                }
            },

            onvalueChange: function() {
                this._super && this._super();
                var idx = mstrmojo.array.find(this.items, 'v', this.value);
                this.setRating(idx);
            },

            onmouseover: function(evt) {
                this._super && this._super(evt);
                var target = evt.target || $D.eventTarget(evt.hWin, evt.e),
                    idx = target && target.getAttribute('idx');
                if (idx != undefined) {
                    this.setRating(idx);
                }
            },

            onmouseout: function(evt) {
                this._super && this._super(evt);
                var idx = mstrmojo.array.find(this.items, 'v', this.value);
                this.setRating(idx);
            },

            postBuildRendering: function() {
                this._super();

                if (!mstrmojo.isDescendant(this.owner, this) && this.showByDefault) {
                    this.set('height', (this.openerStyle.ih || 0) + 'px');
                    this.set('width', (this.openerStyle.iw || 0) + 'px')
                }

                var idx = mstrmojo.array.find(this.items, 'v', this.value);
                if (idx > -1) {
                    this.setRating(idx);
                }
            }
        }
   )
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.TableLayoutList",
        "mstrmojo._IsTableLayoutListDIC",
        "mstrmojo._IsInputControl");

    function getTitleItems(items) {
        var arr = [];
        mstrmojo.array.forEach(items, function (v) {
            arr.push(v.n);
        });
        return arr;
    }

    mstrmojo.LikertScaleDIC = mstrmojo.declare(
        // superclass
        mstrmojo.TableLayoutList,

        // mixins
        [mstrmojo._IsTableLayoutListDIC, mstrmojo._IsInputControl],

        // instance members
        {
            scriptClass: 'mstrmojo.LikertScaleDIC',

            styleCssClass: 'scale',

            init: function (props) {
                this._super(props);
                this.items = this.getItems();
                this.titleItems = getTitleItems(this.items);
            },

            getDisplayValue: function getDisplayValue() {
                return (this.selectedIndex >= 0) ? this.items[this.selectedIndex].n : this.dv;
            },

            getLeftEndTitle: function getLeftEndTitle(idx) {
                return idx >= 0  ? (this.dic.mint || '') : '';
            },

            getRightEndTitle: function (idx) {
                return idx >= 0 ? (this.dic.maxt || '') : '';
            },

            postBuildRendering: function() {
                this._super();
                if (!mstrmojo.isDescendant(this.owner, this) && this.showByDefault) {
                    this.set('height', (this.openerStyle.ih || 0) + 'px');
                    this.set('width', (this.openerStyle.iw || 0) + 'px')
                }
            }
        }
    );
}());
(function() {
    mstrmojo.requiresCls("mstrmojo.android.inputControls.CheckBoxDIC");
    
    mstrmojo.android.inputControls.MarkRowDIC = mstrmojo.declare(
            
            mstrmojo.android.inputControls.CheckBoxDIC,
            
            null,
            
            {
                scriptClass: 'mstrmojo.android.inputControls.MarkRowDIC',
                
                isSwitchStyle: false,

                oncheckedChange: function() {
                    if(this.markAll) {
                        var wm = this.group && this.group.widgetsMap, i;
                        for (i in wm){
                            if(wm.hasOwnProperty(i)) {
                                if  (wm[i].checked !== this.checked) {
                                    wm[i].set('checked', this.checked);
                                }
                            }
                        }
                    } else {
                        this._super();
                    }
                },
                
                postBuildRendering: function(){
                    this._super();
                    
                    // Need to adjust its height so that it could be shown properly
                    this.domNode.style.height = '30px';
                }
            }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.LikertScaleDIC",
                         "mstrmojo.css");

    /**
     * LikertScale data input control for the android app.
     * 
     * @extends mstrmojo.LikertScaleDIC
     * @class
     */
    mstrmojo.android.inputControls.LikertScaleDIC = mstrmojo.declare(
        /**
         * superclass
         */
        mstrmojo.LikertScaleDIC,
        /**
         * mixins
         */
        null,
        /**
         * mstrmojo.android.inputControls.LikertScaleDIC.prototype
         */
        {
            scriptClass: 'mstrmojo.android.inputControls.LikertScaleDIC',

            lowestLabel: null,

            hightestLabel: null,

            

            markupString: '<div id="{@id}" class="mstrmojo-ListBase {@cssClass}" style="{@cssText}" mstrAttach:click>' +
                              '<div class="{@icnCss}" style="{@icnCssText}">' +
                                    '{@itemsHtml}' +
                                    '<div class="label {@lowestClass}">{@lowestLabel}</div>' +
                                    '<div class="label {@hightestClass}">{@hightestLabel}</div>' +
                              '</div>' +
                          '</div>',

            init: function init(props) {
                this._super(props);

                var len = this.titleItems && this.titleItems.length,
                    showMint = this.dic.mint && len,
                    showMaxt = this.dic.maxt && len;
                this.lowestLabel = showMint ? (this.titleItems[0] + ': ' + this.dic.mint) : '';
                this.lowestClass = showMint ? '' : 'hidden';
                this.hightestLabel = showMaxt ? (this.titleItems[len - 1] + ': ' + this.dic.maxt) : '';
                this.hightestClass = showMaxt ? '' : 'hidden';
            },

            // override parent function, don't need to show left end title on android OS
            getLeftEndTitle: function (idx) { return ''; },

            // override parent function, don't need to show right end tilte on android OS
            getRightEndTitle: function (idx) { return ''; },
            
            ontouchend: function (evt) {
                this.onclick(evt);
            },

            setDirtyFlag: function (c, d) {
                mstrmojo.css.addClass(this.itemsNode || d, 'tx-active');
            }
        }
    )
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.dom",
                         "mstrmojo.RatingDIC",
                         "mstrmojo._TouchGestures");

    var $D = mstrmojo.dom;

    /**
     * Rating data input control for the android app.
     *
     * @extends mstrmojo.RatingDIC
     * @borrows mstrmojo._TouchGestures
     *
     * @class
     */
    mstrmojo.android.inputControls.RatingDIC = mstrmojo.declare(
        /**
         * superclass
         */
        mstrmojo.RatingDIC,
        /**
         * mixins
         */
        [ mstrmojo._TouchGestures ],

        /**
         * mstrmojo.android.inputControls.RatingDIC.prototype
         */
        {
            scriptClass: 'mstrmojo.android.inputControls.RatingDIC',

            touchTap: function touchTap(touch) {
                // set touch event to be compatible with mouse event on web
                touch.e = touch.e || touch.evt;
                this.onclick(touch);
            },

            touchSwipeMove: function touchSwipeMove(touch) {
                var target = document.elementFromPoint(touch.pageX, touch.pageY),
                    idx;
                if ( $D.contains(this.domNode, target) ) {
                    idx = target && target.getAttribute('idx');
                    if ( idx != undefined ) {
                        this.setRating(idx);
                        this.ratingSelectedValue = this.items[idx].v;
                    }
                }
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                    if (this.ratingSelectedValue != undefined && this.ratingSelectedValue != this.value) {
                        this.set('value', this.ratingSelectedValue);
                    }
            },

            setDirtyFlag: function setDirtyFlag(c, d) {
                mstrmojo.css.addClass(this.itemsNode || d, 'tx-active');
            }
        }

    );
}());
(function() {

	mstrmojo.requiresCls("mstrmojo.Vis",
						 "mstrmojo.dom",
						 "mstrmojo.VisHeatMapColorTheme",
						 "mstrmojo.VisHeatMapPopup",
						 "mstrmojo.VisHeatMapTree",
						 "mstrmojo._TouchGestures",
						 "mstrmojo._HasTouchScroller",
						 "mstrmojo.num",
						 "mstrmojo._HasWaitIcon",
						 "mstrmojo.EnumReadystate",
						 "mstrmojo.css",
						 "mstrmojo.VisHeatMapCanvas"
						 );

	var $READYSTATE = mstrmojo.EnumReadystate;
	var DRILLING_ACTION = 1,
		SELECTOR_ACTION = 2,
		HYPERLINK_ACTION = 4,
		INFOWINDOW_ACTION = 4;
	var $CSS = mstrmojo.css,
		cssShow = "heatmap-show";
	var LabelSize = {
		On : 0,
		Off : 1,
		Proportional : 2
	};
	var AggregationType = {
		Sum : 0,
		Avg : 1,
		Cnt : 2,
		Max : 3,
		Min : 4,
		GeoAvg : 5
	};
	var BandDirection = {
		LeftToRight : 0,
		RightToLeft : 1,
		Center : 2,
		None : 3
	};
	var LayoutAlgorithm = {
		Squarified : 0,
		PivotByMiddle : 1,
		SliceAndDice : 2
	};

	var LayoutProperties = {
		Padding : 6,
		MaxLegendHeight : 60,
		LegendMenuEditorWidth: 70,
		LegendTickCount: 5,
		LegendMinWidth: 15,
		LegendTickLength: 4,
		LegendMaxBandWidth: 400,
		LegendWidthPercent: 0.9,
		LegendMinPadding: 15,
		LegendBottomPadding: 3,
		LegendGutter: 5,
		LegendBandAspect: 10,
		MinShowLabelDimension: 6,
        DeletedListHeight: 500,
        EditorDialogWidth: 565,
        EditorDialogHeight: 574,
        EditButtonWidth: 60,
        EditButtonHeight: 40,
        EditButtonRight: 10,
        //wait icon
        WaitIconWidth: 205,
        WaitIconHeight: 105,
        WaitIconMargin: 10,
        WaitIconFontSize: 20
	};

    var Spec = {
            heatmap_popup_panel_title: {
                    font_size: {value: 18, unit: 'pt'}
            },
            heatmap_gray_label: {
                    padding_bottom: { value: 7, unit: 'px' },
                    font_size: { value:10, unit: 'pt' },
                    height: { value: 32, unit: 'px' },
                    padding_left: {value: 22, unit: 'px' }
            },

            //todo
            heatmap_tree_button: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_one_level_1: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_multi_level_1: {
                    font_size: {value: 24, unit: 'pt'}
            },
            heatmap_two_level_2: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_multi_level_2: {
                    font_size: {value: 20, unit: 'pt'}
            },
            heatmap_multi_level_3: {
                    font_size: {value: 10, unit: 'pt'}
            },
            heatmap_size_legend: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_color_legend: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_color_legend_label: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_color_legend_tooltip: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_color_legend: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_editor_button: {
                    font_size: {value: 12, unit: 'pt'}
            },
            heatmap_tooltip_gray_bold: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_tooltip_gray: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_tooltip_black_bold: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_tooltip_black: {
                    font_size: {value: 14, unit: 'pt'}
            },
            heatmap_tree_div: {
                    font_size: {value: 18, unit: 'pt'}
            },
            heatmap_tree_root__heatmap_tree_div: {
                    font_size: {value: 14, unit: 'pt'}
            }
    };





	var Fake_Metric_ID = "--";
	var Background_Color = 0xF5F5F7;
	var EID_SELECTALL = "OA:(All)";
	function adjustPixel(px,forceFix){
            var DPIX = 149,
                base = 160;
            if(forceFix){
                    base = 149;
            }
            if(this.enableMultiDPI || forceFix){
                    DPIX = this.DPIX;
            }
            return parseInt(px*(DPIX/base));
	}

	/*function getColorWithFakeID(w,entity) {
		var hasColor = (w.props.colorMetricID != Fake_Metric_ID);
		var color = hasColor ? w.colorTheme.getColor(getColorValue(entity,w)):Background_Color;
		return color;
	}*/

	/*function cloneObject(obj){
			if (null == obj || "object" != typeof obj) return obj;
			var copy = obj.constructor();
			for (var attr in obj) {
					if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];
			}
			return copy;
	}*/

	function getCSSColor(rgb) {
		var c = 0x1000000 + rgb;
		var str = '#' + c.toString(16).substring(1).toUpperCase();
		return str;
	}
	function roundNumber(n, l) { // Arguments: number to round, number of decimal places
		return Math.round(n*Math.pow(10,l))/Math.pow(10,l);
	}
	function createPath(x, y, w, h, r, ctx) {
		ctx.beginPath();
	    ctx.moveTo(x + r, y);
	    ctx.lineTo(x + w - r - 1, y);
	    ctx.quadraticCurveTo(x + w - 1, y, x + w - 1, y + r);
	    ctx.lineTo(x + w - 1, y + h - r - 1);
	    ctx.quadraticCurveTo(x + w - 1, y + h - 1, x + w - r - 1, y + h - 1);
	    ctx.lineTo(x + r, y + h - 1);
	    ctx.quadraticCurveTo(x, y + h - 1, x, y + h - r - 1);
	    ctx.lineTo(x, y + r);
	    ctx.quadraticCurveTo(x, y, x + r, y);
	    ctx.closePath();
	}


	function updateEntityAggValue(ev, rawValue, needsCopy) {
		if (needsCopy && ev.total === undefined) {
			ev.avgTotal = ev.total = ev.geomProduct = ev.max = ev.min = ev.value;
			ev.count = isNaN(ev.value) ? 0 : 1;
			ev.positiveCount = ev.value > 0 ? 1 : 0;
		}
		ev.value = rawValue;
		ev.allChildrenCount++;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.total)) {
				ev.total = rawValue;
			} else {
				ev.total += rawValue;
			}
			if (isNaN(ev.avgTotal)) {
				ev.avgTotal = rawValue;
			} else {
				ev.avgTotal += rawValue;
			}
			if (isNaN(ev.max)) {
				ev.max = rawValue;
			} else {
				ev.max = Math.max(ev.max, rawValue);
			}
			if (isNaN(ev.min)) {
				ev.min = rawValue;
			} else {
				ev.min = Math.min(ev.min, rawValue);
			}
			if (isNaN(ev.geomProduct)) {
				if (rawValue > 0) {
					ev.geomProduct = rawValue;
					ev.positiveCount++;
				}
			} else {
				if (rawValue > 0) {
					ev.geomProduct *= rawValue;
					ev.positiveCount++;
				}
			}
			ev.count++;
		}
	}
	function updateEntityContainerAggValue(ev, oldev) {
		var rawValue = oldev.total;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.total)) {
				ev.total = rawValue;
			} else {
				ev.total += rawValue;
			}
			ev.count++;
		}
		rawValue = oldev.avg;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.avgTotal)) {
				ev.avgTotal = rawValue;
			} else {
				ev.avgTotal += rawValue;
			}
		}
		rawValue = oldev.max;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.max)) {
				ev.max = rawValue;
			} else {
				ev.max = Math.max(ev.max, rawValue);
			}
		}
		rawValue = oldev.min;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.min)) {
				ev.min = rawValue;
			} else {
				ev.min = Math.min(ev.min, rawValue);
			}
		}
		rawValue = oldev.geomAvg;
		if (!isNaN(rawValue)) {
			if (isNaN(ev.geomProduct)) {
				if (rawValue > 0) {
					ev.geomProduct = rawValue;
					ev.positiveCount++;
				}
			} else {
				if (rawValue > 0) {
					ev.geomProduct *= rawValue;
					ev.positiveCount++;
				}
			}
		}
	}
	function decodeXML(s){
		return s.replace(/&lt;/g, "<"
			   ).replace(/&gt;/g, ">"
			   ).replace(/&quot;/g,"\"");
			   //).replace(/&amp;/g, "&");
	}

	var delStatus = {
			dftUnDel: 0, // this item is in default list and now it's undeleted
			dftDel: 1, // this item is in default list and now it's deleted
			usrDel: 2 // this item is not in default list and user delete it
	};

	function parseDeletedList(s){
		var oParser = new DOMParser(),
			oDOM = oParser.parseFromString(decodeXML(s), "text/xml"),
			i = 0,
			ce = oDOM.childNodes[0], //child elements
			l = oDOM.childNodes[0].childElementCount; //length
		if(l == 0) return {};
		var	cr = ce.firstElementChild,
			at = cr.attributes,
			al = at.length,
			ret = this.props.deletedList || {},
			dict = ret,
			key;
		while (i < l) {
			dict = ret;
			at = cr.attributes;
			for (var j = 0; j < al; j++) {
				key = at[j].value;
				if (j === (al - 1)) {
					dict[key] = delStatus.dftDel; // please refer to "delStatus" definition
				} else {
					if (!dict[key]) {
						dict[key] = {};
					}
					dict = dict[key];
				}
			}
			i++;
			cr = cr.nextElementSibling;
		}
		return ret;
	}

    function loadSession() {
            var props = this.props,
                session = this.controller.view.model.session;
            if(session) {
                    //delete button
                    if(session.db !== undefined) {
                            props.delButtonEnabled = session.db;
                    }
                    //deleted list
                    if(session.dl !== undefined) {
                            props.deletedList = mergeDeletedList(props.deletedList, session.dl);
                    }
                    //previous selection
                    if(session.ps != undefined) {
                            this.previousSelected = lookUpSelectionDic.call(this, session.ps);
                    }

                    this.isUsingSavedColorTheme = session.isUsingSavedColorTheme;
                    this.isUsingDefaultColorTheme = session.isUsingDefaultColorTheme;
            }

            function lookUpSelectionDic(sd) {
                    var root = this.root;
                    for(var i = 0, len = sd.length; i < len; i++) {
                            var children = root.entityChildren;
                            for(var j = 0, l = children.length; j < l; j++){
                                    var ret = null;
                                    if(this.getEntityDisplayName(children[j]) === sd[i]){
                                            ret = children[j];
                                            root = ret;
                                            break;
                                    }
                            }
                    }
                    return ret;
            }

            function mergeDeletedList(d1, d2) {
                    //merge b to a
                    function merge(a, b) {
                            var keys = Object.keys(b),
                                len = keys.length;
                            for(var i = 0; i < len; i++) {
                                    var key = keys[i];
                                    if(typeof b[key] !== 'object') {
                                            a[key] = b[key];
                                    }else {
                                            if(a[key] === undefined) {
                                                    a[key] = {};
                                            }
                                            merge(a[key], b[key]);
                                    }
                            }
                    }
                    var ret = {};
                    merge(ret, d1);
                    merge(ret, d2);
                    return ret;
            }
    }

    function storeSession() {
            var cvm = this.controller.view.model,
                session = {},
                props = this.props;
            cvm.session = session;
            if(props.delButtonEnabled !== undefined) {
                    session.db = props.delButtonEnabled;
            }
            if(props.deletedList !== undefined) {
                    session.dl = props.deletedList;
            }
            if(this.previousSelected) {
                    session.ps = generateSelectionDic.call(this, this.previousSelected);
            }

            session.isUsingSavedColorTheme = this.isUsingSavedColorTheme;
            session.isUsingDefaultColorTheme = this.isUsingDefaultColorTheme;

            function generateSelectionDic(entity) {
                    var sd = [];
                    while(entity.parent){
                            sd.push(this.getEntityDisplayName(entity));
                            entity = entity.parent;
                    }
                    return sd;
            }
    }



	function loadProps() {
		this.props = {};
		var props = this.props,
			m = this.model,
			propValue = m.vp? m.vp : {},
			temp;
		// apply default values
        props.deletedList = {};
		props.delButtonEnabled = false;
		props.showMetricValues = false;
		props.refreshType = 0;
		props.labelSize = LabelSize.On;
		props.showLegend = true;

		props.sizeMetricEnabled = true;
		props.colorMetricEnabled = true;
		props.layout = LayoutAlgorithm.Squarified;
		props.legendAsc = true;

		var w = mstrmojo.VisHeatMapColorTheme.newInstance();
		w.initialize();
		this.colorTheme = w;

		if(propValue.dl){
			props.deletedList = parseDeletedList.call(this, propValue.dl);
		}
		if(propValue.ed){
			props.delButtonEnabled = (propValue.ed == "true" ? true:false);
		}
		if(propValue.mv){
			props.showMetricValues = (propValue.mv == "true" ? true:false);
		}
		if(propValue.rt != ""){
			props.refreshType = parseInt(propValue.rt);
		}
		if(propValue.ml){
			temp = propValue.ml.split(',');
			if(temp.length >= 2){
				props.sizeMetricID = temp[0];
				props.colorMetricID = temp[1];
			}
		}
		if(propValue.lb){
			temp = propValue.lb;
			if(temp == "Off"){
				props.labelSize = LabelSize.Off;
			}else if(temp == "Proportional"){
				props.labelSize = LabelSize.Proportional;
			}
		}
		if(propValue.lg){
			props.showLegend = (propValue.lg == "true" ? true:false);
		}
		if(propValue.rlp == "false" && propValue.abs)
			w.convertAbsoluteToBlend(this,propValue);

		if(propValue.blc){
			w.isBlend = (propValue.blc == "true" ? true:false);
		}
		if(propValue.gradientColors && propValue.bandColors){
			w.createDataProviderFromString(propValue.gradientColors, propValue.bandColors);
		}
		// metric limit
		if(propValue.la){
			props.layout = parseInt(propValue.la, 10);
		}
        //convert color banding for fixed color banding
        if(propValue.rlp == "false" && propValue.abs){
                this.colorTheme.convertAbsoluteToBlend(this,propValue);
                this.colorTheme.createDataProviderFromString(propValue.gradientColors, propValue.bandColors);
        }

	}

    function setLayout(){
		var widgetWidth = parseInt(this.width, 10),
			widgetHeight = parseInt(this.height, 10),
			heatMapWidth = widgetWidth - 2*this.LayoutProperties.Padding,
			legendHeight = 0, heatMapHeight;
		//do not show legend when there is no metric
		if(this.model.gvs.items.length <= 0)
			this.props.showLegend = false;
		if(this.props.showLegend){
                legendHeight = Math.min(Math.floor(0.2*(widgetHeight-2*this.LayoutProperties.Padding)), this.LayoutProperties.MaxLegendHeight);
                heatMapHeight = widgetHeight - legendHeight - 3*this.LayoutProperties.Padding;
        }else
                heatMapHeight = widgetHeight - 2*this.LayoutProperties.Padding;
		this.heatMapSize = {
				x : 0,
				y : 0,
				w : heatMapWidth,
				h : heatMapHeight
		};
        this.legendSize = {
                x : 0,
                y : widgetHeight - 2*this.LayoutProperties.Padding - legendHeight,
                w : widgetWidth,
                h : legendHeight
        };
        this.infoWindowSize = {
                maxWidth : parseInt(this.width) - 60,
                maxHeight : parseInt(this.height) - 60
        };

        //this.maxScale = Math.sqrt(2 * document.body.offsetWidth * document.body.offsetHeight / (heatMapWidth * heatMapHeight));
        this.maxScale = 10;// stay the same with iOS
		//this.canvasContainer.style.width = this.heatMapSize.w + 'px';
		//this.canvasContainer.style.height = this.heatMapSize.h + 'px';
        //this.canvasOuterContainer.style.width = this.heatMapSize.w + 'px';
        //this.canvasOuterContainer.style.height = this.heatMapSize.h + 'px';
    }
	function resetMetricIndices() {
		// load metric array
		var m = this.model,
			l = m.ghs.chs.items[0] ? m.ghs.chs.items[0].items.length:0,
			sid = this.props.sizeMetricID,
			cid = this.props.colorMetricID,
			a = [];
		this.metricArray = a;
		for(var i = 0; i < l; i++){
			a.push(getMetricID.call(this, i));
		}
		a.push(Fake_Metric_ID);
		l++;

		//default fake_metric
		this.sizeMetricIndex = 0;
		this.colorMetricIndex = l>2 ? 1:0;
		//if(l <= 2){
			//this.colorMetricIndex = 0;
		//}else{
			//this.colorMetricIndex = 1;
		//}
		//
		//scan in the valid metric to see if user has set the size/color metric
		for(var i = 0; i < l; i++){
			if(sid == a[i]){
				this.sizeMetricIndex = i;
			}
			if(cid == a[i]){
				this.colorMetricIndex = i;
			}
		}
		//if user has not set any of the metric ,set size metric first to meet the defaul behavior( 0:size ,1:color )
		if(sid === undefined){
			//for (var i = 0; i < l-1; i++)
				////use the metric that is not being set as color
				//if(a[i] != cid){
					//this.sizeMetricIndex = i;
					//break;
				//}
			sid = a[this.sizeMetricIndex];
			this.props.sizeMetricID = sid;
		}

		if(cid === undefined){
			//for (var i = 0; i < l-1; i++)
				////use the metric that is not being set as size
				//if(a[i] != sid){
					//this.colorMetricIndex = i;
					//break;
				//}
			cid = a[this.colorMetricIndex];
			this.props.colorMetricID = cid;
		}

        var gvs = m.gvs && m.gvs.items,
            lgvs = gvs && gvs.length,
            i,
            sidx = this.sizeMetricIndex,
            cidx = this.colorMetricIndex;
        this.sizeByMetricMissing = true;
        this.colorByMetricMissing = true;
        for(i = 0; i < lgvs; i++) {
            var values = gvs[i] && gvs[i].items;
            if(values[sidx] === undefined || values[sidx].rv !== '') {
                this.sizeByMetricMissing = false;
                break;
            }
        }
        for(i = 0; i < lgvs; i++) {
            var values = gvs[i] && gvs[i].items;
            if(values[cidx] === undefined || values[cidx].rv !== '') {
                this.colorByMetricMissing = false;
                break;
            }
        }

        if(this.sizeByMetricMissing) {
            this.props.sizeMetricEnabled = false;
            this.sizeMetricIndex = a.length -1;// use the fake metric to show rectangles in the same size
            this.props.sizeMetricID = a[this.sizeMetricIndex];
        }
        if(this.colorByMetricMissing) {
            this.props.colorMetricEnabled = false;
        }

		if(this.props.sizeMetricID === Fake_Metric_ID)
			this.props.sizeMetricEnabled = false;
		if(this.props.colorMetricID === Fake_Metric_ID){
			this.props.colorMetricEnabled = false;
            this.colorTheme.hasNoColorMetric = true;
        }

		if(this.props.sizeMetricEnabled == false && this.props.colorMetricEnabled == false)
			this.props.showLegend = false;

	}
	function loadMetricsInfo(){
		this.aggFunctions = [];
		var props = this.props,
			cid = props.colorMetricID,
			af = this.aggFunctions,
			m = this.model,
			propValue = m.vp? m.vp : {},
			ar = this.metricArray,
			l = ar.length - 1;
		// load color metric limit
		if(cid != Fake_Metric_ID){
			var mlEnabled = (propValue["mle"+cid] == "true") ? true : false;
			if(mlEnabled){
				var val = parseFloat(propValue["mlma"+cid]);
				if(!isNaN(val)){
					this.mlmax = val;
				}
				val = parseFloat(propValue["mlmi"+cid]);
				if(!isNaN(val)){
					this.mlmin = val;
				}
			}
		}
		// load aggregation functions
		for(var i = 0; i < l; i++){
			var id = "agf" + ar[i];
			if(propValue[id] !== undefined){
				af.push(parseInt(propValue[id]));
			}else{
				af.push(AggregationType.Sum);
			}
		}
	}
	function totalRow(row){
		for(var i = 0; i < row.length; i++){
			var obj = row[i].etk;
			if(obj == -1 || obj == "-1"){
				return true;
			}
		}
		return false;
	}

    function convertDataToModels() {
            resetMetricIndices.call(this);
            loadMetricsInfo.call(this);
            var m = this.model,
            deletedList = this.props.deletedList,
            att = m.gts.row, // row headers
            atl = att.length, // length
            mv = m.gvs.items, // metric value array
            //rl = mv.length, // row length
            rl = m.ghs.rhs? m.ghs.rhs.items.length : 0;
            ml = mv[0] ? mv[0].items.length:0, // metric values count
            rhs = m.ghs.rhs.items;


            if(atl <= 0){
                    var errmsg = "The Heat Map requires at least one attribute on row axis to render properly; it is recommended that two metrics be placed on the column axis as well.";

                    m.err = mstrmojo.desc(11147, errmsg);
                    return ;
            }
            this.singleSelection = false;
            this.hasNegativeSizeValue = false;

            this.levelAttributes = [];
            //		this.hierarchicalNodes = [];
            // this.dataProvider = [];
            this.root = {
                    aggValues : [],
                    entityChildren : [],
                    level : 0
            };
            // var dp = this.dataProvider;
            for ( var i = 0; i < atl; i++) {
                    this.levelAttributes[i] = {
                            index : i,
                            order : i + 1,
                            isInLOA : i + 1 > 0 ? true : false
                    }
            }
            var hashDict = {},
            attSpan = [];
            // get to know if there are attribute forms that we need to pay attention to
            for(var i = 0; i < atl; i++){
                    var o = att[i].fs;
                    attSpan[i] = Math.max(1, o ? o.length: 1);
            }
            this.attSpan = attSpan;

            var isAllSelectable = true,
                lastSerialRowIndex,
                serialEntity,
                highestLevelEntity,
                highestLevelIndex;

            // var rowHeaderLength = rhs.length;
            for (var i = 0; i < rl; i++) { // for each row
                    var attributeArray = [],
                    rowHeaderData = rhs[i].items,
                    k;
                    if(totalRow(rowHeaderData)) continue;

                    // create entity containers
                    var levelID = "",
                        delDict = deletedList,
                        parent = this.root,
                        cur = 0,
                        entity,
                        str,
                        serialEndIndex = -1;
                    for (var j = 0; j < atl; j++) {
                            var index,
                                newEntity;
                            str = "";
                            for(var k = 0; k < attSpan[j]; k++, cur++){
                                    index = rowHeaderData[cur].idx;
                                    if(index == -1)//the blank value
                                            continue;
                                    str += att[j].es[index].n + " ";
                                    if(k == 0){
                                            levelID += index;
                                    }
                            }
                            str = str.substring(0, str.length-1);
                            if (delDict) {
                                    delDict = delDict[decodeXML(str)];
                            }
                            //entity container
                            if(j != atl -1){
                                    if (hashDict[levelID] !== undefined) {
                                            parent = hashDict[levelID];
                                    } else {
                                            var entityContainer = {
                                                    aggValues : [],
                                                    entityChildren : [],
                                                    parentEntity : parent
                                            };
                                            var childrenArray = parent.entityChildren;
                                            childrenArray.push(entityContainer);
                                            hashDict[levelID] = entityContainer;
                                            parent = entityContainer;
                                            entityContainer["deleted"] = false;
                                            entityContainer["text"] = str;
                                            entityContainer["label"] = str;
                                            entityContainer["level"] = j;
                                            entityContainer["index"] = i;
                                    }
                                    levelID += ":";
                                    newEntity = entityContainer;
                            }else { // entity
                                    if (hashDict[levelID] !== undefined) {
                                            entity = hashDict[levelID];
                                            var indice = entity.indices;
                                            indice.push(i);
                                            for ( var k = 0; k < ml + 1; k++) {
                                                    var ev = entity.aggValues[k];
                                                    var rawValue;
                                                    // fake value
                                                    if (k == ml) {
                                                            rawValue = 1.0;
                                                    } else {
                                                            rawValue = mv[i].items[k].rv;
                                                    }
                                                    updateEntityAggValue(ev, parseFloat(rawValue), true);
                                                    if (!isNaN(rawValue)) {
                                                            this.aggregated = true;
                                                    }
                                            }
                                    } else {
                                            entity = {
                                                    indices : [],
                                                    aggValues : [],
                                                    parentEntity : parent
                                            };
                                            var indice = entity.indices;
                                            indice.push(i);
                                            var aggValues = entity.aggValues;
                                            for (var k = 0; k < ml + 1; k++) {
                                                    var ev = {};
                                                    aggValues[k] = ev;
                                                    var rawValue;
                                                    // fake value
                                                    if (k == ml) {
                                                            rawValue = 1.0;
                                                    } else {
                                                            rawValue = mv[i].items[k].rv;
                                                    }
                                                    // if (isNaN(rawValue))
                                                    ev.value = parseFloat(rawValue);
                                                    ev.allChildrenCount = 1;
                                            }
                                            this.aggregated = false;
                                            // newItem.data = data;
                                            if (delDict) { // means it is deleted
                                                    entity["deleted"] = true;
                                                    this.colorTheme.useDefault = false;
                                            }
                                            // dp[dp.length] = newItem;
                                            var childrenArray = parent.entityChildren;
                                            childrenArray.push(entity);
                                            entity["level"] = atl - 1;
                                            entity["text"] = str;
                                            entity["label"] = str;
                                            hashDict[levelID] = entity;
                                            //				if(hier === undefined){
                                            //					hier = [];
                                            //					this.hierarchicalNodes[atl - 1] = hier;
                                            //				}
                                            //				hier.push(entity);
                                    }
                                    newEntity = entity;
                            }
                            // load default selection
                            if(rowHeaderData[j].cet != undefined){
                                    if(j - serialEndIndex != 1 || (!isNaN(lastSerialRowIndex) && lastSerialRowIndex != i))
                                            isAllSelectable = false;
                                    if(isAllSelectable){
                                            serialEntity = newEntity;
                                            serialEndIndex = j;
                                            lastSerialRowIndex = i;
                                    }
                                    if(isNaN(highestLevelIndex) || highestLevelIndex < j){
                                            highestLevelIndex = j;
                                            highestLevelEntity = newEntity;
                                    }
                            }
                    }

            }
            if(isAllSelectable)
                    this.previousSelected = serialEntity;
            else
                    this.previousSelected = highestLevelEntity;
            //clearMaxMinValues.call(this);
            //setShow(false, false, true, true, this.root, this, ml+1);
            //layoutEntities.call(this);
            checkSelector.call(this);
            checkLinkDrill.call(this);
    }

	function clearMaxMinValues(){
		this.cmax = NaN;
		this.cmin = NaN;
		this.smax = NaN;
		this.smin = NaN;
	}

	function checkLinkDrill(){
			this.hasLinkDrill = false;
			//row
			var rowHeader = this.model.gts.row,
			rl = rowHeader.length;
			for(var i = 0; i < rl; i++){
					var attr = rowHeader[i];
					if(attr.lm){
							for(var j = 0; j < attr.lm.length; j++)
									if(attr.lm[j].links)break;
							if(j != attr.lm.length){
									this.hasLinkDrill = true;
									this.firstRowLinkDrillIndex = i;
									break;
							}
					}
			}

			//col
			var metricH = this.model.gts.col[0];
            if(!metricH)
                    return;
            var metricHL = metricH.es.length;
			for(var i = 0; i < metricHL; i++){
					var metric = metricH.es[i],
						lm = metricH.lm[i];
					if(lm && lm.links){
						this.hasLinkDrill = true;
						this.firstColLinkDrillIndex = i;
						break;
					}
			}
	}
	function checkSelector(){
		this.hasSelector = false;
		var m = this.model,
			rown = m.gts.row, // row headers
			rl = rown.length;
        var xtabModel = this.xtabModel,
            docModel = (xtabModel && xtabModel.docModel),
            layouts = (docModel && docModel.defn && docModel.defn.layouts),
            currentLayout;
        for(var i = 0; layouts && i < layouts.length; i++){
                if(layouts[i].loaded == true){
                        currentLayout = layouts[i];
                        break;
                }
        }

        var units =  (currentLayout && currentLayout.units);

		for(var i = 0; i < rl; i++){
			var att = rown[i];
            if(att.otp != -1 && att.sc !== undefined){
                    this.hasSelector = true;
                    //check if there is a target for the selector
                    var targets = att.sc.tks;
                    if(typeof targets != 'string')
                            continue;
                    targets = targets.split('\x1E');

                    var len = targets.length;
                    this.hasGridTarget = false;
                    for(var j = 0; j < len; j++){
                            if(targets[j] == '')
                                    continue;
                            targetName = targets[j];
                            if(units && units[targetName] && !units[targetName]['ifw']){
                                    this.hasGridTarget = true;
                                    return ;
                            }
                    }
            }
		}
      //only the lowest level can have selector
      //var att = rown[rl-1];
      //if(att.otp != -1 && att.sc !==undefined)
              //this.hasSelector = true;
	}

	function layoutEntities() {
		var width = this.width - 2*this.LayoutProperties.Padding;
		var legendHeight = 0;
		if(this.props.showLegend){
			legendHeight = Math.min(Math.floor(0.2*(parseInt(this.height)-2*this.LayoutProperties.Padding)), this.LayoutProperties.MaxLegendHeight);
		}
		var hm = this,
			area = copyRect(this.heatMapSize);
		area.w *= this.scaleFactor;
		area.h *= this.scaleFactor;
		var min = Math.min(area.w, area.h);
		var ch = this.root.entityChildren;
		switch (this.props.layout) {
		case LayoutAlgorithm.Squarified:
			var arr = ch.slice(0);
			arr.sort(function sortEntity(s, t) {
				var vs = getSizeValue(s, hm);
				var vt = getSizeValue(t, hm);
				if (isNaN(vs)) {
					if (isNaN(vt))
						return 0;
					return 1;
				} else {
					if (isNaN(vt))
						return -1;
					return vs < vt ? 1 : -1;
				}
				return 0;
			});
			squarify.call(this, arr, {
				r : []
			}, min, area);
			break;
		case LayoutAlgorithm.SliceAndDice:
			sliceAndDice.call(this, ch, area);
			break;
		case LayoutAlgorithm.PivotByMiddle:
			var arr = getVisibleEntities.call(this, ch), l = arr.length;
			if (l > 0) {
				pivotByMiddle.call(this, arr, 0, l - 1, area);
			}
			break;
		}
	}
	// t: treeData
	// r: row
	// m: min (width, height)
	// c: coordinate
	function squarify(t, r, m, c, a) {
		var newRow = false;
		if (t.length == 0) {
			setLayoutOrder.call(this, r, c);
		} else {
			var area = c.w * c.h;
			var cwa;
			if (a !== undefined) {
				cwa = a;
			} else {
				cwa = worstAspect.call(this, r, m, area);// current wosrt
															// aspect ratio
			}

			var data = t[0], arr = r.r;
			arr.push(data);

			var fwa = worstAspect.call(this, r, m, area); // future worst
															// aspect ratio
			if (cwa >= fwa || cwa == -1) {
				t.shift();
				squarify.call(this, t, r, m, c, fwa);
			} else {
				r.r.pop();
				setLayoutOrder.call(this, r, c);
				m = Math.min(c.w, c.h);
				if (r.t === undefined) {
					squarify.call(this, t, {
						r : []
					}, m, c);
				} else {
					squarify.call(this, t, {
						r : [],
						t : r.t
					}, m, c);
				}
			}
		}
	}

	function getTextStyle(l, w) {
		var fs, css, len = w.levelAttributes.length;
		if(len == 1){
			if(l == 0){
				css  = "heatmap-one-level-1";
                fs = this.Spec.heatmap_one_level_1.font_size.value;
				//fs = adjustPixel.call(this,19);
			}
		}
		else if (len == 2) {
			if(l == 0){
				css = "heatmap-multi-level-1";
                fs = this.Spec.heatmap_multi_level_1.font_size.value;
				//fs = adjustPixel.call(this,25);
			}else if(l == 1){
				css = "heatmap-two-level-2";
                fs = this.Spec.heatmap_two_level_2.font_size.value;
				//fs = adjustPixel.call(this,14);
			}
		}
		else if (len >= 3) {
			if(l == 0){
				css = "heatmap-multi-level-1";
                fs = this.Spec.heatmap_multi_level_1.font_size.value;
				//fs = adjustPixel.call(this,25);
			}else if(l == 1){
				css = "heatmap-multi-level-2";
                fs = this.Spec.heatmap_multi_level_2.font_size.value;
				//fs = adjustPixel.call(this,19);
			}else{
				css = "heatmap-multi-level-3";
                fs = this.Spec.heatmap_multi_level_3.font_size.value;
				//fs = adjustPixel.call(this,10);
			}
		}
		return {css:css, size:fs};
	}
	function getRectangleGap(e) {
			var getGapPixel = function(){
					var te = e, level = e.level,
					l = this.levelAttributes.length;
					if (l == 1)
							return 1;
					//		if (te.parentEntity === undefined) {
							//			console.log("no way~");
							//		}
							//		while (te.parentEntity != this.root) {
									//			level++;
									//			te = te.parentEntity;
									//		}
									if (l == 2) {
											if (level == 0)
													return 3;
											return 1;
									}
									if (l == 3) {
											if (level == 0)
													return 6;
											if (level == 1)
													return 3;
											return 1;
									} else {
											if (level == 0)
													return 8;
											if (level == 1)
													return 4;
											if (level == 2)
													return 2;
											return 1;
									}
			};
			var ret,
                gap = getGapPixel.call(this);
            if(this.DPI > 160)
                    ret = adjustPixel.call(this,gap);
            else
                    ret = gap;
            if(ret <= 0)
                    ret = 1;
            return ret;

	}

	function rectIsValid(a){
		return a.w > 0 && a.h > 0;
	}

	function rectIntersection(a, b) {
		var x = Math.max(a.x, b.x);
		var y = Math.max(a.y, b.y);
		var w = Math.min(a.x + a.w, b.x + b.w) - x;
		var h = Math.min(a.y + a.h, b.y + b.h) - y;
		if (w < 0 || h < 0) {
			return {
				x : NaN,
				y : NaN,
				w : NaN,
				h : NaN
			};
		}
		return {
			x : x,
			y : y,
			w : w,
			h : h
		};
	}

    function rectIsEqual(a ,b) {
            if(a.x == b.x && a.y == b.y && a.w == b.w && a.h == b.h)
                    return true;
            else
                    return false;
    }

    //check if b could be put in a
    function rectCanEncircle(a, b) {
            var c = rectIntersection(a, b);
            return rectIsEqual(c,b);
    }

    //put a by the side of b, make sure a is in c
    function rectPutAside(a, b, c) {
            var p = [{x: b.x - a.w, y: b.y + b.h/2 - a.h/2, w:a.w, h:a.h},//left
                     {x: b.x + b.w, y: b.y + b.h/2 - a.h/2, w:a.w, h:a.h},//right
                     {x: b.x + b.w/2 - a.w/2, y: b.y - a.h, w:a.w, h:a.h},//top
                     {x: b.x + b.w/2 - a.w/2, y: b.y + b.h, w:a.w, h:a.h}];//bottom
            for(var i = 0; i < 4; i++){
                    if(rectCanEncircle(c, p[i]))
                            return {rect:p[i], index:i};
            }
    }

	function swapRect(a) {
		var temp = a.x;
		a.x = a.y;
		a.y = temp;
		temp = a.w;
		a.w = a.h;
		a.h = temp;
		return a;
	}
	function copyRect(a) {
		var b = {};
		b.x = a.x;
		b.y = a.y;
		b.w = a.w;
		b.h = a.h;
		return b;
	}

	function worstAspect(r, m, a) {
		var worst, arr = r.r, l = arr.length;
		if (l > 0 && a > 0) {
			var e = arr[0];
			var pval = getSizeValue(e.parentEntity, this);
			if (isNaN(pval) || pval <= 0) {
				return -1;
			}
			var min, max, sum = 0, val, e, inited = false;
			for ( var i = 0; i < l; i++) {
				e = arr[i];
				if (!e.deleted) {
					val = getSizeValue(e, this);
					if (!isNaN(val)) {
						if (inited == false) {
							max = min = val;
							inited = true;
						} else {
							max = Math.max(val, max);
							min = Math.min(val, min);
						}
						sum += val;
					}
				}
			}
			var suba = a * sum / pval, otherMin = suba / m, newMin = (m < otherMin) ? m
					: otherMin;
			max = a * max / pval;
			min = a * min / pval;
			var e1 = max / (newMin * newMin);
			var e2 = min / (newMin * newMin);
			e1 = (e1 > 1) ? e1 : (1 / e1);
			e2 = (e2 > 1) ? e2 : (1 / e2);
			worst = Math.max(e1, e2);
		} else {
			worst = -1;
		}
		return worst;
	}

	function layoutRow(r, c, n, sum, swapped) {
		var width, height, ch = r.r, l = ch.length, w, h, tmpc, localSwapped = false;
		if (l == 0)
			return;
		if (n < c.h) {
			w = n;
			h = c.h;
			tmpc = c;
		} else {
			w = c.h;
			h = n;
			var tmpc = copyRect(c);
			swapRect(tmpc);
			localSwapped = true;
		}
		var x = tmpc.x, y = tmpc.y, bound = {
			x : x,
			y : y,
			w : w,
			h : h
		};
		var gap = getRectangleGap.call(this, ch[0]);

		for ( var i = 0; i < l; i++) {
			var e, rect, minDim;
			e = ch[i];
			if (e.deleted) {
				if ((swapped == true && localSwapped != true)
						|| (swapped == false && localSwapped == true)) {
					e.size = {
						x : y,
						y : x,
						w : 0,
						h : 0
					};
				} else {
					e.size = {
						x : x,
						y : y,
						w : 0,
						h : 0
					};
				}
				continue;
			}
			var value = getSizeValue(e, this);
			height = (sum <= 0 || e.deleted) ? 0 : Math.ceil(h * value / sum);
			width = w;
			if (e.entityChildren !== undefined) {
				if (value < sum) {
					if (i == 0) {
						if (gap > 1) {
							height -= (gap>>1);
						} else {
							height--;
						}
					} else if (i < l - 1) {
						if (gap > 1) {
							height -= gap;
						} else {
							height--;
						}
					} else {
						height = h + tmpc.y - y ;
					}
				}
				var nc = {
					x : x,
					y : y,
					w : width,
					h : height
				};
				rect = rectIntersection(nc, bound);
				if ((swapped == true && localSwapped != true)
						|| (swapped == false && localSwapped == true)) {
					swapRect(nc);
					swapRect(rect);
				}
				if(rectIsValid(rect)){
					e.size = rect;
				}
				else{
					e.size = {
						x : rect.x,
						y : rect.y,
						w : 0,
						h : 0
					};
				}
				minDim = Math.min(rect.w, rect.h);
				var hm = this;
				var arr = e.entityChildren.slice(0);
				arr.sort(function sortEntity(s, t) {
					var vs = getSizeValue(s, hm);
					var vt = getSizeValue(t, hm);
					if (isNaN(vs)) {
						if (isNaN(vt))
							return 0;
						return 1;
					} else {
						if (isNaN(vt))
							return -1;
						return vs < vt ? 1 : -1;
					}
					return 0;
				});
				squarify.call(this, arr, {
					r : []
				}, minDim, nc);
				y += height + gap;
			} else {
				if (value < sum) {
					if (i == 0 || i == l - 1) {
						if (gap > 1) {
							if (height > (gap>>1)) {
								height -= (gap>>1);
							}
						} else {
							if (height > 1) {
								height--;
							}
						}
					} else {
						if (height > gap) {
							height -= gap;
						}
					}
				}
				width = Math.max(0, width);
				height = Math.max(0, height);
				var rect = rectIntersection({
					x : x,
					y : y,
					w : width,
					h : height
				}, bound);
				rect.x = x;
				rect.y = y;
				y += height + gap;
				if (y >= tmpc.y + h) {
					rect.h = tmpc.y + h - rect.y;
				}
				if ((swapped == true && localSwapped != true)
						|| (swapped == false && localSwapped == true)) {
					rect = swapRect(rect);
				}
				if(rectIsValid(rect)){
					e.size = rect;
				}
				else{
					e.size = {
						x : rect.x,
						y : rect.y,
						w : 0,
						h : 0
					};
				}
			}
		}
	}

	function setLayoutOrder(r, c) {
		var sum = 0.0, arr = r.r, l = arr.length;
		if (l == 0)
			return;

		var ra, p = arr[0].parentEntity, ch = p.entityChildren, ll = ch.length;
		for ( var i = 0; i < l; i++) {
			var e = arr[i], v = getSizeValue(e, this);
			if (!e.deleted && v > 0) {
				sum += v;
			}
		}
		if (r.t === undefined) {
			var t = 0.0;
			for ( var i = 0; i < ll; i++) {
				var e = ch[i], v = getSizeValue(e, this);
				if (!e.deleted && v > 0) {
					t += v;
				}
			}
			r.t = t;
		}

		var e = arr[0], gap = getRectangleGap.call(this, e), bound = {
			x : 0,
			y : 0,
			w : 0,
			h : 0
		};

		if (e == this.root) {
			ra = this.heatMapSize.w * this.scaleFactor * this.heatMapSize.h * this.scaleFactor;
			bound.w = this.heatMapSize.w * this.scaleFactor;
			bound.h = this.heatMapSize.h * this.scaleFactor;
		} else {
			if (p == this.root) {
				ra = this.heatMapSize.w * this.scaleFactor * this.heatMapSize.h * this.scaleFactor;
				bound.w = this.heatMapSize.w * this.scaleFactor;
				bound.h = this.heatMapSize.h * this.scaleFactor;
			} else {
				var pSize = p.size;
				ra = pSize.w * pSize.h;
				bound = copyRect(pSize);
			}
			if (r.t == 0)
				ra = 0;
			else {
				ra *= sum / r.t;
			}
		}

		var aw = c.w, // actual width
		ah = c.h, // actual height
		swapped = false;
		if (c.h < c.w) {
		} else {
			swapped = true;
			swapRect(c);
			swapRect(bound);
			var temp = aw;
			aw = ah;
			ah = temp;
		}
		// check left and right
		if ((bound.x < c.x) || (bound.x + bound.w > c.x + c.w)) {
			if (gap > 1) {
				aw += (gap>>1);
			}
		}
		// check top and bottom
		if ((bound.y < c.y) || (bound.y + bound.h > c.y + c.h)) {
			if (gap > 1) {
				ah += (gap>>1);
			}
		}
		var width = ah == 0 ? 0 : Math.min(c.w, Math.ceil(ra / ah));
		if (sum < r.t && sum > 0) {
			if (c.x + width < bound.x + bound.w) {
				if (gap > 1) {
					width -= (gap>>1);
				} else {
					width--;
				}
			}
		}

		layoutRow.call(this, r, c, width, sum, swapped);

		var newX = c.x + width, newWidth = c.w - width;
		if (sum < r.t && sum > 0) {
			if (c.x + width < bound.x + bound.w) {
				if (gap > 1) {
					newX += gap;
					newWidth -= gap;
				} else {
					newX++;
					newWidth--;
				}
			}
		}
		c.x = newX;
		c.w = Math.max(0, newWidth);
		if (swapped) {
			swapRect(c);
		}
	}

	function getVisibleEntities(a) {
		if (a == null)
			return [];
		var arr = a.slice(0), total = 0, l = arr.length;
		arr.t = [];
		for ( var i = 0; i < l; i++) {
			var e = arr[i], val = getSizeValue(e, this);
			if (e.deleted || isNaN(val) || val <= 0) {
				arr.splice(i, 1);
				i--;
				l--;
				continue;
			}
			total += val;
			arr.t[i] = total;
		}
		return arr;
	}

	function pivotByMiddle(t, l, r, c) {
		var e = t[0], gap = getRectangleGap.call(this, e), lc, rc, // left
																	// rectangle
																	// coordination,
																	// right
																	// rectangle
																	// coordination
		lv, rv, lp, swapped = false, n = r - l + 1, pivot = (n > 2 ? ((n - 1)>>1)
				: (n>>1))
				+ l, cc;
		cc = copyRect(c);
		if (cc.w > cc.h) {
		} else {
			swapRect(cc);
			swapped = true;
		}
		lc = copyRect(cc);
		rc = copyRect(cc);
		// only one
		if (l == r) {
			e = t[l];
			layoutEntityByMiddle.call(this, e, cc, swapped);
			return;
		}
		// only two
		if (l + 1 == r) {
			e = t[l];
			lv = getSizeValue(e, this);
			e = t[r];
			rv = getSizeValue(e, this);
		} else {
			if (l == 0) {
				lv = t.t[pivot - 1];
			} else {
				lv = t.t[pivot - 1] - t.t[l - 1];
			}
			if (pivot == 0) {
				rv = t.t[r];
			} else {
				rv = t.t[r] - t.t[pivot - 1];
			}
		}
		lp = lv / (lv + rv);
		lc.w = Math.ceil(lc.w * lp);
		if (lc.w < c.w) {
			if (gap > 1) {
				if (lc.w > (gap>>1)) {
					lc.w -= (gap>>1);
				}
			} else {
				if (lc.w > 1) {
					lc.w--;
				}
			}
		}
		// only two
		if (l + 1 == r) {
			rc.w -= lc.w + gap;
			rc.x += lc.w + gap;
			e = t[l];
			layoutEntityByMiddle.call(this, e, lc, swapped);
			e = t[r];
			layoutEntityByMiddle.call(this, e, rc, swapped);
			return;
		}
		var mc = copyRect(cc), as, // aspect ratio
		pap, // pivot area percentage
		cv = 0, // current total value
		pi = -1, // partIndex
		la = 1, // last aspect
		pv;// pivot value

		if (pivot > l) {
			var llc = copyRect(lc);
			if (swapped) {
				swapRect(llc);
			}
			pivotByMiddle.call(this, t, l, pivot - 1, llc);
		}

		mc.w -= lc.w + gap;
		mc.x += lc.w + gap;
		rc.w = mc.w;
		rc.x = mc.x;
		as = mc.w / mc.h;
		e = t[pivot];
		pv = getSizeValue(e, this);
		pap = pv / rv;

		for ( var i = pivot; i <= r; i++) {
			e = t[i];
			cv += getSizeValue(e, this);
			if (i == r - 1) {
				continue;
			}
			var pwp = cv / rv, php = pv / cv, a = pwp / php * as;
			if (a >= 1) {
				if (la < 1 && la * a > 1) {
					pi = (i == r) ? i - 2 : i - 1;
				} else {
					pi = i;
				}
				break;
			}
			la = a;
		}
		pi = pi < 0 ? r : pi;

		var mv, pw, ph;

		if (pivot == 0) {
			mv = t.t[pi];
		} else {
			mv = t.t[pi] - t.t[pivot - 1];
		}
		pw = Math.ceil(mc.w * (mv / rv));
		ph = Math.ceil(mc.h * (pv / mv));
		if (pw < mc.w) {
			if (gap > 1) {
				if (pw > (gap>>1)) {
					pw -= (gap>>1);
				}
			} else {
				if (pw > 1) {
					pw--;
				}
			}
		}
		if (ph < mc.h) {
			if (gap > 1) {
				if (ph > (gap>>1)) {
					ph -= (gap>>1);
				}
			} else {
				if (ph > 1) {
					ph--;
				}
			}
		}
		var pc = {
			x : mc.x,
			y : mc.y,
			w : pw,
			h : ph
		};
		e = t[pivot];
		layoutEntityByMiddle.call(this, e, pc, swapped);

		if (pivot < pi) {
			mc.y += ph + gap;
			mc.w = pw;
			mc.h -= ph + gap;
			if (swapped) {
				swapRect(mc);
			}
			pivotByMiddle.call(this, t, pivot + 1, pi, mc);
		}
		if (pi < r) {
			rc.x += pw + gap;
			rc.w -= pw + gap;
			if (swapped) {
				swapRect(rc);
			}
			pivotByMiddle.call(this, t, pi + 1, r, rc);
		}
	}

	function layoutEntityByMiddle(e, c, swapped) {
		var size = copyRect(c);
		if (swapped == true) {
			swapRect(size);
		}
		if(rectIsValid(size)){
			e.size = size;
		}
		else{
			e.size = {
				x : size.x,
				y : size.y,
				w : 0,
				h : 0
			};
		}
		var ch = e.entityChildren;
		if (ch !== undefined) {
			var arr = getVisibleEntities.call(this, ch), l = arr.length;
			if (l > 0) {
				pivotByMiddle.call(this, arr, 0, l - 1, size);
			}
		}
	}

	function sliceAndDice(r, c) {
		if (r == null || r.length == 0) {
			return;
		}
		var t = 0, e = r[0], val, gap = getRectangleGap.call(this, e), swapped = false, l = r.length, x, y, w, h;
		for ( var i = 0; i < l; i++) {
			e = r[i], val = getSizeValue(e, this);
			if (!e.deleted && val > 0) {
				t += val;
			}
		}
		if (c.w < c.h) {
		} else {
			swapped = true;
			swapRect(c);
		}
		w = c.w;
		h = c.h;
		x = c.x;
		y = c.y;
		for ( var i = 0; i < l; i++) {
			e = r[i], val = getSizeValue(e, this);
			if (!e.deleted && val > 0) {
				var width, height;
				height = t <= 0 ? 0 : Math.ceil(val / t * h);
				width = w;
				if (val < t) {
					if (i == 0 || i == l - 1) {
						if (gap > 1) {
							if (height > (gap>>1)) {
								height -= (gap>>1);
							}
						} else {
							if (height > 1) {
								height--;
							}
						}
					} else {
						if (height > gap) {
							height -= gap;
						}
					}
				}
				width = Math.max(0, width);
				height = Math.max(0, height);
				var nc = {
					x : x,
					y : y,
					w : width,
					h : height
				}, rect = rectIntersection(nc, c);
				y += height + gap;
				if (y >= c.y + h) {
					rect.h = c.y + h - rect.y;
				}
				if (swapped) {
					swapRect(rect);
				}
				if(rectIsValid(rect)){
					e.size = rect;
				}
				else{
					e.size = {
						x : rect.x,
						y : rect.y,
						w : 0,
						h : 0
					};
				}
				if (e.entityChildren !== undefined) {
					sliceAndDice.call(this, e.entityChildren, rect);
				}
			} else {
				e.size = {};
				if (swapped) {
					e.size = {
						x : y,
						y : x,
						w : 0,
						h : 0
					};
				} else {
					e.size = {
						x : x,
						y : y,
						w : 0,
						h : 0
					};
				}
				continue;
			}
		}
		if (swapped) {
			swapRect(c);
		}
	}

	// all arguments are boolean,
	// mf: isMFing; s: isSearching; fm: filterMode
	// sfm: searchFilterMode; ec: entityContainer
    function setShow(mf, s, fm, sfm, ec, w, ml) {
            // entity container
            if (ec.entityChildren !== undefined) {
                    // var tmpShow = false;
                    // var tmpHilite = false;
                    var parent = ec.parentEntity, del = true, // self should be
                    // deleted or not
                    cd = false, // has one or more children deleted
                    teAggValues = [], eChildren = ec.entityChildren, l = eChildren.length;
                    for ( var i = 0; i < ml; i++) {
                            teAggValues[i] = {
                                    count : 0,
                                    allChildrenCount : 0,
                                    positiveCount : 0
                            };
                    }

                    for ( var i = 0; i < l; i++) {
                            var child = eChildren[i];
                            setShow(mf, s, fm, sfm, child, w, ml);
                            if (!child.deleted) {
                                    del = false;
                            }
                            // child is entity
                            if (child.entityChildren === undefined) {
                                    if (child.deleted) {
                                            cd = true;
                                    }
                            } else {
                                    if (child.hasChildDeleted) {
                                            cd = true;
                                    }
                            }
                            if (!child.deleted) {
                                    aggregateTotals(ec, child, teAggValues, w, ml);
                            }
                    }
                    ec.deleted = del;
                    ec.hasChildDeleted = cd;
                    for ( var i = 0; i < ml; i++) {
                            var ev = ec.aggValues[i];
                            if (ev == null) {
                                    ev = {};
                                    ec.aggValues[i] = ev;
                            }
                            // ev.min = ev.max = null;
                            var temp = teAggValues[i];
                            ev.total = temp.total;
                            ev.avg = temp.count == 0 ? 0 : temp.avgTotal / temp.count;
                            ev.geomAvg = temp.positiveCount == 0 ? NaN : Math.pow(
                                    temp.geomProduct, 1 / temp.positiveCount);
                                    ev.min = temp.min;
                                    ev.max = temp.max;
                                    ev.count = temp.count;
                                    ev.positiveCount = temp.positiveCount;
                    }
            }
            // for entity case
            else {
                    if(ec.deleted)
                            return ;
                    // get the max/min size/color value
                    var sv = getSizeValue(ec, w);
                    if(!isNaN(sv)){
                            if(isNaN(w.smax)){
                                    w.smax = w.smin = sv;
                            } else{
                                    if(sv > w.smax){
                                            w.smax = sv;
                                    }
                                    if(sv < w.smin){
                                            w.smin = sv;
                                    }
                            }
                    }
                    var cv = getColorValue(ec, w);
                    if(!isNaN(cv)){
                            if(isNaN(w.cmax)){
                                    w.cmax = w.cmin = cv;
                            } else{
                                    if(cv > w.cmax){
                                            w.cmax = cv;
                                    }
                                    if(cv < w.cmin){
                                            w.cmin = cv;
                                    }
                            }
                    }
            }
    }
	function aggregateTotals(ec, child, teAggValues, w, ml) {
		var ev, agg = child.aggValues;
		// entity container
		if (child.entityChildren !== undefined) {
			ev = getEntityValue(child, w.sizeMetricIndex);
			if (ev !== null) {
				var cnt = ev.count;
				if (cnt > 0) {
					for ( var i = 0; i < ml; i++) {
						ev = teAggValues[i];
						updateEntityContainerAggValue(ev, agg[i]);
					}
				}
			}
		}
		// entity
		else {
			if (getSizeValue(child, w) > 0 && !child.deleted) {
				for ( var i = 0; i < ml; i++) {
					ev = teAggValues[i];
					updateEntityAggValue(ev, getAggValue(child, i, w));
				}
			}
		}
	}

	function getEntityValue(e, index) {
		var agg = e.aggValues;
		if (index >= agg.length)
			return NaN;
		return agg[index];
	}

	function getColorValue(e, w){
		var idx = w.colorMetricIndex;
		return getAggValue(e, idx, w);
	}

	function getSizeValue(e, w){
		var idx = w.sizeMetricIndex,
			val = getAggValue(e, idx, w);
		if(val < 0){
			w.hasNegativeSizeValue = true;
			return Math.abs(val);
		}
		return val;
	}

	function getSizeRawValue(e, w){
		var idx = w.sizeMetricIndex;
		return getAggValue(e, idx, w);
	}
	// e: entity, i: index, w: widget
	function getAggValue(e, i, w) {
		var agg = e.aggValues;
		if (i >= agg.length)
			return NaN;
		var ev = agg[i],
			t = w.aggFunctions[i]; //type (of aggregation)
		// entity container
		if (e.entityChildren !== undefined) {
			switch (t) {
				case AggregationType.Sum:
					return ev.total;
				case AggregationType.Avg:
					return ev.avg;
				case AggregationType.Cnt:
					return ev.count;
				case AggregationType.Max:
					return ev.max;
				case AggregationType.Min:
					return ev.min;
				case AggregationType.GeoAvg:
					return (ev.positiveCount > 0) ? ev.geomAvg : 0;
				default:
					return ev.total;
			}
		}
		// entity
		else {
			if (ev.allChildrenCount == 1) {
				return ev.value;
			}
			switch (t) {
				case AggregationType.Sum:
					return ev.total;
				case AggregationType.Avg:
					return ev.count == 0 ? 0 : ev.avgTotal / ev.count;
				case AggregationType.Cnt:
					return ev.count;
				case AggregationType.Max:
					return ev.max;
				case AggregationType.Min:
					return ev.min;
				case AggregationType.GeoAvg:
					return ev.positiveCount > 0 ? NaN : Math.pow(ev.geomProduct,
							1.0 / ev.positiveCount);
				default:
					return ev.total;
			}
		}
	}
	function getLegendMaxMin() {
//		this.cmax = getEntityValue(this.root, this.colorMetricIndex).max;
//		this.cmin = getEntityValue(this.root, this.colorMetricIndex).min;
//		this.smax = getEntityValue(this.root, this.sizeMetricIndex).max;
//		this.smin = getEntityValue(this.root, this.sizeMetricIndex).min;


		if(!isNaN(this.mlmax) || !isNaN(this.mlmin)){
			if(!isNaN(this.mlmax)){
				this.cmax = this.mlmax;
				if(isNaN(this.mlmin) && (this.mlmax < this.cmin)){
					this.cmin = this.mlmax;
				}
			}
			if(!isNaN(this.mlmin)){
				this.cmin = this.mlmin;
				if(isNaN(this.mlmax) && (this.mlmin > this.cmax)){
					this.cmax = this.mlmin;
				}
			}

		}
		if (!isNaN(this.mlmax) && this.cmax > this.mlmax) {
			this.cmax = this.mlmax;
		}
		if (!isNaN(this.mlmin) && this.cmin < this.mlmin) {
			this.cmin = this.mlmin;
		}
		this.colorTheme.min = this.cmin;
		this.colorTheme.max = this.cmax;
		this.colorTheme.checkMinMax();
	}

	function getMetricID(idx){
		var str = "",
			m = this.model,
			col = m.ghs.chs.items,
			cnt = col.length,
			ml = col[0].items.length,
			coln = m.gts.col;
		if (idx < 0 || idx >= ml) return "";
		for(var i = 0; i < cnt; i++){
			var index = col[i].items[idx].idx;
			var temp = coln[i].es[index];
			var id = (temp.oid !== undefined) ? temp.oid : temp.id;
			str += id + " ";
		}
		return str.slice(0, str.length-1);
	}
	function getNumberForTick(i){
		var v;
		if(this.props.legendAsc){
			v = this.cmin + (this.cmax - this.cmin) * i/this.legendTickCount;
		}
		else{
			v = this.cmax + (this.cmin - this.cmax) * i/this.legendTickCount;
		}
		if(this.props.legendRounded){
			v = Math.floor(v);
		}
		return v;
	}

	function getTooltip(e, w){
		//attributes
		var level = e.level,
			index = (e.index === undefined) ? e.indices[0] : e.index,
			st = 0, // start index
			str = '',
			ret = '',
			ar = w.attSpan,
			rhs = w.model.ghs.rhs.items,
			rowHeaderData = rhs[index].items,
			attr = w.model.gts.row,
			mv = w.model.gvs.items, // metric value array
			ml = mv[0] ? mv[0].items.length:0,
			//ml = w.model.ghs.rhs ?  w.model.ghs.rhs.items.length:0,
			att, fs;

		for(var i = 0; i < level; i++){
			att = attr[i];
			//get attribute name
			ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-gray-bold">' + att.n + '</div>' + '<div class="heatmap-tooltip-gray-bold"><p>:&nbsp;</p></div>';
			str = '';
			for(var j = st; j < st + ar[i]; j++){
				var idx = rowHeaderData[j].idx;
				if(idx == -1)
					continue;
				str += att.es[idx].n + " ";
			}
			str = str.substring(0, str.length-1);
			ret += '<div class = "heatmap-tooltip-gray">' + str + '</div></div>';
			st += ar[i];
		}
		att = attr[level];
		ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-black-bold">' + att.n + '</div>' +  '<div class="heatmap-tooltip-black-bold"><p>:&nbsp;</p></div>';
		str = '';
		for(var i = st; i < st + ar[level]; i++){
			var idx = rowHeaderData[i].idx;
			if(idx == -1)
				continue;
			str += att.es[idx].n + " ";
		}
		str = str.substring(0, str.length-1);
		ret += '<div class = "heatmap-tooltip-black">' + str + '</div></div>';
		// metric values
		// size
		var si = w.sizeMetricIndex,
			ci = w.colorMetricIndex,
			n, v;
		if(si != ml){
			n = w.getMetricName(si);
			if(e.entityChildren !== undefined || w.aggregated){
				var tmp = w.aggFunctions[si];
				n = tooltipMacro(n, tmp);
				v = getSizeRawValue(e, w);
				if(isNaN(v)){
					v = '-';
				}
				else if(AggregationType.Cnt != tmp){
					fs = w.getFormatString(si);
					v = w.nf.formatByMask(fs, v);
				}
			}else{
				v = mv[index].items[si].v;
			}
			ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-black-bold">' + n + '</div>' + '<div class="heatmap-tooltip-black-bold"><p>:&nbsp;</p></div>';
			ret += '<div class = "heatmap-tooltip-black">' + v + '</div></div>';
		}
		if(e.entityChildren === undefined && ci != ml && si != ci){
			n = w.getMetricName(ci);
			if(e.entityChildren !== undefined || w.aggregated){
				var tmp = w.aggFunctions[ci];
				n = tooltipMacro(n, tmp);
				v = getColorValue(e, w);
				if(isNaN(v)){
					v = '-';
				}
				else if(AggregationType.Cnt != tmp){
					fs = w.getFormatString(ci);
					v = w.nf.formatByMask(fs, v);
				}
			}else{
				v = mv[index].items[ci].v;
			}
			ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-black-bold">' + n + '</div>' + '<div class="heatmap-tooltip-black-bold"><p>:&nbsp;</p></div>';
			ret += '<div class = "heatmap-tooltip-black">' + v + '</div></div>';
		}
		for(var i = 0; i < ml; i++){
			if(i == si) continue;
			if(i == ci && e.entityChildren === undefined && si != ci) continue;
			n = w.getMetricName(i);
			if(e.entityChildren !== undefined || w.aggregated){
				var tmp = w.aggFunctions[i];
				n = tooltipMacro(n, tmp);
				v = getAggValue(e, i, w);
				if(isNaN(v)){
					v = '-';
				}
				else if(AggregationType.Cnt != tmp){
					fs = w.getFormatString(i);
					v = w.nf.formatByMask(fs, v);
				}
			}else{
				v = mv[index].items[i].v;
			}
			ret += '<div class="heatmap-inline"><div class = "heatmap-tooltip-gray-bold">' + n + '</div>' + '<div class="heatmap-tooltip-gray-bold"><p>:&nbsp;</p></div>';
			ret += '<div class = "heatmap-tooltip-gray">' + v + '</div></div>';
		}
		return ret;
	}

	function tooltipMacro(n, t){
		var macro;
		switch(t){
			case AggregationType.Sum:
				macro = "Sum of {0}";
				break;
			case AggregationType.Avg:
				macro = "Average of {0}";
				break;
			case AggregationType.Cnt:
				macro = "Count of {0}";
				break;
			case AggregationType.Max:
				macro = "Maximum of {0}";
				break;
			case AggregationType.Min:
				macro = "Minimum of {0}";
				break;
			case AggregationType.GeoAvg:
				macro = "Geometry Average of {0}";
				break;
			default:
				macro = "Sum of {0}";
		}
		return macro.replace('{0}', n);
	};

    function bindTouchEvents(d, owner) {
            if(d.eventOwner == owner)
                    return;
            var $D = mstrmojo.dom,
                eventList = [$D.TOUCHSTART, $D.TOUCHMOVE, $D.TOUCHEND, $D.TOUCHCANCEL];
            for(var i = 0; i < eventList.length; i++){
                    if(eventList[i] == '')
                            continue;
                    if(document.createTouch){
                            d['on' + eventList[i]] = function (e) {
                                    var evt = document.createEvent("TouchEvent"),
                                        t = e.touches[0];
                                    //touchend has no touches
                                    if(!t){
                                            t = {};
                                    }
                                    //currently the paraments of initTouchEven of webkit on androild is incompatible with that of W3C
                                    evt.initTouchEvent(e.touches, e.targetTouches, e.changedTouches, e.type, e.view, t.screenX, t.screenY, t.clientX, t.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey);

                                    //the following is of Apple, compatible with W3C
                                    //evt.initTouchEvent(e.type, e.bubbles, e.cancelable, e.view, e.detail, t.screenX, t.screenY, t.clientX, t.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.touches, e.targetTouches, e.changedTouches, e.scale, e.rotation);
                                    owner.dispatchEvent(evt);
                            };
                    }else{
                            d['on' + eventList[i]] = function (e) {
                                    var evt = document.createEvent('MouseEvent');
                                    evt.initMouseEvent(e.type, e.bubbles, e.cancelable, e.view, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);
                                    owner.dispatchEvent(evt);
                            };
                    }
                    /*var hln = 'on' + eventList[i];
                    d[hln] = (function(e,n) {
                            return function(e) {
                                    if(owner[n]){
                                            console.log(n);
                                            owner[n](e);
                                    }
                            }
                    })(e, hln);*/
            }
            d.eventOwner = owner;
    };




	mstrmojo.VisHeatMap = mstrmojo.declare(

					mstrmojo.Vis,

					[ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

					{

						scriptClass : 'mstrmojo.VisHeatMap',

						scrollerConfig : {
							bounces : false,
							showScrollbars : false,
							useTranslate3d : true,
							vScroll: true,
							hScroll: true,
							offset : {
									y: {
										start: 0,
										end: 0
									},
									x: {
										start: 0,
										end: 0
									}
							},
							origin: {
								x: 0,
								y: 0
							}
						},

						selectedStyle : "background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #058CF5), color-stop(1, #015DE6));color:#FFFFFF;",

						selectedClass : "",

                        insertedStyles : [],

                        LayoutProperties: {},

						highlightBoxWidth: 3,

                        waitIconString: mstrmojo.desc("8445","Loading"),


						markupString :
						'<div id="{@id}" class="mstrmojo-{@cssClass}" style="background-color:#333333;width:{@width};height:{@height}; left:{@left}; top:{@top}; z-index: {@zIndex}; position:absolute;" mstrAttach:mousedown,mouseup,mousemove,click>'
                                //canvas outer container
                                +'<div class="heatmap-canvas-outer-container" style="padding: {@LayoutProperties.Padding}px; height:{@heatMapSize.h}px; width:{@heatMapSize.w}px">'
                                        //canvas container
                                        +'<div id ="{@id}-heatmap-canvas-container" class="heatmap-canvas-container" style="left: {@LayoutProperties.Padding}px; top: {@LayoutProperties.Padding}px; height:{@heatMapSize.h}px; width:{@heatMapSize.w}px">'
                                                //scrollNode
                                                +'<div>'
                                                        //canvas
                                                        + '<div></div>'
                                                        //selection highlight box
                                                        +'<div class="heatmap-selection-highlight-box heatmap-round-corner" style="border: {@highlightBoxWidth}px solid white;"></div>'
                                                +'</div>'
                                        +'</div>'//end of canvas container
                                +'</div>'
								//legend
								+'<div class="heatmap-legend" style="left:{@legendSize.x}px; top:{@legendSize.y}px; height:{@legendSize.h}px; width:{@legendSize.w}px">'
											//size legend
											+ '<div  class="heatmap-size-legend">'
												// size legend title
												+ '<div class="heatmap-size-legend-title">Rectangle Size:</div>'
												// size legend label
												+ '<div id="{@id}-color-legend-ticker" class="heatmap-size-legend-label" ></div>'
											//end of size legend
											+ '</div>'
											+
											//color legend
											'<div  class="heatmap-color-legend">'
												//color legend title
												+ '<div class="heatmap-color-legend-title">Rectangle Color:</div>'
												//color legend label
												+ '<table cellpadding="4" class="heatmap-color-legend-label">'
													+ '<tbody><tr>'
														+ '<td class="heatmap-color-legend-label-td"></td>'
													+ '</tr></tbody>'
												+ '</table>'
												+ '<div style="position:relative;">'
													//color legend band
													+ '<canvas id="{@id}-color-legend-band" class="heatmap-color-legend-band"></canvas>'
													//rectangle legend tooltip
													+ '<div id="{@id}-legend-tooltip" class="heatmap-color-legend-tooltip"></div>'
												+ '</div>'
											//end of color legend
											+ '</div>'
											//editor button
											+ '<div id="{@id}-editor-div" class="heatmap-editor-button" style="width: {@LayoutProperties.EditButtonWidth}px; height:{@LayoutProperties.EditButtonHeight}px; right:{@LayoutProperties.EditButtonRight}px"></div>'
								//end of legend
								+ '</div>'

								//measure text
								+'<span id="textSpan" class="heatmap-measure-text"></span>'

                                //wait Icon
                                +'<div class="mojo-overlay-wait" style="display: -webkit-box; -webkit-box-align:center; -webkit-box-pack:center; position: absolute; left: -100000px; top: -100000px">'
                                        +'<div class="overlay"></div>'
                                        +'<div style="width:{@LayoutProperties.WaitIconWidth}px; height:{@LayoutProperties.WaitIconHeight}px; background-color: black; opacity: 0.8; display: -webkit-box">'
                                            +'<div style="display: -webkit-box; -webkit-box-align: center; -webkit-box-pack: center; -webkit-box-flex:1;  margin: {@LayoutProperties.WaitIconMargin}px; border: 1px solid white; color: white; font-family: Helvetica; font-weight: bold; font-size:{@LayoutProperties.WaitIconFontSize}pt">'
                                                +'{@waitIconString}'
                                            +'</div>'
                                        +'</div>'
                                +'</div>'

                                //puppet of infoBox
                                + '<div></div>'

                        + '</div>',

						markupSlots : {

							canvas: function() {
								return this.domNode.childNodes[0].childNodes[0].childNodes[0].childNodes[0];
							},

							canvasContainer: function() {
								return this.domNode.childNodes[0].childNodes[0];
							},

                            canvasOuterContainer: function() {
                               return this.domNode.childNodes[0];
                            },

                            scrollNode: function() {
                                return this.domNode.childNodes[0].childNodes[0].childNodes[0];
                            },

							selectionHighlightBox : function() {
								return this.domNode.childNodes[0].childNodes[0].childNodes[0].childNodes[1];
							},

							legend: function() {
								return this.domNode.childNodes[1];
							},

							sizeLegend : function(){
								return this.domNode.childNodes[1].childNodes[0];
							},
							sizeLegendTitle : function() {
								return this.domNode.childNodes[1].childNodes[0].firstChild;
							},
							sizeLegendLabel : function() {
								return this.domNode.childNodes[1].childNodes[0].lastChild;
							},

							colorLegend : function() {
								return this.domNode.childNodes[1].childNodes[1];
							},
							colorLegendTitle : function() {
								return this.domNode.childNodes[1].childNodes[1].firstChild;
							},
							colorLegendLabel : function() {
								return this.domNode.childNodes[1].childNodes[1].childNodes[1];
							},
							colorLegendBand : function() {
								return this.domNode.childNodes[1].childNodes[1].childNodes[2].firstChild;
							},
							legendTooltip : function() {
								return this.domNode.childNodes[1].childNodes[1].childNodes[2].childNodes[1];
							},
							editorButton : function() {
								return this.domNode.childNodes[1].lastChild;
							},
							textSpan : function() {
								return this.domNode.childNodes[2];
							},

                            waitIcon: function() {
                                    return this.domNode.childNodes[3];
                            },

                            infoBoxPuppet: function() {
                                    return this.domNode.childNodes[4];
                            }
						},

                        addCSSToHead: function(){
                                var cssString = {
                                        text:
                                                '.heatmap-popup-panel-title {'+
                                                '  font-size: ' + adjustPixel.call(this,22 , true) + 'pt !important;'+
                                                '  height: ' + adjustPixel.call(this,65 , true) + 'px !important;'+
                                                '}'+
                                                '.heatmap-gray-label {'+
                                                '        padding-bottom: ' + adjustPixel.call(this,7 , true) + 'px !important;'+
                                                '        font-size: ' + adjustPixel.call(this,14 , true) + 'pt !important;'+
                                                '  height: ' + adjustPixel.call(this,32 , true) + 'px !important;'+
                                                '  padding-left: ' + adjustPixel.call(this,22 , true) + 'px !important;'+
                                                '  line-height: ' + adjustPixel.call(this, 40 , true) + 'px !important;' +
                                                '}'+
                                                '.heatmap-tree-text {' +
                                                '  font-size: ' + adjustPixel.call(this, 18 , true) + 'pt !important;' +
                                                '  line-height: ' + adjustPixel.call(this, 65 , true) + 'px !important;'+
                                                '}' +
                                                '.heatmap-tree-div {'+
                                                '  font-size: ' + adjustPixel.call(this,18 , true) + 'pt !important;'+
                                                '  line-height: ' + adjustPixel.call(this, 40 , true) + 'px !important;'+
                                                '}'+
                                                '.heatmap-tree-button {'+
                                                '  font-size: ' + adjustPixel.call(this,16 , true) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-apply-button > .mstrmojo-Button-text {'+
                                                '  font-size: ' + adjustPixel.call(this,14 , true) + 'pt !important;'+
                                                '  line-height: ' + adjustPixel.call(this,24 , true) + 'px !important; '+
                                                '  height: ' + adjustPixel.call(this,24 , true) + 'px !important; '+
                                                '}'+
                                                '.heatmap-tree.root > .heatmap-tree-div > div {'+
                                                '  font-size: ' + adjustPixel.call(this,14 , true) + 'pt !important;'+
                                                '  line-height: ' + adjustPixel.call(this, 40 , true) + 'px !important;'+
                                                '  height: ' + adjustPixel.call(this, 40 , true) + 'px !important;'+
                                                '}'+
                                                '.heatmap-one-level-1 {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-multi-level-1 {'+
                                                '  font-size: ' + adjustPixel.call(this,24) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-two-level-2 {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-multi-level-2 {'+
                                                '  font-size: ' + adjustPixel.call(this,20) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-multi-level-3 {'+
                                                '  font-size: ' + adjustPixel.call(this,10) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-size-legend {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-color-legend {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-color-legend-label {'+
                                                '  font-size: ' + adjustPixel.call(this,10) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-color-legend-tooltip {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-legend {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-editor-button {'+
                                                '  font-size: ' + adjustPixel.call(this,12) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-tooltip-gray-bold {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-tooltip-gray {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-tooltip-black-bold {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'+
                                                '.heatmap-tooltip-black {'+
                                                '  font-size: ' + adjustPixel.call(this,14) + 'pt !important;'+
                                                '}'
                                };

                                this.addAdjustedClassToDocument(cssString.text);

                        },

                        /*removeCSSFromHead: function() {
                                var len = this.insertedStyles.length;
                                if(len){
                                        var styles = this.insertedStyles,
                                            p = this.CSSParent;
                                        for(var i = 0; i < len; i++){
                                                p.removeChild(styles[i]);
                                        }
                                }
                        },*/



						addAdjustedClassToDocument: function(classString){
							var beginIndex = classString.indexOf('.');
							if(beginIndex == -1)
								return;
                            var p = document.getElementsByTagName('head')[0];
                            this.CSSParent = p;
							for(var i = beginIndex; i < classString.length; ){
								var endIndex = i + classString.substring(i).indexOf('}');
								if(endIndex == -1)
									break;
								var style = document.createElement('style');
								style.type = 'text/css';
								style.innerHTML = classString.substring(i,endIndex+1);
                                this.insertedStyles.push(style);
								p.appendChild(style);
								i = endIndex + 1;
							}
						},

                        isMultipleDPIEnabled: function() {
                                var xtabModel = this.xtabModel,
                                    docModel = (xtabModel && xtabModel.docModel),
                                    fitToPage = false,
                                    microApp = false;
                                if (docModel) {
                                        fitToPage = docModel.zt && (docModel.zt==2);
                                        var layouts = (docModel && docModel.defn && docModel.defn.layouts),
                                            layout;
                                        var i;
                                        // for document which has multiple layouts
                                        for(i in layouts) {
                                                if (layouts[i].loaded) {
                                                        layout = layouts[i];
                                                        break;
                                                }
                                        }
                                        if (layout && layout.hasOwnProperty("fch")) {
                                                microApp = layout.fch;
                                        }
                                }
                                if(fitToPage && microApp)
                                        return true;
                                else
                                        return false;
                                //return true;
                        },

                        init: function(e){
//alert('init');
                                if(this._super)
                                        this._super(e);

                                //check HTML5 support
                                var canvas = document.createElement("canvas");
                                browserSupportsHtml5 = canvas.getContext;
                                if (!browserSupportsHtml5) {
                                        this.error = mstrmojo.desc(8126, 'Your browser does not support HTML5');
                                        return;
                                }
//alert('end of init');


                        },
						preBuildRendering :function() {
//alert("prebuildRendering");

                                delete this.error;
                                if(this._super){
                                        this._super();
                                }
                                //set DPI
                                this.dpiAdjusted = true;
                                this.DPI = mstrMobileApp.getDeviceDPI();
                                if(mstrMobileApp.getDeviceDPIX)
                                        this.DPIX = mstrMobileApp.getDeviceDPIX();
                                else
                                        this.DPIX = 149;
                                if(this.isMultipleDPIEnabled()){
                                //if(true){

                                        //add a new class to the body
                                        //var dpiClassName = ' heatmapDPI' + mstrMobileApp.getDeviceDPI();
                                        //if(document.body.className.indexOf('dpiClassName') == -1)
                                                //document.body.className += dpiClassName;

                                        this.enableMultiDPI = true;
                                        //this.DPI = 240;
                                        //alert(mstrMobileApp.getDeviceDPI());
                                }else{
                                        //default to 160DPI as we tested heatmap on 160 dpi devices
                                        this.enableMultiDPI = false;
                                        //this.adjustLocalDPI();
                                        //var dpiClassName = ' heatmapDPI' + 160;
                                        //if(document.body.className.indexOf('dpiClassName') == -1)
                                                //document.body.className += dpiClassName;


                                        //remove the dpi class
                                        //var dpiClassName = 'dpi' + mstrMobileApp.getDeviceDPI();
                                        //document.body.className = document.body.className.replace(dpiClassName, '');
                                }
                                ////alert(this.enableMultiDPI);
                                ////alert(this.DPIX);

                                this.adjustLocalDPI();
                                this.addCSSToHead();




                                this.zIndex = null;

                                this.loadDefinedFormat();


                                loadProps.call(this);
                                loadSession.call(this);
//alert('endof loadProps');

                                if (!this.model) {
                                        this.error = mstrmojo.desc(8426,'No model provided');
//alert("model error");
                                        return ;
                                }
                                // sometimes the refresh might load new data models
                                var err = this.model.err || this.model.eg;
                                if(err){
                                        this.error = err;
                                        return;
                                }
//alert('begin convertDataToModels');
                                convertDataToModels.call(this);
//alert('endof convertDataToModels');
                                var err = this.model.err || this.model.eg;
                                if(err){
                                        this.error = err;
                                        return;
                                }


                                setLayout.call(this);
//alert('endof setLayout');

                                this.calculateValuesInTree();
//alert('endof calculateValuesInTree');
                                layoutEntities.call(this);
//alert('endof layoutEntities');

                                getLegendMaxMin.call(this);
//alert('endof getLegendMaxMin');

                                this.nf = mstrmojo.num;

                                if (this.editorDialog) {// xiawang: If editorDialog is there, we need to destory it and create new one
                                        this.editorDialog.destroy();
                                        this.editorDialog = null;
                                }
//alert("end of preBuildRendering");
						},

                        // set markup string Handler
                        buildRendering: function () {
//alert("buildRendering");

                                var that = this;
                                var backup = mstrmojo.string.apply;
                                mstrmojo.string.apply = function (tmpl, obj) {
                                        if (!tmpl) {
                                                return "";
                                        }
                                        return tmpl.replace(/\{([^\}]+)\}/gm,
                                                            function tokenRepl(token, prop) {
                                                                    var s = token.replace(/@/g, 'that.');
                                                                    var res;
                                                                    try{
                                                                            res = eval(s);
                                                                    }catch(e){
                                                                            res = undefined;
                                                                    }finally{
                                                                    }
                                                                    return res === undefined ? '' : res;
                                                            }
                                        );
                                };

                                if (this._super) {
                                        this._super();
                                }
                                mstrmojo.string.apply = backup;


//alert("end of buildRendering");


                        },

                        createInfoBox: function(){
                                //infoBox
                                //markup string
                                var html =
                                        //it's a place holder, so we don't want it to be display in case it gets some events
                                        '<div id="' + this.id + '-infobox" class="heatmap-infobox" style="position:absolute; left:0px; top:0px;">'  // infoBox    xiawang: according to online material, we must use positioned property in order to have z-index inherited
                                            +'<div class="heatmap-highlight-box heatmap-round-corner" style="border: ' + this.highlightBoxWidth + 'px solid white;"></div>'  // highlightBox
                                            +'<div class="heatmap-shadow-box heatmap-round-corner"></div>'  // shadowBox
                                            +'<div class="heatmap-triangle"></div>'  // triangle
                                            +'<div class="heatmap-tooltip-box heatmap-round-corner" style="max-width: ' + document.body.offsetWidth + 'px; max-height: ' + document.body.offsetHeight + 'px; "></div>'  // tooltipBox
                                            +'<div class="heatmap-delete-button"></div>'  // deleteButton
                                            +'<div class="heatmap-tooltip-shelter heatmap-round-corner"></div>'// shelter
                                        +'</div>';
                                //markup slot
                            var div = document.createElement('div');
                            div.innerHTML = html;

							this.infoBox = div.childNodes[0];
                            this.highlightBox = this.infoBox.childNodes[0];
                            this.shadowBox = this.infoBox.childNodes[1];
                            this.triBox = this.infoBox.childNodes[2];
                            this.tooltipBox = this.infoBox.childNodes[3];
                            this.deleteButton = this.infoBox.childNodes[4];
                            this.shelter = this.infoBox.childNodes[5];

                            //place infoBox
                            //this.updateInfoBoxPosition();

                            div.style.cssText = 'position: absolute; left: 0px; top: 0px';

                            //set event handler
                            bindTouchEvents(div, this.infoBoxPuppet);

                            document.body.appendChild(div);
                        },

                        /*updateInfoBoxPosition: function() {
                            var $P = mstrmojo.dom.position,
                                domRect = $P(document.body, true),
                                widgetRect = $P(this.domNode, true),
                                padding = this.LayoutProperties.Padding,
                                left = widgetRect.x - domRect.x,
                                top = widgetRect.y - domRect.y,
                                div = this.infoBox.parentNode;
                            div.style.position = 'absolute';
                            div.style.left = left + 'px';
                            div.style.top = top + 'px';
                        },*/








						postBuildRendering : function postBR() {
//alert("postBuildRendering");
                                if(this.error){
//alert("end of postBuildRendering for fatal error");
                                        this.renderErrorMessage(this.error);
                                        return ;
                                }
                            var heatMap = this;
                            // set Orientation Handler
                            var tmpFunction = this.controller.onorientationChange;
                            this.controller.onorientationChange = function(){
                                    tmpFunction.call(heatMap.controller);
                                    heatMap.onorientationChange();
                            }

                            // enable the outer tap
                            //this.addCurtain();
                            //this.addGlobalListener();
                            this.enableGlobalDismiss();



                            this.setupScroller();
							if(this._super) {
			                	this._super();
                            }
                            var backup = this._tsCallback;
                            this._tsCallback = function(e){
                                    //check if info window is displayed
                                    if(heatMap.isInfoWindowDisplayed())
                                            heatMap.infoWindowMode = true;
                                    else
                                            heatMap.infoWindowMode = false;


                                    backup.call(heatMap,e);
                            };

                            //this._tn.removeEventListener('mousedown',backup);
                            //this._tn.addEventListener('mousedown',this._tsCallback);

                            var $DAE = mstrmojo.dom.attachEvent,
                                $DDE = mstrmojo.dom.detachEvent,
                                TOUCHSTART = mstrmojo.dom.TOUCHSTART;
                            $DDE(this._tn, TOUCHSTART, backup);
                            $DAE(this._tn, TOUCHSTART, this._tsCallback);

                            // #757205, put it before renderLegend to avoid render legend twice
                            if(this.isUsingSavedColorTheme) {
                                this.useSavedColorTheme();
                            }

                            if(this.isUsingDefaultColorTheme) {
                                this.useDefaultColorTheme();
                            }

                            this.initCanvas();
							//this.renderRectangles();
							this.renderLegend();
                            //init tooltip, so the delete button can be triggered
                            if(!this.infoBox)
                                    this.createInfoBox();

							// xiawang: apply the delete button style
							if (this.props.delButtonEnabled) {
								this.deleteButton.style.display = "block";
							}

							if(this.previousSelected && this.previousSelected.parentEntity){
                                //#763223, don't do a selection when we find a default selection, just highlight it
								this.highlightEntity(this.selectionHighlightBox, this.previousSelected);
                                //clear previousSelected so that it won't do a select all operation
                                /*var entity = this.previousSelected;
                                this.previousSelected = null;
                                this.doSelection(entity);*/
							}

							//this.enableGlobalDismiss();
//alert("end of postBuildRendering");

                        },

                        unrender: function(){
                                /*var div = document.getElementById(this.id+'-curtain');
                                if(div){
                                        div.parentNode.removeChild(div);
                                }*/

                                //this.removeGlobalListener();
                                //this.removeCurtain();
                                //store session info to doc model to persist information between re-creations
                                /*var cvm = this.controller.view.model;
                                if(!cvm.session){
                                        cvm.session = {};
                                }
                                cvm.session.dl = this.props.deletedList;
                                cvm.session.db = this.props.delButtonEnabled;*/
                                storeSession.call(this);


                                this.disableGlobalDismiss();
                                var $DAE = mstrmojo.dom.attachEvent,
                                    $DDE = mstrmojo.dom.detachEvent,
                                    TOUCHSTART = mstrmojo.dom.TOUCHSTART;
                                $DDE(this._tn, TOUCHSTART, this._tsCallback);
                                if(this.infoBox && this.infoBox.parentNode && this.infoBox.parentNode.parentNode)
                                        this.infoBox.parentNode.parentNode.removeChild(this.infoBox.parentNode);
                                delete this.infoBox;
                                //this.removeCSSFromHead();
                                if(this._super)
                                        this._super();
                        },

                        getFirstInfowindow: function getFirstInfowindow() {
                                var me = this,
                                    model = me.model,
                                    xtabModel = me.xtabModel,
                                    docModel = (xtabModel && xtabModel.docModel),
                                    row = model && model.gts && model.gts.row,
                                    tks;
                                if (row && row.length>0) {
                                        tks = row[0] && row[0].sc && row[0].sc.tks;
                                }
                                if (docModel && tks) {
                                        ifws = docModel.getTargetInfoWin(tks);
                                        if (ifws && ifws.length) {
                                                var ifwunit = docModel.infoWinByKey[ifws[0]];
                                                var id = ifwunit && (ifwunit.id + "_ifw");
                                                return mstrmojo.all[id];
                                        }
                                }
                        },

                        isInfoWindowDisplayed: function() {
                                var ifw = this.getFirstInfowindow();
                                if(ifw)
                                        ifw = ifw.domNode;
                                if(!ifw)
                                        return false;

                                if(ifw.style.display == 'block')
                                        return true;
                                else
                                        return false;
                        },

                        globalListener: function (){
                                ////alert("global");
                                var that = window.heatMap;
                                if(!that)
                                        return ;
                                that.hideInfoBox();
                                if(!that.selectAll)
                                        that.doSelection(that.previousSelected);
                        },


                        addGlobalListener: function() {
                                window.heatMap = this;
                                var p = document.getElementsByClassName('mstrmojo-DocLayoutViewer-layout')[0];
                                if(p)
                                        p.addEventListener(mstrmojo.dom.TOUCHSTART, window.heatMap.globalListener, false);
                        },

                        removeGlobalListener: function() {
                                var p = document.getElementsByClassName('mstrmojo-DocumentView')[0];
                                if(p)
                                        p.removeEventListener('click', this.globalListener, false);
                                delete window.heatMap;
                        },



                        addCurtain: function(){
                                var p = document.getElementsByClassName('mstrmojo-DocLayoutViewer-layout')[0];
                                var div = document.createElement('div'),
                                    //p = this.parent.domNode
                                    that = this;
                                div.style.width = p.offsetWidth + 'px';
                                div.style.height = p.offsetHeight+ 'px';
                                div.style.position = 'absolute';
                                //div.style.zIndex = parseInt(this.zIndex) - 1 + '' ;
                                div.style.zIndex = -1;
                                div.id = this.id + 'curtain';

                                div.onclick = this.globalListener;
                                p.appendChild(div);
                        },
                        removeCurtain: function(){
                                var div = document.getElementById(this.id+'curtain');
                                if(div)
                                        div.parentNode.removeChild(div);
                        },
                        renderErrorMessage: function renderErrorMessage(msg) {
                                var d = this.domNode,
                                    p = d.parentNode,
                                    div = document.createElement('div'),
                                    textDiv = document.createElement('div');

                                if(d){
////alert("domNode already exists.");
                                        div.style.width = d.offsetWidth - 2 + 'px' ;
                                        div.style.height = d.offsetHeight - 2 + 'px';
                                        div.style.left = d.offsetLeft + 'px';
                                        div.style.top = d.offsetTop + 'px';
                                        div.style.zIndex = this.zIndex ;
                                }else{
////alert("no domNode for displaying error message.");
                                        div.style.width = parseInt(this.width) - 2 + 'px';
                                        div.style.height = parseInt(this.height) - 2 + 'px';
                                        div.style.left = this.left;
                                        div.style.top  = this.top;
                                        div.style.zIndex = this.zIndex;
                                }

                                div.style.cssText += "background-color:#F5F5F2; position:absolute; display:-webkit-box; -webkit-box-pack:center; -webkit-box-align:center; -webkit-box-orient:vertical; border-style:solid; border-color:#A7A7A7; border-width:1px; ";
                                textDiv.className = "mstrmojo-message";
                                textDiv.innerText = msg;
                                div.appendChild(textDiv);
                                if(d)
                                        p.replaceChild(div, d);
                                else
                                        p.appendChild(div);
                        },

                        convertDPI: function(props) {
                                if(typeof props != 'object'){
                                        if(typeof props == 'number' && props%1 == 0)
                                                return adjustPixel.call(this, props);
                                        else
                                                return props;
                                }else{
                                        var ret = {};
                                        for(var key in props)
                                                ret[key] = this.convertDPI(props[key]);
                                        return ret;
                                }
                        },

						adjustLocalDPI: function(){
								// adjust the DPI
                                this.LayoutProperties = this.convertDPI(LayoutProperties);
                                this.LayoutProperties.LegendTickCount = 5;
                                this.LayoutProperties.LegendWidthPercent = 0.9;
                                this.LayoutProperties.LegendBandAspect = 10;
                                this.LayoutProperties.EditorDialogWidth = adjustPixel.call(this,565, true);
                                this.LayoutProperties.EditorDialogHeight = adjustPixel.call(this,574, true);
                                var h = document.body.offsetHeight,
                                    eh = this.LayoutProperties.EditorDialogHeight,
                                    sfh = h / eh,
                                    sf = 1;
                                if(sfh < 1){
                                        sf = sfh;
                                        sf *= 0.9;// to leave space for borders and paddings
                                        this.LayoutProperties.EditorDialogHeight = parseInt(eh * sf);
                                }

                                this.LayoutProperties.DeletedListHeight = adjustPixel.call(this,500*sf , true);
                                this.LayoutProperties.EditButtonWidth = adjustPixel.call(this,60);
                                this.LayoutProperties.EditButtonHeight = adjustPixel.call(this,40);
                                this.LayoutProperties.EditButtonRight = adjustPixel.call(this,10);
                                //this.Spec = this.convertDPI(Spec);
						},

						onorientationChange: function(){
								if(this.editorDialog){
										var domNode = this.editorDialog.domNode;
                                        if(domNode && domNode.firstChild){
                                                var d = domNode.firstChild, //content node
                                                    t = d.firstChild.firstChild;//title node
                                                d.style.marginTop = parseInt((document.body.offsetHeight - this.LayoutProperties.DeletedListHeight - t.offsetHeight)/2) + 'px';
                                        }
								}
						},


                        loadDefinedFormat: function() {
                                // xiawang: Heatmap has same problem as VisMicroChart when dealing with title bar. Hence we need to copy the title bar handling code
                                if (this.defn && this.defn.fmts) {
                                        var fmts = this.defn.fmts,
                                            pWidgetHeight = fmts && fmts.p_fmts && fmts.p_fmts.height;

                                        if (fmts.height) {
                                                this.height = fmts.height;
                                        }
                                        if(!this.isFullScreenWidget) {
                                                if (fmts.width) {
                                                        this.width = fmts.width;
                                                }
                                        }

                                        if (fmts["z-index"]) {
                                                this.zIndex = fmts["z-index"];
                                        }
                                }
                        },

                        checkErrors: function() {
                                var err = this.error;
                                if(err){
                                        this.renderErrorMessage(err);
                                        return true;
                                }
                                if (!this.model) {
                                        this.renderErrorMessage(mstrmojo.desc(8426,'No model provided'));
////alert("model error");
                                        return true;
                                }
                                var err = this.model.err || this.model.eg;
                                if (err) {
                                        this.renderErrorMessage(err);
////alert("model error");
                                        return true;
                                }
                                return false;
                        },


                        setupScroller: function(){
                                // setup scroller configuration.
                                var sclConfig = this.scrollerConfig;
                                sclConfig.scrollEl = this.scrollNode;
                                sclConfig.offset.x.start = 0;
                                sclConfig.offset.x.end = this.heatMapSize.w * (this.scaleFactor - 1);
                                sclConfig.offset.y.start = 0;
                                sclConfig.offset.y.end = this.heatMapSize.h * (this.scaleFactor - 1);
                                if (sclConfig.origin.x > sclConfig.offset.x.end) {
                                        sclConfig.origin.x = sclConfig.offset.x.end;
                                }
                                if (sclConfig.origin.y > sclConfig.offset.y.end) {
                                        sclConfig.origin.y = sclConfig.offset.y.end;
                                }
                        },




                        refreshLabelInTree: function(){
                                var getLabel = function(e, idx){
                                        if(e == this.root)
                                                return;
                                        var text = this.getLabelForEntity(e);
                                        e.text = text;
                                        e.idx = idx;
                                };
                                this.dfs(this.root, getLabel, "");
                        },

						refreshColorInTree: function() {
							var paintColor = function(e) {
                                    if(e.EntityChildren || e == this.root)
                                            return;
                                    //var color = hasColor ? w.colorTheme.getColor(getColorValue(entity,w)):Background_Color;
                                    var color = getCSSColor(this.colorTheme.getColor(getColorValue(e,this)));
                                    e.color = color;
							};
							this.dfs(this.root,paintColor,"");
						},

//						// t:termination
//						bfs: function(queue, level, f, t){
//							var nq = {};
//							while (queue.length ! = 0){
//								var o = queue.shift(),
//									e = o.e,
//									index = o.i;
//								f(e, index);
//								if(e.entityChildren !== undefined){
//									var ar = e.entityChildren,
//										l = ar.length;
//									for(var i = 0; i < l; i++){
//										var param = index;
//										if(param === undefined){
//											param = i;
//										}else{
//											param += ":" + i;
//										}
//										nq.push(e:ar[i], i:param);
//									}
//								}
//								level ++;
//								if(!t(level)){
//									this.bfs(nq, level, f);
//								}
//							}
//						}

						dfs: function (root, f, indexString) {
							if(root.deleted) {
								return;
							}
							if(indexString === undefined){
								f.call(this,root);
							}else{
								f.call(this,root, indexString);
							}

							if(root.entityChildren === undefined){
								return;
							}
							var arr = root.entityChildren,
								l = arr.length;
							for(var i = 0; i < l; i++){
								var e = arr[i];
								if(indexString === undefined){
									this.dfs(e, f);
								}else{
									var param = indexString;
									if (!param) {
										param = i.toString();
									} else {
										param = param + ":" + i;
									}
									this.dfs(e, f, param);
								}
							}
						},

						// level: starting level, up to 3 levels
						traverseBFS: function traverse(){
							var heatMap = this,
								canvas = this.textCanvas,
								renderText = function(e, indexString) {

								},
								terminate = function(level){
									var lv = level - heatMap.levelToShowText;
									if(lv >= 3) return false;
									return true;
								};
//							for(var i = 0; i < 3; i++){
//								var lv = this.levelToShowText;
//									arr = this.hierarchicalNodes[lv + i],
//									l = arr.length;
//								if(!arr) break;
//								for(var j = 0; j < l; j++){
//									var e = arr[j],
//										indexString = (lv+i) + ":" + j;
//									renderText(e, indexString);
//								}
//							}
						},

                        initCanvas: function() {
								this.refreshColorInTree();
                                this.refreshLabelInTree();
                                var props = {
                                        colorTheme: this.colorTheme,
                                        placeholder: this.canvas,
                                        root: this.root,
                                        width: this.heatMapSize.w,
                                        height: this.heatMapSize.h,
                                        scale: this.scaleFactor,
                                        attributes: this.levelAttributes,
                                        showMetric: this.props.showMetricValues,
                                        labelSetting: this.props.labelSize
                                };
                                this.canvasObject = new mstrmojo.VisHeatMapCanvas(props);
                                this.canvasObject.render();
                                this.canvasObject.updateOffsets(this._scroller.origin.x, this._scroller.origin.y);
                                this.canvas = this.canvasObject.domNode;
                        },


						renderRectangles: function(){
								this.refreshColorInTree();
                                this.refreshLabelInTree();
                                this.canvasObject.scale = this.scaleFactor;
                                this.canvasObject.offsetX =  this._scroller.origin.x;
                                this.canvasObject.offsetY =  this._scroller.origin.y;
                                this.canvasObject.draw();
						},

						renderLegend : function renderLegend() {
							if(this.props.showLegend == false) {
                                this.editorButton.style.height = '';
                                this.editorButton.style.width = '';
                                this.editorButton.style.right = '';
                                this.editorButton.style.bottom = '';

								this.editorButton.className = "heatmap-editor-legend-unshown";
								this.editorButton.innerHTML = "";
								this.editorButton.style.top = "";
								this.sizeLegend.style.display = "none";
								this.colorLegend.style.display = "none";
                                this.legend.style.left = '';
                                this.legend.style.top = '';
                                this.legend.style.right = '0px';
                                this.legend.style.bottom = '0px';
                                this.legend.style.zIndex = '100';
								return;
							}
                                var el = mstrmojo.desc(11158,'EDIT'),
                                rsl = mstrmojo.desc(10079,'Rectangle Size'),
                                rcl = mstrmojo.desc(10080,'Rectangle Color');

							this.editorButton.className = "heatmap-editor-button";
							this.editorButton.innerHTML = el;
							var w = parseInt(this.width), h = parseInt(this.height), canvasHeight = this.heatMapSize.h,
								computedStyle = window.getComputedStyle(this.editorButton,null),
								editorButtonHeight = parseInt(computedStyle['height']),
								editorButtonWidth = parseInt(computedStyle['width']),
                                legendHeight = this.legendSize.h,
                                legendWidth = this.legendSize.w - editorButtonWidth - parseInt(computedStyle['right']),
                                sfs = this.getFormatString(this.sizeMetricIndex);
							this.legend.style.top = this.heatMapSize.h  + 2*this.LayoutProperties.Padding + 'px';
							//this.legend.style.width = this.width ;
							//this.legend.style.height = legendHeight + 'px';
							//if(!this.lastFormateString)
								//this.lastFormateString = sfs;
							//this.editorButton.style.top = h - ((40+legendHeight)>>1) + "px";
							this.editorButton.style.top = ((legendHeight - editorButtonHeight)>>1) + "px" ;
							this.editorButton.style.bottom = "";
							if(this.props.showEditor){
								legendWidth -= this.LayoutProperties.LegendMenuEditorWidth;
							}
							var sizeT = {w:0, h:0}, sizeL = {w:0, h:0}, sizeSize = {w:0, h:0},
								tickCount, padding,
								bandWidth, bandHeight;
							if(this.props.sizeMetricEnabled){
								var sizeTitle = "<span style='font-weight: bold'>" + rsl + ":</span>";
								var vld = this.checkMetricValid(this.sizeMetricIndex),
									mn = this.getMetricName(this.sizeMetricIndex);
								if(this.hasNegativeSizeValue){
									mn = "Absolute value of " + mn;
								}
								if(isNaN(this.smin)){
									this.smin = 0;
									//sfs = this.lastFormateString;
								}
								//to avoid displaying "NaN" to users
								if(isNaN(this.smax))
									this.smax = 0;
								//if the name is too long, cut if off
								//if(mn.length > 25)
									//mn = mn.substr(0,25) + '...';


								var sizeLabel = "<div>" + (vld ? this.nf.formatByMask(sfs, this.smin) : "0")
												+ " < " + "</div>"
                                                + "<div class='heatmap-flex'>" + mn + "</div>"
                                                + "<div>" + " < "
												+ (vld ? this.nf.formatByMask(sfs, this.smax) : "0") + "</div>";
								//sizeT = this.getTextSize(sizeTitle, "Tahoma", '12pt', true);
								//sizeL = this.getTextSize(sizeLabel, "Tahoma", '12pt');
								//sizeSize = {w:Math.max(sizeT.w, sizeL.w), h:sizeT.h};
								this.sizeLegendTitle.innerHTML = sizeTitle;
								//this.sizeLegendTitle.style.height = sizeSize.h+"px";
								this.sizeLegendLabel.innerHTML = sizeLabel;
								//this.sizeLegendLabel.style.height = sizeSize.h+"px";
								//this.sizeLegend.style.display = "";
                                sizeSize = {w:Math.max(this.sizeLegendTitle.offsetWidth, this.sizeLegendLabel.offsetWidth), h: this.sizeLegendTitle.offsetHeight};
							}else{
								this.sizeLegend.style.display = "none";
							}
							if(this.props.colorMetricEnabled){
								var colorTitle;
								if( this.props.sizeMetricEnabled )
									colorTitle = rcl + ": " + "<span style='font-weight:normal;'>"
												 + this.getMetricName(this.colorMetricIndex)+ "</span>";
								else
									colorTitle = "<span style='font-weight:bold'>"
												 + this.getMetricName(this.colorMetricIndex)+ "</span>";
								tickCount = this.LayoutProperties.LegendTickCount;
								if(isNaN(this.cmin) || this.cmin >= this.cmax) {
									tickCount = 1;
								}
								this.legendTickCount = tickCount;
								//bandWidth = Math.min(LayoutProperties.LegendMaxBandWidth, LayoutProperties.LegendWidthPercent*legendWidth);
								bandWidth = Math.min(this.LayoutProperties.LegendMaxBandWidth, this.LayoutProperties.LegendWidthPercent*(legendWidth-sizeSize.w));
								padding = Math.floor((legendWidth - sizeSize.w - bandWidth)/3);
								var pd = this.renderTickLabels(bandWidth, tableHeight, tickCount);
								if(padding >= this.LayoutProperties.LegendMinPadding + pd.l + pd.r){
									bandWidth += pd.l + pd.r;
									padding -= ((pd.l + pd.r)>>1);
								}
								else if(padding < this.LayoutProperties.LegendMinPadding){
									padding = this.LayoutProperties.LegendMinPadding;
									var temp = ((legendWidth-3*padding)>>1);
									if(temp > sizeSize.w){
										bandWidth = legendWidth - 3*padding - sizeSize.w;
									}else{
										sizeSize.w = temp;
										bandWidth = sizeSize.w;
									}
								}
								bandHeight = Math.min(Math.floor(bandWidth/this.LayoutProperties.LegendBandAspect), Math.floor(legendHeight/3)) - this.LayoutProperties.LegendBottomPadding;
								this.colorLegend.style.display = "";
								//this.colorLegendTitle.style.height = sizeSize.h+"px";
								this.colorLegendTitle.innerHTML = colorTitle;
							}else{
								padding = ((legendWidth - sizeSize.w)>>1);
								this.colorLegend.style.display = "none";
							}
							if(this.props.sizeMetricEnabled){
								this.sizeLegend.style.left = padding + 'px';
								this.sizeLegend.style.width = sizeSize.w + this.LayoutProperties.LegendGutter + 2*this.LayoutProperties.Padding + 'px';
								//this.sizeLegend.top = h - legendHeight + 'px';
								this.sizeLegend.style.height = legendHeight + 'px';
								//this.sizeLegendLabel.style.marginTop = ((legendHeight - LayoutProperties.LegendBottomPadding-2*sizeSize.h)>>1) + 'px';
								//this.sizeLegendLabel.style.marginTop = legendHeight - LayoutProperties.LegendBottomPadding-2*sizeSize.h - 7 + 'px';//7 is the margin of size title, but as we will reset the top margin , so we don't need to minus the margin the size label it self.
							}
							else{
								this.sizeLegend.style.left = '0px';
								this.sizeLegend.style.width = '0px';
								this.sizeLegend.top =  '0px';
								this.sizeLegend.style.height = '0px';
								this.sizeLegendLabel.style.marginTop = '0px';
								padding = ((legendWidth - bandWidth)>>1);
							}

							if(this.props.colorMetricEnabled){
								//this.colorLegend.style.left = parseInt(this.sizeLegend.style.width) + parseInt(this.sizeLegend.style.left) + padding + 'px';
								if (this.props.sizeMetricEnabled)
									this.colorLegend.style.left = sizeSize.w + 2*padding + 'px';
								else
									this.colorLegend.style.left = sizeSize.w + padding + 'px';
								this.colorLegend.style.width = bandWidth + 'px';
								this.colorLegend.style.height = legendHeight + 'px';


								//sizeT = this.getTextSize(colorTitle, "Tahoma", '12pt',true);
                                sizeT = {w:this.colorLegendTitle.offsetWidth, h:this.colorLegendTitle.offsetHeight};
								var tableHeight = legendHeight - bandHeight - sizeT.h - 2*this.LayoutProperties.LegendBottomPadding;
								//var tableHeight = legendHeight - bandHeight - 11 - 2*LayoutProperties.LegendBottomPadding;
								this.colorLegendLabel.style.width = bandWidth + 'px';
								this.colorLegendLabel.style.height = tableHeight + 'px';

								this.colorLegendBand.width = bandWidth;
								this.colorLegendBand.height = bandHeight + 10;  // xiawang: add 10 transparent space just to accept touch event
								var pd = this.renderTickLabels(bandWidth, tableHeight, tickCount);
                                // #769634, clear the tooltip information so the information could always be updated
                                this.colorTheme.tooltipInfo = null;
								//if(this.legendBand && this.legendBand.w != bandWidth-pd.r-pd.l){
									//this.colorTheme.tooltipInfo = null;
								//}
								//debug_body = this;
								this.legendBand = {x:pd.l, y:0, w:bandWidth-pd.r-pd.l, h:bandHeight};
                                this.colorLegendBand.parentNode.style.width = bandWidth + 'px';
                                this.colorLegendBand.parentNode.style.height= bandHeight + 'px';

								this.renderGradientBand(this.legendBand);
							}
						},
						renderTickLabels: function renderLabel(w, h, t){
							var count = t + 1;
							var p = this.colorLegendLabel.firstChild.firstChild,
								nodes = p.childNodes,
								curCount = nodes.length,
								lastNode = p.lastChild,
								diff = curCount - count,
								cfs = this.getFormatString(this.colorMetricIndex);
							lastNode.style.display = "";
							lastNode.style.width = "";
							lastNode.style.textAlign = "center";
							if(diff < 0){
								for(var i = 0; i < Math.abs(diff); i++){
									var node = lastNode.cloneNode(true);
									p.insertBefore(node, lastNode.nextSibling);
									lastNode = node;
								}
							}
							else {
								for(var i = 0; i < diff; i++){
									if(t == 0 && i == diff-1){
										lastNode.style.display = "none";
										break;
									}
									//p.removeNode(lastNode);
									p.removeChild(p.lastChild);
									//lastNode = nodes.lastChild;
								}
							}
							p.firstChild.style.textAlign = "left";
							p.lastChild.style.textAlign = "right";
							var valid = true;
							if(isNaN(this.cmax) || isNaN(this.cmin)){
								valid = false;
							}
							for(var i = 0; i < count; i++){
								node = nodes[i];
								var v = "Null";
								if(valid){
									v = getNumberForTick.call(this, i);
								}
								node.innerHTML = '<div style="display: inline-block; overflow: hidden; text-overflow: ellipsis; max-width: 100%; white-space: nowrap;">' + this.nf.formatByMask(cfs, v) + '</div>';
								if(this.props.legendRounded){

								}
							}
							var firstV = p.firstChild.innerHTML,
								lastV = p.lastChild.innerHTML,
								//fSize = this.getTextSize(firstV, "Tahoma", '12pt'),
								//lSize = this.getTextSize(lastV, "Tahoma", '12pt'),
                                fSize = {w:p.firstChild.firstChild.offsetWidth, h:p.firstChild.firstChild.offsetHeight};
                                lSize = {w:p.lastChild.firstChild.offsetWidth, h: p.lastChild.firstChild.offsetHeight};
								left = Math.min(w/count, fSize.w)>>1,
								right = Math.min(w/count, lSize.w)>>1;

							return {l:left, r:right};

						},
						renderGradientBand: function renderBand(frame){
							var x = frame.x, y = frame.y, w = frame.w, h = frame.h,
								ctx = this.colorLegendBand.getContext("2d");
							ctx.clearRect(x, y, w+2, h);
							var lingrad = ctx.createLinearGradient(x,y,w+x,y);
							lingrad.addColorStop(0,"#333333");//display black if no metric value is valid
							var gradientInfo = this.colorTheme.getGradientFillInfo(this.cmin, this.cmax);
							var c = gradientInfo.c,
								r = gradientInfo.r,
								l = c.length;
							for(var i = 0; i < l; i++){
								lingrad.addColorStop(roundNumber(r[i], 2), getCSSColor(c[i]));
							}
							ctx.fillStyle = lingrad;
							createPath(x, y, w, h, 0, ctx);
							ctx.fill();
						},
						renderHilightedBand: function renderHighlightedBand(i){
							var frame = this.legendBand,
								info = this.colorTheme.tooltipInfo[i],
								x = frame.x, y = frame.y, w = frame.w, h = frame.h,
								ctx = this.colorLegendBand.getContext("2d");
							this.renderGradientBand(frame);
							this.selectedBandIndex = i;
							// draw highlighted bar
							ctx.strokeStyle = "#FFFFFF";
							ctx.lineWidth = 2;
							ctx.strokeRect(info.r.x+x+1, y+1, info.r.w-1, h-3);
						},

						getTextSize: function gts(str, fontName, fontSize, isBold, isItalic) {
							this.textSpan.style = "";
							this.textSpan.style.fontFamily = fontName;
							this.textSpan.style.fontSize = isNaN(fontSize) ? fontSize : fontSize + 'px';
							this.textSpan.style.fontWeight = isBold ? "bold" : "normal";
							this.textSpan.style.fontStyle = isItalic ? "italic" : "normal";
							this.textSpan.innerHTML = str;
							var w = this.textSpan.offsetWidth,
								h = this.textSpan.offsetHeight;
							return {w:w, h:h};
						},


						reRender : function reRender() {
							if (this.model.err || this.model.eg) {
								// #500786 should not render the error message
								// again just do nothing.
								return;
							}
                            if(this._super) {
                                    this._super();
                            }
						},

						useDefaultColorTheme: function(callback){
							var colorTheme = this.colorTheme,
								needsRefresh = false;
							if(colorTheme.useDefault == false){
								needsRefresh = true;
								colorTheme.isBlend = true;
								colorTheme.setDefaultDataProvider();
							}
							if (this.scaleFactor != 1) {
								needsRefresh = true;
								this.scaleFactor = 1;
							}

							// for default case, we mark everything as undeleted
							function markUndelete (delDict) {
								for (var key in delDict) {
									var childDict = delDict[key];
									if (typeof childDict === "object") {
										if (Object.keys(childDict).length === 0) { // empty object!
											delete delDict[key];
										} else { // else iterate children
											markUndelete(childDict);
										}
									} else if (childDict === delStatus.dftDel) { // if it's default deleted, mark it as default undeleted
										needsRefresh = true;
										delDict[key] = delStatus.dftUnDel;
									} else if (childDict === delStatus.usrDel) { // if it is user deleted, simply delete that key
										needsRefresh = true;
										delete delDict[key];
									}
								}
							};
							markUndelete(this.props.deletedList); // process deleted list first;
							this.loadDeleteStatus(this.root, this.props.deletedList);

							if(needsRefresh){
								colorTheme.tooltipInfo = null;
								this.refreshWidget();
							}
							if (callback) {
								callback();
							}
						},

						loadDeleteStatus: function (node, delDict) {
							if (!node.entityChildren) { // leaf node
								if (delDict === delStatus.dftDel || delDict === delStatus.usrDel) {
									node.deleted = true;
								} else { // for other cases, mark undeleted
									delete node.deleted;
								}
								return;
							}
							// non-leaf node
							if ((!delDict || Object.keys(delDict).length === 0) && !node.hasChildDeleted) { // don't need to go in
								return;
							}
							// for normal case
							var children = node.entityChildren;
							for (var i = 0; i < children.length; i++) {
								var child = children[i];
								var name = this.getEntityDisplayName(child);
								var thisDict = delDict && delDict[name];
								this.loadDeleteStatus(child, thisDict);
							}
						},

						useSavedColorTheme:function(callback){
							var colorTheme = this.colorTheme,
								needsRefresh = false;
							if(colorTheme.useDefault == true){
								needsRefresh = true;
								var propValue = this.model.vp;
								if(propValue){
									colorTheme.isBlend = ((propValue.blc === undefined || propValue.blc == "true") ? true:false);
								}
								if(propValue.gradientColors && propValue.bandColors){
									colorTheme.createDataProviderFromString(propValue.gradientColors, propValue.bandColors);
								}
								colorTheme.useDefault = false;
							}
							if (this.scaleFactor != 1) {
								needsRefresh = true;
								this.scaleFactor = 1;
							}

							// for saved case, we use dft settings and change delStatus.dftUnDel to delStatus.dftDel once found
							function markDelete (delDict) {
								for (var key in delDict) {
									var childDict = delDict[key];
									if (typeof childDict === "object") {
										if (Object.keys(childDict).length === 0) { // empty object!
											delete delDict[key];
										} else { // else iterate children
											markDelete(childDict);
										}
									} else if (childDict === delStatus.dftUnDel) { // if it's default undeleted, mark it as default deleted
										needsRefresh = true;
										delDict[key] = delStatus.dftDel;
									} else if (childDict === delStatus.usrDel) { // if it is user deleted, simply delete that key
										needsRefresh = true;
										delete delDict[key];
									}
								}
							};
							markDelete(this.props.deletedList); // process deleted list first;
							this.loadDeleteStatus(this.root, this.props.deletedList);

							if(needsRefresh){
								colorTheme.tooltipInfo = null;
								this.refreshWidget();
							}

							if (callback) {
								callback();
							}
						},

						getFormatString: function getFormatString(idx){
							var m = this.model,
								col = m.gvs.items[0] ? m.gvs.items[0].items:[],
								cnt = col.length;
							if(idx >= 0 && idx < cnt){
								var obj = col[idx];
								if(obj.formatstring !== undefined){
									return obj.formatstring.replace(/\'/g, '"');
								}
								return "";
							}
							return "";
						},

						checkMetricValid: function checkMetric(idx) {
							var str = "",
								m = this.model,
								col = m.ghs.chs.items,
								cnt = col.length,
								ml = col[0] ? col[0].items.length:0,
								coln = m.gts.col;
							if (idx < 0 || idx >= ml) return false;
							return true;
						},

						getMetricName: function getMetricName(idx){
							var str = "",
								m = this.model,
								col = m.ghs.chs.items,
								cnt = col.length,
								coln = m.gts.col;
							if(!this.checkMetricValid(idx)) return Fake_Metric_ID;
							for(var i = 0; i < cnt; i++){
								var index = col[i].items[idx].idx;
								var name = coln[i].es[index].n;
								str += name + " ";
							}
							return str.slice(0, str.length-1);
						},

						getEntityDisplayName: function getEntityDisplayName(e){
							var level = e.level,
								index = (e.index === undefined) ? e.indices[0] : e.index,
								st = 0, // start index
								str = "",
								ar = this.attSpan,
								rhs = this.model.ghs.rhs.items,
								rowHeaderData = rhs[index].items,
								att = this.model.gts.row[level];

							for(var i = 0; i < level; i++){
								st += ar[i];
							}
							str = "";
							for(var i = st; i < st + ar[level]; i++){
								var idx = rowHeaderData[i].idx;
								if(idx == -1)
									continue;
								str += att.es[idx].n + " ";
							}
							str = str.substring(0, str.length-1);
							return str;
						},

						previousTooltip: null,

                        previousSelected: null,


                        highlightEntity: function(box, entity) {
                                if(!entity || !box)
                                        return;
                                var w = this.canvasContainer.offsetWidth,
                                    h = this.canvasContainer.offsetHeight,
                                    size = entity.size,
                                    origin = this._scroller.origin,
                                    border = this.highlightBoxWidth,
                                    widgetRect = mstrmojo.dom.position(this.canvasContainer, true);

                                var container = {
                                        x: origin.x,
                                        y: origin.y,
                                        w: w,
                                        h: h
                                };

                                var canvasRect = {
                                        x: 0,
                                        y: 0,
                                        w: Math.ceil(this.heatMapSize.w * this.scaleFactor),
                                        h: Math.ceil(this.heatMapSize.h * this.scaleFactor)
                                };

                                //outer rectangle, including the border, it's the final area showing on the screen
                                var rect = {
                                        x: size.x - border,
                                        y: size.y - border,
                                        w: size.w + 2*border,
                                        h: size.h + 2*border
                                };

                                var inters = rectIntersection(rect, canvasRect);

                                if(box == this.highlightBox){
                                        inters = rectIntersection(inters, container);
                                        this.previousHighlighted = entity;
                                }


                                if (isNaN(inters.x)) {
                                        return null;
                                }

                                //inner rectangle, to canvasContainer
                                inters.x += (border - origin.x);
                                inters.y += (border - origin.y);
                                inters.w -= 2*border;
                                inters.h -= 2*border;


                                if(box == this.highlightBox){
                                        box.style.left = inters.x  - border + widgetRect.x + "px";
                                        box.style.top = inters.y - border  + widgetRect.y + "px";
                                        inters.x += widgetRect.x;
                                        inters.y += widgetRect.y;
                                }else {
                                        box.style.left = inters.x  - border + "px";
                                        box.style.top = inters.y - border + "px";
                                }
                                box.style.width = inters.w + "px";
                                box.style.height = inters.h + "px";
                                box.style.display = "block";


                                return inters;
                        },

						getLowestLevelRectangle: function(touch){
									target = document.elementFromPoint(touch.pageX, touch.pageY);
									var hiddenStack = [];
									//while (target !== this.domNode && target.innerHTML) { // this is probably a label
									while(!this.isLowestLevelRectangle(target)){
										target.style.display = "none";
										//$CSS.removeClass(target,cssShow);
										hiddenStack.push(target); // hide it and push it to stack
										target = document.elementFromPoint(touch.pageX, touch.pageY);
									}
									while (hiddenStack.length) { // pop all items from stack and set visible
										hiddenStack.pop().style.display = "block";
										//$CSS.addClass(target,cssShow);
									}
									return target;
						},

						getEntityByTouch: function(touch,getLowest) {
                                //console.log("in getEntityByTouch");
								var entity = null;
                                /*if(touch.evt._pagePosition){
//console.log("#getEntityByTouch# got pageX/Y !");
                                        var pageX = touch.evt._pagePosition.pageX,
                                            pageY = touch.evt._pagePosition.pageY;
                                }else{
                                        var pageX = touch.pageX,
                                            pageY = touch.pageY;
                                }
                                if(touch.evt._target){
                                        console.log("#getEntityByTouch# got _target");
                                }
                                if(touch.evt._pagePosition){
                                        console.log("#getEntityByTouch# got _pagePosition");
                                }*/
                                var pageX = touch.pageX,
                                    pageY = touch.pageY;
console.log("#getEntityByTouch#" + "pageX:" + pageX + " " + "pageY:" + pageY);
								var target = document.elementFromPoint(pageX,pageY),
									backUps = [];

								if(!target) {
                                    console.log("target is null! at elementFromPoint.");
									return null;
                                }
                                //console.log(target);
                                var lastLevel = target;
								while(!this.isRectangle(target) && target != this.domNode){
										backUps.push(target);
										target.style.visibility = 'hidden';
										target = document.elementFromPoint(pageX,pageY);
										if(!target || target == lastLevel)
											break ;
                                        lastLevel = target;
								}
                                //continue to search if we need the lowest entity
                                if(getLowest){
                                        lastLevel = target;
                                        while(target != this.domNode && target.tagName.toLowerCase() != 'img'){
                                                backUps.push(target);
                                                target.style.visibility = 'hidden';
                                                target = document.elementFromPoint(pageX,pageY);
                                                //if(target == lastLevel)
                                                        ////alert("hidden element can still be selected!");
                                                if(!target || target == lastLevel)
                                                        break ;
                                                lastLevel = target;
                                        }
                                }

								var backLen = backUps.length;
								while(backUps.length > 0){
										var node = backUps.pop();
										node.style.visibility = 'visible';
								}
								if(!target) {
                                    console.log("target is null. At backups.");
									return null;
                                }
                                //console.log(target);
								if(target != this.domNode){
										if (target.getAttribute('idx') && !getLowest) {
												var entity = this.getIdxObjectByTarget(target);
										}
										else{
                                                var rectPosition = mstrmojo.dom.position(this.canvas,true),
                                                offsetX = pageX - rectPosition.x,
                                                offsetY = pageY - rectPosition.y;
                                                var position = {x:offsetX,y:offsetY},
                                                    entity = this.canvasObject.getEntity(position);
                                                //console.log("position: " + position.x + ', ' + position.y);
                                                /*if(entity) {
                                                        console.log(entity);
                                                }*/
                                                ////alert(position.x+":"+position.y);
										}
								} else {
                                        //console.log("the target is the domNode of the widget. That's not scientific!");
                                }
                                ////alert(!entity);
                                //console.log(entity);
								return entity;
						},
						getLabelForEntity : function(e) {
                            if(!this.props.showMetricValues || e.entityChildren !== undefined)
                                    return this.getEntityDisplayName(e);
							var	index = (e.index === undefined) ? e.indices[0] : e.index,
								st = '',
								si = this.sizeMetricIndex,
								ci = this.colorMetricIndex,
								mv = this.model.gvs.items,
								ml = mv[0].items.length,
								n, v,
                                dn = this.getEntityDisplayName(e);

							st = '<span style="font-weight:bold;">';
                            // #762301, don't show an empty line if the display name is null
                            if(dn !== '') {
                                st += dn + '<br>';
                            }
							if(si != ml){
								if(e.entityChildren !== undefined || this.aggregated){
									var tmp = this.aggFunctions[si];
									v = getSizeValue(e, this);
									if(isNaN(v)){
										v = '-';
									}
									else if(AggregationType.Cnt != tmp){
										fs = this.getFormatString(si);
										v = this.nf.formatByMask(fs, v);
									}
								}else{
									v = mv[index].items[si].v;
								}
                                if(v !== ''){
                                    st += v + '<br>';
                                }
							}
							if(e.entityChildren === undefined && ci != ml && si != ci){
								if(e.entityChildren !== undefined || this.aggregated){
									var tmp = this.aggFunctions[ci];
									v = getColorValue(e, this);
									if(isNaN(v)){
										v = '-';
									}
									else if(AggregationType.Cnt != tmp){
										fs = this.getFormatString(ci);
										v = this.nf.formatByMask(fs, v);
									}
								}else{
									v = mv[index].items[ci].v;
								}
                                if(v !== '') {
                                    st += v + '<br>';
                                }
							}
							st += '</span><span style="font-weight:normal;">';
							for(var i = 0; i < ml; i++){
								if(i == si) continue;
								if(i == ci && e.entityChildren === undefined && si != ci) continue;
								if(e.entityChildren !== undefined || this.aggregated){
									var tmp = this.aggFunctions[i];
									n = tooltipMacro(n, tmp);
									v = getAggValue(e, i, this);
									if(isNaN(v)){
										v = '-';
									}
									else if(AggregationType.Cnt != tmp){
										fs = this.getFormatString(i);
										v = this.nf.formatByMask(fs, v);
									}
								}else{
									v = mv[index].items[i].v;
								}
                                if(v !== '') {
                                    st += v;
                                    if(i !== ml-1){
                                        st += '<br>';
                                    }
                                }
							}
							st += '</span>';
							return st;
						},




						multiTap: true,
                        touchBegin: function(touch) {
                                //stop bubble to avoid the curtain doing something
                                //touch.evt.stopPropagation();
                        },
						touchTap: function (touch) {
								if (touch.count >= 2) { // multiple count? then resize back to normal size
										if (this.scaleFactor > 1) {
												this.scaleFactor = 1;
												this._scroller.offset.x.start = 0;
												this._scroller.offset.x.end = 0;
												this._scroller.offset.y.start = 0;
												this._scroller.offset.y.end = 0;
												this._scroller.scrollTo(0, 0, 0);
												this.refreshWidget();
										}
										return;
								}
								// else, single tap


								//debug
								//this.controller.onorientationChange();

								var target = touch.target;
                                //if users click on infoBox, we need to know which part they clicked
                                if(target == this.infoBoxPuppet){
                                    target = document.elementFromPoint(touch.pageX, touch.pageY);
                                }
//console.log('#touchtap# className:' + target.className);
								if(this.touchLegendTooltipValid(touch))
										this.showLegendTooltip(touch);
								else
										this.hideLegendTooltip();
								switch(target){
										case this.editorButton:{
												target.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
												var callback = function () {
														mstrmojo.VisHeatMapAnimation.animate(target, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
												};
												var that = this;
												setTimeout(function(){
														setTimeout(function(){
																try {
																		that.popupEditor(target);
																} catch (e) {
																} finally {
																		callback();
																}
														}, 0);
												}, 0);

												return; // TQMS 580580, do not hide tooltips if editorButton is clicked
										}
										case this.deleteButton:{
                                                if (this.previousTooltip) {
                                                        var delDict = this.props.deletedList;
                                                        var delNode = this.previousTooltip;
                                                        // shrink delDict to the same level as delNode
                                                        var keyStack = [];
                                                        var tempNode = delNode;
                                                        do { // at least once
                                                                keyStack.push(this.getEntityDisplayName(tempNode));
                                                                tempNode = tempNode.parentEntity;
                                                        } while (tempNode.parentEntity);
                                                        var parentDict, key;
                                                        for (var i = keyStack.length - 1; i >= 0; i--) { // we make sure there is only one key left in dict
                                                                parentDict = delDict;
                                                                key = keyStack.pop();
                                                                var tempDict = delDict[key];
                                                                if (!tempDict) {
                                                                        delDict[key] = {};
                                                                        tempDict = delDict[key];
                                                                }
                                                                delDict = tempDict;
                                                        }
                                                        this.deleteNode(delNode, delDict, parentDict, key);
                                                        this.hideInfoBox();
                                                        this.refreshWidget();
                                                        // todo;
                                                        var deleteTreeId = this.id + "-deleteTree";
                                                        var object = mstrmojo.all[deleteTreeId];
                                                        if (object) {
                                                                object.needRefresh = true;
                                                        }
                                                }
                                                this.previousTooltip = null;
                                                break;
										}

										case this.selectionHighlightBox: {
												this.doSelection(this.previousSelected);
												break;
										}

                                        case this.highlightBox: {
                                                this.hideInfoBox();
                                                var entity = this.previousHighlighted;
                                                if(this.hasSelector){
                                                        if(!this.previousHighlighted.entityChildren){
                                                                this.doSelection(entity);
                                                                //this.doInfoWindow(entity);
                                                        }
                                                }
                                                else if(this.hasLinkDrill){
                                                        this.doLinkDrill(entity);
                                                }
                                                break;
                                        }



										default:{
												//1. selection  2.linkDrill 3.showInfoBox
                                                if(this.isRectangle(target)){
                                                        if(this.hasSelector){
                                                                this.hideInfoBox();
                                                                var entity = this.getEntityByTouch(touch,true);
                                                                //do selection and show info window(if any)
                                                                this.doSelection(entity);
                                                                //console.log("do selection");
                                                        }
                                                        else if(this.hasLinkDrill){
                                                                var entity = this.getEntityByTouch(touch);
                                                                this.doLinkDrill(entity);
                                                        }
                                                        else {
                                                                var entity = this.getEntityByTouch(touch);
                                                                this.showInfoBox(entity);
                                                                //console.log("show info box");
                                                        }

														break;
												}
                                                //infobox
												else if(target.parentNode == this.infoBox){
                                                        this.hideInfoBox();
                                                }else{
														this.hideInfoBox();
                                                        if(!this.selectAll){
                                                                this.doSelection(this.previousSelected);
                                                        }
												}
										}
								}
						},

						isRectangle: function(target){
							if(this.canvasObject.domNode == target.parentNode || (target.parentNode && this.canvasObject.domNode == target.parentNode.parentNode) || target.tagName.toLowerCase() == 'img')
								return true;
							else
								return false;
						},
						isLowestLevelRectangle: function(target){
							if(target.getAttribute && target.getAttribute("idx") && !(target.innerHTML))
								return true;
							else
								return false;
						},

						doLinkDrill: function(entity){
								if(!entity)
									return;
								var actionObj = this.getActionObj({entity: entity, type:HYPERLINK_ACTION});
								if(actionObj){
										this.highlightEntity(this.selectionHighlightBox,entity);
										this.performAction([actionObj]);
								}
						},


						/*touchTap: function (touch) {
							if (touch.count >= 2) { // multiple count? then resize back to normal size
								if (this.scaleFactor > 1) {
									this.scaleFactor = 1;
									this._scroller.offset.x.start = 0;
									this._scroller.offset.x.end = 0;
									this._scroller.offset.y.start = 0;
									this._scroller.offset.y.end = 0;
									this._scroller.scrollTo(0, 0, 0);
									this.refreshWidget();
								}
								return;
							}
							// else, single tap
							var target = touch.target;
							if (target === this.editorButton){
								target.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
								var callback = function () {
									mstrmojo.VisHeatMapAnimation.animate(target, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
								};
								var that = this;
								setTimeout(function(){
									setTimeout(function(){
										try {
											that.popupEditor(target);
										} catch (e) {
										} finally {
											callback();
										}
									}, 0);
								}, 0);

								return; // TQMS 580580, do not hide tooltips if editorButton is clicked
							}
							if(this.touchLegendTooltipValid(touch)){
								this.showLegendTooltip(touch);
							}else{
								this.hideLegendTooltip();
							}
							if (target === this.deleteButton) {
								if (this.previousTooltip) {
									var delDict = this.props.deletedList;
									var delNode = this.previousTooltip;
									// shrink delDict to the same level as delNode
									var keyStack = [];
									var tempNode = delNode;
									do { // at least once
										keyStack.push(this.getEntityDisplayName(tempNode));
										tempNode = tempNode.parentEntity;
									} while (tempNode.parentEntity)
									var parentDict, key;
									for (var i = keyStack.length - 1; i >= 0; i--) { // we make sure there is only one key left in dict
										parentDict = delDict;
										key = keyStack.pop();
										var tempDict = delDict[key];
										if (!tempDict) {
											delDict[key] = {};
											tempDict = delDict[key];
										}
										delDict = tempDict;
									}
									this.deleteNode(delNode, delDict, parentDict, key);
									this.refreshWidget();
									// todo;
									var deleteTreeId = this.id + "-deleteTree";
									var object = mstrmojo.all[deleteTreeId];
							    	if (object) {
							    		object.needRefresh = true;
							    	}
								}
								this.previousTooltip = null;
							}

							//if it's not a rectangle
							if(!target.getAttribute || !target.getAttribute("idx")){
									if(this.infoBox.style.display != "none"){
											this.hideInfoBox(); // hide InfoBox anyway
									}
							}
							else{
								if(this.hasSelector){
									this.doSelection(target);
								}
								else if (this.hasLinkDrill){
									var actionObj = this.getActionObj({target: target, type:HYPERLINK_ACTION});
									if(actionObj){
										this.highlightEntity(this.selectionHighlightBox,this.getIdxObjectByTarget(target));
										this.performAction(actionObj);
									}
								}
								else{
										//display infobox if there is no selector or link drill(currently only necessary to check selector since drill link is not supported on android.
										//var idxObject = this.getIdxObjectByTarget(target);
										//var isSelector = this.model.gts.row[idxObject["level"]].sc;
										//if(!isSelector)
										this.showInfoBox(target);
								}

							}

						},*/

						getActionObj: function(actionInfo) {
							if(!actionInfo)
								return null;
							var actionType = actionInfo.type,
								entity = actionInfo.entity,
								actionObj = null;

							switch(actionType){
									case HYPERLINK_ACTION: {
                                            //row
                                            var rowHeader = this.model.gts.row,
                                                rl = rowHeader.length,
                                                level = entity['level'],
                                                attrIndex;
                                            for(var i = 0; i <= level; i++){
                                                    var attr = rowHeader[i];
                                                    if(attr.lm){
                                                            for(var j = 0; j < attr.lm.length; j++)
                                                                if(attr.lm[j].links)break;
                                                            if(j != attr.lm.length){
                                                                    attrIndex = i;
                                                                    break;
                                                            }
                                                    }
                                            }
                                            var rowIndex = (entity.index === undefined) ? entity.indices[0] : entity.index,
                                                ghs = this.model.ghs;

											if(!isNaN(attrIndex)){
                                                    var attr = this.model.gts.row[attrIndex];
                                                        linkDrillNode = {};
                                                    linkDrillNode.titleInfo = attr;
                                                    linkDrillNode._e = attr.es[ghs.rhs.items[rowIndex].items[attrIndex].idx];//use the first element with a linkdrill in the row to answer
                                                    actionObj = {at:actionType, k: this.getModelKey(), node: linkDrillNode};
                                                    break;
                                            }

											//col
											index = this.firstColLinkDrillIndex;
											if(!isNaN(index)){
													var metricH = this.model.gts.col[0],
														metric = metricH.es[index],
														lm = metricH.lm[index];
													if(lm && lm.links){
														linkDrillNode = {};
														linkDrillNode.titleInfo = metricH;
														linkDrillNode.mix = index;
														actionObj = {at: actionType, k: this.getModelKey(), node: linkDrillNode};
													}
                                                    break;
											}

											break;
									}

							case SELECTOR_ACTION: {
                                    var entity = actionInfo.entity,
                                        anchor = actionInfo.anchor;
									if(!entity || !anchor){
											//console.log("invalid action info for action" + actionType);
											break;
									}

									if(entity){
											var m = this.model,
											rown = m.gts.row, // row headers
											rl = rown.length,
											rhs = m.ghs.rhs.items,
											index = (entity.index === undefined) ? entity.indices[0] : entity.index,
											row = rhs[index].items,
											selectorObjects = [];
											for(var i = 0; i < rl; i++){//what if selector is on customer group? rl is not right
													var att = rown[i],
													sc = att.sc;
													if(att.otp != -1 && sc !== undefined){
															var ix = row[i].idx,
															elementId = att.es[ix].id,
															//es = att[ix].n,
															//eid = att[ix].id;
															es = att.es[ix].n,
															eid;
															if (!elementId || elementId.substring(0, 1) === "D") {
																	// xiawang: jump for subtotal and empty ID;
																	continue;
															};
															if(sc.all != 'false' && sc.all != false && actionInfo.needSelectAll)
																eid = EID_SELECTALL;
															else
																eid = att.es[ix].id;
															selectorObjects.push({ // push this element selection info to event
																	//ck: sc.ck,
																	//ctlKey: sc.ckey,
																	//tks: sc.tks,
																	sc: sc,
																	es: es,
																	eid: eid
															});
													}
                                            }
                                            actionObj = {at:actionType, k:this.getModelKey(), scObjList: selectorObjects,anchor:anchor};
									}


									break;
							}
                            //the codes are totally the same as selector, only an anchor added in the returned object
							case INFOWINDOW_ACTION: {
									var entity = actionInfo.entity,
									anchor = actionInfo.anchor;
									if(!entity || !anchor){
//console.log("invalid action info for action" + actionType);
											break;
									}

									if(entity){
											var m = this.model,
											rown = m.gts.row, // row headers
											rl = rown.length,
											rhs = m.ghs.rhs.items,
											index = (entity.index === undefined) ? entity.indices[0] : entity.index,
											row = rhs[index].items,
											selectorObjects = [];
											for(var i = 0; i < rl; i++){//what if selector is on customer group? rl is not right
													var att = rown[i],
													sc = att.sc;
													if(att.otp != -1 && sc !== undefined){
															var ix = row[i].idx,
															elementId = att.es[ix].id,
															//es = att[ix].n,
															//eid = att[ix].id;
															es = att.es[ix].n,
															eid;
															if (!elementId || elementId.substring(0, 1) === "D") {
																	// xiawang: jump for subtotal and empty ID;
																	continue;
															};
															if(sc.all != 'false' && sc.all != false && actionInfo.needSelectAll)
																eid = EID_SELECTALL;
															else
																eid = att.es[ix].id;
															selectorObjects.push({ // push this element selection info to event
																	//ck: sc.ck,
																	//ctlKey: sc.ckey,
																	//tks: sc.tks,
																	sc: sc,
																	es: es,
																	eid: eid
															});
													}
											}
													actionObj = {at:actionType, k:this.getModelKey(), scObjList: selectorObjects, anchor: anchor};
									}


									break;
							}
									default: {
//console.log("invalid action type");
											break;
									}

							}
							return actionObj;
						},
						getModelKey: function(){
							return this.model && this.model.k;
						},

						deleteNode: function (node, delDict, parentDict, key) { // this function will recursively find its leaft nodes and mark deleted on them, also make a sign on deletedTree
                            // #767369, we don't show a node in heatmap, if the size-by values of its children are all null
                            if(!(node.size && node.size.w && node.size.h)){
                                return ;
                            }
							if (!node.entityChildren) { // if this is a leaf node, just delete it
								node.deleted = true;
								if (parentDict && key) {
									if (delDict === delStatus.dftUnDel || delDict === delStatus.dftDel) { // this goes to stored delete
										parentDict[key] = delStatus.dftDel;
									} else { // this goes to user delete
										parentDict[key] = delStatus.usrDel;
									}
								}
								return;
							} else {
								parentDict = delDict;
								for (var index in node.entityChildren) {
									var thisChild = node.entityChildren[index];
									key = this.getEntityDisplayName(thisChild);
									var thisDict = parentDict[key];
									if (!thisDict) {
										parentDict[key] = {};
										thisDict = parentDict[key];
									}
									this.deleteNode(thisChild, thisDict, parentDict, key);
								}
							}
						},

                        // return true if toggle succeed, otherwise false
						toggleSelectAll: function(entity){
                                var sc = this.model.gts.row[entity.level].sc;
                                if((sc && sc.all != 'false' && sc.all != false) || !this.hasGridTarget){
                                        if(this.selectAll)
                                                this.selectAll = false;
                                        else
                                                this.selectAll = true;
                                        return true;
                                }
                                return false;
						},
						doSelection: function(entity){
							if(!entity)
								return ;
							if(entity == this.previousSelected){
                                // if cannot toggle, do nothing
                                if(!this.toggleSelectAll(entity))
                                        return;

                                //if actionOjb has property "anchor", then the document will try to display a info window if there is any
								var anchor = this.selectionHighlightBox,
                                    actionInfo = {entity: entity, type:SELECTOR_ACTION, needSelectAll:this.selectAll, anchor:anchor};
							        actionObject = this.getActionObj(actionInfo);
								if(this.selectAll){//dismiss the highlight box and infowindow(if any)
									//$CSS.removeClass(this.selectionHighlightBox,cssShow);
									this.selectionHighlightBox.style.display = "none";
                                    delete actionObject.anchor;
                                }
								else
									this.highlightEntity(this.selectionHighlightBox,entity)
								this.performAction([actionObject]);
								//console.log("a selector has been applied.");
							}
							else{
								this.selectAll = false;
								var anchor = this.selectionHighlightBox,
                                    actionInfo = {entity: entity, type:SELECTOR_ACTION, needSelectAll:this.selectAll, anchor:anchor};
								this.previousSelected = entity;
								this.highlightEntity(this.selectionHighlightBox,entity);
							    var actionObject = this.getActionObj(actionInfo);
								this.performAction([actionObject]);
								//console.log("a selector has been applied.");
							}
						},

						getObjectByIdx: function (idx) {
							if (idx) {
								var indexArray = idx.split(":");
								var obj = this.root;
								for (var i = 0; i < indexArray.length; i++) {
									obj = obj.entityChildren[indexArray[i]];
								}
								return obj;
							}
							return null;
						},


						toggleDeleteButton: function () {
                            if(!this.infoBox)
                                    return;
							//if(this.deleteButton.className.indexOf(cssShow) != -1)
								//$CSS.removeClass(this.deleteButton,cssShow);
								//this.deleteButton.style.display = "none";
							//else
								//$CSS.addClass(this.deleteButton,cssShow);
								//this.deleteButton.style.display = "block";

							if (this.props.delButtonEnabled) {
								this.deleteButton.style.display = "none";
                                this.props.delButtonEnabled = false;
							} else {
								this.deleteButton.style.display = "block";
                                this.props.delButtonEnabled = true;
							}
						},


						editorDialog: null,  /* editor dialog looks like singleton to a VisHeatMap instance*/


						popupEditor: function (anchor) {
                                this.hideInfoBox();
                                var heatmapId = this.id;
                                var deleteTreeId = heatmapId + "-deleteTree";
                                var editorId = heatmapId + "-editor";
								var that = this;

								var defaultSelectionStatus = 0;
								if (this.props.delButtonEnabled) {
									defaultSelectionStatus = 1;
								}
                                var strSettings = mstrmojo.desc(7831, 'Settings'),
                                    strDeletedItems = mstrmojo.desc(10081, 'Deleted Items'),
                                    strRefresh = mstrmojo.desc(10378, 'REFRESH'),
                                    strRTSC = mstrmojo.desc(10082, 'Refresh to saved configuration'),
                                    strRTDC = mstrmojo.desc(10083, 'Refresh to default configuration'),
                                    strApply = mstrmojo.desc(10379, 'APPLY'),
                                    strDelete = mstrmojo.desc(10380, 'DELETE'),
                                    strEnableDelete = mstrmojo.desc(10085, 'Enable Delete'),
                                    strRestore = mstrmojo.desc(10084, 'Please select elements that you want to restore'),
                                    strButtonCancel = mstrmojo.desc(221, 'Cancel'),
                                    strButtonApply = mstrmojo.desc(134, 'Apply');


								var prop = {
									anchor: this.editorButton,
									title: "Heat Map",
									id: editorId,
									anchorOrientation: "h",
									width: this.LayoutProperties.EditorDialogWidth + 'px',
                                    //marginTop: parseInt((document.body.offsetHeight - this.LayoutProperties.EditorDialogHeight)/2) + 'px',
								    contentMaxHeight: this.LayoutProperties.DeletedListHeight,
									panels: [{
										//title: "Settings",
                                        title: strSettings,
										scriptClass: "mstrmojo.VisHeatMapPopupPanel",
                                        width: "100%",
									    height: "100%",
										children:[
										       {
										    	   scriptClass: 'mstrmojo.Label',
											       //text: "REFRESH",
                                                   text: strRefresh,
                                                   cssDisplay: "-webkit-box",
                                                   cssClass: "heatmap-gray-label"
                                                   //cssText: grayLabelCssText
										       },
										       {
										    	   scriptClass: 'mstrmojo.VisHeatMapTree',
                                                   showIndicators: false,
										    	   isSelectable: false,
										    	   cssClass: "simple-tree",
										    	   cssText: "padding-left:15px;padding-right:15px;",
										    	   buttonNodeCss: "",//"heatmap-tree-button",
										    	   items: [
										    	           {
										    	        	   //n: "Refresh to saved configuration",
                                                               n: strRTSC,
										    	        	   buttonNodeWidget: {
										    	        		   scriptClass: 'mstrmojo.Button',
																   //text: "APPLY",
                                                                   text: strApply,
																   cssClass: "heatmap-apply-button",
										    	        		   onclick: function () {
                                                                       that.isUsingSavedColorTheme = true;
                                                                       that.isUsingDefaultColorTheme = false;
															    	   var node = this.domNode;
															    	   node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
															    	   that.hideInfoBox();
															    	   that.hideLegendTooltip();

															    	   // TQMS 586596, revert scale factor back as well as scroller position back
															    	   //that.scaleFactor = 1; // put this code inside that.useSavedColorTheme to cleverly detect if we need to refresh
															    	   that._scroller.offset.x.start = 0;
															    	   that._scroller.offset.x.end = 0;
															    	   that._scroller.offset.y.start = 0;
															    	   that._scroller.offset.y.end = 0;
															    	   that._scroller.scrollTo(0, 0, 0);

															    	   var callback = function () {
															    		   mstrmojo.VisHeatMapAnimation.animate(node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
															    	   };
															    	   setTimeout(function () {
														    		   		setTimeout(function () {
														    		   			that.useSavedColorTheme(callback);
														    		   			var object = mstrmojo.all[deleteTreeId];
																		    	if (object) {
																		    		object.needRefresh = true;
																		    	}
														    		   		}, 0);
														    		   },0); // use two level setTimeout so that we make sure the dom get refreshed first
										    	        		   }
										    	        	   }
										    	           },
										    	           {
										    	        	   //n: "Refresh to default configuration",
                                                               n: strRTDC,
										    	        	   buttonNodeWidget: {
										    	        		   scriptClass: 'mstrmojo.Button',
																   //text: "APPLY",
                                                                   text: strApply,
																   cssClass: "heatmap-apply-button",
										    	        		   onclick: function () {
                                                                       that.isUsingSavedColorTheme = false;
                                                                       that.isUsingDefaultColorTheme = true;
															    	   var node = this.domNode;
															    	   node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
															    	   that.hideInfoBox();
															    	   that.hideLegendTooltip();

															    	   // TQMS 586596, revert scale factor back as well as scroller position back
															    	   //that.scaleFactor = 1; // put this code inside that.useDefaultColorTheme to cleverly detect if we need to refresh
															    	   that._scroller.offset.x.start = 0;
															    	   that._scroller.offset.x.end = 0;
															    	   that._scroller.offset.y.start = 0;
															    	   that._scroller.offset.y.end = 0;
															    	   that._scroller.scrollTo(0, 0, 0);

															    	   var callback = function () {
															    		   mstrmojo.VisHeatMapAnimation.animate(node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
															    	   };
															    	   setTimeout(function () {
														    		   		setTimeout(function () {
														    		   			that.useDefaultColorTheme(callback);
														    		   			var object = mstrmojo.all[deleteTreeId];
																		    	if (object) {
																		    		object.needRefresh = true;
																		    	}
														    		   		}, 0);
														    		   }, 0); // use two level setTimeout so that we make sure the dom get refreshed first

															       }
										    	        	   }
										    	           }
										    	   ]
										       },
										       {
										    	   scriptClass: 'mstrmojo.Label',
											       //text: "DELETE",
                                                   text: strDelete,
                                                   cssDisplay: "-webkit-box",
                                                   cssClass: "heatmap-gray-label"
                                                   //cssText: grayLabelCssText
										       },
										       {
										    	   scriptClass: 'mstrmojo.VisHeatMapTree',
										    	   isSelectable: true,
										    	   cssClass: "simple-tree",
										    	   cssText: "margin-left:15px;margin-right:15px;",
                                                   showIndicators: false,
										    	   defaultSelectionStatus: defaultSelectionStatus,
										    	   items: [
										    	           {
										    	        	   //n: "Enable Delete",
                                                               n: strEnableDelete,
										    	        	   itemFunction: function () {
																		that.toggleDeleteButton();
															   }
										    	           }
										    	   ]
										       },
										]
									}, {
										//title: "Deleted Items",
                                        title: strDeletedItems,
										scriptClass: "mstrmojo.VisHeatMapPopupPanel",
                                        cssText: "position: relative",
										//width: "565px",
										//height: "500px",
                                        //height: this.LayoutProperties.DeletedListHeight + 'px',
                                        //width: this.LayoutProperties.EditorDialogWidth + 'px',
                                        width: "100%",
                                        //height: "100%",
										naviAction: function () {
											var object = mstrmojo.all[deleteTreeId];
									    	if (object) {
									    		object.refresh();
									    	}
										},
										children:[
										       {
										    	   scriptClass: "mstrmojo.Box",
										    	   cssText: "padding-left:16px;padding-right:16px; maxHeight:" + parseInt(this.LayoutProperties.DeletedListHeight * 0.89) + 'px',
										    	   children: [
															{
																scriptClass: "mstrmojo.VisHeatMapTree",
																height: "100%",
																heightLimit: parseInt(this.LayoutProperties.DeletedListHeight * 0.89),
                                                                showIndicators: true,
                                                                showScrollbars: true,
																id: deleteTreeId,
																itemDisplayField: "label",
																itemChildrenField: "entityChildren",
																draggable:  true,
																showRoot: true,
																//rootText: "Please select elements that you want to restore",
                                                                rootText: strRestore,
																itemIncludeFunction: function (item) {
																	if (item && (item.deleted || item.hasChildDeleted)) {
																		return true;
																	} else {
																		return false;
																	}
																},

													            apply: function (callback) {
													            	var itemFunction = function () {
																		if (this.selectionStatus === 1 && this.dataProvider && this.dataProvider.deleted) {
																			this.dataProvider.deleted = false;
																			// also mark the corresponding deletedList if it is leaf node
																			var tempNode = this.dataProvider;
																			if (!tempNode.entityChildren) {
																				var keyStack = [];
																				while (tempNode.parentEntity) {
																					keyStack.push(that.getEntityDisplayName(tempNode));
																					tempNode = tempNode.parentEntity;
																				}
																				var delDict = that.props.deletedList;
																				while (keyStack.length > 1) {
																					delDict = delDict[keyStack.pop()];
																				}
																				var key = keyStack.pop(); // for the last level
																				if (delDict[key] === delStatus.dftDel) {
																					delDict[key] = delStatus.dftUnDel;
																				} else {
																					delete delDict[key];
																				}
																			}
																		}
																	};
													            	var iterator = function (item, itemFunction) {
													            		itemFunction.apply(item);
													            		if (!item.childTree) {
													            			return;
													            		}
													            		for (var i = 0; i < item.childTree.length; i++) {
													            			var subItem = item.childTree[i];
													            			iterator(subItem, itemFunction);
													            		}
													            	};
													            	iterator(this, itemFunction);
													            	that.refreshWidget();
                                                                    var tree = this;
                                                                    window.setTimeout(function(){
                                                                                    // reload the Tree
                                                                                    tree.needRefresh = true;
                                                                                    tree.refresh();

                                                                                    if (callback) {
                                                                                        callback();
                                                                                    }
                                                                    },50);//wait 50ms to let the refreshWidget be call first
													            },

																dataProvider: that.root,

																owner: that
													    	}

										    	   ]
										       },{
										    		scriptClass: "mstrmojo.Box",
										    		cssText: "background-color:whiteSmoke; position:relative; bottom:0px;font:12pt Roboto,Regular;text-align:center;vertical-align:middle;line-height:55px;border-top: 1px solid rgba(34, 34, 34, 0.18);",
										    		height: parseInt(this.LayoutProperties.DeletedListHeight * 0.11) + 'px',
                                                    //height: "100%",
										    		width: "100%",
										    		children: [
										    		           {
											    	        		   scriptClass: 'mstrmojo.Button',
																       //text: "Cancel",
                                                                       text: strButtonCancel,
																       cssClass: "heatmap-tree-button",
																       cssDisplay: "inline-block",
																       cssText: "border-right: 1px solid rgba(34, 34, 34, 0.18); position: absolute; left:0px; top: 0px; height:100%;",
																       width: "49.5%",
																       onclick: function () {
																    	   var node = this.domNode;
																    	   node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
																    	   mstrmojo.VisHeatMapAnimation.animate(node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
																    	   setTimeout(function() { // delay 100ms so that the hightlight effect could be observed
																    		   mstrmojo.all[editorId].close();
																    		   }, 100);
																       }
										    		           },
										    		           {
										    	        		   scriptClass: 'mstrmojo.Button',
															       //text: "Apply",
                                                                   text: strButtonApply,
															       cssClass: "heatmap-tree-button",
															       cssDisplay: "inline-block",
															       cssText: "position: absolute; right:0px; top:0px; height: 100%",
															       width: "50.5%",
															       postBuildRendering: function () {
															    	   mstrmojo.all[deleteTreeId].register(this);
															       },
															       notify: function (enabled) {
															    	   this.set("enabled", enabled);
															    	   /*
															    	   if (enabled) {
															    		   this.domNode.style.opacity = 1;
															    	   } else {
															    		   this.domNode.style.opacity = 0.4;
															    	   }*/
															       },
															       onclick: function () {
															    	   var node = this.domNode;
															    	   node.style.backgroundColor = "rgba(51, 181, 229, 0.6)";
															    	   that.hideInfoBox();
															    	   var callback = function () {
															    		   mstrmojo.VisHeatMapAnimation.animate(node, "background", {r:51, g:181, b:229, a:0.6}, {r: 255, g:255, b:255, a: 0});
															    	   };
															    	   setTimeout(function () {
															    		   setTimeout(function () {
															    			   mstrmojo.all[deleteTreeId].apply(callback);
															    		   }, 0);
															    	   }, 0); // use two levels of setTimeout so that we make sure the dom get refreshed first
															    	   // mstrmojo.all[editorId].close();
															       }
										    		           }
										    		]
										    	}
										]
									}]
								};
								this.editorDialog = mstrApp.showDialog(prop,'HeatMapEditor'); //VisHeatMapPopup    //android.Popup
						},

						showWaitIcon: function (delay){
							/*this.defn.raiseEvent({
								name: "readyStateChange",
								value: $READYSTATE.WAITING,
								delay: delay
								});*/

                                var w = this.waitIcon;
                                w.style.display = '-webkit-box';
                                w.style.left = '0px';
                                w.style.top = '0px';
                        },
						hideWaitIcon: function (){
							/*this.defn.raiseEvent({
								name: "readyStateChange",
								value: $READYSTATE.IDLE
								});*/
                                var w = this.waitIcon;
                                w.style.left = '-100000px';
                                w.style.top = '-100000px';

						},

						clearChildren: function(node) {
							var firstChild;
							if(!node)
								return;
							while(firstChild = node.firstChild)
								node.removeChild(firstChild);
						},

                        calculateValuesInTree: function() {
							var ml = this.model.gvs.items[0] ? this.model.gvs.items[0].items.length:0;
							clearMaxMinValues.call(this);
							setShow(false, false, true, true, this.root, this, ml+1);
                        },

						refreshWidget: function () {
							/*this.showWaitIcon(0);//0 means we show wait icon immediatly, there is no setTimeOut()
							var heatMap = this;

							window.setTimeout(function(){
									//heatMap.canvas.innerHTML = "";
									//heatMap.textCanvas.innerHTML = "";
									var ml = heatMap.model.gvs.items[0] ? heatMap.model.gvs.items[0].items.length:0;
									clearMaxMinValues.call(heatMap);
									setShow(false, false, true, true, heatMap.root, heatMap, ml+1);
									layoutEntities.call(heatMap);
									heatMap.refreshColorInTree();
									getLegendMaxMin.call(heatMap);
									heatMap.canvasObject.draw();
	//								heatMap.renderLegend();
									heatMap.hideWaitIcon();



									//window.setTimeout(function(){
//
											//for(var i = 0; i < 10000; i++){
													//window.document.body.style.display = "none";
													//window.document.body.offsetHeight;
													//window.document.body.style.display = "block";
											//}
										//},0.01);

									},0);*/

                            this.showWaitIcon();
                            var that = this;
                            var refresh = function(){
                                    that.calculateValuesInTree();
                                    getLegendMaxMin.call(that);

                                    layoutEntities.call(that)
                                    that.renderRectangles()

                                    that.renderLegend()

                                    var ps = that.previousSelected;
                                    if(ps){
                                            if(ps.deleted){
                                                    that.selectionHighlightBox.style.display = 'none';
                                            }else if(!that.selectAll){
                                                    that.highlightEntity(that.selectionHighlightBox, that.previousSelected);
                                            }
                                    }
                                    that.hideWaitIcon();
                            };
                            //set timeout to let the waiting icon be displayed
                            window.setTimeout(refresh,10);
                            /*refresh();
                            this.canvasObject.attachEventListener('canvasDrawDone',
                                                                  this.id,
                                                                  function(){
                                                                          that.hideWaitIcon();
                                                                  }
                                                                 );*/
                                /*this.showWaitIcon();
                                this.calculateValuesInTree();
                                getLegendMaxMin.call(this);

                                layoutEntities.call(this);
                                this.renderRectangles();

                                this.renderLegend();

                                if(this.selectionHighlightBox.style.display == 'block'){
                                        this.highlightEntity(this.selectionHighlightBox, this.previousSelected);
                                }

                                this.hideWaitIcon();*/

                        },


						hideInfoBox: function () {
							//this.infoBox.style.visibility = "hidden";
							//this.infoBox.style.display = "none";
							//this.infoBox.style.display = "block";
							//this.infoBox.style.left = '0px';
							//this.infoBox.style.top  = '0px';
							//this.infoBox.style.transform = "translate(100px,100px)";
                            if(!this.infoBox)
                                    return;
                            this.infoBox.style.zIndex = "-50";
                            this.infoBox.style.opacity = 0;
                            //try{
                                    //this.infoBox.style.visibility = "hidden";
                                    //this.infoBox.style.display = "none";
                            //}catch(e){
                            //}finally{
                            //}
							//$CSS.removeClass(this.infoBox, cssShow);
							//if(!(this.cacheInfoBox))
									//this.cacheInfoBox = this.infoBox.cloneNode(true);
							//if(this.infoBox.parentNode)
									//this.infoBox.parentNode.removeChild(this.infoBox);
							//window.setTimeout(function() {
									//mstrMobileApp.forceRepaint();
							//},0);
							//this.canvasContainer.offsetHeight;

							//var tmp = document.createTextNode(" ");
							//this.canvas.appendChild(tmp);
							//(function(){tmp.parentNode.removeChild(tmp)}).defer();
							this.previousTooltip = null;
						},

						getIdxObjectByTarget: function (target) {
							var ancestor = mstrmojo.dom.findAncestorByAttr(target, "idx", true, this.domNode);
							var idx = ancestor && ancestor.value;
							if (!idx) {
								return null;
							}
							var idxObject = this.getObjectByIdx(idx);
							return idxObject;
						},

						showInfoBox: function (entity) {
                                //this.hideInfoBox();
                            if(!entity)
                                    return;
                            if(!this.infoBox)
                                    this.createInfoBox();

							var idxObject = entity;

							if (idxObject === this.previousTooltip) {
								// do nothing
								return;
							}
							this.previousTooltip = idxObject;
                            if(this.infoBox.style.display != "block")
                                    this.infoBox.style.display = "block";
                            this.infoBox.style.zIndex = "75";
                            this.infoBox.style.opacity = 1;
							//this.infoBox.style.visibility = "visible";
							//this.infoBox.style.display = "block";
							//$CSS.addClass(this.infoBox,cssShow);
							//this.infoBox.style.display = "none";

							var	hBoxWidth = this.highlightBoxWidth,
								//domRect = mstrmojo.dom.position(this.domNode, true),
								//domRect = {x: parseInt(this.left), y: parseInt(this.top), w: parseInt(this.width), h: parseInt(this.height)},
                                domRect = mstrmojo.dom.position(document.body, true),
                                //widgetRect = mstrmojo.dom.position(this.canvasContainer, true);
								interRect = this.highlightEntity(this.highlightBox, idxObject);

							if (!interRect || isNaN(interRect.x)) {
								return;
							}

							// layout the delete button
							this.deleteButton.style.left = interRect.x + "px";
							this.deleteButton.style.top = interRect.y + "px";

							// set text of tooltip
							this.tooltipBox.style.width = "";//clear and let the browser calculate it
							this.tooltipBox.innerHTML = getTooltip(idxObject, this);


//console.log("#showInfoBox#:" + this.tooltipBox.innerHTML);


							// calculate the anchor box, outer rectangle
							var anchorBox = {
								x: interRect.x - hBoxWidth,
								y: interRect.y - hBoxWidth,
								w: interRect.w + hBoxWidth * 2,
								h: interRect.h + hBoxWidth * 2
							}; // in page coordinate system
							// we set triBox to visible first. Then decide if we should hide it
							this.triBox.style.display = "block";
							var anchorCenterX = anchorBox.x + (anchorBox.w>>1);
							var anchorCenterY = anchorBox.y + (anchorBox.h>>1);
							var triSize = this.triBox.offsetWidth * 0.717;


                            // handle long lines
                            var cNodes = this.tooltipBox.childNodes,
                                len = cNodes.length;
                            for(var i = 0; i < len; i++){
                                    var cInline = cNodes[i].childNodes;
                                    if(cInline[0].offsetWidth + cInline[1].offsetWidth + cInline[2].offsetWidth > cNodes[i].offsetWidth)
                                            cInline[0].className += ' heatmap-half-width';
                            }


							var tHeight = this.tooltipBox.offsetHeight;
							var tWidth = this.tooltipBox.offsetWidth;





							// this flag used to see if ever a match is made
							var matched = false;

							// the xFit and yFit will not change. So calculate it once and use the result in following caluclation
							var xFit = ((anchorCenterX - (tWidth>>1)) > 0) && (anchorCenterX + (tWidth>>1)) < (domRect.w);
							var yFit = ((anchorCenterY - (tHeight>>1)) > 0) && (anchorCenterY + (tHeight>>1)) < (domRect.h);

							// this function is used to position triBox, tooltipBox and deleteButton
							var canShiftPadding = 10; // this is fixed and will be used by calcPosition function
							function calcPosition (triBox, tooltipBox, deleteButton, /*boolean*/ canShift) {
								if (canShift === undefined) {
									canShift = false; // default to false
								}
								if (!matched && (canShift || yFit)) { // try left and right
									if (anchorBox.x - triSize - tWidth >= 0) { // if left succeed
										matched = true;
										triBox.style.left = anchorBox.x - triSize + "px";
										tooltipBox.style.left = anchorBox.x - triSize - tWidth + "px";

										// delete button put on right top
										deleteButton.style.left = interRect.x + interRect.w + "px";
									} else if (anchorBox.x + anchorBox.w + triSize + tWidth <= domRect.w) { // if right succeed
										matched = true;
										triBox.style.left = anchorBox.x + anchorBox.w + triSize + "px";
										tooltipBox.style.left = anchorBox.x + anchorBox.w + triSize + "px";
									}
									if (matched) { // if left or right succeed
										var triTop = anchorCenterY;
										var tooltipTop = anchorCenterY - tHeight / 2;
										if (canShift) {
											if (tHeight + canShiftPadding * 2 > domRect.h) {
												matched = false; // no way to match. Set matched to false again
											} else {
												var upLimit = canShiftPadding;
												var downLimit = domRect.h - canShiftPadding - tHeight;
												if (tooltipTop < upLimit) { // then shift down
													tooltipTop = upLimit;
												} else if (tooltipTop > downLimit) { // shift up
													tooltipTop = downLimit;
												}
											}
										}
										triBox.style.top = triTop + "px";
										tooltipBox.style.top = tooltipTop + "px";
									}
								}

								if (!matched && (canShift || xFit)) { // try top and bottom
									if (anchorBox.y - triSize - tHeight >= 0) { // if top succeed
										matched = true;
										triBox.style.top = anchorBox.y - triSize + "px";
										tooltipBox.style.top = anchorBox.y - triSize - tHeight + "px";

										// delete button put on left bottom
										deleteButton.style.top = interRect.y + interRect.h + "px";
									} else if (anchorBox.y + anchorBox.h + triSize + tHeight <= domRect.h) { // if bottom succeed
										matched = true;
										triBox.style.top = anchorBox.y + anchorBox.h + triSize + "px";
										tooltipBox.style.top = anchorBox.y + anchorBox.h + triSize + "px";
									}
									if (matched) { // if top or bottom succeed
										var triLeft = anchorCenterX;
										var tooltipLeft = anchorCenterX - tWidth / 2;
										if (canShift) {
											if (tWidth + canShiftPadding * 2 > domRect.w) {
												matched = false; // no way to match. Set matched to false again
											} else {
												var leftLimit = canShiftPadding;
												var rightLimit = domRect.w - canShiftPadding - tWidth;
												if (tooltipLeft < leftLimit) { // then shift left
													tooltipLeft = leftLimit;
												} else if (tooltipLeft > rightLimit) { // shift right
													tooltipLeft = rightLimit;
												}
											}
										}
										triBox.style.left = triLeft + "px";
										tooltipBox.style.left = tooltipLeft + "px";
									}
								}
							};

							// according to iOS HeatMap behavior, we should first use border match and use strict center alignment first
							// if that does not fit, try center match and the tooltip could shift. In this case, we should also disable the triBox
							calcPosition (this.triBox, this.tooltipBox, this.deleteButton, false);
							//$CSS.addClass(this.infoBox,cssShow);
							this.infoBox.style.display = 'block';
							if (!matched) { // use the center point of anchorBox and try again
								anchorBox = {
										x: anchorCenterX,
										y: anchorCenterY,
										w: 0,
										h: 0
								};
								this.triBox.style.display = "none";
								triSize = 0;
								calcPosition (this.triBox, this.tooltipBox, this.deleteButton, true);
							}
							if (!matched) { // then put it in the center
								this.triBox.style.display = "none";
								this.tooltipBox.style.left = anchorCenterX - tWidth / 2 + "px";
								this.tooltipBox.style.top = anchorCenterY - tHeight / 2 + "px";
							}
							// by this time, the tooltipBox should have already be positioned. copy this setting to shadow box
							this.shadowBox.style.left = this.tooltipBox.style.left;
							this.shadowBox.style.top = this.tooltipBox.style.top;
							this.shadowBox.style.width = this.tooltipBox.offsetWidth + "px";
							this.shadowBox.style.height = this.tooltipBox.offsetHeight + "px";
							this.shelter.style.left = this.tooltipBox.style.left;
							this.shelter.style.top = this.tooltipBox.style.top;
							this.shelter.style.width = this.tooltipBox.offsetWidth + "px";
							this.shelter.style.height = this.tooltipBox.offsetHeight + "px";

                            //debug
                            var span = this.tooltipBox.childNodes[0].childNodes[0];
                            var style = window.getComputedStyle(span,null);

                            ////alert("tooltip bold:"+style['font'] + "\n" + "offsetWidth: " + span.offsetWidth + " offsetHeight:" + span.offsetHeight);
//console.log('#showInfoBox#:' + this.infoBox.parentNode.offsetLeft + ' ' + this.infoBox.parentNode.offsetTop);
						},


						enableGlobalDismiss: function(){
								var touchManager = mstrmojo.touchManager;
								var heatMap = this;
								this._globalTouchListener = touchManager.attachEventListener("touchesBegin",
										this.id,
										function(evt){
                                                if(!evt || !evt.touch || !evt.touch.target)
                                                        return;
                                            var target = evt.touch.target,
                                                backgroundDiv1 = document.getElementsByClassName('mstrmojo-DocLayoutViewer-layout')[0],
                                                backgroundDiv2 = document.getElementsByClassName('mstrmojo-DocSubsection')[0];
//console.log("#enableGlobalDismiss# className:" + target.className);
                                            //when scroll the widget, we should dismiss the tooltip to fix it's position
											if(heatMap.infoBoxPuppet != target && !mstrmojo.dom.contains(heatMap.infoBox, target, true)){
                                                    heatMap.hideInfoBox();
                                            }
                                            //do select all if we click on blank places near the widget
                                            if(target != backgroundDiv1 && target != backgroundDiv2)
                                                    return ;
                                            if(!this.selectAll)
                                                heatMap.doSelection(heatMap.previousSelected);
											//console.log("hide tooltip done.");
										}
								);
						},

						disableGlobalDismiss: function(){
								var touchManager = mstrmojo.touchManager;
								if(this._globalTouchListener){
										touchManager.detachEventListener(this._globalTouchListener);
										delete this._globalTouchListener;
								}
						},


						touchInfoBoxValid: function(touch) {
								var taget = touch.target;
								if(target.id == this.id+"-infobox") return true;
						},

						touchLegendTooltipValid: function touchValid(touch){
							var target = touch.target;
							if(target.id != this.id+'-color-legend-band') return false;
							var	frame = mstrmojo.dom.position(target, true),
								x = touch.clientX-frame.x,
								y = touch.clientY-frame.y,
								p = this.legendBand;
							if(x < p.x || x >= p.x + p.w - 1) {
								return false;
							}
							return true;
						},

						showLegendTooltip: function (touch) {
							var target = touch.target,
								frame = mstrmojo.dom.position(target, true),
								x = touch.clientX-frame.x,
								y = touch.clientY-frame.y,
								p = this.legendBand,
								idx;
							var ct = this.colorTheme;
							if(ct.tooltipInfo === undefined || ct.tooltipInfo === null){
								ct.createTooltipInfo(this.legendTickCount, p.w, this);
								this.selectedBandIndex = -1;
							}
							var i = ct.getTooltipInfo(x-p.x);
							if(i != this.selectedBandIndex){
								this.renderHilightedBand(i);
							}
							// show tooltip
							var t = this.colorTheme.tooltipInfo[i],
								cfs = this.getFormatString(this.colorMetricIndex),
								mn = this.getMetricName(this.colorMetricIndex),
								sign = (t.sign === undefined) ? " < " : " > ",
								str = "<div>" + this.nf.formatByMask(cfs, t.sv)
									  + sign + "</div>"
                                      + "<div class='heatmap-flex'>" + mn + "</div>"
                                      +"<div>" + sign
									  + this.nf.formatByMask(cfs, t.ev) + "</div>";
							//size.w += LayoutProperties.Padding;
							//size.h += 2*LayoutProperties.Padding;
							this.legendTooltip.innerHTML = str;
							this.legendTooltip.style.borderColor = getCSSColor(t.c);
							//this.legendTooltip.style.width = size.w + 'px';
							//this.legendTooltip.style.height = size.h + 'px';
							this.legendTooltip.style.lineHeight = this.legendTooltip.style.height;
							this.legendTooltip.style.display = "-webkit-box";
                            var size = {w: this.legendTooltip.offsetWidth, h: this.legendTooltip.offsetHeight};
							var lc = mstrmojo.dom.position(this.colorLegend, true),//color legend container
								cv = mstrmojo.dom.position(this.canvas, true), // canvas container
								tx = t.r.x+((t.r.w-size.w)>>1);
							if(tx < 0){
								tx = 0;
							}else if(tx > frame.w - size.w){
								tx = frame.w - size.w;
							}
							this.legendTooltip.style.left = tx + 'px';
							this.legendTooltip.style.top = -35 + 'px';
						},

						hideLegendTooltip: function () {
							if (this.selectedBandIndex === undefined || this.selectedBandIndex == -1) return;
							this.renderGradientBand(this.legendBand);
							this.selectedBandIndex = -1;
                            this.legendTooltip.style.left = '-100000px';
							//this.legendTooltip.style.display = "none";
						},


						touchSelectBegin: function (touch) {
							if (touch.evt.ctrlKey) { // if ctrl Key is pressed
								this.touchMultiBegin(touch);
								return;
							}
							var target = touch.target;
							if(!target) return;
                            this.lastTouchSelectTarget = target;
							if(this.touchLegendTooltipValid(touch)){
								this.showLegendTooltip(touch);
								this.hideInfoBox();
							}else{
								this.hideLegendTooltip();
								/*if (mstrmojo.dom.contains(this.infoBox, target, true, this.domNode)) {
									this.infoBox.style.display = "none";
									//$CSS.removeClass(this.infoBox,cssShow);
									target = document.elementFromPoint(touch.pageX, touch.pageY);
									this.infoBox.style.display = "block";
									//$CSS.addClass(this.infoBox,cssShow);

								}*/
                                var entity;
                                if(this.infoWindowMode){
                                        entity = this.getEntityByTouch(touch,true);
                                }else{
                                        entity = this.getEntityByTouch(touch);
                                }
								if(!entity)
									return;
								if (this.timer) {
									cleatTimeout(this.timer);
									this.timer = null;
								}
                                if(this.infoWindowMode){
                                        this.doSelection(entity);
                                }else{
                                        this.showInfoBox(entity);
                                        //console.log('show info box in touchSelectBegin');
                                }
							}
						},

						touchSelectMove: function (touch) {
							if (touch.evt.ctrlKey) {
								this.touchMultiMove(touch);
								return;
							}
							var target = touch.target;
							if(!target) return;
                            //if(target.parentNode == this.infoBox && target != this.shelter)
                                    //return ;
							if(this.touchLegendTooltipValid(touch)){
								this.showLegendTooltip(touch);
								this.hideInfoBox();
							}else{
								this.hideLegendTooltip();
								/*var target = document.elementFromPoint(touch.pageX, touch.pageY);
								if (mstrmojo.dom.contains(this.infoBox, target, true, this.domNode)) {
									//$CSS.removeClass(this.infoBox,cssShow);
									this.infoBox.style.display = "none";
									target = document.elementFromPoint(touch.pageX, touch.pageY);
									//$CSS.addClass(this.infoBox,cssShow);
									this.infoBox.style.display = "block";
								}*/
                                var entity;
                                if(this.infoWindowMode){
                                        entity = this.getEntityByTouch(touch,true);
                                }
                                else{
                                        entity = this.getEntityByTouch(touch);
                                }
								if(!entity)
									return;
								var that = this;
								if (this.timer) {
									clearTimeout(this.timer);
									this.timer = null;
								}
								//this.timer = setTimeout(function () {that.showInfoBox(entity);that.timer = null;}, 10); // delay for 10ms in order to make it more smooth
                                if(this.infoWindowMode){
                                        if(this.previousSelected != entity){
                                                this.doSelection(entity);
                                        }
                                }else{
                                        this.showInfoBox(entity);
                                        //console.log('show info box in touchSelectMove');
                                }
							}
						},


						touchSelectEnd: function (touch) {
							if (touch.evt.ctrlKey) {
								this.touchMultiEnd(touch);
							}
							return;
						},


						initScroller: function (scroller) {
							scroller.attachEventListener('scrollMoved', this.id, function (evt) {
								this.hideInfoBox();
							});
                            scroller.attachEventListener('scrollDone', this.id, function (evt) {
                                    this.canvasObject.updateOffsets(scroller.origin.x, scroller.origin.y);
                            });
                        },


						multiTouch: true,

						touchMultiBegin: function (touch) {
							// we have two mode. First is using single touch or mouse event for simpler debug. Second is really multi touch
							// hide the info box and tooltip anyway
							this.hideLegendTooltip();
							this.hideInfoBox();
                            //hide highlightBox
                            //this.selectionHighlightBox.style.display = 'none';

							var touch1;
							var touch2;
							if (touch.evt.touches && touch.evt.touches.length == 2) {
								touch1 = touch.evt.touches[0];
								touch2 = touch.evt.touches[1];
							} else {
								touch1 = touch;
								touch2 = {pageX: 300, pageY:300};
							}
							var xDiff = touch1.pageX - touch2.pageX;
							var yDiff = touch1.pageY - touch2.pageY;
							this.initDiffDiff = xDiff * xDiff + yDiff * yDiff;
							this.initCenterX = ((touch1.pageX + touch2.pageX)>>1);
							this.initCenterY = ((touch1.pageY + touch2.pageY)>>1);
							this.initScrollX = this._scroller.origin.x;
							this.initScrollY = this._scroller.origin.y;

							this.relScaleFactor = 1;

							//console.log("initDiffDiff:" + this.initDiffDiff + ", with init center:" + this.initCenterX + "," + this.initCenterY);
							// this.touchSelectBeginHandler(touch);
						},

						touchMultiMove: function (touch) {
							// we have two mode. First is using single touch or mouse event for simpler debug. Second is really multi touch
							var touch1;
							var touch2;
							if (touch.evt.touches && touch.evt.touches.length == 2) {
								touch1 = touch.evt.touches[0];
								touch2 = touch.evt.touches[1];
							} else {
								touch1 = touch;
								touch2 = {pageX: 300, pageY: 300};
							}
							var xDiff = touch1.pageX - touch2.pageX;
							var yDiff = touch1.pageY - touch2.pageY;
							var curDiffDiff = xDiff * xDiff + yDiff * yDiff;

							var curCenterX = ((touch1.pageX + touch2.pageX)>>1);
							var curCenterY = ((touch1.pageY + touch2.pageY)>>1);

							var scale = Math.sqrt(curDiffDiff / this.initDiffDiff);


							var offset = { // xiawang: This is calculated by us
								x: scale * (this.initCenterX + this.initScrollX) - curCenterX,
								y: scale * (this.initCenterY + this.initScrollY) - curCenterY
							};
							var transform = {scale: scale, offset: offset};

							this.relScaleFactor = scale;
                            if(this.relScaleFactor * this.scaleFactor >= this.maxScale && !this.oldTransform){
                                    this.oldTransform = transform;
                            }
							//console.log("xiawang: sclae factor:" + this.scaleFactor + " with currentDiffDiff:" + curDiffDiff);
							this.applyTransform(transform);
						},

						touchMultiEnd: function (touch) {
                                var finalScale = this.relScaleFactor * this.scaleFactor;
							if (finalScale < 1) {
								// make sure the final scale factor is not larger than 1
                                var initTransform = {offset:{x:0,y:0}, scale: 1 / this.scaleFactor};
								this.relScaleFactor = initTransform.scale;
								this.applyTransform(initTransform, 500, this.postScale);
                            } else if(finalScale > this.maxScale){
                                    this.relScaleFactor = this.maxScale / this.scaleFactor;
                                    this.applyTransform(this.oldTransform, 500, this.postScale);
                                    delete this.oldTransform;
                            }else{
								this.postScale();
							}
						},

						relScaleFactor: 1,

						scaleFactor: 1,

                        applyTransform: function (transform, duration, callback) {
                                var scl = this._scroller;

                                if (duration === undefined) {
                                        duration = 0;
                                }
                                scl.scrollEl.style["webkitTransformOrigin"] = "left top";

                                scl.transform = "scale(" + transform.scale + "," + transform.scale + ")";
                                var scrollX = transform.offset.x,
                                    scrollY = transform.offset.y,
                                    scrollerOffsetScale = this.scaleFactor * this.relScaleFactor - 1,
                                    vOffsetEnd = this.heatMapSize.h * scrollerOffsetScale,
                                    hOffsetEnd = this.heatMapSize.w * scrollerOffsetScale;
                                scl.offset = {
                                        y: {
                                                start: 0,
                                                end: vOffsetEnd
                                        },
                                        x: {
                                                start: 0,
                                                end: hOffsetEnd
                                        }
                                };
                                this._scroller.scrollTo(scrollX, scrollY, duration);
                                if (callback) {
                                        var that = this;
                                        setTimeout(function () {callback.apply(that); that = null;}, duration);
                                }


                        },


						postScale: function () {
							delete this._scroller.transform;
							this._scroller.scrollTo(this._scroller.origin.x, this._scroller.origin.y, 0);
							this.scaleFactor *= this.relScaleFactor;
                            // limit maxmum zoom in deepth
                            if(this.scaleFactor > this.maxScale)
                                    this.scaleFactor = this.maxScale;
							this.refreshWidget();
						},


						destroy: function (skipCleanup) {
							this._super(skipCleanup);
							if (this.editorDialog) {
								// console.log(this.editorDialog.id);
								this.editorDialog.destroy();
                                delete this.editorDialog;
							}
						}

					});
})();


(function () {

    mstrmojo.requiresCls("mstrmojo.Vis");

    var DEFAULT_DARK_THEME = 1;
    var DEFAULT_LIGHT_THEME = 2;
    var CUSTOM_DARK_THEME = 3;
    var CUSTOM_LIGHT_THEME = 4;

    mstrmojo.VisMicroChartBullet = mstrmojo.declare(

        mstrmojo.Vis,

        null,

        {

            scriptClass: 'mstrmojo.VisMicroChartBullet',

            isDrawAxis: false,

            margin: {t: 0, r: 5, b: 0, l: 5},

            showHighlightLine: false,

            themeColor: '#FFFFFF',

            noBackground: true,

            isAnimateLines: false,

            toolTipMain: null,

            mainWidth: 0,

            mainLeftPos: 0,

            showMinLabel: false,

            markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};top:{@top};left:{@left};position:relative;" ' +
                ' mstrAttach:mousedown,mouseup,mousemove,click ' +
                '><canvas width="{@width}" height="{@height}"></canvas>' +
                //				'<canvas style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>' +
                //				'<canvas style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>' +
                '<div style="position:absolute;left:0px;bottom:0px;display:none;font:7px Arial;text-align:left;line-height:7px;"></div>' +
                '<div style="width:100%;height:{@height};top:0px;left:0px;position:absolute;display:none;font:10pt Arial;overflow: hidden; text-overflow: ellipsis; white-space:nowrap"></div>' +
                '</div>',

            markupSlots: {

                canvas: function () {
                    return this.domNode.firstChild;
                },
                minLabel: function () {
                    return this.domNode.childNodes[1];
                },
                errorMsg: function () {
                    return this.domNode.childNodes[2];
                }
                //					animationCanvas: function(){ return this.domNode.childNodes[1]; },
                //					highlightCanvas: function(){ return this.domNode.childNodes[2]; },
                //					minLabel: function(){ return this.domNode.childNodes[3]; }
            },
            postBuildRendering: function postBR() {
                if (this._super) {
                    this._super();
                }
                this.browserSupportsHtml5 = this.canvas.getContext;
                if (!this.browserSupportsHtml5) {
                    this.renderErrorMessage(mstrmojo.desc(8126, 'Your browser does not support HTML5'));
                    return;
                }
                if (!this.model) {
                    this.renderErrorMessage(mstrmojo.desc(8426, 'No model provided'));
                    return;
                }

                if (this.model.err || this.model.eg) {
                    this.renderErrorMessage(this.model.err || this.model.eg);
                    return;
                }

                this.context = this.canvas.getContext('2d');
                //					this.highlightContext = this.highlightCanvas.getContext('2d');
                //					this.animationContext = this.animationCanvas.getContext('2d');
                this.setColorByTheme();
                this.drawChart();
            },

            setColorByTheme: function setColorByTheme() {
                var bulletProps = this.config;
                var dpi = mstrMobileApp && mstrMobileApp.getDeviceDPI() || 160;
                if (this.theme == DEFAULT_DARK_THEME) {
                    this.bandColor1 = "#494949";
                    this.bandColor2 = "#595959";
                    this.bandColor3 = "#727272";

                    this.refLinePosColor = "#FF781D";
                    this.refLineNegColor = "#FF781D";
                    this.refLineWidth = dpi >= 160 ? 2 : 1;
                    this.blueBarPosColor = "#00BDFF";
                    this.blueBarNegColor = bulletProps.mwNegCol;
                } else if (this.theme == DEFAULT_LIGHT_THEME) {
                    this.bandColor1 = "#A5A5A5";
                    this.bandColor2 = "#B3B3B3";
                    this.bandColor3 = "#C4C4C4";

                    this.refLinePosColor = "#FF781D";
                    this.refLineNegColor = "#FF781D";
                    this.refLineWidth = dpi >= 160 ? 2 : 1;
                    this.blueBarPosColor = "#00BDFF";
                    this.blueBarNegColor = bulletProps.mwNegCol;
                } else {
                    this.bandColor1 = bulletProps.mwBand1 || "#999999";
                    this.bandColor2 = bulletProps.mwBand2 || "#BBBBBB";
                    this.bandColor3 = bulletProps.mwBand3 || "#DEDEDE";

                    this.refLinePosColor = bulletProps.mwRefLineCol;
                    this.refLineNegColor = bulletProps.mwRefLineCol;
                    this.blueBarPosColor = bulletProps.mwPosCol;
                    this.blueBarNegColor = bulletProps.mwNegCol;
                }
            },

            showTooltip: function shwttp(touchX, touchY) {
                if (!this.config.mbShowTooltip) {
                    return false;
                }
                var minValue = this.config.mfMinValue;
                var refV = this.refv;
                var mc3 = refV[2].rv - minValue;
                var mc4 = refV[3].rv - minValue;
                var ttp = this.toolTipMain;

                var model = this.model;
                var metrics = model.mtrcs.items;

                var bulletProps = this.config;

                var ofht = 17;
                var line1;// = metrics[2] + ": " + refV[2].v;

                if (/*!this.widget.isKPI &&*/ this.widget.bulletProps.mstrAssMetric) {
                    line1 = this.widget.bulletProps.mstrAssMetric + ": " + refV[2].v;
                }
                else {
                    line1 = metrics[2] + ": " + refV[2].v;
                }
                var maxWidth = this.widget.getTextWidthByCanvas(line1, ttp);
                if (bulletProps.mbRefLine) {
                    line1 = '<div style="margin-left:5px;margin-top:5px;"><div style="float:left;margin-right:5px;margin-top:2px;width:12px;height:10px;background-color:' + this.targetColor + ';"></div><div style="float:left;text-align:top;">' + line1 + "</div></div>";
                } else {
                    line1 = '<div style="margin-left:5px;margin-top:5px;margin-bottom:5px;"><div style="float:left;margin-right:5px;margin-top:2px;width:12px;height:10px;background-color:' + this.targetColor + ';"></div><div style="float:left;text-align:top;">' + line1 + "</div></div>";
                }

                if (bulletProps.mbRefLine) {
                    ofht += 17;
                    var line2 = metrics[6] + ": " + refV[6].v;
                    var line2Width = this.widget.getTextWidthByCanvas(line2, ttp);
                    if (line2Width > maxWidth) {
                        maxWidth = line2Width;
                    }
                    line2 = '<div style="margin-left:5px;margin-bottom:5px;"><div style="float:left;margin-left:5px;margin-top:2px;margin-right:10px;width:2px;height:10px;background-color:' + this.refLineColor + ';"></div><div style="float:left;">' + line2 + "</div></div>";
                    line1 += "<br/>" + line2;
                }
                ofht += 10;

                //					if ( mc3 * mc4 > 0 && Math.abs(mc3) > Math.abs(mc4)) {
                //						var err = mstrmojo.desc(10381, 'Metric of Butllet is out of the max graph range');
                //						ttp.innerHTML = err;
                //					}else{
                //						ttp.innerHTML = line1;
                //					}

                if (this.tooltipErrMsg) {
                    ttp.innerHTML = this.tooltipErrMsg;
                } else {
                    ttp.innerHTML = line1;
                }

                var pos = mstrmojo.dom.position(this.domNode, true);
                var posWdt = mstrmojo.dom.position(this.widget._leftChart.domNode, true);
                maxWidth += 28;//+= 30;
                ttp.style.display = 'block';
                ttp.style.borderColor = this.targetColor;
                ttp.style.width = maxWidth + "px";
                var tpof = 0;
                if ((this.getHeight() - ofht) % 2 == 0) {
                    tpof = (pos.y - posWdt.y + (this.getHeight() - ofht) / 2);
                } else {
                    tpof = (pos.y - posWdt.y + (this.getHeight() - ofht - 1) / 2);
                }

                if (tpof < 0) {
                    tpof = 0;
                }
                if (tpof + ofht > this.widget.getHeight()) {
                    tpof = this.widget.getHeight() - ofht - 5;
                }
                ttp.style.top = tpof + "px";

                // TQMS 548335: We should also check if the tooltip will go out of left bound of MicroChart
                var ttpLeft = 0;
                if (pos.x + pos.w / 2 > (posWdt.x + posWdt.w / 2)) {
                    // if the bullet chart center is to the right of the MC center, we should put the tooltip on the left
                    ttpLeft = pos.x - posWdt.x - maxWidth - 10;
                } else {
                    // if the bullet chart center is to the left of the MC center, we should put the tooltip on the right
                    ttpLeft = pos.x - posWdt.x + pos.w + 10;
                }
                if (ttpLeft < 0) {
                    ttpLeft = 0;
                }

                ttp.style.left = ttpLeft + "px";
                return true;
            },

            drawChart: function drwchrt() {
                var bulletProps = this.config;
                var minValue = bulletProps.mfMinValue;
                var refV = this.refv;
                var mc3, mc4, mc5, mc6, mc7;
                /*
                 * mMc3:bar value
                 * mMc4:high
                 * mMc5:medium
                 * mMc6:low
                 * mMc7:ref line value
                 */
                var mMc3, mMc4, mMc5, mMc6, mMc7;
                mMc3 = parseFloat(refV[2].rv);
                mMc4 = parseFloat(refV[3].rv);
                mMc5 = parseFloat(refV[4].rv);
                mMc6 = parseFloat(refV[5].rv);
                mMc7 = parseFloat(refV[6].rv);
                mc3 = mMc3 - minValue;
                mc4 = mMc4 - minValue;
                mc5 = mMc5 - minValue;
                mc6 = mMc6 - minValue;
                mc7 = mMc7 - minValue;

                var isInverted = bulletProps.mbInvertAxis;
                var hasRefLine = bulletProps.mbRefLine;
                var hasRefBands = bulletProps.mbRefBands;
                var mShowTooltip = bulletProps.mbShowTooltip;
                var ctx = this.context;
                var ratioBetweenMetricViewWidth;
                var bulletHeight;

                var minLabelHeight = 7, minLabelWidth;
                var xPadding = 0, yPadding = 5;

                if (isNaN(mc3) || isNaN(mc4) || isNaN(mc5) || isNaN(mc6)) {
                    var err = mstrmojo.desc(10860, 'Insufficient data to plot the graph');
                    this.errorMsg.innerHTML = err;
                    this.errorMsg.style.display = 'block';
                    this.minLabel.style.display = "none";

                    this.tooltipErrMsg = err;
                    return;
                } else if (mc3 * mc4 > 0 && Math.abs(mc3) > Math.abs(mc4)) {
                    var err = mstrmojo.desc(10381, 'Metric of Butllet is out of the max graph range');
                    this.errorMsg.innerHTML = err;
                    this.errorMsg.style.display = 'block';
                    this.minLabel.style.display = "none";

                    this.tooltipErrMsg = err;
                    return;
                } else {
                    this.errorMsg.style.display = 'none';

                    this.tooltipErrMsg = null;
                }

                var xOri;
                var redComp, greenComp, blueComp;
                var mcOriX, mcOriY;
                var mcHeight, mcWidth;

                if (mc3 < 0 && mc4 > 0) {
                    ratioBetweenMetricViewWidth = (this.getWidth() - 2 * xPadding) / (mc4 - mc3);
                    xOri = xPadding - mc3 * ratioBetweenMetricViewWidth;
                    bulletHeight = this.getHeight() - minLabelHeight - 2 * yPadding - 2;
                    //draw ref bands
                    if (hasRefBands) {
                        mcHeight = bulletHeight;

                        //draw the high band
                        mcWidth = this.getWidth() - 2 * xPadding;
                        mcOriX = xPadding;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.bandColor3;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                        //draw the middle band
                        if (mc6 > mc3 && mc6 < mc4) {
                            mcWidth = (mc6 - mc3) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            ctx.fillStyle = this.bandColor2;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }

                        //draw the low ref band
                        if (mc5 > mc3 && mc5 < mc4) {
                            mcWidth = (mc5 - mc3) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            ctx.fillStyle = this.bandColor1;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }
                    }
                    //draw performent bar
                    mcHeight = bulletHeight / 2.0;
                    mcWidth = Math.abs(mc3) * ratioBetweenMetricViewWidth;
                    mcOriX = xPadding;
                    mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                    ctx.fillStyle = this.targetColor = mMc3 >= 0 ? this.blueBarPosColor : this.blueBarNegColor;
                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    //draw ref line
                    if (hasRefLine && mc7 > mc3 && mc7 < mc4) {
                        mcHeight = bulletHeight;
                        mcWidth = 2;
                        mcOriX = xOri + mc7 * ratioBetweenMetricViewWidth;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.refLineColor = mMc3 >= 0 ? this.refLinePosColor : this.refLineNegColor;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    }
                } else if (mc3 < 0 && mc4 < 0) {
                    ratioBetweenMetricViewWidth = (this.getWidth() - 2 * xPadding) / (Math.abs(mc4));
                    xOri = xPadding;
                    bulletHeight = this.getHeight() - minLabelHeight - 2 * yPadding - 2;
                    isInverted = !isInverted;
                    //draw ref bands
                    if (hasRefBands) {
                        mcHeight = bulletHeight;

                        //draw the high band
                        mcWidth = this.getWidth() - 2 * xPadding;
                        mcOriX = xPadding;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.bandColor3;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                        //draw the middle band
                        if (mc6 < 0 && mc6 > mc4) {
                            mcWidth = Math.abs(mc6) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            ctx.fillStyle = this.bandColor2;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }

                        //draw the low ref band
                        if (mc5 < 0 && mc5 > mc4) {
                            mcWidth = Math.abs(mc5) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            ctx.fillStyle = this.bandColor1;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }
                    }
                    //draw performent bar
                    mcHeight = bulletHeight / 2.0;
                    mcWidth = Math.abs(mc3) * ratioBetweenMetricViewWidth;
                    mcOriX = xPadding;
                    mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                    ctx.fillStyle = this.targetColor = mMc3 >= 0 ? this.blueBarPosColor : this.blueBarNegColor;
                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    //draw ref line
                    if (hasRefLine && mc7 < 0 && mc7 > mc4) {
                        mcHeight = bulletHeight;
                        mcWidth = 2;
                        mcOriX = xOri + Math.abs(mc7) * ratioBetweenMetricViewWidth;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                        ctx.fillStyle = this.refLineColor = mMc3 >= 0 ? this.refLinePosColor : this.refLineNegColor;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    }
                } else if (mc3 > 0 && mc4 > 0) {
                    if (this.showMinLabel) {
                        yPadding = 9.5;
                    } else {
                        yPadding = 5;
                    }
                    ratioBetweenMetricViewWidth = (this.getWidth() - 2 * xPadding) / mc4;
                    xOri = xPadding;
                    bulletHeight = this.getHeight() - 2 * yPadding;
                    //draw ref bands
                    if (hasRefBands) {
                        mcHeight = bulletHeight;

                        //draw the high band
                        mcWidth = this.getWidth() - 2 * xPadding;
                        mcOriX = xPadding;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.bandColor3;
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                        //draw the middle band
                        if (mc6 > 0 && mc6 < mc4) {
                            mcWidth = mc6 * ratioBetweenMetricViewWidth;
                            mcOriX = xOri;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            ctx.fillStyle = this.bandColor2;
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }

                        //draw the low ref band
                        if (mc5 > 0 && mc5 < mc4) {
                            mcWidth = mc5 * ratioBetweenMetricViewWidth;
                            mcOriX = xOri;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            ctx.fillStyle = this.bandColor1;
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }
                    }
                    //draw performent bar
                    mcHeight = bulletHeight / 2.0;
                    mcWidth = mc3 * ratioBetweenMetricViewWidth;
                    mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                    mcOriX = xOri;
                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    ctx.fillStyle = this.targetColor = mMc3 >= 0 ? this.blueBarPosColor : this.blueBarNegColor;
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    //draw ref line
                    if (hasRefLine && mc7 > 0 && mc7 < mc4) {
                        mcHeight = bulletHeight;
                        mcWidth = 2;
                        mcOriX = xOri + mc7 * ratioBetweenMetricViewWidth;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.refLineColor = mMc3 >= 0 ? this.refLinePosColor : this.refLineNegColor;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    }

                } else {
                    //mc3 > 0 && mc4 < 0
                    ratioBetweenMetricViewWidth = (this.getWidth() - 2 * xPadding) / (mc3 - mc4);
                    bulletHeight = this.getHeight() - minLabelHeight - 2 * yPadding - 2;
                    xOri = xPadding - mc4 * ratioBetweenMetricViewWidth;
                    ;
                    isInverted = !isInverted;

                    //draw ref bands
                    if (hasRefBands) {
                        mcHeight = bulletHeight;

                        //draw the high band
                        mcWidth = this.getWidth() - 2 * xPadding;
                        mcOriX = xPadding;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.bandColor3;
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                        //draw the middle band
                        if (mc6 < mc3 && mc6 > mc4) {
                            mcWidth = (mc3 - mc6) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                            ctx.fillStyle = this.bandColor2;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }

                        //draw the low ref band
                        if (mc5 < mc3 && mc5 > mc4) {
                            mcWidth = (mc3 - mc5) * ratioBetweenMetricViewWidth;
                            mcOriX = xPadding;
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                            ctx.fillStyle = this.bandColor1;
                            if (isInverted) {
                                mcOriX = this.getWidth() - mcOriX - mcWidth;
                            }
                            this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                        }
                    }
                    //draw performent bar
                    mcHeight = bulletHeight / 2.0;
                    mcWidth = Math.abs(mc3) * ratioBetweenMetricViewWidth;
                    mcOriX = xOri;
                    mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                    ctx.fillStyle = this.targetColor = mMc3 >= 0 ? this.blueBarPosColor : this.blueBarNegColor;
                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    //draw ref line
                    if (hasRefLine && mc7 < mc3 && mc7 > mc4) {
                        mcHeight = bulletHeight;
                        mcWidth = 2;
                        mcOriX = xOri + mc7 * ratioBetweenMetricViewWidth;
                        mcOriY = (bulletHeight) / 2 - mcHeight / 2 + yPadding;
                        ctx.fillStyle = this.refLineColor = mMc3 >= 0 ? this.refLinePosColor : this.refLineNegColor;
                        if (isInverted) {
                            mcOriX = this.getWidth() - mcOriX - mcWidth;
                        }
                        this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                    }
                }

                //					//draw ref bands
                //					if (hasRefBands) {
                //						mcHeight=bulletHeight;
                //
                //						//draw the high band
                //						mcWidth=this.getWidth()-2*xPadding;
                //						mcOriX=xPadding;
                //						mcOriY=(bulletHeight)/2-mcHeight/2+yPadding;
                //						ctx.fillStyle = this.bandColor3;
                //						this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                //
                //						//draw the middle band
                //						if(mc6 > 0 && mc6 < mc4){
                //							mcWidth=Math.abs(mc6)*ratioBetweenMetricViewWidth;
                //
                //							mcOriX=xOri;
                //							mcOriY=(bulletHeight)/2-mcHeight/2+yPadding;
                //
                //							if (mc3<0) {
                //								mcOriX=xPadding;
                //								mcWidth=xOri+mcWidth-xPadding;
                //							}
                //							if (isInverted) {
                //								mcOriX=this.getWidth()-mcOriX-mcWidth;
                //							}
                //
                //							ctx.fillStyle = this.bandColor2;
                //							this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                //						}
                //
                //
                //					}
                //
                //					if (hasRefBands && mc5>0)
                //					{
                //
                //						mcHeight=bulletHeight;
                //						mcWidth=mc5*ratioBetweenMetricViewWidth;
                //
                //
                //						mcOriX=xOri;
                //						mcOriY=(bulletHeight)/2-mcHeight/2+yPadding;
                //
                //						if (mc3<0) {
                //							mcOriX=xPadding;
                //							mcWidth=xOri+mcWidth-xPadding;
                //						}
                //						if (isInverted) {
                //							mcOriX=this.getWidth()-mcOriX-mcWidth;
                //						}
                //
                //						ctx.fillStyle = this.bandColor1;
                //						this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                //					}
                //
                //					mcHeight=bulletHeight/2.0;
                //
                //					mcWidth=(mc3>0?mc3:-mc3)*ratioBetweenMetricViewWidth;
                //
                //					if(mc3>=0){
                //						mcOriX=xOri;
                //						mcOriY=(bulletHeight)/2-mcHeight/2+yPadding;
                //
                //					}
                //					else {
                //						mcOriX=xPadding;
                //						mcOriY=(bulletHeight)/2-mcHeight/2+yPadding;
                //					}
                //
                //					if (mMc3>=0) {
                //						ctx.fillStyle = this.blueBarPosColor;
                //						this.targetColor = this.blueBarPosColor;
                //					}
                //					else {
                //						ctx.fillStyle = this.blueBarNegColor;
                //						this.targetColor = this.blueBarNegColor;
                //					}
                //
                //
                //					if (isInverted) {
                //						mcOriX=this.getWidth()-mcOriX-mcWidth;
                //					}
                //
                //					this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                //
                //					if (hasRefLine) {
                //						mcHeight=bulletHeight;
                //						mcWidth=2;
                //						if (mc7>=0) {
                //							mcOriX=xOri+mc7*ratioBetweenMetricViewWidth;
                //							mcOriY=(bulletHeight)/2-mcHeight/2+yPadding;
                //						}
                //						else {
                //							mcOriX=xOri-(-mc7)*ratioBetweenMetricViewWidth;
                //							mcOriY=(bulletHeight)/2-mcHeight/2+yPadding;
                //						}
                //
                //						if (mMc3>0) {
                //							ctx.fillStyle = this.refLinePosColor;
                //							this.refLineColor = this.refLinePosColor;
                //
                //						}else{
                //							ctx.fillStyle = this.refLineNegColor;
                //							this.refLineColor = this.refLineNegColor;
                //						}
                //
                //						if (isInverted) {
                //							mcOriX=this.getWidth()-mcOriX-mcWidth;
                //						}
                //						this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);
                //					}

                ///////////the black line if necessary///////////////
                if (mc3 < 0) {
                    mcHeight = bulletHeight;
                    mcWidth = 2;
                    mcOriX = xOri;
                    mcOriY = yPadding;
                    redComp = 0;
                    greenComp = 0;
                    blueComp = 0;

                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }

                    ctx.fillStyle = "#000000";
                    this.drawRect(ctx, mcOriX, mcOriY, mcWidth, mcHeight);

                    //here, show the label
                    minValue = minValue + "";
                    var disPlayValue = (minValue == "0") ? "" : "$";//"$";
                    var mlen = 0;
                    for (var i = 0; i < minValue.length; i++) {
                        if (minValue[i] == '.') {
                            break;
                        }
                        mlen++;
                    }
                    for (var i = 0; i < minValue.length; i++) {
                        disPlayValue += minValue[i];
                        mlen--;
                        if (mlen % 3 == 0 && mlen > 0) {
                            disPlayValue += ",";
                        }
                    }
                    minValue = disPlayValue;
                    var textWidth = this.widget.getTextWidthByCanvas(minValue, this.minLabel);

                    minLabelWidth = textWidth - 1;

                    mcOriX = xOri;

                    if (isInverted) {
                        mcOriX = this.getWidth() - mcOriX - mcWidth;
                    }
                    if (mcOriX - minLabelWidth / 2 <= xPadding) {
                        this.minLabel.style.paddingLeft = xPadding;
                    } else if (mcOriX + minLabelWidth / 2 <= this.getWidth() - xPadding) {
                        this.minLabel.style.paddingLeft = Math.round(mcOriX - minLabelWidth / 2) + "px";
                    }
                    else {
                        this.minLabel.style.paddingLeft = Math.round((this.getWidth() - xPadding - minLabelWidth)) + "px";
                    }

                    this.minLabel.style.bottom = yPadding + "px";

                    //	this.minLabel.style.fontFamily = "Arial";
                    this.minLabel.style.fontSize = "7pt";
                    //	this.minLabel.style.fontStyle = "normal";
                    if (this.labelColorRGB) {
                        this.minLabel.style.color = 'rgb(' + this.labelColorRGB[0] + ',' + this.labelColorRGB[1] + ',' + this.labelColorRGB[2] + ')';
                    } else {
                        this.minLabel.style.color = "";
                    }
                    this.minLabel.innerHTML = minValue;
                    this.minLabel.style.display = "block";

                } else {
                    this.minLabel.style.display = "none";
                }

            },

            convertColor: function convrtClr(ngv) {
                var ret = "#";
                var base = parseInt("0xff");
                var blueComp = ngv & base;
                base = parseInt("0xff00");
                var greenComp = ((ngv & base) >> 8);
                base = parseInt("0xff0000");
                var redComp = ((ngv & base) >> 16);
                var redP = redComp.toString(16);
                if (redP.length < 2) {
                    redP = "0" + redP;
                }

                var greenP = greenComp.toString(16);
                if (greenP.length < 2) {
                    greenP = "0" + greenP;
                }

                var blueP = blueComp.toString(16);
                if (blueP.length < 2) {
                    blueP = "0" + blueP;
                }
                ret += redP;
                ret += greenP;
                ret += blueP;
                return ret;
            },

            drawRect: function (ctx, x, y, width, height) {
                // xiawang: remove the anti-aliasing effect by rounding to integer
                x = Math.round(x);
                y = Math.round(y);
                width = Math.round(width);
                height = Math.round(height);
                ctx.fillRect(x, y, width, height);
            },

            reDrawChart: function reDrwchart() {
                var context = this.context,
                    canvas = this.canvas,
                    wd = canvas.width,
                    ht = canvas.height;
                context.clearRect(0, 0, wd, ht);
                this.postBuildRendering();
            }
        }
    );

})();

(function() {

	mstrmojo.requiresCls("mstrmojo.Vis",
						 "mstrmojo.VisChartUtils",
						 "mstrmojo.VisChartData",
						 "mstrmojo.boxmodel"
						 );

	function getTooltipName(ch, s) {
		var nm = "",
			l = ch.length;
		
		if(l !== s.hi.length) {
			//something wrong these two must be the same
			return ch[0].items[s.hi[0]].n;
		}
		
		for(var i = 0; i < l; i++) {
			nm += (i > 0 ? " " : "") + ch[i].items[s.hi[i]].n;
		}

		return nm;
	}
		
	/**
	 * A Chart widget
	 * 
	 * @class
	 * @extends mstrmojo.Widget
	 */
	mstrmojo.VisChart = mstrmojo.declare(
			// superclass
			mstrmojo.Vis,

			// mixins
			null,
					/**
					 * @lends mstrmojo.VisChart.prototype
					 */
			{
				/**
				 * @ignore
				 */
				scriptClass: 'mstrmojo.VisChart',

				/**
				 * @ignore
				 */
				utils: mstrmojo.VisChartUtils,                        

				/**
				 * 
				 * @ignore
				 */
				data: mstrmojo.VisChartData,                        

				/**
				 * The list of items to display.
				 * 
				 * @type Array
				 */
				model: null,

				/**
				 * To remember the previous Y label co-ordinates to make sure it does not overlap
				 */
				prevYLabel: {x:0, y:0, h:0},

				/**
				 * To remember the previous X label co-ordinates to make sure it does not overlap
				 */
				prevXLabel: {x:0, y:0, w:0},

				/**
				 * @ignore
				 */
				context: null,

				/**
				 * The color used as the background of the Chart. It is also used to determine the color of the lines.
				 * @type String
				 */
				themeColor: '#000000',

				/**
				 * The color used when highligting items in the Chart
				 * @type String
				 */
				highlightColor: '#ff8833',

				/**
				 * An object representing the margins the Chart will have. It contains the following Objects: t (top), r (right), b (bottom), l (left).
				 * @type Object
				 */
				margin: {t:50, r:2, b:30, l:2},

				/**
				 * Widget offset in pixels
				 */
				offsetLeft: null,

				/**
				 * padding to use between x axis labels
				 */
				xLabelPadding: 10,

				/**
				 * padding to use between y axis labels
				 */
				yLabelPadding: 10,

				/**
				 * Property that determines if we need to draw axis in the chart.
				 * If no axes are drawn labels are excluded automatically
				 */
				isDrawAxis: true,

				/**
				 * Property that determines if we need to draw labels on x axis
				 */
				drawXAxisLabels: true,

				/**
				 * Property that determines if we need to draw labels on y axis
				 */
				drawYAxisLabels: true,

				/**
				 * Property that determines if need to draw highlight when touch event occurs
				 */
				isHighlightOnTouch: true,

				/**
				 * property that defines if the chart is linear or based on low high point values
				 */
				isLinearChart: true,

				/**
				 * if we want to show the highlight line on the chart
				 */
				showHighlightLine: true,

				browserSupportsHtml5: true,

				/**
				 * if the user want to display a single line or multi line chart.
				 */
				multiLine: true,

				/**
				 * draw the Grid Lines.
				 * 0 - No Grid Line
				 * 1 - Horizontal lines only
				 * 2 - Vertical lines only
				 * 3 - Both horizontal and vertical lines
				 */
				drawGridLines: 3,

				/**
				 * Variable to control drawing horizontal lines
				 */
				drawHorizontalGridLines: 1,

				/**
				 * Variable to control drawing vertical lines
				 */
				drawVerticalGridLines: 2,

				/**
				 * Variable that controls the behavior of tooltip and selection point selection
				 * if true we select next point closer to the touch for move events.  If it is 
				 * set to false on touch start the closer line will be selected and will remain
				 *  to be the one even during move another line become closer.
				 *  By default it is true for chartLine and false for TimeSeries.
				 */
				switchSeriesOnTouch: true,

				/**
				 * variable that works in conjuction with switchSeriesOnTouch to cache the series index that
				 * will be selected on touch and stay cached during the move event.
				 */
				seriesIndex: -1,

				/**
				 * This property will help determine the user if we have display mode set to regular or micro-chart
				 * 0 - regular
				 * 1 - micro-chart
				 * setting this property other than displayMode to regular will result in overwriting bunch of other properties
				 * to ensure that the micro-chart behavior is maintained 
				 */
				displayMode: 0,
				
				/**
				 * @ignore
				 */
				markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};top:{@top};left:{@left};position:relative;" ' +
				' mstrAttach:mousedown,mouseup,mousemove,click ' +                             
				'><canvas width="{@width}" height="{@height}"></canvas>' + 
				'<canvas style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>' + 
				'<canvas style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>' +
				'<div id="{@id}-tooltip" class="mstrmojo-Chart-tooltip"></div>' + 
				'</div>',

				/**
				 * @ignore
				 */
				markupSlots: {
					//the main canvas of the Chart
					canvas: function(){ return this.domNode.firstChild; },

					//the base canvas for animation @TODO: each animation should create independent canvas objects
					animationCanvas: function(){ return this.domNode.childNodes[1]; },

					//the canvas used for highlighting points
					highlightCanvas: function(){ return this.domNode.childNodes[2]; },

					//the tooltip display when highlighting points
					tooltip: function(){ return this.domNode.childNodes[3]; }
				},

				/**
				 * @ignore
				 */
				postBuildRendering: function postBR() {
					if (this._super) {
						this._super();
					}
					this.browserSupportsHtml5 = this.canvas.getContext; 
	                if (!this.browserSupportsHtml5) {
	                	this.renderErrorMessage(mstrmojo.desc(8126,'Your browser does not support HTML5')); 
	                	return;
	                }
	                if (!this.model) {
	                	this.renderErrorMessage(mstrmojo.desc(8426,'No model provided'));
	                	return; // should return here
	                }
	                // If error message is received than print error message and return
	                if(this.model.err || this.model.eg) {
						this.renderErrorMessage(this.model.err  || this.model.eg);
						return;
					}
	                
	                // process data
	                if(this.isLinearChart) {
	                	this.data.processLinearData(this);
	                } else {
	                	this.data.process(this);
	                }
	                
	                //cache the values length property
	                this.windowSize = this.model.series[0].rv.length;						

					//cache the different canvas' context objects in the Widget
	                this.context = this.canvas.getContext('2d');
					this.highlightContext = this.highlightCanvas.getContext('2d');
					this.animationContext = this.animationCanvas.getContext('2d');
										
					//fill the Chart's background with the theme color
					this.utils.fillBackground(this);

					if(this.windowSize <= 1) {
						return; // not enought data to draw chart
					}
					//trigger the Chart's plot method
					this.plot();
				},
				
				/*
				 * return the max value of all the points on Y axis
				 */
				getMaxValue: function getMaxV(){
					var vals = this.model.mvalues;					
					return vals && vals[vals.length - 1];
				},
				
				/*
				 * return the min value of all the points on Y axis
				 */
				getMinValue: function getMinV(){
					var vals = this.model.mvalues;
					
					return vals && vals[0];
				},

				/**
				 * Called to render the Chart elements
				 */
				plot: function plt() {

					// draw the chart
					this.drawChart();

					// If error is found don't draw any axis etc just return. Error message should be displayed
					// from the drawChart method already
					if(this.model.err  || this.model.eg) {
						return;
					}

					//draw the Chart's axes.
					if(this.isDrawAxis) {
						
						if(this.isTimeSeries || !(this.isAnimateLines && (!this.multiLine || this.model.series.length === 1 ))) {
							this.drawLabels();
						}
						else{
							this.drawAxis();
						}
					}
				},

				/**
				 * draw the actual chart lines/bars
				 */
				drawChart: function drwchrt() {},

				/**
				 * Called to render the Chart axes
				 */
				drawAxis: function drwAxs() {
					var utils = this.utils,
						margin = this.margin,
						width = this.getWidth(),
						height = this.canvas.height,
						context = this.context;

					context.save();

					//set the style of the axes lines    
					context.strokeStyle =  utils.getColor(this);
					context.lineWidth = 2;
					context.globalAlpha = 0.3;

					//draw the rectangle
					utils.drawRectangle(this, margin.l, margin.t, width - margin.l - margin.r, height - margin.t - margin.b);

					context.restore();
				},

				/**
				 * Called to render the Chart data labels. By default this method renders labels for the max and min values of a single axis Chart
				 */
				drawLabels: function drwlbls() {
					if (!this.isDrawAxis || !this.drawYAxisLabels) return;
					var model = this.model,
					utils = this.utils,
					margin = this.margin,
					v = model.mvalues,
					ylbls = model.ylbls,
					l = v.length,
					dgl = this.drawGridLines;

					this.prevYLabel.x = 0;
					this.prevYLabel.y = 0;
					this.prevYLabel.h =0;
					
					for(var i = 0; i < l; i++) {
						var y = utils.getYValue(this, v[i]);
						var lbl = utils.addDataLabel(this, ylbls[i], y, this.prevYLabel);
						//only if label was drawn draw the highlight			
						var yPos = Math.floor(y) + 0.5;
						if(lbl && (dgl & this.drawHorizontalGridLines) && i > 0 && i < l-1 ) {
							utils.drawHighlightLine(this, yPos);
						}
						if(i == l-1 && this.isTimeSeries && lbl && (dgl & this.drawHorizontalGridLines)){
							utils.drawHighlightLine(this, yPos);
						}
					}
				},

				renderTooltip: function rndrttp(valIndex, touchX, touchY) {
					if (valIndex < 0) {
						this.tooltip.style.display = 'none';
						return;
					}

					var m = this.model, 
						s = m.series,
						utils = this.utils,
						l = s.length,
						si = this.seriesIndex,
						ch = m.colHeaders,
						ttp = this.tooltip;

					// also put the series name
					var sn = ''; 

					//if not multiline get the value of series to be drawn
					if(!this.multiLine) {
						sn = getTooltipName(ch,s[0]) + ': ' + s[0].v[valIndex];
					} else {
						//Now if we are drawing multiLines get all the values of highlight line
						// have to be shown
						if(this.showHighlightLine) {
							for(var i = 0; i < l; i++) {
								sn += (i === 0 ? '' : '<br/>') + getTooltipName(ch,s[i]) + ': ' + s[i].v[valIndex];
							}
						} else {
							//else draw the index based on the series selected
							sn = getTooltipName(ch,s[si]) + ': ' + s[si].v[valIndex];
						}

					}

					//Cached the row/attribute values
					var rVal = this.model.categories.items[valIndex];

					//Set the tooltip text 
					ttp.innerHTML = rVal + '<br/>' + sn;

					//show the tooltip
					ttp.style.display = 'block';

					//Calculate the position of the highlight tooltip and adjust if necesary

					//get the width of the tooltip div
					var tooltipWidth = ttp.offsetWidth;

					var toolx = touchX - tooltipWidth /2;
					var margin = this.margin;

					if (toolx < margin.l) {
						toolx = margin.l;
					} else if (toolx > this.getWidth() - margin.r - tooltipWidth) {
						toolx = this.getWidth() - margin.r - tooltipWidth;
					}

					//Set the tooltip position
					if(this.showHighlightLine) {
						utils.translateCSS(toolx, 0, false, ttp);
					} else {
						//series should actually be picked up either for one that is drawn or which is the closest to the touch
						// get the ypos to show the tooltip and make sure it fits inside the window.
						var yPos = utils.getYValue(this, s[si].rv[valIndex]) - ttp.offsetHeight - 20;
						if(yPos < 0 ) {
							yPos = utils.getYValue(this, s[si].rv[valIndex]);
						}
						utils.translateCSS(toolx, yPos, false, ttp);
					}

				},

				/**
				 * Returns the selected value (null if nothing is selected)
				 * @param x the x position of the click event
				 * @param y the y position of the click event
				 * @return the selected value (null if nothing is selected)
				 */
				getTouchValue: function gtvlindx(x,y) {
					var md = this.model,
						m = this.margin;

					var sz = md.rne - md.rns > 0 ? md.rne - md.rns > 1 ? md.rne - md.rns : 2 : this.windowSize;
					var touchVal = Math.round(((x - m.l) * (sz - 1))/(this.getWidth() - m.l - m.r - 1));
					return (touchVal < sz) ? touchVal: null;
				},

				/**
				 * Called to highlight a single data point. Implemetation left empty for Chart Widgets. 
				 * @param {Integer} [x] the x axis point to highlight
				 */
				highlightPoint: function hghlghtpnt(x, touchY) {

				},

				/**
				 * Handles the touch begin event.
				 * @private
				 */
				handleTouchBegin: function handleTouchBegin(touchX, touchY) {
					if(!this.isHighlightOnTouch || !this.browserSupportsHtml5) {
						return;
					}
					this.tooltipOn = true;
					this.adjustWidgetOffsets();
					this.handleTouchMove(touchX, touchY);
				},

				/**
				 * Handles the touch move event. The method positions the Chart tooltip and calls highlightPoint()
				 * @private
				 */
				handleTouchMove: function handleTouchMove(touchX, touchY) {
					var me = this,
						m = me.model;
						
					if (!me.tooltipOn || !me.isHighlightOnTouch || !this.browserSupportsHtml5 || this.windowSize <= 1) {
						return;
					}

		             var touchPointOnWidget = me.utils.getTouchXYOnWidget(touchX, touchY, me);	
					touchX = touchPointOnWidget.touchX;
					touchY = touchPointOnWidget.touchY;     

					var margin = me.margin;

					// if we have not touched in the chart area don't do anything
					if(touchX < margin.l || touchY < margin.t || touchY > me.canvas.height - margin.b) {
						return;
					}

					//Get the index of the values array that matched the x coordinate where the event happened.
					var touchVal = me.getTouchValue(touchX,touchY);

					//The points falls within a valid window
					if (touchVal !== null) {

					//	var x = (touchVal * me.RTX) + margin.l;

						// adjust rns value if the difference is only 1 point
						var rns = (m.rne - m.rns > 1) ? m.rns : m.rns - 1;

						// if this is the first time we come in select the series we try to display
						if(me.seriesIndex === -1 || me.switchSeriesOnTouch) {
							me.seriesIndex = me.utils.getSeriesIndexAndYValue(me, rns + touchVal, touchY).si;
						}

						//This point has no value
						if(m.series[me.seriesIndex].rv[rns + touchVal] === "") {
							return;
						}
						
						//remember previous highlightpoint position
						me.prevHighlight = me.currentHighlight;
						
						//cache the highlightpoint position
						me.currentHighlight = touchVal;
						
						//render the tooltip
						me.renderTooltip(touchVal, touchX, touchY);
						
						//Call the method that will highlight the current point 
						if(this.isTimeSeries){
							me.highlightPoint(touchVal, touchX, touchY);
						}else{
							me.highlightPoint(touchVal, touchY);	
						}
						
					}
				},

				/**
				 * Handles the touch end event.
				 * @private
				 */
				handleTouchEnd: function handleTouchEnd() {
			        if (!this.browserSupportsHtml5) {
			        	return;
			        }
					var me = this;
					
					if(me.model.err || this.model.eg) {
						return;
					}
					me.tooltipOn = false;

					me.seriesIndex = -1;
					me.currentHighlight = null;
					
					//erase the highlight context.
					//me.highlightContext.clearRect(0, 0, me.getWidth(), me.highlightCanvas.height);
					me.highlightCanvas.height = me.highlightCanvas.height;

					//hide the tooltip
					me.tooltip.style.display = 'none';
				},
				
				/**
				 * @ignore
				 */
				onmousedown: function(evt) {
					if(!this.isAndroid) {
						this.handleTouchBegin(evt.e.pageX, evt.e.pageY);
					}
				},

				/**
				 * @ignore
				 */
				onmouseup: function(evt) {
					if(!this.isAndroid) {
						this.handleTouchEnd();
					}
				},

				/**
				 * @ignore
				 */
				onmousemove: function(evt) {
					if (!this.isAndroid) {
						this.handleTouchMove(evt.e.pageX, evt.e.pageY);
					}
				}				
			}
	);

})();
/**
  * AndroidMap.js
  * Copyright 2010-2012 MicroStrategy Incorporated. All rights reserved.
  * @version 1.0

  * @fileoverview <p>Widget for displaying Maps rendered by Google Maps JavaScript API.</p>
  * @author <a href="mailto:dhill@microstrategy.com">Doug Hill</a>
  */
  
  (function () {

    mstrmojo.requiresCls("mstrmojo.Vis",
                         "mstrmojo.hash",
                         "mstrmojo.GeoLocation",
                         "mstrmojo._TouchGestures");

    var GD_SEP = '\u001F',
    	GR_SEP = '\u001E',
    	GC_SEP = '\u001D',
    	GI_SEP = '\u001C',
    	GV_SEP = '\u001B';
    
    /**
     * Toggles the opacity of the preview image node.
     *
     * @param {mstrmojo.Image} preview The preview image control.
     * @param {Number} opacity The new opacity of the image.
     *
     * @private
     */
    function togglePreviewCtrl(preview, opacity) {
    	if (!!preview && !!preview.imgNode) { 
            var imgNodeStyle = preview.imgNode.style;
            //imgNodeStyle.webkitTransitionDuration = (opacity) ? '300ms' : 0;
            imgNodeStyle.opacity = opacity;
    	}
    }
    
    
    
    var PREVIEW_CLS_NAME = mstrmojo.Image.baseCssClass + '-prv';

    /**
     * <p>A widget to display an Android specific Android Map.</p>
     *
     * This is intended to live inside an AndroidView widget as the contentChild.
     *
     * @class
     * @extends mstrmojo.Box
     */
    mstrmojo.maps.androidmap.AndroidMap = mstrmojo.declare(
        mstrmojo.Vis,

        null,

        {
            scriptClass: "mstrmojo.maps.androidmap.AndroidMap",

            cssClass : "mstr-googleMapView",

            markupString: '<div id="{@id}" class="mstrmojo-Box {@cssClass}" style="{@domNodeCssText}" mstrAttach:touchstart>' +
                          '</div>',

            reRenderOnDimensionChg: false,
            
            mapRendered: false,
            
            firstScreen: true,
            
            children: [{
                scriptClass: 'mstrmojo.Image',
                alias: 'imgPreview',
                cssClass: 'prv',
                cssText: 'position:absolute;left:0;top:0;',
                firstLoad:false,
                onload: function () {
                    // Image is done loading so toggle opacity to 1.0.
                    togglePreviewCtrl(this, 1);
                    var ths = this;
                    window.setTimeout(function() 
              		{
              			ths.parent.postImageProcessing(ths.firstLoad);
              			ths.firstLoad = false;
              		},300);
                }
            }],
            
           /**
            * map is the slot for the googleMap object
            * metricSelector is the slot for the metric selector label
            *
            */
           markupSlots : {
               containerNode : function() {return this.domNode;}
           },

            markupMethods: {
                onheightChange: function(){
                    this.domNode.style.height = this.getHeight() + 'px';
                },
                onwidthChange: function(){
                    this.domNode.style.width = this.getWidth() + 'px';
                }
            },

            setModel: function setModel(model) {
                this.set('model', model);
                this.xtabModel = model;
                if ( model.data ) {
                    this.set('gridData', model.data);
                }
            },
            
            postImageProcessing:function postImageProcessing(firstLoad) {
            	if (firstLoad && this.controller && this.controller.takeScreenShot) {
            		this.controller.takeScreenShot();
            	}
            	if (this.imgPreview.src != '' && mstrMobileApp && mstrMobileApp.hideMapView) {
                    window.setTimeout(function(){
                        mstrMobileApp.hideMapView(0);
                    }, 100);
                }
            },

            ongridDataChange: function() {
                this.parser = new mstrmojo.Vis.DataParser(this.gridData);
                //clear data map object to force generating a new data to push to native side
                delete this.dataMap;
            },

            update: function update(node) {
                node = node || this.node;
                if (node) { // called from docs
                	if (node.data) {
                	
                	    this.set('gridData', node.data);

                        var gd = this.gridData;
                		if (gd.layoutModel) this.layoutModel = gd.layoutModel;
                		if (gd.layoutNode) this.layoutNode = gd.layoutNode;
                		
                		delete gd.layoutModel;
                		delete gd.layoutNode;
                	}
                    var fmts = node.defn.fmts || node.defn.units[this.xtabModel.k].fmts;

                    this.width = parseInt(fmts.width, 10);
                    this.height = parseInt(fmts.height, 10);
                    this.top = parseInt(fmts.top,10);
                    this.left = parseInt(fmts.left,10);
                    this.fmts = fmts;
                }

                if (this.xtabModel) {
                	this.initFromVisProps(this.gridData.vp);
                }
                this.updated = true;
                
            },

            getMapModel: function() {
                var pid = mstrApp.getCurrentProjectId(),
                	sessions = mstrApp.serverProxy.getSessions();

                return {
                    pid: pid,
                    sessions: sessions,
                    mapId: this.id,
                    hasTarget: false,
                    hostUrl: mstrApp.getConfiguration().getHostUrlByProject(pid)
                };
            },
            
            getGridModel: function() {
            	var gridModel = mstrmojo.hash.copy(this.gridData, {}); 
            	
            	return gridModel;
            },

			initFromVisProps: function initFromVisProps(vp) {
                this.vp = vp;
            },
			
            dispatchMapData: function dispatchMapData() {
                var mapModel = this.getMapModel(),
                	gd = this.simplifyGridData();

                mstrMobileApp.loadMap(JSON.stringify(mstrmojo.hash.copy(mapModel, {
                	gdProp: gd.prop,
                    infoWindow: {dft: true}
                })), gd.es, gd.data, '');
                
                //set the map status to be rendered
                this.mapRendered = true;
            },
            
            /**
             * Convert grid data into three properties: prop, es, and data. The prop property contains properties vp, ts, th, gts. 
             * The es contains a string connected with string seperators to connect all row header es collection and metrics collection.
             * The data property contains a string with string seperators to combine the row header value and metric values.    
             */
            simplifyGridData: function simplifyGridData() {
            	if(this.dataMap) {
            		return this.dataMap;
            	}
            	var gd = this.gridData,
            		ghs = [],
            		gvs = [],
            		gts = {row: [], col: []}, o, row, col, ges = [], res = [], ces = [],
            		rd = [], items = [], cv, //cv: complicate type, including ti, ts
            		ritems, citems, i, iLen, j, jLen;
            	
            	// if there are no grid headers or row titles, we don't really have any data to display on maps. 
            	if (typeof(gd.ghs) == 'undefined' || (gd.gts.row.length == 0)) {
            		gd.eg = 'no data returned';
            	}
            	//empty grid with no data
            	if(gd.eg) {
            		this.dataMap = {prop: {}, data: '', es: ''};
            	} else {
            		//go through each row to put all the row items into ghs array
                	for(i = 0, ritems = gd.ghs.rhs.items, iLen = ritems.length; i < iLen; i++) {
                		//for each row, get the item idx and put it into rd array 
                		for(j = 0, citems = ritems[i].items, jLen = citems.length; j < jLen; j++) {
                			rd.push(citems[j].idx);
                		}
                		//connect each row item with GC_SEP (column seperator)
                		ghs.push(rd.join(GC_SEP));
                		//clear rd once the data is pushed into ghs
                		rd = [];
                	}

                	//do the same thing for each metric values
                	for(i = 0, ritems = gd.gvs.items, iLen = ritems.length; i < iLen; i++) {
                		//for each row of values
                		for(j = 0, citems = ritems[i].items, jLen = citems.length; j < jLen; j++) {
                			//push the value first
                			items.push(citems[j].v);
                			//then raw value
                			items.push(citems[j].rv || 0);
                			//combine ti and ts as a single unit pushed 
                			if(citems[j].ti !== undefined || citems[j].ts !== undefined) {
                				//empty value as default
                				v = '';
                				if(citems[j].ti !== undefined) {
                					//put ty into th to optimize
                					gd.th[citems[j].ti].ty = citems[j].ty;
                					v = citems[j].ti;
                				}
                				//seperate with value seperator
                				v += GV_SEP;
                				if(citems[j].ts !== undefined) {
                					v += citems[j].ts;
                				}
                				items.push(v);
                			}
                			//put the items into rd array
                			rd.push(items.join(GI_SEP));
                			items = [];
                		}
                		//put the each row into gvs
                		gvs.push(rd.join(GC_SEP));
                		rd = [];
                	}
                	
                	//make a copy of gts to minimize the data
                	//start from row
                	row = gd.gts.row;
                	mstrmojo.array.forEach(row, function(v){
                		o = {};
                		//only copy the following properties into gts
                		mstrmojo.hash.copyProps(['n', 'id', 'fid', 'fs', 'sc'], v, o);
                		gts.row.push(o);
                		rd = [];
                		//meanwhile, generate the es collection into rd array 
                		mstrmojo.array.forEach(v.es, function(elem) {
                			rd.push(elem.n);
                		});
                		//row es collection
                		res.push(rd.join(GI_SEP));
                	});
                	//put the es collection into ges
                	ges.push(res.join(GR_SEP));
                	
                	//then move to column data
                	col = gd.gts.col;
                	mstrmojo.array.forEach(col, function(v) {
                		o = {};
                		mstrmojo.hash.copyProps(['n', 'id', 'fid'], v, o);
                		gts.col.push(o);
                		rd = [];
                		//move es collection into rd array
                		mstrmojo.array.forEach(v.es, function(elem) {
                			rd.push(elem.n);
                		});
                		//push into column es collection
                		ces.push(rd.join(GI_SEP));
                	});
                	//put the es collection into ges
                	ges.push(ces.join(GR_SEP));
                	
                	//save the data map
                	this.dataMap = {
                		prop: {
                			vp: gd.vp,
                			th: gd.th,
                			gts: gts
                		},
                		es: ges.join(GD_SEP),
                		data: ghs.join(GR_SEP) + GD_SEP + gvs.join(GR_SEP)
                	};
            	}
            	
            	return this.dataMap;
            },
            
            getModel: function getModel() {
                return this.gridData;
            },
            
            handleMarkerSelection: mstrmojo.emptyFn,
			
            postBuildRendering : function postBuildRendering(){
               //send grid data to native side
               this.dispatchMapData();
               
               this._super();
            },

            rebuildLayout: mstrmojo.emptyFn,

            resetLayout: mstrmojo.emptyFn,

            setDimensions: function setDimensions(h, w) {
                var map = this.googleMap,
                    center = map ? map.getCenter() : null,
                    dimensionChanged = this._super(h, w);

                if ( map ) {
                    this.map.style.height = this.getHeight() + "px";
                   	this.map.style.width = (this.getWidth() - 1) + "px";
                   	map.setCenter(center);
                }
               	
                return dimensionChanged;            	
            },
            
            unrender:function unrender() {
            	this.imgPreview.src = '';
            	if(this.mapRendered) {
                    this.removeMap();
                    this.mapRendered = false;
                }
            	this._super();
            },
            
            removeMap:function removeMap() {
            	mstrMobileApp.hideMapView("1");
            },
            switchToImage: function switchToImage(src,width,height) {
                // Do we have a preview source?
                var imgPreview = this.imgPreview;
                imgPreview.firstLoad = this.firstScreen;
                this.firstScreen = false;
                if (src && imgPreview.hasRendered) {
                    // Does the existing image source not match the new source?
                    if (imgPreview.src !== src) {
                        // Set preview opacity to 0 so the image doesn't flash when we set the source.
                        togglePreviewCtrl(imgPreview, 0);
        
                        // Reset the class name.
                        imgPreview.domNode.className = PREVIEW_CLS_NAME;
        
                        // Set the new source.
                        imgPreview.set('src', src);
                        
                        imgPreview.set('width',width);
                        imgPreview.set('heihgt',height);
                        
                        //imgPreview.set('visible',true);
                    } else if (mstrMobileApp && mstrMobileApp.hideMapView) {
                    	togglePreviewCtrl(this.imgPreview,1);
                    	//put hide map view in timeout as the toggle might take some time longer
                    	this.postImageProcessing(false);
                    }
                } else {
                    mstrMobileApp.hideMapView(0);
                }
            },
            hidePreview:function hidePreview() {
            	togglePreviewCtrl(this.imgPreview,0);
            },
            showPreview:function showPreview() {
            	togglePreviewCtrl(this.imgPreview,1);
            },
            closeInfoWindow: function closeInfoWindow() {
                //close all the opening dialog until the info window dialog is closed.
                do{
                    mstrApp.closeDialog();
                } while(mstrmojo.all.mstrMapInfoWindow);
            },
            ontouchstart: function ontouchstart() {
                if(this.mapRendered) {
                    mstrMobileApp.showMapView(0);
                }
            },
            
            destroy: function destroy() {
                //TODO: detach scrolling event listeners
                var p = this.parent;
                while(p) {
                    if(p._scroller && p.scrollMoveListener) {
                        //TODO: add code here to detach functions
                    }
                    p = p.parent;
                }                
            	this._super();
            	if (this.mapRendered) {
            	    mstrMobileApp.navigateAway();
            	}
            }
        }
    );
})();
(function(){

    mstrmojo.requiresCls('mstrmojo.url', 'mstrmojo.Vis', 'mstrmojo._CanSupportTransaction');
    
    mstrmojo.PhotoUploader = mstrmojo.declare(
            
            mstrmojo.Vis,
            
            [mstrmojo._CanSupportTransaction, mstrmojo._TouchGestures],
            
            {
                scriptClass: 'mstrmojo.PhotoUploader',
                
                photoNum: 0,
                
                markupString: '<div id="{@id}" class="mstrmojo-PhotoUploader" style="left:{@left};top:{@top};width:{@width};height:{@height}" mstrAttach:click>' +
                                  '<div class="actionButton" style="line-height:{@height}">{@n}</div>' +
                                  '<img class="preview"></img>' +
                                  '<div class="numberBadge">' +
                                      '<div class="badgeText"></div>' +
                                  '</div>' +
                              '</div>',
                
                markupSlots: {
                    buttonNode: function(){ return this.domNode.firstChild;},
                    previewNode: function(){ return this.domNode.childNodes[1];},
                    badgeNode: function() { return this.domNode.lastChild;},
                    badgeTextNode: function() {return this.domNode.lastChild.firstChild;}
                },
                
                markupMethods:{
                    onphotoNumChange: function(){
                        mstrmojo.css.toggleClass(this.domNode, 'empty', this.photoNum == 0);
                        if (this.photoNum > 0){
                            this.badgeTextNode.innerHTML = this.photoNum;
                        }
                    }
                },
               
                preBuildRendering: function(){
                    this._super();
                    
                    var dp = this.getDataParser(),
                        rowTitles = dp.getRowTitles(),
                        colTitles = dp.getColTitles(),
                        firstRow, t1, t2, t3, atid1, atid2;
                    
                    if (rowTitles.size() < 3 && colTitles.size() < 1){
                        // Must have at least 3 attribute forms and 1 metric
                        mstrmojo.alert("Incorrect grid template structure!");
                        return false;
                    } else if (dp.getTotalRows() < 10){
                        // Must have at least 10 rows 
                        mstrmojo.alert("At least 10 rows required!");
                        return false;
                    } 
                    
                    firstRow = dp.getRowHeaders(0);
                    t1 = rowTitles.getTitle(0); //photo path attribute
                    t2 = rowTitles.getTitle(1); //photo description attribute
                    atid1 = t1.getUnitId(); // attribute id
                    atid2 = t2.getUnitId();
                    t3 = colTitles.getTitle(0).getHeaderValues()[0]; //count metric
                    
                    this.cellInfo = [{
                        atid: atid1,
                        form_id: t1.getFormId(),
                        ui: 0
                    }, {
                        atid: atid2,
                        form_id: t2.getFormId(),
                        ui: (atid1 == atid2) ? 0:1 //if two forms are from the same attribute, then unit index should be the same
                    }, {
                        metric_id: t3.oid
                    }];

                    this.photoNum = 0; //reset photoNum
                    this.n = mstrmojo.desc(8470);
                },
                
                /**
                 * @override
                 */
                setModel: function(model){
                    this.model = this.txModel = model && model.docModel;
                },
                
                /**
                 * @param k the current row ordinal
                 * @return
                 */
                getKeyContext: function(k){
                    return { o: parseInt(k, 10) };
                },
                
                /**
                 * generate manipulation JSON for android
                 */
                getUpdateObject: function(i){
                    var udvs = this.getUpdatedValues(),
                        CHANGE_DATA = 2, //manipulation type for grid cell change
                        cells = [], ci = this.cellInfo;
                    
                    for (var i in udvs){
                        var udv = udvs[i],
                            photoPath = mstrmojo.string.encodeXMLAttribute(String(udv.v[0])),
                            photoDesc = mstrmojo.string.encodeXMLAttribute(String(udv.v[1])),
                            count = '1';
                        cells.push({
                            rowOrdinal: udv.o, //photo path attr
                            attId: ci[0].atid,
                            formId: ci[0].form_id,
                            unitIndex: ci[0].ui,
                            newValue: photoPath
                        }, {
                            rowOrdinal: udv.o, //photo desc attr
                            attId: ci[1].atid,
                            formId: ci[1].form_id,
                            unitIndex: ci[1].ui,
                            newValue: photoDesc
                        }, {
                            rowOrdinal: udv.o, //count metric
                            colOrdinal: 0,
                            newValue: count
                        });
                    }
                    
                    return {
                        manipulation: CHANGE_DATA,
                        nodeKey: this.k,
                        sliceId: this.sid,
                        cells: cells,
                        autoRefresh: false
                    };
                },
                
                /**
                 * generate manipulation xml for oivm
                 * TODO: data type is hardcoded, should read this info from txi node.
                 */
                getUpdates: function getUpdates(){
                    var eg = [], 
                        w = this, 
                        j, udt = false,
                        udvs = this.getUpdatedValues(), udv,
                        TX_ELEM_ATT_FORM = 1,
                        TX_ELEM_METRIC = 2,
                        DssXmlDataTypeVarChar = 9,
                        DssXmlDataTypeInteger = 1,
                        ci = this.cellInfo;
                    
                    eg.push('<gr rw_tree_type="' + this.defn.tt + '" rw_node_key="' + w.k + '" slice_id="' + (w.sid || 0) + '">');
                    
                    for(j in udvs) {
                        if(udvs.hasOwnProperty(j)) {
                            udv = udvs[j];
                            
                            for (var i = 0; i < 2; i++){
                                eg.push('<cli ax="1" attribute_id="' + ci[i].atid + '" form_id="' + ci[i].form_id + '">' + 
                                            '<updt types="' + TX_ELEM_ATT_FORM +'" ordinal="' + udv.o + '" value="' + udv.v[i] + '" dt="' + DssXmlDataTypeVarChar + '"/>' +
                                        '</cli>');
                            }
                            
                            eg.push('<cli cordinal="0" metric_id="' + ci[2].metric_id + '">' + 
                                        '<updt types="' + TX_ELEM_METRIC + '" rordinal="' + udv.o + '" value="1" dt="' + DssXmlDataTypeInteger + '"/>' +
                                    '</cli>');
                            
                            udt = true;
                        }
                    }
                    eg.push('</gr>');
                    if (!udt){
                        eg = [];
                    }
                    
                    return eg.join('');
                },
                
                /**
                 * callback upon the photo has been uploaded
                 */
                photoUploaded: function(imagePath, description){
                    mstrMobileApp.setWaitScreenVisibility(false);
                    var url = mstrmojo.url.getAbsoluteURL(imagePath, mstrApp.getConfiguration().getCurrentProjectWebServerUrl()),
                        desc = description,
                        currentIdx = this.photoNum;
                    
                    this.previewNode.src = url;
                    
                    this.dataChanged(currentIdx, {}, {v: [url, desc]});

                    this.set('photoNum', currentIdx + 1);
                },
                
                touchTap: function(){
                    this.onclick();
                },
                
                onclick: function(){
                    if (this.photoNum == 10){
                        mstrmojo.alert("can upload at most 10 photos");
                    }else{
                        var params = {
                            serverUrl: mstrApp.getConfiguration().getTaskUrlByProject(mstrApp.getCurrentProjectId()),
                            sessionState: mstrApp.getSessionState(),
                            descs: {
                                'ADD_PHOTO' : mstrmojo.desc(8470),
                                'TAKE_NEW_PHOTO' : mstrmojo.desc(8471),
                                'CHOOSE_FROM_GALLERY' : mstrmojo.desc(8472),
                                'DONE' : mstrmojo.desc(8473),
                                'CANCEL' : mstrmojo.desc(221)
                            }
                        };
                        
                        //TODO: let controller decide instead of calling mstrMobileApp interface directly.
                        mstrMobileApp.uploadPhotos(JSON.stringify(params), 'mstrmojo.all["' + this.id + '"].photoUploaded');
                    }
                }
            }
    );

}());
(function() {

	mstrmojo.requiresCls("mstrmojo.Vis",
			"mstrmojo.VisChartUtils",
			"mstrmojo._TouchGestures",
			"mstrmojo._HasTouchScroller",
			"mstrmojo.color",
			"mstrmojo.array",
			"mstrmojo.css" );


	var browserSupportsHtml5 = true;

	var DISPLAY_MODE_AUTOMATIC = "0",
		DISPLAY_MODE_AREA = "1",
		DISPLAY_MODE_BUBBLE = "2";

	var MARKER_UNDEFINED = 0,
		MARKER_IMAGE = 1,
		MARKER_BUBBLE = 2;

	var SHAPE_FILE_UNDEFINED = 0,
		SHAPE_FILE_POLYGON = 1,
		SHAPE_FILE_POINT = 2;

	var THRESHOLD_UNDEFINED = 0,
		THRESHOLD_COLOR = 1,
		THRESHOLD_IMAGE = 2;

	var SIZE_MODE_AUTOMATIC = 0,
		SIZE_MODE_MANUAL = 1;
	
	// bubble size
	var MAX_RATIO_UP_LIMIT = 1.0,
		MAX_RATIO_LOW_LIMIT = 0.01;
	// TQMS: 685697, adjust the bubble size according to Flash mode
	var MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER = 0.3,
		MAX_SIZE_DEFAULT_RATIO_FOR_AUTOMATIC = 0.3,
		MAX_SIZE_DEFAULT_RATIO_FOR_MANUAL = 0.3;

	var HIGHLIGHT_MODE_NORMAL = 0,
		HIGHLIGHT_MODE_HOVER = 1,
		HIGHLIGHT_MODE_SELECTED = 2;

	var THEME_DARK = 0,
		THEME_LIGHT = 1;
		
	var DRILLING_ACTION = 1,
		SELECTOR_ACTION = 2,
		HYPERLINK_ACTION = 4;
		
	var ROW_AXIS = 1,
		COL_AXIS = 2;

	var DEFAULT_BG_COLOR = "#FFFFFF";

	var POLY_COLOR_NO_ALT_DARK_THEME = "RGBA(139,139,139,0.8)", // 8B8B8B
		POLY_COLOR_NO_COLORBY_DARK_THEME = "RGBA(33,195,255,0.8)", // 21C3FF
		POLY_COLOR_NO_ALT_LIGHT_THEME = "RGBA(195,195,195,0.8)", // C3C3C3
		POLY_COLOR_NO_COLORBY_LIGHT_THEME = "RGBA(112,168,207,0.8)", // 70A8CF
		POLY_STROKE_COLOR_DARK_THEME = "#4C4C4C",
		POLY_STROKE_COLOR_LIGHT_THEME = "#FFFFFF",
		POLY_NORMAL_OPACITY = 0.8,
		POLY_ABOVE_BG_OPACITY = 0.7,
		POLY_UNDER_BUBBLE_OPACITY = 1,
		POLY_HOVER_OPACITY = 0.5,
		POLY_LINKDRILL_OPACITY = 0.5,
		POLY_SELECTED_OPACITY_WITHOUT_BG = 1,
		POLY_SELECTED_OPACITY_WITH_BG = 0.7,
		POLY_UNSELECTED_OPACITY = 0.5,
		POLY_SELECTED_HOVER_OPACITY_WITH_BG = 0.7,
		POLY_SELECTED_HOVER_OPACITY_WITHOUT_BG = 1,
		POLY_STROKE_COLOR_HOVER_DARK_THEME = "#FFFFFF",
		POLY_STROKE_COLOR_HOVER_LIGHT_THEME = "#000000",
		POLY_STROKE_COLOR_LINKDRILL_DARK_THEME = "#FFFFFF",
		POLY_STROKE_COLOR_LINKDRILL_LIGHT_THEME = "#000000",
		POLY_STROKE_COLOR_SELECTED_DARK_THEME = "#FFFFFF",
		POLY_STROKE_COLOR_SELECTED_LIGHT_THEME = "#000000",
		POLY_STROKE_COLOR_SELECTED_HOVER_DARK_THEME = "RGBA(0,0,0,0)",
		POLY_STROKE_COLOR_SELECTED_HOVER_LIGHT_THEME = "RGBA(0,0,0,0)",
	
		BUBBLE_COLOR_NO_COLORBY_DARK_THEME = "RGBA(33,195,255,0.8)", // 21C3FF
		BUBBLE_COLOR_NO_COLORBY_LIGHT_THEME = "RGBA(31,119,180,0.8)", // 1F77B4
		BUBBLE_STROKE_COLOR_DARK_THEME = "RGBA(129,129,129,0.8)", // 818181
		BUBBLE_STROKE_COLOR_LIGHT_THEME = "RGBA(129,129,129,0.8)", // 818181
		BUBBLE_NORMAL_OPACITY = 0.8,
		BUBBLE_HOVER_OPACITY = 0.5,
		BUBBLE_SELECTED_OPACITY = 1,
		BUBBLE_LINKDRILL_OPACITY = 0.8,
		BUBBLE_STROKE_COLOR_HOVER_DARK_THEME = "RGBA(129,129,129,0.8)", // 818181
		BUBBLE_STROKE_COLOR_HOVER_LIGHT_THEME = "RGBA(129,129,129,0.8)", // 818181
		BUBBLE_STROKE_COLOR_LINKDRILL_DARK_THEME = "RGBA(129,129,129,0.8)", // 818181
		BUBBLE_STROKE_COLOR_LINKDRILL_LIGHT_THEME = "RGBA(129,129,129,0.8)", // 818181
		BUBBLE_STROKE_COLOR_SELECTED_DARK_THEME = "RGBA(255,255,255,0.8)", // FFFFFF
		BUBBLE_STROKE_COLOR_SELECTED_LIGHT_THEME = "RGBA(0,0,0,0.8)", // FFFFFF
		BUBBLE_HIGHLIGHT_STROKE_COLOR_DARK_THEME = "#FFFFFF",
		BUBBLE_HIGHLIGHT_STROKE_COLOR_LIGHT_THEME = "#000000";
	

	// error message font color
	var ERROR_MSG_FONT_COLOR_DARK_THEME = "#FFF",
		ERROR_MSG_FONT_COLOR_LIGHT_THEME = "#000";
	
	// take screenshot
	var RENDERING_TIME = 300;
	
	
	/**
	 * Detect an Object obj is a {} or not
	 */
	function isOwnEmpty(obj) {
		var name;
		for (name in obj) {
			if(obj.hasOwnProperty(name)) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * Returns a lighter variation of the color passed in.
	 *
	 * @param {String} c The color to lighten (in HEX value).
	 *
	 * @returns String The lighter color (in RGB function value).
	 * @private
	 */
	function getLighterColor(c) {
		// Iterate rbg values.
		var rgb = mstrmojo.color.hex2rgb(c);
		mstrmojo.array.forEach(rgb, function (v, idx) {
			// Reduce each value by 25%.
			rgb[idx] = Math.floor(v * 0.75);
		});

		return 'rgb(' + rgb.join(',') + ')';
	}

	/**
	 * Positions the supplied tooltip at the indicated position.
	 *
	 * @param {HTMLElement} tooltip The HTMLElement to be positioned.
	 * @param {Integer} touchX The left position.
	 * @param {Integer} touchY The top position.
	 *
	 * @private
	 */
	function positionTooltip(tooltip, touchX, touchY) {
		var tooltipStyle = tooltip.style,
			translateValue = 'translate(' + touchX + 'px, ' + touchY + 'px)',
			translateValue3d = translateValue.replace('late(', 'late3d(').replace('px)', 'px, 0)');

		tooltipStyle.MozTransform = translateValue;
		tooltipStyle.msTransform = translateValue;
		tooltipStyle.webkitTransform = translateValue3d;
		tooltipStyle.transform = translateValue3d;
	}

	/**
	 * To decide whether a point is in a giving polygon or not.
	 * Maybe we can try canvas.isPointInPath() function instead of this.
	 *
	 * @param {Array} poly indicates a polygon.
	 * @param {integel} px the x coordinate of a giving point.
	 * @param {integel} py the y coordinate of a giving point.
	 *
	 * @returns 
	 * @private
	 */
	function inPoly(poly, px, py) {
		var npoints = poly.length, // number of points in polygon
			inside = false,
			xnew,
			ynew,
			xold,
			yold,
			x1,
			y1,
			x2,
			y2,
			i;

		if (npoints / 2 < 3) { // points don't describe a polygon
			return false;
		}

		xold = poly[npoints - 2];
		yold = poly[npoints - 1];

		for (i = 0; i < npoints; i = i + 2) {
			xnew = poly[i];
			ynew = poly[i + 1];

			if (xnew > xold) {
				x1 = xold;
				x2 = xnew;
				y1 = yold;
				y2 = ynew;
			} else {
				x1 = xnew;
				x2 = xold;
				y1 = ynew;
				y2 = yold;
			}
			if ((xnew < px) === (px <= xold) && ((py - y1) * (x2 - x1) < (y2 - y1) * (px - x1))) {
				inside = !inside;
			}

			xold = xnew;
			yold = ynew;
		}

		return inside;
	}
	
	/**
	 * Draw a polygon (coordsArray) in a canvas context (ctx).
	 *
	 * @param {Array} poly indicates a polygon.
	 * @param {integel} px, py the x, y coordinate of a giving point.
	 *
	 * @returns 
	 * @private
	 */
	function drawPoly(ctx, coordsArray, offset, strokeColor, strokeWidth, fillColor) {
		try {
			var offsetX = offset ? offset.x : 0,
				offsetY = offset ? offset.y : 0;
			
			var getPointAt = function(j){
				var offset = j%2  ? offsetY : offsetX;
				return pointsArray[j] + offset;
			};
			
			var i, j;
			for (i = 0; i < coordsArray.length; i++) {
				var pointsArray = coordsArray[i];

				ctx.beginPath();
				ctx.moveTo(getPointAt(0), getPointAt(1));

				for (j = 2; j < pointsArray.length - 1; j = j + 2) {
					var xx = getPointAt(j),
						yy = getPointAt(j + 1);

					ctx.lineTo(xx, yy);

				}
				
				// close the path
				var x = getPointAt(0),
					y = getPointAt(1),
					fillStyle = fillColor;
				
				ctx.lineTo(x, y);
				ctx.fillStyle = fillStyle;
				ctx.fill();
				ctx.strokeStyle = strokeColor;
				ctx.lineWidth = strokeWidth;
				ctx.stroke();
			}
		} catch (e) {
			//ignore
		}
	}

	/**
	 * Draw a circle in a canvas context (context) with fillcolor (color) and radius (radius).
	 *
	 * @param {Array} pt is the position of the circle.
	 * @param {Array} offset is the offset of the circle.
	 *
	 * @returns 
	 * @private
	 */
	function drawBubble(context, pt, offset, color, radius) {
		context.fillStyle = color;
		context.beginPath();
		context.arc(pt[0] + offset.x, pt[1] + offset.y, radius, 0, Math.PI * 2, true);
		context.closePath();
		context.fill();
	}

	/**
	 * Draw a circle in a canvas context (context) with stokecolor (color) and radius (radius).
	 *
	 * @param {Array} pt is the position of the circle.
	 * @param {Array} offset is the offset of the circle.
	 *
	 * @returns 
	 * @private
	 */
	function drawStroke(context, pt, offset, color, radius, strokeWidth) {
		context.strokeStyle = color;
		context.lineWidth = strokeWidth;
		context.beginPath();
		context.arc(pt[0] + offset.x, pt[1] + offset.y, radius, 0, Math.PI * 2, true);
		context.closePath();
		context.stroke();
	}

	/**
	 * Return the map file type -- point or polygon according to coords.
	 *
	 */
	function getShapeFileType(coords) {
		if (coords) {
			var elem;
			for (elem in coords) {
				if (coords.hasOwnProperty(elem)) {
					if (elem === "bgImage") {
						continue;
					}
					if (coords[elem][0]) {
						if (coords[elem][0].length === 2) {
							return SHAPE_FILE_POINT;
						} else if (coords[elem][0].length > 2) {
							return SHAPE_FILE_POLYGON;
						} else {
							return SHAPE_FILE_UNDEFINED;
						}
					} else {
						return SHAPE_FILE_UNDEFINED;
					}
				}				
			}
		} else {
			return SHAPE_FILE_UNDEFINED;
		}
		
	}


	/**
	 * Store the center of the areas in a 2-dimention array
	 * @returns 
	 * @private
	 */
	function getPolygonCenter(pointsArr) {
		var sumX=0,
			sumY=0
			i;
		for (i=0; i<pointsArr.length; i++) {
			sumX = sumX + pointsArr[i];
			i++;
			sumY = sumY + pointsArr[i];
		}
		var centerX = sumX / (pointsArr.length/2),
			centerY = sumY / (pointsArr.length/2),
			center1 = [centerX, centerY]
			center2 = [];
		center2.push(center1);
		
		return center2;
	}
	
	/**
	 * Return the centroid of a polygon.
	 */
	function getCentroidOfPolygon(points) {
		if (points == null || points.length < 4) {
			return null;
		}

		var area = 0,
			len = points.length,
			i,
			px,
			py,
			p2x,
			p2y;

		for (i=0; i<len-2; i+=2) {
			px = points[i];
			py = points[i+1];
			p2x = points[i+2];
			p2y = points[i+3];
	
			area += (px * p2y - p2x * py);
		} 
		px = points[len-2];
		py = points[len-1];
		p2x = points[0];
		p2y = points[1];
		area += (px * p2y - p2x * py);
		area = Math.abs(area / 2.0);

		if (area <= 0) {
			return null;
		}

		var centroid = [0, 0];
		for (i=0; i<len-2; i+=2) {
			px = points[i];
			py = points[i+1];
			p2x = points[i+2];
			p2y = points[i+3];
			centroid[0] += ((px + p2x) * (px * p2y - p2x * py));
			centroid[1] += ((py + p2y) * (px * p2y - p2x * py));
		}
		px = points[len-2];
		py = points[len-1];
		p2x = points[0];
		p2y = points[1];
		centroid[0] += ((px + p2x) * (px * p2y - p2x * py));
		centroid[1] += ((py + p2y) * (px * p2y - p2x * py));

		centroid = [Math.abs(centroid[0] / (area * 6.0)), Math.abs(centroid[1] / (area * 6.0))];
		
		var two_dim_centroid = [];
		two_dim_centroid.push(centroid);

		return two_dim_centroid;
	}

	/**
	 * Add opacity to a given color (color).
	 */	
	function getOpacityColor(color, opacity) {
		var opacityColor,
			i;
		var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
		if (color) {
			var colorNew;
			if (/^(rgba|RGBA)/.test(color)) {
				var tempColor = color.replace(/rgba\(|RGBA\(/, "");
				tempColor = tempColor.replace(")", "");
				colorNew = tempColor.split(",");
				opacityColor = "RGBA(" + colorNew[0] + "," + colorNew[1] + "," + colorNew[2] + "," + opacity + ")";
				return opacityColor;
			} else if (/^(rgb|RGB)/.test(color)) {
				colorNew = color.replace(/rgb\(|RGB\(/, "");
				colorNew = colorNew.replace(")", "");
				opacityColor = "RGBA(" + colorNew + "," + opacity + ")";
				return opacityColor;
			} else if (reg.test(color)) {
				if (color.length === 4) {
					colorNew = "#";
					for (i=1; i<4; i++) {
						colorNew += color.slice(i,i+1).concat(color.slice(i,i+1));
					}
					color = colorNew;
				}
				var colorChange = [];
				for (i=1; i<7; i+=2) {
					colorChange.push(parseInt("0x" + color.slice(i,i+2)));
				}
				colorChange.push(opacity);
				opacityColor = "RGBA(" + colorChange.join(",") + ")";
				return opacityColor;
			} else {
				return color;
			}
		} else {
			return null;
		}
		
	}
	

	
	/**
	 * Return the theme mode of the given color -- dark or light.
	 */
	function getThemeMode(color) {
		var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/,
			i,
			r,
			g,
			b,
			brightness;
		if (color) {
			var colorNew,
				tempColor;
			if (/^(rgba|RGBA)/.test(color)) {
				tempColor = color.replace(/rgba\(|RGBA\(/, "");
				tempColor = tempColor.replace(")", "");
				colorNew = tempColor.split(",");
				r = colorNew[0];
				g = colorNew[1];
				b = colorNew[2];
			} else if (/^(rgb|RGB)/.test(color)) {
				tempColor = color.replace(/rgb\(|RGB\(/, "");
				tempColor = tempColor.replace(")", "");
				colorNew = tempColor.split(",");
				r = colorNew[0];
				g = colorNew[1];
				b = colorNew[2];
			} else if (reg.test(color)) {
				if (color.length === 4) {
					colorNew = "#";
					for (i=1; i<4; i++) {
						colorNew += color.slice(i,i+1).concat(color.slice(i,i+1));
					}
					color = colorNew;
				}
				var colorChange = [];
				for (i=1; i<7; i+=2) {
					colorChange.push(parseInt("0x" + color.slice(i,i+2)));
				}
				r = colorChange[0];
				g = colorChange[1];
				b = colorChange[2];
			} else {
				return THEME_DARK;
			}
			
			brightness = (r*299 + g*587 + b*114) / 1000;
			if (brightness > 150) {
				return THEME_LIGHT;
			} else {
				return THEME_DARK;
			}
		} else {
			return THEME_DARK;
		}
	}
	
	
	/**
	 * For image threshold highlight.
	 */
	function drawWhiteRectCorner(hlContext, xOffset, yOffset, width, height) {
		hlContext.strokeStyle = "#FFF";
		hlContext.lineWidth = 2;
		hlContext.beginPath();
		hlContext.moveTo(xOffset+width*0.25, yOffset);
		hlContext.lineTo(xOffset, yOffset);
		hlContext.lineTo(xOffset, yOffset+height*0.25);
		hlContext.moveTo(xOffset, yOffset+height*0.75);
		hlContext.lineTo(xOffset, yOffset+height);
		hlContext.lineTo(xOffset+width*0.25, yOffset+height);
		hlContext.moveTo(xOffset+width*0.75, yOffset+height);
		hlContext.lineTo(xOffset+width, yOffset+height);
		hlContext.lineTo(xOffset+width, yOffset+height*0.75);
		hlContext.moveTo(xOffset+width, yOffset+height*0.25);
		hlContext.lineTo(xOffset+width, yOffset);
		hlContext.lineTo(xOffset+width*0.75, yOffset);
		hlContext.stroke();
		hlContext.closePath();
	}
	
	
	
	/**

	* An image layout visualization for the Android platform.

	* 

	* @class

	* @extends mstrmojo.VisMap

	* 

	*/


	mstrmojo.AndroidVisMap = mstrmojo.declare(

			mstrmojo.Vis,

			[mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

			{

				scriptClass: 'mstrmojo.AndroidVisMap',
				
				/**
				 * The list of items to display.
				 *
				 * @type Array
				 */
				model: null,

				/**
				 * used for getting the scrolled position in the widget.
				 *
				 */
				utils: mstrmojo.VisChartUtils,  
				
				scrollerConfig : {
					bounces : false,
					showScrollbars : false,
					useTranslate3d : true,
					vScroll: true,
					hScroll: true,
					offset : {
							y: {
								start: 0,
								end: 0
							},
							x: {
								start: 0,
								end: 0
							}
					},
					origin: {
						x: 0,
						y: 0
					}
				},
				
				/**
				 * Scale factor in every step.
				 */
				relScaleFactor: 1, 
				
				/**
				 * Total scale factor.
				 */
				scaleFactor: 1,
				
				/*
				 * store the current selected area or bubble name
				 */
				currSelectedObj: null,
				
				/*
				 * store the default selected area or bubble names
				 */
				defaultSelectedObjs: {},
				
				/*
				 * store the current highlighted area or bubble name
				 */
				currHoverObj: null,
				
				/*
				 * store the current highlighted area or bubble name
				 */
				currLinkObj: null,
				
				
				tooltipOn: false,
				
				/**
				 * @ignore
				 */
				context: null,
				
				/**
				 * to support double tap gesture
				 */
				multiTap: true,
				
				/**
				 * to support double touch gesture
				 */
				multiTouch: true,

				browserSupportsHtml5: true,
				

				/**
				 * @ignore
				 */
				markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};top:{@top};left:{@left};z-index:{@zIndex};position:absolute;{@cssText};overflow:hidden;" ' +
									' mstrAttach:mouseover,mousemove >' +
									//'<canvas width="{@width}" height="{@height}"></canvas>' +
									'<div id="{@id}"-scroll-element style="position:absolute;left:0;top:0;width:{@width};height={@height}">' +
										'<canvas id="{@id}-highlightCanvas" style="position:absolute;left:0;top:0;z-index:100" width="{@width}" height="{@height}"></canvas>' +
										'<canvas id="{@id}-animationCanvas" style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>'+
									'</div>'+
									'<div id="{@id}-tooltip" style="z-index:200" class="mstrmojo-ImageLayout-tooltip" clk="clk"><table style="margin:5px 7px"></table></div>' +
									'<div id="{@id}-infowindow-anchor" style="position:absolute;width:18px;height:18px;display:block"></div>'+
									'<div id="{@id}-css" style="display:none"></div>'+
									'<div id="{@id}-errMsg" align="center" style="position:absolute; z-index:300; top:35%; word-wrap:break-word;"></div>'+
								'</div>',

				/**
				 * @ignore
				 */
				markupSlots: {
					//the main canvas of the Chart
					//canvas: function () { return this.domNode.firstChild; },
					
					//the div containing animationCanvas and highlightCanvas
					scrollableCanvasDiv: function () { return this.domNode.childNodes[0]; },

					//the canvas used for highlighting points
					highlightCanvas: function () { return this.domNode.childNodes[0].firstChild; },

					//the base canvas for animation @TODO: each animation should create independent canvas objects
					animationCanvas: function () { return this.domNode.childNodes[0].lastChild; },

					//the tooltip display when highlighting points
					tooltip: function () { return this.domNode.childNodes[1]; },
					
					// for info window position
					infowindowAnchor: function() {return this.domNode.childNodes[2];},
					
					// for getting the format of a cell
					cssDiv: function() { return this.domNode.childNodes[3]; },
					
					// for displaying error message
					errorMessage: function() { return this.domNode.childNodes[4]; }
				},
				
				postBuildRendering: function postBuildRendering() {
					var me = this;
					
					// set font according to dpi
					me.setFontByDPI();

					browserSupportsHtml5 = me.highlightCanvas.getContext;
					if (!browserSupportsHtml5) {
						me.renderErrorMessage(mstrmojo.desc(8126, 'Your browser does not support HTML5'));
						return;
					}
					
					/*
					 * If the template is not correct, show error message and return.
					 */
					if (me.model.hasOwnProperty("eg")) {
						var errorMessage = me.model.eg,
							wrongTemplateStr = "The Image Layout requires:";
						if (errorMessage.match(wrongTemplateStr)) {
							me.renderErrorMessage(mstrmojo.desc(9853, errorMessage));
						} else {
							me.renderErrorMessage(errorMessage);
						}
						
						return;
					}

					me.newRenderFlag = true;
					
					me.attrIndices = me.getAttrIndices();
					me.createTooltipTable();
					
					// 697276 set the top and left style of this.domNode to enable title bar
					// assumption: the title bar will be only placed on the top of the widget
					// now this is fixed for all widgets in Vis::buildRendering function
//					var	fmts = this.fmts, 
//						pWidgetHeight = fmts && fmts.p_fmts && fmts.p_fmts.height,
//						widgetHeight = fmts && fmts.height,
//						widgetTop = fmts && fmts.top,
//						widgetLeft = fmts && fmts.left;
//					if (pWidgetHeight && widgetHeight){
//						pWidgetHeight = parseInt(pWidgetHeight, 10); // remove "px"
//						widgetHeight = parseInt(widgetHeight, 10); // remove "px"
//						this.domNode.style.top = (pWidgetHeight-widgetHeight) + "px";
//					} else if (widgetTop) {
//						this.domNode.style.top = widgetTop + "px";
//					} else {
//						this.domNode.style.top = "0px";
//					}				
//					if (widgetLeft) {
//						this.domNode.style.left = widgetLeft + "px";
//					} else {
//						this.domNode.style.left = "0px";
//					}
					
					// store default selected objects' names in defaultSelectedObjs
					me.getDefaultSelectedObjs();
					
					//cache the different canvas' context objects in the Widget
					//me.context = canvas.getContext('2d');
					me.highlightContext =  me.highlightCanvas.getContext('2d');
					me.animationContext =  me.animationCanvas.getContext('2d');
					
					
					var sclConfig = me.scrollerConfig;
					sclConfig.scrollEl = me.scrollableCanvasDiv;
					sclConfig.offset.x.start = 0;
					sclConfig.offset.x.end = me.getWidth() * (me.scaleFactor - 1);
					sclConfig.offset.y.start = 0;
					sclConfig.offset.y.end = me.getHeight() * (me.scaleFactor - 1);
					if (sclConfig.origin.x > sclConfig.offset.x.end) {
						sclConfig.origin.x = sclConfig.offset.x.end;
					}
					if (sclConfig.origin.y > sclConfig.offset.y.end) {
						sclConfig.origin.y = sclConfig.offset.y.end;
					}

					/*
					 * set the animationCanvas and highlightCanvas twice as large as widget
					 * as the max scaleFactor is 2
					 */
					me.animationCanvas.width = me.highlightCanvas.width = me.getWidth() * 2;
					me.animationCanvas.height = me.highlightCanvas.height = me.getHeight() * 2;
					
//					var varString = '';
//					if (me.model) {
//						varString += 'model yes';
//						if (me.displayMode) {
//							varString += '\nmodel::displayMode yes';
//						} else {
//							varString += '\nmodel::displayMode no';
//						}					
//					} else {
//						varString += 'model no';
//					}
//					if (me.mapDataScreenshotTaken) {
//						varString += '\nthis::mapDataScreenshotTaken yes';
//					} else {
//						varString += '\nthis::mapDataScreenshotTaken no';
//					}
					//alert(varString);
					
					if (!me.model.coords) {
//						var alertString = "postRendering with Server Request";
//						if (me.currSelectedObj && me.currSelectedObj.touchVal) {
//							alertString += "\ncurrSelectedObj: " + me.currSelectedObj.touchVal;
//						} else {
//							alertString += "\ncurrSelectedObj: null";
//						}
						//alert(alertString);
						
						if(typeof(mstrApp) != 'undefined' && mstrApp.serverRequest) {
							
							var xhrCfg = {
									success: function(res) {
										if (!res) {
											return;
										}
										me.model.coords = res.coords;
										
										me.drawMap();
										if (me.markerType !== MARKER_IMAGE) {
											// default selection highlight 
											// for MARKER_IMAGE, the defualt selection highlight is done in model["imageIcon_" + elem].onload()
											me.highlightPoint();
										}
										// for "fit page". when "fit page", the document may be replaced
										me.adjustWidgetOffsets();
										
										// take screenshot after finishing rendering
										if (!me.mapDataScreenshotTaken) {
											me.mapDataScreenshotTaken = true;
											me.localTakeScreenshot(RENDERING_TIME);
										}
									},
									
									failure: function(res) { // wrong when reading map html file
//										var errorMessage = "The Image Map / Shape file cannot be found.";
//										me.renderErrorMessage(mstrmojo.desc(9854, errorMessage));
//										return;
									}
															
								};
							
							params = {
									taskId: 'getMapCoordinates'
							};
							var vp = me.model.vp;
							if (vp && vp.mf) {
								params.coordinatesFile = vp.mf;
							}
							mstrApp.serverRequest(params,xhrCfg,{src:"postBuildRendering"});
						}
					} else {
//						var alertString2 = "postRendering without Server Request";
//						if (me.currSelectedObj && me.currSelectedObj.touchVal) {
//							alertString2 += "\ncurrSelectedObj: " + me.currSelectedObj.touchVal;
//						} else {
//							alertString2 += "\ncurrSelectedObj: null";
//						}
						//alert(alertString2);
						
						me.drawMap();
						// #701694 highlightPoint when back from linkDrill
						me.highlightPoint();
						
						// for "fit page". when "fit page", the document may be replaced
						this.adjustWidgetOffsets();
					}
					
					if(this._super) {
						this._super();
					}
					
					// save infowindowOn flag before infowindow close, before "touchesBegin" event
					// this should be after _super to make sure this._tn has been set in _TouchGesture.js
					if (this._tn) {
						var backup = this._tsCallback;
						this._tsCallback = function(e) {
							me.infowindowOn = me.model.infowindowOn;
							me.currSelectedObjBackup = me.currSelectedObj; // will not introduce a "copy reference" problem 
							backup.call(this, e);
						};
						mstrmojo.dom.detachEvent(this._tn, mstrmojo.dom.TOUCHSTART, backup);
						mstrmojo.dom.attachEvent(this._tn, mstrmojo.dom.TOUCHSTART, this._tsCallback);
					}
					
					/*
					* clear the selected highlight when all info windows are closed and there are not any other select targets
					*/
					var xtabModel = me.xtabModel,
						docModel = (xtabModel && xtabModel.docModel);
					if(docModel){
						me.docModelListener = me.xtabModel.docModel.attachEventListener('infoWindowClosed', this.id, function (evt) {
							// #697294 #688647
//							if(me.hasOwnProperty("selectorTargetMap") && me.selectorTargetMap.length>0 && me.selectorTargetMap[evt.psKey]){
//								delete me.selectorTargetMap[evt.psKey];
//								me.selectorTargetCount--;
//								me.model.infowindowOn = false;
//								//console.log("selectorTargetCount: " + me.selectorTargetCount + "\n");
//								if(me.selectorTargetCount <= 0){
//										//last infowindow closed and no other targets
//										me.currSelectedObj = null;
//										me.highlightPoint();
//								}
//								return;
//							}
							me.model.infowindowOn = false;
							if (!me.hasNonifwTarget && me.currSelectedObj) {
								window.setTimeout(function() {
									// put this in a setTimeout function to make sure the browser will repaint
									me.currSelectedObj = null;
									me.highlightPoint();
								}, 10);
							}
//							window.setTimeout(function() {
//								me.model.infowindowOn = false;
//							}, 600);
						});
					}
					
					
					// #701640 fullscreen
					me.fullScreenListener = mstrmojo.touchManager.attachEventListener('fullScreenStateChange', this.id, function(evt) {
						me.adjustWidgetOffsets();
					});
					
					// for debugging
					//this.evalExpr = function(expr) { return eval(expr); }
					//mstrmojo.VisDebuggerUtils.enable(this);

					
//					me.touchesBeginListener = mstrmojo.touchManager.attachEventListener("touchesBegin", this.id, function(evt) {
//						me.infowindowOn = me.model.infowindowOn;
//						me.currSelectedObjBackup = me.currSelectedObj;
//					});

				},
				
				/**
				 * get full path according to path, used by image threshold icon and  background image
				 * path: can be relative or absolute path
				 * 
				 */
				getFullPath: function getFullPath(path) {
					var fullPath = '';
					var reg = /^[A-z]:\/\//; // absolute url regulation
					if (reg.test(path)) {
						// is an complete URL
						fullPath = path;
					} else {
						// is relative path in mobile server
						
						// delete '../', '..\', './', '.\', '/', '\' at the beginning of the path if there is any
						var tempReg1 = /^(..\/|..\\)/; // need to test the regularation
						var tempReg2 = /^(.\/|.\\)/;
						var tempReg3 = /^(\/|\\)/;
						path = path.replace(tempReg1, '');
						path = path.replace(tempReg2, '');
						path = path.replace(tempReg3, '');
						
						if (typeof(mstrApp)!='undefined' && mstrApp.getConfiguration) {
							fullPath = mstrmojo.url.getAbsoluteURL(path, mstrApp.getConfiguration().getCurrentProjectWebServerUrl());
						}
					}
					
					return fullPath;
				},
				
				
				touchMultiBegin: function (touch) {
					// hide tooltip and infowindow
					this.hideTooltip();
					// this.closeInfowindow();
					
					// we have two mode. First is using single touch or mouse event for simpler debug. Second is really multi touch
					
					var touch1,
						touch2;
					if (touch.evt.touches && touch.evt.touches.length == 2) {
						touch1 = touch.evt.touches[0];
						touch2 = touch.evt.touches[1];
					} else {
						touch1 = touch;
						touch2 = {pageX: 100, pageY:100};
					}
					var xDiff = touch1.pageX - touch2.pageX,
						yDiff = touch1.pageY - touch2.pageY;
					this.initDiffDiff = xDiff * xDiff + yDiff * yDiff;
					this.initCenterX = (touch1.pageX + touch2.pageX)>>1;
					this.initCenterY = (touch1.pageY + touch2.pageY)>>1;
					this.initScrollX = this._scroller.origin.x;
					this.initScrollY = this._scroller.origin.y;
					
					this.relScaleFactor = 1;
					
					//console.log("initDiffDiff:" + this.initDiffDiff + ", with init center:" + this.initCenterX + "," + this.initCenterY);
				},
				
				touchMultiMove: function (touch) {
					
					
					// we have two mode. First is using single touch or mouse event for simpler debug. Second is really multi touch
					var touch1,
						touch2;
					if (touch.evt.touches && touch.evt.touches.length == 2) {
						touch1 = touch.evt.touches[0];
						touch2 = touch.evt.touches[1];
					} else {
						touch1 = touch;
						touch2 = {pageX: 100, pageY: 100};
					}
					var xDiff = touch1.pageX - touch2.pageX,
						yDiff = touch1.pageY - touch2.pageY,
						curDiffDiff = xDiff * xDiff + yDiff * yDiff,
						curCenterX = (touch1.pageX + touch2.pageX)>>1,
						curCenterY = (touch1.pageY + touch2.pageY)>>1;
					
					var scale = Math.sqrt(curDiffDiff / this.initDiffDiff);
					
					var offset = { // xiawang: This is calculated by us
						x: scale * (this.initCenterX + this.initScrollX) - curCenterX,
						y: scale * (this.initCenterY + this.initScrollY) - curCenterY
					};
					var transform = {scale: scale, offset: offset};
					
					this.relScaleFactor = scale;
					//console.log("sclae factor:" + this.scaleFactor + " with currentDiffDiff:" + curDiffDiff);
					this.applyTransform(transform);
				},
				
				touchMultiEnd: function (touch) {
					if (this.relScaleFactor * this.scaleFactor < 1) {
						// make sure the final scale factor is not larger than 1
						this.relScaleFactor = 1 / this.scaleFactor;
						this.applyTransform({scale: this.relScaleFactor}, 500, this.postScale);
					} else if(this.relScaleFactor * this.scaleFactor > 2) {
						var scaleBack = this.relScaleFactor * this.scaleFactor / 2;
						this.relScaleFactor = 2 / this.scaleFactor;
						this.applyTransform({scale: this.relScaleFactor, scaleBack: scaleBack}, 500, this.postScale);
					} else {
						this.postScale();
					}
				},
				
				// handle touchSelect with infowindow on
				handleTouchSelectWithIfw: function handleTouchSelectWithIfw (touchX, touchY) {
					var me = this,
						nearestObj = me.getAreaOrNearestBubble(false, touchX, touchY);
					
					if (!nearestObj) { // hide infowindow when the touch is in invalid area
						me.closeInfowindow();
					} else if (nearestObj.hdrIndex < 0) { 
						me.closeInfowindow();
					} else if (!me.currSelectedObj || nearestObj.touchVal !== me.currSelectedObj.touchVal) {
						me.showInfowindow(nearestObj);						
						me.currSelectedObj = nearestObj;

						me.highlightPoint();
					} else { // touchSelect the current selected node
						
					}
				},
				// handle touchSelect without infowindow or without infowindow on
				handleTouchSelectNoIfw: function handleTouchSelectNoIfw (touchX, touchY) {
					var me = this,
						nearestObj = me.getAreaOrNearestBubble(false, touchX, touchY);
					
					if (!nearestObj) { // hide tooltip when the touch is in invalid area
						me.hideTooltip();
					} else if (!me.currHoverObj || nearestObj.touchVal !== me.currHoverObj.touchVal) {
						me.currHoverObj = nearestObj;
						//Call the method that will highlight the current point and render tooltip
						me.highlightPoint();
					} else {
						me.renderTooltip(nearestObj.touchVal, nearestObj.point.x, nearestObj.point.y, nearestObj.hdrIndex);
					}
				},
				
				touchSelectBegin: function (touch) {
					if (touch.evt.ctrlKey) { // if ctrl Key is pressed
						this.touchMultiBegin(touch);
						return;
					}
					
					if (this.infowindowOn) {
						this.touchSelectWithIfw = true;
						this.handleTouchSelectWithIfw(touch.pageX, touch.pageY);						
					} else {
						this.handleTouchSelectNoIfw(touch.pageX, touch.pageY);
					}

				},
				
				touchSelectMove: function (touch) {
					if (touch.evt.ctrlKey) {
						this.touchMultiMove(touch);
						return;
					}
					
					if (this.touchSelectWithIfw) {
						this.handleTouchSelectWithIfw(touch.pageX, touch.pageY);
					} else {
						this.handleTouchSelectNoIfw(touch.pageX, touch.pageY);
					}				

				},
				
				touchSelectEnd: function (touch) {
					if (touch.evt.ctrlKey) {
						this.touchMultiEnd(touch);
					}
					this.touchSelectWithIfw = false;
					return;
				},				
				
				/**
				* hide tooltip and infowindow while touchSwipe
				*/
				touchSwipeBegin: function touchSwipeBegin(touch) {
					this.hideTooltip();
					//this.closeInfowindow(); //info window closes automatically when "touchesBegin"

					if (this._super) {
						this._super(touch);
					}
				},
				
				applyTransform: function (transform, duration, callback) {
					var scl = this._scroller;
					
					if (duration === undefined) {
						duration = 0;
					}
					scl.scrollEl.style["webkitTransformOrigin"] = "left top";
					
					scl.transform = "scale(" + transform.scale + "," + transform.scale + ")";
					var scrollX,
						scrollY;
					if (transform.offset) {
						scrollX = transform.offset.x;
						scrollY = transform.offset.y;
					} else {
						var scaleBack = transform.scaleBack || 1;
						scrollX = this._scroller.origin.x / scaleBack;
						scrollY = this._scroller.origin.y / scaleBack;
					}
					
					var scrollerOffsetScale = this.scaleFactor * this.relScaleFactor - 1,
						vOffsetEnd = this.getHeight() * scrollerOffsetScale,
						hOffsetEnd = this.getWidth() * scrollerOffsetScale;
					if (scrollerOffsetScale < 0) { // If now the scale factor is less than 1
						scl.offset = {
								y: {
									start: vOffsetEnd,
									end: 0
								},
								x: {
									start: hOffsetEnd,
									end: 0
								}
						};
					} else { // If now the scale factor is larger than 1
						scl.offset = {
								y: {
									start: 0,
									end: vOffsetEnd
								},
								x: {
									start: 0,
									end: hOffsetEnd
								}
						};
					}
					this._scroller.scrollTo(scrollX, scrollY, duration);
					if (callback) {
						var that = this;
						setTimeout(function () {callback.apply(that); that = null;}, duration);
					}
						
					
				},
				
				pointCanBeSelected: function pointCanBeSelected(touchObj){
					
					var me = this,
						m = me.model,
						gts = m.gts,
						colHeaders = gts.col,
						colHL = colHeaders.length,
						rowHeaders = gts.row,
						rowHL = rowHeaders.length,
						i;

					for(i = 0; i < rowHL; i++){
						var rowH = rowHeaders[i];
						if(rowH.sc && rowH.sc.tks){
							return true;
						}
						if(rowH.lm && rowH.lm[0] && rowH.lm[0].links && rowH.lm[0].hasOwnProperty("di")){ // link drill with default link
							return true;
						}
					}
					return false;
				},
				
				getModelK: function getModelK(){
					var k = this.model && this.model.k;
					
					return k;
				},
				
				getActionObj: function getActionObj(touchedObj, selectedAll, sameAsCurrSelectedPoint){
					var scObjList = [],
						actionType = 0,
						actionObjList = [],
						linkDrillNode = null;
				
					var me = this,
						model = me.model,
						gts = model.gts,
						rowH = gts.row[0];
						
					//row
					if(rowH.sc && rowH.sc.tks && (!touchedObj || touchedObj.hdrIndex>=0)){
						if(selectedAll && (rowH.sc.all === "false" || rowH.sc.all === false)){
							// unselect is true and can't select all, then do nothing
							return null;
						}
						var scObj = {};
						scObj.sc = rowH.sc;
						if (touchedObj && touchedObj>=0) {
							scObj.es = rowH.es[touchedObj.hdrIndex].n;
						} else {
							scObj.es = null;
						}
						
						scObj.eid = selectedAll ? "OA:(All)" : rowH.es[touchedObj.hdrIndex].id;					
						scObjList.push(scObj);
						actionType = rowH.at || 0;
					}
					if(rowH.lm && rowH.lm[0] && rowH.lm[0].links && !linkDrillNode && touchedObj && touchedObj.hdrIndex>=0){
						//find link drill on rows
						linkDrillNode = {};
						linkDrillNode.titleInfo = rowH;
						linkDrillNode._e = rowH.es[touchedObj.hdrIndex];
					}
					
					//col
					var colH = gts.col && gts.col.length>0 && gts.col[0];
					//metric selector can't take effect, ignore
								
					if(scObjList.length >0){
						actionType = actionType | SELECTOR_ACTION;
						if (touchedObj && touchedObj.hdrIndex>=0) {
							if (!sameAsCurrSelectedPoint) {
								if (this.hasIfwTarget) {
									//get the info window
									this.getAnchorStyle(touchedObj);								
									//node use as info window anchor
									// showInfo: for TQMS 689917
									//console.log("different areas\n");
									this.model.infowindowOn = true;
									//this.selectorTargetCount++;
									return {at:actionType, k:this.getModelK(), scObjList:scObjList, anchor:this.infowindowAnchor};									
								} else {
									return {at:actionType, k:this.getModelK(), scObjList:scObjList};
								}

							} else {
								//console.log("the same area\n");
								//this.model.infowindowOn = false;
								return {at:actionType, k:this.getModelK(), scObjList:scObjList};
							}
						} else if (touchedObj && touchedObj.hdrIndex<0) {
							//this.model.infowindowOn = false;
							return {at:actionType, k:this.getModelK(), scObjList:scObjList};
						} else if (!touchedObj) { // TQMS 689917
							// actionType = SELECTOR_ACTION;
							// showInfo: for TQMS 689917
							//console.log("empty area\n");
							//this.model.infowindowOn = false;
							return {at:actionType, k:this.getModelK(), scObjList:scObjList};
						}

					}
					
					if(!linkDrillNode && touchedObj && touchedObj.hdrIndex>=0){
					//find link drill on metric (on columns)
						var metricH = colH,
							metricHL = metricH && metricH.es && metricH.es.length,
							i;
						if (metricH && metricHL>0) {
							for(i = metricHL - 1; i >= 0; i--){
								var metric = metricH.es[i],
									lm = metricH.lm[i];
								
								if(lm && lm.links){
									linkDrillNode = {};
									linkDrillNode.titleInfo = metricH;
									//mix: metric index
									linkDrillNode.mix = i;
									//build node parent
									var currNode = linkDrillNode,
										nodeLP = {};
									nodeLP.titleInfo = rowH;
									nodeLP._e = rowH.es[touchedObj.hdrIndex];						
												
									currNode._lp = nodeLP;
									currNode.axis = ROW_AXIS;
								}
							}
						}						
					}
					if(linkDrillNode){
						actionType = actionType | HYPERLINK_ACTION;
						return {at:actionType, k:this.getModelK(), node:linkDrillNode};
					}
					return null;
				},
				
				getAnchorStyle: function getAnchorStyle(touchedObj) {
					if (!touchedObj) { return; }
					
					var touchVal = touchedObj.touchVal,
						me = this,
						model = me.model,
						coords = model.coords,
						i,
						j,
						k;
					
					// default anchor style
					me.infowindowAnchor.style.left = (touchedObj.point.x - 9) + 'px';
					me.infowindowAnchor.style.top = (touchedObj.point.y - 9) + 'px';
					
					if(me.displayMode === DISPLAY_MODE_AREA) {
						var minX = Number.POSITIVE_INFINITY,
							maxX = 0,
							minY = Number.POSITIVE_INFINITY,
							maxY = 0;
						if (coords.hasOwnProperty(touchVal)) {
							var rgn = coords[touchVal];
							for (i in rgn) {
								if (!rgn.hasOwnProperty(i)) {
									continue;
								}
								var c = rgn[i];
								for (j=0; j<c.length; j++) {
									if (minX > c[j]) { minX = c[j]; }
									if (maxX < c[j]) { maxX = c[j]; }
									j++;
									if (minY > c[j]) { minY = c[j]; }
									if (maxY < c[j]) { maxY = c[j]; }
								}
							}
							me.infowindowAnchor.style.left = (minX + me.leftOffset - me._scroller.origin.x) + "px";
							me.infowindowAnchor.style.top = (minY + me.topOffset - me._scroller.origin.y) + "px";
							me.infowindowAnchor.style.width = (maxX - minX) + "px";
							me.infowindowAnchor.style.height = (maxY - minY) + "px";
							
						}
					} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
						if (me.shapeFileType === SHAPE_FILE_POLYGON) {
							coords = model.polygonCenters;
						}
						if (coords.hasOwnProperty(touchVal)) {
							if (me.markerType === MARKER_BUBBLE) {
								var ct = coords[touchVal][0],
									rd = me.getRadiusFromName(touchVal);
								me.infowindowAnchor.style.left = (ct[0] + me.leftOffset - rd - me._scroller.origin.x) + "px";
								me.infowindowAnchor.style.top = (ct[1] + me.topOffset - rd - me._scroller.origin.y) + "px";
								me.infowindowAnchor.style.width = (2 * rd) + "px";
								me.infowindowAnchor.style.height = (2 * rd) + "px";
							} else if (me.markerType === MARKER_IMAGE) {
								var ct = coords[touchVal][0],
									_image = model["imageIcon_" + touchVal],
									_width = 0,
									_height = 0;
								
								if (_image) {
									_width = _image.width;
									_height = _image.height;
								}
								
								me.infowindowAnchor.style.left = (ct[0] + me.leftOffset - _width/2 - me._scroller.origin.x) + "px";
								me.infowindowAnchor.style.top = (ct[1] + me.topOffset - _height/2 - me._scroller.origin.y) + "px";
								me.infowindowAnchor.style.width = _width + "px";
								me.infowindowAnchor.style.height = _height + "px";
							}
							
						}
					}
				},
				
				
				getLastHighlightPoint: function gtLstHighlightPnt(){
					// highlight point is the point showing the tooltip
					return this.currHoverObj || null;
				},
				
				/*
				* get touched area or bubble
				* for bubble mode,
				* if there is any highlight point, 45*45 rule is applied to the highlight point
				* if there is no highlight point, 45*45 rule is applied to the nearest point
				*/
				getTouchedObj: function getTouchedObj(isTap, touchX, touchY){
					var me = this;
					if( me.displayMode == DISPLAY_MODE_AREA ){
						
						return this.getAreaOrNearestBubble(isTap, touchX, touchY);

					}else if( me.displayMode == DISPLAY_MODE_BUBBLE ){
						var touchedObj = this.getLastHighlightPoint(),
							touchPointOnWidget = me.utils.getTouchXYOnWidget(touchX, touchY, me);
						
						// 
						var touchPointInHighlightArea = false,
							tx = 0,
							ty = 0,
							twx = 0,
							twy = 0;
						if (touchedObj && touchPointOnWidget) {
							tx = touchedObj.point.x;
							ty = touchedObj.point.y;
							twx = touchPointOnWidget.touchX;
							twy = touchPointOnWidget.touchY;
							
							touchPointInHighLightArea = this.tooltipOn && (tx-twx)*(tx-twx) + (ty-twy)*(ty-twy)<= this.bias * this.bias; 
						}
						
						
						//var touchPointInHighlightArea = this.tooltipOn && this.utils.getPointDistanceSquare({x:touchedObj.point.x,y:touchedObj.point.y},{x:touchPointOnWidget.touchX,y:touchPointOnWidget.touchY}) <= 45*45;
						
					
						if(touchPointInHighlightArea){
							/*
							*If a tooltip is being displayed and an action is associated with the datapoint
							*then tapping within a 45x45 area around the datapoint will result in the action being triggered
							*/
							me.hideTooltip();	
							touchedObj = this.getLastHighlightPoint();
						}else{
							touchedObj = this.getAreaOrNearestBubble(isTap, touchX, touchY);
						}  
						
						return touchedObj;
						
					}
				
					return null;
				},
				
				closeInfowindow: function closeInfowindow() {
					var me = this;
					me.getFirstInfowindow();
					if (me.model.infowindowOn && me.infowindow) {
						me.model.infowindowOn = false;
						me.infowindow.close();
						if (me.infowindow._tchHandler) { 
							mstrmojo.touchManager.detachEventListener(me.infowindow._tchHandler);
							delete me.infowindow._tchHandler; 
						}
					}
					
				},
				
				getFirstInfowindow: function getFirstInfowindow() {
					var me = this,
						model = me.model,
						xtabModel = me.xtabModel,
						docModel = (xtabModel && xtabModel.docModel),
						row = model && model.gts && model.gts.row,
						tks = null;
					if (row && row.length>0) {
						tks = row[0] && row[0].sc && row[0].sc.tks;
					}
					if (docModel && tks) {
						var ifws = docModel.getTargetInfoWin(tks);
						if (ifws && ifws.length>0) {
							var ifwunit = docModel.infoWinByKey[ifws[0]],
								id = ifwunit && (ifwunit.id + "_ifw");
							me.infowindow = mstrmojo.all[id];						
						}
					}
				},
				
				hasNoninfowindowTarget: function hasNoninfowindowTarget(actionObj) {	
					var xtabModel = this.xtabModel,
						docModel = (xtabModel && xtabModel.docModel);
					if (docModel) {
						var layouts = docModel.defn && docModel.defn.layouts,
							layout = null,
							i;
						// for document which has multiple layouts
						if (layouts) {
							for(i in layouts) {
								if (layouts.hasOwnProperty(i)) {
									if (layouts[i].loaded) {
										layout = layouts[i];
										break;
									}
								}								
							}
						}
						
						var units = layout && layout.units;
						if (units) {
							for(i = 0; i < actionObj.scObjList.length; i++){
								var scObj = actionObj.scObjList[i];
								/*
								* if there are multi tks on the attr, the tks of sc will be "W45\x1EW50"
								*/
								
								var tksList = scObj.sc.tks.split("\x1E"),
									j;
								for(j = 0; j < tksList.length; j++){
									var unit = units[tksList[j]];
									if (unit) {
										if (!unit.ifw) {
											return true;
										}
									}
								}								
							}
						}
					}
					
					return false;
				},
				
				hasInfowindowTarget: function hasInfowindowTarget(actionObj) {	
					var xtabModel = this.xtabModel,
						docModel = (xtabModel && xtabModel.docModel);
					if (docModel) {
						var layouts = docModel.defn && docModel.defn.layouts,
							layout = null,
							i;
						// for document which has multiple layouts
						if (layouts) {
							for(i in layouts) {
								if (layouts.hasOwnProperty(i) && layouts[i].loaded) {
									layout = layouts[i];
									break;
								}
							}
						}
						
						var units = layout && layout.units;
						if (units) {
							for(i = 0; i < actionObj.scObjList.length; i++){
								var scObj = actionObj.scObjList[i];
								/*
								* if there are multi tks on the attr, the tks of sc will be "W45W50"
								* so scObj.sc.tks.split("W") will split to "";"45";"50"
								*/
								// there may be encode inconsistance of the string in the json model
//								var tks = scObj.sc.tks;
//								var equal = (tks==="W48W51");
//								if (equal) {
//									alert(tks+": equal to W48W51");
//								} else {
//									alert(tks+": not equal to W48W51");
//								}
								
								var tksList = scObj.sc.tks.split("\x1E"),
									j;
								for(j = 0; j < tksList.length; j++){
									var unit = units[tksList[j]];
									if (unit) {
										if (unit.ifw) {
											return true;
										}
									}
								}								
							}
						}
					}
					
					return false;
				},
				
				
				touchTap: function touchTap(touch){
					//console.log("touchTap");
					var me = this;
					if (touch.count == 2) { // double tap
						/*
						* Dismiss the tooltip and its associated highlight if any
						*/
						me.hideTooltip();
						
						me.relScaleFactor = 1 / me.scaleFactor;
						me.applyTransform({scale: me.relScaleFactor}, 500, me.postScale);
					} else if (touch.count == 1) { // single tap
						/*
						* If tooltip show and tap on the tooltip
						* Dismiss the tooltip and its associated highlight
						*/
						
						var actionObj;
						if (me.tooltipOn) {
							var item = mstrmojo.dom.findAncestorByAttr(touch.target, "clk", true, this.domNode) || null;
							if (item) {
								var value = item.value;
								if (value === "clk" ){
									me.hideTooltip();
									return;
								}						
							} 
						}
						
						var touchedObj = this.getTouchedObj(true, touch.pageX, touch.pageY);
						
						if (touchedObj && touchedObj.hdrIndex>=0){
							/*
							* Area or Bubble being touched!
							*/
							var canBeSelected = me.pointCanBeSelected(touchedObj),
								sameAsCurrSelectedPoint = me.currSelectedObjBackup && (touchedObj.touchVal == me.currSelectedObjBackup.touchVal),
								sameAsLastHighlight;
							
							if (canBeSelected){
								
								if (!sameAsCurrSelectedPoint){
									
									me.defaultSelectedObjs = {};
									/*
									* Do selection or link drill
									*/
									
									/*
									* Dismiss the tooltip and its associated highlight if any
									*/									
									me.hideTooltip();								
									
									actionObj = this.getActionObj(touchedObj);
									if (actionObj && actionObj.scObjList){
										me.currSelectedObj = touchedObj;
										/*
										* caculate the selector targets count
										*/
										if (!me.hasOwnProperty("hasNonifwTarget") || !me.hasOwnProperty("hasIfwTarget")) {
											me.hasNonifwTarget = me.hasNoninfowindowTarget(actionObj);
											me.hasIfwTarget = me.hasInfowindowTarget(actionObj);
											actionObj = this.getActionObj(touchedObj);
										}
										
//										me.selectorTargetCount = 0;
//										var scTks = {};
//										
//										for(var i = 0; i < actionObj.scObjList.length; i++){
//											var scObj = actionObj.scObjList[i];
//											/*
//											* if there are multi tks on the attr, the tks of sc will be "W45W50"
//											* so scObj.sc.tks.split("W") will split to "";"45";"50"
//											*/
//											var tksList = scObj.sc.tks.split("W");
//											for(var j = 1; j < tksList.length; j++){
//												var target = 'W'+tksList[j];
//												if(!scTks[target]){
//													scTks[target] = true;
//													me.selectorTargetCount++;
//												}
//											}
//												
//										}
//										
//										this.selectorTargetMap = scTks;	
										
										me.highlightPoint();
										
										me.performAction([actionObj]);
									
									} else if (actionObj && actionObj.node) { // link drill with default
										me.currLinkObj = touchedObj;
										me.highlightPoint();
										
										me.performAction([actionObj]);
										me.currLinkObj = null;
										
									} 
									
									
								} else { // tap the current selected node
									/*
									* Tap on the last selected area or bubble
									* Do unselection
									*/
									// me.hideTooltip();
									// me.closeInfowindow();
									
									if (this.currHoverObj && this.currSelectedObj && this.currHoverObj.touchVal===this.currSelectedObj.touchVal){ // there is tooltip on the current selected node
										/*
										* if the selected element is showing a tooltip
										* then tapping on the selected element will only dismiss the tooltip (not the selection highlight or the selection).
										*/
									} else {
										if (me.hasNonifwTarget) { 
											/*
											* select all
											* sameAsCurrentSelectedObj
											* has non-infowindow target
											*/
											actionObj = me.getActionObj(touchedObj, true, true);	
											if(actionObj){ // do select all					
												me.performAction([actionObj]);	
												me.currSelectedObj = null;
												me.highlightPoint();
											} else { // no "select all"
												// tap on a node to display an infowindow, and then tap it again to dismiss it. And then tap it again, an info window should be displayed again.
												me.getFirstInfowindow();
												if (!me.infowindowOn && me.infowindow) {
													me.model.infowindowOn = true;
													me.infowindow.open();
												}
												
											}
										}										
									}
									
									me.hideTooltip();
								}
							} else { // No selection and (no link drill configured or linkdrill without default link)
								sameAsLastHighlight = me.currHoverObj && (touchedObj.touchVal == me.currHoverObj.touchVal);
								if(!sameAsLastHighlight){
									/*
									* Show tooltip and associated highlight 
									*/
									me.currHoverObj = touchedObj;
									
									me.highlightPoint();
								} else { 
									me.hideTooltip();
								}
								
							}
						
						} else if (touchedObj && touchedObj.hdrIndex<0) { // tap on node with hdrIndex<0
							/*
							* tap on a target that is in the ALT, but not in the model
							*/
							sameAsLastHighlight = me.currHoverObj && (touchedObj.touchVal == me.currHoverObj.touchVal);
							if (!sameAsLastHighlight){
								/*
								* Show tooltip and associated highlight 
								*/
								me.currHoverObj = touchedObj;
								
								me.highlightPoint();
							} else {
								me.hideTooltip();
							}
						} else if (!touchedObj){ // tap on the empty space inside the widget
							/*
							* tapped on empty space:
							* dismiss tooltip is there is any
							* dismiss infowindow if there is any
							* dismiss selector if the current selector permits "select all"
							*/
							
							me.hideTooltip();
							
							// me.closeInfowindow();
														
							if (me.currSelectedObjBackup && me.hasNonifwTarget){
								/*
								* if a selector action has been triggered from the visualization
								* tapping on the empty space will clear the selection and remove the highlight
								*/
								
								actionObj = this.getActionObj(touchedObj, true);	
								/*
								* if there is attr sc can't select all, actionObj is null
								*/
								if (actionObj){
									me.performAction([actionObj]);
									me.currSelectedObj = null;
									me.highlightPoint();
								}
								
							}
						}
					}
					
							
				},
				
				showInfowindow: function showInfowindow(touchedObj) {
					var me = this,
						actionObj;
					
					if (touchedObj && touchedObj.hdrIndex>=0){
						/*
						* Area or Bubble being touched!
						*/
						var canBeSelected = me.pointCanBeSelected(touchedObj),
							sameAsCurrSelectedPoint = me.currSelectedObj && (touchedObj.touchVal == me.currSelectedObj.touchVal);
						
						if( canBeSelected ){
							
							if( !sameAsCurrSelectedPoint ){
								/*
								* Dismiss the tooltip and its associated highlight if any
								*/
								me.hideTooltip();
								
								actionObj = me.getActionObj(touchedObj);
								if (actionObj && actionObj.scObjList){
									me.currSelectedObj = touchedObj;
								}
								
								/*
								* dismiss the last selection and its associated highlight
								* make the currently tapped element the selection
								*/
								me.highlightPoint();
								
								me.performAction([actionObj]);
								
							} else { // tap the current selected node								
								if (this.currHoverObj && this.currSelectedObj && this.currHoverObj.touchVal===this.currSelectedObj.touchVal){ // there is tooltip on the current selected node
									/*
									* if the selected element is showing a tooltip
									* then tapping on the selected element will only dismiss the tooltip (not the selection highlight or the selection).							
									*/
									me.hideTooltip();
								} else {
									me.hideTooltip();
									/*
									* Do unselection
									*/									
									actionObj = this.getActionObj(touchedObj, true, true);	
									/*
									* if there is attr sc can't select all, actionObj is null
									*/
									if (actionObj){					
										me.performAction([actionObj]);	
										me.currSelectedObj = null;
										me.highlightPoint();
									}
								}
							}
						} else { // cannot be selected

						}					
					} else if ((touchedObj && touchedObj.hdrIndex<0) || !touchedObj){ 
						// tap on the empty space inside the widget or an node in the map html file but not in the attribute element
						/*
						* tapped on empty space or an node in the map html file but not in the attribute element:
						* dismiss tooltip if there is any
						* dismiss infowindow if there is any
						* dismiss selector if the current selector permits "select all"
						*/
						
						me.hideTooltip();
						
						// me.closeInfowindow();
													
						if(me.currSelectedObj){
							/*
							* if a selector action has been triggered from the visualization
							* tapping on the empty space will clear the selection and remove the highlight
							*/
							
							actionObj = me.getActionObj(touchedObj, true);	
							/*
							* if there is attr sc can't select all, actionObj is null
							*/
							if(actionObj){
								me.performAction([actionObj]);
								me.currSelectedObj = null;
								me.highlightPoint();
							}
							
						}
					}
				},
				
				
				
				/*
				* remove the transform scale
				* redraw the map according to the scaleFactor 
				*/
				postScale: function () {
					delete this._scroller.transform;
					this._scroller.scrollTo(this._scroller.origin.x, this._scroller.origin.y, 0);
					this.scaleFactor *= this.relScaleFactor;
					this.refreshWidget();
				},
				
				/*
				* redraw the map according to the scaleFactor 
				*/
				refreshWidget: function () {
					this.drawMap();
					this.highlightPoint();
				},
				
				/*
				* return attrIndices as [[0], [1,2], [3],...] 
				*/
				getAttrIndices: function getAttrIndices() {
					var me = this,
						model = me.model,
						rows = model && model.gts && model.gts.row,
						i,j;
					
					if (rows) {
						var attrIndices = [],
							idx = 0;
						for (i=0; i<rows.length; i++) {
							var fs = rows[i] && rows[i].fs;
							attrIndices.push(new Array());
							if (fs) {
								for (j=0; j<fs.length; j++) {
									attrIndices[i].push(idx++);
								}
							}						
						}					
						return attrIndices;
					} else {
						return null;
					}
				},
				
				createTooltipTable: function createTooltipTable() {
					var me = this,
						model = me.model,
						table = me.tooltip.childNodes[0],
						rows = model && model.gts && model.gts.row,
						cols = model && model.gts && model.gts.col && model.gts.col[0] && model.gts.col[0].es,
						i;
					
					if (table.childNodes.length===0 && rows && rows.length>0) {
						var trNum = rows.length + (cols?cols.length:0); // rows cannot be null, but cols can be null
						for (i=0; i<trNum; i++) {
							var tr = document.createElement("tr");
							
							var tdLeft = document.createElement("td");
							tdLeft.align = "right";
							tdLeft.style.color = "#545462";
							tr.appendChild(tdLeft);
							
							var tdRight = document.createElement("td");
							tdRight.align = "left";
							tdRight.style.color = "#000000";
							tr.appendChild(tdRight);
							
							table.appendChild(tr);
						}
					}
					
				},
				
				localTakeScreenshot: function localTakeScreenshot(_time) {
					var me = this;
					window.setTimeout(function() {
						var ctrlID = me.controller.id;
						var ctrl = mstrmojo.all[ctrlID];
						if (ctrl && ctrl.rootCtrl.getCurrent() === ctrl) {
							ctrl.takeScreenShot();
							// alert("screenshot taken");
						}
					}, _time);
				},
				
				// get default selected objects: name and hdrIndex
				getDefaultSelectedObjs: function getDefaultSelectedObjs() {
					var me = this,
						model = me.model,
						idxs = model && model.ghs && model.ghs.rhs && model.ghs.rhs.items,
						gts_rows = model && model.gts && model.gts.row,
						i,name,idx,item;
					
					// do not do this again
					if (me.haveGotDftSltObjs) {
						return;
					} else {
						me.haveGotDftSltObjs = true;
					}
					
					me.defaultSelectedObjs = {};
					if (idxs && gts_rows && gts_rows.length>0) {
						for (i in idxs) {
							if (idxs.hasOwnProperty(i)) {
								item = idxs[i].items[0];
								if (item && item.hasOwnProperty("cet")) {
									idx = item.idx;
									name = gts_rows[0].es[idx].n;
									if (!(me.defaultSelectedObjs.hasOwnProperty(name))) {
										me.defaultSelectedObjs[name] = idx;
									}							
								}
							}						
						}
					}
						
				},
				
				renderErrorMessage: function renderErrorMessage(errorMessage) {
					//this._super(errorMessage);
									
					// format the div
					var me = this,
						msgDiv = me.errorMessage,
						newErrorMessage = errorMessage.replace(/-/g, "<br />-");
					msgDiv.innerHTML = newErrorMessage;
					
					msgDiv.style.width = me.getWidth() + "px";
					msgDiv.style.fontSize = me.errMsgFontSize + "px";
					msgDiv.style.fontFamily = "Tahoma";
					msgDiv.style.color = ERROR_MSG_FONT_COLOR_DARK_THEME;
					msgDiv.style.backgroundColor = "RGBA(0,0,0,0)";
					
					var bgColor = DEFAULT_BG_COLOR;
					if (me.model.hasOwnProperty("vp") && me.model.vp.hasOwnProperty("bc") && me.model.vp.bc!=="") {
						bgColor = "#" + me.model.vp.bc;
					} else {
						bgColor = me.utils.getAncestorBgColor(me) || DEFAULT_BG_COLOR;
					}		
					me.domNode.style.backgroundColor = bgColor;
					me.model.themeMode = getThemeMode(bgColor);
					if (me.model.themeMode === THEME_LIGHT) {
						msgDiv.style.color = ERROR_MSG_FONT_COLOR_LIGHT_THEME;
					}
					
				},
				
				setFontByDPI: function setFontByDPI() {
					// avoid repeat setting
					if (this.setFontByDPIFlag) {
						return;
					}
					var me = this;
					me.setFontByDPIFlag = true;
					
					// init the font size
					me.hoverBubbleRadiusLarger = 5;
					me.bubbleStrokeWidth = 2;
					me.baseMaxBubbleSizeAuto = 12;
					me.baseMaxBubbleSizeManual = 24;
					me.polygonStrokeWidth = 1;
					me.highlightPolygonStrokeWidth = 2;
					me.borderSpace = 5;
					// me.tooltipFontSize = 8; // 8pt
					me.tooltipFontSize = 12; // 12px
					me.tooltipBorderWidth = 1; // 1px
					me.tooltipBorderRadius = 5;
					// me.errMsgFontSize = 12; // 12pt
					me.errMsgFontSize = 16; // 16px
					me.bias = 30; // 30px
					me.tooltipRightShadowWidth = 4; // 4px
					
					// check fitToPage and microApp
					var xtabModel = me.xtabModel,
						docModel = (xtabModel && xtabModel.docModel),
						fitToPage = false, 
						microApp = false;
					if (docModel) {
						fitToPage = docModel.zt && (docModel.zt==2);
						var layouts = docModel.defn && docModel.defn.layouts,
							layout,
							i;
						// for document which has multiple layouts
						for(i in layouts) {
							if (layouts.hasOwnProperty(i) && layouts[i] && layouts[i].loaded) {
								layout = layouts[i];
								break;
							}
						}
						if (layout && layout.hasOwnProperty("fch")) {
							microApp = layout.fch;
						}
					}
					if (fitToPage && microApp) {
//						var dpix = mstrMobileApp.getDeviceDPIX();
//						var dpiy = mstrMobileApp.getDeviceDPIY();
//						alert("dpix: " + dpix +
//								"\ndpiy: " + dpiy);
						
						var devicedpi = mstrMobileApp.getDeviceDPIX();
						var baseDpi = 149;
						var ratio = 1;
						if (devicedpi > 0 ) { ratio = devicedpi / baseDpi; }
						
						if (ratio > 1) {
							me.hoverBubbleRadiusLarger *= ratio;
							me.bubbleStrokeWidth *= ratio;
							me.baseMaxBubbleSizeAuto *= ratio;
							me.baseMaxBubbleSizeManual *= ratio;
							me.polygonStrokeWidth *= ratio;
							me.highlightPolygonStrokeWidth *= ratio;
							me.borderSpace *= ratio;
							me.tooltipFontSize *= ratio;
							me.tooltipBorderWidth *= ratio;
							me.tooltipBorderRadius *= ratio;
							me.errMsgFontSize *= ratio;
							me.bias *= ratio;
							me.tooltipRightShadowWidth *= ratio;
							
											
							// adjust tooltip div
							var tooltip = me.tooltip,
								table = tooltip.childNodes[0];
							
							tooltip.style.fontSize = me.tooltipFontSize + "px";
							tooltip.style.borderWidth = me.tooltipBorderWidth + "px";
							tooltip.style.borderRadius = me.tooltipBorderRadius + "px";
							tooltip.style.boxShadow = 3*ratio + "px " + 3*ratio + "px " + 4*ratio + "px " + "RGBA(0,0,0,0.45)";
							table.style.margin = 5*ratio + "px " + 7*ratio + "px";
						}
					}
					
					
				},
				
				initScroller: function initScroller(scroller) {
					scroller.vScroll = true;
					scroller.hScroll = true;

					this._super(scroller);
				},
				
				
				/*
				 * get the last cell of an element of the first attribute
				 * used for docuemnt with multiple attributes
				 * test examples can be found in Test Suite > 001 - Template > 4:1 or 4:2 or 4:3
				 */
				getIndexFromHdrindex: function getIndexFromHdrIndex(hdrIndex) {
					var me = this,
						idxs = me.model.ghs.rhs.items;
					
					if (idxs) {
						var i,
							curRow,
							nextRow;
						for (i=0; i<idxs.length; i++) {
							curRow = idxs[i].items;
							if (curRow.length>0 && curRow[0].idx==hdrIndex) {
								if (i===idxs.length-1) {
									return i;
								} else {
									nextRow = idxs[i+1].items;
									if (nextRow.length>0 && nextRow[0].idx!=hdrIndex) {
										return i;
									} else {
										continue;
									}
								}
							} else {
								continue;
							}
						}
					}
					
					return 0;
				},

				/*
				 * 
				 */
				drawMap: function drawMap(){
					var me = this,
						model = me.model;
					
					
					/*
					 * Clear the animation canvas by resetting the width of the canvases, so that ImamgeLayout can be rendered in OS 4.2
					 * 
					 */
					//me.animationContext.clearRect(0,0,me.animationCanvas.width, me.animationCanvas.height);
					//me.highlightContext.clearRect(0,0,me.highlightCanvas.width, me.highlightCanvas.height);
					me.animationCanvas.width = me.animationCanvas.width;
					me.highlightCanvas.width = me.highlightCanvas.width;
				
					/*
					 * create some properties in model to indicate the display mode
					 */
					if (!me.hasOwnProperty("displayMode")) { me.displayMode = DISPLAY_MODE_AUTOMATIC; }
					if (!me.hasOwnProperty("markerType")) { me.markerType = MARKER_UNDEFINED; }
					if (!me.hasOwnProperty("shapeFileType")) { me.shapeFileType = SHAPE_FILE_UNDEFINED; }
					if (!me.hasOwnProperty("colorByIndex")) { me.colorByIndex = -1; }
					if (!me.hasOwnProperty("sizeByIndex")) { me.sizeByIndex = -1; }
					//if (!me.hasOwnProperty("drawPolygonFlag")) { me.drawPolygonFlag = false; } // Define draw polygon or not when shapeFileType = SHAPE_FILE_POLYGON
					if (!me.hasOwnProperty("drawBgImageFlag")) { me.drawBgImageFlag = false; } // Indicate whether the background image is drawn.
					//if (!me.hasOwnProperty("hasBGImage")) { me.hasBGImage = false; }
					if (!me.hasOwnProperty("thresholdType")) { me.thresholdType = THRESHOLD_UNDEFINED; }
					//if (!model.hasOwnProperty("highlightMode")) { model.highlightMode = HIGHLIGHT_MODE_NORMAL; }
					if (!me.hasOwnProperty("curPolygonOpacity")) { me.curPolygonOpacity = POLY_NORMAL_OPACITY; }
					if (!model.hasOwnProperty("infowindowOn")) { model.infowindowOn = false; }
					if (!me.hasOwnProperty("touchSelectWithIfw")) { me.touchSelectWithIfw = false; }
					
					if (me.model.hasOwnProperty("vp")) {
						var bgColor = DEFAULT_BG_COLOR;
						if (me.model.vp.hasOwnProperty("bc") && me.model.vp.bc!=="") {
							bgColor = "#" + me.model.vp.bc;
						} else {
							bgColor = me.utils.getAncestorBgColor(me) || DEFAULT_BG_COLOR;
						}
						me.domNode.style.backgroundColor = bgColor;
						me.model.themeMode = getThemeMode(bgColor);
						me.model.bgColor = bgColor;
						
						me.tooltip.style.top = "0px";
						
						me.setDisplayParas();
						
						if (me.displayMode === DISPLAY_MODE_AREA) { 
							me.drawAreaMap();
						} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
							me.drawBubbleMap();
						}
					}

				},
				
				/*
				 * return the index of the metric (in column) according to its id
				 */
				getIndexById: function getIndexById(id) {
					var me = this,
						model = me.model,
						gtsCol = model.gts && model.gts.col,
						gtsColEle = null,
						i;
					if (gtsCol && gtsCol.length > 0 && gtsCol[0].hasOwnProperty("es")) {
						gtsColEle = gtsCol[0].es;
						
						for (i=0; i<gtsColEle.length; i++) {
							if (gtsColEle[i].oid === id) {
								return i;
							}
						} 
					}
					
					return -1;
				},
				
				
				/*
				 * set this.displayMode, this.markerType, this.shapeFileType, 
				 * this.colorByIndex, this.sizeByIndex...
				 */
				setDisplayParas: function setDisplayParas(){
					
					var me = this,
						model = me.model;  
					
					/*
					 * set display parameters only once for a given template
					 */
					if (!me.hasOwnProperty("setDisplayParasFlag")) {
						me.setDisplayParasFlag = true;
					} else {
						return;
					}

					me.shapeFileType = getShapeFileType(model.coords);
					
					var colCount = 0;
					if (model.hasOwnProperty("gvs") 
							&& model.gvs.hasOwnProperty("items") 
							&& model.gvs.items.length > 0
							&& model.gvs.items[0].hasOwnProperty("items")
							&& model.gvs.items[0].items.length > 0) {
						colCount = model.gvs.items[0].items.length;
					}
					
					me.displayMode = model.vp.mt;
					if (me.displayMode === DISPLAY_MODE_AREA) {
						if (colCount > 0) {
							if (model.vp.hasOwnProperty("ColorBy")) {
								me.colorByIndex = me.getIndexById(model.vp.ColorBy);
								if (me.colorByIndex < 0) {
									me.colorByIndex = 0;
								}
							} else {
								me.colorByIndex = 0;
							}
							
							me.thresholdType = me.getThresholdType(me.colorByIndex);
							
							// TQMS: 687074, comment this to fix this issue.
//							for (i=0; i<colCount; i++) {
//								var thresholdType = this.getThresholdType(i);
//								if (thresholdType === THRESHOLD_COLOR) {
//									me.colorByIndex = i;
//									me.thresholdType = THRESHOLD_COLOR;
//								} else if (thresholdType === THRESHOLD_IMAGE) {
//									me.colorByIndex = i;
//									me.thresholdType = THRESHOLD_IMAGE;
//									me.markerType = MARKER_IMAGE;
//								}
//							}		
						} else { // no data
							//model.colorAreaFlag = false;
						}
					} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
						if (colCount > 0) {
							this.setBubbleModeParasWithData(colCount);
						} else { // no data, the same size in the corresponding center(POLYGON) or the point position(POINT)
							// to display bubbles in default size and default color.
							me.markerType = MARKER_BUBBLE;
						}					
					} else if (me.displayMode === DISPLAY_MODE_AUTOMATIC) {
						if (colCount > 0) {
							me.displayMode = DISPLAY_MODE_BUBBLE;
							this.setBubbleModeParasWithData(colCount);
						} else { // no data in the model
							if (me.shapeFileType === SHAPE_FILE_POLYGON) {
								me.displayMode = DISPLAY_MODE_AREA;
							} else if (me.shapeFileType === SHAPE_FILE_POINT) {
								me.displayMode = DISPLAY_MODE_BUBBLE;
								me.markerType = MARKER_BUBBLE;
							}						
							//model.colorAreaFlag = false;
						}
						
					} else if (!me.displayMode) { // TQMS 687396
						if (colCount > 0) {
							me.displayMode = DISPLAY_MODE_BUBBLE;
							this.setBubbleModeParasWithData(colCount);
						} else { // no data in the model
							if (me.shapeFileType === SHAPE_FILE_POLYGON) {
								me.displayMode = DISPLAY_MODE_AREA;
							} else if (me.shapeFileType === SHAPE_FILE_POINT) {
								me.displayMode = DISPLAY_MODE_BUBBLE;
								me.markerType = MARKER_BUBBLE;
							}						
							//model.colorAreaFlag = false;
						}
					}
					
					// define this.drawPolygonFlag
//					if (me.shapeFileType === SHAPE_FILE_POLYGON) {
//						me.drawPolygonFlag = true;
//						if (me.displayMode===DISPLAY_MODE_BUBBLE && model.coords.bgImage) {
//							me.drawPolygonFlag = false;
//						}
//					}
					
				},
				
				/*
				 * if bubble mode is used, set corresponding display parameters when column count is greater than 0
				 */
				setBubbleModeParasWithData: function setBubbleModeParasWithData(colCount) {
					var me = this,
						model = me.model;
					if (model.vp.hasOwnProperty("SizeBy")) {
						me.sizeByIndex = this.getIndexById(model.vp.SizeBy);
						if (me.sizeByIndex < 0) {
							me.sizeByIndex = 0;
						}
					} else {
						me.sizeByIndex = 0;
					}
					
					if (model.vp.hasOwnProperty("ColorBy")) {
						me.colorByIndex = this.getIndexById(model.vp.ColorBy);
						if (me.colorByIndex < 0) {
							me.colorByIndex = 0;
						}
						
						me.thresholdType = me.getThresholdType(me.colorByIndex);
						if (me.thresholdType === THRESHOLD_IMAGE) {
							me.markerType = MARKER_IMAGE;
						} else {
							me.markerType = MARKER_BUBBLE;
						}
					} else {
						if (colCount===1) {
							me.colorByIndex = 0;
							me.thresholdType = this.getThresholdType(0);
							if (me.thresholdType === THRESHOLD_IMAGE) {
								me.markerType = MARKER_IMAGE;
							} else {
								me.markerType = MARKER_BUBBLE;
							}
						} else if (colCount>1) {
							var firstThresholdType = this.getThresholdType(0); 
							if (firstThresholdType === THRESHOLD_IMAGE) {
								me.colorByIndex = 0;
								me.thresholdType = firstThresholdType;
								me.markerType = MARKER_IMAGE;
							} else {
								me.colorByIndex = 1;
								me.thresholdType = this.getThresholdType(1);
								if (me.thresholdType === THRESHOLD_IMAGE) {
									me.markerType = MARKER_IMAGE;
								} else {
									me.markerType = MARKER_BUBBLE;
								}
								
							}
						}
					}

				},
				
				/*
				 * to decide the threshold type (color or image or none)
				 */
				getThresholdType: function getThresholdType(colIndex) {
					var me = this,
						th = me.model && me.model.th,
						subTh = th && th[colIndex],
						gvs = me.model && me.model.gvs,
						gts_es = me.model.gts.row[0].es,
						elem,
						i,
						cellData;
					
					if (subTh && gvs.items.length>0) { // have data
						if (colIndex >= gvs.items[0].items.length || colIndex<0 || subTh.length === 0) { 
							return THRESHOLD_UNDEFINED; 
						}
						for (i in gts_es) {
							if (gts_es.hasOwnProperty(i)) {
								cellData = gvs.items[me.getIndexFromHdrindex(i)].items[colIndex];
								if (cellData.hasOwnProperty("ty") && parseInt(cellData.ty,10)===4) {
									return THRESHOLD_IMAGE;
								}
							}						
						}
						
						var isImgReg = /(jpg|jpeg|png|gif|tiff|bmp)$/i;
						for (elem in subTh) {
							if (subTh.hasOwnProperty(elem) && isImgReg.test(subTh[elem].n)) {
								return THRESHOLD_IMAGE;
							}
						}

						for (i in gts_es) {
							if (gts_es.hasOwnProperty(i)) {
								cellData = gvs.items[me.getIndexFromHdrindex(i)].items[colIndex];
								if (cellData.hasOwnProperty("ty") && parseInt(cellData.ty,10)===2) {
									return THRESHOLD_COLOR;
								}
							}						
						}
						return THRESHOLD_UNDEFINED;
					} else { // no data
						return THRESHOLD_UNDEFINED;
					}
				},
				
				/*
				 * scale the polygon coords according to the size of the widget (considering scale factor)
				 * and get the offset stored in this widget as this.topOffset and this.leftOffset
				 */
				scalePolygonCoords: function scalePolygonCoords() { 
					var me = this,
						model = me.model,
						coords = model.coords;
					
					var maxX = 0,
						maxY = 0, 
						rgn, c, i, j, k;

					for (i in coords) {
						if (coords.hasOwnProperty(i)) {
							if (i === "bgImage") {
								continue;
							}
							rgn = coords[i];
							for (j in rgn) {
								if (rgn.hasOwnProperty(j)) {
								c = rgn[j];
									for (k = 0; k < c.length; k++) {
										if (c[k] > maxX) {
											maxX = c[k];
										}
										k++;
										if (c[k] > maxY) {
											maxY = c[k];
										}							
									}
								}							
							}
						}					
					}

					var xRatio = maxX / ((this.getWidth() - 10) * this.scaleFactor),
						yRatio = maxY / ((this.getHeight() - 10) * this.scaleFactor),
						ratio = Math.max(yRatio, xRatio) ;
					
					//make map in the center
					this.topOffset = (this.getHeight()*this.scaleFactor - maxY/ratio) / 2 ;
					this.leftOffset = (this.getWidth()*this.scaleFactor - maxX/ratio) / 2 ;
					
					
					for (i in coords) {
						if (coords.hasOwnProperty(i)) {
							if (i === "bgImage") {
								continue;
							}
							rgn = coords[i];
							for (j in rgn) {
								if (rgn.hasOwnProperty(j)) {
									c = rgn[j];
									for (k = 0; k < c.length; k++) {
										c[k] = parseInt(c[k] / ratio, 10);
									}
								}							
							}
						}					
					}
				},
				
				/*
				 * get the background color of a cell from its attribute element name
				 */
				getBubbleColorFromName: function getBubbleColorFromName(elem) {
					if (this.allBubblesColor && this.allBubblesColor.hasOwnProperty(elem)) {
						return this.allBubblesColor[elem];
					} else {
						return null;
					}
				},
				/*
				 * get the background color of a cell from its cell data (cellData)
				 */
				getBgColorFromCSS: function getBgColorFromCSS(cellData) {
					var cssDiv = this.cssDiv,
						csss = null,
						th = null,
						cni,
						cssStyle;
					if (this.model.hasOwnProperty("css")) {
						csss = this.model.css;
					}
					if (this.model.hasOwnProperty("th")) {
						th = this.model.th && this.model.th[this.colorByIndex];
					}
									
					if (csss && th && cellData && cellData.hasOwnProperty("ty")) {
						if ((parseInt(cellData.ty, 10) === 2 || parseInt(cellData.ty, 10) === 4) && cellData.hasOwnProperty("ti") && th.length>cellData.ti && th[cellData.ti].udbg===1) {
							// udbg=1: user has set the background color, otherwise, return null -- use the default color
							cni = th[cellData.ti].cni;
							cssDiv.className = cni && csss[cni] && csss[cni].n;
							cssStyle = mstrmojo.css.getComputedStyle(cssDiv);
							if (cssStyle.hasOwnProperty("backgroundColor")) {
								return cssStyle.backgroundColor;
							}
//							if (cssStyle.hasOwnProperty("backgroundColor") && cssStyle.backgroundColor!=="rgba(0, 0, 0, 0)" && cssStyle.backgroundColor!=="rgb(255, 255, 255)") {
//								// A default backgroundColor is rgb(255, 255, 255) and "no fill" color is rgba(0, 0, 0, 0). In these two occasions noColorByColor is displayed
//								return cssStyle.backgroundColor;
//							}
						}
					}

					return null;
				},

				/*
				 * draw all the polygons stored in model.coords in animationCanvas with opacity (opacity)
				 */
				drawPolygonInMap: function drawPolygonInMap(opacity) {
					var me = this,
						model = me.model,
						coords = model.coords,
						context = this.animationContext,
						elem;
					//context.clearRect(0, 0, this.animationCanvas.width, this.animationCanvas.height);
					me.animationCanvas.width = me.animationCanvas.width;
					
					/*
					 * if the widget has background image, draw it first
					 */
					if (me.drawBgImageFlag && model.bgImg) {
						var xRatio = me.oriBgImageWidth / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
							yRatio = me.oriBgImageHeight / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), // add some padding
							ratio = Math.max(yRatio, xRatio); 
						
						me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
						me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;

						context.drawImage(model.bgImg, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
					}
					
					me.curPolygonOpacity = opacity;
					
					var noAltColor = POLY_COLOR_NO_ALT_DARK_THEME,
						noColorByColor = POLY_COLOR_NO_COLORBY_DARK_THEME,
						strokeColor = POLY_STROKE_COLOR_DARK_THEME;
					if (model.themeMode === THEME_LIGHT) {
						noAltColor = POLY_COLOR_NO_ALT_LIGHT_THEME;
						noColorByColor = POLY_COLOR_NO_COLORBY_LIGHT_THEME;
						strokeColor = POLY_STROKE_COLOR_LIGHT_THEME;
					}
					
					if (model.vp && model.vp.npc) {
						noAltColor = getOpacityColor("#"+model.vp.npc, POLY_NORMAL_OPACITY);
					}
					
					// loop through all areas on the coords
					for (elem in coords) {
						if (!coords.hasOwnProperty(elem)) {
							continue;
						}
						if (coords.hasOwnProperty(elem)) {
							if (elem === "bgImage") {
								continue;
							}
							
							// start with default color
							var clr = noAltColor;
							
							// for the current area find its index in mojo data
							if (me.displayMode === DISPLAY_MODE_AREA) {
								var hdrIndex = this.getHeaderIndex(elem);
								if (hdrIndex >= 0) {
									if (me.colorByIndex >= 0) { // find threshold color.
										var mv = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
										clr = me.getBgColorFromCSS(mv);
										if (!clr) {
											clr = noColorByColor;
										}
										if (me.drawBgImageFlag) {
											clr = getOpacityColor(clr, POLY_ABOVE_BG_OPACITY);
										} else {
											clr = getOpacityColor(clr, POLY_NORMAL_OPACITY);
										}
		//								if (mv && mv.hasOwnProperty("ty") && parseInt(mv.ty, 10) === 2) {
		//									var ti = mv.ti;
		//									if (mv.hasOwnProperty("ti")) {
		//										var clr = model.th[mv.ti].n; // threshold object
		//										//var cssName = model.css[cni];
		//										//clr = "#FF0";
		//										//clr = getBgColorFromCssString(???, cssName);
		//										if (/fff|FFF|ffffff|FFFFFF/.test(clr)) {
		//											clr = noColorByColor;
		//										} else {
		//											if (me.drawBgImageFlag) {
		//												clr = getOpacityColor(clr, POLY_ABOVE_BG_OPACITY);
		//											} else {
		//												clr = getOpacityColor(clr, POLY_NORMAL_OPACITY);
		//											}											
		//										}
		//									}
		//								} else {
		//									clr = noColorByColor;
		//									//drawPoly(context, coords[elem], {x:this.leftOffset,y:this.topOffset}, strokeColor, 1, clr);
		//									
		//									// TQMS: 687074, Donot show image image Area mode.
		//									// draw image icon in center of polygon
		////									var iconPath = mv.v;
		////									var fullIconPath = this.getFullPath(iconPath);
		////									var propName = "imageIcon_" + elem;
		////									model[propName] = new Image();
		////									model[propName].src = fullIconPath;
		////									model[propName].id = elem
		////									model[propName].onload = function() {
		////										if (this.width<me.getWidth()*me.scaleFactor && this.height<me.getHeight()*me.scaleFactor) {
		////											var xOffset = model.polygonCenters[this.id][0][0] - this.width/2 + me.leftOffset;
		////											var yOffset = model.polygonCenters[this.id][0][1] - this.height/2 + me.topOffset;
		////											me.animationContext.drawImage(this, xOffset, yOffset);
		////										}
		////									}
		//									
		//									//continue;
		//								}
									} else {
										clr = noColorByColor;
									}
								} else {
									clr = noAltColor;
								}
							} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
								clr = noAltColor;
							}
						}					
						
						clr = getOpacityColor(clr, opacity);

						//add opacity to clr and lclr
						//clr = getOpacityColor(clr, model.polygonOpacity);
						
						drawPoly(context, coords[elem], {x:this.leftOffset,y:this.topOffset}, strokeColor, me.polygonStrokeWidth, clr);
					}
				},
				
				/*
				 * return bubble radius according to the element name (considering the scale factor)
				 */
				getRadiusFromName: function getRadiusFromName(name) {
					var me = this,
						model = me.model;
					
					if (model.coords.hasOwnProperty(name)) {
						if (me.model.hasOwnProperty("oriBubbleSize")) {
							return me.model.oriBubbleSize[name] * me.scaleFactor;
						} else {
							if (me.model.hasOwnProperty("maxBubbleRadius")) {
								return me.model.maxBubbleRadius * me.scaleFactor;
							} else {
								return 2;
							}
						}					
					} else {
						return -1;
					}
				},


				/*
				 * draw all the bubbles in animationCanvas in bubble mode -- bubble marker or image marker
				 */
				drawBubblesInMap: function drawBubblesInMap() {
					var me = this,
						model = me.model,
						coords = model.coords,
						elem;
					if (model.hasOwnProperty("polygonCenters")) {
						coords = model.polygonCenters;
					}
					
					me.highlightCanvas.width = me.highlightCanvas.width;
					
					var defBubbleColor = BUBBLE_COLOR_NO_COLORBY_DARK_THEME,
						strokeColor = BUBBLE_STROKE_COLOR_DARK_THEME;
					if (model.themeMode === THEME_LIGHT) {
						defBubbleColor = BUBBLE_COLOR_NO_COLORBY_LIGHT_THEME;
						strokeColor = BUBBLE_STROKE_COLOR_LIGHT_THEME;
					}
					var defRadius = Math.max(2, Math.min(12, MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER*0.15*Math.min(me.getWidth(),me.getHeight())));
					defRadius = defRadius * me.scaleFactor;
					
					var th = model.th && model.th[me.colorByIndex];
					if (me.markerType === MARKER_IMAGE) {
						var notFoundImageIconPath = me.getFullPath("images/image_not_found.jpg");
							defaultImageIconPath = me.getFullPath("images/roundedpp.png");
						
							//console.log('\ndefaultImageIconPath: ' + defaultImageIconPath);
							
						for (elem in coords) {
							if (coords.hasOwnProperty(elem)) {
								if (elem === "bgImage") {
									continue;
								}
								var propName = "imageIcon_" + elem;
								
								// If it is not the first time to draw, use the image icons in model directly without downloading
								if (model.hasOwnProperty(propName)) {
									var _image = model[propName];
									if (_image && _image.width && _image.height && _image.width<me.getWidth()*me.scaleFactor && _image.height<me.getHeight()*me.scaleFactor) {
										var xOffset = coords[elem][0][0] - _image.width/2 + me.leftOffset,
											yOffset = coords[elem][0][1] - _image.height/2 + me.topOffset;
										me.animationContext.drawImage(_image, xOffset, yOffset);
									}
									continue;
								}
								
								// download and draw image icons
								var hdrIndex = me.getHeaderIndex(elem);
								if (th && hdrIndex >= 0 && me.colorByIndex >= 0 && me.thresholdType === THRESHOLD_IMAGE) {
									var cellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
									if (cellData.hasOwnProperty("ty") && parseInt(cellData.ty, 10) === 4) {
										var iconPath = th.length>cellData.ti && th[cellData.ti].n;
										if (iconPath) {
											var fullIconPath = me.getFullPath(iconPath);
											model[propName] = new Image();
											model[propName].src = fullIconPath;
											model[propName].id = elem;
											model[propName].onload = function() {
												if (this.width<me.getWidth()*me.scaleFactor && this.height<me.getHeight()*me.scaleFactor) {
													var xOffset = coords[this.id][0][0] - this.width/2 + me.leftOffset,
														yOffset = coords[this.id][0][1] - this.height/2 + me.topOffset;
													me.animationContext.drawImage(this, xOffset, yOffset);
													// #725663 image icon default selection highlight cannot be achieved in highlightPoint() function
													// as the highlightPoint() function run before the image icon's downloading, so the width and height
													// of image icons can not be achieved.
//													if (me.defaultSelectedObjs.hasOwnProperty(this.id)) {
//														me.highlightImageIcon(me.highlightContext, coords, this.id, 0);
//													}
													
													// by doing above, we shouldn't call highlightPoint function afterwords,
													// or there will be repeated highlight in Web emulator and Nexus android 4.2.2 ( good in Samsung 4.0.4)
													// however, if we donot call highlightPoint when markerType equals MARKER_IMAGE, there will be another os 4.2.2 specific issue: 
													// the highlight above will not show up until you hover a node to show tooltip
													// so the following tricky way is using: 
													if (me.defaultSelectedObjs.hasOwnProperty(this.id)) {
														me.highlightCanvas.width = me.highlightCanvas.width;
														for (var dftSltObj in me.defaultSelectedObjs) {
															if (me.defaultSelectedObjs.hasOwnProperty(dftSltObj)) {
																me.highlightImageIcon(me.highlightContext, coords, dftSltObj, 0);
															}
														}
													}
												}
											};
											model[propName].onerror = function() {
												model["imageIcon_" + this.id].src = notFoundImageIconPath;
											};
										}								
									} else { 
										// display default pin image for cells not set image icon 2013-1-9
										model[propName] = new Image();
										model[propName].src = defaultImageIconPath;
										model[propName].id = elem;
										model[propName].onload = function() {
											if (this.width<me.getWidth()*me.scaleFactor && this.height<me.getHeight()*me.scaleFactor) {
												var xOffset = coords[this.id][0][0] - this.width/2 + me.leftOffset,
													yOffset = coords[this.id][0][1] - this.height/2 + me.topOffset;
												me.animationContext.drawImage(this, xOffset, yOffset);
												// #725663 reason as above
												if (me.defaultSelectedObjs.hasOwnProperty(this.id)) {
													me.highlightImageIcon(me.highlightContext, coords, this.id, 0);
												}
											}
										};
										model[propName].onerror = function() {
											model["imageIcon_" + this.id].src = notFoundImageIconPath;
										};
									}							
								} else { // TQMS: 690972
									delete coords[elem];
								}
							}
							
						}
						// take screenshot when the image icons is drawn over whthin RENDERING_TIME ms.
						if (!me.imageIconScreenshotTaken) {
							me.imageIconScreenshotTaken = true;
							//me.localTakeScreenshot(RENDERING_TIME);
						}					
					} else if (me.markerType === MARKER_BUBBLE) {
						for (elem in coords) {
							if (!coords.hasOwnProperty(elem)) {
								continue;
							}
							if (elem === "bgImage" 
								|| elem === (me.currHoverObj && me.currHoverObj.touchVal)
								|| elem === (me.currSelectedObj && me.currSelectedObj.touchVal)
								|| elem === (me.currLinkObj && me.currLinkObj.touchVal)
								|| (!isOwnEmpty(me.defaultSelectedObjs) && me.defaultSelectedObjs.hasOwnProperty(elem))) {
								continue;
							}
							var bubbleColor = defBubbleColor,
								bubbleRadius = defRadius,
								hdrIndex = me.getHeaderIndex(elem);
							if (hdrIndex >= 0) { // find threshold color(if any) and size
								if (me.sizeByIndex >= 0) {
									//var sizeByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.sizeByIndex];
									bubbleRadius = me.getRadiusFromName(elem);
								}
								if (me.colorByIndex >= 0 && me.thresholdType === THRESHOLD_COLOR) {
									bubbleColor = me.getBubbleColorFromName(elem);
									
									if (!bubbleColor) {
										bubbleColor = defBubbleColor;
									} else {
										bubbleColor = getOpacityColor(bubbleColor, BUBBLE_NORMAL_OPACITY);
									}
								}
								//bubbleColor = getOpacityColor(bubbleColor, 0.8);
								var offset = {x:me.leftOffset, y:me.topOffset};
								drawBubble(me.highlightContext, coords[elem][0], offset, bubbleColor, bubbleRadius);
								drawStroke(me.highlightContext, coords[elem][0], offset, strokeColor, bubbleRadius, me.bubbleStrokeWidth);
							} else { // not in document
								delete coords[elem];
							}						
						}
					}			   	

				},
				
				/*
				* store the original polygon coordinates in model
				*/
				getOriPolygonCoords: function getOriPolygonCoords() {
					var me = this,
						model = me.model,
						coords = model.coords,
						i,
						j,
						k,
						rgn,
						c;
					
					if (!model.hasOwnProperty("oriPolyCoords")) {
						model.oriPolyCoords = {};
						for (i in coords) {
							if (coords.hasOwnProperty(i)) {
								if (i === "bgImage") {
									continue;
								}
								var arr2 = [];
								rgn = coords[i];
								for (j in rgn) {
									if (rgn.hasOwnProperty(j)) {
										c = rgn[j];
										var arr1 = [];
										for (k=0; k<c.length; k++) {
											arr1.push(c[k]);
										}
										arr2.push(arr1);
									}								
								}
								model.oriPolyCoords[i] = arr2;
							}
						}
					}
				},
				
				// store the bubble color in the widget
				getAllBubblesColor: function getAllBubblesColor() {
					var me = this,
						model = me.model,
						coords = model.coords,
						elem;
					
					// do not do this for the second time
	 
					if (me.haveAllBubblesColor) {
						return;
					} else {
						//me.haveAllBubblesColor = true;
						// if ImageLayout is targeted by a "metric" selector, color should be changed according to data model
						// so comment this sentence.
						me.allBubblesColor = {};
					}
					
					var defBubbleColor = BUBBLE_COLOR_NO_COLORBY_DARK_THEME;
					if (model.themeMode === THEME_LIGHT) {
						defBubbleColor = BUBBLE_COLOR_NO_COLORBY_LIGHT_THEME;
					}
					
					if (me.markerType === MARKER_BUBBLE && me.colorByIndex >= 0 && me.thresholdType === THRESHOLD_COLOR) {
						for (elem in coords) {
							if (coords.hasOwnProperty(elem)) {
								if (elem === "bgImage") {
									continue;
								}
								var hdrIndex = me.getHeaderIndex(elem);
								if (hdrIndex >= 0) { // find threshold color(if any) and size
									var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex],
										bubbleColor = me.getBgColorFromCSS(colorByCellData);
									
									if (!bubbleColor) {
										bubbleColor = defBubbleColor;
									}
									me.allBubblesColor[elem] = bubbleColor;
								} else { // not in attribute element list
									//delete coords[elem];
								}
							}												
						}
					}
				},
				
				/*
				* calculate the maximum bubble radius and store in model
				* and store all the bubbles' radius in the model
				*/
				getOriBubbleSize: function getOriBubbleSize() {
					var me = this,
						model = me.model,
						gvs = model.gvs,
						idxs = model.ghs.rhs.items,
						gts_es = model.gts.row[0].es,
						elem,i,j,k,pt,
						maxRadius = 0;
					
					// TQMS 687541 is not correct, the original size of bubbles should be stored in the model, not the widget,
					// and is recalculated when model is changed
//					if (!me.model.hasOwnProperty("getOriBubbleSizeFlag")) {
//						me.model.getOriBubbleSizeFlag = true;
//					} else {
//						return;
//					}
					
					// get maxRadius
					var ratio = 1;
					if (model.vp.ty === "0") { // automatic size
						if (me.sizeByIndex < 0) {
							ratio = MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER;
						} else if (me.sizeByIndex >= 0) {
							ratio = MAX_SIZE_DEFAULT_RATIO_FOR_AUTOMATIC;
						}
					} else if (model.vp.ty === "1") { // manual size
						if (model.vp.hasOwnProperty("val") && model.vp.val!==null && model.vp.val!=="") {
							ratio = parseFloat(model.vp.val);
							if (ratio > MAX_RATIO_UP_LIMIT) { ratio = MAX_RATIO_UP_LIMIT; }
							if (ratio < MAX_RATIO_LOW_LIMIT) { ratio = MAX_RATIO_LOW_LIMIT; }
						} else {
							if (me.sizeByIndex < 0) {
								ratio = MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER;
							} else if (me.sizeByIndex >= 0) {
								ratio = MAX_SIZE_DEFAULT_RATIO_FOR_MANUAL;
							}
						}					
					} else { // model.vp does not have property "ty"
						if (me.sizeByIndex < 0) {
							ratio = MAX_SIZE_DEFAULT_RATIO_FOR_SCATTER*2;
						} else if (me.sizeByIndex >= 0) {
							ratio = MAX_SIZE_DEFAULT_RATIO_FOR_MANUAL*2;
						}
					}
					var maxMaxSize = me.baseMaxBubbleSizeAuto;
					if (me.sizeByIndex >= 0) { maxMaxSize = me.baseMaxBubbleSizeManual; }
									
					var baseSize = 0.15*Math.min(me.getWidth(), me.getHeight());
					if (model.vp.ty === "0") {
						maxRadius = Math.min(ratio*baseSize, maxMaxSize);
					} else if (model.vp.ty === "1") {
						maxRadius = ratio * baseSize;
					} else { // // model.vp doesnot have property "ty"
						maxRadius = ratio * baseSize;
					}
					
					if (maxRadius <= 2) { maxRadius = 3; }
					me.model.maxBubbleRadius = maxRadius;
					
					// store oriBubbleSize in model
					if (me.sizeByIndex >= 0) {
						var idx = me.sizeByIndex,
							maxValue = Math.abs(parseFloat(gvs.items[0].items[idx].rv)),
							minValue = Math.abs(parseFloat(gvs.items[0].items[idx].rv));
						for (i in gts_es) {
							if (gts_es.hasOwnProperty(i)) {
								var gvsIndex = me.getIndexFromHdrindex(i),
									tempVal = Math.abs(parseFloat(gvs.items[gvsIndex].items[idx].rv));
								if (maxValue < tempVal) {
									maxValue = tempVal;
								}
								if (minValue > tempVal) {
									minValue = tempVal;
								}
							}						
						}
						
						var oriBubbleSize = {};
						if (maxValue > minValue) { // modified for TQMS 697281
							var minRadius = maxRadius * minValue / maxValue;
							if (minRadius < 2) { minRadius = 2; }
							var step = (maxRadius - minRadius) / (maxValue - minValue),
								radius;
							for (i in gts_es) {
								if (gts_es.hasOwnProperty(i)) {
									radius = (Math.abs(parseFloat(gvs.items[me.getIndexFromHdrindex(i)].items[idx].rv))-minValue) * step + minRadius;
									oriBubbleSize[gts_es[i].n] = radius;
								}							
							}

						} else {
							for (i=0; i<gts_es.length; i++) {
								oriBubbleSize[gts_es[i].n] = maxRadius;
							}
						}
						
						// TQMS 687541 is not correct, the original size of bubbles should be stored in the model, not the widget,
						// and is recalculated when model is changed
						me.model.oriBubbleSize = oriBubbleSize;
						
					}
					
				},
				
				/**
				* Store the original bubble position.
				*/
				// store original bubble position
				storeOriPoints: function storeOriPoints() {
					var coords = this.model.coords,
						oriCoords = {},
						point,
						newPoint,
						elem;
					for(elem in coords) {
						if (coords.hasOwnProperty(elem)) {
							point = coords[elem][0];
							newPoint = [point[0], point[1]];
							oriCoords[elem] = newPoint;
						}
					}
					return oriCoords;
				},
				
				/*
				* when the widget is in bubble mode
				*/
				drawBubbleMap: function drawBubbleMap() {
					var me = this,
						model = me.model,
						context = this.animationContext,
						coords = model.coords,
						elem,i,j,k,pt;
					
					// get bubble original radius
//					if (!me.model.hasOwnProperty("oriBubbleSize")) {
//						me.getOriBubbleSize();
//					}
					
					// store bubble color in the widget
					me.getAllBubblesColor();
					
					me.getOriBubbleSize();

					// background image
					if (model.hasOwnProperty("bgImg") && model.bgImg.hasOwnProperty("src") && model.bgImg.src!="" && model.bgImg.src!=null) {
						me.drawBgImageFlag = true;
						if (!me.hasOwnProperty("oriBgImageWidth")) { me.oriBgImageWidth = model.bgImg.width; }
						if (!me.hasOwnProperty("oriBgImageHeight")) { me.oriBgImageHeight = model.bgImg.height; }
						if (!me.hasOwnProperty("oriCoords")) { me.oriCoords = me.storeOriPoints(); }
						
						var xRatio = model.bgImg.width / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
							yRatio = model.bgImg.height / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), // add some padding
							ratio = Math.max(yRatio, xRatio); 
						
						me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
						me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
						
						context.drawImage(model.bgImg, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
						
						if (me.shapeFileType === SHAPE_FILE_POLYGON) {
						// get polygon centers
							var polygonCenters = {};
							for (i in coords) {
								if (coords.hasOwnProperty(i)) {
									if (i === "bgImage") {
										continue;
									}
									var center = getCentroidOfPolygon(coords[i][0]);
									polygonCenters[i] = center;
									polygonCenters[i][0][0] /= ratio;
									polygonCenters[i][0][1] /= ratio;
								}
							}
							model.polygonCenters = polygonCenters;
						} else {
							//if ((xRatio > 1 || yRatio > 1 || xRatio < 0.8 || yRatio < 0.8)) { //scale
								var oriCoords = me.oriCoords;
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										pt = coords[i][0];
										pt[0] = parseInt(oriCoords[i][0] / ratio, 10);
										pt[1] = parseInt(oriCoords[i][1] / ratio, 10);
									}
								}
							//}
						}

						me.drawBubblesInMap();
					} else {
						model.bgImg = new Image();

						model.bgImg.onerror = function() {
							var errorMessage = "The backgrond Image cannot be found.";
							me.renderErrorMessage(mstrmojo.desc(9856, errorMessage));
							return;
						};

						model.bgImg.onload = function() {
							
							me.drawBgImageFlag = true;
							if (!me.hasOwnProperty("oriBgImageWidth")) { me.oriBgImageWidth = this.width; }
							if (!me.hasOwnProperty("oriBgImageHeight")) { me.oriBgImageHeight = this.height; }
							if (!me.hasOwnProperty("oriCoords")) { me.oriCoords = me.storeOriPoints(); }
							
							var xRatio = this.width / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
								yRatio = this.height / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), // add some padding
								ratio = Math.max(yRatio, xRatio); 
							
							me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
							me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
							
							me.animationCanvas.width = me.animationCanvas.width;
							context.drawImage(this, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
							
							if (me.shapeFileType === SHAPE_FILE_POLYGON) {
								// get polygon centers
								var polygonCenters = {};
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										var center = getCentroidOfPolygon(coords[i][0]);
										polygonCenters[i] = center;
										polygonCenters[i][0][0] /= ratio;
										polygonCenters[i][0][1] /= ratio;
									}									
								}
								model.polygonCenters = polygonCenters;
							} else {
								//if ((xRatio > 1 || yRatio > 1 || xRatio < 0.8 || yRatio < 0.8)) { //scale
									var oriCoords = me.oriCoords;
									for (i in coords) {
										if (coords.hasOwnProperty(i)) {
											if (i === "bgImage") {
												continue;
											}
											pt = coords[i][0];
											pt[0] = parseInt(oriCoords[i][0] / ratio, 10);
											pt[1] = parseInt(oriCoords[i][1] / ratio, 10);
										}
									}
								//}
							}
								
							me.drawBubblesInMap();
//							}
							if (!me.bgImageScreenshotTaken) {
								me.bgImageScreenshotTaken = true;
								me.localTakeScreenshot(RENDERING_TIME);
							}						
						};//image onload	
					}
					
					if (coords.hasOwnProperty("bgImage") && coords.bgImage!=="") {
						if (!model.hasOwnProperty("bgImg") || !model.bgImg.hasOwnProperty("src") || model.bgImg.src=="" || model.bgImg.src==null) {
							var bgImgPath = coords.bgImage;
							model.bgImg.src = me.getFullPath(bgImgPath);
							
							//console.log('\nbgImg src: ' + model.bgImg.src);
						}					
					} else if (me.shapeFileType === SHAPE_FILE_POLYGON) { // no bgImage
						me.drawBgImageFlag = false;
						me.scalePolygonCoords();
						me.drawPolygonInMap(POLY_UNDER_BUBBLE_OPACITY);
						
						// get polygon centers
						var polygonCenters = {};
						for (i in coords) {
							if (coords.hasOwnProperty(i)) {
								if (i === "bgImage") {
									continue;
								}
								var center = getCentroidOfPolygon(coords[i][0]);
								polygonCenters[i] = center;
							}						
						}
						model.polygonCenters = polygonCenters;
						
						me.drawBubblesInMap();
					}
					
					// all the draw work mush be put in the onload function, because they need the bgImage width and height to scale the coords

				},

				/**
				* when the widget is in area mode
				*/
				drawAreaMap: function drawAreaMap() {
					var me = this,
						model = me.model,
						context = this.animationContext,
						coords = model.coords,
						elem,i,j,k,rgn,oriRng,c,oriC,pt;
					
					if (!model.hasOwnProperty("oriPolyCoords")) {
						me.getOriPolygonCoords();
					}
					
					var oriCoords = model.oriPolyCoords;
					
					context.save();
					context.lineWidth = 2;
					context.strokeStyle = '#AAAAAA';
					
					/*
					* this code is to ensure the drawAreaMap function can be called more than once
					* this is necessary in some situations, for example, at the end of zooming gesture
					*/
					if (model.hasOwnProperty("bgImg") && model.bgImg.hasOwnProperty("src") && model.bgImg.src!="" && model.bgImg.src!=null) {
						if (me.shapeFileType === SHAPE_FILE_POINT) { // draw polygon
								me.drawBgImageFlag = false;
							} else if (me.shapeFileType === SHAPE_FILE_POLYGON) { // draw background image
								me.drawBgImageFlag = true;
								
								if (!me.hasOwnProperty("oriBgImageWidth")) { me.oriBgImageWidth = model.bgImg.width; }
								if (!me.hasOwnProperty("oriBgImageHeight")) { me.oriBgImageHeight = model.bgImg.height; }
								
								var xRatio = model.bgImg.width / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
									yRatio = model.bgImg.height / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), // add some padding
									ratio = Math.max(yRatio, xRatio);
								
								me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
								me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
								
								context.drawImage(model.bgImg, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
								
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										rgn = coords[i];
										oriRgn = oriCoords[i];
										for (j in rgn) {
											if (rgn.hasOwnProperty(j)) {
												c = rgn[j];
												oriC = oriRgn[j];
												for (k=0; k<c.length; k++) {
													c[k] = parseInt(oriC[k]/ratio, 10);
												}
											}										
										}
									}								
								}
								
								// get polygon centers for 45*45 rule
								var polygonCenters = {};
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										var center = getCentroidOfPolygon(coords[i][0]);
										polygonCenters[i] = center;
									}								
								}
								model.polygonCenters = polygonCenters;
							
								me.drawPolygonInMap(POLY_ABOVE_BG_OPACITY);
							}
					} else {
						model.bgImg = new Image();
						
						model.bgImg.onerror = function() {
							var errorMessage = "The backgrond Image cannot be found.";
							me.renderErrorMessage(mstrmojo.desc(9856, errorMessage));
							return;
						};
						
						model.bgImg.onload = function() {
							if (me.shapeFileType === SHAPE_FILE_POINT) { // draw polygon
								me.drawBgImageFlag = false;
							} else if (me.shapeFileType === SHAPE_FILE_POLYGON) { // draw background image
								me.drawBgImageFlag = true;
								
								if (!me.hasOwnProperty("oriBgImageWidth")) { me.oriBgImageWidth = this.width; }
								if (!me.hasOwnProperty("oriBgImageHeight")) { me.oriBgImageHeight = this.height; }
								
								var xRatio = this.width / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
									yRatio = this.height / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), // add some padding
									ratio = Math.max(yRatio, xRatio);
								
								me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
								me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
								
								context.drawImage(this, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
								
								// scale coordinats of model.coords
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										rgn = coords[i];
										oriRgn = oriCoords[i];
										for (j in rgn) {
											if (rgn.hasOwnProperty(j)) {
												c = rgn[j];
												oriC = oriRgn[j];
												for (k=0; k<c.length; k++) {
													c[k] = parseInt(oriC[k]/ratio, 10);
												}
											}
										}
									}
								}
								
								// get polygon centers for 45*45 rule
								var polygonCenters = {};
								for (i in coords) {
									if (coords.hasOwnProperty(i)) {
										if (i === "bgImage") {
											continue;
										}
										var center = getCentroidOfPolygon(coords[i][0]);
										polygonCenters[i] = center;
									}								
								}
								model.polygonCenters = polygonCenters;
								
								me.drawPolygonInMap(POLY_ABOVE_BG_OPACITY);
							}
							if (!me.bgImageScreenshotTaken) {
								me.bgImageScreenshotTaken = true;
								me.localTakeScreenshot(RENDERING_TIME);
							}						
						}; //image onload	
					}
					
					
					if (coords.hasOwnProperty("bgImage") && coords.bgImage!=="") {
						if (!model.bgImg.hasOwnProperty("src") || model.bgImg.src=="" || model.bgImg.src==null) {
							model.bgImg.src = me.getFullPath(coords.bgImage);
						}					
					} else if (me.shapeFileType === SHAPE_FILE_POLYGON) {
						me.drawBgImageFlag = false;
						
						this.scalePolygonCoords();
						
						// get polygon centers
						var polygonCenters = {};
						for (i in coords) {
							if (coords.hasOwnProperty(i)) {
								if (i === "bgImage") {
									continue;
								}
								var center = getCentroidOfPolygon(coords[i][0]);
								polygonCenters[i] = center;
							}						
						}
						model.polygonCenters = polygonCenters;
						
						// get polygon centers
						// TQMS: 687074, No need to draw image in Area mode, so comment for fixing this issue.
//						if (me.markerType === MARKER_IMAGE) {
//							var polygonCenters = new Object;
//							for (i in coords) {
//								if (i === "bgImage") {
//									continue;
//								}
//								var center = getCentroidOfPolygon(coords[i][0]);
//								polygonCenters[i] = center;
//							}
//							model.polygonCenters = polygonCenters;
//						}					
						
						this.drawPolygonInMap(POLY_NORMAL_OPACITY);

					}
					
					context.restore();
				},

				/*
				* get the index of the attribute according to its name
				* the attribute must be the first attribute on the left on the rows
				*/
				getHeaderIndex: function getHeaderIndex(headerName) {
					var hdrIndex = -1,
						hdrs = this.model.gts.row[0].es,
						i;

					if (headerName) {
						headerName = headerName.toLowerCase();
						for (i = 0; i < hdrs.length; i++) {
							var name = hdrs[i].n;
							if (name && name.toLowerCase() === headerName) {
								hdrIndex = i;
								break;
							}
						}
					}

					return hdrIndex;
				},
				
				/*
				* in order to change the opacity of canvas A, we only need to draw a canvas B above it
				* we need to decide the color of canvas B (color of background or color of canvas A)
				* and also need to know the opacity of canvas B
				*/
				getNewColorForOpacityChange: function getNewColorForOpacityChange(bgColor, haveBgImage, curColor, curOpacity, destOpacity) {
					if (curOpacity>1 || curOpacity<0 || destOpacity>1 || destOpacity<0) {
						return curColor;
					}
					
					var eps = 0.0001,
						newBgColor = bgColor;
					if (!bgColor || haveBgImage) { newBgColor = "#FFFFFF"; }				
					
					if (destOpacity >= curOpacity) {
						if (curOpacity + eps > 1) {
							return curColor;
						} else {
							return getOpacityColor(curColor, (destOpacity-curOpacity)/(1-curOpacity));
						}
					} else if (destOpacity < curOpacity) {
						if (curOpacity - eps < 0) {
							return getOpacityColor(curColor, 0);
						} else {
							return getOpacityColor(newBgColor, (curOpacity-destOpacity)/curOpacity);
						}
					}
				},
				
				/*
				* draw part of an image (coordsArray) in canvas context (ctx) with opacity (bgOpacity)
				*/
				drawPartOpacityBG: function drawPartOpacityBG(ctx, coordsArray, bgOpacity) {
					ctx.save();
				
					var me = this,
						model = me.model,
						offsetX = me.leftOffset ? me.leftOffset : 0,
						offsetY = me.topOffset ? me.topOffset : 0;
					
					var getPointAt = function(j){
						var offset = j%2  ? offsetY : offsetX;
						return pointsArray[j] + offset;
					};
					
					ctx.beginPath();
					
					var i,
						j;
					for (i = 0; i < coordsArray.length; i++) {
						var pointsArray = coordsArray[i],
							minX = getPointAt(0),
							minY = getPointAt(1),
							maxY = getPointAt(1),
							x,
							y;
		
						//ctx.beginPath();
						ctx.moveTo(getPointAt(0), getPointAt(1));
		
						for (j = 2; j < pointsArray.length - 1; j = j + 2) {
							x = getPointAt(j);
							y = getPointAt(j + 1);
		
							ctx.lineTo(x, y);
		
							// init min/max values
							maxY = Math.max(y, maxY);
							minY = Math.min(y, minY);
							minX = Math.min(x, minX);
						}
						
						// close the path
						x = getPointAt(0);
						y = getPointAt(1);
						ctx.lineTo(x, y);
					}
					
					ctx.clip();
					
					// draw background image with opacity
					ctx.globalAlpha = bgOpacity;
					
					var xRatio = me.oriBgImageWidth / ((me.getWidth()-me.borderSpace*2)*me.scaleFactor),
						yRatio = me.oriBgImageHeight / ((me.getHeight()-me.borderSpace*2)*me.scaleFactor), // add some padding
						ratio = Math.max(yRatio, xRatio);
					
					me.topOffset = (me.getHeight()*me.scaleFactor - me.oriBgImageHeight/ratio) / 2 ;
					me.leftOffset = (me.getWidth()*me.scaleFactor - me.oriBgImageWidth/ratio) / 2 ;
					
					ctx.drawImage(model.bgImg, me.leftOffset, me.topOffset, me.oriBgImageWidth/ratio, me.oriBgImageHeight/ratio);
					
					
					ctx.restore();
				},
				
				/**
				* highlight one selected image icon for (default) selection
				*/
				highlightImageIcon: function highlightImageIcon(hlContext, coords, touchVal, radiusLarget) {
					var me = this,
						model = me.model,
						fillColor = "RGBA(255,255,255,0.5)",
						iconName = "imageIcon_" + touchVal;
					
					if (model.hasOwnProperty(iconName)) {								
						var imgIcon = model[iconName],
							width = imgIcon.width + radiusLarget*2,
							height = imgIcon.height + radiusLarget*2,
							xOffset = coords[touchVal][0][0] - width/2 + me.leftOffset,
							yOffset = coords[touchVal][0][1] - height/2 + me.topOffset;
						
						// draw the rectangle area
						hlContext.fillStyle = fillColor;
						hlContext.fillRect(xOffset, yOffset, width, height);
						
						// draw the rectangle boundary
						//hlContext.strokeStyle = highlightStrokeColor;
						drawWhiteRectCorner(hlContext, xOffset, yOffset, width, height);
						
					}
				},

				/**
				* Called to highlight a single data point. Implemetation left empty for Map Widgets.
				* @param {Integer} [x] the x axis point to highlight
				*/
				highlightPoint: function highlightPoint() {
					var me = this,
						model = me.model,
						hlContext = me.highlightContext,
						hdrIndex; 
					//var hCanvas = me.highlightCanvas;
					//hlContext.clearRect(0, 0, hCanvas.width, hCanvas.height);
					me.highlightCanvas.width = me.highlightCanvas.width;
					
					// if select is canceled, then change back the opacity of the unselected area
					if (me.currSelectedObj===null && isOwnEmpty(me.defaultSelectedObjs) && me.displayMode===DISPLAY_MODE_AREA) {
						if (me.drawBgImageFlag) {
							if (me.curPolygonOpacity !== POLY_ABOVE_BG_OPACITY) {
									me.drawPolygonInMap(POLY_ABOVE_BG_OPACITY);
							}
						} else {
							if (me.curPolygonOpacity !== POLY_NORMAL_OPACITY) {
								me.drawPolygonInMap(POLY_NORMAL_OPACITY);
							}
						}
					}

					if (me.displayMode === DISPLAY_MODE_AREA) {
						// re-render polygon with white border and half transparency
						var bgColor = model.bgColor,
							selectedStrokeColor = POLY_STROKE_COLOR_SELECTED_DARK_THEME,
							hoverStrokeColor = POLY_STROKE_COLOR_HOVER_DARK_THEME,
							selectedHoverStrokeColor = POLY_STROKE_COLOR_SELECTED_HOVER_DARK_THEME,
							noAltColor = POLY_COLOR_NO_ALT_DARK_THEME,
							noColorByColor = POLY_COLOR_NO_COLORBY_DARK_THEME;
						if (model.themeMode === THEME_LIGHT) {
							selectedStrokeColor = POLY_STROKE_COLOR_SELECTED_LIGHT_THEME;
							hoverStrokeColor = POLY_STROKE_COLOR_HOVER_LIGHT_THEME;
							selectedHoverStrokeColor = POLY_STROKE_COLOR_SELECTED_HOVER_LIGHT_THEME;
							noAltColor = POLY_COLOR_NO_ALT_LIGHT_THEME;
							noColorByColor = POLY_COLOR_NO_COLORBY_LIGHT_THEME;
						}
						if (model.vp && model.vp.npc) {
							noAltColor = getOpacityColor("#"+model.vp.npc, POLY_NORMAL_OPACITY);
						}
						
						var fillColor = noAltColor;
						
						// hightlight default selected objects in area mode
						var dftSltObjs = me.defaultSelectedObjs;
						if (!isOwnEmpty(dftSltObjs)) {
							if (me.curPolygonOpacity !== POLY_UNSELECTED_OPACITY) {
								me.drawPolygonInMap(POLY_UNSELECTED_OPACITY);
							}	
							
							var i;
							for (i in dftSltObjs) {
								if (dftSltObjs.hasOwnProperty(i)) {
									if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null
											&& me.currHoverObj.touchVal===i) {
										continue;
									} else {
										var hIndex = me.defaultSelectedObjs[i]; 
										if (hIndex >= 0) {
											if (me.colorByIndex>=0) {
												if (me.thresholdType === THRESHOLD_COLOR) {
													var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hIndex)].items[me.colorByIndex];
													fillColor = me.getBgColorFromCSS(colorByCellData);
													if (!fillColor) {
														fillColor = noColorByColor;
													}
												} else {
													fillColor = noColorByColor;
												}								
											} else {
												fillColor = noColorByColor;
											}
																		
										} else {
											fillColor = noAltColor;
										}
										
										if (me.drawBgImageFlag) {
											fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_OPACITY_WITH_BG);
										} else {
											fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_OPACITY_WITHOUT_BG);
										}
										
										drawPoly(hlContext, model.coords[i], {x:me.leftOffset, y:me.topOffset}, selectedStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
									}
								}						
							}
							
							fillColor = noAltColor;
						} else if (me.currSelectedObj!==null && me.currSelectedObj.hasOwnProperty("touchVal") && me.currSelectedObj.touchVal!=="" && me.currSelectedObj.touchVal!==null) {
							if (me.curPolygonOpacity !== POLY_UNSELECTED_OPACITY) {
								me.drawPolygonInMap(POLY_UNSELECTED_OPACITY);
							}						
							
							if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null
									&& me.currHoverObj.touchVal===me.currSelectedObj.touchVal) {
								// Do not draw this area, because it will be highlighted as a hover area
							} else {
								if (me.currSelectedObj.hasOwnProperty("hdrIndex")) {
									hdrIndex = me.currSelectedObj.hdrIndex;
								} else {
									hdrIndex = me.getHeaderIndex(me.currSelectedObj.touchVal);
								}
								if (hdrIndex>=0) {
									if (me.colorByIndex>=0) {
										if (me.thresholdType === THRESHOLD_COLOR) {
											var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
											fillColor = me.getBgColorFromCSS(colorByCellData);
											if (!fillColor) {
												fillColor = noColorByColor;
											}
										} else {
											fillColor = noColorByColor;
										}								
									} else {
										fillColor = noColorByColor;
									}
																
								} else {
									fillColor = noAltColor;
								}
								
								if (me.drawBgImageFlag) {
									fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_OPACITY_WITH_BG);
								} else {
									fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_OPACITY_WITHOUT_BG);
								}
								
								drawPoly(hlContext, model.coords[me.currSelectedObj.touchVal], {x:me.leftOffset, y:me.topOffset}, selectedStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
							}
						} else if (me.currLinkObj!==null && me.currLinkObj.hasOwnProperty("touchVal") && me.currLinkObj.touchVal!=="" && me.currLinkObj.touchVal!==null) {
							if (me.currLinkObj.hasOwnProperty("hdrIndex")) {
									hdrIndex = me.currLinkObj.hdrIndex;
								} else {
									hdrIndex = me.getHeaderIndex(me.currLinkObj.touchVal);
								}
								if (hdrIndex>=0) {
									if (me.colorByIndex>=0) {
										if (me.thresholdType === THRESHOLD_COLOR) {
											var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
											fillColor = me.getBgColorFromCSS(colorByCellData);
											if (!fillColor) {
												fillColor = noColorByColor;
											}
										} else {
											fillColor = noColorByColor;
										}
									} else {
										fillColor = noColorByColor;
									}
																
								} else {
									fillColor = noAltColor;
								}
								
								if (me.drawBgImageFlag) {
									fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_ABOVE_BG_OPACITY, POLY_LINKDRILL_OPACITY);
								} else {
									fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_NORMAL_OPACITY, POLY_LINKDRILL_OPACITY);
								}						
								
								drawPoly(hlContext, model.coords[me.currLinkObj.touchVal], {x:me.leftOffset, y:me.topOffset}, hoverStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
						}
						if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null) {
								var hvObj = me.currHoverObj;
								
								if (hvObj.hasOwnProperty("hdrIndex")) {
									hdrIndex = hvObj.hdrIndex;
								} else {
									hdrIndex = me.getHeaderIndex(hvObj.touchVal);
								}
								
								if (hdrIndex>=0) {
									if (me.colorByIndex>=0) {
										if (me.thresholdType === THRESHOLD_COLOR) {
											var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
											fillColor = me.getBgColorFromCSS(colorByCellData);
											if (!fillColor) {
												fillColor = noColorByColor;
											}
										} else {
											fillColor = noColorByColor;
										}
									} else {
										fillColor = noColorByColor;
									}						
								} else {
									fillColor = noAltColor;
								}
								
								
								if (me.currSelectedObj!==null || !isOwnEmpty(me.defaultSelectedObjs)) { // with selected object
		//							if (sltObj.hasOwnProperty("touchVal") && sltObj.touchVal === hvObj.touchVal) { // get rid of the selected stroke color
		//								hlContext.clearRect(0, 0, hCanvas.width, hCanvas.height); // 
		//							}
									
									if (me.drawBgImageFlag) {
										fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_HOVER_OPACITY_WITH_BG);
									} else {
										fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_UNSELECTED_OPACITY, POLY_SELECTED_HOVER_OPACITY_WITHOUT_BG);
									}

									drawPoly(hlContext, model.coords[me.currHoverObj.touchVal], {x:me.leftOffset, y:me.topOffset}, selectedHoverStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
								} else { // without selected object
									
									if (me.drawBgImageFlag) {
										// draw background image with opacity
										var bgOpacity = (POLY_ABOVE_BG_OPACITY - POLY_HOVER_OPACITY) / POLY_ABOVE_BG_OPACITY;
										this.drawPartOpacityBG(hlContext, model.coords[me.currHoverObj.touchVal], bgOpacity);
										// draw polygon stroke
										fillColor = "RGBA(0,0,0,0)";
										drawPoly(hlContext, model.coords[me.currHoverObj.touchVal], {x:me.leftOffset, y:me.topOffset}, hoverStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
									} else {
										fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, POLY_NORMAL_OPACITY, POLY_HOVER_OPACITY);
										drawPoly(hlContext, model.coords[me.currHoverObj.touchVal], {x:me.leftOffset, y:me.topOffset}, hoverStrokeColor, me.highlightPolygonStrokeWidth, fillColor);
									}
									
									
								}						
								
								//render the tooltip
								if (me.newRenderFlag) {
									// reposition tooltip when the device is retated
									me.newRenderFlag = false;
									var polygonCenter = me.model.polygonCenters && me.model.polygonCenters[me.currHoverObj.touchVal] && me.model.polygonCenters[me.currHoverObj.touchVal][0];
									if (polygonCenter) {
										var xOnWidget = polygonCenter[0] + me.leftOffset - me._scroller.origin.x;
										var yOnWidget = polygonCenter[1] + me.topOffset - me._scroller.origin.y;
										me.renderTooltip(this.currHoverObj.touchVal, xOnWidget, yOnWidget, this.currHoverObj.hdrIndex);
									}
								} else {
									me.renderTooltip(this.currHoverObj.touchVal, this.currHoverObj.point.x, this.currHoverObj.point.y, this.currHoverObj.hdrIndex);
								}
								
								

											
						}
					} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
						var selectedStrokeColor = BUBBLE_STROKE_COLOR_SELECTED_DARK_THEME,
							hoverStrokeColor = BUBBLE_STROKE_COLOR_HOVER_DARK_THEME,
							linkdrillStrokColor = BUBBLE_STROKE_COLOR_LINKDRILL_DARK_THEME,
							highlightStrokeColor = BUBBLE_HIGHLIGHT_STROKE_COLOR_DARK_THEME,
							noColorByColor = BUBBLE_COLOR_NO_COLORBY_DARK_THEME;
						if (model.themeMode === THEME_LIGHT) {
							selectedStrokeColor = BUBBLE_STROKE_COLOR_SELECTED_LIGHT_THEME;
							hoverStrokeColor = BUBBLE_STROKE_COLOR_HOVER_LIGHT_THEME;
							linkdrillStrokColor = BUBBLE_STROKE_COLOR_LINKDRILL_LIGHT_THEME;
							highlightStrokeColor = BUBBLE_HIGHLIGHT_STROKE_COLOR_LIGHT_THEME;
							noColorByColor = BUBBLE_COLOR_NO_COLORBY_LIGHT_THEME;
						}
						if (me.markerType === MARKER_BUBBLE) {
							me.drawBubblesInMap();
							
							// highlight default selected bubble(s)
							var dftSltObjs = me.defaultSelectedObjs;
							if (!isOwnEmpty(dftSltObjs)) {
								var i;
								for (i in dftSltObjs) {
									if (dftSltObjs.hasOwnProperty(i)) {
										var sltBubbleRadius = me.getRadiusFromName(i);
										fillColor = me.getBubbleColorFromName(i);
										if (!fillColor) {
											continue;
										}
										
		//								var hIndex = dftSltObjs[i];
		//								if (hIndex >= 0) {
		//									if (me.colorByIndex>=0) {
		//										if (me.thresholdType === THRESHOLD_COLOR) {
		//											var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hIndex)].items[me.colorByIndex];
		//											fillColor = me.getBgColorFromCSS(colorByCellData);
		//											if (!fillColor) {
		//												fillColor = noColorByColor;
		//											}
		//										} else {
		//											fillColor = noColorByColor;
		//										}
		//									} else {
		//										fillColor = noColorByColor;
		//									}
		//								} else {
		//									fillColor = noColorByColor;
		//								}
										
										//fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, BUBBLE_NORMAL_OPACITY, BUBBLE_SELECTED_OPACITY);
										fillColor = getOpacityColor(fillColor, BUBBLE_SELECTED_OPACITY);
										
										// get the selected bubble position
										if (me.shapeFileType === SHAPE_FILE_POLYGON) {
											if (model.hasOwnProperty("polygonCenters")) {
												sltCoord = model.polygonCenters[i][0];
											}
										} else if (me.shapeFileType === SHAPE_FILE_POINT) {
											sltCoord = model.coords[i][0];
										}
										
										drawBubble(hlContext, sltCoord, {x:me.leftOffset,y:me.topOffset}, fillColor, sltBubbleRadius);
										drawStroke(hlContext, sltCoord, {x:me.leftOffset,y:me.topOffset}, selectedStrokeColor, sltBubbleRadius, me.bubbleStrokeWidth);
									}								
								}
								
								fillColor = noAltColor;
							} else if (me.currSelectedObj!==null && me.currSelectedObj.hasOwnProperty("touchVal") && me.currSelectedObj.touchVal!=="" && me.currSelectedObj.touchVal!==null) {
								var fillColor = noColorByColor,
									sltCoord,
									sltBubbleRadius;
								
								// get the selected bubble radius
								sltBubbleRadius = me.getRadiusFromName(me.currSelectedObj.touchVal);
								
								// get the selected bubble color
								fillColor = me.getBubbleColorFromName(me.currSelectedObj.touchVal);
								if (!fillColor) {
									fillColor = noColorByColor;
								}
//								if (me.currSelectedObj.hasOwnProperty("hdrIndex")) {
//									hdrIndex = me.currSelectedObj.hdrIndex;
//								} else {
//									hdrIndex = me.getHeaderIndex(me.currSelectedObj.touchVal);
//								}
//								if (hdrIndex>=0) {
//									if (me.colorByIndex>=0) {
//										if (me.thresholdType === THRESHOLD_COLOR) {
//											var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
//											fillColor = me.getBgColorFromCSS(colorByCellData);
//											if (!fillColor) {
//												fillColor = noColorByColor;
//											}
//										} else {
//											fillColor = noColorByColor;
//										}
//									} else {
//										fillColor = noColorByColor;
//									}
//								} else {
//									fillColor = noColorByColor;
//								}
								
								// fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, BUBBLE_NORMAL_OPACITY, BUBBLE_SELECTED_OPACITY);
								fillColor = getOpacityColor(fillColor, BUBBLE_SELECTED_OPACITY);
								
								// get the selected bubble position
								if (me.shapeFileType === SHAPE_FILE_POLYGON) {
									if (model.hasOwnProperty("polygonCenters")) {
										sltCoord = model.polygonCenters[me.currSelectedObj.touchVal][0];
									}
								} else if (me.shapeFileType === SHAPE_FILE_POINT) {
									sltCoord = model.coords[me.currSelectedObj.touchVal][0];
								}
								
								drawBubble(hlContext, sltCoord, {x:me.leftOffset,y:me.topOffset}, fillColor, sltBubbleRadius);
								drawStroke(hlContext, sltCoord, {x:me.leftOffset,y:me.topOffset}, selectedStrokeColor, sltBubbleRadius, me.bubbleStrokeWidth);
							} else if (me.currLinkObj!==null && me.currLinkObj.hasOwnProperty("touchVal") && me.currLinkObj.touchVal!=="" && me.currLinkObj.touchVal!==null) {
								var linkCoord,
									linkBubbleRadius;
								
								// get the linkdrill bubble radius
								linkBubbleRadius = me.getRadiusFromName(me.currLinkObj.touchVal);
								
								// get the linkdrill bubble color
								fillColor = me.getBubbleColorFromName(me.currLinkObj.touchVal);
								if (!fillColor) {
									fillColor = noColorByColor;
								}
								
//								if (me.currLinkObj.hasOwnProperty("hdrIndex")) {
//									hdrIndex = me.currLinkObj.hdrIndex;
//								} else {
//									hdrIndex = me.getHeaderIndex(me.currLinkObj.touchVal);
//								}
//								if (hdrIndex>=0) {
//									if (me.colorByIndex>=0) {
//										if (me.thresholdType === THRESHOLD_COLOR) {
//											var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
//											fillColor = me.getBgColorFromCSS(colorByCellData);
//											if (!fillColor) {
//												fillColor = noColorByColor;
//											}
//										} else {
//											fillColor = noColorByColor;
//										}
//									} else {
//										fillColor = noColorByColor;
//									}
//								} else {
//									fillColor = noColorByColor;
//								}

								// fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, BUBBLE_NORMAL_OPACITY, BUBBLE_LINKDRILL_OPACITY);
								fillColor = getOpacityColor(fillColor, BUBBLE_LINKDRILL_OPACITY);
								
								// get the hover bubble position
								if (me.shapeFileType === SHAPE_FILE_POLYGON) {
									if (model.hasOwnProperty("polygonCenters")) {
										linkCoord = model.polygonCenters[me.currLinkObj.touchVal][0];
									}
								} else if (me.shapeFileType === SHAPE_FILE_POINT) {
									linkCoord = model.coords[me.currLinkObj.touchVal][0];
								}
								
								drawBubble(hlContext, linkCoord, {x:me.leftOffset,y:me.topOffset}, fillColor, linkBubbleRadius);
								drawStroke(hlContext, linkCoord, {x:me.leftOffset,y:me.topOffset}, linkdrillStrokColor, linkBubbleRadius, me.bubbleStrokeWidth);
								drawStroke(hlContext, linkCoord, {x:me.leftOffset,y:me.topOffset}, highlightStrokeColor, linkBubbleRadius+me.hoverBubbleRadiusLarger, me.bubbleStrokeWidth);
							}
							if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null) {
								var hoverCoord, 
									hoverBubbleRadius,
									hoverTouchVal = me.currHoverObj.touchVal;
								
								// get the hover bubble radius
								hoverBubbleRadius = me.getRadiusFromName(hoverTouchVal);
								
								// get the hover bubble color
								fillColor = me.getBubbleColorFromName(hoverTouchVal);
								if (!fillColor) {
									fillColor = noColorByColor;
								}
								
//								if (me.currHoverObj.hasOwnProperty("hdrIndex")) {
//									hdrIndex = me.currHoverObj.hdrIndex;
//								} else {
//									hdrIndex = me.getHeaderIndex(me.currHoverObj.touchVal);
//								}
//								if (hdrIndex>=0) {
//									if (me.colorByIndex>=0) {
//										if (me.thresholdType === THRESHOLD_COLOR) {
//											var colorByCellData = model.gvs.items[me.getIndexFromHdrindex(hdrIndex)].items[me.colorByIndex];
//											fillColor = me.getBgColorFromCSS(colorByCellData);
//											if (!fillColor) {
//												fillColor = noColorByColor;
//											}
//										} else {
//											fillColor = noColorByColor;
//										}
//									} else {
//										fillColor = noColorByColor;
//									}
//								} else {
//									fillColor = noColorByColor;
//								}

								// fillColor = this.getNewColorForOpacityChange(bgColor, me.drawBgImageFlag, fillColor, BUBBLE_NORMAL_OPACITY, BUBBLE_HOVER_OPACITY);
								var nodeStrokeColor = hoverStrokeColor;
								if ((me.currSelectedObj && me.currSelectedObj.touchVal===hoverTouchVal) 
										|| (!isOwnEmpty(me.defaultSelectedObjs) && me.defaultSelectedObjs.hasOwnProperty(hoverTouchVal))) {
									fillColor = getOpacityColor(fillColor, BUBBLE_SELECTED_OPACITY);
									nodeStrokeColor = selectedStrokeColor;
								} else {
									fillColor = getOpacityColor(fillColor, BUBBLE_HOVER_OPACITY);
								}
															
								
								// get the hover bubble position
								if (me.shapeFileType === SHAPE_FILE_POLYGON) {
									if (model.hasOwnProperty("polygonCenters")) {
										hoverCoord = model.polygonCenters[me.currHoverObj.touchVal][0];
									}
								} else if (me.shapeFileType === SHAPE_FILE_POINT) {
									hoverCoord = model.coords[me.currHoverObj.touchVal][0];
								}
								
								drawBubble(hlContext, hoverCoord, {x:me.leftOffset,y:me.topOffset}, fillColor, hoverBubbleRadius); 
								drawStroke(hlContext, hoverCoord, {x:me.leftOffset,y:me.topOffset}, nodeStrokeColor, hoverBubbleRadius, me.bubbleStrokeWidth);
								drawStroke(hlContext, hoverCoord, {x:me.leftOffset,y:me.topOffset}, highlightStrokeColor, hoverBubbleRadius+me.hoverBubbleRadiusLarger, me.bubbleStrokeWidth);
								
								//render the tooltip
								if (me.newRenderFlag) {
									// reposition tooltip when the device is retated
									me.newRenderFlag = false;
									var _center;
									if (me.shapeFileType === SHAPE_FILE_POLYGON) {
										_center = me.model.polygonCenters && me.model.polygonCenters[me.currHoverObj.touchVal] && me.model.polygonCenters[me.currHoverObj.touchVal][0];
									} else if (me.shapeFileType === SHAPE_FILE_POINT) {
										_center = me.model.coords && me.model.coords[me.currHoverObj.touchVal] && me.model.coords[me.currHoverObj.touchVal][0];
									}
									if (_center) {
										var xOnWidget = _center[0] + me.leftOffset - me._scroller.origin.x;
										var yOnWidget = _center[1] + me.topOffset - me._scroller.origin.y;
										me.renderTooltip(this.currHoverObj.touchVal, xOnWidget, yOnWidget, this.currHoverObj.hdrIndex);
									}
								} else {
									me.renderTooltip(this.currHoverObj.touchVal, this.currHoverObj.point.x, this.currHoverObj.point.y, this.currHoverObj.hdrIndex);
								}
								
					
							}
							
						} else if (me.markerType === MARKER_IMAGE) { // highlight image icon
							var coords = model.coords;
							if (model.hasOwnProperty("polygonCenters")) {
								coords = model.polygonCenters;
							}
							
							// highlight default selected image icon(s)
							var dftSltObjs = me.defaultSelectedObjs;
							if (!isOwnEmpty(dftSltObjs)) {
//								var fillColor = "RGBA(255,255,255,0.5)";
								var i;
//								hlContext.fillStyle = fillColor;
								for (i in dftSltObjs) {
									if (dftSltObjs.hasOwnProperty(i)) {
										me.highlightImageIcon(hlContext, coords, i, 0);
//										var hIndex = dftSltObjs[i],
//											iconName = "imageIcon_" + i;
//										if (model.hasOwnProperty(iconName)) {
//											var imgIcon = model[iconName],
//												width = imgIcon.width,
//												height = imgIcon.height,
//												xOffset = coords[i][0][0] - width/2 + me.leftOffset,
//												yOffset = coords[i][0][1] - height/2 + me.topOffset;
//											
//											// draw the rectangle area									
//											hlContext.fillRect(xOffset, yOffset, width, height);
//											
//											// draw the rectangle boundary
//											//hlContext.strokeStyle = selectedStrokeColor;
//											drawWhiteRectCorner(hlContext, xOffset, yOffset, width, height);
//										}
									}								
								}
								
//								fillColor = noAltColor;
							} else if (me.currSelectedObj!==null && me.currSelectedObj.hasOwnProperty("touchVal") && me.currSelectedObj.touchVal!=="" && me.currSelectedObj.touchVal!==null) {
								var touchVal = me.currSelectedObj.touchVal;
								me.highlightImageIcon(hlContext, coords, touchVal, 0);
//								var fillColor = "RGBA(255,255,255,0.5)";
								
//								var iconName = "imageIcon_" + touchVal;
//								if (model.hasOwnProperty(iconName)) {
//									var imgIcon = model[iconName],
//										width = imgIcon.width,
//										height = imgIcon.height,
//										xOffset = coords[touchVal][0][0] - width/2 + me.leftOffset,
//										yOffset = coords[touchVal][0][1] - height/2 + me.topOffset;
//									
//									// draw the rectangle area
//									hlContext.fillStyle = fillColor;
//									hlContext.fillRect(xOffset, yOffset, width, height);
//									
//									// draw the rectangle boundary
//									//hlContext.strokeStyle = selectedStrokeColor;
//									drawWhiteRectCorner(hlContext, xOffset, yOffset, width, height);
//								}
								
							} else if (me.currLinkObj!==null && me.currLinkObj.hasOwnProperty("touchVal") && me.currLinkObj.touchVal!=="" && me.currLinkObj.touchVal!==null) {
								var touchVal = me.currLinkObj.touchVal;
//								var fillColor = "RGBA(255,255,255,0.5)",
//									iconName = "imageIcon_" + touchVal;
								
								me.highlightImageIcon(hlContext, coords, touchVal, me.hoverBubbleRadiusLarger);
//								if (model.hasOwnProperty(iconName)) {								
//									var imgIcon = model[iconName],
//										width = imgIcon.width + me.hoverBubbleRadiusLarger*2,
//										height = imgIcon.height + me.hoverBubbleRadiusLarger*2,
//										xOffset = coords[touchVal][0][0] - width/2 + me.leftOffset,
//										yOffset = coords[touchVal][0][1] - height/2 + me.topOffset;
//									
//									// draw the rectangle area
//									hlContext.fillStyle = fillColor;
//									hlContext.fillRect(xOffset, yOffset, width, height);
//									
//									// draw the rectangle boundary
//									//hlContext.strokeStyle = highlightStrokeColor;
//									drawWhiteRectCorner(hlContext, xOffset, yOffset, width, height);
//									
//								}
							}
							if (me.currHoverObj!==null && me.currHoverObj.hasOwnProperty("touchVal") && me.currHoverObj.touchVal!=="" && me.currHoverObj.touchVal!==null) {
								var touchVal = me.currHoverObj.touchVal,
									fillColor = "RGBA(255,255,255,0.5)";
								
								var iconName = "imageIcon_" + touchVal;
								if (model.hasOwnProperty(iconName)) {
									var imgIcon = model[iconName],
										width = imgIcon.width + me.hoverBubbleRadiusLarger*2,
										height = imgIcon.height + me.hoverBubbleRadiusLarger*2,
										xOffset = coords[touchVal][0][0] - width/2 + me.leftOffset,
										yOffset = coords[touchVal][0][1] - height/2 + me.topOffset;
									
									// draw the rectangle area
									hlContext.fillStyle = fillColor;
									hlContext.fillRect(xOffset, yOffset, width, height);
									
									// draw the rectangle boundary 
									//hlContext.strokeStyle = highlightStrokeColor;
									var sltObj = me.currSelectedObj,
										hvTouchVal = me.currHoverObj.touchVal;
									if ((sltObj!==null && sltObj.hasOwnProperty("hdrIndex") && sltObj.hdrIndex >= 0 && sltObj.touchVal === hvTouchVal) 
											|| (!isOwnEmpty(me.defaultSelectedObjs) && me.defaultSelectedObjs.hasOwnProperty(hvTouchVal))) {
										// Do not call drawWhiteRectCorner() function when the image icon is selected.
									} else {
										drawWhiteRectCorner(hlContext, xOffset, yOffset, width, height);
									}
								}
								
								//render the tooltip
								if (me.newRenderFlag) {
									// reposition tooltip when the device is retated
									me.newRenderFlag = false;
									var _center;
									if (me.shapeFileType === SHAPE_FILE_POLYGON) {
										_center = me.model.polygonCenters && me.model.polygonCenters[me.currHoverObj.touchVal] && me.model.polygonCenters[me.currHoverObj.touchVal][0];
									} else if (me.shapeFileType === SHAPE_FILE_POINT) {
										_center = me.model.coords && me.model.coords[me.currHoverObj.touchVal] && me.model.coords[me.currHoverObj.touchVal][0];
									}
									if (_center) {
										var xOnWidget = _center[0] + me.leftOffset - me._scroller.origin.x;
										var yOnWidget = _center[1] + me.topOffset - me._scroller.origin.y;
										me.renderTooltip(this.currHoverObj.touchVal, xOnWidget, yOnWidget, this.currHoverObj.hdrIndex);
									}
								} else {
									me.renderTooltip(this.currHoverObj.touchVal, this.currHoverObj.point.x, this.currHoverObj.point.y, this.currHoverObj.hdrIndex);
								}
								
					
							}
						}
					}
					
				},
					

				/**
				* Returns the selected value (null if nothing is selected)
				* @param x the x position of the click event
				* @param y the y position of the click event
				* @return the selected value (null if nothing is selected)
				*/
				getTouchValue: function getTouchValue(x, y) {
					var me = this,
						model = this.model,
						coords = model.coords,
						elem,
						i;				

					//find clicked area
					if (me.displayMode === DISPLAY_MODE_AREA) {
						if (me.shapeFileType === SHAPE_FILE_POLYGON) {
							for (elem in coords) {
								if (coords.hasOwnProperty(elem)) {
									if (elem === "bgImage") {
										continue;
									}
									var coordsArray = coords[elem],
										l = coordsArray.length;
									for (i = 0; i < l; i++) {
										if (inPoly(coordsArray[i], x, y)) {
											return elem;
										}
									}
								}							
							}
						}
					} else if (me.displayMode === DISPLAY_MODE_BUBBLE) {
						if (me.shapeFileType === SHAPE_FILE_POLYGON && model.hasOwnProperty("polygonCenters")) {
							coords = model.polygonCenters;
						}
						var minDistance = Number.MAX_VALUE,
							touchName = "";
						for (elem in coords) {
							if (coords.hasOwnProperty(elem)) {
								if (elem === "bgImage") {
									continue;
								}
								var coord = coords[elem][0],
									distance = Math.sqrt((x-coord[0])*(x-coord[0])+(y-coord[1])*(y-coord[1]));
								if (distance < minDistance) {
									minDistance = distance;
									touchName = elem;
								}
							}						
						}
						// Not using the 45*45 rules, so as to be consistent with iOS
						if (minDistance < this.bias) {
							return touchName;
						}
											
					}
					
//					for (elem in coords) {
//						var coordsArray = coords[elem],
//							l = coordsArray.length;
//						for (i = 0; i < l; i++) {
//							if (inPoly(coordsArray[i], x, y)) {
//								return elem;
//							}
//						}
//					}

					return null;
				},


				
				/*
				* get touched Area or nearest Bubble
				* return null if:
				* 1. isTap: use for using 45*45 rule for tapping. If the gesture is not "tap", do not use 45*45 rule
				* 2. not in any area
				* 3. nearest Bubble satisfies the 45*45 rule for tapping
				* 
				*/
				getAreaOrNearestBubble: function (isTap, touchX, touchY){
					var me = this,
						model = me.model,
						coords = model.coords;
					
					//console.log("oritouchX:"+touchX + "  oritouchY:"+touchY);
					
					var touchPointOnWidget = me.utils.getTouchXYOnWidget(touchX, touchY, me);
					touchX = touchPointOnWidget.touchX;
					touchY = touchPointOnWidget.touchY;
					
					// 45*45 rule
					var x = touchX+ me._scroller.origin.x-me.leftOffset,
						y = touchY+ me._scroller.origin.y-me.topOffset,
						touchVal;
					if (isTap && me.tooltipOn && me.currHoverObj!==null) {
						var crHP = null;
						if (me.shapeFileType === SHAPE_FILE_POLYGON){
							crHP = model.polygonCenters && model.polygonCenters[me.currHoverObj.touchVal] && model.polygonCenters[me.currHoverObj.touchVal][0];
						} else if (me.shapeFileType === SHAPE_FILE_POINT) {
							crHP = coords[me.currHoverObj.touchVal] && coords[me.currHoverObj.touchVal][0]; 
						}
						
						if (crHP) {
							var dis = Math.sqrt((x-crHP[0])*(x-crHP[0]) + (y-crHP[1])*(y-crHP[1]));
							if (dis < me.bias) {
								touchVal = me.currHoverObj.touchVal;
							} else {
								touchVal = me.getTouchValue(x, y);
							}
						}
					} else {
						touchVal = me.getTouchValue(x, y);
					}
					
					if(!touchVal){
						return null;
					}
					// for the current area find its index in mojo data
					var hdrIndex = me.getHeaderIndex(touchVal);

							
					return {touchVal:touchVal, hdrIndex:hdrIndex, point:{x:touchX, y:touchY}};
				},
				
				renderTooltip: function renderTooltip(touchVal, touchX, touchY, hdrIndex) {
					var me = this,
						tooltip = this.tooltip,
						model = this.model,
						table = this.tooltip.childNodes[0],
						tooltipIndex = 0,
						i, j, tr, tdLeft, tdRight;
					
					// clear the content of the table
					if (table) {
						for (i=0; i<table.childNodes.length; i++) {
							tr = table.childNodes[i];
							if (tr) {
								tr.childNodes[0].innerHTML = '';
								tr.childNodes[1].innerHTML = '';
							}
						}
					}
					
					// display tooltip
					this.tooltip.style.visibility = "visible";
					
					if (!me.tooltipOn) {				
						me.tooltipOn = true;
						// if the tap is out of the widget, hide the tooltip
						var touchManager = mstrmojo.touchManager;
						me.tooltipListener = touchManager.attachEventListener('touchesBegin', me.id, function (evt) {
							if(!me.isTouchedOnWidget(evt.touch)){
								me.hideTooltip();
							}
						});
					}				

					var gts = model.gts,
						leftHtml,
						rightHtml;

					if (hdrIndex >= 0) {
						var rows = gts.row,
							idxs = model.ghs.rhs.items,
							idx;
						
						// rows[0]
						tr = tooltipIndex<table.childNodes.length && table.childNodes[tooltipIndex++];
						if (tr) {
							// change back from hdrIndex<0 style.display and style.align
							tr.childNodes[0].style.display = 'table-cell';
							tr.childNodes[1].style.align = 'left';
							
							tr.childNodes[0].style.paddingRight = "5px";
							leftHtml = rows[0].n + ':';
							tr.childNodes[0].innerHTML = leftHtml;
							//idx = idxs[hdrIndex].items[0].idx;
							rightHtml = rows[0].es[hdrIndex].n;
							tr.childNodes[1].innerHTML = rightHtml;
						}
						
						// start from rows[1];
						var ghsIndex = me.getIndexFromHdrindex(hdrIndex);
						for (i=1; i<rows.length; i++) {
							tr = tooltipIndex<table.childNodes.length && table.childNodes[tooltipIndex++];
							if (tr) {
								tr.childNodes[0].style.paddingRight = "5px";
								leftHtml = rows[i].n + ':';
								tr.childNodes[0].innerHTML = leftHtml;
								rightHtml = '';
								var _indices = me.attrIndices[i];
								if (_indices) {
									for (j=0; j<_indices.length; j++) {
										// for one attribute on the row having multi attribute forms
										idx = idxs[ghsIndex].items[_indices[j]].idx;
										rightHtml += rows[i].es[idx].n;
										if (j !== _indices.length-1) {
											rightHtml += ' ';
										}
									}							
								}						
								tr.childNodes[1].innerHTML = rightHtml;
							}
						}
						
						// display infomation on columns, not consider one metric with multi columns
						var gtsCol = gts.col;
						if (gtsCol && gtsCol.length>0) {
							var units = gtsCol[0].es,
								values = model.gvs.items[ghsIndex].items;

							for (i = 0; i < units.length; i++) {
								tr = tooltipIndex<table.childNodes.length && table.childNodes[tooltipIndex++];
								if (tr) {
									tr.childNodes[0].style.paddingRight = "5px";
									var mv = values[i],
										v = mv.v;
									// 773201 read number formatting from th if the threshold is not image (ty=4) or symbol (ty=10) or replaced text (ty=3)
									if (mv && mv.hasOwnProperty('ty') && mv.ty!=4 && mv.ty!=10 && mv.ty!=3 && mv.hasOwnProperty('ti')) {
										var th = model.th && model.th[i];
										v = (th && th[mv.ti] && th[mv.ti].n) ? th[mv.ti].n : mv.v;
									}
									
									leftHtml = units[i].n + ':';
									tr.childNodes[0].innerHTML = leftHtml;
									rightHtml = '' + v;
									tr.childNodes[1].innerHTML = rightHtml;
								}							
							}
						} else {
							
						}
					} else if (hdrIndex < 0) {
						rightHtml = touchVal;
						tr = tooltipIndex<table.childNodes.length && table.childNodes[tooltipIndex++];
						if (tr) {
							tr.childNodes[1].innerHTML = rightHtml;
							tr.childNodes[0].style.display = 'none';
							tr.childNodes[1].style.align = 'center';
							//tr.childNodes[0].style.paddingRight = "0px";
							//tr.childNodes[1].style.paddingRight = "5px"; // to make the content in the middle of the tooltip
						}					
					}
					
					// TQMS: 687390
					var TLx = touchX + this.bias,
						TLy = touchY - this.bias - tooltip.offsetHeight,
						RightX = this.getWidth() - tooltip.offsetWidth - this.tooltipRightShadowWidth, // considering the shade of the tooltip
						RightY = this.getHeight() - tooltip.offsetHeight;   // no shade on top of the tooltip
					if (TLx > RightX) {
						if (TLy < 0) {
							TLy = 0;
							TLx = Math.max(touchX - this.bias - tooltip.offsetWidth, 0);
						} else if (TLy >= 0) {
							TLx = RightX;
						}
					} else if (TLx <= RightX) {
						if (TLy < 0) {
							TLy = 0;
						} else if (TLy >= 0) {
							
						}
					}
					
					// Position the tooltip at new position.
					positionTooltip(tooltip, TLx, TLy);
				},
				
				/**
				* hide the tooltip and associated highlight
				* @private
				*/
				hideTooltip: function hideTooltip() {
					if(this.tooltipOn){	
						this.tooltipOn = false;	
						this.currHoverObj = null;					
						this.highlightPoint();	
						// Fadeout the tooltip.
//						var table = this.tooltip.childNodes[0];
//						var titleTD = table.childNodes[0].childNodes[0].childNodes[0];
//						var valueTD = table.childNodes[0].childNodes[0].childNodes[1];
//						titleTD.innerHTML = "";
//						valueTD.innerHTML = "";
//						console.log("tooltip tds innerHTML is set to null");
						//this.tooltip.innerHTML += "b";
						//$CSS.removeClass(this.tooltip, displayTooltipCss);
						//this.tooltip.innerHTML += "a";
						this.tooltip.style.visibility = "hidden";
						
						//positionTooltip(this.tooltip, this.getWidth(), 0);
						
						if (this.tooltipListener) {
							// Without this checking, after you rotate the device with tooltip on and tap on the tooltip,
							// there will be an error message, as the tooltip listener doesn't exist any more.
							mstrmojo.touchManager.detachEventListener(this.tooltipListener);
							delete this.tooltipListener;
						}						
					}
				},

				
				/**
				* Return true if the touch (touch) is on the widget.
				*/
				isTouchedOnWidget: function isTouchedOnWidget(touch) {
					
					if(!touch){
						return false;
					}
					
					var me = this,
						touchPointOnWidget = me.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, me),
						x = touchPointOnWidget.touchX,
						y = touchPointOnWidget.touchY;

					if ((x > 0 && x < me.getWidth()) && (y >0 && y < me.getHeight())) {
						return true;
					}
					return false;
				},
				
				unrender: function unrender(ignoreDom) {
					var me = this,
						model = me.model;
										
					if (this._super) {
						this._super(ignoreDom);
					}
					
					if (me.docModelListener) {
						if (me.xtabModel && me.xtabModel.docModel) {
							me.xtabModel.docModel.detachEventListener(me.docModelListener);
						}						
						delete me.docModelListener;
					}
					
					if (me.fullScreenListener) {
						mstrmojo.touchManager.detachEventListener(me.fullScreenListener);
						delete me.fullScreenListener; 
					}
	
					if (me.tooltipListener) {
						mstrmojo.touchManager.detachEventListener(me.tooltipListener);
						delete me.tooltipListener;
					}
					
					if (me.highlightContext) {
						delete me.highlightContext;
					}
					if (me.animationContext) {
						delete me.animationContext;
					}
									
					if (me._tn) {
						delete me._tn;
					}
					
				},
				
				destroy: function destroy() {
					
					if (this._super) {
						this._super();
					}
				}

			}

			

	);

}());//@ sourceURL=AndroidVisMap.js
(function(){
    
    mstrmojo.requiresCls("mstrmojo.Vis", 
                         "mstrmojo.url",
                         "mstrmojo._TouchGestures", 
                         "mstrmojo.HBox",
                         "mstrmojo.Label",
                         "mstrmojo.Image",
                         "mstrmojo._HasTouchScroller");
    
    var $M = Math,
        $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom,
        BORDER_WIDTH = 30,
        MARGIN_BOTTOM = 50,
        DOT_INTERVAL = 32;
    
    /**
     * Gets the container width or height.
     * @param {String} dimension. Value can be 'Height' or 'Width'.
     * @returns {Integer} The height or width of container.
     */
    function getDimension(dimension) {
        //Do we already have the value cached?
        var n = 'container' + dimension;
        if(!this[n]) {
            var domNode = this.domNode,
            x = parseInt(this[dimension.toLowerCase()], 10);
            
            //Cache the value
            this[n] = (isNaN(x)) ? domNode['client' + dimension] : x;
        }
        return this[n];
    }    
    
    /**
     * Gets the colgroup HTML markup string for table. Each column width is set to the same width.
     * @param {Integer} len The number of columns.
     * @returns {String} The colgroup HTML markup string. 
     */
    function getColGroupHTML(len) {
        var i, cols = '';
        if(len > 0) {
            for(i = 0; i < len; i++) {
                //Use percentage to control the width of each column.
                cols += '<col style="width:' + (100/len) + '%" />';
            }
        }
        return '<colgroup>' + cols + '</colgroup>';
    }
        
    /**
     * Returns the absolute path for a given image path. If the image path is absolute URL (containing 'http' in the path), no changes on the URL.
     * Otherwise we concat the image server with the image path.  
     * @param {String} n The image path. 
     * @returns {String} The absolute image URL.
     */
    function getImagePath(n) {
        return mstrmojo.url.getAbsoluteURL(n, mstrApp.getConfiguration().getCurrentProjectWebServerUrl());
    }
    
    /**
     * Uses the Webkit's transform property to translate a DOM node to a position on the X-axis. The animation duration is set to 500ms.
     * @param {HTMLElement} domNode The given DOM node for translate.
     * @param {Integer} xpos The end position on X-axis.    
     */
    function transitTo(domNode, xpos) {
        domNode.style[$DOM.CSS3_TRANSITION_DURATION] = '500ms';
        $DOM.translate(domNode, xpos, 0, 0, '', true);
    }
    
    /**
     * Resize a give image to fit to its container.
     * @param {HTMLElement} n The image DOM node
     * @param Integer w The width of the container
     * @param Integer h The height of the container
     * @returns {Boolean} True if the image is resized, otherwise false.
     */
    function resizeImage(n, w, h) {
        //If the image node is not there, return directly
        if(!n) {
            return ;
        }
        var iw = n.clientWidth, //image width
            ih = n.clientHeight, //image height
            rw, rh,
            resized = false;
        
        //if any dimension is bigger than the container, we need to resize the image
        if(w < iw || h < ih) {
            resized = true;
            rw = w/iw; //ratio of width to compress
            rh = h/ih; //ratio of height to compress

            //if width needs to compress more
            if(rw < rh) {
                //set the image width using the container width
                n.width = w;
            } else {
                //otherwise, use the container height as the image height
                n.height = h;
            }
        }
        return resized;
    }
    
    /**
     * Returns the headers organized by column.
     * @param {Object} dp The data parser object.
     * @returns {Object} An array of object arrays. Each object array contains the data of
     */
    function getHeadersByColumn(dp) {
        var cols = [], r, c, col,
            rhs, hds,
            rc = dp.getTotalRows(), //row count
            cc = rc > 0 ? dp.getRowTitles().size() : 0; //column count
        //go through each row
        for(r = 0; r < rc; r++) {
            //get all the row headers
            rhs = dp.getRowHeaders(r);
            //for each columns of the row
            for(c = 0; c < cc; c++) {
                //create a new array if no array previously created to store the values
                if(!cols[c]) {
                    cols[c] = [];
                }
                //get the header for the column
                hds = rhs.getHeader(c);
                //save the value into an object and push the object into the object array
                cols[c].push({n: hds.getName()});
            }      
        }
        return cols;
    }
    
    /**
     * <p>This component is used to visualize the images stored in grid.</p>
     * 
     * @class
     * @extends mstrmojo.Vis
     */    
    mstrmojo.ImageCarousel = mstrmojo.declare(
        //baseclass
        mstrmojo.Vis,
        //mixins
        [mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],
        /**
         * @lends mstrmojo.ImageViewer.prototype
         */        
        {
            scriptClass: 'mstrmojo.ImageCarousel',
            
            markupString: '<div class="mstrmojo-ImageCarousel {@cssClass}" style="overflow:hidden;{@cssText}">'+
                              '<div class="imageViewer" mstrAttach:click>{@noImageMsg}</div>' +
                              '<div class="imageTitle"></div>' +
                              '<div class="statusBar" style="overflow:hidden"></div>' +
                          '</div>',            
        
            markupSlots: {
                viewerNode: function() { return this.domNode.firstChild; },
                textNode: function() { return this.domNode.childNodes[1]; },
                statusBarNode: function() { return this.domNode.lastChild; }
            },
                          
            formatHandlers: {
                domNode: [ 'RW' ]
            },
            
            /**
             * Scroller configuration for the image viewer
             */
            scrollerConfig: {
                friction: 0.0087,
                bounces: false,
                vScroll: false,
                hScroll: true
            },            
                        
            /**
             * The index of selected image
             */
            selected: -1,
            
            /**
             * First child: The image list. All the images are placed inside the table cells of mstrmojo.HBox.
             * Second child: The description text. The description of the image.
             * Third child: The status bar.  The status bar use white and gray dots indicating which image is selected.
             */
            children: [{
                scriptClass: 'mstrmojo.HBox',
                slot: 'viewerNode',
                alias: 'viewer',                
                onitemsChange: function() {
                    var v, i, len, c = [],
                        vp = this.parent.vp,
                        bdcss;
                    
                    v = this.items;
                    if(!this.hasRendered) {
                        var p = this.parent,
                            cw = getDimension.call(p, 'Width'), //container width
                            ch = getDimension.call(p, 'Height'); //container height

                        if(this.children) {
                            this.removeChildren();
                        }                        
                        
                        len = v.length;
                        //set each column to be the same width
                        this.colHTML = getColGroupHTML(len);
                        //set the table width to be the total width of all columns and set the height to be 
                        //the photo viewers area height
                        this.cssText = 'width:' + (cw*len) + 'px;height:' + (ch - MARGIN_BOTTOM) + 'px';
                        //image border width and color
                        bdcss = (vp && vp.bw) ? ('border:' + vp.bw + 'px solid #' + (vp.bc || 'FFF')) : ''; 
                        
                        for(i = 0; i < len; i++) {
                            c.push({
                                scriptClass: 'mstrmojo.Image',
                                cssText: bdcss,
                                cssDisplay: 'inline-block',
                                src: getImagePath(v[i].n || v[i].v),
                                onload: function() {
                                    //once image is loaded, we might need to resize it
                                    resizeImage(this.imgNode, cw - BORDER_WIDTH, ch - MARGIN_BOTTOM);
                                }
                            });
                        }
                        this.addChildren(c);
                    }
                }
            },{
                scriptClass: 'mstrmojo.Label',
                slot: 'textNode',
                alias: 'description'
            }, {
                scriptClass: 'mstrmojo.HBox',
                slot: 'statusBarNode',
                alias: 'sb',
                onitemsChange: function() {                
                    var v = this.items, c = [], i, len;
                    
                    //if items are changed, we should remove the existing children and reset all the variables
                    if(this.children) {
                        this.removeChildren();
                        delete this.numVisibleDots;
                        this.lastSelected = -1;
                    }
                    
                    for(i = 0, len = v.length; i < len; i++) {
                        c.push({
                            scriptClass: 'mstrmojo.Label'                            
                        });
                    }
                    this.addChildren(c);
                    
                    //once items are reset
                },
                lastSelected: 0, //record the last selected index 
                select: function(idx) {
                    var lstPg, curPg, dn = this.domNode, dts = this.numVisibleDots; 
                    
                    if(this.selectedNode) {
                        $CSS.removeClass(this.selectedNode.domNode, 'selected');
                    }
                    
                    //if we have items to select
                    if(this.items.length > 0) {
                        this.selectedNode = this.children[idx];
                        $CSS.addClass(this.selectedNode.domNode, 'selected');
                        
                        //if the selected idx exceeded the maximum visible one, shift the status bar to left to displaying the remaining ones
                        //or if the selected idx needs go back to previous visible dots, the status bar needs to be shifted back
                        if(!dts) {
                            dts = this.numVisibleDots = $M.floor(getDimension.call(this.parent, 'Width')/DOT_INTERVAL);
                            if(this.items.length < dts) {
                                $CSS.addClass(dn, 'center');
                            } else {
                                $CSS.removeClass(dn, 'center');
                            }
                        }
                        
                        lstPg = $M.floor(this.lastSelected/this.numVisibleDots);
                        curPg = $M.floor(idx/this.numVisibleDots);
                        //if needs to change page position of the status bar
                        if(lstPg !== curPg) {
                            transitTo(dn, -curPg * dts * DOT_INTERVAL);
                        } 
                        this.lastSelected = idx;
                    }
                }
            }],
            
            //configure the horizontal scroller
            updateScrollerConfig: function updateScrollerConfig() {
                var len = this.viewer.items.length;
                mstrmojo.hash.copy({
                    scrollEl: this.viewerNode,
                    origin: {x: 0, y: 0},
                    offset: {
                        x: {
                            start: 0,
                            end: ((len > 0) ? (len - 1) : 0) * getDimension.call(this, 'Width')
                        }    
                    }
                }, this.scrollerConfig);
                return this._super();
            },
            
            touchSwipeEnd: function touchSwipeEnd(touch) {
                var delta = touch.delta,
                    len = this.viewer.items.length;
                
                //this._super(touch); //do not call super, otherwise, it will trigger decelaration code
                if(delta && delta.x > 0) {
                    this.set('selected', Math.max(0, this.selected - 1));
                } else if(delta && delta.x < 0) {
                    this.set('selected', Math.min(this.selected + 1, len));
                }
            },
            
            /*
            initScroller: function initScroller(scroller) {
                // Attach an event listener to hear when scrolls are done.
                scroller.attachEventListener('scrollDone', this.id, function (evt) {
                    var translateX = evt.x,
                        width = getDimension.call(this, 'Width'),
                        selectedIdx = $M.floor(translateX / width),
                        position = $M.floor( selectedIdx * width),
                        extraPos = $M.abs(translateX - position);
                    
                        //unset the selected value so that we will force the scroller to scroll
                        this.selected = -1;
                    
                        if(extraPos >= width * 0.5) {
                            selectedIdx += 1;
                        }
                        this.set('selected', selectedIdx);
                });
            },            
            */
            
            onclick: function(e) {
                var dlgCfg;
                //go to full screen mode
                if(mstrApp.getScreenDimensions && this.selectedImage) {
                    dlgCfg = {
                            cssClass: 'image-FullScreen',
                            onclick: function() { this.close(); },
                            //reset the dialog dimension if dialog is resized (e.g. rotate screen from portrait mode to landscape mode)
                            resizeDialog: function() {
                                var d = mstrApp.getScreenDimensions(),
                                    dm = this.domNode,
                                    ds = dm && dm.style;
                                if(d && ds) {
                                    ds.width = d.w + 'px';
                                    ds.height = d.h + 'px';
                                }
                            },
                            //put a mstrmojo.Image object as the content
                            children:[{
                                scriptClass: 'mstrmojo.Image',
                                src: this.selectedImage,
                                onload: function() {
                                    var d = mstrApp.getScreenDimensions();
                                    if(d) {
                                        //if the image width and height is adjusted, that means the original position of 
                                        //dialog might not be right. We need to re-position dialog
                                        resizeImage(this.imgNode, d.w, d.h);
                                        // TQMS690871 The left and top position of the dialog content node is dynamically calculated. After image is loaded, the content node size might get changed.
                                        // Need to re-position dialog as in some case the dialog is positioned before the image is loaded
                                        this.parent.positionDialog();
                                    }
                                }
                            }]};
                    mstrApp.showDialog(dlgCfg);
                }
            },
            
            touchTap: function(e) {
                this.onclick(e);
            },
            
            preBuildRendering: function preBuildRendering() {
                var dp = this.getDataParser(),
                    headers = getHeadersByColumn(dp),
                    imgs, desc;
                
                // set visualization property
                if(!this.vp) {
                    this.vp = this.model.vp;
                }
                
                imgs = headers[0] || []; //first column, path
                desc = headers[1] || []; //second column, description
                this.viewer.set('items', imgs);
                
                this.sb.set('items', desc);
                this.selected = -1;
                
                //if more than one image, we need to hide the noImageMsg 
                if(imgs.length > 0) {
                    this.cssClass = this.cssClass ? '' : this.cssClass.replace(/noImage/, '');
                    this.noImageMsg = '';
                } else {
                    this.cssClass += this.cssClass ? '' : ' noImage';
                    this.noImageMsg = 'No Photo Found';
                }
                
                //background color
                if(this.vp && this.vp.bgc) {
                    this.cssText = 'background-color:#' + this.vp.bgc + ';';
                }
                
                this._super();
            },
            
            postBuildRendering: function postBuildRendering() {
                this._super();
                
                //select the first image as selected one
                this.set('selected', 0);
            },
            
            /**
             * Set the status bar and the description of the image.
             * @param {Integer} idx
             */
            onselectedChange: function onselectedChange() {
                var idx = this.selected, 
                    s = this.sb,
                    img = this.viewer.items[idx],
                    desc = s.items[idx];
                
                //if there is an image selected
                if(img) {
                    //set the scroller to scroll to a proper position
                    this._scroller.scrollTo(idx * getDimension.call(this, 'Width'), 0, 500);
                    //save the image URL
                    this.selectedImage = getImagePath( (img && img.n) || '');
                    
                    //change the dot indicator 
                    s.select(idx);
                    
                    //set the description
                    this.description.set('text', (desc && desc.n) || '');
                }
            }
            
            
        });
}());
/**
  * AndroidMap.js
  * Copyright 2010-2012 MicroStrategy Incorporated. All rights reserved.
  * @version 1.0

  * @fileoverview <p>Widget for displaying Maps rendered by Google Maps JavaScript API.</p>
  * @author <a href="mailto:dhill@microstrategy.com">Doug Hill</a>
  */
  
  (function () {

    mstrmojo.requiresCls("mstrmojo.Vis",
                         "mstrmojo.array",
                         "mstrmojo.hash",
                         "mstrmojo.android.EnumMenuOptions",
                         "mstrmojo.GeoLocation",
                         "mstrmojo._TouchGestures",
                         "mstrmojo.android.DropDownList",
                         "mstrmojo.Label");

	mstrmojo.requiresDescs(7736, 8068, 8069, 8102, 8395, 8954);

    var $A = mstrmojo.array,
        $M = mstrmojo.android.EnumMenuOptions,
        REPROMPT = $M.REPROMPT,
        MAX_MARKERS = 1000; // Max number of markers to display on map

    /*
     * To create bubbles on the map we need to do our own implementation of the google.maps.OverlayView
     * (see http://code.google.com/apis/maps/documentation/javascript/reference.html#OverlayView) according to
     * the google.maps spec we need to implement three methods onAdd(), draw(), and onRemove(). In the add() method,
     * we create DOM objects and append them as children of the panes. In the draw() method, we position these elements.
     * In the onRemove() method, we should remove the objects from the DOM.
     * */
    function CustomMarker(lbl, latlng, rad, index, color) {
        this.title = lbl;
        this._latlng = latlng;
        this._rad = rad;
        this._ix = index;
        this._color = color;
    }

    function initCustomMarker() {

       CustomMarker.prototype = new google.maps.OverlayView();

       CustomMarker.prototype.draw = function() {

           // Check if the div has been created.
           var div = this.div_;
           if (!div) {
               // Create a overlay text DIV
               div = this.div_ = document.createElement('DIV');
               // Create the DIV representing our CustomMarker
               var sty = div.style,
                   rad = this._rad,
                   radD2 = rad / 2,
                   radD2Px = radD2 + "px " + radD2 + "px",
                   panes = this.getPanes(),
                   me = this;

               sty.position = "absolute";
               sty.paddingLeft = "0px";
               sty.cursor = 'pointer';
               sty.backgroundColor = this._color;
               sty.opacity = '.65';
               sty.borderRadius = radD2Px;
               sty.height = sty.width = rad + "px";
               sty.border = "2px solid black";

               google.maps.event.addDomListener(div, "click", function(event) {
                   google.maps.event.trigger(me, "click");
               });

               // Then add the overlay to the DOM
               panes.overlayMouseTarget.appendChild(div);
           }

           // Position the overlay
           var point = this.getProjection().fromLatLngToDivPixel(this._latlng);
           if (point) {
               div.style.left = (point.x - this._rad / 2) + 'px';
               div.style.top = (point.y - this._rad / 2) + 'px';
           }
       };

       CustomMarker.prototype.remove = function() {
           // Check if the overlay was on the map and needs to be removed.
           var dv = this.div_;
           if (dv) {
               dv.parentNode.removeChild(dv);
               this.div_ = null;
           }
       };

       CustomMarker.prototype.getPosition = function() {
           return this._latlng;
       };

   }

    var getBounds = function getBounds(markers){
        var bnds;
        if(markers.length > 0){

            bnds = new google.maps.LatLngBounds();
            for(var i in markers){
                var m = markers[i],
                    p = m.getPosition();



                bnds.extend(p);
            }
        }
        return bnds;
    };

    function getFromPoint(laOrln, value){
        return value.replace(/POINT[ ]?\(|\)/g,"").split(' ')[laOrln == 'lat' ? 1 : 0];
    }

    function _getMapType() {
        return this._mapTypeToGoogleMapTypeId[this.mapType];
    }


    /**
     * <p>A widget to display an Android specific Android Map.</p>
     *
     * This is intended to live inside an AndroidView widget as the contentChild.
     *
     * @class
     * @extends mstrmojo.Box
     */
    mstrmojo.maps.jsmap.AndroidMap = mstrmojo.declare(
        mstrmojo.Vis,

        [ mstrmojo._TouchGestures ],

        {
            scriptClass: "mstrmojo.maps.jsmap.AndroidMap",

            cssClass : "mstr-googleMapView",

            markupString: '<div id="{@id}" class="mstrmojo-Box {@cssClass}" style="{@domNodeCssText}">' +
                             '<div></div>' +
                              '<div class="androidMap-metricSelector"><span class="androidMap-toggleHeader"></span></div>' +
                              '<div class="mstr-googleMap" id="map_canvas_{@id}"></div>' +
                          '</div>',

            reRenderOnDimensionChg: false,
            
            noMapsMsg: mstrmojo.desc(8954,"Google Maps have not been configured for this device. Please check with your mobile administrator to enable Google Maps in the mobile configuration."),
            
            /*
             * Since the mapped attribute can have several metrics on the grid we need to have a
             * selected one that will be used to show the marker specific details for that mapped
             * attribute, this index will tell us which metric is selected, the default will be 0.
             *
             */
            selMetricIx : 0,

           /*
            * An array of marker arrays
            * When we switch metrics we need to rebuild all the markers, to avoid unnecessary overhead
            * we keep the group of markers cached, this array will store them. The index 0 corresponds
            * to the group of markers for the metric 0, 1 to the 1 and so on.
            *
            */
            markerArr : [],

           /*
            * Internal reference of our google.map object
            *
            */
           googleMap : null,

           /*
            * This will store the maximum raw value of a certain metric, used to build the bubbles. The
            * index 0 corresponds to the metric 0 and so on.
            *
            */
           bubblesMaxInfo : [],

           /*
            * Defines the size of the bigger bubble on the map in pixels, all bubble marker size will be equal or
            * less than this value.
            *
            */
           maxBubbleSize : 50,
           minBubbleSize : 20,

           /**
            * map is the slot for the googleMap object
            * metricSelector is the slot for the metric selector label
            *
            */
           markupSlots : {
               msg : function() { return this.domNode.childNodes[0]; },
               metricSelector : function(){ return this.domNode.childNodes[1];},
               map : function(){ return this.domNode.childNodes[2];}
           },

            markupMethods: {
                onheightChange: function(){
                    this.domNode.style.height = this.getHeight() + 'px';
                },
                onwidthChange: function(){
                    this.domNode.style.width = this.getWidth() + 'px';
                }
            },

           /**
            * Initially the metric selector height is zero, will be updated before
            * rendering in case the map has more than one metric.  This is used by the
            * _HasLayout mixin
            *
            */
           layoutConfig: {
               h: {
                   metricSelector: '32px',
                   map: '100%'
               },
               w: {
                   metricSelector: '200px',
                   map: '100%'
               }
           },

           children: [{
                   scriptClass: 'mstrmojo.android.DropDownList',
                   slot: 'metricSelector',
                   options: null,
                   onidxChange: function(evt) {
                       this._super(evt);
                       this.parent.onselMetricIxChange( evt );
                       this.set('value', this.options[evt.value].v);
                   },
                   visible: false,
                   alias: "metricSel"
                },{
                   scriptClass: 'mstrmojo.Box',
                   slot: 'map'

                }, {
                    scriptClass: 'mstrmojo.Label',
                    cssClass: "androidMap-errorMsg",
                    visible: true,
                    alias: "errorMsg",
                    slot: "msg"
                }
            ],

            setModel: function setModel(model) {
                this.set('model', model);
                this.xtabModel = model;
                if ( model.data ) {
                    this.set('gridData', model.data);
                }
            },

            ongridDataChange: function() {
                this.parser = new mstrmojo.Vis.DataParser(this.gridData);
            },

            update: function update(node) {
                node = node || this.node;
                if (node) { // called from docs
                	if (node.data) {
                	
                	    this.set('gridData', node.data);

                        var gd = this.gridData;
                		if (gd.layoutModel) this.layoutModel = gd.layoutModel;
                		if (gd.layoutNode) this.layoutNode = gd.layoutNode;
                	}
                    var fmts = node.defn.fmts || node.defn.units[this.xtabModel.k].fmts;

                    this.width = parseInt(fmts.width, 10);
                    this.height = parseInt(fmts.height, 10);
                    this.top = parseInt(fmts.top,10);
                    this.left = parseInt(fmts.left,10);
                    this.fmts = fmts;
                }

                if (this.xtabModel) {
                	this.initFromVisProps(this.gridData.vp);
                }
                this.updated = true;
            },

            getMapModel: function() {
                return this.xtabModel;
            },

			initFromVisProps: function initFromVisProps(vp) {
				if(!vp) return;

				// get the type of map we're supposed to display				
				if(vp.dv) {
					this.mapType = parseInt(vp.dv,10);
				}				
                this.usePt = ( vp.gr == "1" );
                this.useAttributes = ( vp.af === "0" );
                this.geoAttr = vp.ga;
                this.markerType = vp.mtp;
                this.attrThresholds = vp.at;
                this.flong = vp.flong;
                this.flat = vp.flat;
                this.fpt = vp.fpt;
                this.mstyl = vp.mstyl;
                this.maxBubbleSize = vp.mbs || 50;
            },

            showErrorMsg: function showErrorMsg(show,msg) {
                this.errorMsg.set("text", msg );
                this.metricSelector.style.display = show ? "none" : "block";
                this.map.style.display = show ? "none" : "block";
                this.msg.style.display = show ? "block" : "none";
            },
			
            postBuildRendering : function postBuildRendering(){
console.log("JSMAP:androiMap:postBuildRendering");
               this._super();

               if ( typeof this.gridData.eg !== "undefined" ) {
                   this.showErrorMsg( true, this.gridData.eg );
               } else if ( typeof google === "undefined" || ( google && typeof google.maps === "undefined" )) {
                   this.showErrorMsg(true,this.noMapsMsg);
               } else {

                   this.showErrorMsg(false);

                    // Update selector info on widget.
                    var selectorCtrl = this.children[0];

                    selectorCtrl.idx = 0;
                    selectorCtrl.unset = true;
                    selectorCtrl.options = [{ v: '-1', n: '' }];

                    if( /* !mstrApp.onMobileDevice() && */
                        ( typeof google !== "undefined" && google.maps ) ) {

                        // if we are NOT an info window then either load the map
                        if ( !mstrApp.isInfoWindow ) {
                            this.markerArr = [];
                            this.bubblesMaxInfo = [];
                        }

                        this._mapTypeToGoogleMapTypeId = [  google.maps.MapTypeId.ROADMAP,
                                                            google.maps.MapTypeId.SATELLITE,
                                                            google.maps.MapTypeId.HYBRID,
                                                            google.maps.MapTypeId.TERRAIN ];

                        //the custom marker requires google.maps API so just create it if present
                        initCustomMarker();
                        /* update the metric selector, once we have the slots and data
                        * we know the contents of the initial label, if there is one.
                        * */
                        if(this.gridData){

                            var showSelector = this.buildMetricSelector(),
                                selectorHeight = showSelector ? parseInt(this.layoutConfig.h.metricSelector,10) : 0;

                            this.metricSel.set('visible',showSelector);

                            this.map.style.height = this.getHeight() + "px";
                           	this.map.style.width = (this.getWidth() - 1) + "px";

                            this.metricSelector.style.height = selectorHeight + "px";
                            this.metricSelector.style.display = showSelector ? "block" : "none";

                            this.initMap();

                            if ( this.map.firstChild ) {
                                this.map.firstChild.style.zIndex = 1;
                            }
                        }
                    }
               }
           },



            gup: function gup(n){
            	n = n.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
            	var rxs = "[\\?&]"+n+"=([^&#]*)",
            	    rx = new RegExp(rxs),
            	    r = rx.exec(window.location.href);
            	return r == null ? "" : r[1];
            },

           /*
            * Updates the markers on the map when the selected metric changes
            *
            */
           onselMetricIxChange: function(evt){
               var f = function(map,mks){
                   for(var i in mks){
                       if(mks[i].setMap){
                           mks[i].setMap(map);
                       }
                   }
               };

               //Check if the map has an opened info window, if it does try to close it
               if(this.openedInfoWindow){
                   this.openedInfoWindow.close();
               }
               //Get the old and new set of markers
               var mks = this.getMarkers(evt.value),
                   oldMks = this.getMarkers(evt.valueWas);

               this.selMetricIx = evt.value;

               //Set null map to the old markers, this will remove them from the map
               f(null, oldMks);
               //Set the map to the new marker group, this will place them on the map
               f(this.googleMap, mks);
           },

           /*
            * Creates the label of the metric selector based on the current selected metric
            *
            */
           buildMetricSelector : function buildMetricSelector() {
               var  col = this.gridData.gts.col,
                    useSelector = false;

               if ( col.length > 0 ) {
                   var metrics = col[0].es;

                   if( metrics.length > 1 ) {

                        var  items = [],
                             x = -1;

                        // Iterate list.
                        $A.forEach(metrics, function (m, idx) {
                            // Add n|v item to return array.
                            items[++x] = {
                                n: m.n,
                                v: x,
                                id: m.id
                            };
                        });

                        var selector = this.children[0];

                        selector.set('options',items);
                        selector.set('value', 0 );

                        useSelector = true;
                    }
               }
               return useSelector;
           },

            /**
             * Initializes the googleMap object, sets the initiall group of markers, zoom and center.
             *
             */

            initMap : function () {
                var map,
                    gm = google.maps,
                    gme = gm.event,
                    mapType = _getMapType.call(this) || gm.MapTypeId.ROADMAP,
                   //mapOptions follow the spec from google.maps API http://code.google.com/apis/maps/documentation/javascript/reference.html#MapOptions
                   mapOptions = {
                       mapTypeControl : true,
                       mapTypeControlOptions: {
                           position: gm.ControlPosition.TOP_LEFT,
                           style: gm.MapTypeControlStyle.HORIZONTAL_BAR // DROPDOWN_MENU
                       },
                       streetViewControl :false,
                       mapTypeId : mapType,
                       navigationControlOptions : {
                         position : gm.ControlPosition.RIGHT_BOTTOM,
                         style : gm.NavigationControlStyle.ANDROID
                       },
                       zoomControlOptions: {
                           style: gm.ZoomControlStyle.LARGE
                       },
                       tilt: 0

                     };

                //Initialize the googleMap object and cache it
                this.googleMap = map = new gm.Map(this.map, mapOptions);

                // use previously selected metric if available
                this.selMetricIx = this.selMetricIx;

                //Get a list of markers for the selected metric that should be 0
                var markers = this.getMarkers(this.selMetricIx);

                if ( markers.length > 0 ) {
                    // Use bounds object computed while generating the markers; the bounds is used to center and zoom the map
                    var bnds = this.mapBounds; // getBounds(markers);

                   // If bounds are available (i.e. we have one or more markers), set the center and zoom (using the fitBounds method)
                   if ( bnds ) {
                       map.fitBounds(bnds);
                       map.setCenter(bnds.getCenter());
                   }
                } else {
                    // we found no valid markers in the grid data; set the center of the map to MSTR HQ if no GPS is available.
                    var mstrHQ = new gm.LatLng(38.893444,77.221648);
                    map.setCenter(mstrHQ);
                }

                // TQMS#494753v2 - map.getZoom() can return "undefined" if we don't wait a bit for the map to initialize.
                //                  wait up to 300ms for the map to get itself together and then set the zoom.
                var INTERVAL = 30,
                    t = 0,
                    mz = map.getZoom(),
                    ti = setInterval(function() {
	                	mz = map.getZoom();	                	
	                    t += INTERVAL;
	                    if ( mz !== undefined ) {
	                        // TQMS#499060 - back off the zoom if we are in too tight
                            // TQMS#494753 - if we are zoomed in too far, then zoom out a bit
			                if ( mz > 20 ) {
			                    map.setZoom(15);			
			                } else if ( mz < 2 ) {
			                    map.setZoom(2);
			                }
	                        clearTimeout(ti);
	                    } else if (t > 10*INTERVAL) {
	                        // exceeded our timeout, clear interval and set default zoom
	                        clearTimeout(ti);
	                        map.setZoom(2);
	                    }
	                }, INTERVAL);	                
           },

           /**
            * Returns the group of markers for a certain metric, it will return the cached version
            * or it will create the new set if not present on the cache.
            *
            * The marker data contains consists of two or three parts depending on whether the "point" form is being used.
            * In "point" form, the longitude and latitude are combined into a single attribute/attribute form.
            * Otherwise the data consists of three individual parts (label, longitude, and latitude). The minValues
            * variable is set to two or three depending on which form the geolocation data is in.
            *
            *        <option value="0">Use Attribute</option>
            *        <option value="1">Use Attribute Form</option>
            *
            *
            */
            getMarkers : function getMarkers(metricIx){
                // May be cached already, return cached version
                if(!!this.markerArr[metricIx]){
                    return this.markerArr[metricIx];
                }

                var map = this.googleMap,
                    d = this.gridData,
                    vp = d.vp,
                    gts = d.gts,
                    row = gts.row,
                    usePt = this.usePt,
                    minVals = (usePt ? 1 : 2 ),  // minimum number of attribute forms, don't count the label in min values (TQMS#499060)
                    useAttributes = this.useAttributes,
                    geoAttr = this.geoAttr,
                    longs, lats, labels,
                    longIdx = -1, latIdx = -1, labelIdx = -1,
                    mks = [],
                    tIcon = null;

                for( var r = 0, numRows = row.length, totalForms = 0; r < numRows; ++r ) {
                    var curRow = row[r],
                        rid = curRow.id;
					
                    // check if the row ID matches any of our geo IDs

                    // are we using POINT() form?
                    if ( usePt ) {
                        // yes, check the fpt ID
                        if ( rid == this.fpt ) {
                            longs = lats = curRow;
                            longIdx = latIdx = totalForms;
                        }
                    } else {
                        // no, using separate long/lat data
                        // is this the LONGITUDE data?
                        if ( rid == this.flong ) {
                            longs = curRow;
                            longIdx = totalForms;

                        // is this the LATITUDE data?
                        } else if ( rid == this.flat ) {
                            lats = curRow;
                            latIdx = totalForms;
                        }
                    }

                    for( var f = 0, numForms = curRow.fs.length; f < numForms; ++f ) {
                        var curForm = curRow.fs[f],
                            fid = curForm.id;

                        // are we using POINT() form?
                        if ( usePt ) {
                            // yes, check the fpt ID
                            if ( fid == this.fpt ) {
                                longs = lats = curRow;
                                longIdx = latIdx = totalForms + f;
                            }
                        } else {
                            // no, using separate long/lat data
                            // is this the LONGITUDE data?
                            if ( fid == this.flong ) {
                                longs = curRow;
                                longIdx = totalForms + f;
                            // is this the LATITUDE data?
                            } else if ( fid == this.flat ) {
                                lats = curRow;
                                latIdx = totalForms + f;
                            }
                        }

                        // grab the first non-geo data to use as the label
                        if ( labelIdx < 0 ) {
                            labels = curRow;
                            labelIdx = totalForms + f;
                        }
                    }

                    totalForms += numForms;
                }

                // check for minimal requirements for displaying a map;
                if ( Math.min(longIdx,latIdx,labelIdx) < 0 ) {
                    throw new Error(mstrmojo.desc(8395, 'Not enough data to display map.'));
                }

                var rhs = d.ghs.rhs.items,
                    numMarkers = Math.min( rhs.length , MAX_MARKERS ),
                    lat_hi = -90, lat_lo = 90, lng_hi = -180, lng_lo = 180;

                for( var i = 0; i < numMarkers; i++ ) {
                    var vals = rhs[i].items; // set up access to the grid row headers

                    // if this row does not have enough data to display a marker, then skip it.
                    // This can occur on Total and Sub-Total rows
                    if ( vals.length < minVals) {
                        continue;
                    }
                    // get the 'longitude' value for this marker; if we are using the Point form
                    // we must extract the long and lat. data from this value
                    var longV = longs.es[vals[longIdx].idx].n,
                        lon = parseFloat( usePt ? getFromPoint("long", longV ) : longV ),
                        lat = parseFloat( usePt ? getFromPoint("lat", longV ) : lats.es[vals[latIdx].idx].n ),
                        lbl = labels.es[vals[labelIdx].idx].n,
                        marker,
                        metricItem = d.gvs.items[i];

                    // if longitude or latitude is invalid then skip this row
                    if ( isNaN(lat) || isNaN(lon)) {
                        continue;
                    }

                    // track the low and high lat/long values
                    lat_lo = ( lat < lat_lo ) ? lat : lat_lo;
                    lat_hi = ( lat > lat_hi ) ? lat : lat_hi;
                    lng_lo = ( lon < lng_lo ) ? lon : lng_lo;
                    lng_hi = ( lon > lng_hi ) ? lon : lng_hi;

                    //Create a LatLng google.maps object using the latitude and longitud from the data
                    latLng = new google.maps.LatLng(lat, lon);

                    //'mtp' is the marker type, 1-markerStyle 2-DynamicBubbles
                    if ( this.markerType == "2" ) {
                        marker = this.getMetricBubble(d.gvs.items[i], lbl, latLng, i, metricIx);
                    } else {

                        //Use a predefined icon if there is no image as threshold for the marker
                    	tIcon = "../" + this.mstyl;
                    	
                    	var gvsItem = d.gvs.items[i];
	                    if ( gvsItem ) {
	
	                    	var	mitems = gvsItem.items;
	                    	if ( mitems ) {
	                    		var mi = mitems[metricIx];

	                    		//'at' will be 1 if we need to use the thresholds, metricItem value type 'ts' will be 4 for images
		                        if( mi && (mi.ts == 4) && (this.attrThresholds == "1")){
		                            tIcon = this.getImage(mi.v);
		                        }
	                    	}
	                    }

                        //Construct the new gogle.maps.Marker using the API spec http://code.google.com/apis/maps/documentation/javascript/reference.html#Marker
                        marker = new google.maps.Marker({
                            position: latLng,
                            title: lbl,
                            _ix : i,
                            icon : tIcon,
                            zIndex: i       // set the z-index of the markers so they are drawn in order rather than by screen position
                        });
                    }

                    // attach the element id and groupby ids to each marker
                    marker.eid = labels.es[vals[labelIdx].idx].id;
                    marker.attrid = labels.id;

                    marker.setMap(map);

                    //Attach an event listener to the marker to execute the following method when pressed
                    google.maps.event.addListener(marker, 'click', function(ths,m) {
                        return function() {

                            // pan to the marker so that the info window is fully visible (#490587)
                            // map.panTo(m.getPosition());

                            // handle click on a marker
                            ths.handleMarkerClick(map,m);
                        };
                    }(this,marker) );

                    //add the marker to the markers collection
                    mks[mks.length] = marker;
                }

                // mstrmojo.dbg("map bounds: lat_hi="+lat_hi+", lat_lo="+lat_lo + ", lng_hi="+lng_hi + ", lng_lo="+lng_lo);

                this.mapBounds = new google.maps.LatLngBounds(
                    new google.maps.LatLng(lat_lo,lng_lo),
                    new google.maps.LatLng(lat_hi,lng_hi)
                 );

                //cache this marker collection
                this.markerArr[metricIx] = mks;

               return mks;
           },

           handleMarkerClick: function(map,marker) {
                //Check if we have any other info window already opened, close it.
                if( this.openedInfoWindow){
                    this.openedInfoWindow.close();
                    this.openedInfoWindow = null;
                }
                this.openInfoWindow(map,marker);

                this.postHandleMarkerClick(map,marker);
           },

           /**
            * Called after info window has been displayed in response to user click on map marker
            */
           postHandleMarkerClick: mstrmojo.emptyFn,

           // TODO need to move it other where since there're several copies of this function
           getImage: function getImage(url) {
                var app = mstrApp,
                    config = app.getConfiguration();

                if (config && url && url.indexOf('://') === -1) {

                    url = config.getHostUrlByProject(app.getCurrentProjectId()) + url;
                }

                return (mstrApp.useBinaryFormat) ? String(mstrMobileApp.getImage(url)) : url;
            },


          /**
           * Used to build the custom marker with bubble shape, returns a new CustomMarker (google.maps.OverlayView)
           *
           */

           getMetricBubble : function getMetricBubble(metricItem, lbl, latLng, index, metricIx){

               var d = this.gridData,
                   mValues = d.gvs.items, //metric values
                   maxVal = this.bubblesMaxInfo[metricIx], //see if we have stored a max value for this metric series
                   mv = parseFloat(metricItem.items[metricIx].rv), //the value of this specific bubble
                   color = "red", //default color
                   bubbleRange = Math.abs(this.maxBubbleSize - this.minBubbleSize );

               //If we have not previously calculated the max value of this metric series, iterate through the metrics and get it
               if(!maxVal){
                   for(var i in mValues){
                       var item = mValues[i].items[metricIx],
                           v = parseFloat(item.rv) || 0; //The 'rv' field contains the data non formatted
                       if(!maxVal){
                           maxVal = v;
                       }
                       maxVal = Math.max(maxVal,v);
                   }
                   //after calculating the max value, store it
                   this.bubblesMaxInfo[metricIx] = maxVal;
               }

               //If using thresholds, use the font color for the bubble background color
               if(this.attrThresholds == "1" && (typeof metricItem.items[metricIx].ty !== "undefined" )){
                    // get threshold type
                    var ty = metricItem.items[metricIx].ty;
                    if ( ty == 2 ) {
                        // CLR
                        color = d.th[metricItem.items[metricIx].ti].n;
                    } else {
                        // use white fill if the threshold type is not CLR
                        color = "#FFF";
                    }
               }

               //Construct a new CustomMarker with the position, the bubble size, the index of the bubble and the color
               return new CustomMarker(lbl, latLng, this.minBubbleSize + Math.round((mv/maxVal) * bubbleRange), index, color);
           },

           /**
            * opens info window on specified map for specified marker
            *
            */
           openInfoWindow : function(map,marker){
                var ix = marker._ix,//index of the marker on the rows
                    w = this.getInfoWindow(map,marker);

                // if we have an info window, display it; if we are pulling the info window from a layout
                // or panel stack then it may not be available yet.
                if ( w ) {
                    //store the currently opened infoWindow
                    this.openedInfoWindow = w;
                    w.open(map,marker);
                }
           },

           /*
            * Uses the marker information to generate the info window content,
            * in a perfect world this should be called once for each marker and
            * when clicked.
            * */
           getInfoWindow : function(map,marker){
               return this.getDefaultInfoWindow(this.gridData, marker );
           },

           getDefaultInfoWindow : function getDefaultInfoWindow(d /*Data*/, marker /* marker*/){
                var ix = marker._ix,
                    // find the indexes of the labels and long data
                    mLabels = [],  //metriLabels
                    mValues = d.gvs.items,      //metric values
                    res = document.createElement("div"),
                    innerHTML = '<table><tbody><tr>' +
                                   '<td colspan="2" class="androidMap-infoWindowTitle" style="padding-right: 20px">'+ marker.title +'</td>' +
                               '</tr>';
							   
				if (d.gts.col.length != 0) {
					mLabels = d.gts.col[0].es;
				}
							   
               for(var i in mLabels){
                   var item = mValues[ix].items[i];

                   //'ts' will be 4 if using an image instead of a value
                   if(item.ts == 4){
                       var path = item.v;
                       if ( path.indexOf("http") !== 0 ) {
                           path = "../" + path;
                       }
                       innerHTML += '<tr><td class="androidMap-infoWindowText">'+ mLabels[i].n +'</td><td><img src="'+ path +'"></td></tr>';
                   } else {
                       //Default font and background colors
                       var fColor = 'black',
                           bColor = 'white';

                       //If using thresholds, use the background and font color from the data
                       if(d.th && this.attrThresholds == "1" && (typeof item.ti !== "undefined") ){
                           fColor = d.th[item.ti].n;   //font color
                       }
                       innerHTML += '<tr><td class="androidMap-infoWindowText">'+ mLabels[i].n +'</td><td style="background-color:'+ bColor +';color:'+ fColor +';">'+ item.v + '</td></tr>';
                   }
               }

               innerHTML += '</tbody></table>';

               res.innerHTML = innerHTML;

                return new google.maps.InfoWindow({
                    content: res
                });
            },
               		
            /**
             * override of touchBegin to prevent bubbling and cancel further processing of the touch
             */
            touchBegin: function(touch) {
               touch.stop();
               return false;
            },

            rebuildLayout: mstrmojo.emptyFn,

            setDimensions: function setDimensions(h, w) {
                var map = this.googleMap,
                    center = map ? map.getCenter() : null,
                    dimensionChanged = this._super(h, w);

                if ( map ) {
                    this.map.style.height = this.getHeight() + "px";
                   	this.map.style.width = (this.getWidth() - 1) + "px";
                   	map.setCenter(center);
                }
               	
                return dimensionChanged;            	
            },

            unrender: function unrn(ignoreDom) {
                if ( this.googleMap ) {
                    delete this.googleMap;
                }

            	this._super(ignoreDom);
            },
            
            destroy: function destroy() {
                if ( this.googleMap ) {
                    delete this.googleMap;
                }

            	this._super();
            }
        }
    );
})();
(function () {

	mstrmojo.requiresCls( "mstrmojo.Vis", "mstrmojo._TouchGestures", "mstrmojo.TouchScroller", "mstrmojo._HasTouchScroller");

	var legendFontFamily = "Helvetica",
		legendFontStyle = "bold 14px Helvetica",
		legendFontStyleHighlight = "bold 20px Helvetica",
		legendSwitcherBarHeight = 30,
		zf = 1;

	function resetSizeByDPI(zoomfactor){
		zf = zoomfactor;
		legendFontStyle = "bold "+ Math.round(14*zf)+"px Helvetica";
		legendFontStyleHighlight = "bold "+Math.round(20*zf)+"px Helvetica";
		legendSwitcherBarHeight = Math.round(30*zf)
	}

	function getTouchedElement(touch) {
        var item = mstrmojo.dom.findAncestorByAttr(touch.target, "clk", true, this.domNode);
        return item || null;
    }

    function setScrollerPosition() {
		var scl = this._scroller;

		var realHeight = this.height - this.legendBarSwitcher.height - 15*zf;

		var realOffSetHeight = this.legendListDiv.offsetHeight;
		if(realOffSetHeight > realHeight) {
			this.scrollPast = true;
		}
		var offsetEnd = realOffSetHeight > realHeight? realOffSetHeight - realHeight : 0;
		scl.origin = {
				x: 0,
				y: 0
		};

		scl.showScrollbars = true;
		scl.noVScroll = false;
		scl.vScroll = (offsetEnd !== 0 && scl.noVScroll !== true) || this.scrollPast;

		if (scl.vScroll) {

			scl.offset = {
					y: {
				start: 0,
				end: offsetEnd
			},
			scrollPast: this.scrollPast
			};
		}
		var icn = this.legendListDiv;
		this.utils.translateCSS(0,0,false,icn);
	}

     /**
     * A Widget to display the Time Series legend
     * @class
     * @extends mstrmojo.Vis
     */
    mstrmojo.VisTimeSeriesLegend = mstrmojo.declare(

    // superclass
    mstrmojo.Vis,

    // mixins
    [mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

    {
        /**
         * @ignore
         */
        scriptClass: 'mstrmojo.VisTimeSeriesLegend',

        /**
         * This is to set the scroll properties
         */
        scrollerConfig: {
            bounces: false,
            showScrollbars: true,
            useTranslate3d: true
        },

         /**
         * Indicates whether we support multi-touch.
         *
         * @type Boolean
         * @default false
         */
        multiTouch: true,

        /**
         * property that determines if we want to allow scrolling past the actual data to produce the stretching
         * effect
         */
        scrollPast: false,
        /**
         * property that determines if we are running on Android Tablet
         */
        isAndroidTab: false,

		  /**
	         * property that determines the width of legend
	         */
		legendBarWidth : 30,

		  /**
	         * property that determines whether the legend  is opend
	         */
		isLegendBarOpen : false,

	      /**
	         * property that determines whether the legend item is selected
	         */
         isLegendSelected:false,
	        	 /**
	     	         * property that determines the legend item index which is selected
	     	         */
         legendSelectedIndex:-1,

         maxLegendAttrLength:0,
         /**
	         * property that point to the VisTimeSeries Widget
	         */
         widget:null,
        /**
         * y interval for legend items
         */
         y_axis_interval: 25,
        /**
         * @ignore
         */
        markupString: '<div id="{@id}-legend-bar" style="position:absolute;top:{@top};right:{@right};z-index:{@zIndex};" >' +
							'<div id="{@id}-legend-switcher" class="mstrmojo-timeseries-legend-switcher" clk="S">'+
								'<canvas id="{@id}-legend-triangle" width="15px" height="17px" style="position:absolute;" ></canvas>' +
								'<div id="{@id}-legend-shadow" class="timeseries-legend-switcher-shadow" style="height:0px; width:0px;position:absolute"></div>' +
							'</div>' +
							'<div class="mstrmojo-timeseries-legend-List-Div" style="overflow:hidden;">' +
								'<div id="{@id}-legend-List" ></div>' +
							'</div>' +
							'<canvas style="z-index:-1;" clk="C"></canvas>' +
						'</div>' ,

        /**
         * @ignore
         */
        markupSlots: {
		// the element that holds the titlebar and attributes
		legendBarDiv: function(){return this.domNode;},

		// the element that holds the titlebar and attributes
		legendBarSwitcher: function(){return this.domNode.firstChild;},

		triangle: function(){return this.domNode.firstChild.firstChild;},

		// list container
		legendListDivContainer: function(){return this.domNode.childNodes[1];},
		// the element that holds the titlebar and attributes
		legendListDiv: function(){return this.domNode.childNodes[1].firstChild;},

		// the element that holds the titlebar and attributes
		legendCanvas: function(){return this.domNode.childNodes[2];}
        },

		switchLegendBar : function switchLegendBar(){
		    this.isLegendBarOpen = !this.isLegendBarOpen;

		    this.calculateAndSetLegendWidth();

		    this.widget.reDrawSlaveChartImpl();

		    this.renderLegend(true);

		     setScrollerPosition.call(this);
		},

		enableLegendGlowEffect: function enableLegendGlowEffect(index,clr){
			 var selectedLegend = this.legendListDiv.childNodes[index];
			 var color = clr || selectedLegend.style.color;
			 selectedLegend.style.textShadow = color + '0px 0px 8px';
			 selectedLegend.style.font = legendFontStyleHighlight;
		},

		hiddenLegendGlowEffect: function hiddenLegendGlowEffect(index){
			var selectedLegend = this.legendListDiv.childNodes[index];
			selectedLegend.style.textShadow = 'none';
			selectedLegend.style.font = legendFontStyle;
		},

		toggleTriangle: function toggleTriangle(open){
			var canvas = this.triangle,
				tStyle = canvas.style,
				cntx = canvas.getContext('2d'),
				ts = this.widget;

			var triH = Math.round(17*zf),
				triW = Math.round(15*zf);
			//reset canvas
			canvas.height = triH;
			canvas.width = triW;

			tStyle.top = Math.round(7*zf) + 'px';
			tStyle.left = Math.round(8*zf) + 'px';

			cntx.save();
			cntx.fillStyle =  ts.utils.rgb2rgbStr(ts.formatProp.textClr, 0.75);

			cntx.beginPath();
			if(open){
				cntx.moveTo(0,0);
				cntx.lineTo(triW, triH/2);
				cntx.lineTo(0, triH);
				cntx.lineTo(0,0);
			}else{
				cntx.moveTo(0,triH/2);
				cntx.lineTo(triW, 0);
				cntx.lineTo(triW, triH);
				cntx.lineTo(0,triH/2);
			}

			cntx.closePath();
			cntx.fill();
			cntx.restore();
		},

		renderLegend: function renderLegend(hasGlowEffect) {
			var model = this.model,
				s = model.series,
				sl = s && s.length || 0,
				h = this.height,
				utils = this.utils,
				ch = model.colHeaders,
				lc = this.legendCanvas.getContext('2d'),
				legendListDiv = this.legendListDiv,
				legendBarSwitcher = this.legendBarSwitcher;


			this.legendBarDiv.style.width = this.legendBarWidth + 'px';
			this.legendBarDiv.style.height = h + 'px';
			legendListDiv.style.width = this.legendBarWidth+ 'px';

			legendBarSwitcher.width = this.legendBarWidth;
			legendBarSwitcher.height = legendSwitcherBarHeight;
			legendBarSwitcher.style.width = this.legendBarWidth + 'px';

			this.legendCanvas.width = this.legendBarWidth;
			this.legendCanvas.height = h;

			if(this.isLegendSelected && this.legendSelectedIndex >= sl){
			/*
			 * if saved legend selected index is out of legend index, set the legend selected index to the first serie
			 * this may happend when slice
			 */
				 this.legendSelectedIndex = 0;
				 this.widget.setLegendSelected(this.isLegendSelected,this.legendSelectedIndex);
			 }

			if(legendListDiv.childNodes.length == 0){
				//render the legendAttr if haven't rendered
				for(var i = 0; i < sl; i++){
					var legendAttr = document.createElement("div");
					legendAttr.id = 'legendAttr'+i;

					legendAttr.style.font = legendFontStyle;
					legendAttr.className = 'timeseries-legendAttr';
					legendAttr.innerHTML = this.widget.getLegendName(ch,s,i);
					legendAttr.setAttribute("clk", "LA");
					legendAttr.setAttribute("vIndex",i);
					legendAttr.style.color = this.widget.getSerieColor(i) ;

					legendListDiv.appendChild(legendAttr);
					utils.changeElementSize(legendAttr,'height', utils.getScreenZoomFactor());
				}
				this.y_axis_interval = Math.max(legendAttr.offsetHeight, 25);

			}


			if(this.isLegendBarOpen){
				this.toggleTriangle(true);
				legendListDiv.style.display = 'block';

				//-15 is to make the legendName won't show at the roundRectangle corner
				this.legendListDivContainer.style.height = (h - legendBarSwitcher.height - 15*zf) + "px";
				this.legendListDivContainer.style.weight = this.legendBarWidth +"px";
				this._scroller.updateScrollBars();
				this.utils.translateCSS(0,legendBarSwitcher.height,false,this.legendListDivContainer);

				if(this.isLegendSelected){
					this.enableLegendGlowEffect(this.legendSelectedIndex);
				}
				 //draw the convas
				this.legendCanvas.height = h ;
				this.legendCanvas.style.position = "absolute";
				this.legendCanvas.style.top = "0px";
				this.legendCanvas.style.left = "0px";

				this.drawLegendOutline(h, legendBarSwitcher.height, lc);
			 }
			 else{
				this.toggleTriangle(false);

				legendListDiv.style.display = 'none';

				//draw the outline canvas
				this.legendCanvas.height = h ;
				this.legendCanvas.style.position = "absolute";
				this.legendCanvas.style.top = "0px";
				this.legendCanvas.style.left = "0px";

				this.drawLegendOutline(h, legendBarSwitcher.height, lc);
				lc.save();
				var x = this.legendBarWidth/2;
				var y = this.y_axis_interval / 2;
				var r = Math.round(5*zf);

				//make sure y < h-5 ,so that we won't draw half circle at the bottom
				for(var i = 0; i < sl && y+this.y_axis_interval< h-15*zf; i++){
					lc.fillStyle = this.widget.getSerieColor(i);
					y +=this.y_axis_interval;
					utils.drawArc(this, x, y, r, 0, Math.PI * 2, true, true, lc);
				}
				lc.restore();

			 }
			 var glowDiv = this.legendBarSwitcher.lastChild;
			 if(hasGlowEffect){
			 	glowDiv.className = "timeseries-legend-switcher-shadow";
			 	glowDiv.style.left = Math.round(15*zf) + 'px';
				glowDiv.style.top = Math.round(15*zf) + 'px';
				glowDiv.style.display = "";
				glowDiv.style.visibility = "visible"
			 }
			 else{
			 	glowDiv.className = "";
			 	glowDiv.style.visibility = "hidden";
			 }
		},

		/*
		 * called when dimension changed
		 */
        reRender: function reRender() {
        	//recalculate the legend width
        	this.calculateAndSetLegendWidth();

        	this.height = this.calculateHeight();

        	this.renderLegend(false);

        	this.legendBarDiv.style.top = this.widget.margin.t + "px";

		    setScrollerPosition.call(this);
        },

		hiddenSwitcherArrowGlowEffect: function hiddenSwitcherArrowGlowEffect(){
        	var glowDiv = this.legendBarSwitcher.lastChild;
        	//#669640
        	glowDiv.innerHTML = "";
        	glowDiv.style.visibility = "hidden";
        },

        drawLegendOutline: function drawLegendOutline(totalH, switcherH, context){
        	var utils = this.utils,
        		formatProp = this.widget.formatProp;

        	context.save();

        	context.globalAlpha = 1;
        	context.strokeStyle = utils.rgb2rgbStr(formatProp.textClr, 0.5) || '#58595B';
        	context.lineWidth = 2;
        	//15 is the radius for round corner
			utils.drawHalfRoundedRectangle(this, 1, 1, this.legendBarWidth, totalH-2, Math.round(15*zf), false, context);

			var gradient = context.createLinearGradient(0, 0, this.legendBarWidth - 2, 0);
			var topGradient = utils.rgb2rgbStr(formatProp.textClr, 0.5) || '#58595B';
			var bottomGradient = utils.rgb2rgbStr(formatProp.textClr, 0.13) || '#222222';
			gradient.addColorStop(0, topGradient);
        	gradient.addColorStop(1, bottomGradient);
        	context.strokeStyle = gradient;
			context.lineWidth = 1;
			var yPos = switcherH - 0.5;
			utils.drawLineSet(this, [{
				x: 2,
				y: yPos
			}, {
				x: this.legendBarWidth,
				y: yPos
			}], false, context);

			context.restore();
        },

		calculateMaxLegendAttrLength: function calculateMaxLegendAttrLength( useHighlightFontStyle ){
			var model = this.model,
				s = model.series,
				sl = s.length,
				ch = model.colHeaders;
			for(var i = 0; i < sl; i++){
				 var tmpLegendLength = 0;
				 var legendName = this.widget.getLegendName(ch,s,i);
				 var fontStyle = useHighlightFontStyle ? legendFontStyleHighlight  : legendFontStyle ;
				 tmpLegendLength = this.widget.getTextWidth(legendName,fontStyle);
				 this.maxLegendAttrLength = Math.max(this.maxLegendAttrLength,tmpLegendLength);
			 }
			 //+10 for the margin
			 this.maxLegendAttrLength = this.maxLegendAttrLength + 10;
		},

		calculateAndSetLegendWidth: function cLegendWidth(){

			if(this.isLegendBarOpen){
				var maxLegendBarWidth = (this.widget.getWidth() - 50)*0.3+20;
				this.legendBarWidth = Math.min(maxLegendBarWidth, this.maxLegendAttrLength);
		    }
		    else{
		    	this.legendBarWidth = Math.round(40*zf);
		    }
			this.widget.setlegendStatus(this.isLegendBarOpen, this.legendBarWidth);
		},

		calculateHeight: function cHeight(){
			var m = this.widget.margin;
			return this.widget.getHeight() - this.widget.masterChartHeight - m.t - m.b;
		},

		postBuildRendering: function postBR() {
			resetSizeByDPI(this.utils.getScreenZoomFactor());

			this.height = this.calculateHeight();

			//always selected is there is only one serie
			var sLength = this.model.series && this.model.series.length;
			if(sLength == 1){
				 this.isLegendSelected = true;
				 this.legendSelectedIndex = 0;
				 this.widget.setLegendSelected(this.isLegendSelected,this.legendSelectedIndex);
			}

			this.calculateMaxLegendAttrLength(sLength == 1);

			this.calculateAndSetLegendWidth();

			this.scrollerConfig.scrollEl = this.legendListDiv;

			if (this._super) {
				this._super();
			}

			this.renderLegend(false);

		    setScrollerPosition.call(this);

		  //  this.domNode.ontouchstart = this.widget.hiddenAllTooltip;
		},

		 initScroller: function initScroller(scroller) {
			scroller.vScroll = true;

			this._super(scroller);
		},

		touchBegin: function touchBegin(touch) {
			//hidden the slave chart tooltip, if it remain
		 	this.widget.hiddenTooltipAndShowTimeSelector();
		    // check if we have touched on clickable element if yes call handle on click ignore otherwise
		    var item = getTouchedElement.call(this, touch);
		    if (item) {
				var value = item.value;

				if (value === 'S' ){
					this.switchLegendBar();
				}else if(!this.isLegendBarOpen && value === 'C'){
					/*
					 * TQMS 663518:Ability to expand legend selector, by tapping anywhere as opposed to tapping on the left arrow.
					 */
					this.switchLegendBar();
				}

		    }
		},

		touchTap: function touchTap(touch) {

		    // check if we have touched on clickable element if yes call handle on click ignore otherwise
		    var item = getTouchedElement.call(this, touch);
		    if (item) {
				var value = item.value;
				if(value === 'LA'){
					var itemIndex = mstrmojo.dom.findAncestorByAttr(touch.target, "vIndex", true, this.domNode);
					if(itemIndex){
						this.handleLegendItemTap(parseInt(itemIndex.value, 10));
					}
				}
		    }
		},

		touchEnd: function touchEnd(touch) {
	    	var me = this;

            me.hiddenSwitcherArrowGlowEffect();


	    },

		touchSelectBegin: function touchSelectBegin(touch) {
			var item = getTouchedElement.call(this, touch);
			if (item) {
				var value = item.value;
				if (value === 'LA' ){
					var itemIndex = mstrmojo.dom.findAncestorByAttr(touch.target, "vIndex", true, this.domNode);
					if(itemIndex){
						var fontStyle = (itemIndex.value == this.legendSelectedIndex)? legendFontStyleHighlight  : legendFontStyle ;
						var tmpItemLength = this.widget.getTextWidth(item.node.innerHTML, fontStyle);

						// -2 for the border
						if(tmpItemLength > this.legendBarWidth - 12){
						//	var tooltipY = touch.pageY - this.offsetTop-25;
							var tooltipY = item.node.offsetTop -this._scroller.origin.y + this.widget.margin.t + this.legendBarSwitcher.height -5;
							this.widget.showLegendTooltip(item.node);
						}
					}
				}
			}
		},

		touchSelectEnd: function touchSelectEnd(touch) {
			this.widget.hiddenLegendTooltip();
			//this.hiddenSwitcherArrowGlowEffect();
	/*		var item = getTouchedElement.call(this, touch);
			if (item) {
				var value = item.value;
				if (value === 'LA' ){

							this.widget.hiddenLegendTooltip();

				}
			}
			*/
		},

		touchMultiBegin: function touchMultiBegin(touch){
			this.touchSelectEnd(touch);
		},

		onCrossWidgetMultitouch: function onCrossWidgetMultitouch(){
			this.widget.hiddenLegendTooltip();
			this.hiddenSwitcherArrowGlowEffect();
		},

		handleLegendItemTap:function handleLegendItemTap(vIndex){
			//always selected is there is only one serie
			if(this.model.series.length == 1){
				return;
			}
			if(this.isLegendSelected){
				if( this.legendSelectedIndex === vIndex){
					this.isLegendSelected  =  false;
					this.hiddenLegendGlowEffect(vIndex);
					this.legendSelectedIndex  = -1;
				}else{
					this.hiddenLegendGlowEffect(this.legendSelectedIndex);
					this.legendSelectedIndex =  vIndex;
					this.enableLegendGlowEffect(vIndex);
				}
			}else{
				this.isLegendSelected = true;
				this.legendSelectedIndex =  vIndex;
				this.enableLegendGlowEffect(vIndex);

			}
			this.widget.setLegendSelected(this.isLegendSelected,this.legendSelectedIndex);
			this.widget.reDrawSlaveChart();
		},

		destroy: function destroy() {
			if(this._super){
				 this._super();
			}
		}

    });

})();
(function () {

	mstrmojo.requiresCls("mstrmojo.Vis", "mstrmojo._TouchGestures", "mstrmojo.TouchScroller", "mstrmojo._HasTouchScroller", "mstrmojo.css");

	var $CSS = mstrmojo.css;
	
	var FONT_SIZE = 15;
	
	function getTouchedElement(touch) {
        var item = mstrmojo.dom.findAncestorByAttr(touch.target, "clk", true, this.domNode);
		//alert(touch.target.innerHTML);			
        return item || null;
    }
    
    function setScrollerPosition() {
		var scl = this._scroller;
	        
	    var realWidth =  this.timeSelectorListContainer.width;
		
		var realOffSetWidth = this.timeSelectorList.offsetWidth;
		if(realOffSetWidth > realWidth) {
			this.scrollPast = true;
		}
		var offsetEnd = realOffSetWidth > realWidth? realOffSetWidth - realWidth : 0;
	    scl.origin = {
				x: 0,
				y: 0
		};

		scl.showScrollbars = true;
		scl.noHScroll = false;
		scl.hScroll = (offsetEnd !== 0 && scl.noHScroll !== true) || this.scrollPast;

		if (scl.hScroll) {
			
			scl.offset = {
				x: {
					start: 0,
					end: offsetEnd
				},
				scrollPast: this.scrollPast
			};
		}
		var icn = this.timeSelectorList;
		this.widget.utils.translateCSS(0,0,false,icn);
		
	}
    
     /**
     * A Widget to display the Time Series TimeSelector
     * @class
     * @extends mstrmojo.Vis
     */
    mstrmojo.VisTimeSeriesTimeSelector = mstrmojo.declare(

    // superclass
    mstrmojo.Vis,

    // mixins
    [mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

    {
        /**
         * @ignore
         */
        scriptClass: 'mstrmojo.VisTimeSeriesTimeSelector',

        /**
         * This is to set the scroll properties
         */
        scrollerConfig: {
            bounces: false,
            showScrollbars: true,
            useTranslate3d: true
        },

        /**
         * property that determines if we want to allow scrolling past the actual data to produce the stretching
         * effect
         */
        scrollPast: false,
        /**
         * property that determines if we are running on Android Tablet
         */
        isAndroidTab: false,
		
		offsetx: 0,
         /**
	         * property that point to the VisTimeSeries Widget
	         */
        widget:null,
        /**
         * @ignore
         */
        markupString: '<div id="{@id}-TimeSelector-Container" class="mstrmojo-timeseries-timeselector-div" style="position:absolute; left:{@offsetx}px; overflow:hidden;">' +
						'<div id="{@id}-TimeSelector-List" style="position:absolute;left:0;top:0"></div>' +
					'</div>' ,
			
        /**
         * @ignore
         */
        markupSlots: {
		
			timeSelectorListContainer: function(){return this.domNode;},
			
			timeSelectorList: function(){return this.domNode.firstChild;}
		
        },
        
        toggleSelected: function toggleSelected(el, selected){
        	if(!el){
        		return;
        	}
			var style = el.style;
			var ts = this.widget;
			var textClr = ts.utils.rgb2rgbStr(ts.formatProp.textClr);//, ts.formatProp.backgroundAlpha);
			var bgClr = ts.utils.rgb2rgbStr(ts.formatProp.backgroundClr);//, ts.formatProp.backgroundAlpha);
			if(selected){
				style.backgroundColor = textClr;
				style.color = bgClr;
			}else{
				style.backgroundColor = '';
				style.color = textClr;
			}
		},
		
        
        toggleGlowEffect: function toggleGlowEffect(el, glow){
        	if(!el){
        		return;
        	}
        	if(glow){
        		$CSS.applyShadow(el, 0, 0, 20, this.widget.glowColor );
        	}else{
        		$CSS.removeShadow(el);
        	}
        },
        
        drawTimeSelectorLabels: function drwtslbls() {
		    var tsl = this.widget.baseModel.vp.rl;
		    var chartStatus = this.chartStatus;
		    
		    if (tsl) {
		        var ts = this.widget,
		            mg = ts.margin,
		            utils = ts.utils,
		            width = ts.getWidth(),
		            totalWidth = 0;
		
		        //set the container width
		        this.timeSelectorListContainer.width = width - mg.l - mg.r;
		        this.timeSelectorListContainer.style.width = (width - mg.l - mg.r) + 'px';
		        this.timeSelectorListContainer.style.height = mg.t + 'px';
		        //calculate the interval for each timeseries label at x axis
		        var d = tsl.length;
		
		        var x = (width - mg.l - mg.r) / (d + 1);
		
		        var id = ts.id,timeSelectorList = this.timeSelectorList;
		        
		        if(timeSelectorList.childNodes.length == 0){
		        	//for now keep the max time series selectors to be shown to six i.e defined in iphone specs.
		        	//render the time intervals if haven't rendered
		        	 ts.currSelection = null;
					for (var i = 0; i < d; i++) {
			            var lbl = document.createElement("div");
			            lbl.id = 'timeseries-intervals';
			            lbl.className = 'timeseries-intervals';
						
						lbl.style.fontWeight = "bold";
						lbl.style.fontFamily = "Arial";
						lbl.style.fontSize = FONT_SIZE + "px";
			            lbl.innerHTML = tsl[i].n;
			            lbl.setAttribute("clk", "S");
			            lbl.setAttribute("value", i);
			            lbl.style.position = 'relative';
			            lbl.style.whiteSpace = 'nowrap';
			            lbl.style.cssFloat = 'left';
			            
			            if (i === 0 && chartStatus.currSelectionIdx == -1 && !chartStatus.usingCustomInterval) {
			            	// if there is no currSelection and not using custom interval, then
			            	// highlight the first time interval and make it as selected
			            	this.toggleSelected(lbl, true);			               
			                ts.currSelection = lbl;
			            } else if (!chartStatus.usingCustomInterval && chartStatus.currSelectionIdx == i) {
			            	// if not using custom interval and currSelectionIdx == i
			            	// highlight the ith time interval
			            	this.toggleSelected(lbl, true);	
			                ts.currSelection = lbl;
			            }else{
			            	this.toggleSelected(lbl, false);	
			            }
			            
			            timeSelectorList.appendChild(lbl);
			
			            // get the current label width
			            offsetWidth = lbl.offsetWidth;
			            
			            totalWidth += offsetWidth;
			            
			            spaceWidth = offsetWidth < x? x - offsetWidth : 20;
			            
			            totalWidth += spaceWidth;
			            
			            if(i == 0){
							timeSelectorList.insertBefore(this.createWhiteSpace(spaceWidth) , timeSelectorList.firstChild);
							totalWidth += spaceWidth;
			            }
						timeSelectorList.appendChild(this.createWhiteSpace( spaceWidth ));
			        }
		        }else{
		        	//resize the white space
		        	var childNodes = timeSelectorList.childNodes;
		        	var childNodesLength = childNodes.length;
		        	for(var i = 0; i < childNodesLength; i ++){
		        		var lbl = childNodes[i];
		        		// get the current label width
			            offsetWidth = lbl.offsetWidth;
			            
			            totalWidth += offsetWidth;
						
						if (i == 0) {
							continue;
						}
			            
			            spaceWidth = offsetWidth < x? x - offsetWidth : 20;
			            
			            totalWidth += spaceWidth;
			            
			            if(i == 1){
			            	childNodes[0].style.paddingLeft = spaceWidth + 'px';
			            }
			            i++;
			            childNodes[i].style.paddingLeft = spaceWidth + 'px';
		        	}
		        }

		        
		        
		       this.timeSelectorList.style.width = totalWidth+'px';
		    }
	},

	postBuildRendering: function postBR() {
		
		FONT_SIZE = Math.round(15 * this.widget.utils.getScreenZoomFactor());
						
		this.scrollerConfig.scrollEl = this.timeSelectorList;
	
		if (this._super) {
			this._super();
		}

		this.drawTimeSelectorLabels();
	
	    setScrollerPosition.call(this);
	},
	
	/*
	 * called when dimension changed
	 */
    reRender: function reRender() {   	
    	
    	this.drawTimeSelectorLabels();
    	
	    setScrollerPosition.call(this);
    },
	
	createWhiteSpace: function crtWhtSpc(w){
		var spaceDiv = document.createElement("div");
		spaceDiv.style.height = '30px';
		spaceDiv.style.position = 'relative';
		spaceDiv.style.whiteSpace = 'nowrap';
		spaceDiv.style.cssFloat = 'left';
		spaceDiv.style.paddingLeft = w + 'px';
		return spaceDiv;
	},

	initScroller: function initScroller(scroller) {
			scroller.hScroll = true;

			this._super(scroller);
	},
		
	touchBegin: function touchBegin(touch) {
		//hidden the slave chart tooltip, if it remain
		this.widget.hiddenTooltipAndShowTimeSelector();
	    
	},   
    
    touchSelectEnd: function touchEnd(touch) {	    
    	var currSelection = this.widget.currSelection;
    	if(currSelection){
    		this.toggleGlowEffect(currSelection, false);   
    	}
		
    },
    
    touchSelectBegin: function touchSelectBegin(touch) {
    	var item = getTouchedElement.call(this, touch);
		if (item) {
			var value = item.value;
			if (value === 'S'){
				this.widget.timeSelectorOnClick(item);
			}
		} 
    },
    
    touchTap: function touchTap(touch) {
    	var item = getTouchedElement.call(this, touch);
		if (item) {
			var value = item.value;
			if (value === 'S'){
				this.widget.timeSelectorOnClick(item);
			}
		} 
		this.toggleGlowEffect(this.widget.currSelection, false);   
    },
    
	destroy: function destroy() {
		if(this._super){
			 this._super();
		}
		
	}
    
    
    });

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.XtabBase",
                         "mstrmojo.XtabZone",
                         "mstrmojo._TouchGestures",
                         "mstrmojo._HasXtabTouchScroll",
                         "mstrmojo._XtabSelections",
                         "mstrmojo.dom",
                         "mstrmojo.hash",
                         "mstrmojo.css",
                         "mstrmojo._HasMagnifier",
                         "mstrmojo.XtabMagnifierHelper");

    var $CSS = mstrmojo.css,
        $DOM = mstrmojo.dom;

    /**
     * Lock headers constants.
     *
     * @private
     * @refactoring Need to share these instead of copying to each class.
     */
    var LOCK_OFF = 0;
    var LOCK_ROW = 1;
    var LOCK_COL = 2;
    var LOCK_BOTH = 3;

//    /**
//     * Default configuration for pivot buttons.
//     *
//     * @private
//     */
//    var pivotButtonsConfig = {
//        2: 'To Columns',
//        1: 'To Rows',
//        l: 'Left',
//        r: 'Right',
//        u: 'Up',
//        d: 'Down'
//    };

    /**
     * Adds (or removes) the transaction dirty class to the cell node.
     *
     * @param {HTMLElement} cellNode The tablet cell for which to add (or remove) the class.
     * @param {Boolean} isDirty Whether the css class should be added or removed.
     *
     * @private
     */
    function flagUnit(cellNode, isDirty) {
        $CSS.toggleClass(cellNode.firstChild, 'tx-active', isDirty);
    }

    // Let magnifier to respond touch events
    function bringMagnifierToFront(magnifier) {
        if (magnifier) {
            magnifier.domNode.style.pointerEvents = 'auto';
        }
    }

    //TQMS 665777.
    function checkLinks() {
        // Re-check this condition here because this function can be called asynchronously
        // so the state can change between then and now.
        if (mstrMobileApp.isOnline()) {
            return;
        }

        // Build link requests to check which ones can be fulfilled via caches.
        var controller = this.controller,
            z,
            zone,
            nodes,
            node,
            cell,
            action,
            i,
            lnk,
            linkRequests = [],
            linkNodes = [],
            req;

        //TQMS 718838 We don't support disabling links in stand alone reports
        if ( ! controller.getLinkRequest) {
        	return;
        }
        for (z in this.zones) {
            if (z === '_BL' || z === '_BR') {
                zone = this.zones[z];
                nodes = zone.getNodesByPositions(zone.posMap);
                for (i = 0; i < nodes.length; i++) {
                    node = nodes[i];
                    cell = this.getCellForNode(node);
                    if (cell && cell.at && (cell.at & 4)) {
                        action = this.model.getAction(this.getActionCells(cell), null);

                        // Do we have a handler and does our controller support this handler?
                        if (action) {
                            lnk = action.a;
                            req = controller.getLinkRequest(lnk);
                            if (req) {
                                linkRequests.push(req);
                                linkNodes.push(node);
                            }
                        }
                    }
                }
            }
        }

        // Submit requests
        var count = linkRequests.length;
        if (count) {
            // On request completion enable/disable links.
            var fnSuccess = function (res) {
                var i,
                    node;
                for (i = 0; i < count; i++) {
                    node = linkNodes[i];
                    if (!res[i]) {
                    	node.setAttribute("hl_d", true);
                    	$CSS.addClass(node, "hl_d");
                    }
                }
            };

            if (mstrApp.isHosted()) {
                /*DEBUG
                window.setTimeout(function () {
                    fnSuccess([true, true]);
                },100);*/

            } else {
                this.model.getDataService().checkCachedLinkTargets(linkRequests, {
                    success: fnSuccess,
                    failure: mstrmojo.emptyFn
                });
            }
        }
    }

    //TQMS 665777.
    function onConnectivityChange() {
        if (mstrMobileApp.isOnline()) {
            var z, zone,
                nodes,
                node,
                i;
            for (z in this.zones) {
                if (z === '_BL' || z === '_BR') {
                    zone = this.zones[z];
                    nodes = zone.getNodesByPositions(zone.posMap);
                    for (i = 0; i < nodes.length; i++) {
                        node = nodes[i];
                    	node.removeAttribute("hl_d");
                    	$CSS.removeClass(node, "hl_d");
                    }
                }
            }
        } else {
            checkLinks.call(this);
        }
    }

    /**
     * <p>The widget used to display a single touch enabled MicroStrategy Crosstabbed data grid display for a Mobile device.</p>
     *
     * @class
     * @extends mstrmojo.XtabBase
     */
    mstrmojo.MobileXtab = mstrmojo.declare(
        // superclass
        mstrmojo.XtabBase,

        [ mstrmojo._TouchGestures, mstrmojo._HasXtabTouchScroll, mstrmojo._XtabSelections, mstrmojo._HasMagnifier ],

        /**
         * @lends mstrmojo.MobileXtab.prototype
         */
        {
            scriptClass: "mstrmojo.MobileXtab",

            /**
             * The number of animations per second when decelerating a scroll operation.
             *
             * @type Number
             * @default 30
             */
            frameRate: 30,

            /**
             * Whether to show magnifier when touch events get fired.
             * @type Boolean
             * @default true
             */
            enableMagnifier: true,

            useSeamlessIncFetch: false,
            
            /**
             * Allows a Xtab cell to be deselected if an option to select all is checked for its title. In other cases,
             * it will need the Xtab to have atleast a single selection.
             *  
             *  @type Boolean
             */
            allowToggleSelections: true,

            markupMethods: {
                onvisibleChange: function () { this.domNode.style.display = (this.visible) ? 'block' : 'none'; },
                onheightChange: function () { this.domNode.style.height = this.height || ''; },
                onwidthChange: function () { this.domNode.style.width = this.width || ''; }
            },

            init: function init(props) {
                this._super(props);
                this.magnifierHelper = new mstrmojo.XtabMagnifierHelper({xtab: this});
                this.disposables.push(this.magnifierHelper);
            },

            gridPagesRendered: function gridPagesRendered() {
                this._super();
                //TQMS 665777.
                checkLinks.call(this);
            },


            onRender: function onRender() {
                this._super();
                //TQMS 665777.
                var interactiveCells = this.interactiveCellsArray;
                if (interactiveCells && interactiveCells.length > 0 && this.controller.getLinkRequest) {
                    //Subscribe to connectivity events
                    if (!this.subscr) {
                        var publisher = mstrmojo.publisher;
                        this.subscr = publisher.subscribe(publisher.NO_SRC, publisher.CONNECTIVITY_CHANGED_EVENT, onConnectivityChange, this.id);
                    }

                    // Check links when all rendering is done.
                    if ((mstrApp.useBinaryFormat || mstrApp.isHosted()) && !mstrMobileApp.isOnline()) {
                        var me = this;
                        window.setTimeout(function () {
                        	try{
                        	    checkLinks.call(me);
                        	} catch (ex) {
                                // TQMS751450 capture the exception in case grid is destroyed before the timeout fishes
                        	}
                        }, 100);
                    }
                }
            },

            unrender: function unrender() {
                if (this.subscr) {
                    mstrmojo.publisher.unsubscribe(this.subscr);
                    delete this.subscr;
                }
                //Call super.
                this._super();
            },

            getDataService: function getDataService(options) {
                return this.model.getDataService();
            },

            setData: function setData(data) {
                this.set('gridData', data);
            },

            createZone: function createZone(cfg) {
                cfg = cfg || {};
                var ds = this.getDataService();
                cfg.imgCacheMap = (ds && ds.imgCache) || this.imgCacheMap;
                cfg.unCachedMap = {};

                return new mstrmojo.XtabZone(cfg);
            },

            showDownloadStatus: function showDownloadStatus() {
            },

            onclick: mstrmojo.emptyFn,

            /**
             * Setup the touch scroll nodes depending on the lock header case.
             */
            setupTNs: function setupTNs() {

                // Cache the containing table.
                var node = this.contentNode,
                    scrollBox = node.rows[1].cells[1].lastChild,
                    zIndex = 0;

                // Setup touch nodes.
                switch (this.lockHeadersCase) {
                case LOCK_OFF:
                    this._TSN.x = [ scrollBox.lastChild.lastChild ];
                    this._TSN.y = [ scrollBox.firstChild ];
                    break;

                case LOCK_COL:
                    this._TSN.x = [ node ];
                    this._TSN.y = [ scrollBox.firstChild ];
                    break;

                case LOCK_ROW:
                    this._TSN.x = [ scrollBox ];
                    this._TSN.y = [ node ];
                    zIndex = -1;
                    break;

                case LOCK_BOTH:
                    this._TSN.x = [
                        node.rows[0].cells[1].lastChild,    // Header
                        scrollBox.firstChild                // Contents
                    ];
                    this._TSN.y = [ node.rows[1] ];
                    zIndex = 2;
                    break;
                }

                // Do we need to change the zIndex of the first X scroll node?
                if (zIndex) {
                    this._TSN.x[0].style.zIndex = zIndex;
                }

                // Set offsets
                this.setOffsets();

                // Attach an event listener to hear when scrolling is done.
                this.attachEventListener('scrolledOut', this.id, this.scrolledOut);
            },

            /**
             * For xtabs that have locked headers, we always have fixed rows heights and column widths. So we optimize to
             * not use the dom to calculate the offsets.
             */
            useDomToCalculateOffsets: function useDomToCalculateOffsets() {
                return (this.lockHeadersCase === LOCK_OFF || (this._super && this._super()));
            },

            setOffsets: function setOffsets() {
                var TW = 0,                                 // Total width.
                    TH = 0;                                 // Total height.

                // Calculate the offsets.
                var lockHeadersCase = this.lockHeadersCase;

                //For Lock off case, we do not have fixed row heights and hence we calculate the dom dimensions.
                //Although Interactive Grids are Locked Col Headers by definition, we calculate the dom because of
                //possible grouping sections.
                if (this.useDomToCalculateOffsets()) {
                    var touchNodes = this._TSN,
                        xScroll = touchNodes.x[0],
                        yScroll = touchNodes.y[0];

                    // Use DOM calculations since we don't have column widths or row heights.
                    TW = xScroll.offsetLeft + xScroll.offsetWidth + (!!(lockHeadersCase & LOCK_ROW) ? this._BL.offsetWidth : 0);
                    TH = yScroll.offsetTop + yScroll.offsetHeight + (!!(lockHeadersCase & LOCK_COL) ? this._TR.offsetHeight : 0);
                } else {
                    var zones = this.zones,
                        rh = (this.gridData.rh && parseInt(this.gridData.rh, 10)) || 0,           // Row height. #616100 make sure rh is set to the rh value or zero not NAN
                        cntTopRight = zones._TR ? zones._TR.cp.rc : 0,                 // Top right zone row count.
                        cntBottomRight = zones._BR.cp.rc,              // Bottom right zone row count.
                        widthBottomLeft = zones._BL ? zones._BL.totalColWidth : 0,     // Bottom left zone total column width.
                        widthBottomRight = zones._BR.totalColWidth;    // Bottom right zone total column width.

                    TH = ((lockHeadersCase === LOCK_ROW) ? cntBottomRight : cntTopRight + cntBottomRight) * rh;
                    TW = (lockHeadersCase === LOCK_COL) ? widthBottomRight :  widthBottomLeft + widthBottomRight;
                }

                //For Mobile Xtabs in Documents, we want to check if we have the scrolling dimensions in the formatting properties.
                var HEIGHT = 1,
                    WIDTH = 2,
                    scrollWidth = this.getGridDimension(WIDTH) || 0,
                    scrollHeight = this.getGridDimension(HEIGHT) || 0;

                // We calculate the offsets by subtracting the total width from the available scroll area.  For reports smaller than
                // the scroll area, set the max and offset to 0.
                this._TMAX = {
                    x: Math.min(scrollWidth - TW, 0),
                    y: Math.min(scrollHeight - TH, 0)
                };

                if (this._super) {
                    this._super();
                }
            },

            touchTap: function touchTap(touch) {
                // TQMS 578073: Stray taps should be ignored on grid when info viewer is invoked.
                if (!this.magnifier) {
                    if (this._super) {
                        this._super();
                    }

                    // Is there no action to perform?
                    if (this.performAction(touch) === false) {
                        // Does the controller have a viewTap method?
                        var ctrl = this.controller;
                        if (ctrl && ctrl.viewTap) {
                            // Call viewTap method on controller.
                            ctrl.viewTap();
                        }
                    }
                }
            },

            performAction: function performAction(touch) {
                // Deselect any lingering cell.
                this.deselectCell();

                // Find the cell that was clicked on
                var td = $DOM.findAncestorByAttr(touch.target, 'ei', true, this.domNode);

                // Did we NOT find a td, or is the value NOT present.
                if (!td || !td.value) {
                    // Nothing to do.
                    return false;
                }

                var node = td.node,
                    cell = this.getCellForNode(node),
                    actionType = cell.at;

                if (this._super && this._super(touch)) {
                    //nothing more to do
                    return;
                }

                // Does this cell NOT have an action type?
                if (!actionType) {
                    // Nothing to do.
                    return false;
                }
                if ((actionType & 4) && ! node.getAttribute("hl_d")) {
                    var mask = document.createElement('div'),
                    	st = mask.style;
	                    id = this.id;
	
	                // Add mask to domNode.
	                mask.className = 'activeLink on';
	                st.left = node.offsetLeft + "px";
	                st.top = node.offsetTop + "px";
	                st.width = node.offsetWidth + "px";
	                st.height = node.offsetHeight + "px";
	                node.appendChild(mask);
	
	                // Set timeout to remove mask.
	                window.setTimeout(function () {
	                    // Is the domNode still rendered?
	                    var grid = mstrmojo.all[id];
	                    if (grid && grid.hasRendered) {
	                    	$DOM.attachOneTimeEvent(mask, 'webkitTransitionEnd', function () {
	                            // Remove mask when background color has faded.
	                            node.removeChild(mask);
	                        });
	
	                        // Remove on css class.
	                    	$CSS.removeClass(mask, 'on');
	                    }
	                }, 200);
                }
                this.defaultAction(node);
            },


            /**
             * Changes the appearance of the passed cell to indicate a "selected" status.
             *
             *  @param {HTMLElement} cell The cell to select.
             */
            selectCell: function selectCell(cell) {
                // Add an overlay highlight.
                var highlight = document.createElement('div'),
                    highlightStyle = highlight.style;

                highlight.className = 'overlay';
                highlightStyle.top = cell.offsetTop + 'px';
                highlightStyle.left = (cell.offsetLeft + 1) + 'px';
                highlightStyle.height = (cell.clientHeight - 2) + 'px';
                highlightStyle.width = (cell.clientWidth - 1) + 'px';

                cell.appendChild(highlight);
            },

            flagDirtyUnit: function flagDirtyUnit(cellNode) {
                flagUnit(cellNode, true);
            },

            clearDirtyUnit: function clearDirtyUnit(cellNode) {
                flagUnit(cellNode, false);
            },

            /**
             * Removes the "selected" status from the currently selected cell.
             */
            deselectCell: function deselectCell() {
                // Do we have a selected cell?
                var cell = this._selectedCell;
                if (cell) {
                    // Remove overlay.
                    cell.removeChild(cell.lastChild);

                    delete this._selectedCell;
                }
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                if (this.enableMagnifier) {
                	var controller = this.controller, magnifierConfig;
                	if (controller.getMagnifierConfig) {
                		magnifierConfig = controller.getMagnifierConfig();
                	}
                	
                    this.displayMagnifier(touch, magnifierConfig);
                }
            },

            touchSelectMove: function touchSelectMove(touch) {
                if (this.enableMagnifier) {
                    var me = this;
                    this.latestTouch = touch;
                    if (!this._moveMagnifierTimer) {
                        //Performance optimization: Put the function in a timeout to avoid too many touch events being raised because user cares more about
                        //the most recently tapped cell than those cells that the finger has moved across.
                        this._moveMagnifierTimer = setTimeout(function () {
                            me.displayMagnifier(me.latestTouch);
                            me._moveMagnifierTimer = null;
                        }, 50);
                    }
                }
            },

            touchSelectCancel: function touchSelectCancel(touch) {
                bringMagnifierToFront(this.magnifier);
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                bringMagnifierToFront(this.magnifier);
            },
            
            getCaptureDimensions: function getCaptureDimensions() {
            	var viewport = this.viewport,
            	    position = $DOM.position(this.domNode, true);
            	
            	position.w = Math.min(viewport.offsetWidth, position.w);
            	position.h = Math.min(viewport.offsetHeight, position.h)
            	
            	return position;
            }
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.ListBase",
                         "mstrmojo._IsList",
                         "mstrmojo._HasSuggestion",
                         "mstrmojo.Enum_Keys",
                         "mstrmojo.hash",
                         "mstrmojo.dom");

    var $DOM = mstrmojo.dom,
        $KEYS = mstrmojo.Enum_Keys,
        KEY_DELAY = 200,
        markup;

    var STATES = {
        DEFAULT: 1,
        ADDING: 2,
        EMPTY: 3,
        FULL: 4
    };

    var deleteCssCls = 'mstrmojo-SimpleObjectInputBox-del';

    /**
     * Shows suggestions if the input text doesn't match the previous search pattern.
     *
     * @private
     */
    function testInputText() {
        var inputBox = this.inputBox,
            text = inputBox.value;

        // Is the text different from the previous pattern?
        if (text !== this._lastPattern) {
            // Show suggestions for the new text.
            this.showSuggestion(text);
        }

        // Cache the new text as the previous pattern.
        this._lastPattern = text;

        // Delete the timer handle.
        delete this._timerHandle;
    }

    /**
     * Clears the input text compare timer if present.
     *
     * @private
     */
    function clearInputTextTimer() {
        // Do we have an input timer?
        var timerHandle = this._timerHandle;
        if (timerHandle) {
            // Clear timer.
            window.clearTimeout(timerHandle);

            // Kill handle.
            delete this._timerHandle;
        }
    }

    /**
     * Sets the default (non-adding) state on the widget.
     *
     * @private
     */
    function setDefaultState() {
    	var mx = this.maxObjectCount,
			itsLen = (this.items && this.items.length) || 0,
			isFull = (mx != null && itsLen >= mx);
	
        this.set('state', !itsLen ? STATES.EMPTY : (isFull? STATES.FULL : STATES.DEFAULT) );
    }

    /**
     * <p>A control for displaying a simple object input box that allows for addition and delete, but not edit.</p>
     *
     * <p> This control will make suggestions based on input text.
     *
     * @class
     *
     * @extends mstrmojo.ListBase
     *
     * @borrows mstrmojo._IsList
     * @borrows mstrmojo._HasSuggestion
     */
    mstrmojo.SimpleObjectInputBox = mstrmojo.declare(

        mstrmojo.ListBase,

        [ mstrmojo._IsList, mstrmojo._HasSuggestion ],

        /**
         * @lends mstmrojo.SimpleObjectInputBox.prototype
         */
        {
            scriptClass: 'mstrmojo.SimpleObjectInputBox',

            markupString: '<div id="{@id}" class="mstrmojo-ListBase mstrmojo-SimpleObjectInputBox {@cssClass}" style="{@cssText}" mstrAttach:click>' +
                              '<div class="mstrmojo-SimpleObjectInputBox-container {@icnCss}" style="{@icnCssText}">{@itemsHtml}' +
                                  '<input type="text" mstrAttach:keydown,keyup,blur style="display: none;" />' +
                              '</div>' +
                              '<div class="mstrmojo-SimpleObjectInputBox-empty"><div>{@emptyText}</div></div>' +
                           '</div>',

            markupSlots: {
                itemsContainerNode: function () { return this.domNode.firstChild; },
                scrollboxNode: function () { return this.domNode; },
                emptyTextNode: function () { return this.domNode.childNodes[1]; },
                inputBox: function () { return this.domNode.firstChild.lastChild; }
            },

            markupMethods: {
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod,
                onheightChange: mstrmojo.Widget.heightMarkupMethod,
                onwidthChange: mstrmojo.Widget.widthMarkupMethod,
                onmaxItemWidthChange: function onmaxItemWidthChange() {
                    // Is the max item width a number?
                    var w = this.maxItemWidth;
                    if (!isNaN(w)) {
                        // Add pixels.
                        w += 'px';
                    }

                    // Set max width of empty node.
                    this.emptyTextNode.style.maxWidth = w;
                }
            },

            /**
             * The field within each item that contains the text to use when the item is displayed.
             * 
             * @type String
             * @default n
             */
            itemField: 'n',

            /**
             * The text to display if the {@link mstmrojo.SimpleObjectBox} has no elements.
             * 
             * @type String
             * @default ""
             */
            emptyText: '',

            state: 0,

            /**
             * 
             */
            maxItemWidth: 'none',

            /**
             * Whether to delay before submitting input text search.
             *
             * @type Boolean
             * @default false
             */
            useKeyDelay: false,

            /**
             * The max items number supported. if 'Allow multiple selections' is disabled, the max value is set to 1
             * 
             */
            maxObjectCount: null,
            
            getItemMarkup: function (item) {
                // Have we NOT cached the markup yet?
                if (!markup) {
                    var itemField = this.itemField;
                    markup = this._super(item).replace('>{@n}<', ' title="{@' + itemField + '}"><div class="elem">{@' + itemField + '}<div class="' + deleteCssCls + '"></div></div><');
                }

                // Return cached markup.
                return markup;
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx),
                    itemField = this.itemField;

                // Update dynamic update field.
                props[itemField] = item[itemField];

                // Set max width (reduce by 24 to allow for vertical scrollbar).
                var maxWidth = this.maxItemWidth;
                if (!isNaN(maxWidth)) {
                    maxWidth = (maxWidth - 24) + 'px';
                }
                
                props.addStyle('max-width:' + maxWidth);

                return props;
            },

            getSuggestionPos: function getSuggestionPos() {
                var inputPosition = this._inputPos;

                return {
                    target: this.inputBox,
                    left: inputPosition.x,
                    top: inputPosition.y + inputPosition.h,
                    zIndex: 100
                };
            },

            getSearchPattern: function getSearchPattern() {
                return this.inputBox.value;
            },

            onSuggestionItemSelect: function onSuggestionItemSelect(item) {
                // Make sure there is no lingering text timer.
                clearInputTextTimer.call(this);

                // Set new items.
                this.set('items', this.items.concat(item));

                this._super();

                // Back into edit mode.
                var id = this.id;
                window.setTimeout(function () {
                	var obj = mstrmojo.all[id];
                	if (obj.state != STATES.FULL) {
                		obj.set('state', STATES.ADDING);
                	}
                }, 0);
            },

            onstateChange: function onstateChange(evt) {
                var state = evt.value;

                // Set empty node text visibility based on EMPTY state.
                this.emptyTextNode.style.display = (state === STATES.EMPTY) ? 'block' : 'none';

                var inputBox = this.inputBox,
                    inputStyle = inputBox.style,
                    itemsContainer = this.itemsContainerNode;

                // Are we adding?
                if (state === STATES.ADDING) {

                    // Show the input box.
                    inputStyle.display = '';

                    // Set focus into the input text box.
                    inputBox.focus();

                    // Cache the widget position for suggestion popup position.
                    this._inputPos = $DOM.position(inputBox, true);

                } else {
                    // Make sure there is no lingering text timer.
                    clearInputTextTimer.call(this);

                    // Hide input box and clear value.
                    inputStyle.display = 'none';
                    inputBox.value = '';

                    // Clear last search pattern.
                    this._lastPattern = '';
                }
            },

            postBuildRendering: function postBuildRendering() {
                // Set the current state.
                setDefaultState.call(this);
                return this._super();
            },

            preitemsChange: function preitemsChange() {
                // Set new state.
                setDefaultState.call(this);
            },

            onclick: function onclick(evt) {
                // Did the user click on a delete button?
                var target = $DOM.eventTarget(evt.hWin, evt.e);
                if (target && target.className === deleteCssCls) {
                    var item = $DOM.findAncestorByAttr(target, 'idx', true, this.domNode),
                        idx = item && parseInt(item.value, 10);

                    // Did we get a valid index of the item delete button clicked?
                    if (idx !== null && !isNaN(idx)) {
                        // Copy items.
                        var items = this.items.concat();

                        // Remove target item.
                        items.splice(idx, 1);

                        // Reset items to refresh UI and initiate server request.
                        this.set('items', items);
                    }

                    // Nothing else to do.
                    return;
                }

                if (this.state != STATES.FULL) {
                	// Enter adding mode.
                	this.set('state', STATES.ADDING);
                }
            },

            onblur: function onblur() {
                // Make sure there is no lingering text timer.
                clearInputTextTimer.call(this);

                if (!this.suggestionShown) {
                    // Click outside the input box and the suggestion popup so abandon this edit.
                    setDefaultState.call(this);
                }
            },

            prekeydown: function prekeydown(evt) {
                // What key is being pressed.
                var e = evt.e;
                switch (parseInt(e.keyCode || e.charCode, 10)) {
                case $KEYS.DOWN_ARROW:
                    this.nextHighlight();
                    break;

                case $KEYS.UP_ARROW:
                    this.preHighlight();
                    break;

                case $KEYS.TAB:
                case $KEYS.ENTER:
                    // Prevent default browser behavior.
                    $DOM.preventDefault(evt.hWin, e);

                    // Do we have a selected item?
                    var item = this.getSelected();
                    if (item) {
                        // Handle the suggestion.
                        this.handleSuggestionItemSelect(item);

                    } else {
                        // No selected item so exit.
                        this.hideSuggestion();

                        setDefaultState.call(this);

                    }
                    break;

                case $KEYS.ESCAPE:
                    // Make sure there is no lingering text timer.
                    clearInputTextTimer.call(this);

                    // No selected item so exit.
                    this.hideSuggestion();

                    setDefaultState.call(this);
                    break;
                    
                case $KEYS.BACKSPACE:
                	// is the input value is empty?
                	if (!this.getSearchPattern()) {
                		// Prevent default browser behavior.
                		$DOM.preventDefault(evt.hWin, e);

                		var items = this.items && this.items.concat();
                		if (items && items.length) {
                			// delete the last item
                			items.splice(items.length - 1, 1);
                			
                			// reset items
                			this.set('items', items);
                			
                			// keep state in adding mode
                			var id = this.id;
                			window.setTimeout(function () {
                           		mstrmojo.all[id].set('state', STATES.ADDING);
                            }, 0);
                		}
                	}
                    
                    break;

                }
            },

            prekeyup: function prekeyup() {
                // Should the search be delayed?
                if (this.useKeyDelay) {
                    var id = this.id;

                    // Do we NOT already have a timer going?
                    if (!this._timerHandle) {
                        // Create timer to called text input test.
                        this._timerHandle = window.setTimeout(function () {
                            testInputText.call(mstrmojo.all[id]);
                        }, KEY_DELAY);
                    }
                } else {
                    // Call test input text immediately.
                    testInputText.call(this);
                }
            }
        }
    );
}());
(function(){
    mstrmojo.requiresCls("mstrmojo.android.Dialog", "mstrmojo.Button");
    
    mstrmojo.android.AndroidDICPopup = mstrmojo.declare(
            mstrmojo.android.Dialog,
            
            null,
            
            {
                scriptClass: 'mstrmojo.AndroidDICPopup',

                cssClass: 'mstrmojo-AndroidDICPopup',

                autoClose: false,
                
                fadeOnClose: false,
                
                init: function init(props) {
                    this._super(props);
                    
                    this.addChildren([this.widget]);
                },
                
                close: function close(){
                    //TQMS 583616: hide the dialog first so that it won't be shown when the contained DIC is being unrendered. 
                    this.set('visible', false);
                    
                    // Unrender it so that it could be re-rendered while opened in the popup again. 
                    // Input controls rely this process to update itself.
                    if (this.widget.hasRendered){
                        this.widget.unrender();
                    }
                    // remove the input control widget from the children collection
                    this.removeChildren(this.widget);
                    
                    this._super();
                },
                
                onpopupResized: function onpopupResized(e) {
                    if(this.widget.onpopupResized) {
                        this.widget.onpopupResized(e);
                    }
                },
                
                onkeyup: function onkeyup(evt) {
                    var hWin = evt.hWin,
                        e = evt.e || hWin.event;
                    //on enter key
                    if(this.widget.applyOnEnter && e.keyCode === 13) {
                        // Call the on blur method.
                        this.onApply();
                    } else if(e.keyCode === 27) {//on escape key   
                        this.onCancel();
                    }               
                },   
                              
                onApply: function() {
                    return this.widget.applyChanges();
                },
                
                onCancel: function() {
                    this.widget.cancelChanges();
                },
                
                enableApply: mstrmojo.emptyFn
            }
    );
}());
/**
  * MobileDocXtabCanvasGraph.js
  * Copyright 2011 MicroStrategy Incorporated. All rights reserved.
  *
  * @fileoverview <p>The widget for a single HTML5 Canvas-basedv MicroStrategy Report Services Graph control on a mobile device.</p>
  * @author <a href="mailto:dhill@microstrategy.com">Doug Hill</a>
  * @version 1.0
  */
(function () {

    mstrmojo.requiresCls("mstrmojo.MobileDocXtabGraph",
                         "mstrmojo.graph._CanvasGraph");

    /**
     * @class
     * @extends mstrmojo.DocXtabGraph
     */
    mstrmojo.graph.MobileDocXtabCanvasGraph = mstrmojo.declare(
        mstrmojo.MobileDocXtabGraph,

        [ mstrmojo.graph._CanvasGraph ],

        /**
         * @lends mstrmojo.graph.MobileDocXtabCanvasGraph.prototype
         */
        {

            scriptClass: "mstrmojo.graph.MobileDocXtabCanvasGraph",
            update: function update(node) {
                delete this.graphData;

                this._super(node);
            },

            setModel: function setModel(model) {
                // _CanvasGraph assumes there will be a graph data node so retrieve it from the model now.
                this.graphData = model.data;
            },

            retrieveGraphSrc: function retrieveGraphSrc(h, w) {
                if (!this.graphData) {
                    var id = this.id,
                        parentMethod = this._super,
                        md = this.model;

                    if (parseInt(h, 10) > 0 && parseInt(w, 10) > 0) {

                        this.model.getDataService().getRWGraphImage({
                            w: w,
                            h: h,
                            k: this.k,
                            sid: this.node.data.sid
                        }, md.newCallback({
                            success: function (res) {
                                var graph = mstrmojo.all[id];

                                if(!graph) { // #710246
                                	return;
                                }
                                // Set the model.
                                graph.setModel({
                                    data: res
                                });

                                // Call the _super to render graph.
                                parentMethod.call(graph, h, w);
                                
                                var parent = graph.parent;  // #714574
                                if(parent && parent.updateScroller) {
                                	parent.updateScroller();
                                }
                                
                            }
                        }));
                    }
                } else {
                    this._super(h, w);
                }
            }
        }
    );

}());




(function () {
    mstrmojo.requiresCls("mstrmojo.android.AndroidDICPopup",
                         "mstrmojo.DefaultDIC",
                         "mstrmojo.android.inputControls.SliderDIC",
                         "mstrmojo.android.inputControls.TextFieldDIC",
                         "mstrmojo.android.inputControls.CheckBoxDIC",
                         "mstrmojo.android.inputControls.PullDownDIC",
                         "mstrmojo.android.inputControls.RadioListDIC",
                         "mstrmojo.android.inputControls.LikertScaleDIC",
                         "mstrmojo.android.inputControls.CalendarDIC",
                         "mstrmojo.android.inputControls.DateTimePickerDIC",
                         "mstrmojo.android.inputControls.TextAreaDIC",
                         "mstrmojo.android.inputControls.MarkRowDIC",
                         "mstrmojo.android.inputControls.ToggleDIC",
                         "mstrmojo.android.inputControls.SignatureDIC",
                         "mstrmojo.android.inputControls.StepperDIC",
                         "mstrmojo.android.inputControls.RatingDIC",
                         "mstrmojo.android.inputControls.BarcodeDIC",
                         "mstrmojo.android.ui.Button");

    mstrmojo.requiresDescs(221, 1442);

    var $BTN = mstrmojo.android.ui.Button.newButton,
        TEXTFIELD = 1,
        SWITCH = 2,
        LIST = 3,
        SLIDER = 4,
        CALENDAR = 5,
        TIMEPICKER = 6,
        TOGGLE = 7,
        TEXTAREA = 8,
        SIGNATURE = 9,
        RATING = 10,
        STEPPER = 12,
        BARCODE = 13,
        LIKERTSCALE = 14,
        MARKROW = 102;
        //input control owner type
//        XTAB = 1,
//        FIELDGROUP = 2;


    var $ADC = mstrmojo.android.AndroidDICConfig = mstrmojo.provide(

        "mstrmojo.android.AndroidDICConfig",

        {
            DICList: {
                1: mstrmojo.android.inputControls.TextFieldDIC,
                2: mstrmojo.android.inputControls.CheckBoxDIC,
                3: {
                    0: mstrmojo.android.inputControls.PullDownDIC,
                    1: mstrmojo.android.inputControls.RadioListDIC
                },
                4: mstrmojo.android.inputControls.SliderDIC,
                5: mstrmojo.android.inputControls.DateTimePickerDIC,
                6: mstrmojo.android.inputControls.DateTimePickerDIC,
                7: mstrmojo.android.inputControls.ToggleDIC,
                8: mstrmojo.android.inputControls.TextAreaDIC,
                9: mstrmojo.android.inputControls.SignatureDIC,
                10: mstrmojo.android.inputControls.RatingDIC,
                11: mstrmojo.DefaultDIC,
                12: mstrmojo.android.inputControls.StepperDIC,
                13: mstrmojo.android.inputControls.BarcodeDIC,
                14: mstrmojo.android.inputControls.LikertScaleDIC,
                102: mstrmojo.android.inputControls.MarkRowDIC
            },

            DICPopup: {
                getInstance: function (opener, dic) {
                    // let mstrApp create the popup for us
                    return mstrApp.showPopup({
                        scriptClass: 'mstrmojo.android.AndroidDICPopup',
                        widget: dic,
                        buttons: [ $BTN(mstrmojo.desc(221, 'Cancel'), function () {
                            this.parent.parent.onCancel();
                        }), $BTN(mstrmojo.desc(1442, 'OK'), function () {
                            return this.parent.parent.onApply();
                        }) ],
                        title: dic.popupTitle || opener.parent.title        // Use panel name if popup title not available.
                    });
                }
            },

            /**
             * Get the implementation Mojo class for different type of DIC
             */
            getDICClass: function getDICClass(dic) {
                if (dic.t === LIST) {
                    return this.DICList[dic.t][dic.st || 0];
                }
                return this.DICList[dic.t];
            },

            /**
             * If true, we should render the input control as inline and replace the content of the editable cell or text field with it.
             * @param dic {Object}
             * @param openerType {Integer} 1=xtab, 2=field group
             * @return {Boolean}
             */
            showDICByDefault: function showDICByDefault(dic, openerType) {
                if (dic.sbd === undefined) {
                    switch (dic.t) {
                    case LIST:
                        dic.sbd = (!!dic.st) ? true : false; // popup style for PullDown and inline style for RadioList
                        break;
                    case CALENDAR:
                    case TIMEPICKER:
                    case TEXTFIELD:
                    case BARCODE:
                        dic.sbd = false;
                        break; //popup only

                    case TOGGLE:
                    case SWITCH:
                    case MARKROW:
                    case RATING:
                    case STEPPER:
                    case LIKERTSCALE:
                        dic.sbd = true;
                        break;

                    default:
                        dic.sbd = (dic.dm === 1); //slider, textarea
                    }
                }

                return dic.sbd;
            },

            /**
             * It tells whether a popup dic has the preview to be rendered inside the grid cell or textfield.
             *
             * @param dic {Object}
             * @param openerType {Integer} 1=xtab, 2=field group
             * @return {Boolean}
             */
            hasDICPreview: function hasDICPreview(dic, openerType) {
                // Android always shows at least a minimal preview (see mstrmojo._HasPreviewButton.renderPreviewButton).
                return true;
            },

            isKeyNavigable: function isKeyNavigable(dic) {
                if (dic.ikn === undefined) {
                    dic.ikn = false;
                }
                return dic.ikn;
            }
        }
    );

    $ADC.TYPES = {
        TEXTFIELD: TEXTFIELD,
        SWITCH: SWITCH,
        LIST: LIST,
        SLIDER: SLIDER,
        CALENDAR: CALENDAR,
        TIMEPICKER: TIMEPICKER,
        TOGGLE: TOGGLE,
        TEXTAREA: TEXTAREA,
        SIGNATURE: SIGNATURE,
        RATING: RATING,
        STEPPER: STEPPER,
        LIKERTSCALE: LIKERTSCALE
    };

    mstrmojo.DICConfig = $ADC;
    mstrmojo.DICList = $ADC.DICList;
    mstrmojo.DICPopup = $ADC.DICPopup;
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.array",
                         "mstrmojo.string",
                         "mstrmojo.elementHelper",
                         "mstrmojo.SimpleObjectInputBox");

    var $ARR = mstrmojo.array,
        $DOM = mstrmojo.dom,
        thousandsSeperator = mstrConfig.thousandsSep;

    // Is the thousands seperator undefined?
    if (thousandsSeperator === undefined) {
        // Default to comma.
        thousandsSeperator = ',';
    }

    var ERR_SDK_E_INVALID = 0x80044033,
        ERR_SDK_E_PROMPT_NUMERICAL_VALUES = 0x80044056,
        ERR_SDK_E_PROMPT_DATE_TIME = 0x8004405D,
        MAX_SUGGESTION_POPUP_HEIGHT = 140;

    var markup;

    mstrmojo.SearchBoxSelectorList = mstrmojo.declare(

        mstrmojo.SuggestionList,

        null,

        {
            getItemMarkup: function (item, idx) {
                // Have we not cached the markup already?
                if (!markup) {
                    // Add weight token to markup.
                    markup = this._super(item, idx).replace('>{@' + this.itemField + '}<', '>{@' + this.itemField + '}{@weight}<');
                }

                return markup;
            },

            getItemProps: function getItemProps(item, idx) {
                var props = this._super(item, idx),
                    weight = item.wt;

                // Set weight.
                props.weight = (weight) ? '<em>(' + mstrmojo.num.addSeparators(weight, thousandsSeperator) + ' likes)</em>' : '';

                return props;
            }
        }
    );

    /**
     * A search box style selector.
     *
     * @extends mstrmojo.SimpleObjectInputBox
     * @class
     */
    mstrmojo.SearchBoxSelector = mstrmojo.declare(

        mstrmojo.SimpleObjectInputBox,

        null,

        /**
         * @lends mstrmojo.SearchBoxSelector.prototype
         */
        {
            cssClass: 'mstrmojo-SearchBoxSelector',

            srcid: null,

            dataSourcesXML: null,

            maxItemWidth: '',

            suggestionListClass: 'mstrmojo.SearchBoxSelectorList',

            postCreate: function postCreate() {
                var suggestionPopup = this.suggestionPopup;

                // Set suggestion popup class.
                suggestionPopup.cssClass = 'mstrmojo-SearchBoxSelector-suggest';

                // Override suggestion popup nudge method.
                suggestionPopup.nudge = function () {
                    // Do we NOT have an editor node?
                    var editorNode = this.editorNode;
                    if (!editorNode) {
                        // Nothing to do.
                        return;
                    }

                    var height = Math.min(editorNode.offsetHeight, MAX_SUGGESTION_POPUP_HEIGHT),
                        width = editorNode.offsetWidth,
                        windowDimensions = $DOM.windowDim(),
                        left = this.left,
                        top = this.top;

                    // Will the bottom of the popup be beyond the bottom of the window?
                    if (top + height >= windowDimensions.h) {
                        // Shift popup to appear above top position.
                        top -= height;
                    }

                    // Will the right of the popup be beyond the right of the window?
                    if (left + width >= windowDimensions.w) {
                        // Shift popup to appear left of the left position.
                        left -= width;
                    }

                    // Position editor node to calculated top and left position.
                    var editorNodeStyle = editorNode.style;
                    editorNodeStyle.top = top + 'px';
                    editorNodeStyle.left = left + 'px';
                };
            },

            preBuildRendering: function preBuildRendering() {
                // Compute maxItemWidth. 
                // TQMS 642768: style.width can be '100%'. 
                // To get the content node's content area width in pixels,
                // we can use offsetWidth directly since the node has no border/padding. 
                this.set('maxItemWidth', this.parent.contentNode.offsetWidth);

                this._super();
            },
            
            postBuildRendering: function postBuildRendering() {
            	var fmts = this.parent.defn.fmts;
            	//#642120, check whether we have set the height of the selector.
            	// if not, this must have been set to "fit into content", 
            	// so we should let its height to be "auto"
            	if (!fmts.height) {
            		this.domNode.style.height = "auto";
            	}
            	return this._super();
            },
            
            // overwrite original logic, the selected item will not display in the suggestion list
            filterCandidates: function filterCandidates(items, t, max) {
                var filteredCandidates = items,
                    suggestCnt = this.suggestCount;

                if (!this.noCache) {
                    // 600514 do a local starts with filter here
                    max = max || suggestCnt;
                    t = mstrmojo.string.regEscape(t);

                    var itemField = this.itemField,
                        testExp = new RegExp('^' + t, 'i');

                    filteredCandidates = $ARR.filter(items, function (item) {
                        return testExp.test(item[itemField]);
                    }, {
                        max: max
                    });
                }

                // continue to filter the selected items
                if (filteredCandidates.length) {
                    $ARR.forEach(this.items, function (item) {
                        var idx = $ARR.find(filteredCandidates, 'v', item.v);
                        if (idx > -1) {
                            filteredCandidates.splice(idx, 1);
                        }
                    });
                }

                if (filteredCandidates.length >= suggestCnt) {
                    filteredCandidates = filteredCandidates.slice(0, suggestCnt);
                }

                return filteredCandidates;
            },

            getCandidatesThroughTaskCall: function getCandidatesThroughTaskCall(params, callbacks) {
                var id = this.id,
                    targetWas = this.getSuggestionTarget(),
                    searchPattern = params.pattern || '',
                    parent = this.parent,
                    attributeId = this.srcid;

                // since we don't support search by ", we have to remove it from user input.
                searchPattern = searchPattern.replace(/"/, '');

                // Do we have an attribute ID?
                if (attributeId) {
                    // Create browseElements mojo task request parameters.
                    var taskParams = {
                        taskId: 'browseElements',
                        styleName: 'MojoAttributeStyle',
                        attributeID: attributeId,
                        dataSourcesXML: this.dsrc || '',
                        blockCount: this.REQUEST_THRESHOLD,
                        searchPattern: searchPattern,
                        browseFlags: 1
                    };

                    // Do we have a dataset ID?
                    var defn = parent.defn;
                    if (defn.dsid) {
                        taskParams.datasetID = defn.dsid;
                        taskParams.messageID = parent.model.mid;
                        taskParams.ctlKey = parent.ckey;
                    }

                    // Do we have a search form ID?
                    if (defn.sfid) {
                        // 559271. We need to send to the server a proper search form
                        taskParams.searchForms = defn.sfid;

                        // Is this a text form?
                        if (parseInt(defn.sfdt, 10) === 8) {
                            // Add wildcard to end of search pattern.
                            taskParams.searchPattern += '*';
                        }
                    }

                    callbacks.success = function (res) {
                        if (res && res.es) {
                            var box = mstrmojo.all[id],
                                target = box.getSuggestionTarget(),
                                len = res.es.length;

                            if (!res || !target || (targetWas !== target)) {//no target or target changed, do not use it
                                return;
                            }

                            // #542767. do not show the candidates list if it's too long
                            if (len && (len > box.suggestCount)) {
                                return;
                            }

                            var newPattern = target.getSearchPattern(),
                                items = res.es;

                            // Do we have an attribute ID?
                            if (attributeId) {
                                items = mstrmojo.elementHelper.buildElemsTerseID(items, attributeId, true);
                            }

                            var srcPattern = params.pattern;

                            // Cache last hit.
                            box._last_hit = {
                                items: items,
                                pattern: srcPattern
                            };

                            if (newPattern && newPattern.indexOf(srcPattern) > -1) {
                                box.updateSuggestion(box.filterCandidates(items, newPattern));
                            }
                        }
                    };

                    // TQMS 536101, 547686
                    // for search scenario, it is finally built as complete filter expression in the web server.
                    // if the date type of attr-form is not char, or user input some special string like space, are percent(%), ampersand(&), underscore(_), comma(,),
                    // will trigger exceptions in web sdk level for expression building.
                    // We can't simply change the search filter expression builder directly, because it is widely used for element search on prompts and many other places.
                    // Current work-around is we swallow these special error messages in client side, to avoid the message box pop up.
                    callbacks.failure = function (res) {
                        var ec = parseInt(res.getResponseHeader('X-MSTR-TaskErrorCode'), 10) + 0x100000000;
                        if (ec !== ERR_SDK_E_INVALID && ec !== ERR_SDK_E_PROMPT_NUMERICAL_VALUES && ec !== ERR_SDK_E_PROMPT_DATE_TIME) {
                            mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
                        }
                    };

                    mstrmojo.xhr.request('POST', mstrConfig.taskURL, callbacks, taskParams, false, null, true); // Use cache.
                }
            },

            onsuggestionItemsChange: function onsuggestionItemsChange() {
                var suggestionItems = this.suggestionItems,
                    popup = this.suggestionPopup,
                    editorNode = popup.editorNode,
                    hasScrollBar = suggestionItems && (suggestionItems.length > 8),
                    height = '',            // Default to empty.
                    px = '';                // Default to empty.

                // Is the scroll bar visible?
                if (hasScrollBar) {
                    // Change height and padding from default.
                    height = MAX_SUGGESTION_POPUP_HEIGHT;
                    px = 'px';
                }

                // Does the DOM already exist?
                if (editorNode) {
                    // Change style of dom node.
                    editorNode.style.height = height + px;

                } else if (hasScrollBar) {
                    // Add semi-colon to pixels.
                    px += ';';

                    // Change cssText on popup object.
                    popup.cssText = (popup.cssText || '') + 'height:' + height + px;
                }
            }
        }
    );
}());
(function(){

    mstrmojo.requiresCls(         
        "mstrmojo.MobileXtab", /*, mstrmojo._XtabSeamlessIncrementalFetch */
        "mstrmojo._HasMagnifier"
       );
    
    /**
     * Overflow constants
     */
    var OVERFLOW_A = "overflow:auto",
    	OVERFLOW_H = "overflow:hidden",
    	$DOM = mstrmojo.dom;
    
    /**
     * Utility function called whenever the height or width changes.
     * 
     * @param {mstrmojo.iXtab} xtab The current iXtab instance.
     * @param {String} dimension Either 'Height' or 'Width'.
     * 
     * @returns Boolean true if the change was performed, false otherwise.
     * 
     * @private
     */
    function dimensionChange(xtab, dimension) {
        // Do we have a dom?
        var dn = xtab.domNode;
        if (!dn) {
            // NO, then nothing to do.
            return false;
        }
        
        var lcDimension = dimension.toLowerCase(),
            x = xtab[lcDimension],
            intValue = parseInt(x, 10),
            isWidth = (dimension === 'Width');
        
        dn.style[((isWidth) ? 'left' : 'top')] = 0;
        dn.style[lcDimension] = x;
        xtab.contentNode.parentNode.style[lcDimension] = x;
        xtab['scrollbox' + dimension] = intValue;
        
        return true;
    }
    
    /**
     * Create magnifier content based on a given row object
     * @param {Object} row An object contains the information of a give row 
     *   
     * @returns String return a markup string
     * 
     * @private
     */
    function _createMagnifierContent(row) {
        
        var mks = [];
        mks.push('<table style="border-spacing:0px 0px;background:white;border-collapse:collapse;table-layout:auto">');
        
        var addRow = function(l, r, selected) {
            
            var addCell = function(c, cs, s) {          
                if(c && c.ts === 4) { // BASEFORM_PICTURE                        
                    mks.push('<td ' + ' class="' + (c.css || '') + (s ? ' xtab-selected-cell': '') + '" ><img src="' + (c.n || c.v) + '"/></td>');
                } else {
                    mks.push('<td ' + ' class="' + (c.css || '') + (s ? ' xtab-selected-cell': '') + '" style="white-space:nowrap;' + cs + '">' + (c.n || c.v || '&nbsp;') + '</td>');
                }
            };

            mks.push('<tr>');
            addCell(l, 'text-decoration:none;text-align:right !important');
            addCell(r, 'text-decoration:none;text-align:left !important', selected);
            mks.push('</tr>');
        };
        
        var si = row.si, //selected index
        hds = false,
        rc = row.th.length;
    
        for(var i = 0, len = row.rh[0].length; i < len; i++) {
            var rt = row.th[0][i]; 
            if(rc > 1 && i === len -1) { //the last row header
                rt = row.th[rc - 1][0];
            }            
            if(i == si) {
                addRow(rt , row.rh[0][i], true);
                hds = true;
                break;
            }
            addRow(rt, row.rh[0][i]);
        }
        
        var metrics = null;
        if(!hds) {
            for(var j = 0, jLen = row.ch.length; j < jLen; j++) {
                var m = i;
                for(var k = 0, kLen = row.ch[j].length; k < kLen; k++) {
                    var c = row.ch[j][k],
                        cs = (c && c.cs) || 1;
                    
                    if((si >= m) && (si < m + cs)) {
                        if(c.mix !== undefined) { //metrics
                            metrics = c;
                        } else {
                            addRow(j == 0 ? row.th[0][i-1] : row.th[j][0] , c);
                        }
                        break;
                    }
                    m += cs;
                }
            }
            addRow(c, row.vs[0][si-i], true);
        }
        
        mks.push('</table>');
        return mks.join('');        
    }
    
    function findTD (event) {
        var td = event.target;
        while(td && td.tagName != 'TD') {
            td = td.parentElement;
        } 
        return td;
    }
    
    /**
     * iXtab is a crosstabbed data grid display for iPhone.  
     *
     * <p>The widget for a single MicroStrategy Report Services Crosstabbed data grid display.</p>
     * 
     * <p>Or at least, that's how it appears.  It is actually a container with up to 4 child widgets, each of which is a XtabZone instance.  The HTML of
     * the Xtab is typically a 2x2 HTML table, whose cells contain the HTML of each XtabZone.  The 2x2 HTML table of the Xtab is wrapped in a 
     * non-scrolling div, called the "viewport" of the Xtab.  The viewport node does not scroll; however, the bottom-right cell of the 2x2
     * table does have a scrolling div (called the "scrollboxNode" of the Xtab), which contains the HTML of the bottom-right XtabZone width.  
     * This HTML arrangement allows us to produce a "locked headers" effect.</p>
     * 
     * @class
     * @extends mstrmojo.Container
     * 
     */
    mstrmojo.iXtab = mstrmojo.declare(
        // superclass
        mstrmojo.MobileXtab,
        
        [ mstrmojo._FillsBrowser, mstrmojo._HasMagnifier /*, mstrmojo._XtabSeamlessIncrementalFetch */],
        
        /** 
         * @lends mstrmojo.iXtab.prototype
         */
        {            
            scriptClass: "mstrmojo.iXtab",

            scrollboxHeightFixed: false,
            
            //allows enabling Menus and other interactivity on the iXtab
            enableXtabInteractivity: false,
            
            // for adjust the row number for the value content provider 
            rowAdjust: 0,
            
            /**
             * Sets the renderMode of the "BOTTOMRIGHT" and "BOTTOMLEFT" XtabZones. This property value
             * is simply passed down to the child widgets; it does not affect the rendering of the 
             * Xtab widget itself.
             */
            preBuildRendering: function preBuildRendering() {
        		// for iphone, we want to make sure that the rpp of the Grid is the same as what the content provider has. hence the setting below. 
        		this.numRowFixed = true;
        		
                //Set the overflow to hidden by default
                this.scrollboxNodeOverflow = OVERFLOW_H;                                
                                                
        		//Do we want interactivity? Create an instance of toolbar manager
        		if (this.enableXtabInteractivity) {
                    mstrmojo.requiresCls("mstrmojo._iToolbarMgr");                  
        			this.toolbarMgr = "mstrmojo._iToolbarMgr";
                }
                                
                // trigger the parent's prebuild rendering. 
                return this._super();
            },
            
            postBuildRendering: function postBuildRendering() {
                // trigger the parent's prebuild rendering. 
                var rtn = this._super();
                
                // Setup the mask.
                var msgNode = this.msgNode,
                    maskNode = this.maskNode,
                    evtName = $DOM.CSS3_TRANSITION_END,
                    $DAE = mstrmojo.dom.attachEvent,
                    $PAF = mstrmojo.css.parkAfterFade;

                // Hijack the message node for displaying the loading message.
                msgNode.style.height = 'auto';
                msgNode.style.width = 'auto';
                    
                // Attach an event for when the mask opacity is done animating.
                $DAE(maskNode, evtName, $PAF);
                
                // Attach an event for when the message is done animating.
                $DAE(msgNode, evtName, $PAF);

                // Set a timeout to fade the mask.
                var me = this;
                window.setTimeout(function() {
                    maskNode.style.opacity = 0;
                    me.clearTransitionCurtain();
                    
                    // request for image caching
                    var ic = me.imgCacheMap;
                    if(ic && ic.unCachedImg && ic.unCachedImg.length > 0) {
                        if(me.model && me.model.cacheImages) {
                            me.model.cacheImages(ic.unCachedImg.join(',,,'));
                        }
                    }
                    
                }, 400);
                
                if (this.enableXtabInteractivity) {
                //create toolbar manager object
                this.requiresContrib("toolbarMgr", true);
                }
                
                if(this.lockHeadersCase == LOCK_OFF || this.lockHeadersCase == LOCK_ROW) {
                    this.rowAdjust = this.chsCP.rc || 0;
                }                
                
                return rtn;                                
            },
            
            setTransitionCurtain: function setTransCurtn(/*DOMNode*/domNode) {
                if(domNode) {
                    domNode.style.zIndex = 20;
                    this.transitionCurtain = domNode;                    
                }
            },
            
            clearTransitionCurtain: function clrTransCurtn() {
                var curtain = this.transitionCurtain;
                if(curtain) {
                    var curtainStyle = curtain.style;
                    
                    //when transition curtain fades out, we set the 
                    window.setTimeout(function() {
                        curtainStyle.zIndex = -1;                        
                        curtain.innerHTML = "";
                    }, 10);
                    curtainStyle.opacity = 0;               
                }
            },
            
            performAction: function performAction(touch) {
                // Deselect any lingering cell.
                this.deselectCell();
                
                // Find the cell that was clicked on
                var td = mstrmojo.dom.findAncestorByAttr(touch.target, 'ei', true, this.domNode);
                
                // Did we NOT find a td, or is the value NOT present.
                if (!td || !td.value) {
                    //todo0: need a good way to handle view specific actions rather than let model to handle it
                    if(this.controller.touchTap) {
                        this.controller.touchTap();
                    }
                    return;
                }
                
                var node = td.node;
                this.defaultAction(node);
            },            
            
            /**
             * Display the floating menu if the activity is enabled.
             * 
             * @param {HTMLElement} cell The table cell that initiated this action.
             * @param {Object[]} actions An array of objects that describe each action.
             * 
             * @returns boolean True if the cell should be selected.
             */
            updateActionMenu: function updateActionMenu(cell, actions) {
                if(this.enableXtabInteractivity && this.toolbarMgr) {
                    this.toolbarMgr.showToolbar(cell, actions, this);
                    
                    // Return true so that the cell gets selected.
                    return true;
                } else {
                    //unselect cell
                    return false;
                }
            },
            
            /**
             * Custom handler to improve resize performance.
             * 
             * @see mstrmojo._FillsBrowser
             * 
             * @param {Object} size An object with height ('h') and width ('w') values.
             * @return Boolean true if we don't want the default behavior to occur.
             */
            browserResized: function browserResized(size) {
                if (this.height !== size.h || this.width !== size.w) {
                    // Silently set height and width.
                    this.height = size.h;
                    this.width = size.w;
                    
                    // Call handlers for each.
                    var w = dimensionChange(this, 'Width'),
                        h = dimensionChange(this, 'Height');
                    
                    // Did either handler succeed?
                    if (w || h) {
                        // YES, did height succeed and are column headers locked?
                        //if (h && this.lockHeadersCase === LOCK_COL) { 
                            // Reduce the height of SCROLLAREA.y by the height of the locked headers.
                            //TODO: Use _HasLayout to calculate the height of the scrollable area instead.
                            //SCROLLAREA.y -= 24;
                        //}
                        
                        // Set offsets since height and width changed.
                        this.setOffsets();
                    }
                    
                    return true;
                }
                
                return false;
            },
            
            scrolledOut: function scrolledOut(e) {
                var abs = Math.abs,
                    off = {
                        x: 0,
                        y: 0
                    },
                    axis = e.axis,
                    limit = (0.20 * parseInt(axis === 'x' ? this.width : this.height, 10)),
                    max = abs(this._TMAX[axis]),
                    min = this._TMIN[axis],
                    value = e.value;
                
                //If we use seamless incremental fetch, we do not want to send a swipe for incremental
                //fetch.
                if (axis == 'y' && this.useSeamlessIncFetch) {
                    return;
                }
                
                //Check have we scrolled out of bounds.    
                if ((value > (limit + max)) || (value < (min - limit)) ) {
                    off[axis] = value;
                    
                    //Tell the model that a valid swipe gesture has been made.
                    //todo0: need a good way to handle view specific actions rather than let model to handle it
                    this.controller.swipe({
                        cmd: e.direction,
                        offX: off.x,
                        offY: off.y
                    });
                }
            },
            
            createZone: function createZone(cfg) {
                cfg = cfg || {};
                cfg.tbodyStyle = "background-color:white;";
                
                return this._super(cfg);
            }
        }
    );
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.MobileXtab",
                         "mstrmojo.array",
                         "mstrmojo.hash");

    /**
     * Removes the stylesheet associated with this xtab.
     *
     * @private
     */
    function removeStyleSheet() {
        var xtabStyleSheet = this.xtabStyleSheet,
            parentNode =  xtabStyleSheet && xtabStyleSheet.parentNode;

        //Delete the lingering CSS styles created for this Xtab.
        if (parentNode) {
            parentNode.removeChild(xtabStyleSheet);

            //delete the widget property
            delete this.xtabStyleSheet;
        }
    }

    /**
     * <p>A widget to display an Android specific MobileXtab.</p>
     *
     * @class
     * @extends mstrmojo.MobileXtab
     */
    mstrmojo.AndroidXtab = mstrmojo.declare(
        // superclass
        mstrmojo.MobileXtab,

        null,

        /**
         * @lends mstrmojo.AndroidXtab.prototype
         */
        {
            scriptClass: "mstrmojo.AndroidXtab",

            /**
             * Overrides the default friction on the scroller
             *
             * @type Number
             * @default 0.0021
             */
            scrollerFriction: 0.0015,

            preBuildRendering: function preBuildRendering() {
                // Remove any lingering style sheets.
                removeStyleSheet.call(this);

                // Update style sheet with new data.
                this.updateXtabStyles(this.model.data.cssString);

                // Call super.
                this._super();
            },

            /**
             * Handles auto fit to window xtabs by adjusting the size of the scrollbox node so the Xtab renders correctly.
             */
            onwidthChange: function onwidthChange() {
                //Is the grid in auto fit to window mode?
                if (this.gridData.afw) {
                    var sbn = this.scrollboxNode,
                        width = this.width;

                    //Have we rendered already?
                    if (sbn) {
                        sbn.style.width = width;
                    } else {
                        this.scrollboxNodeCssText = 'width: ' + width;
                    }
                }

                // Call super
                if (this._super) {
                    this._super();
                }
            },

            /**
             * This function sets the grid's css onto the browser by appending it into a style node created (if it does not exist already) under the head node.
             *
             * @param css The css string to be appended to the style node.
             */
            updateXtabStyles: function updateXtabStyles(css) {
                // Add the grid css on the head of the page.
                if (!this.xtabStyleSheet) {
                    this.xtabStyleSheet = document.getElementsByTagName('head')[0].appendChild(document.createElement('style'));
                }

                // Append CSS to the style sheet.
                this.xtabStyleSheet.appendChild(document.createTextNode(css));
            },

            /**
             * Removes xtab associated style sheet.
             *
             * @ignore
             */
            unrender: function unrender(ignoreDom) {
                this._super(ignoreDom);

                // Remove any lingering style sheets.
                removeStyleSheet.call(this);
            },
            
            getMaskNode: function getMaskNode() {
                var div = document.createElement('div');
                div.appendChild(this.xtabStyleSheet.cloneNode(true));
                div.appendChild(this.domNode.cloneNode(true));
                
                return div;
            },

            /**
             * Caches the actions in case the user requests to show the menu.
             *
             * @param {HTMLElement} cell The table cell that initiated this action.
             * @param {Object[]} actions An array of objects that describe each action.
             *
             * @returns boolean True if the cell should be selected.
             */
            updateActionMenu: function updateActionMenu(cell, actions) {
                // Cache the action in case the menu is requested later.
                this._selectionActions = actions;

                // Return true so that the cell gets selected.
                return true;
            },

            setModel: function setModel(model) {
                this._super(model);

                // Make request for page by data.
                this.controller.getPageByTree(false);
            },

            deselectCell: function deselectCell() {
                this._super();

                // Kill the current actions.
                delete this._selectionActions;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.maps.jsmap.AndroidMap");

    /**
     * <p>A widget to display a report based Google Map Widget on the Android platform.</p>
     */
    mstrmojo.maps.jsmap.AndroidRptMap = mstrmojo.declare(
        /**
         * Superclass
         */
        mstrmojo.maps.jsmap.AndroidMap,

        /**
         * Mixins
         */
        null,

        {
            scriptClass: 'mstrmojo.maps.jsmap.AndroidRptMap',

            setModel: function setModel(model) {
                this._super(model);

                // Make request for page by data.
                this.controller.getPageByTree(false);
            }
        }
    );
}());
/**
 * AndroidDocMap.js
 * Copyright 2011 MicroStrategy Incorporated. All rights reserved.
 * @version 1.0
 * @fileoverview <p>Android flavour of Map contained in RW documents.</p>
 * @author <a href="mailto:dhill@microstrategy.com">Doug Hill</a>
 */

(function () {
    mstrmojo.requiresCls("mstrmojo.maps.jsmap.AndroidMap",
                         "mstrmojo.maps.jsmap.AndroidDocMapInfoWindow",
                         "mstrmojo.Overlay",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.dom");

    var $DOM = mstrmojo.dom;

    /**
     * <p>A widget to display an Android specific Android Map in RW documents.</p>
     *
     * This is intended to live inside an AndroidView widget as the contentChild.
     *
     * @class
     * @extends mstrmojo.Box
     */
    mstrmojo.maps.jsmap.AndroidDocMap = mstrmojo.declare(
        mstrmojo.maps.jsmap.AndroidMap,

        [ mstrmojo._Formattable ],

        {
            scriptClass: "mstrmojo.maps.jsmap.AndroidDocMap",

            cssClass: "mstr-googleMapView",

            formatHandlers: {
                domNode: ['left', 'top', 'z-index', 'height', 'width', 'border', 'border-color', 'border-style', 'border-width' ]
            },

            sc: null,

            getMapModel: function getMapModel() {
                var d = this.doc,
                    m = d.model,
                    pid = mstrApp.getCurrentProjectId(),
                    sessions = mstrApp.serverProxy.getSessions();

                return {
                    pid: pid,
                    sessions: sessions,
                    model: this.model,
                    docData: {
                        did: d.did,
                        ttl: d.ttl,
                        st: d.st,
                        mid: m.mid,
                        bs: m.bs,
                        data: m.data,
                        defn: m.defn
                    },
                    cfg: mstrApp.getConfiguration().getConfiguration()
                };
            },

            /**
             * Overridden to listen to touch manager and close open info windows when a touch occurs.
             *
             * @ignore
             */
            postBuildRendering: function postBuildRendering() {
                // Attach a listener for touchesBegin.
                this._touchListener = mstrmojo.touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                    // Do we have an open info window?
                    var openInfoWindow = this.openedInfoWindow;
                    if (openInfoWindow) {
                        // Is the target of the touch not contained within our widget AND there is no dialog open?
                        if (!$DOM.contains(this.domNode, evt.touch.target, true, document.body) && !mstrApp.isDialogUp()) {
                            // Close info window.
                            openInfoWindow.close();
                        }
                    }
                });

                return this._super();
            },

            destroy: function destroy(ignoreDom) {
                // Do we have a touch listener?
                var listener = this._touchListener;
                if (listener) {
                    // Detach event listener and delete listener handle.
                    mstrmojo.touchManager.detachEventListener(listener);
                    delete this._touchListener;
                }

                this._super(ignoreDom);
            },

            setModel: function setModel(d) {
                // our containing mobile doc is assumed to be the controller's content view
                this.doc = d.controller.view;
                this._super(d);
            },

            initFromVisProps: function initFromVisProps(vp) {
                this._super(vp);

                if (!vp) {
                    return;
                }

                this.iwDocLayout = (parseInt(vp.dl, 10) === 1);

                // get the type of map we're supposed to display
                if (vp.lyt) {
                    this.iwLayoutKey = vp.lyt;
                }
            },

            /**
             * find info window panel stack defn
             */
            findSelectorTarget: function findSelectorTarget(sc) {
                if (sc && sc.tks) {
                    var dm = this.model.docModel,
                        targets = sc.tks.split('\u001E'),
                        i = 0,
                        len = targets.length;

                    for (i = 0; i < len; ++i) {
                        var d = dm.getTargetDefn(targets[i]);
                        if (d[targets[i]].ifw) {
                            return targets[i];
                        }
                    }
                }
            },

            showInfoWindow: function showInfoWindow(mp, mkr, w) {
                this.openedInfoWindow = w;
                w.open(mp, mkr);
            },

            /*
             * Uses the marker information to generate the info window content,
             * in a perfect world this should be called once for each marker and
             * when clicked.
             **/
            getInfoWindow: function getInfoWindow(map, marker) {
                var gd = this.gridData;

                // is this a doc layout info window?
                if (this.iwDocLayout) {

                    // YES, we must load the layout async. and then display the window
                    this.getInfoWindowFromLayout(gd, map, marker, this.showInfoWindow);

                } else {

                    var sc = this.getInfoWindowSelectorControl(gd),
                        firstInfoWinKey = this.findSelectorTarget(sc);

                    // is there a selector target that is an info window?
                    if (!(!!sc && firstInfoWinKey)) {
                        // no, display the default info window
                        return this.getDefaultInfoWindow(gd, marker);
                    }

                    // NOTE: info windows from panel stacks will be created in postHandleMarkerClick()
                }
            },

            getInfoWindowFromLayout: function getInfoWindowFromLayout(d, map, marker, callback) {
                // Get the attribute id from the marker, we need it for send it to the task
                var ths = this,
                    doc = this.doc,
                    layouts = doc.getLayouts(),
                    lyt = this.iwLayoutKey,
                    layout = layouts[mstrmojo.array.find(layouts, 'k', lyt)],
                    sep = "\x1F",
                    dssXmlTypeAttribute = "12",
                    // EnumDSSXMLObjectTypes.DssXmlTypeAttribute
                    // GROUPBY ID = attribute ID + sep + ObjectType(12) + sep + element ID
                    gbIDs = marker.attrid + sep + dssXmlTypeAttribute + sep + marker.eid;

                var taskParams = {
                    layoutKey: lyt,
                    groupByIDs: gbIDs
                };

                doc.selectLayout(layout, (lyt !== doc.model.currlaykey), {
                    complete: function () {

                        layout.defn.loaded = false;

                        doc.getNewLayout(taskParams, layouts, false, {
                            complete: function () {
                                mstrApp.hideMessage();
                            },
                            submisson: function () {
                                mstrApp.showMessage();
                            },
                            success: function (res) {
                                var node = res.node, overlay,
                                    content = document.createElement('div'),
                                    contentStyle = content.style,
                                    w = node.defn.fmts.width,
                                    h = node.defn.fmts.height || node.data.mh; //get minimum layout height if no format height defined

                                overlay = new mstrmojo.Overlay({
                                    children: [res]
                                });
                                //set the dimensions
                                overlay.set('width', w);
                                overlay.set('height', h);

                                // create element to act as layout containerNode
                                var cn = document.createElement('div');
                                overlay.placeholder = cn;
                                overlay.render();

                                contentStyle.overflow = "hidden";
                                content.appendChild(overlay.domNode);

                                var win = new google.maps.InfoWindow({
                                    content: content
                                });

                                //callback.call(ths, map, marker, win);
                                ths.openedInfoWindow = win;
                                win.open(map, marker);

                                var INTERVAL = 300,
                                    t = 0,
                                    ti = window.setInterval(function () {
                                        var n = content.parentNode;
                                        if (n) {
                                            var ow = n.offsetWidth,
                                                oh = n.offsetHeight;
                                            if (ow !== parseInt(w, 10) || oh !== parseInt(h, 10)) {
                                                overlay.setDimensions(oh + 'px', ow + 'px');
                                                window.clearTimeout(ti);
                                            }
                                        }
                                        t += INTERVAL;
                                        //if it exceeds the maximum time we can wait, we assume the google bubble size is the same size
                                        //as we initially set on the layout
                                        if (t > 10 * INTERVAL) {
                                            window.clearTimeout(ti);
                                        }
                                    }, INTERVAL); //use interval to check the google bubble height
                            }
                        }, true);
                    }
                });
            },

            getInfoWindowSelectorControl: function getInfoWindowSelectorControl(d) {
                if (!this.sc) {
                    // we assume that the first attribute on the rows has the selector control
                    this.sc = d.gts.row[0].sc;
                }
                return this.sc;
            },

            /**
             * Called after info window has been displayed in response to user click on map marker;
             *
             * For documents, if the info window was generated from a layout or we are using the default window, then
             * we need to also check for any document elements that the grid may be targeting and make sure they get updated.
             * For panel stack info windows, we have already done this when we called setDocSelectorElements().
             */
            postHandleMarkerClick: function postHandleMarkerClick(map, marker) {

                var d = this.gridData,
                    sc = this.getInfoWindowSelectorControl(d);

                if (sc && sc.tks) {
                    var ths = this,
                        dataCacheUpdate = null,
                        dm = ths.model.docModel;

                    dm.getDataService().setDocSelectorElements(sc.ck, marker.eid, sc.ckey, sc.include, {
                        success: function (res) {

                            // The collection of target definitions for this slice.
                            var tgtDefs = dm.getTargetDefn(sc.tks);

                            // With new partial update mechanism
                            if (res.pukeys) {
                                tgtDefs = dm.getTargetDefn(res.pukeys);
                            }

                            // Update this DocModel's "dataCache" with a hash of all the partial update nodes which are either targets or descendants of targets.
                            // Returned is an object with information about widgets that need to be updated as a result of this operation.
                            // update the data cache with the new data for the target
                            dataCacheUpdate = dm.updateDataCache(res.data, tgtDefs);

                            var firstInfoWinKey = ths.findSelectorTarget(sc);

                            // do we have a target that is an info window?
                            if (firstInfoWinKey) {
                                // create the info window for the map marker using the data from the partial update.  We render the first
                                // panel stack with the ifw property set for use as the window's content.

                                var targetDef = dm.getTargetDefn(firstInfoWinKey),
                                    psId = "*l" + res.currlaykey + "*k" + firstInfoWinKey + "*x1*t" + dm.buildTime,
                                    id = psId + "_ifw",
                                    widget = mstrmojo.all[id];

                                // if we have already created an info window then destroy it
                                if (widget) {
                                    widget.destroy();
                                }

                                // create a map info window.  Note that we don't use the DocInfoWindow because it is anchorable
                                // and we don't have the anchor - Google's map does.
                                var ifw = new mstrmojo.maps.jsmap.AndroidDocMapInfoWindow({
                                    id: id,
                                    parent: ths,
                                    builder: ths.builder,
                                    model: dm,
                                    psKey: firstInfoWinKey,
                                    psId: psId
                                });

                                // Retrieve formats and create content node.
                                var fmts = targetDef[firstInfoWinKey].fmts,
                                    content = document.createElement('div'),
                                    contentStyle = content.style,
                                    w = fmts.width,
                                    h = fmts.height;

                                //set the dimensions
                                ifw.set('width', w);
                                ifw.set('height', h);

                                // create element to act as containerNode and render the info window.
                                var cn = document.createElement('div');
                                ifw.placeholder = cn;
                                ifw.render();

                                contentStyle.height = h;
                                contentStyle.width = w;
                                contentStyle.overflow = "hidden";
                                content.appendChild(ifw.domNode);

                                // create the info window passing the rendered panel stack as the content
                                var iw = new google.maps.InfoWindow({
                                    content: content
                                    // ,
                                    // maxWidth: parseInt(targetDef[firstTargetKey].fmts.width,10)
                                });

                                // Wrap the google infowindow close method.
                                var fnClose = iw.close;
                                iw.close = function () {
                                    // Close the google info window.
                                    fnClose.call(iw);

                                    // Destroy the mojo info window.
                                    ifw.destroy();

                                    // Kill reference to opened info window.
                                    delete ths.openedInfoWindow;
                                };

                                // call the callback to display the info window
                                // ths.showInfoWindow(map, marker, iw);

                                ths.openedInfoWindow = iw;
                                iw.open(map, marker);

                                var INTERVAL = 300,
                                    t = 0,
                                    ti = window.setInterval(function () {
                                        var n = content.parentNode;
                                        if (n) {
                                            var ow = n.offsetWidth,
                                                oh = n.offsetHeight;
                                            if (ow !== parseInt(w, 10) || oh !== parseInt(h, 10)) {
                                                ifw.setDimensions(oh + 'px', ow + 'px');
                                                window.clearTimeout(ti);
                                            }
                                        }
                                        t += INTERVAL;
                                        //if it exceeds the maximum time we can wait, we assume the google bubble size is the same size
                                        //as we initially set on the layout
                                        if (t > 10 * INTERVAL) {
                                            window.clearTimeout(ti);
                                        }
                                    }, INTERVAL); //use interval to check the google bubble height






                            }

                            // to update any other targets we have the doc model raise an partialUpdate event.  Other
                            // widgets that need updating will be listening for this event and update accordingly.
                            var ue = {
                                name: 'partialUpdate',
                                tree: res.data,   // Partial update tree.
                                ids: dataCacheUpdate
                            };

                            //if has info window, pass on the position.
                            if (!mstrmojo.hash.isEmpty(ue.ids.ifws)) {
                                // delete the info window from the array of info windows that need updating
                                delete ue.ids.ifws[firstInfoWinKey];
                            }

                            // Raise the 'partialUpdate' event so the doc widgets will hear it.
                            dm.raiseEvent(ue);
                        }
                    }, dm.zf, true);
                }
            }
        }
    );
}());
/**
 * AndroidDocMap.js
 * Copyright 2011 MicroStrategy Incorporated. All rights reserved.
 * @version 1.0
 * @fileoverview <p>Android flavour of Map contained in RW documents.</p>
 * @author <a href="mailto:dhill@microstrategy.com">Doug Hill</a>
 */

(function () {
    mstrmojo.requiresCls("mstrmojo.maps.androidmap.AndroidMap",
                         "mstrmojo.maps.androidmap.AndroidDocMapInfoWindow",
                         "mstrmojo.Image",
                         "mstrmojo.DynamicClassFactory",
                         "mstrmojo.Box",
                         "mstrmojo._HasLayout",
                         "mstrmojo.DocPanel",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo.dom");

    var $DOM = mstrmojo.dom;

    var REGULAR_SIZE = 0,
        FULL_SCREEN = 1,
        $H = mstrmojo.hash;
   
    function adjustFormat(fmt) {
    	if (!fmt || !fmt.p_fmts) return fmt;
    	var panel_fmt = fmt.p_fmts;
    	var panel_top = parseInt(panel_fmt.top)||0;
    	var panel_height = parseInt(panel_fmt.height)||0;
    	var height = parseInt(fmt.height)||0;
    	return { top:(panel_top+panel_height-height)+"px",
    		left:panel_fmt.left,
    		width:fmt.width,
    		height:fmt.height,
    		'z-index':panel_fmt['z-index']
    	};
    }
    
    function compareFormats(fmt1, fmt2) {
        if (fmt1 && fmt2) {
        	if (fmt1['z-index']>fmt2['z-index']) return false;
            var x1 = parseInt(fmt1.left),
                y1 = parseInt(fmt1.top),
                w1 = parseInt(fmt1.width),
                h1 = parseInt(fmt1.height),
                x2 = parseInt(fmt2.left),
                y2 = parseInt(fmt2.top),
                w2 = parseInt(fmt2.width)||0,
                h2 = parseInt(fmt2.height)||0;
            return ((((x1 <= x2) && (x2 < x1+w1)) || ((x2 < x1) && (x1 < x2 + w2))) &&
                    (((y1 <= y2) && (y2 < y1+h1)) || ((y2 < y1) && (y1 < y2 + h2))));
        }
        return false;
    }
    
   
      
    /**
     * Register map before rendering. The registration will be successful only if no other map object register or the object itself register.
     * The function is used to avoid rendering multiple native map at the same time.
     * @returns {Boolean} True if it can register successfully.
     */
    function registerMapRendering() {
        if( !mstrApp.renderingMap || (mstrApp.renderingMap === this.id) ) {
            mstrApp.renderingMap = this.id;
            return true;
        } else {
            return false;
        }
    }
    
    /**
     * Deregister the map when the map is unrendered or destroyed.
     */
    function deregisterMapRendering() {
        if(mstrApp.renderingMap === this.id) {
            delete mstrApp.renderingMap;
            return true;
        }
        return false;
    }
    
    /**
     * <p>A widget to display an Android specific Android Map in RW documents.</p>
     *
     * This is intended to live inside an AndroidView widget as the contentChild.
     *
     * @class
     * @extends mstrmojo.Box
     */
    mstrmojo.maps.androidmap.AndroidDocMap = mstrmojo.declare(
        mstrmojo.maps.androidmap.AndroidMap,

        [ mstrmojo._Formattable ],

        {
            scriptClass: "mstrmojo.maps.androidmap.AndroidDocMap",

            markupString: '<div id="{@id}" class="mstrmojo-Box {@cssClass}" style="{@domNodeCssText}" mstrAttach:touchstart>' +
            			  '</div>',

            formatHandlers: {
                domNode: ['left', 'top', 'z-index', 'height', 'width', 'border', 'border-color', 'border-style', 'border-width' ]
            },

            sc: null,
            
            domNodeCssText:'position:relative;',
            
            lastSelectedRow: null,
            
            hasTarget: function hasTarget() {
                var sc = this.getInfoWindowSelectorControl(this.gridData);
                return !!(sc && sc.tks);
            },

            /**
             * Overridden to listen to touch manager and close open info windows when a touch occurs.
             *
             * @ignore
             */
            postBuildRendering: function postBuildRendering() {
                // Attach a listener for touchesBegin.
                this._touchListener = mstrmojo.touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                    // Do we have an open info window?
                    var openInfoWindow = this.openedInfoWindow;
                    if (openInfoWindow) {
                        // Is the target of the touch not contained within our widget?
                        if (!$DOM.contains(this.domNode, evt.touch.target, true, document.body)) {
                            // Close info window.
                            openInfoWindow.close();
                        }
                    }
                });

                return this._super();
            },
            
            destroy: function destroy(ignoreDom) {
                // Do we have a touch listener?
                var listener = this._touchListener;
                if (listener) {
                    // Detach event listener and delete listener handle.
                    mstrmojo.touchManager.detachEventListener(listener);
                    delete this._touchListener;
                }
                if(this.mapRendered) {
                    this.removeMap();
                }
                this._super(ignoreDom);
            },

            setModel: function setModel(d) {
                // our containing mobile doc is assumed to be the controller's content view
                this.doc = d.controller.view;
                this._super(d);
            },
            
            initFromVisProps: function initFromVisProps(vp) {
                this._super(vp);

                if (!vp) {
                    return;
                }

                this.iwDocLayout = (parseInt(vp.dl, 10) === 1);

                // get the type of map we're supposed to display
                if (vp.lyt) {
                    this.iwLayoutKey = vp.lyt;
                }
            },

            /**
             * find info window panel stack defn
             */
            findSelectorTarget: function findSelectorTarget(sc) {
                if (sc && sc.tks) {
                    var dm = this.xtabModel.docModel,
                        targets = sc.tks.split('\u001E'),
                        i = 0,
                        len = targets.length;

                    for (i = 0; i < len; ++i) {
                        var d = dm.getTargetDefn(targets[i]);
                        if (d[targets[i]].ifw) {
                            return targets[i];
                        }
                    }
                }
                return null;
            },

            findIntersectingComponents: function findIntersectingComponents() {
            	var container = this,
            	    skipNode,
            	    fmt = this.getFormats();
            	while (container.scriptClass != "mstrmojo.DocSubsection" || container.scriptClass != "mstrmojo.DocInfoWindow") {
            		skipNode = container;
            		container = container.parent;            		
            		if(!container) {
            		    break;
            		}
            		var children = container.children,
            		    numChild = (children && children.length) || 0,
            		    comp = null,
            		    idx;
            		for (idx = 0; idx < numChild; idx++) {
            			comp = children[idx];
            			
            			//TODO need to check all children and grandchildren
            			if (comp != skipNode && comp.getFormats && compareFormats(adjustFormat(fmt), adjustFormat(comp.getFormats()))) {
            				return true;
            			}
            		}
            		
            	}
            	return false;
            },
            
            getGridModel: function() {
            	var gridModel = this._super();
            	
            	//remove unnecessary properties that can cause circular reference
            	delete gridModel.layoutModel;
            	delete gridModel.layoutNode;
            	return gridModel;
            },
            
            dispatchMapData: function dispatchMapData() {
                //If there is a map already is registered for rendering, do not dispatch map data
                if(!registerMapRendering.call(this)) {
                    this.domNode.innerHTML = mstrmojo.desc(9480, 'Only one map visualization is supported at a time');
                    mstrmojo.css.addClass(this.domNode, 'noMapVis');
                    return ;
                }
                
                var doc = this.doc,
                	m = doc.model,
                    viewTree = this.getViewHierarchy(),
                    mapModel = this.getMapModel(),
                    gridModel = this.simplifyGridData(),
                    layouts = (doc.getSupportedLayouts && doc.getSupportedLayouts()) || doc.getLayouts(),
                    fullScreen = !!this.isFullScreenWidget? FULL_SCREEN : REGULAR_SIZE,
                    isActive = false,
                    curLyt = doc.getCurrentLayout(),
                    docData;
                
                    docData = JSON.stringify({
                        did: doc.did,
                        ttl: doc.ttl,
                        st: doc.st,
                        mid: m.mid,
                        ci: m.ci,
                        bs: m.bs,
                        zt: m.zt,
                        defn: m.defn,
                        currlaykey: m.currlaykey
                    });
                    
                    
                //delete model to avoid circular structure
                delete mapModel.model;
                
                //register self with current layout
                if (curLyt.setMapID){
                    curLyt.setMapID(this.id);
                }
                
                //if full screen is REGULAR_SIZE
                if(!fullScreen) {
                	isActive = this.findIntersectingComponents();
                }
                               
                mstrMobileApp.loadMap(JSON.stringify($H.copy({
                	fullScreen: fullScreen,
                	infoWindow: this.getInfoWindowConfig(),
                	viewTree: viewTree,
                	mapPath: this.mapPath,
                	active: isActive,
                	docModelId: this.xtabModel.docModel.id,
                	hasTarget:this.hasTarget(),
                	zt: m.zt,
                	gdProp: gridModel.prop
                }, mapModel)), gridModel.es, gridModel.data, docData);       
                
                //set the map status to be rendered
                this.mapRendered = true;
            },
            
            getViewHierarchy: function () {
                //save the structure of the map into a string to identify the unique of the map
                var mapPath = [];
                
                //start preparing data for Map widget
                //1. Get the formats from all its parent, make sure the map is properly size since it might be cut
                //2. Set up listener to the scrollMove event
                //TODO: delete all the listeners when destory the widget
                var p = this.parent, w = [], c = $H.copy(this.fmts, {}), me = this;
                w.push(c);
                while(p) {
                    c = $H.copy(p.fmts, {});
                    c.id = p.id;                    
                    mapPath.push(c.id);
                    
                    if(p.scriptClass === "mstrmojo.MobileDocLayoutViewer") {
                        //MobileDocLayoutViewer uses the same fmts object as DocLayout. Delete the width/height value to avoid the limit on DocLayout
                        delete c.width;
                        delete c.height;
                    } else if(p instanceof mstrmojo.DocPanel) {
                        //The left of map panel can be started with a certain offset. When scrolling, we need to consider the offset when passing the
                        //scrolling updated value
                        var left = parseInt(p.domNode.style.left, 10); 
                        if(left > 0) {
                            p.parent._scrollOffsetLeft = left;
                        }
                    } else if(p.scriptClass === "mstrmojo.DocSection") {
                        //TQMS#548034 the layout header and layout header (both readered as mstrmojo.DocSection) can take space. 
                        //So the map can have some offset to its parent due to the existance of page/layout header. 
                        //Use offsetTop to calculate the offset of its section to the container. The offset value should be the sum of the header heights.  
                        if(p.domNode.offsetTop) {
                            c.top = p.domNode.offsetTop + 'px';
                        }
                    } else if(p.scriptClass === "mstrmojo.DocInfoWindow") {
                        //if the map is inside of a info window, then it should be positioned after the info window is rendered and repositioned
                        //use info window container position for the map container position
                        if(p.containerNode) {
                            c.top = p.containerNode.offsetTop + 'px';
                            c.left = p.containerNode.offsetLeft + 'px';
                        }
                        //add hide map view when the info window is closed 
                        p.onClose = function() {
                            mstrMobileApp.hideMapView(1);
                        };
                    }

                    if(p._scroller) {
                        if(!p._scroller.scrollMoveListener) {
                            var scrollerUpdate = function(e) {
                                mstrMobileApp.scrollerUpdated(JSON.stringify({id: this.id, /*scriptClass: this.scriptClass,*/ x: e.x - (this._scrollOffsetLeft || 0) , y: e.y}));
                            };
                            p._scroller.attachEventListener('scrollMoved', p.id, scrollerUpdate);
                            p._scroller.attachEventListener('scrollDone', p.id, scrollerUpdate);
                            p._scroller.attachEventListener('transformAnim', p.id, scrollerUpdate);
                            p._scroller.scrollMoveListener = true;
                        }
                        c.scroller = true;
                    }
                    w.splice(0, 0, c);
                    p = p.parent;
                }
                
                this.mapPath = mapPath.join('') + ':' + JSON.stringify(w);
                return w;
            },            
            
            getInfoWindowConfig: function useDefaultInfoWindow() {
                // Do we already set the value?
                if(!this.iwConfig) {
                    if(this.iwDocLayout) {
                        this.iwConfig = {dft: false};
                    } else {
                        var d = this.gridData,
                            sc = this.getInfoWindowSelectorControl(d);
                        if(sc) {
                            var dm = this.xtabModel.docModel,
                            tgtDefs = dm.getTargetDefn(sc.tks);

                            if(this.findSelectorTarget(sc)) {
                                this.iwConfig = {dft: false};
                                if(tgtDefs && tgtDefs[sc.tks]) {
                                    var fmt = tgtDefs[sc.tks].fmts;
                                    this.iwConfig.size = {
                                        w: parseInt(fmt.width, 10), 
                                        h: parseInt(fmt.height, 10)
                                    };
                                    return this.iwConfig;
                                }
                            }
                        } 
                        this.iwConfig = {dft: true};
                    }
                } 
                
                return this.iwConfig;
            },
           
            /**
             * When a new document is opened by link or drilling, the document will be in inactive status.
             * Calling the function to reset the current layout if the info window is set to be selected layout.
             */
            resetLayout: function resetLayout() {
                //if the info window layout is set as selected one, we need to select the base layout.
                if (this.iwDocLayout && this.preIWLayout) {
                    this.doc.selectLayout(this.preIWLayout, true, null, true);
                    this.preIWLayout = null;
                }
            },
            
            closeInfoWindow: function closeInfoWindow() {
                //close all the opening dialog until the info window dialog is closed.
                do{
                    mstrApp.closeDialog();
                } while(mstrmojo.all.mstrMapInfoWindow);
            },
            
            removeMarkerAnchor: function removeMarkerAnchor() {
                var anchor = mstrmojo.all.mstrMapMarkerAnchor;
                if(anchor) {
                    anchor.destroy();
                }
            },
            beforeViewHidden: function beforeViewHidden(isBackOperation) {
            	
            	this.unrender();
            },
            
            handleMarkerSelection: function handleMarkerSelection(ri, ancherX, ancherY) {
                //remove existing anchor
                this.removeMarkerAnchor();
                
                //create an anchor for info window to locate its position
                var anchor = mstrmojo.insert({
                    id: 'mstrMapMarkerAnchor',
                    scriptClass: 'mstrmojo.Box',
                    cssText: 'left:' + ancherX + 'px;top:' + ancherY + 'px;position:absolute;z-index:100',
                    width: '1px',
                    height: '1px'
                });
                anchor.render();
                document.body.appendChild(anchor.domNode);
                this.handleMarkerTargetSelection(ri,anchor);
                this.handleMarkerInfoWindowLayoutSelection(ri,anchor);
            },
                
            handleMarkerInfoWindowLayoutSelection: function handleMarkerInfoWindowLayoutSelection(ri,anchor) {
                
                var d = this.gridData,
                    att = d.gts.row[0],
                    attrid = att.id,
                    r = d.ghs.rhs.items[ri],
                    c = r && r.items[0].idx,
                    ths = this,
                    eid = (c >= 0) ? att.es[c].id : -1;
                
              //figure out whether the info window is from layout
                if (this.iwDocLayout) {
                    //Get the attribute id from the marker, we need it for send it to the task
                    var doc = this.doc,
                        layouts = doc.getLayouts(),
                        lyt = this.iwLayoutKey,
                        layout = layouts[mstrmojo.array.find(layouts, 'k', lyt)],
                        sep = "\x1F",
                        dssXmlTypeAttribute = "12",
                        gbIDs = attrid + sep + dssXmlTypeAttribute + sep + eid;

                    var taskParams = {
                            layoutKey: lyt,
                            groupByIDs: gbIDs,
                            reload: true
                        };
                    
                        //TQMS#545767 save the layout to preIWLayout so that when the document is navigated away, we can switch the document back to its original layout
                        if(!this.preIWLayout) {
                            this.preIWLayout = layouts[mstrmojo.array.find(layouts, 'k', this.defn._lkz)];
                        }

                    (function (params, layouts) {
                        var me = doc,
                            model = me.model,
                            dataService = model.getDataService(),
                            key = params.layoutKey,
                            layout = layouts[mstrmojo.array.find(layouts, 'k', key)];  // existing layout

                        // Has the newly selected layout NOT been loaded yet or do we want to reload on purpose?
                        if (layout.defn && (params.reload || layout.defn.loaded === false)) {
                            
                            // Ask data service to retrieve layout from server.
                            dataService.loadDocLayout(params, {
                            success: function (res) {
                                var model = ths.xtabModel.docModel,
                                    key = lyt,
                                    newLayout;
                                
                                //set res for info window response
                                res.key = key;
                                res.isSelected = false;
                                
                                // Replace the data for this new layout.
                                model.replaceLayout(key, res);
                                
                                newLayout = doc.rebuildLayout(key, layouts);
                                
                                ths.lastSelectedRow = ri;
                                
                                var node = newLayout.node, 
                                    overlay,
                                    dimensions = mstrApp.getScreenDimensions(),
                                    mw = dimensions.w * 0.85,
                                    mh = dimensions.h * 0.9,
                                    dw = dimensions.w * 0.6, //default widget
                                    dh = dimensions.h * 0.5, //default height
                                    w = node.defn.fmts.width || (dw + 'px'),
                                    h = node.defn.fmts.height || node.data.mh || (dh + 'px'); //get minimum layout height if no format height defined
    
                                ths.closeInfoWindow();
                                
                                overlay = new mstrmojo.Overlay({
                                    cssClass: 'iwOverlay',
                                    children: [newLayout]
                                });

                                //set the dimensions
                                overlay.set('width', w);
                                overlay.set('height', h);
                                mstrApp.showPopup({
                                    id: 'mstrMapInfoWindow',
                                    cssClass: 'mapInfoWindow',
                                    scriptClass: 'mstrmojo.android.Popup',
                                    anchorOffset: 1,
                                    onClose: function() {
                                        window.setTimeout(function(){
                                            ths.resetLayout();
                                        }, 0);
                                    },
                                    
                                    resizeDialog: function() {
                                        var editorNode = this.editorNode; //default height
                                        
                                        // Is this a tablet device?
                                        if (mstrApp.isTablet()) {
                                            // Does the popup already have dimensions?
                                            var popDimensions = this.popDimensions;
                                            if (popDimensions) {
                                                mh = popDimensions.h;
                                                mw = popDimensions.w;
                                            } else {
                                                // Use either the default sizes for tablets, or the calculated height (whichever is smaller).
                                                mh = Math.min(488, mh);
                                                mw = Math.min(550, parseInt(w, 10));
                                            }
                                        }
                                        
                                        // Use set for width.
                                        this.set('width', Math.min(parseInt(w, 10), mw) + 'px');
                                        
                                        // set content height
                                        if(editorNode) {
                                            editorNode.style.height = Math.min(parseInt(h, 10), mh) + 'px';
                                        }
                                        // call Dialog resize function to set the curtain size so that the anchor can be placed properly
                                        mstrmojo.Dialog.prototype.resizeDialog.call(this);
                                    },
                                    children: [overlay]
                                }, anchor.domNode);
                                
                                var INTERVAL = 300,
                                    t = 0,
                                    ti = window.setInterval(function () {
                                        var n = overlay.parent.editorNode;
                                        if (n) {
                                            var ow = n.clientWidth,
                                                oh = n.clientHeight;
                                            if (ow !== parseInt(w, 10) || oh !== parseInt(h, 10)) {
                                                overlay.setDimensions(oh + 'px', ow + 'px');
                                                window.clearTimeout(ti);
                                            }
                                        }
                                        t += INTERVAL;
                                        //if it exceeds the maximum time we can wait, we assume the google bubble size is the same size
                                        //as we initially set on the layout
                                        if (t > 10 * INTERVAL) {
                                            window.clearTimeout(ti);
                                        }
                                    }, INTERVAL); //use interval to check the google bubble height
                                
                                doc.selectLayout(layout, true);
                                }
                            });
                        } else {
                            // Update the server if the new layout is different than the current layout.
                            me.selectLayout(layout, true);
                        }
                    })(taskParams, layouts);
                }
            },
            handleMarkerTargetSelection:function handleMarkerTargetSelection(ri,anchor){
            	var d = this.gridData,
                    att = d.gts.row[0],
                    attrid = att.id,
                    r = d.ghs.rhs.items[ri],
                    c = r && r.items[0].idx,
                    ths = this,
                    eid = (c >= 0) ? att.es[c].id : -1;
                
                //not from layout
                var sc = this.getInfoWindowSelectorControl(d),
                    firstInfoWinKey = this.findSelectorTarget(sc);
    
                if (sc && sc.tks) {
                    var dataCacheUpdate = null,
                        dm = ths.xtabModel.docModel;

                    //TODO: use doc model to create callback object
                    dm.getDataService().setDocSelectorElements(sc.ck, eid, sc.ckey, sc.include, {
                        success: function (res) {

                            // The collection of target definitions for this slice.
                            var tgtDefs = dm.getTargetDefn(sc.tks);

                            // With new partial update mechanism
                            if (res.pukeys) {
                                tgtDefs = dm.getTargetDefn(res.pukeys);
                            }

                            // Update this DocModel's "dataCache" with a hash of all the partial update nodes which are either targets or descendants of targets.
                            // Returned is an object with information about widgets that need to be updated as a result of this operation.
                            // update the data cache with the new data for the target
                            dataCacheUpdate = dm.updateDataCache(res.data, tgtDefs);

                            var firstInfoWinKey = ths.findSelectorTarget(sc);
                            
                            //if we have panel stack as target
                            if(firstInfoWinKey) {
                                var targetDef = dm.getTargetDefn(firstInfoWinKey),
                                    id = firstInfoWinKey + "_ifw",
                                    w = mstrmojo.all[id],
                                    psId = "*l" + res.currlaykey + "*k" + firstInfoWinKey + "*x1*t" + dm.buildTime;
    
                                // if we have already created an info window then destroy it
                                if (w) {
                                    w.destroy();
                                }
    
                                var ifw = new mstrmojo.maps.androidmap.AndroidDocMapInfoWindow({
                                    id: id,
                                    builder: ths.doc.builder,
                                    model: dm,
                                    psKey: firstInfoWinKey,
                                    psId: psId
                                });
                            
                             // Retrieve formats and create content node.
                                var fmts = targetDef[firstInfoWinKey].fmts,
                                    iw = parseInt(fmts.width, 10) || width,
                                    ih = parseInt((fmts.p_fmts && fmts.p_fmts.height) || fmts.height, 10) || height;
    
                                ifw.set('width', iw + 'px');
                                ifw.set('height', ih + 'px');
                                
                                mstrApp.showPopup({
                                    id: 'mstrMapInfoWindow',
                                    scriptClass: 'mstrmojo.android.Popup',
                                    cssClass: 'mapInfoWindow',
                                    anchorOffset: 1,
                                    children: [ifw],
                                    resizeDialog: function() {
                                        var editorNode = this.editorNode;
                                        // Use set for width.
                                        this.set('width', iw + 'px');
                                        
                                        // set content height
                                        if(editorNode) {
                                            editorNode.style.height = ih + 'px';
                                        }
                                        // call Dialog resize function to set the curtain size so that the anchor can be placed properly
                                        mstrmojo.Dialog.prototype.resizeDialog.call(this);
                                    }
                                }, anchor.domNode);
                            }
                            
                            // to update any other targets we have the doc model raise an partialUpdate event.  Other
                            // widgets that need updating will be listening for this event and update accordingly.
                            var ue = {
                                name: 'partialUpdate',
                                tree: res.data,   // Partial update tree.
                                ids: dataCacheUpdate,
                                anchor: anchor.domNode
                            };

                            //if has info window, pass on the position.
                            if (!mstrmojo.hash.isEmpty(ue.ids.ifws)) {
                                // delete the info window from the array of info windows that need updating
                                delete ue.ids.ifws[firstInfoWinKey];
                            }
                            
                            // Raise the 'partialUpdate' event so the doc widgets will hear it.
                            dm.raiseEvent(ue);
                        }
                    }, dm.zf, true);
                } 
            },
            
            getInfoWindowSelectorControl: function getInfoWindowSelectorControl(d) {
                if (!this.sc && !d.eg) {
                    // we assume that the first attribute on the rows has the selector control
                    this.sc = d.gts.row[0].sc;
                }
                return this.sc;
            },
            
            afterViewVisible: function afterViewVisible() {
                window.setTimeout(function() {mstrMobileApp.showMapView(1);},300);
            },
            
            removeMap:function removeMap() {
            	 //close info window
                this.closeInfoWindow();
                //remove existing anchor
                this.removeMarkerAnchor();
                
                //reset layout
                //TQMS 718411 692464
                //When we display an infowindow using a layout, we will switch the current layout to the infowindow layout.
                // The purpose of this is to enable the functionality such as drilling, slicing on infowindow.
                //When we leave the document at that stage, we need to reset the layout to be the original layout.
                //Previously, resetLayout is called by the onClose of the info window popup.
                //The problem arises when unrender() is called before the onClose() being called.
                //resetLayout() requires the domNode to manipulate the data and thus cannot be called after unrender()
                //since we don't have any control on enforing resetLayout() to be called before unrender()
                //we made resetLayout as a part of unrender().
                //flag (this.preIWLayout is set to null) is used to indicate that we are in orignal layout and no more action will be taken.
                this.resetLayout();
                
                //unregister map rendering
                if(deregisterMapRendering.call(this)) {
                    //hide map view if the registered current rendering one is the same as itself 
                    mstrMobileApp.hideMapView(1);
                } 
            },
            
            unrender: function() {
                this.lastSelectedRow = null;
                this._super();
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.maps.androidmap.AndroidMap");

    /**
     * <p>A widget to display a report based Google Map Widget on the Android platform.</p>
     *
     * @class
     * @extends mstrmojo.maps.androidmap.AndroidMap
     */
    mstrmojo.maps.androidmap.AndroidRptMap = mstrmojo.declare(
        mstrmojo.maps.androidmap.AndroidMap,

        null,

        /**
         * @lends mstrmojo.maps.androidmap.AndroidRptMap
         */
        {
            scriptClass: 'mstrmojo.maps.androidmap.AndroidRptMap',

            setModel: function setModel(model) {
                this._super(model);

                // Make request for page by data.
                this.controller.getPageByTree(false);
            }
        }
    );
}());
(function() {

	mstrmojo.requiresCls(
						"mstrmojo.VisChart",
						"mstrmojo.locales"
						);

	// to rotate do the div 150 pixels wide x and y point adjustments
	//This will also depend on what margins we are allocating in bottom for y axis.
	// here is what we currently have in char.js margin: {t:50, r:60, b:25, l:0},
	var ROTATE_X_ADJUST = 20;
	var ROTATE_Y_ADJUST = -20;

	//just the y point adjustment in case of no rotation based on 30 pixels margin at bottom
	var PLAIN_Y_ADJUST = 25;

	var $H = mstrmojo.hash;
	
	var prevDate = null; 

	/**
	 * A line chart control
	 * @class
	 * @extends mstrmojo.VisChart
	 */
	mstrmojo.VisChartLine = mstrmojo.declare(
			// superclass
			mstrmojo.VisChart,

			// mixins
			null,

			/**
			 * @lends mstrmojo.VisChartLine.prototype
			 */
			{
				/**
				 * @ignore
				 */ 
				scriptClass: 'mstrmojo.VisChartLine',

				/**
				 * The filling color for the area under the lines 
				 * color should be in the '#ffffff' format
				 */
				fillinColor: null,

				/**
				 * Whether to rotate the X labels 45 degrees
				 */
				rotateXLabels: false,

				/**
				 * Whether to fill the area under the lines
				 */
				isFillLinesArea: null,

				/**
				 * Whether to animate the lines drawn on chart
				 */
				isAnimateLines: true,

				/**
				 * draw the points on start and end points.
				 * 0 - No points
				 * 1 - start point only
				 * 2 - end point only
				 * 3 - start and end points both
				 */
				isDrawStartEndPoints: 0,

				/**
				 * radius of the circle we draw on start and end points
				 */
				startEndPointRadius: 5,

				/**
				 * defines the color we want to display on the start point
				 * color should be in the '#ffffff' format
				 */
				startPointColor: null,

				/**
				 * defines the color we want to display on the end point
				 * color should be in the '#ffffff' format
				 */
				endPointColor: null,

				/**
				 * The previous set of lines so we can animate between the last and the new lines when the data changes
				 */
				prevLines: null,

				/**
				 * set of default series colors to draw chart lines
				 * If there are more than six series, we can repeat this set of colors
				 */
				chartLineColors: ['#0099FF', '#FFB03C', '#F26AE1', '#888BF4', '#93CA20', '#FE2F68'],

				/**
				 * max number of x axis labels to be shown on the screen
				 */
				maxXLabels: 6,
				
				/**
				 * This is the enumeration used for the forms to determine if the category is of type date
				 */
				DSS_XML_BASE_FORM_DATE : "8",
				
				/**
				 * Called to render the Chart elements
				 */            
				drawChart: function drwchrt() {
					
					var model = this.model;
					if(model.err) {
						return;
					}

					//local objects
					var context = this.animationContext,
					mvalues = model.mvalues,
					values = model.series,
					margin = this.margin,lines = [],linesFrom = [],
					height = this.getHeight(),
					width = this.getWidth(),
					me = this,
					utils = this.utils;

					if (!values) return; 

					var vl = values.length;

					if(this.isDrawAxis && this.drawYAxisLabels) {
						margin.l = utils.getLabelWidthForMargin(this,model.mls);
					}

					//cache x & y ratios
					me.RTY = (height - margin.t - margin.b - 5) / (mvalues[mvalues.length - 1] - mvalues[0]);
					me.RTX = (width - margin.l - margin.r - 1) / (me.windowSize - 1);

					var mn = (mvalues[0] + mvalues[mvalues.length - 1]) / 2;
					var mnY = utils.getYValue(me, mn); // mean y value to start animation
					//create the lines array used to create the chart's line
					for(var j = 0; j < vl; j++) {
						lines = [];
						var k = 0;
						for (var i = 0; i < me.windowSize; i++) {
							var val = values[j].rv[i];
							if(val.length === 0) continue;

							lines[k] = {x:(i * me.RTX) + margin.l, y:utils.getYValue(me, val)};

							if (!this.prevLines) {
								//the from array is used to animate the line, the line will animate from the mean 
								linesFrom[k] = {x:lines[k].x, y:mnY};
							}
							k++;
						}

						this.drawChartLine(lines, linesFrom, vl, j, context);

						if(!this.multiLine) break; // break out of outer loop
					}

					this.prevLines = lines;

			},

			drawChartLine: function drwcl(lines, linesFrom, vl, si, context, lw/*line width*/) {

				var me = this, 
					height = me.getHeight(),
					utils = me.utils;

				//config object used in the line animation method
				var cfg = {
						rate: 6
				};

				context.strokeStyle = utils.getColor(me);
				context.lineCap = 'round';
				context.lineWidth = lw || 2;
				context.lineJoin = 'round';

				if(me.isAnimateLines && (!me.multiLine || vl === 1 )) {
					if (me.prevLines) {
						linesFrom = me.prevLines;
						// match array lengths if the from is smaller
						if (linesFrom.length < lines.length) {
							for (var i = linesFrom.length; i < lines.length; i++) {
								linesFrom.push(lines[linesFrom.length-1]);
							}
						}
					}

					//animate the line
					utils.animateLineSet(me, me.prevLines || linesFrom, lines, cfg);
				} else {

					if(me.multiLine && vl > 1) {
						context.strokeStyle = me.chartLineColors[si % 6];
					}

					//just draw the lines no animation
					utils.drawLineSet(me, lines, false, context);

					if(me.isFillLinesArea) {
						utils.fillLinesArea(me,lines.slice(0));
					}

					if(me.isDrawStartEndPoints ) {
						utils.drawStartEndPoints(me, lines, context, me.isDrawStartEndPoints);
					}
				}

			},

			/**
			 * this function will set some properties by default to micro-chart mode
			 */
			setMicroChartProperties: function setMicroChartProperties() {
				this.isDrawAxis = false;
				this.margin = {t:0, r:5, b:0, l:5};
				this.showHighlightLine = false;
				this.isDrawStartEndPoints = 3;
			},
			
			initFromVisProps: function initFromVisProps(vp) {
				if(!vp) return;
				
				if(vp.thc) {
					this.themeColor = "#" + vp.thc;
				}
				
				if(vp.shl === "0") {
					this.showHighlightLine = false;
				}
				
				if(vp.mc === "1") {
					this.setMicroChartProperties();
				}
			},
			
			/**
			 * @ignore
			 */ 
			postCreate: function pstCrt() {
				if (this._super) {
					this._super();
				}

				if (this.rotateXLabels) {
					this.margin.b = 75;
				}

				// initialize the isFillLinesArea if it is not defined by the user and chart is single line chart
				if(typeof(this.isFillLinesArea) === 'undefined' && !this.multiLine) {
					this.isFillLinesArea = true;
				}
			},
			
			/**
			 * Called to render the Chart data labels. By default this method renders labels for the max and min values of a single axis Chart
			 * @param needNotDrawVerticalGridLine : when we don't redraw the chart, we will not redraw the vertical grid line
			 */
			drawLabels: function drwlbls(needNotDrawVerticalGridLine) {					
				//No axis no labels
				if (!this.isDrawAxis) return;            	

				if (this._super) {
					//render the YLabels and draw horizontalGridLines
					this._super();
				}

				if(!this.drawXAxisLabels) return;
				
				//local vars
				var me = this,
					cat = me.model.categories,
					labels = cat.items,
					tp = cat.tp,
					utils = me.utils,
					mg = me.margin,
					l = labels.length,
					li = null,
					x = null,
					y = 0,
					lbl = null,
					ts = me.isTimeSeries,
					ctx = me.animationContext,
					dgl = me.drawGridLines;

				//reset previous lable settings
				var pxl = me.prevXLabel;
				pxl.x = 0;
				pxl.y = 0;
				pxl.w = 0;

				ctx.save();
				//set the context settings 
				ctx.globalAlpha = 1;
				ctx.strokeStyle = utils.rgb2rgbStr(me.formatProp.textClr, 0.35);//getColor(me);
				ctx.lineWidth = 1;
				ctx.lineCap = 'round';

				//should draw only limited number of x labels for better performance currently using 6 max
				var totalLabels = l > me.maxXLabels ? me.maxXLabels : l;
				
				var xlblDiv = null;
				
				//if is timeseries
				if(ts) {
					xlblDiv = document.createElement("div");
					me.xdiv = xlblDiv;

					//totalLabels *= (me.animationCanvas.width/(me.getWidth() - mg.l - mg.r));
					totalLabels *= (me.totalChartWidth/(me.chartWidth));
				} 

				
				if(me.rotateXLabels) {
					y = me.canvas.height + ROTATE_Y_ADJUST;
				} else {
					if(ts){
						//make X-Axis Label higher, so the slider tooltip will not overlay it.
						y =  me.canvas.height - this.margin.b + 5;
					}else{
						y =  me.canvas.height - PLAIN_Y_ADJUST;
					}

				}
				
				var labInterval = Math.round(l / totalLabels);
				// interval can be zero in case of timeseries when diff btw rne and rns is less than maxXLabels
				if(labInterval === 0) {
					labInterval = 1;
				}
				
				var lw = Math.round(labInterval * me.RTX) - me.xLabelPadding;
					
				prevDate = null;
				var curPrevDate = {mn:0,dt:0,yr:0};
				if(ts){
					/*labelDisplay : -1 is not show on screen
					 * 				  0 is the most left label show on screen
					 * 				  1 is other label show on screen
					 */
					var labelDisplayStatus = -1;
					this.needRedrawVerticalLine = false;
					for(var i = me.ACrns; i < me.ACrne; i+=labInterval) {
						x = ((i - me.ACrns) * me.RTX);
						var dtlbl = labels[i];
						if(labelDisplayStatus < 0 && i >= me.model.rns){
							// the first label on the right of orgin
							labelDisplayStatus = 0;
						}
						if(ts && (tp.toString() === me.DSS_XML_BASE_FORM_DATE)) {
							//if the label is the first displayed label, always show the year and month info
							if(labelDisplayStatus == 0){
								prevDate = null;
								labelDisplayStatus = 1;
							}
							dtlbl = me.getFormattedDateLabel(dtlbl, curPrevDate);
							
						}
						
						if (me.rotatXLabels) {
							lbl = utils.addLabel(me, dtlbl, x - ROTATE_X_ADJUST, y, null, true, pxl);
						} else {
							lbl = utils.addLabel(me, dtlbl, x , y, null, false, pxl);
						}
						//only draw the line if Draw Vertical lines is true and label is added
						if(lbl) {
							if(dgl & me.drawVerticalGridLines) {
								prevDate = $H.clone(curPrevDate);
								if(!needNotDrawVerticalGridLine){
									var xPos = Math.floor(x) + 0.5;
									utils.drawLineSet(me,[{x:xPos,y:me.canvas.height - mg.b},{x:xPos, y:mg.t}], false, ctx);
								}
							}
						}

					}
					
				}else{
				
					for(var i = 0; i < l; i+=labInterval) {
						x = (i * me.RTX) + mg.l;
						var dtlbl = labels[i];
						if(ts && (tp.toString() === me.DSS_XML_BASE_FORM_DATE)) {
							dtlbl = me.getFormattedDateLabel(dtlbl, curPrevDate);
						}
						
						if (me.rotateXLabels) {
							lbl = utils.addLabel(me, dtlbl, x - ROTATE_X_ADJUST, y, null, true, pxl);
						} else {
							lbl = utils.addLabel(me, dtlbl, x, y, lw, false, pxl);
						}
						//only draw the line if Draw Vertical lines is true and label is added
						if(lbl) {
							if(dgl & me.drawVerticalGridLines) {
								prevDate = $H.clone(curPrevDate);
								utils.drawLineSet(me,[{x:x,y:me.canvas.height - mg.b},{x:x, y:mg.t}], false, ctx);
							}
						}
					}
				}
				//TODO this code can be activated only if we want to draw vertical lines at the beginning and end
				/*if(me.isTimeSeries && me.scrollPast && (dgl & me.drawVerticalGridLines)) {
					//draw vertical lines at start at end
					for(var i = 0; i < l; i+= l -1) {
						x = (i * me.RTX) + mg.l;
						utils.drawLineSet(me,[{x:x,y:me.canvas.height - mg.b},{x:x, y:mg.t}], false, ctx);
					}
				}*/
				
				if(xlblDiv) {
					if(this.isTimeSeries){
						//var tc = me.animationCanvas;
						me.xLabelsDiv.innerHTML = xlblDiv.innerHTML;
						//me.animationCanvasDiv.insertBefore(tc, me.animationCanvasDiv.firstChild);
						me.xdiv = null;
						
					}else{
						var tc = me.animationCanvas;
						me.itemsContainerNode.innerHTML = xlblDiv.innerHTML;
						me.itemsContainerNode.insertBefore(tc, me.itemsContainerNode.firstChild);
						me.xdiv = null;
						
					}
					
				}
				
				ctx.restore();
			},

			/**
			 * This function will return the formatted date value.  If raw value is not date it returns
			 * the raw value
			 */
			getFormattedDateLabel: function getFormattedDateLabel(/*date string in milliseconds*/ val, /* object holding current date info*/cpv) {
				if(isNaN(val)) {
					return val;
				}
				
				var fVal = val;
				try {
					val = this.utils.convertRawValueToMilliseconds(val);
					var dt = new Date(Number(val));
					var mn = cpv.mn = mstrmojo.locales.datetime.MONTHNAME_SHORT[dt.getMonth()];
					var yr = cpv.yr = dt.getFullYear().toString().substring(2);
					cpv.dt = dt.getDate();
					
					if(!prevDate || (mn !== prevDate.mn && yr !== prevDate.yr)) {
						fVal = mn + " " + cpv.dt + " " + yr;
					} else if(mn !== prevDate.mn) {
						fVal = mn + " " + cpv.dt;
					} else {
						fVal = cpv.dt;
					}
				} catch(e) {
				}
				return fVal;
			},

			removeLabels: function rmvlbls() {
				
				var todel = this.domNode.getElementsByClassName('mstrmojo-Chart-lbl');
				for (var i = todel.length - 1; todel && i >= 0; i--) {
					todel[i].parentElement.removeChild(todel[i]);
				}
				
			},

			/**
			 * Called to highlight a single data point
			 * @param {Integer} [x] the x axis point to highlight
			 */
			highlightPoint: function hghlghtpnt(x, touchY) {

				//local vars
				var me = this,
				ctx = me.highlightContext,
				height = me.getHeight(),
				margin = me.margin,
				model = me.model,
				utils = me.utils,
				si = me.seriesIndex;

				// clear around the previous highlight
				var xcoord = (x * me.RTX) + margin.l;
				if (this.prevHighlight >= 0) {
					var prevXCoord = (this.prevHighlight * me.RTX) + margin.l;
					var PADDING = 10;
					var TOP_PADDING = 8;
					var y = margin.t-TOP_PADDING > 0 ?  margin.t-TOP_PADDING : 0; // fix for no margin on top
					ctx.clearRect(prevXCoord-PADDING, y , prevXCoord + PADDING, height - margin.b);					
				}		

				if (x < 0) return;

				var xcoord = (x * me.RTX) + margin.l;

				ctx.shadowBlur    = 5;
				ctx.shadowColor   = '#000';
				ctx.globalAlpha = 1;

				if(me.showHighlightLine) {
					// set colors
					ctx.strokeStyle = this.highlightColor;
					ctx.fillStyle = this.highlightColor;
					ctx.lineWidth = 2;
					ctx.lineCap = "round";				

					//draw the highlight
					utils.drawLineSet(me, 
							[ {x:xcoord, y:margin.t},
							  {x:xcoord, y:height - margin.b}
							], false, ctx);
				} else {
					ctx.strokeStyle = utils.getColor(me);
					ctx.fillStyle = ctx.strokeStyle;
				}

				var s = model.series,
				l = s.length,
				y = utils.getYValue(me, s[si].rv[x]);

				//position the highlight image
				if(!me.multiLine) {
					utils.drawArc(me, xcoord, y, 5, 0, Math.PI * 2, true, true, ctx);
				} else {
					if(me.showHighlightLine) {
						if(l > 1) {
							ctx.strokeStyle = this.chartLineColors[0];
							ctx.fillStyle = ctx.strokeStyle;
						}
						for(var i = 0; i < l; i++) {
							ctx.strokeStyle = this.chartLineColors[i % 6];
							if(i > 0) {
								ctx.fillStyle = ctx.strokeStyle;
							}
							y = utils.getYValue(me, s[i].rv[x]);
							utils.drawArc(me, xcoord, y, 5, 0, Math.PI * 2, true, true, ctx);
						}
					} else {
						if(l > 1) {
							ctx.strokeStyle = this.chartLineColors[si];
							ctx.fillStyle = ctx.strokeStyle;
						}
						utils.drawArc(me, xcoord, utils.getYValue(me, s[si].rv[x]), 5, 0, Math.PI * 2, true, true, ctx);
					}
				}
			},

			refreshChart: function refreshChart() {
				//clear animation and highlite canvas
				var height = this.getHeight(),
					width = this.getWidth();
				this.highlightContext.clearRect(0, 0, width, height);    
				this.animationContext.clearRect(0, 0, width, height);

				// remove labels
				this.removeLabels();

				// re-draw chart
				this.drawChart();

				// re-draw labels
				this.drawLabels();
			}
		}
	);

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.VisChart");

    var DEFAULT_DARK_THEME = 1;
    var DEFAULT_LIGHT_THEME = 2;
    var CUSTOM_DARK_THEME = 3;
    var CUSTOM_LIGHT_THEME = 4;

    mstrmojo.VisMicroChartLine = mstrmojo.declare(

        mstrmojo.VisChart,

        null,

        {

            scriptClass: 'mstrmojo.VisMicroChartLine',

            isDrawAxis: false,

            /*
             * To get the effects of padding top and bottom is 4, make margin.t and margin.b is 4
             * As we draw the bottom point with 4px above the margin.b(VisChartUtils.js getYValue),so margin.b = 4-4 = 0
             */
            margin: {t: 5, r: 2, b: 1, l: 2},

            showHighlightLine: false,

            themeColor: '#FFFFFF',

            isDrawRefArea: true,

            noBackground: true, // There should be no background for microChart

            isAnimateLines: false,

            toolTipMain: null,

            mainWidth: 0,

            mainLeftPos: 0,

            reDrawChart: function reDrwchart() {
                var context = this.context,
                    canvas = this.canvas,
                    wd = canvas.width,
                    ht = canvas.height;
                context.clearRect(0, 0, wd, ht);

                this.data.processLinearData(this);
                //cache the values length property
                this.windowSize = this.model.series[0].rv.length;
                //fill the Chart's background with the theme color
                this.utils.fillBackground(this);

                if (this.windowSize <= 1) {
                    return; // not enought data to draw chart
                }
                this.drawChart();
            },

            setColorByTheme: function setColorByTheme() {
                var lineProps = this.config;
                if (this.theme === DEFAULT_DARK_THEME || this.theme === DEFAULT_LIGHT_THEME) {
                    this.startPointColor = '#50B5D8';
                    this.endPointColor = '#50B5D8';
                    this.otherPointColor = '#50B5D8';
                    this.isDrawRefArea = false;
                    this.sparkLineColor = "#50B5D8";
                    this.refLineColor = "#FF781D";
                } else {
                    /**
                     * defines the color we want to display on the start point
                     * color should be in the '#ffffff' format,this property is fixed. Copied from Flash settings
                     */
                    this.startPointColor = '#000000';
                    /**
                     * defines the color we want to display on the end point
                     * color should be in the '#ffffff' format
                     * this property is fixed. Copied from Flash settings.
                     */
                    this.endPointColor = '#FF0000';
                    /**
                     * This is used to represent color settings for those points which are not start or end point.
                     * Value is fixed. Copied from Flash side code
                     */
                    this.otherPointColor = '#663300';
                    this.isDrawRefArea = lineProps.mbRefArea;
                    this.sparkLineColor = lineProps.mwSeriesLineCol;
                    this.refLineColor = lineProps.mwRefLineCol;
                }
                var dpi = mstrMobileApp.getDeviceDPI();
                this.sparkLineWidth = dpi > 160 ? 2 : 1;
                this.refLineWidth = 1;
                /**
                 * radius of the circle we draw on start and end points
                 */
                this.startEndPointRadius = dpi >= 320 ? 4 : dpi >= 240 ? 3 : 2;
            },

            drawChart: function drwchrt() {
                this.setColorByTheme();
                var lineProps = this.config;
                var context = this.context;
                var model = this.model;
                var values = model.series;
                var mvalues = model.mvalues;
                var margin = this.margin;
                var height = this.getHeight();
                var width = this.getWidth();
                var utils = this.utils;
                var maxVR = mvalues[mvalues.length - 1]; // this is the max value for values including reference value
                var minVR = mvalues[0]; // this is the min value for values including reference value
                var maxYValue = mvalues[mvalues.length - 1];
                var minYValue = mvalues[0];

                //this.domNode.style.position = "absolute";

                // calculate reference line value
                if (this.refv && this.refv.length > 1 && lineProps.mbRefLine) {
                    var refValue = parseFloat(this.refv[1].rv);
                    if (isNaN(refValue)) {
                        //When 2nd metric is null value / missing object, it displays sparkline without reference line
                    } else {
                        // xiawang;TQMS 531977;if the mvalues[] array has length 1, we can't just substitue it with maxVR or minVR;
                        if (refValue > maxVR) {
                            maxVR = refValue;
                            if (mvalues.length === 1) {
                                mvalues[1] = maxVR;
                            } else {
                                mvalues[mvalues.length - 1] = maxVR;
                            }
                        }
                        if (refValue < minVR) {
                            minVR = refValue;
                            if (mvalues.length === 1) {
                                mvalues[1] = mvalues[0];
                                mvalues[0] = maxVR;
                            } else {
                                mvalues[0] = minVR;
                            }
                        }
                    }

                }
                this.themeColor = lineProps.mwRefAreaCol;
                // set the begin, end, all point values. Please refer to VisChartUtils.js::drawStartEndPoints  for help
                this.isDrawStartEndPoints = lineProps.mbAllPoints ? 7 : (lineProps.mbEndPoints ? 3 : 0);
                if (this.isDrawStartEndPoints & 1 && margin.l < this.startEndPointRadius) {
                    margin.l = this.startEndPointRadius;
                }
                if (this.isDrawStartEndPoints & 2 && margin.r < this.startEndPointRadius) {
                    margin.r = this.startEndPointRadius - 1; // xiawang: there seems to be an offset when draw the chart. so we minus extra 1 for the right margin
                }

                if (model.err) {
                    return;
                }

                if (!values) {
                    return;
                }

                // xiawang: handle the case of divide by zero
                if (maxVR !== minVR) {
                    this.RTY = (height - margin.t - margin.b - 4) / (maxVR - minVR);
                } else {
                    this.RTY = 0;
                }
                if (this.windowSize !== 1) {
                    this.RTX = (width - margin.l - margin.r - 1) / (this.windowSize - 1);
                } else {
                    this.RTX = 0;
                }
                // calculate the lines and max/min Y values
                var lines = [];
                var k = 0;
                //var maxYValue = undefined;
                //var minYValue = undefined;
                for (var i = 0; i < this.windowSize; i++) {
                    var val = values[0].rv[i];
                    if (val.length === 0) {
                        continue;
                    }
                    var x = (i * this.RTX) + margin.l;
                    var y = utils.getYValue(this, val);
                    lines[k] = {x: x, y: y};
                    /*if (k === 0) {
                     maxYValue = minYValue = y;
                     }
                     if (y < minYValue) {
                     minYValue = y;
                     } else if (y > maxYValue) {
                     maxYValue = y;
                     }*/
                    k++;
                }
                if (lines.length === 0) {
                    //no data to draw lines
                    return;
                }
                maxYValue = utils.getYValue(this, maxYValue);
                minYValue = utils.getYValue(this, minYValue);
                //console.log("maxY:"+maxYValue+",minY:"+minYValue);
                if (maxYValue === undefined || minYValue === undefined) { // if either maxYValue or minYValue is unset, default to draw the whole chart
                    maxYValue = height - 4 - margin.b;
                    minYValue = margin.t;
                }
                // draw the background. According to spec and TQMS 531508, the background only between maxV and minV
                if (this.isDrawRefArea) {
                    context.fillStyle = this.themeColor;
                    context.fillRect(margin.l, minYValue, width - margin.r - margin.l, (maxYValue - minYValue));
                }
                // draw the lines
                context.lineCap = 'round';
                context.lineWidth = this.sparkLineWidth;
                context.lineJoin = 'round';
                context.strokeStyle = this.sparkLineColor;

                utils.drawLineSet(this, lines, false, context);

                // draw the start and end points
                if (this.isDrawStartEndPoints) {
                    utils.drawStartEndPoints(this, lines, context, this.isDrawStartEndPoints);
                }

                // draw the reference line
                if (this.refv && this.refv.length > 1 && lineProps.mbRefLine) {
                    var refValue = this.refv[1].rv * 1.0;
                    var y = this.utils.getYValue(this, refValue);
                    if (isNaN(y)) {
                        y = height - 5;
                    }
                    if (context.lineWidth % 2 === 1) {
                        y = Math.round(y + 0.5) - 0.5; // xiawang: To remove the alias effect when the line width is 1 pixel
                    }
                    context.beginPath();
                    context.moveTo(margin.l, y);
                    context.lineTo(width - margin.r, y);
                    context.lineWidth = this.refLineWidth;
                    context.strokeStyle = this.refLineColor;
                    context.stroke();
                }
            },

            /**
             * Called to highlight a single data point
             * @param {Integer} [x] the x axis point to highlight
             */
            highlightPoint: function hghlghtpnt(x, touchY) {

                var me = this,
                    ctx = me.highlightContext,
                    height = me.getHeight(),
                    width = me.getWidth(),
                    margin = me.margin,
                    model = me.model,
                    utils = me.utils;

                ctx.clearRect(0, 0, width, height);

                if (x < 0) {
                    return;
                }

                var xcoord = (x * me.RTX) + margin.l;

                ctx.globalAlpha = 1;

                ctx.strokeStyle = this.sparkLineColor;
                ctx.fillStyle = ctx.strokeStyle;

                var y = utils.getYValue(me, model.series[0].rv[x]);

                if (xcoord < 5) {
                    xcoord = 5;
                }
                if (xcoord > width - 5) {
                    xcoord = width - 5;
                }
                if (y < 5) {
                    y = 5;
                }
                if (y > height - 5) {
                    y = height - 5;
                }
                ctx.strokeStyle = "FFFFFF";
                ctx.fillStyle = ctx.strokeStyle;
                ctx.globalAlpha = 0.8;
                utils.drawArc(this, xcoord, y, 5, 0, Math.PI * 2, true, true, ctx);

                ctx.strokeStyle = this.sparkLineColor;
                ctx.fillStyle = ctx.strokeStyle;
                ctx.globalAlpha = 1.0;
                utils.drawArc(me, xcoord, y, 5, 0, Math.PI * 2, true, false, ctx);
                utils.drawArc(me, xcoord, y, 2.5, 0, Math.PI * 2, true, true, ctx);
                this.highlightCanvas.id = "highLightCav" + this.widget.domNode.id;
            },

            renderTooltip: function rndrttp(valIndex, touchX, touchY) {
                if (valIndex < 0) {
                    this.toolTipMain.style.display = 'none';
                    return;
                }

                var highLightCav = document.getElementById("highLightCav" + this.widget.domNode.id);
                if (highLightCav) {
                    var highlightCt = highLightCav.getContext('2d');
                    highLightCav.id = "";
                    highlightCt.clearRect(0, 0, 1000, 1000);
                }

                var m = this.model,
                    s = m.series,
                    utils = this.utils,
                    l = s.length,
                    si = this.seriesIndex,
                    ch = m.colHeaders,
                    rh = this.baseModel.rowHeaders,
                    ttp = this.toolTipMain;

                var me = this,
                    ctx = me.highlightContext,
                    height = me.getHeight(),
                    width = me.getWidth(),
                    margin = me.margin,
                    utils = me.utils;

                var metrics = m.mtrcs;
                metrics = metrics.items;
                if (isNaN(this.kpiOffset)) {
                    this.kpiOffset = 0;
                }
                var sn = '';

                var line1 = m.categories.tn + ': ' + m.categories.items[valIndex];
                var line2;// = metrics[this.kpiOffset] + ": " + s[0].v[valIndex];
                if (/*!this.widget.isKPI &&*/ this.widget.sparklineProps.mstrAssMetric) {
                    line2 = this.widget.sparklineProps.mstrAssMetric + ": " + s[0].v[valIndex];
                }
                else {
                    line2 = metrics[this.kpiOffset] + ": " + s[0].v[valIndex];
                }
                var relx = (valIndex * me.RTX) + margin.l;
                var rely = utils.getYValue(me, s[0].rv[valIndex]);

                var leng1 = this.widget.getTextWidthByCanvas(line1, ttp);
                var leng2 = this.widget.getTextWidthByCanvas(line2, ttp);

                var domHtml = line1 + '<br/>' + line2;

                var leng3 = 0;
                if (this.refv && this.refv.length > 1 && this.config.mbRefLine) {
                    domHtml += "<br/>";
                    var line3 = metrics[this.kpiOffset + 1] + ": " + this.refv[1].v;
                    leng3 = this.widget.getTextWidthByCanvas(line3, ttp);
                    domHtml += line3;
                }
                ttp.innerHTML = '<div style="margin-left:5px;margin-bottom:4px;margin-top:5px;">' + domHtml + "</div>";

                var maxLength = Math.max(leng1, leng2, leng3);

                var oft = mstrmojo.boxmodel.offset(this.domNode, this.widget.domNode);
                var pos = mstrmojo.dom.position(this.domNode, true);
                var posWdt = mstrmojo.dom.position(this.widget.domNode, true);
                var maxWidth = maxLength + 10;
                ttp.style.display = 'block';
                ttp.style.borderColor = this.sparkLineColor;
                ttp.style.width = maxWidth + "px";

                var topOff = (rely + pos.y - posWdt.y - ttp.offsetHeight - 29);
                if (topOff < 0) {
                    topOff = 0;
                }
                var leftOff = (oft.left + relx + maxWidth + 20);
                if (leftOff > this.widget.getWidth()) {
                    leftOff = (relx + oft.left - maxWidth - 20);
                    if (leftOff < 0) {
                        leftOff = 0;
                    }
                } else {
                    leftOff -= maxWidth;
                }

                ttp.style.top = topOff + "px";
                ttp.style.left = leftOff + "px";

                var yadjust = this.mainOffsetTop === 0 ? ttp.offsetHeight + 20 : (2 * ttp.offsetHeight) + 30;
                var yPos = utils.getYValue(this, s[si].rv[valIndex]) - yadjust + this.offsetTop;
                if (yPos < 0) {
                    yPos = 0;
                }

                if (this.mainWidth > 0) {
                    var xposr = touchX + ttp.offsetWidth + this.offsetLeft - this.mainLeftPos;
                    if (xposr > this.mainWidth) {
                        touchX -= (xposr - this.mainWidth);
                    }
                }

            },

            /***
             *
             * @param touchX x coord based on widget
             * @param touchY y coord based on widget
             */
            isTouchPointInGraphRange: function tpInGR(touchX, touchY) {
                var margin = this.margin;
                if (touchX < margin.l || touchY < margin.t || touchY > this.canvas.height - margin.b) {
                    return false;
                }

                return true;
            },

            showTooltip: function handleTouchMove(touchX, touchY) {
                if (!this.config.mbShowTooltip) {
                    return false;
                }
                var me = this,
                    m = me.model;

                if (m.series[0].rv.length <= 1) {
                    return false;
                }

                //find x y position on canvas
                var pos = mstrmojo.dom.position(this.domNode, true);
                touchX = touchX - pos.x;
                touchY = touchY - pos.y;

                if (!this.isTouchPointInGraphRange(touchX, touchY)) {
                    return false;
                }

                var touchVal = me.getTouchValue(touchX, touchY);

                var margin = this.margin;

                if (touchVal !== null) {

                    var x = (touchVal * me.RTX) + margin.l;

                    /*
                     * TQMS 749810:
                     * on device issue:
                     * if the highlight point is covered by leftChart, we will not show the tooltip
                     */

                    if (me.widget.enableSmoothScroll) {
                        if (this.domNode.offsetLeft + x < this.widget._scroller.origin.x) {
                            return false;
                        }
                    }

                    var rns = (m.rne - m.rns > 1) ? m.rns : m.rns - 1;

                    if (me.seriesIndex === -1 || me.switchSeriesOnTouch) {
                        me.seriesIndex = me.utils.getSeriesIndexAndYValue(me, rns + touchVal, touchY).si;
                    }

                    if (m.series[me.seriesIndex].rv[rns + touchVal] === "") {
                        return false;
                    }

                    me.prevHighlight = me.currentHighlight;
                    me.currentHighlight = touchVal;

                    //To improve performance:
                    //only need to update tooltip and highlight point when curr point changed, or first show tooltip
                    if (!me.widget.tooltipShow || me.prevHighlight != me.currentHighlight) {
                        me.renderTooltip(touchVal, x, touchY);
                        me.highlightPoint(touchVal, touchY);
                    }

                    return true;

                }
            }

        }
    );

})();
(function() {

	mstrmojo.requiresCls("mstrmojo.VisChart");

	var DEFAULT_DARK_THEME = 1;
	var DEFAULT_LIGHT_THEME = 2;
	var CUSTOM_DARK_THEME = 3;
	var CUSTOM_LIGHT_THEME = 4;


	mstrmojo.VisMicroChartBar = mstrmojo.declare(

			mstrmojo.VisChart,

			null,

			{

				scriptClass: 'mstrmojo.VisMicroChartBar',


				isDrawAxis: false,


				margin:{t:0, r:1, b:0, l:1},


				showHighlightLine: false,


				themeColor: '#FFFFFF',


				noBackground: true, // There should be no background for microChart


				isAnimateLines: false,


				toolTipMain: null,

				labelLen: 0,

				mainWidth: 0,


				mainLeftPos: 0,

				markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};top:{@top};left:{@left};position:relative;" ' +
				' mstrAttach:mousedown,mouseup,mousemove,click ' +
				'><canvas width="{@width}" height="{@height}"></canvas>' +
				'<canvas style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>' +
				'<canvas style="position:absolute;left:0;top:0" width="{@width}" height="{@height}"></canvas>' +
				'<div style="position:absolute;left:0px;top:0px;padding-left:1px;padding-top:1px;text-align:left;-webkit-text-size-adjust: none"></div>' +
				'<div style="position:absolute;left:0px;bottom:0px;padding-left:1px;padding-bottom:1px;text-align:left;-webkit-text-size-adjust: none"></div>' +
				'</div>',

				/**
				 * @ignore
				 */
				markupSlots: {
					//the main canvas of the Chart
					canvas: function(){ return this.domNode.firstChild; },
					animationCanvas: function(){ return this.domNode.childNodes[1]; },
					highlightCanvas: function(){ return this.domNode.childNodes[2]; },
					minLabel: function(){ return this.domNode.childNodes[3];},
					maxLabel: function(){ return this.domNode.childNodes[4];}
				},

				postBuildRendering: function postBR() {
					if (this._super) {
						this._super();
					}
					//draw bar when size == 1, TQMS 531674
					this.windowSize = this.model.series[0].rv.length;
	                if (this.windowSize === 1) {
	                	this.plot();
	                }

				},


                /**
                 * Returns the selected value index
                 *
                 * @param touchX The x position of the click event on widget.
                 * @returns {int} The index of selected bar.
                 */
                 getTouchValue: function gtvlindx(touchX) {
                    var series = this.model.series[0];
                    var ind = 0;
                    for (var i = 0; i < series.v.length; i++) { // xiawang: use real bar position to decide show which bar
                        if (touchX < this.hightLightPos[i].x) {
                            if (i === 0) {
                                ind = i;
                            } else {
                                ind = (this.hightLightPos[i].x + this.hightLightPos[i - 1].x)/2 > touchX? (i - 1): i;
                            }
                            break;
                        }
                    }
                    if (i !== series.v.length) {
                    } else {
                        ind = i - 1;
                    }
                    return ind;
				},


                /***
                 *
                 * @param touchX x coord based on widget
                 * @param touchY y coord based on widget
                 */
                isTouchPointInGraphRange: function tpInGR(touchX, touchY){
                    if (touchX <= this.labelLen + 1 || touchX >= this.getWidth() - 1 ) {
                        return false;
                    }
                    return true;
                },

                /**
                 *
                 * @param pageX
                 * @param pageY
                 */
				showTooltip: function rndrttp(pageX, pageY) {
					if(!this.config.mbShowTooltip || this.noDataToShowTtp) {
						return false;
					}

                    var m = this.model,
                        series = m.series[0];

                    if(series.rv.length <= 1){
                        return false;
                    }

					var pos = mstrmojo.dom.position(this.domNode, true);
					var touchX = pageX - pos.x;
					var touchY = pageY - pos.y;

                    if(!this.isTouchPointInGraphRange(touchX, touchY)){
                        return false;
                    }


                    var touchVal = this.getTouchValue(touchX, touchY);



                    var x =  this.hightLightPos[touchVal].x;
                    /*
                     * TQMS 749810:
                     * on device issue:
                     * if the highlight point is covered by leftChart, we will not show the tooltip
                     */
                    if(this.widget.enableSmoothScroll){
                        if(this.domNode.offsetLeft + x < this.widget._scroller.origin.x){
                            return false;
                        }
                    }

                    this.prevHighlight = this.currentHighlight;
                    this.currentHighlight = touchVal;

                    //To improve performance:
                    //only need to update tooltip and highlight point when curr point changed, or first show tooltip
                    if(!this.widget.tooltipShow || this.prevHighlight != this.currentHighlight){

                        touchX = Math.round(this.hightLightPos[touchVal].x);
                        touchY = Math.round(this.hightLightPos[touchVal].y);

                        var vl = series.rv[touchVal] * 1.0;
                        var tColor = this.posBarColor;
                        if(vl < 0) {
                            tColor = this.negBarColor;
                        }
                        if(series.thClr && series.thClr[touchVal]){
                            //if there is threshold use threshold color;
                            tColor = series.thClr[touchVal];
                        }

                        this.renderTooltip(touchVal, x, touchY, tColor);
                        this.highlightPoint(touchX, touchY, tColor);
                    }
                    return true;
                },

                renderTooltip: function rndrttp(valIndex, touchX, touchY, tColor) {
                    var model = this.model;
                    var barProps = this.config;
                    var series = model.series[0],
                        categories = model.categories.items,
                        width = this.getWidth();
                    var metrics = model.mtrcs;
                    metrics = metrics.items;
                    var ttp = this.toolTipMain;

					var line1 = model.categories.tn + ": " + categories[valIndex];
					if(isNaN(this.kpiOffset)) {
						this.kpiOffset = 0;
					}

					if(/*!this.widget.isKPI && */this.widget.sparklineProps.mstrAssMetric)
						line2 = this.widget.sparklineProps.mstrAssMetric + ": " + series.v[valIndex];
					else
						line2 = metrics[this.kpiOffset] + ": " + series.v[valIndex];

					var maxLength = this.widget.getTextWidthByCanvas(line1, ttp);
					var leng2 = this.widget.getTextWidthByCanvas(line2, ttp);
					if(leng2 > maxLength) {
						maxLength = leng2;
					}
					var domHtml =  line1 + '<br/>' + line2;

					if(this.refv && this.refv.length > 1 && this.config.mbRefLine) {
						domHtml += "<br/>";

						var line3 = metrics[this.kpiOffset + 1] + ": " + this.refv[1].v;
						var leng3 = this.widget.getTextWidthByCanvas(line3, ttp);
						if(leng3 > maxLength) {
							maxLength = leng3;
						}
						domHtml += line3;
					}
					ttp.innerHTML = '<div style="margin-left:5px;margin-bottom:4px;margin-top:5px;">' + domHtml + "</div>";

					//there is issue in boxmodel.offset when the scroller.origin.x < 0
//					var oft = mstrmojo.boxmodel.offset(this.domNode, this.widget.domNode);
                    var pos = mstrmojo.dom.position(this.domNode, true);
					var posWdt = mstrmojo.dom.position(this.widget.domNode, true);
					var oft =  {
							left: pos.x - posWdt.x,
							top: pos.y - posWdt.y
					};

					var maxWidth = maxLength + 10;
					ttp.style.display = 'block';
					ttp.style.borderColor = tColor;
					ttp.style.width = maxWidth + "px";

					var topOff = (touchY + pos.y - posWdt.y - ttp.offsetHeight - 29);
					if(topOff < 0) {
						topOff = 0;
					}
					var leftOff = (oft.left + touchX + maxWidth + 20);
					if(leftOff > this.widget.getWidth()) {
						leftOff = (touchX + oft.left  - maxWidth - 20);
						if(leftOff < 0) {
							leftOff = 0;
						}
					} else {
						leftOff -= maxWidth;
					}
					ttp.style.display = 'none';
					ttp.style.top = (topOff) + "px";
					ttp.style.left = (leftOff) + "px";
					ttp.style.display = 'block';

				},

				highlightPoint: function highlightPoint(touchX, touchY, tColor){
//					var highLightCav = document.getElementById("highLightCav" + this.widget.domNode.id);
//					if(highLightCav) {
//						var highlightCt = highLightCav.getContext('2d');
//                		highLightCav.id = "";
//                		highlightCt.clearRect(0, 0, 1000, 1000);
//					}

                    var ctx = this.highlightContext,
                        width = this.getWidth(),
                        height = this.getHeight(),
                        utils = this.utils;


                    ctx.clearRect(0, 0, width, height);
                    ctx.globalAlpha = 1;

                    touchX = touchX > 5 ? touchX : 5;
                    if(touchX > width - 5) {
                        touchX = width - 5;
                    }
                    touchY = touchY > 5 ? touchY : 5;
                    if(touchY > height - 5) {
                        touchY = height - 5;
                    }
                    ctx.globalAlpha = 0.8;
                    ctx.strokeStyle = "FFFFFF";
                    ctx.fillStyle = ctx.strokeStyle;
                    utils.drawArc(this, touchX, touchY, 5, 0, Math.PI * 2, true, true, ctx);

                    ctx.strokeStyle = tColor;
                    ctx.fillStyle = ctx.strokeStyle;

                    ctx.globalAlpha = 1.0;
                    utils.drawArc(this, touchX, touchY, 5, 0, Math.PI * 2, true, false, ctx);
                    utils.drawArc(this, touchX, touchY, 2.5, 0, Math.PI * 2, true, true, ctx);
                    this.highlightCanvas.id = "highLightCav" + this.widget.domNode.id;
				},

				textLen: function txtLn(str) {
					// xiawang: this method should be obsolted because we can use context.measureText() method to measure text which are more accurate
					var len = 0;
				    for (var i = 0; i < str.length; i++) {
				        if (str.charCodeAt(i) > 255 || str.charCodeAt(i<0)) len += 2; else len ++;
				    }
				    return len;
				},

				handleTouchMove: function () {
					// xiawang: do nothing. Just disable parent class method.
				},

				reDrawChart: function reDrwchart(){
					var context = this.context,
						canvas = this.canvas,
						wd = canvas.width,
						ht = canvas.height;
					context.clearRect(0,0, wd, ht);
					this.data.processLinearData(this);
					 //cache the values length property
	                this.windowSize = this.model.series[0].rv.length;
	              //fill the Chart's background with the theme color
					this.utils.fillBackground(this);

					if(this.windowSize < 1) {
						return; // not enought data to draw chart
					}
					this.drawChart();
				},

				setColorByTheme: function setColorByTheme(){
					var barProps = this.config;
					if(this.theme == DEFAULT_DARK_THEME || this.theme == DEFAULT_LIGHT_THEME){
						this.posBarColor = "#598200";
						this.negBarColor = "#CC3A06";

						this.xAxisLineWidth = 1;
						this.xAxisLineColor = "#7F7F7F";
						this.refLineWidth = 1;
						this.refLineColor = "#00A6EF";
					}else{
						this.posBarColor = barProps.mwPosCol;
						this.negBarColor = barProps.mwNegCol;

						this.xAxisLineWidth = 1;
						this.xAxisLineColor = "#000000";
						this.refLineWidth = 1;
						this.refLineColor = barProps.mwRefLineCol;
					}
				},

				drawChart: function drwchrt() {

					var model = this.model;
					var barProps = this.config;
					if(model.err) {
						this.noDataToShowTtp = true;
						return;
					}

					this.setColorByTheme();

					var context = this.context,
					values = model.series,
					height = this.getHeight(),
					width = this.getWidth(),
					me = this,
					utils = this.utils;
					var barOffset = 0;
					var barPadLeft = this.margin.l;
					var barPadRight = this.margin.r;

					var min = 0,
						max = 0,
						minLabel = maxLabel = "",
						series = model.series[0];

					for (var i = 0; i < series.v.length; i ++) {
						var vl = parseFloat(series.rv[i]);
						if (i === 0) {// for the first element, set max and min
							max = min = vl;
							minLabel = maxLabel = series.v[i];
						} else if(vl > max) {
							max = vl;
							maxLabel = series.v[i];
						} else if(vl < min) {
							min = vl;
							minLabel = series.v[i];
						}
					}

					if(isNaN(min) && isNaN(max)){
						//all the data is NaN, draw nothing
						this.minLabel.innerHTML = "";
						this.maxLabel.innerHTML = "";
						this.noDataToShowTtp = true;
						return;
					}

					this.noDataToShowTtp = false;

					if (barProps.mbShowLegend) { // xiawang: do not show the legend if not told to
						var fontSize = Math.ceil(Math.min(12, (height / 2) * 0.7));  // xiawang: original is 13px, change to match Flash behavior
						var mintxt = "Min:" + minLabel.replace(/[ ]/g, "");
						var maxtxt = "Max:" + maxLabel.replace(/[ ]/g, "");

						this.minLabel.innerHTML = mintxt;
						this.maxLabel.innerHTML = maxtxt;

						// leave at least 10 pixels for chart
						var maxBarOffset = width - 10;
						if(maxBarOffset > width * 0.5){
							maxBarOffset = Math.floor(width*0.5);
						}
						do {
							this.minLabel.style.fontSize = fontSize + "px";
							this.maxLabel.style.fontSize = fontSize + "px";
							var fontFamily = "Arial";
							var minTxtLen = this.widget.getTextWidth(mintxt, "", fontFamily, fontSize, "px", this.isTextBold);
							var maxTxtLen = this.widget.getTextWidth(maxtxt, "", fontFamily, fontSize, "px", this.isTextBold);
							var txtLen = minTxtLen > maxTxtLen? minTxtLen: maxTxtLen; // get the maximum text length
							barOffset = txtLen + barPadLeft;
							fontSize -= 1;
						} while ( barOffset > maxBarOffset && fontSize > 5); //add fontSize > 5 to avoid endless loop
						fontSize += 1;
					} else {
						barOffset = barPadLeft;
					}

					this.labelLen = barOffset;

					// xiawang: process the reference value. This might need result in adjust of min/max value
					if(this.refv && this.refv.length > 1 && barProps.mbRefLine) {
						var refValue = this.refv[1].rv * 1.0;
						if(refValue < min) {
							min = refValue;
						}
						if(refValue > max) {
							max = refValue;
						}
					}
					// xiawang: processs the base line
					var ts = max - min;
					var baseY = 0;
					var barPadTop = 5;
					var barPadBottom = 5;
					var rangeRatio = height - barPadTop - barPadBottom; // use rangeRatio to universally calculate the printed height
					if (ts == 0) { // xiawang: consider the case when max == min or any value is undefined
						if (min == 0) {
							baseY = height / 2;
							rangeRatio = 0;
						} else {
							rangeRatio /= Math.abs(max);
							if (max < 0) {
								baseY = barPadTop;
							} else {
								baseY = height - barPadBottom;
							}
						}
					} else if(max < 0) {
						baseY = barPadTop;
						rangeRatio /= Math.abs(min);
					} else if (min < 0) {
						baseY = max / ts * rangeRatio + barPadTop;
						rangeRatio /= ts;
					} else { // both are larger than 0
						baseY = height - barPadBottom;
						rangeRatio /= max;
					}


					// xiawang: draw each value bar
					// xiawang: TQMS 532258, Change the bar size to smaller. We should also be more smart to decide position and size of each bar to make it looks symmetric
					var barTotalWidth = width - barOffset - barPadRight;
					var barCount = series.v.length;
					var barSpaceWidth = barTotalWidth * 0.4 / barCount; // allocate 40% for space
					barSpaceWidth = barSpaceWidth >= 1? barSpaceWidth: 1; // space at least 1
					var barWidth = barTotalWidth / barCount - barSpaceWidth;
					this.hightLightPos = [];
					for(var i = 0; i < barCount; i ++) {
						this.hightLightPos[i] = {};
						var vl = series.rv[i] * 1.0;
						var direct = true;
						if(vl < 0) {
							vl = 0 - vl;
							direct = false;
						}
						//console.log("data value: " + vl);
						var hgt = vl * rangeRatio;
						//console.log("data height: " + hgt);
						var cw = (width - barOffset) / series.v.length;
						this.drawBar(barOffset + (barWidth + barSpaceWidth) * i + barSpaceWidth / 2, baseY, barWidth, hgt, context, series.thClr && series.thClr[i],direct, this.hightLightPos[i]);
					}

					// xiawang: draw the base line
					context.strokeStyle = this.xAxisLineColor;
					context.lineWidth = this.xAxisLineWidth;
					if (context.lineWidth % 2 === 1) {
						baseY = Math.round(baseY + 0.5) - 0.5; // xiawang: To remove the alias effect when the line width is 1 pixel
					}

					context.beginPath();
					context.moveTo(barOffset, baseY);
					context.lineTo(width - barPadRight, baseY);
					context.stroke();

					// xiawang: draw the reference line
					if(this.refv && this.refv.length > 1 && barProps.mbRefLine) {
						var refValue = this.refv[1].rv * 1.0;
						var refH = baseY - refValue * rangeRatio;
						//console.log("reference value: " + refValue);
						//console.log("reference height: " + refH);
						if (context.lineWidth % 2 === 1) {
							refH = Math.round(refH + 0.5) - 0.5; // xiawang: To remove the alias effect when the line width is 1 pixel
						}
						context.beginPath();
						context.moveTo(barOffset, refH);
						context.lineTo(width - barPadRight, refH);
						context.strokeStyle = this.refLineColor;// TQMS 533746
						context.stroke();
					}
				},

				drawBar: function drwBr(x, y, width, height, context, color, direct, posStore) {
					/*
					 *  xiawang: TQMS 532210 As PM said, remove the gradient effect currently to match Flash behavior
					 *
					var lingrad = context.createLinearGradient(x,y,x+width,y);
					lingrad.addColorStop(0, '#66CC00');
				    lingrad.addColorStop(0.5, '#CCFFFF');
				    lingrad.addColorStop(0.5, '#CCFFFF');
				    lingrad.addColorStop(1, '#66CC00');
				    context.fillStyle = lingrad;
				    */

					// xiawang: to remove anti-alias effect, we need to make sure the x, y, width and height are all integers.
					if (width >= 3) { // xiawang: only remove anti-alias effect if the width is larger than 3
						x = Math.round(x);
						y = Math.round(y);
						width = Math.round(width);
					}
					if (height != 0) {
						height = Math.round(height);
						if (height < 1) { // xiawang;TQMS 531982;draw the bar chart for at least 1 pixel even if the metric value is very small
							height = 1;
						}
					}

				    if(direct) {
				    	context.fillStyle = color ? color : this.posBarColor;
				    	context.fillRect(x,y - height,width,height);
				    	posStore.x = x + Math.round(width / 2.0);
				    	posStore.y = y - height;
				    } else {
				    	context.fillStyle = color ? color : this.negBarColor;
				    	context.fillRect(x,y,width,height);
				    	posStore.x = x + Math.round(width / 2.0);
				    	posStore.y = y + height;
				    }
				}
			}
	);

})();
(function () {
    mstrmojo.requiresCls("mstrmojo.Vis", "mstrmojo.dom", "mstrmojo._TouchGestures", "mstrmojo.VisChartUtils",
        "mstrmojo._HasTouchScroller", "mstrmojo.color", "mstrmojo.css", "mstrmojo.VisMicroChartLine", "mstrmojo.VisMicroChartBar", "mstrmojo.VisMicroChartBullet", "mstrmojo._NeedSyncScroller");

    //theme type
    var DEFAULT_DARK_THEME = 1;
    var DEFAULT_LIGHT_THEME = 2;
    var CUSTOM_DARK_THEME = 3;
    var CUSTOM_LIGHT_THEME = 4;

    //column type
    var ATTR_NAME = 0,
        METRIC_NAME = 1,
        METRIC_VALUE = 2,
        CHART = 3,
        TREE_TRIANGLE = 4,
        DROP_SHADOW = 5;

    var TRIANGLE_NONE = 0;
    var TRIANGLE_OPEN = 1;// "microchart-triangle-open";-webkit-transform:scale(0.9,0.7)
    var TRIANGLE_CLOSE = 2;// "microchart-triangle-close";
    var TRIANGLE_CLOSE_STYLE = "width:0px;height:0px;border-left:10px solid black;border-top:5px solid transparent;border-bottom:5px solid transparent;margin-left:auto;margin-right:auto;-webkit-transform:scale(0.8,0.9)";
    var TRIANGLE_OPEN_STYLE = "width:0px;height:0px;border-left:5px solid transparent;border-top:10px solid black;border-right:5px solid transparent;margin-left:auto;margin-right:auto;-webkit-transform:scale(0.9,0.8)";

    var DOCKED_HEADER = 0,
        OTHER_ROW = 1;

    var zf = 1;

    var $CLR = mstrmojo.color,
        $CSS = mstrmojo.css;

    var MC_TABLE_TEXT = "microchart-table-text";

    var ROW_HEIGHT = 0;
    var ROW_HEIGHT_FOR_CHART = 0;

    function removeChildren(container) {
        container.innerHTML = '';
    }

    function setDHBackGroundColor() {
        var backgroundColor = this.backgroundColor;
        if (!backgroundColor) {
            return;
        }
        this.dockedHeaderTable.style.backgroundColor = backgroundColor;
        this.dockedHeaderTable.style.opacity = '1';
        this.dockedHeaderReplaceDiv.firstChild.style.backgroundColor = backgroundColor;
        this.dockedHeaderReplaceDiv.firstChild.style.opacity = '1';
    }

    // xiawang: this is helper function to set border and background-color while
    // maintain the width and height
    function setNodeCssText(node, cssText) {
        var height = node.style.height;
        var width = node.style.width;
        var textDecoration = node.style.textDecoration;
        var display = node.style.display;
        var fontSize = node.style.fontSize;
        var paddingLeft = node.style.paddingLeft;
        var paddingRight = node.style.paddingRight;
        var boxShadow = node.style.boxShadow;
        node.style.cssText = cssText;
        node.style.height = height;
        node.style.width = width;
        node.style.textDecoration = textDecoration;
        if (display) {
            node.style.display = display;
        }
        if (fontSize) {
            node.style.fontSize = fontSize;
        }
        if (paddingLeft) {
            node.style.paddingLeft = paddingLeft;
        }
        if (paddingRight) {
            node.style.paddingRight = paddingRight;
        }
        if (boxShadow) {
            node.style.boxShadow = boxShadow;
        }

    }

    function setTreeTriangle(arrowDiv, treeNode, color) {
        var level = treeNode.level;

        var state = "";
        if (treeNode.isLeaf) {
            // for leafNode , not show triangle
            state = TRIANGLE_NONE;
        } else {
            if (treeNode.needExpand) {
                state = TRIANGLE_OPEN;
            } else {
                state = TRIANGLE_CLOSE;
            }
        }

        var whichBorderColor = null;
        var bodyFontColorRGB = this.bodyFontColorRGB;
        var theme = this.theme;

        if (state == TRIANGLE_CLOSE) {
            arrowDiv.className = "microchart-tree-arrow-close";
            whichBorderColor = "border-left-color";
        } else if (state == TRIANGLE_OPEN) {
            arrowDiv.className = "microchart-tree-arrow-open";
            whichBorderColor = "border-top-color";
        } else {
            //leaf node, no triangle
            arrowDiv.className = "";
            arrowDiv.setAttribute("style", "");
            return;
        }

        var styleContent = "";

        if (color) {
            //use specific color
            styleContent = whichBorderColor + ':' + color;
        } else if (theme == DEFAULT_LIGHT_THEME) {
            if (level == 0) {
                // First Level Triangle: color:#4C4C4C
                styleContent = whichBorderColor + ':' + '#4c4c4c';
            } else if (level == 1) {
                // Second Level Triangle: color:#4C4C4C 80% opacity
                styleContent = whichBorderColor + ':' + 'rgba(76,76,76,0.8)';
            } else if (level > 1) {
                styleContent = whichBorderColor + ':' + 'rgba(76,76,76,0.6)';
            }
        } else if (theme == DEFAULT_DARK_THEME) {
            if (level == 0) {
                // First Level Triangle: color: white opaque
                styleContent = whichBorderColor + ':' + 'white';
            } else if (level == 1) {
                // Second Level Triangle: color:white 80% opacity
                styleContent = whichBorderColor + ':' + "rgba(255,255,255,0.8)";
            } else if (level > 1) {
                styleContent = whichBorderColor + ':' + "rgba(255,255,255,0.6)";
            }

        } else if (bodyFontColorRGB && bodyFontColorRGB.length > 2 && (theme == CUSTOM_LIGHT_THEME || theme == CUSTOM_DARK_THEME)) {
            if (level == 0) {
                // First Level Triangle: color: white opaque
                styleContent = whichBorderColor + ':' + 'rgba(' + bodyFontColorRGB[0] + ',' + bodyFontColorRGB[1] + ',' + bodyFontColorRGB[2] + ',0.8)';
            } else if (level > 0) {
                // Second Level Triangle: color:white 80% opacity
                styleContent = whichBorderColor + ':' + 'rgba(' + bodyFontColorRGB[0] + ',' + bodyFontColorRGB[1] + ',' + bodyFontColorRGB[2] + ',0.7)';
            }

        }

        arrowDiv.setAttribute("style", styleContent);
    }

    function renderOneRow(rowIdx, dockedHeaderRowInfo) {
        var widget = this.widget,
            rowInfo = widget.rows[rowIdx],
            curM = rowInfo.model,
            elms = curM.elms,
            rowTmpl = this.rowTemplate,
            treeNode = rowInfo.treeNode,
            colInfos = this.colInfos,
            rowIdx = rowInfo.rowIdx,
            rowRef = null,
            colCount = colInfos.length;
        var bodyFontColorRGB = this.bodyFontColorRGB;

        var ths = this.headerTable.firstChild.firstChild.childNodes;

        rowRef = dockedHeaderRowInfo ? dockedHeaderRowInfo.rowRef : rowInfo.rowRef;

        var tr = null;
        var tds = null;
        if (rowRef[this.domRefName]) {
            //reuse the tr
            tr = rowRef[this.domRefName];
        } else {
            //new tr
            tr = rowTmpl.cloneNode(true);
            rowRef[this.domRefName] = tr;
        }
        tr.style.display = '';

        fillThemeColor.call(this, dockedHeaderRowInfo ? dockedHeaderRowInfo : rowInfo);

        //TODO
        if (!this.isAndroidTab) {
            //on phone
            tr.style.fontSize = 14 * zf + "px";
        }

        tr.setAttribute("rowType", dockedHeaderRowInfo ? DOCKED_HEADER : OTHER_ROW);

        var tds = tr.childNodes;

        var attr = null;

        for (var j = 0, tdsIdx = 0; j < colCount; j++, tdsIdx++) {
            var colInfo = colInfos[j];
            var colIdx = colInfo.colIdx;

            tds[j].setAttribute("mrow", rowInfo.rowIdx);

            if (colIdx == this.treeColumnIdx && treeNode) {
                //tree trianlge
                var arrowDiv = tds[j].firstChild;

                setTreeTriangle.call(this, arrowDiv, treeNode);

                if (!treeNode.isLeaf) {

                    arrowDiv.parentNode.setAttribute("CLK", "T");
                }
                continue;
            }

            // changed for attribute will be put in any column
            if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_NAME) {
                if (this.isTreeMode) {
                    var attrName = "";
                    for (var k = 0; k < treeNode.es.length; k++) {
                        attrName += treeNode.es[k].n;
                    }
                    //TQMS 702933:
                    if (attrName.indexOf("&lt;") >= 0) {
                        attrName = attrName.replace(/&lt;/g, "<");
                        attrName = attrName.replace(/&gt;/g, ">");
                    }

                    tds[j].innerHTML = attrName;

                    if (treeNode.level == 0) {
                        tds[j].style.fontWeight = 'bold';
                    } else {
                        tds[j].style.fontWeight = '';
                    }
                    if (treeNode.level > 0 && (this.theme == CUSTOM_DARK_THEME || this.theme == CUSTOM_LIGHT_THEME)) {
                        //Texts: user defined the first level bold
                        //		 second level or lower: 80% regular
                        if (bodyFontColorRGB && bodyFontColorRGB.length > 2) {
                            tds[j].style.color = 'rgba(' + bodyFontColorRGB[0] + ',' + bodyFontColorRGB[1] + ',' + bodyFontColorRGB[2] + ',0.8)';
                        }
                    } else {

                    }
                } else {
                    attr = elms[colInfo.order];
                    var attrName = attr ? attr.n : "";
                    //TQMS 722933:
                    if (attrName.indexOf("&lt;") >= 0) {
                        attrName = attrName.replace(/&lt;/g, "<");
                        attrName = attrName.replace(/&gt;/g, ">");
                    }
                    tds[j].innerHTML = attrName;

                }

                continue;
            }

            if (colInfo.order == "LineChart") {

                if (rowRef[colIdx]) {
                    var w = rowRef[colIdx];
                    if (curM.isTotal && !this.isTreeMode) {
                        w.domNode.style.display = 'none';
                    } else {
                        //reuse chart
                        w.domNode.style.display = '';
                        w.model = curM.model;
                        w.refv = curM.refv;
                        w.kpiOffset = this.kpiOff * rowIdx;
                        w.reDrawChart();
                        //						tds[j].appendChild(w.domNode);
                    }

                } else {
                    if (curM.isTotal && !this.isTreeMode) {
                        continue;
                    }
                    var placeholder = document.createElement("div");
                    var props = {
                        placeholder: placeholder,
                        model: curM.model,
                        refv: curM.refv,
                        config: widget.sparklineProps,
                        widget: widget,
                        kpiOffset: this.kpiOff * rowIdx,
                        width: colInfo.contentWidth,
                        height: ROW_HEIGHT_FOR_CHART,
                        toolTipMain: widget.tooltip,
                        mainOffsetTop: this.offsetTop,
                        mainLeftPos: parseInt(this.domNode.style.left, 0) || 0,
                        mainWidth: this.getWidth(),
                        isTreeMode: this.isTreeMode,
                        theme: this.theme
                    };
                    tds[j].appendChild(placeholder);
                    var w = new mstrmojo.VisMicroChartLine(props);
                    w.render();
                    tds[j].removeAttribute("class");
                    rowRef[colIdx] = w;
                }

            } else if (colInfo.order == "BarChart") {

                if (rowRef[colIdx]) {
                    var w = rowRef[colIdx];
                    if (curM.isTotal && !this.isTreeMode) {
                        w.domNode.style.display = 'none';
                    } else {
                        //reuse chart
                        w.model = curM.model;
                        w.refv = curM.refv;
                        w.kpiOffset = this.kpiOff * rowIdx;
                        w.isTextBold = this.isTreeMode ? treeNode.level == 0 : false;
                        w.reDrawChart();
                        //					tds[j].appendChild(w.domNode);
                    }
                } else {
                    if (curM.isTotal && !this.isTreeMode) {
                        continue;
                    }
                    var placeholder = document.createElement("div");
                    var props = {
                        placeholder: placeholder,
                        model: curM.model,
                        refv: curM.refv,
                        widget: widget,
                        kpiOffset: this.kpiOff * rowIdx,
                        config: widget.barProps,
                        width: colInfo.contentWidth,
                        height: ROW_HEIGHT_FOR_CHART,
                        toolTipMain: widget.tooltip,
                        mainOffsetTop: this.offsetTop,
                        mainLeftPos: parseInt(this.domNode.style.left, 0) || 0,
                        mainWidth: this.getWidth(),
                        isTreeMode: this.isTreeMode,
                        theme: this.theme,
                        isTextBold: this.isTreeMode ? treeNode.level == 0 : false
                    };

                    tds[j].appendChild(placeholder);
                    var w = new mstrmojo.VisMicroChartBar(props);
                    w.render();
                    //add the className so that the max and min value have the right style
                    tds[j].className = this.valueCssClass;
                    rowRef[colIdx] = w;
                }

            } else if (colInfo.order == "GaugeChart") {
                /*
                 * if (curM.isTotal) { continue; }
                 */
                if (rowRef[colIdx]) {
                    //reuse chart
                    var w = rowRef[colIdx];
                    w.model = curM.model;
                    w.refv = curM.refv;
                    w.kpiOffset = this.kpiOff * rowIdx;
                    w.labelColorRGB = this.bodyFontColorRGB;
                    w.reDrawChart();
                } else {
                    var placeholder = document.createElement("div");
                    var props = {
                        placeholder: placeholder,
                        model: curM.model,
                        refv: curM.refv,
                        widget: widget,
                        config: widget.bulletProps,
                        width: colInfo.contentWidth,
                        height: ROW_HEIGHT_FOR_CHART,
                        toolTipMain: widget.tooltip,
                        mainOffsetTop: this.offsetTop,
                        mainLeftPos: parseInt(this.domNode.style.left, 0) || 0,
                        mainWidth: this.getWidth(),
                        labelColorRGB: this.bodyFontColorRGB,
                        showMinLabel: this.showMinLabel,
                        isTreeMode: this.isTreeMode,
                        theme: this.theme

                    };
                    tds[j].appendChild(placeholder);
                    var w = new mstrmojo.VisMicroChartBullet(props);
                    w.render();
                    tds[j].removeAttribute("class");
                    rowRef[colIdx] = w;
                }

            } else {
                var metricIdx = -1;
                var idx = -1;

                if (this.widget.isKPI) {
                    //idx for refv in model
                    idx = parseInt(colInfo.order) % this.kpiOff;

                    //idx for the metric in metric array
                    var metricIdx = rowInfo.model.metricIdx + idx;
                } else {
                    if (colInfo.type == METRIC_VALUE) {
                        metricIdx = parseInt(colInfo.order);
                        idx = metricIdx;
                    }
                }

                var innerHTML = "";
                var cssClass = "";

                if (!curM.refv[idx]) {
                    continue;
                }

                if (curM.refv[idx].ti === undefined) { // by defult, use regular value
                    if (curM.refv[idx].ts === 4) { // xiawang: For web JSON, ts  === 4 means image
                        innerHTML = "<img src='" + curM.refv[idx].v + "'/>";
                    } else {
                        innerHTML = curM.refv[idx].v;
                    }
                } else { // there is threshold
                    try { // we will try to apply the threshold. But if it fails, we shouldn't just fail the document rendering.
                        // Instead, we show default value;
                        var model = this.widget.model;
                        var th = model.th['' + metricIdx];
                        var ti = curM.refv[idx].ti;

                        if (curM.refv[idx].ty === 4) { // xiawang: This is image type
                            var path;
                            if (th[ti] && th[ti].n) {
                                path = th[ti].n;
                            } else {
                                path = curM.refv[idx].v;
                            }
                            if (path.indexOf(":") >= 0) { // xiawang: Then it is absolute image path like http://.... or ftp://...
                                // do nothing
                            } else { // xiawang: Then it is relative image path like "Images/Arr3_Up.png". We should append base url to the image path
                                var baseURL;
                                try {
                                    baseURL = mstrApp.getConfiguration().getHostUrlByProject(mstrApp.getCurrentProjectId());
                                } catch (err) {
                                    baseURL = "";
                                }
                                path = baseURL + path;
                            }
                            innerHTML = "<img src='" + path + "'/>";
                        } else {
                            if (th[ti] && th[ti].n && th[ti].cni !== undefined) { // if the threshold text is there, use it
                                innerHTML = th[ti].n;
                            } else {
                                innerHTML = curM.refv[idx].v;
                            }
                            tds[j].style.fontSize = this.widget.fontSize; // xiawang: We should keep consistent with Flash and iOS to
                            // NOT inherite font size from Threshold at this time
                        }
                        cssClass = model.css[th[ti].cni].n;
                    } catch (err) {
                        if (!innerHTML) { // xiawang: If innerHTML is not finalized yet.
                            innerHTML = curM.refv[idx].v;
                        }
                    }
                }

                if (cssClass) {
                    tds[j].className = colInfo.valueCssClass + " " + cssClass;
                } else if (this.valueCssClass) {
                    tds[j].className = colInfo.valueCssClass + " " + this.valueCssClass;
                } else {
                    tds[j].className = colInfo.valueCssClass;
                }

                tds[j].innerHTML = innerHTML;
            }

            //set first level font weight to bold
            if (this.isTreeMode) {
                if (treeNode.level == 0) {
                    tds[j].style.fontWeight = 'bold';
                } else {
                    tds[j].style.fontWeight = '';
                }
            }
        }

        if (this.isTreeMode) {
            /*
             * Drop shadow are need to apply below the higher level add the drop
             * shadow on the top of the first row, which are added under the
             * expanded treeNode
             * For docked header, it is always expanded, so we add the drop shadow and remove the dividing line
             */
            var preRowInfo = widget.rows[rowIdx - 1];
            var preRowExpanded = preRowInfo && preRowInfo.treeNode.level < rowInfo.treeNode.level;
            var isDockedHeader = dockedHeaderRowInfo != undefined;
            var isFirstRow = rowIdx == 0;

            if (preRowExpanded || ( isDockedHeader && treeNode.level > 0)) {
                //show drop shadow and remove dividing line
                var tdCount = tds.length;
                for (var i = 0; i < tdCount; i++) {
                    if (this.theme == DEFAULT_LIGHT_THEME || this.theme == CUSTOM_LIGHT_THEME) {
                        tds[i].style.boxShadow = '0px 5px 3px -3px rgba(0,0,0,0.2) inset';
                    } else if (this.theme == DEFAULT_DARK_THEME || this.theme == CUSTOM_DARK_THEME) {
                        tds[i].style.boxShadow = '0px 6px 3px -3px rgba(0,0,0,0.5) inset';
                    }

                }

                //if show the drop shadow, we will not draw the dividing line, but have to keep the 1px border
                //so that the row height is same
                tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0)';

            } else if ((isDockedHeader && treeNode.level == 0 || isFirstRow) && (this.theme == DEFAULT_LIGHT_THEME || this.theme == DEFAULT_DARK_THEME)) {
                /*
                 * PM required:
                 * For default dark theme and default light theme: the 2px line between the header and the body should be removed.
                 * For custom themes, the 2px line should be left as it is.
                 */
                tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0)';
            } else {
                var tdCount = tds.length;
                for (var i = 0; i < tdCount; i++) {
                    tds[i].style.boxShadow = '';
                }
            }
        }

        var rowInfoToHighlight = dockedHeaderRowInfo ? dockedHeaderRowInfo : rowInfo;
        if (this.isTreeMode) {
            //tree mode
            if (treeNode.selected) {
                this.widget.highlightRowByRowInfo(rowInfoToHighlight);
            } else {
                this.widget.unHighlightRowByRowInfo(rowInfoToHighlight);
            }

        } else {
            //none-tree mode
            if (this.widget.isAllAttrSelectable) {
                if (rowInfo.selected[-1]) {
                    //highlight entire row
                    this.widget.highlightRowByRowInfo(rowInfo);
                } else {
                    this.widget.unHighlightRowByRowInfo(rowInfo);
                }
            } else {
                //highlight one cell
                this.widget.highlightCellsByRowInfo(rowInfo);
            }
        }

        return tr;
    }

    function fillThemeColor(rowInfo) {
        var tr = rowInfo.rowRef[this.domRefName];
        // set fill color
        if (this.isTreeMode) {

            var treeNode = rowInfo.treeNode
            var level = treeNode.level;

            if (level == 0) {
                //First level row
                if (this.theme == DEFAULT_LIGHT_THEME) {

                    tr.style.backgroundColor = '#f9f9f9';
                    tr.style.color = '#191919';
                    // Dividing line on top of the first level: black, 15% opacity, 1px
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.3)';

                } else if (this.theme == DEFAULT_DARK_THEME) {

                    tr.style.backgroundColor = '#333333';
                    tr.style.color = 'white';
                    // Dividing line on top of the first level: white, 30% opacity, 1px
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.3)';

                } else if (this.theme == CUSTOM_DARK_THEME) {
                    tr.style.backgroundColor = '';

                    // Dividing line follow DEFAULT_DARK_THEME
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.3)';

                } else if (this.theme == CUSTOM_LIGHT_THEME) {
                    tr.style.backgroundColor = '';
                    // Dividing line follow DEFAULT_DARK_THEME
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.3)';

                }

                tr.style.font = 'bold 12pt Helvetica';

            } else if (level == 1) {
                //Second level row
                if (this.theme == DEFAULT_LIGHT_THEME) {

                    tr.style.backgroundColor = '#e5e5e5';
                    tr.style.color = '#4c4c4c';
                    // Dividing line on top of the second level: white, 20% opacity, 1px
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.2)';

                } else if (this.theme == DEFAULT_DARK_THEME) {

                    tr.style.backgroundColor = '#232323';
                    tr.style.color = '#cccccc';
                    // Dividing line on top of the second level: white, 20% opacity, 1px
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.2)';

                } else if (this.theme == CUSTOM_DARK_THEME) {

                    tr.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                    // Dividing line follow DEFAULT_DARK_THEME
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.2)';

                } else if (this.theme == CUSTOM_LIGHT_THEME) {

                    tr.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
                    // Dividing line follow DEFAULT_LIGHT_THEME
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.2)';

                }

                tr.style.font = '12pt Helvetica';

            } else if (level == 2) {
                //Third level row
                if (this.theme == DEFAULT_LIGHT_THEME) {

                    tr.style.backgroundColor = '#d1d1d1';
                    tr.style.color = '#333333';
                    // Dividing line on top of the third level: white, 10%
                    // opacity, 1px
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.1)';

                } else if (this.theme == DEFAULT_DARK_THEME) {

                    tr.style.backgroundColor = '#0F0F0F';
                    tr.style.color = '#cccccc';
                    // Dividing line on top of the third level: white, 10%
                    // opacity, 1px
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.1)';

                } else if (this.theme == CUSTOM_DARK_THEME) {

                    tr.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                    // Dividing line follow DEFAULT_DARK_THEME
                    tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.1)';

                } else if (this.theme == CUSTOM_LIGHT_THEME) {

                    tr.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';
                    // Dividing line follow DEFAULT_LIGHT_THEME
                    tr.style.borderTop = 'solid 1px rgba(0, 0, 0, 0.1)';

                }
                tr.style.font = '12pt Helvetica';
            } else if (level > 2) {
                //Four or more level row
                var opc = level > 9 ? 1 : level / 10;

                if (this.theme == DEFAULT_LIGHT_THEME) {

                    tr.style.backgroundColor = '#BDBDBD';
                    tr.style.color = '#333333';

                } else if (this.theme == DEFAULT_DARK_THEME) {

                    tr.style.backgroundColor = '#000000';
                    tr.style.color = '#cccccc';

                } else if (this.theme == CUSTOM_DARK_THEME) {

                    tr.style.backgroundColor = 'rgba(255, 255, 255, ' + opc + ')';

                } else if (this.theme == CUSTOM_LIGHT_THEME) {

                    tr.style.backgroundColor = 'rgba(0, 0, 0, ' + opc + ')';

                }

                tr.style.font = '12pt Helvetica';
                //TQMS 698607: add dividing line for four or more levels
                tr.style.borderTop = 'solid 1px rgba(255, 255, 255, 0.1)';
            }

        } else {
            //none tree mode
            if (this.theme == DEFAULT_LIGHT_THEME) {
                tr.style.backgroundColor = '#f9f9f9';
                tr.style.font = '12pt Helvetica';
                tr.style.color = '#191919';
            } else if (this.theme == DEFAULT_DARK_THEME) {
                tr.style.backgroundColor = '#333333';
                tr.style.font = '12pt Helvetica';
                tr.style.color = 'white';
            }
        }
    }

    function setScrollerPosition(scrollTo) {
        var scl = this._scroller,
            icn = this.chartTable,
        //			offsetEnd = Math.max((this.widget.rows.length - this.widget.startCnt) * this.rowOffsetHeight  + hbody.offsetHeight - this.getHeight() + 2, 0);
            offsetEnd = Math.max(this.chartTableOffsetHeight + this.headerTableOffsetHeight - this.getHeight(), 0);

        scl.origin = {
            x: scrollTo && scrollTo.x || 0,
            y: scrollTo && scrollTo.y || 0
        };

        scl.showScrollbars = this.showScrollbars;
        scl.vScroll = (offsetEnd !== 0 && scl.noVScroll !== true) || this.scrollPast;

        if (scl.vScroll) {

            scl.offset = {
                y: {
                    start: 0,
                    end: offsetEnd
                },
                scrollPast: this.scrollPast

            };
        }

        this.utils.translateCSS(-scl.origin.x, -scl.origin.y, false, icn);
    }

    mstrmojo.VisMicroChartTable = mstrmojo.declare(

        mstrmojo.Vis,

        //mixin
        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller, mstrmojo._NeedSyncScroller ],

        {
            scriptClass: 'mstrmojo.VisMicroChartTable',

            utils: mstrmojo.VisChartUtils,

            scrollerConfig: {
                bounces: false,
                showScrollbars: false,
                useTranslate3d: false,
                hScroll: false,
                vScroll: true
            },

            scrollPast: false,

            /*
             * colInfos get from VisMicroChart.js
             */
            colInfos: null,

            rowTemplate: null,

            theme: -1,

            isTreeMode: false,

            showMinLabel: false,

            bodyFontColorRGB: null,

            markupString: '<div id="{@id}-microchart-table" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};z-index:{@zIndex};position:absolute;background-color:{@backgroundColor}">'
                +
                '<div id="{@id}-header-bar" class="microchart-header-div" style="width:{@width};">'
                + '<table id="{@id}-header-table" style="width:{@width};table-layout:fixed;">'
                + '<tr class="microchart-table-row" >'
                + '<th style="border:none;text-decoration:none;"></th>'
                + '</tr>'
                + '</table>'
                + '</div>'
                +
                '<div id="{@id}-chart-table-container" class="microchart-canvas-div" style="position:absolute;overflow:hidden;width:{@width};">'
                + '<table id="{@id}-charts-body" style="width:{@width};table-layout:fixed">'
                + '<tr class="microchart-table-row">'
                + '<td style="border:none;background:transparent;text-decoration:none;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-top:0px;padding-bottom:0px"></td>'
                + '</tr>'
                + '</table>'
                + '</div>'
                +
                '<div style="position:absolute;z-index:2;">'
                + '<table id="{@id}-docked-header" style="width:{@width};table-layout:fixed;position:relative;background-color:white;">'
                + '<tbody></tody>'
                + '</table>'
                + '<div id="{@id}-docked-header-replace-div" style="width:{@width};position:relative;overflow:hidden">'
                + '<table id="{@id}-docked-header-replace" style="width:{@width};table-layout:fixed;background-color:white;">'
                + '<tbody></tody>'
                + '</table>'
                + '</div>'
                + '</div>'
                +
                '</div>',

            markupSlots: {

                headerTable: function () {
                    return this.domNode.childNodes[0].firstChild;
                },

                itemsContainerNode: function () {
                    return this.domNode.childNodes[1];
                },

                chartTable: function () {
                    return this.domNode.childNodes[1].firstChild;
                },

                dockedHeaderTable: function () {
                    return this.domNode.childNodes[2].firstChild;
                },

                dockedHeaderReplaceDiv: function () {
                    return this.domNode.childNodes[2].lastChild;
                }
            },

            postBuildRendering: function postBR() {

                //-1 for the height of the dividing line
                ROW_HEIGHT = (this.widget.otherProps.mRowHeight - 1) + 'px';
                ROW_HEIGHT_FOR_CHART = (this.widget.otherProps.mRowHeight - 2) + 'px';
                zf = this.utils.getScreenZoomFactor();
                this.scrollerConfig.scrollEl = this.chartTable;
                this.scrollerConfig.indicatorEl = this.widget.indicatorEl;
                this.scrollerConfig.showScrollbars = this.showScrollbars;
                this._super();
                this.renderMicroChart();
                this.updateRowOffsetHeight();
                this.updateHeaderTableOffsetH();
                this.updateChartTableOffsetH();
                setScrollerPosition.call(this, this.widget.mcStatus && this.widget.mcStatus.scrollTo);

                setDHBackGroundColor.call(this);

                // save infowindowOn flag before infowindow close, before "touchesBegin" event
                // this should be after _super to make sure this._tn has been set in _TouchGesture.js
                var widget = this.widget;
                if (this._tn) {
                    var backup = this._tsCallback;
                    this._tsCallback = function (e) {
                        widget.closedIfwAttr = null;
                        backup.call(this, e);
                    };
                    mstrmojo.dom.detachEvent(this._tn, mstrmojo.dom.TOUCHSTART, backup);
                    mstrmojo.dom.attachEvent(this._tn, mstrmojo.dom.TOUCHSTART, this._tsCallback);
                }
            },

            renderMicroChart: function rmc() {

                var colLen = this.colInfos.length;

                var ht = this.headerTable;
                //set style for Header
                ht.style.font = 'bold 13pt Helvetica';
                if (this.theme == DEFAULT_LIGHT_THEME) {
                    ht.style.backgroundColor = '#B5BDC4';
                    ht.style.color = 'black';
                } else if (this.theme == DEFAULT_DARK_THEME) {
                    ht.style.backgroundColor = '#1C273A';
                    ht.style.color = 'white';
                }
                if (!this.isAndroidTab) {
                    //on phone, resize according to DPI
                    ht.style.height = zf * 32 + 'px';
                    ht.style.fontSize = 14 * zf + "px";
                }

                // header tr
                var htr = ht.firstChild.firstChild;

                // table body
                var tbody = this.chartTable.firstChild;
                var rowTmpl = tbody.firstChild;

                var th0 = htr.firstChild;
                var td0 = rowTmpl.firstChild;
                //build one row in headerTable and rowTmpl
                for (var i = ht.childNodes.length; i < colLen; i++) {
                    htr.appendChild(th0.cloneNode(true));
                    rowTmpl.appendChild(td0.cloneNode(true));
                }
                this.rowTemplate = rowTmpl;

                var fnSD = function (e, width, noSetHeight) {
                    var paddingWidth = 0;

                    var compStyle = mstrmojo.css.getComputedStyle(e);
                    if (compStyle.paddingLeft) {
                        paddingWidth += parseFloat(compStyle.paddingLeft);
                    }
                    if (compStyle.paddingRight) {
                        paddingWidth += parseFloat(compStyle.paddingRight);
                    }

                    e.style.width = (width - paddingWidth) + 'px';

                    if (!noSetHeight) {
                        e.style.height = ROW_HEIGHT;
                    }

                };

                // header ths
                var ths = htr.childNodes;
                // body tds
                var tds = rowTmpl.childNodes;

                if (this.isTreeMode) {
                    // remove the border-bottom
                    $CSS.removeClass(rowTmpl, "microchart-table-row");
                    $CSS.removeClass(htr, "microchart-table-row");
                }

                for (var i = 0; i < colLen; i++) {

                    var colInfo = this.colInfos[i];

                    ths[i].innerHTML = colInfo.title ? colInfo.title : '';

                    if (colInfo.padding.l != undefined) {
                        tds[i].style.paddingLeft = colInfo.padding.l + "px";
                    }
                    if (colInfo.padding.r != undefined) {
                        tds[i].style.paddingRight = colInfo.padding.r + "px";
                    }

                    ths[i].className = colInfo.headerCssClass;
                    if (this.treeColumnIdx == colInfo.colIdx) {
                        // add the arrow
                        var arrowDiv = document.createElement('div');
                        tds[i].appendChild(arrowDiv);
                        arrowDiv.style.display = "";
                    } else {
                        //use this.valueCssClass as we need its padding value if inherit from grid/graph
                        tds[i].className = colInfo.valueCssClass + " " + this.valueCssClass;
                    }

                    if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_NAME) {
                        this.bodyFontColorRGB = this.valueCssClass && $CLR.rgbStr2rgb(mstrmojo.css.getStyleValue(tds[i], 'color'));
                    }

                    fnSD(ths[i], colInfo.colWidth);
                    fnSD(tds[i], colInfo.colWidth);

                    ths[i].style.wordBreak = "break-word";
                    ths[i].style.whiteSpace = "normal";

                    tds[i].setAttribute("mcol", colInfo.colIdx);
                    ths[i].setAttribute("mcol", colInfo.colIdx);
                    ths[i].setAttribute("mrow", -1);

                }

                for (var i = 0; i < colLen; i++) {
                    var colInfo = this.colInfos[i];
                    colInfo.titleOverflow = this.utils.truncateTextToLineWithWordWrap2(ths[i], this.textCanvas, 2);

                    if (colInfo.type == CHART) {
                        colInfo.contentWidth = tds[i].offsetWidth - colInfo.padding.l - colInfo.padding.r;
                    }

                }

                var otherProps = this.widget.otherProps;
                this.kpiOff = otherProps.mnMetricsPerKPI;
                if (!this.widget.isKPI) {
                    this.kpiOff = 0;
                }

                var w = this.widget;

                var fragment = document.createDocumentFragment();
                for (var i = w.startCnt; i < w.endCnt; i++) {
                    var newTR = renderOneRow.call(this, i);
                    fragment.appendChild(newTR);

                }
                tbody.appendChild(fragment);

                rowTmpl.style.display = "none";

                // xiawang: hide the headerTable if user set it TQMS 532011
                if (otherProps.mbHideColHeaders) {
                    this.headerTable.style.display = "none";
                }

                this.itemsContainerNode.style.top = this.headerTableOffsetHeight + 'px';
            },

            reRenderRows: function reRenderRows(scrollTo, firstRowRemain, lastRowRemain, firstRowToRender, lastRowToRender) {
                var tbody = this.chartTable.firstChild;
                tbody.innerHTML = "";
                var w = this.widget;

                var fragment = document.createDocumentFragment();

                if (firstRowRemain == undefined) {
                    firstRowRemain = 0;
                    lastRowRemain = 0;
                    firstRowToRender = w.startCnt;
                    lastRowToRender = w.endCnt;
                }

                var rows = w.rows;
                if (firstRowRemain < firstRowToRender) {
                    for (var i = firstRowRemain; i < lastRowRemain; i++) {
                        var newTR = rows[i].rowRef[this.domRefName];
                        fragment.appendChild(newTR);
                    }

                    for (var i = firstRowToRender; i < lastRowToRender; i++) {
                        var newTR = renderOneRow.call(this, i);
                        fragment.appendChild(newTR);

                    }
                } else {
                    for (var i = firstRowToRender; i < lastRowToRender; i++) {
                        var newTR = renderOneRow.call(this, i);
                        fragment.appendChild(newTR);

                    }
                    for (var i = firstRowRemain; i < lastRowRemain; i++) {
                        var newTR = rows[i].rowRef[this.domRefName];
                        fragment.appendChild(newTR);
                    }
                }

                tbody.appendChild(fragment);

                this.updateChartTableOffsetH();
                setScrollerPosition.call(this, scrollTo);
            },

            updateHeaderTableOffsetH: function updateHeaderTableOffsetH() {
                if (this.widget.otherProps.mbHideColHeaders) {
                    this.headerTableOffsetHeight = 0;
                } else {
                    this.headerTableOffsetHeight = this.headerTable.offsetHeight;
                }
            },

            updateRowOffsetHeight: function updateRowOffsetHeight() {
                this.rowOffsetHeight = this.chartTable.firstChild.lastChild.offsetHeight;

            },

            updateChartTableOffsetH: function updateChartTableOffsetH() {
                this.chartTableOffsetHeight = this.chartTable.firstChild.offsetHeight;
            },

            onScrollDone: function onScrollDone(evt) {
                if (this._super) {
                    this._super(evt);
                }
                this.widget.onScrollDone(evt);
            },

            onScrollMoved: function onScrollMoved(evt) {
                if (this._super) {
                    this._super(evt);
                }
                this.widget.onScrollMoved(evt);
            },

            initScroller: function initScroller(scroller) {

                if (!scroller.offset && this.scrollPast) {
                    scroller.offset = {scrollPast: this.scrollPast};
                }

                scroller.vScroll = true;

                if (this._super) {
                    this._super(scroller);
                }

                var me = this;
            },

            initDHs: function initDHs() {
                var dockedHeaderTable = this.dockedHeaderTable;
                dockedHeaderTable.parentNode.style.top = this.headerTableOffsetHeight + 'px';
            },

            /*
             * add domNode to dockedHeader table or dockedHeaderReplacing table
             * rowcount is the last x rowInfos in w.xxRows
             */
            addRowsToDH: function addRowsToDH(rowCount, toDHReplacingTable) {
                var w = this.widget;
                var rows = null;
                if (toDHReplacingTable) {
                    rows = w.dockedHeaderReplaceRows;
                } else {
                    rows = w.dockedHeaderRows;
                }

                var fragment = document.createDocumentFragment();
                for (var i = rows.length - rowCount; i < rows.length; i++) {
                    var newTR = renderOneRow.call(this, rows[i].rowIdx, rows[i]);
                    rows[i].rowRef[this.domRefName] = newTR;
                    fragment.appendChild(newTR);
                }
                if (toDHReplacingTable) {
                    this.dockedHeaderReplaceDiv.firstChild.firstChild.appendChild(fragment);
                } else {
                    this.dockedHeaderTable.firstChild.appendChild(fragment);
                }

            },

            removeRowsFromDH: function removeRowsFromDH(rowCount, moveToReplacingTable) {
                var dockedHeaderTable = this.dockedHeaderTable,
                    dockedHeaderTbody = dockedHeaderTable.firstChild;
                var dockedHeaderReplaceTbody = this.dockedHeaderReplaceDiv.firstChild.firstChild;

                if (rowCount > dockedHeaderTbody.childNodes.length) {
                    //there are not enough rows to remove
                    rowCount = dockedHeaderTbody.childNodes.length;
                }

                if (rowCount > 1) {
                    //if rowCount > 1, remove the tbody to remove the reflow
                    dockedHeaderTable.removeChild(dockedHeaderTbody);
                    for (var i = 0; i < rowCount; i++) {
                        dockedHeaderTbody.removeChild(dockedHeaderTbody.lastChild);
                    }
                    dockedHeaderTable.appendChild(dockedHeaderTbody);

                } else if (rowCount == 1) {
                    var dockedHeaderTR = dockedHeaderTbody.lastChild;
                    dockedHeaderTbody.removeChild(dockedHeaderTR);
                    if (moveToReplacingTable) {
                        dockedHeaderReplaceTbody.appendChild(dockedHeaderTR);
                    }

                }
            },

            moveRowFromDHRplcTableToDH: function moveRowFromDHRplcTableToDH() {
                var dockedHeaderTable = this.dockedHeaderTable,
                    dockedHeaderTbody = dockedHeaderTable.firstChild;
                var dockedHeaderReplaceTbody = this.dockedHeaderReplaceDiv.firstChild.firstChild;

                var replacingTR = dockedHeaderReplaceTbody.firstChild;
                if (replacingTR) {
                    removeChildren(dockedHeaderReplaceTbody);
                    dockedHeaderTbody.appendChild(replacingTR);
                }

            },

            removeChildrenForDHReplaceTable: function removeChildrenForDHReplaceTable() {
                var dockedHeaderReplaceTbody = this.dockedHeaderReplaceDiv.firstChild.firstChild;

                removeChildren(dockedHeaderReplaceTbody);
            },

            showDockedHeader: function showDockedHeader() {
                this.dockedHeaderTable.parentNode.style.display = 'block';
            },

            hideDockedHeader: function hideDockedHeader() {
                this.dockedHeaderTable.parentNode.style.display = 'none';
            },

            setTreeArrow: function setTreeArrow(rowInfo, color) {
                var tr = rowInfo.rowRef[this.domRefName];
                var tds = tr.childNodes;
                var arrowDiv = tds[this.treeColumnIdx].firstChild;
                setTreeTriangle.call(this, arrowDiv, rowInfo.treeNode, color);
            },

            scrollTo: function (origin) {
                var icn = this.chartTable;
                this.utils.translateCSS(-origin.x, -origin.y, false, icn);
            },

            shouldTouchBubble: function shouldTouchBubble(touch) {
                var scroller = this._scroller,
                    isVertical = touch.isVertical;

                var vScrollable = !!scroller.offset && scroller.offset['y'].end !== 0;

                return isVertical ? !vScrollable : this._super(touch);
            },

            multiTap: true,

            touchTap: function (touch) {
                this.widget.touchTap(touch);
            },

            touchSelectBegin: function touchSelectBegin(touch) {
                this.bubbleTouchEvent(touch);
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                this.bubbleTouchEvent(touch);
            },

            touchSelectMove: function touchSelectMove(touch) {
                this.bubbleTouchEvent(touch);
            },

            multiTouch: true,

            touchMultiBegin: function (touch) {
                this.bubbleTouchEvent(touch);
            },

            touchMultiMove: function (touch) {
                this.bubbleTouchEvent(touch);
            },

            touchMultiEnd: function (touch) {
                this.bubbleTouchEvent(touch);
            },

            destroy: function destroy() {
                delete this.widget;
                delete this.parent;
                delete this.rowTemplate;

                this._super();
            }
        }
    );
}());//@ sourceURL=VisMicroChartTable.js
(function () {

    mstrmojo.requiresCls("mstrmojo.VisChartLine", "mstrmojo.EnumRWUnitType",
        "mstrmojo.VisTooltip",
        //"mstrmojo.VisDebuggerUtils",
        "mstrmojo.dom", "mstrmojo._TouchGestures", "mstrmojo.TouchScroller", "mstrmojo._HasTouchScroller", "mstrmojo.css", "mstrmojo.color",
        "mstrmojo.VisTimeSeriesLegend", "mstrmojo.VisTimeSeriesTimeSelector");

    mstrmojo.requiresDescs(5674, 8475, 8626);

    /**
     * closure variables
     */
    var $CSS = mstrmojo.css,
        $CLR = mstrmojo.color;

    var DRILLING_ACTION = 1,
        SELECTOR_ACTION = 2,
        HYPERLINK_ACTION = 4;
    var ROW_AXIS = 1,
        COL_AXIS = 2;
    var chartStatus = {},
        widgetCount = 0,
        tooltipShown = false,
        itemClicked = false,
        isDataSetChanged = false,
        chartSizeChanged = false,
        originalTouchPosition = 0,
        masterSliderClicked = null,
    //Max Ratio of the render canvas to the display canvas
        rangeToSeriesMaxRatio = 5;

    var MCHW = 20; //Master Chart Handler WIDTH. This is also the added size of masterMargin.l and r
    var MCHH = 20; //Master Chart Handler Height
    var MAXPOINTS_PER_DRAW = 80; // Maximal points allowed in one drawLine/drawArea;
    //used to decide whether the width between slider is changed.
    var SWidthChanged = false;

    var masterMargin = {
        t: 5,
        r: MCHW / 2,
        b: 5,
        l: MCHW / 2
    }; // l and r should be the same size and both added togather should be the size of MCHW

    //PADDING variables are used when drawing the highlight
    var PADDING = 10,
        TOP_PADDING = 8;

    var canvasReseted = false;

    var $_DT = mstrmojo.locales.datetime;

    /**
     * private function
     */
    function resetLocalVars() {
        tooltipShown = false;
        itemClicked = false;
        isDataSetChanged = false;
        chartSizeChanged = false;
        originalTouchPosition = 0;
        masterSliderClicked = null;
    }

    function getParentBkgColor() {
        var parentNode = this.domNode.parentNode;
        while (parentNode) {
            var compStyle = mstrmojo.css.getComputedStyle(parentNode);
            var bkgColor = compStyle.backgroundColor;
            if (bkgColor) {
                if (bkgColor.indexOf('rgba') >= 0) {
                    var rgba = this.utils.rgbaStr2rgba(bkgColor);
                    if (rgba && rgba[4]) {
                        return rgba;
                    }
                } else if (bkgColor.indexOf('rgb') >= 0) {
                    var rgb = $CLR.rgbStr2rgb(bkgColor);
                    return rgb;
                }

            }
            parentNode = parentNode.parentNode;
        }

        //return default value
        return [255, 255, 255];
    }

    var LIGHT_THEME = 0;
    var DARK_THEME = 1;

    function getUITheme() {
        var utils = this.utils;

        //var parentBkgColor = utils.getAncestorBgColor(this) || '#ffffff';
        //rgb = $CLR.hex2rgb(parentBkgColor);

        var rgb = getParentBkgColor.call(this);

        var opacity = this.formatProp.backgroundAlpha;

        rgb = utils.getRGBWithOpacity(rgb, opacity, this.formatProp.backgroundClr);

        var brightness = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
        if (brightness > 150) {
            this.theme = LIGHT_THEME;
        } else {
            this.theme = DARK_THEME;
        }

    }

    /*
     * currSelectionIdx: the idx of the time interval selected
     */
    function addChartStatus(id) {
        chartStatus[id] = {isLegendBarOpen: false,
            legendBarWidth: 30,
            isLegendSelected: false,
            legendSelectedIndex: -1,
            timeSelectedIntervalPosition: {},
            currSelectionIdx: -1,
            usingCustomInterval: false};
    }

    /**
     * private function
     */
    function isScrollableElementTouched(touch) {

        //return true;
        var me = this,
            m = me.margin,
            chartWidth = me.getChartWidthOnScreen();

        var touchPointOnWidget = me.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, me);

        var x = touchPointOnWidget.touchX,
            y = touchPointOnWidget.touchY;

        if (x < m.l || x > (chartWidth + m.l) || y < m.t || y > this.canvas.height - m.b) {
            return false;
        }
        return true;
    }

    function isTouchedOnWidget(touch) {

        if (!touch) {
            return false;
        }
        var me = this;

        var touchPointOnWidget = me.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, me);

        var x = touchPointOnWidget.touchX,
            y = touchPointOnWidget.touchY;

        if ((x > 0 && x < me.getWidth()) && (y > 0 && y < me.getHeight())) {
            return true;
        }
        return false;
    }

    function getTouchedElement(touch) {
        var item = mstrmojo.dom.findAncestorByAttr(touch.target, "clk", true, this.domNode);
        return item || null;
    }

    /*
     * calculate the highest point in the lines
     */
    function getMinYPosition(lines) {
        var l = lines.length;
        var i = 0, min;
        while (i < l) {
            if (lines[i]) {
                min = lines[i].y;
                break;
            }
            i++;
        }
        for (i = 0; i < l; i++) {
            if (lines[i]) {
                min = Math.min(min, lines[i].y);
            }
        }
        return min;
    }

    function resetBaseAndDerivedData(tsl) {
        var obm = this.baseModel;
        var currStatus = chartStatus[this.chartID];
        this.baseModel = this.getModel(tsl.ds) || this.baseModel;
        var bm = this.baseModel;

        this.checkData(bm);
        //If error message received just return.
        var err = bm.err || bm.eg;

        if (err) {
            this.renderErrorMessage(err);
            return false;
        }

        var bms = bm.series,
            m = this.model,
            cs = m.series,
        // sl = cs.length,
        // TQMS ??
            sl = bms.length,
            s = [],
            j = 0;

        for (j = 0; j < sl; j++) {
            s[j] = bms[j];
            //s[j].i = cs[j].i;
        }
        this.model.categories = bm.categories;
        this.model.series = s;
        this.model.colHeaders = bm.colHeaders;

        var currWindowSize = this.model.series[0].rv.length;
        if (this.windowSize !== currWindowSize) {
            //#
            currStatus.rns = 0;
            currStatus.rne = currWindowSize;
        }
        this.windowSize = currWindowSize;

        //#564326: use the original vp if bm.vp.rl.length < obm.vp.rl.length
        if (!bm.vp || !bm.vp.rl || bm.vp.rl.length < obm.vp.rl.length) {
            bm.vp = obm.vp;
        }
        isDataSetChanged = true;
        return true;
    }

    /*
     * update scroller config
     * update scroller position
     */
    function localUpdateScrollerConfig() {
        var scl = this._scroller,
            m = this.model,
            margin = this.margin,
            currStatus = chartStatus[this.chartID],
            animationCanvas = this.animationCanvas,
            chartWidth = this.getChartWidthOnScreen(),
            offsetEnd = Math.max(this.acContentWidth - chartWidth, 0);
        var rns = (currStatus.rns !== 0 && currStatus.rns + 1 === currStatus.rne) ? currStatus.rns - 1 : currStatus.rns; // to adjust if diff is only one point and rns is at the end
        // Initialize origin to the current start of selection point
        scl.origin = {
            x: parseInt(((rns - this.ACrns) * this.RTX), 10),
            y: 0
        };

        // Should we be able to horizontally scroll?
        scl.hScroll = (offsetEnd !== 0 && scl.noHScroll !== true) || this.scrollPast;

        if (scl.hScroll) {
            // Add the computed offset.
            scl.offset = {
                x: {
                    start: 0,
                    end: offsetEnd
                },
                scrollPast: this.scrollPast

            };
        }
        //Move the animationCanvasDiv containing animationCanvas and the Xlabel to the correct position
        //  mstrmojo.dom.translate(this.animationCanvasDiv, -(scl.origin.x), scl.origin.y, 0, "", true);
        this.utils.translateCSS(-(scl.origin.x), scl.origin.y, false, this.animationCanvasDiv);
        this.utils.translateCSS(-(scl.origin.x) + this.maxYLblWidth, scl.origin.y, false, this.xLabelsDiv);

    }

    /***
     *
     * @param m {Object} model
     * @returns {string}
     */
    function getCurrencySymbolForMetric(m) {
        var s = m.series,
            ch = m.colHeaders,
            chl = ch[0].items.length;

        //Get the currency symbol or percent symbol present in format
        var hi0 = s[0].hi,
            fInfo = ch[ch.length - 1].items[hi0[hi0.length - 1]],
            f = fInfo.f;
        var cs = (fInfo && f && f.indexOf(fInfo.cs) >= 0) ? "," + fInfo.cs : "";

        if (cs === "" && f) {
            cs = f.indexOf("%") >= 0 ? ",%" : "";
        }

        if (cs === "" && f) {
            var q = null;
            if (f.indexOf('\'') >= 0) {
                q = '\'';
            } else if (f.indexOf("\"") >= 0) {
                q = "\"";
            }
            if (q) {
                var temp = f.substring(f.indexOf(q) + 1);
                cs = "," + temp.substring(0, temp.indexOf(q));
            }
        }

        return cs;
    }

    function hideMasterSliderTooltip() {
        var ms = this.masterSlider,
            stt = this.sliderTooltip,
            sttF = stt.firstChild,
            sttP = stt.lastChild,
            fc = ms.firstChild,
            lc = ms.lastChild;

        //For now just replace all occurrances since testing in browser
        $CSS.removeClass(fc, 'mstrmojo-timeseries-span-shadow');
        $CSS.removeClass(lc, 'mstrmojo-timeseries-span-shadow');

        //Also remove the scroller tooltip
        sttF.innerHTML = '';
        sttF.style.display = 'none';
        sttP.style.display = 'none';
    }

    //handle move or swipe master slider end
    function resizeMasterSliderDone() {
        var me = this,
            currStatus = chartStatus[this.chartID];

        //unselect the orig chart's interval if any and redraw orig chart according to the custom interval
        if (currStatus.usingCustomInterval && me.currSelection) {
            me._timeSelector.toggleSelected(me.currSelection, false);
            me._timeSelector.toggleGlowEffect(me.currSelection, false);

            this.updateIntervalPosition();
            me.currSelection = null;
            currStatus.currSelectionIdx = -1;
        }
        if (chartSizeChanged && masterSliderClicked !== 'MS') {
            me.showMessage(); // need to redraw so display loading message

            this.makeSureMasterSliderNotBeyondTheMargin();
            this.makeSureSliderOnPoint();
            this.makeSureSelectedIntervalMoreThanTwo();
            this.makeSureMasterSliderNoOverlap();
            this.setMasterSliderLayout();
            window.setTimeout(function () {
                me.reDrawSlaveChart();
            }, 10);

        } else {
            //slider not moved
            masterSliderClicked = null;
        }
        // hide the master tooltip
        hideMasterSliderTooltip.call(this);
    }

    function getFormattedDateForSliderTooltip(sliderTooltipXPosition) {
        var me = this,
            cat = me.model.categories,
            tp = cat.tp;

        var pos = Math.round((sliderTooltipXPosition - masterMargin.l) / me.MRTX),
            rVal = cat.items[pos];

        if (tp.toString() === me.DSS_XML_BASE_FORM_DATE) {
            rVal = me.getFormattedDateForTooltip(rVal, true);
        }

        return rVal;
    }

    function getPointDistanceSquare(p1, p2) {
        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
    }

    function getACRnsRne(rns, rne) {
        var me = this,
            currStatus = chartStatus[me.chartID],
            model = me.model,
            windowSize = me.windowSize,
            needRedraw = true,
            ACrns,
            ACrne;

        if ((!rns && rns !== 0) || !rne) {
            rns = currStatus.rns;
            rne = currStatus.rne;
        }

        var diff = rne - rns;

        model.currentRatio = Math.round(windowSize / ((diff - 1) || 1));
        if (model.currentRatio > rangeToSeriesMaxRatio) {
            var ACRation = (rangeToSeriesMaxRatio - 1) / 2;
            //cal the witdh of animationCanvas which draw 5 times size of the scree
            ACrns = Math.max(0, rns - ACRation * (diff - 1));
            ACrne = Math.min(windowSize, rne + ACRation * (diff - 1));
            if (ACrns === 0) {
                ACrne = rangeToSeriesMaxRatio * (diff - 1) + 1;
            } else if (ACrne === windowSize) {
                ACrns = ACrne - rangeToSeriesMaxRatio * (diff - 1) - 1;
            }
        } else {
            ACrns = 0;
            ACrne = windowSize;
            var ACdiff = ACrne - ACrns;
        }
        if (me.ACrns === ACrns && me.ACrne === ACrne) {
            needRedraw = false;
        } else {
            me.ACrns = ACrns;
            me.ACrne = ACrne;
        }

        return needRedraw;
    }

    function removeChildren(container) {
        var count = container && container.childNodes && container.childNodes.length,
            i;
        for (i = 0; i < count; ++i) {
            container.removeChild(container.firstChild);
        }

    }

    function removeLegendAndTimeSelectorChildren() {
        //remove legendBarDiv childNodes
        //this.legendBarDiv = this.getLegendBarDiv();
        //removeChildren(this.legendBarDiv);
        if (this._legend) {
            this._legend.destroy();
        }

        //remove the timeseries intervals if any
        //this.timeSelectorDiv = this.getTimeSelectorDiv();
        //removeChildren(this.timeSelectorDiv);
        if (this._timeSelector) {
            this._timeSelector.destroy();
        }
    }

    /**
     * A Widget to display the Time Series visualization
     * @class
     * @extends mstrmojo.VisChartLine
     */
    mstrmojo.VisTimeSeries = mstrmojo.declare(

        // superclass
        mstrmojo.VisChartLine,

        // mixins
        [mstrmojo._TouchGestures, mstrmojo._HasTouchScroller],

        {
            /**
             * @ignore
             */
            scriptClass: 'mstrmojo.VisTimeSeries',

            // overwrite this property of super class for time series we always have linear chart
            isLinearChart: true,

            //set the highlight color to white
            highlightColor: '#ffffff',

            chartLineColors: ['#16b0ff', '#ff3729', '#04ba22', '#ff960e',
                '#ae79de', '#cccd25', '#19cee0', '#a9a9a9',
                '#b3cdef', '#ffa796', '#98df8a', '#ffbf80',
                '#dac3ec', '#dac3ec', '#a1dfea', '#d6d6d6'],

            // overwrite make this property set to false always in time series
            switchSeriesOnTouch: false,

            /**
             * Indicates whether we support multi-touch.
             *
             * @type Boolean
             * @default false
             */
            multiTouch: true,

            /**
             * An object representing the margins the Chart will have. It contains the following Objects: t (top), r (right), b (bottom), l (left).
             * @type Object
             */
            margin: {
                t: 70,
                r: 1,
                b: 50,
                l: 5
            },

            SLXP: 0,
            // master chart slider Left X Position, x position of the rns on masterchart
            SRXP: 0,
            // Scroller Right X Position,x position of the rne on masterchart

            /**
             * just to make sure that the data we want to create is for time series vs chartline
             */
            isTimeSeries: true,

            /**
             * overwrite max number of x axis labels to be shown on the screen
             */
            maxXLabels: 4,

            /**
             * This is to set the scroll properties
             */
            scrollerConfig: {
                bounces: false,
                showScrollbars: false,
                useTranslate3d: true
            },
            /**
             * property that determines if we want to allow scrolling past the actual data to produce the stretching
             * effect
             */
            scrollPast: true,
            /**
             * property that determines if we are running on Android Tablet
             */
            isAndroidTab: false,

            /**
             * context to draw the master timeseries in case of Android Tablet
             */
            masterContext: null,

            /*
             * whether there are selection, info window, link drilling on row headers
             */
            selectionOrLinkdrillOnRow: false,

            /*
             * restore the index of the selected point
             * point contain x and y coordination of the datapoint
             */
            lastSelectedPoint: null,

            /**
             * @ignore TQMS #557885 the position got from backend data seems absolute,so change style of position to absolute
             */
            markupString: '<div id="{@id}" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};left:{@left};top:{@top};z-index:{@zIndex};position:absolute;-webkit-transition: 0ms; transition: 0ms; -webkit-transform: translate3d(0px, 0px, 0px);" ' +
                ' mstrAttach:mousedown,mouseup,mousemove,click >' +
                '<canvas width="{@width}" height="{@slaveChartHeight}"></canvas>' +
                '<div style="overflow:hidden;position:absolute;left:0px;top:0px;">' +
                '<div id="{@id}-animation-canvas-div" class="mstrmojo-timeseries-animation-canvas" style="position:absolute;left:0px;top:0px;width:{@width};height:{@slaveChartHeight+"px"};">' +
                '<canvas style="position:absolute;left:0px;top:0px;" width="{@width}" height="{@slaveChartHeight}"></canvas>' +
                '</div>' +
                '</div>' +
                '<div style="overflow:hidden;position:absolute;left:0px;top:0px;">' +
                '<div id="{@id}-x-labels-div" class="mstrmojo-timeseries-animation-canvas" style="position:absolute;left:0px;top:0px;width:{@width};height={@slaveChartHeight+"px"}">' +
                '</div>' +
                '</div>' +
                '<canvas id="{@id}-highlight-canvas" style="position:absolute;left:0px;top:0px;" width="{@width}" height="{@slaveChartHeight}"></canvas>' +
                '<div id="{@id}-tooltip"></div>' +
                '<div id="{@id}-time-selector-div"></div>' +
                '<div id="{@id}-legend-bar-div" ></div>' +
                '<div id="{@id}-loading-msg" class="mstrmojo-loading-msg" style="display:none"></div>' +
                '<canvas id="{@id}-master-canvas" style=" position:absolute;left:0px;bottom:0px;" width="{@width}" height="{@masterChartHeight}"></canvas>' +
                '<div id="{@id}-master-div" class="mstrmojo-master-parent-div" width="{@width}" style="position:absolute;bottom:5px" >' +
                '<div id="{@id}-master-cover-span" style="position:absolute;left:0px;" class="mstrmojo-master-cover-span"></div>' +
                '<div id="{@id}-master-slider" class="mstrmojo-master-slider-div" clk="MS">' +
                '<canvas id="{@id}-master-img-L" width="20" height="20" style="position:absolute;left:0px" class="mstrmojo-timeseries-master-span" clk="L" ></canvas>' +
                '<canvas id="{@id}-master-slider" width="{@width}" height="{@masterChartHeight}" style="top:0px;left:0px" class="mstrmojo-master-slider-div-top"></canvas>' +
                '<canvas id="{@id}-master-img-R" width="20" height="20" style="position:absolute;right:0px" class="mstrmojo-timeseries-master-span" clk="R" ></canvas>' +
                '</div>' +
                '<div id="{@id}-master-cover-span" style="position:absolute;right:0px;" class="mstrmojo-master-cover-span"></div>' +
                '</div>' +
                '<div id="{@id}-slider-tooltip" style="position:absolute;left:0;top:0;z-index:150;width:{@width};">' +
                '<div class="timeseries-slider-tooltip"></div>' +
                '<canvas style="position:absolute;left:0px;top:20px;display: none;" width="6px" height="5px"></canvas>' +
                '</div>' +
                '<div id="{@id}-legend-tooltip" class="mstrmojo-Chart-tooltip timeseries-legend-tooltip"></div>' +
                '<span id="textSpan" style="z-index:-10;visibility:hidden;"></span>' +
                '<div id="{@id}-infowindow-anchor" style="position:absolute;width:18px;height:18px;display:block"></div>' +
                '<div id="{@id}-errMsg" class="mstrmojo-message" style="width:{@width};height:{@height};top:0px;left:0px;position:absolute;display:none; z-index:20;"></div>' +
                '</div>',
            /**
             * @ignore
             */
            markupSlots: {
                //the main canvas of the Chart
                canvas: function () {
                    return this.domNode.firstChild;
                },

                //the base canvas for animation @TODO: each animation should create independent canvas objects
                animationCanvasDiv: function () {
                    return this.domNode.childNodes[1].firstChild;
                },

                //the base canvas for animation @TODO: each animation should create independent canvas objects
                animationCanvas: function () {
                    return this.domNode.childNodes[1].firstChild.firstChild;
                },

                // this is the scrollable div that contains canvas and x axis labels
                itemsContainerNode: function () {
                    return this.domNode.childNodes[1];
                },

                //the x labels div
                xLabelsDiv: function () {
                    return this.domNode.childNodes[2].firstChild;
                },

                //the x labels div
                xLabelsDivContainer: function () {
                    return this.domNode.childNodes[2];
                },

                //the canvas used for highlighting points
                highlightCanvas: function () {
                    return this.domNode.childNodes[3];
                },

                //the tooltip display when highlighting points
                tooltip: function () {
                    return this.domNode.childNodes[4];
                },

                timeSelectorDiv: function () {
                    return this.domNode.childNodes[5];
                },

                // the element that holds the titlebar and attributes
                legendBarDiv: function () {
                    return this.domNode.childNodes[6];
                },

                loadingMsg: function () {
                    return this.domNode.childNodes[7];
                },

                masterCanvas: function () {
                    return this.domNode.childNodes[8];
                },

                masterSlider: function () {
                    return this.domNode.childNodes[9].childNodes[1];
                },

                sliderTooltip: function () {
                    return this.domNode.childNodes[10];
                },

                legendTooltip: function () {
                    return this.domNode.childNodes[11];
                },

                textSpan: function () {
                    return this.domNode.childNodes[12];
                },

                infoWindowAnchor: function () {
                    return this.domNode.childNodes[13];
                },

                errorMsg: function () {
                    return this.domNode.childNodes[14];
                }
            },

            /*
             * zf is the zoomfactor decide by dpi
             */
            getTextWidth: function gtw(str, fontStyle, zf) {
                this.textSpan.style.font = fontStyle;
                this.textSpan.innerHTML = str;
                if (zf) {
                    this.utils.changeElementSize(this.textSpan, 'font', zf);
                }
                var ret = this.textSpan.offsetWidth;

                return ret;
            },

            /**
             *
             * @param text the string to meature
             * @param elem the element which provide the computed style used to meatrue text width
             */
            getTextWidthByElem: function gtwCvs(text, elem) {

                var computedStyle = mstrmojo.css.getComputedStyle(elem);
                var fontStyle = computedStyle.fontStyle + " "
                    + computedStyle.fontWeight + " "
                    + computedStyle.fontSize + "/"
                    + computedStyle.fontVariant
                    + " " + computedStyle.fontFamily;

                return this.getTextWidth(text, fontStyle);
            },

            /*
             * zf is the zoomfactor decide by dpi
             */
            getTextHeight: function gtw(str, fontStyle, zf) {
                this.textSpan.style.font = fontStyle;
                this.textSpan.innerHTML = str;
                if (zf) {
                    this.utils.changeElementSize(this.textSpan, 'font', zf);
                }
                var ret = this.textSpan.offsetHeight;

                return ret;
            },

            getMaxTextWidth: function (textArray, fontStyle) {
                var me = this,
                    l = textArray.length,
                    maxWidth = 0,
                    currWidth = 0,
                    i;
                for (i = 1; i < l; i++) {
                    currWidth = me.getTextWidth(textArray[i], fontStyle);
                    maxWidth = currWidth > maxWidth ? currWidth : maxWidth;
                }

                return maxWidth;
            },

            /*the width of the chart on screen */
            getChartWidthOnScreen: function getChartWidthOnScreen() {
                var m = this.margin;
                return this.getWidth() - m.r - m.l - chartStatus[this.chartID].legendBarWidth;
            },

            /*   drawAxis: function drwAxs() {
             this.drawChartXYAxis();
             this.setMasterChart();
             this.setMasterSlider();

             },
             */
            drawChartXYAxis: function drawChartXYAxis() {
                var utils = this.utils,
                    m = this.margin,
                    w = this.getWidth() - chartStatus[this.chartID].legendBarWidth,
                    h = this.canvas.height,
                    c = this.context;

                c.save();

                //set the style of the axes lines
                c.strokeStyle = utils.rgb2rgbStr(this.formatProp.textClr);
                c.lineWidth = 1;
                c.globalAlpha = 0.8;

                // y-axis
                var xPos = Math.floor(m.l) - 0.5;
                utils.drawLineSet(this, [
                    {
                        x: xPos,
                        y: m.t
                    },
                    {
                        x: xPos,
                        y: h - m.b
                    }
                ], false, c);
                // x-axis
                var yPos = Math.floor(h - m.b) + 0.5;
                utils.drawLineSet(this, [
                    {
                        x: m.l - this.maxYLblWidth,
                        y: yPos
                    },
                    {
                        x: w - m.r,
                        y: yPos
                    }
                ], false, c);

                c.restore();

            },

            /**
             *  called when first time the masterSlider is drawed,
             */
            setMasterSlider: function setMasterSlider() {
                var width = this.getWidth(),
                    h = this.masterCanvas.height - masterMargin.t - masterMargin.b,
                    utils = this.utils,
                    msl = this.masterSlider,
                    msStyle = msl.style,
                    mslp = msl.parentNode,
                //left cover style
                    lcStyle = mslp.firstChild.style,
                // right cover style
                    rcStyle = mslp.childNodes[2].style,
                    m = this.model,
                    mrtx = this.MRTX,
                    currStatus = chartStatus[this.chartID];

                //Set the fixed dimension for the masterchart slider
                mslp.style.display = 'block';
                mslp.style.height = h + 'px';
                mslp.style.width = width + 'px';
                //            mslp.style.bottom = masterMargin.b + "px";

                msStyle.height = h + 'px';//(h - (h * 2 / 9) - 2) + 'px';

                //cover span height - 2 to show the top and bottom line
                lcStyle.height = h - 2 + 'px';
                rcStyle.height = h - 2 + 'px';
                lcStyle.backgroundColor = rcStyle.backgroundColor = utils.rgb2rgbStr(this.formatProp.backgroundClr, this.formatProp.backgroundAlpha * 0.5);

                //draw left handlers
                this.drawMasterChartHandler(msl.firstChild, MCHW, MCHH, true);
                //draw right handlers
                this.drawMasterChartHandler(msl.lastChild, MCHW, MCHH, false);
                //make the handler vertical middle
                msl.firstChild.style.marginTop = msl.lastChild.style.marginTop = Math.round((h - MCHH) / 2) + 'px';

                //set the masterslider width and position according to SLXP and SRXP
                this.calculateSXP(currStatus.rns, currStatus.rne, true);
                this.makeSureMasterSliderNotBeyondTheMargin();
                this.makeSureMasterSliderNoOverlap();
                this.setMasterSliderLayout();
            },

            drawMasterChartHandler: function drwMCH(canvas, w, h, isLeft) {
                var utils = this.utils,
                    ctx = canvas.getContext('2d');

                //clear the canvas
                canvas.width = w;
                canvas.height = h;

                ctx.save();
                //filled with background color, 76% opacity
                ctx.fillStyle = utils.rgb2rgbStr(this.formatProp.backgroundClr, 0.76);
                utils.drawRoundRect(ctx, 0.5, 0.5, w - 1, h - 1, 1, true);
                //stroke with text color
                ctx.strokeStyle = utils.rgb2rgbStr(this.formatProp.textClr);
                ctx.lineWidth = 1;
                utils.drawRoundRect(ctx, 0.5, 0.5, w - 1, h - 1, 1);
                //draw the center line
                ctx.beginPath();
                ctx.lineWidth = 2;
                if (isLeft) {
                    ctx.moveTo(11, 6);
                    ctx.lineTo(7, 10);
                    ctx.lineTo(11, 14);
                } else {
                    ctx.moveTo(9, 6);
                    ctx.lineTo(13, 10);
                    ctx.lineTo(9, 14);
                }
                ctx.stroke();

                ctx.restore();
            },

            drawMasterChartDiv: function drwMCD(x, w) {
                var canvas = this.masterSlider.childNodes[1],
                    width = this.SRXP - this.SLXP + MCHW;

                //        	this.utils.translateCSS(this.SLXP, 0, false, canvas);
                if (canvas.width == width) {
                    //no need to redraw
                } else {
                    var margin = masterMargin,
                        mcHeight = this.masterChartHeight,
                        divHeight = mcHeight - margin.t - margin.b,
                        h = (divHeight - MCHH) / 2;

                    //clear canvas
                    canvas.height = divHeight
                    canvas.width = width;

                    var ctx = canvas.getContext('2d');
                    ctx.save();
                    ctx.strokeStyle = this.utils.rgb2rgbStr(this.formatProp.textClr);
                    ctx.lineWidth = 1;
                    ctx.beginPath();

                    var leftX = 0.5 + MCHW / 2;
                    var rightX = width - 0.5 - MCHW / 2;
                    ctx.moveTo(leftX, h);
                    ctx.lineTo(leftX, 0);
                    ctx.lineTo(rightX, 0);
                    ctx.lineTo(rightX, h);

                    ctx.moveTo(leftX, h + MCHH);
                    ctx.lineTo(leftX, divHeight);
                    ctx.lineTo(rightX, divHeight);
                    ctx.lineTo(rightX, h + MCHH);

                    ctx.stroke();
                    ctx.restore();
                }

            },

            /**
             * set the masterslider width and position according to SLXP and SRXP
             */
            setMasterSliderLayout: function setMasterSliderLayout() {
                var width = this.getWidth(),
                    utils = this.utils,
                    msl = this.masterSlider,
                    msStyle = msl.style,
                    mslp = msl.parentNode,
                //left cover style
                    lcStyle = mslp.firstChild.style,
                // right cover style
                    rcStyle = mslp.childNodes[2].style;

                lcStyle.width = (this.SLXP) + 'px';
                rcStyle.width = (width - this.SRXP) + 'px';

                //+1 for two point under the slider
                var slWidth = (this.SRXP - this.SLXP);

                msStyle.width = (slWidth + MCHW) + 'px';
                //translate to left position
                utils.translateCSS(this.SLXP - MCHW / 2, 0, false, msl);

                this.drawMasterChartDiv();

            },

            makeSureMasterSliderNoOverlap: function makeSureMasterSliderNoOverlap(fixWhich) {
                var slWidth = this.SRXP - this.SLXP;

                // avoid the two spans to overlap
                if (slWidth < MCHW) {
                    slWidth = MCHW;
                    var width = this.getWidth();

                    if (!fixWhich) {
                        fixWhich = this.SRXP + MCHW / 2 === width - 1 ? "R" : "L";
                    }

                    if (fixWhich == "L") {
                        this.SRXP = this.SLXP + MCHW;
                    } else {
                        this.SLXP = this.SRXP - MCHW;
                    }

                }
            },

            //caculate SLXP and SRXP
            calculateSXP: function calculateSXP(rns, rne, intervalChanged) {
                if (intervalChanged) {
                    this.SLXP = Math.round((this.MRTX * rns) + masterMargin.l);
                    this.SRXP = Math.round((this.MRTX * (rne - 1)) + masterMargin.l);
                } else {
                    var width = this.SRXP - this.SLXP;
                    this.SLXP = Math.round((this.MRTX * rns) + masterMargin.l);
                    this.SRXP = this.SLXP + width;
                }

            },

            makeSureMasterSliderNotBeyondTheMargin: function makeSureMasterSliderNotBeyondTheMargin(keepWidth) {
                var SWidth = this.SRXP - this.SLXP;
                var width = this.getWidth();
                if (this.SLXP < masterMargin.l) {
                    this.SLXP = masterMargin.l; // make sure left position is never going below left margin
                    if (keepWidth) {
                        this.SRXP = this.SLXP + SWidth;
                    }
                }
                if (this.SRXP > width - masterMargin.r - 1) {
                    this.SRXP = width - masterMargin.r - 1; // make sure right position is never going after right margin
                    if (keepWidth) {
                        this.SLXP = this.SRXP - SWidth;
                    }
                }
            },

            makeSureSelectedIntervalMoreThanTwo: function makeSureSelectedIntervalMoreThanTwo() {
                var mrtx = this.MRTX,
                    width = this.getWidth();
                if (this.SRXP - this.SLXP < mrtx) {
                    if (masterSliderClicked) {
                        if (masterSliderClicked === 'L') {
                            this.SLXP = this.SRXP - mrtx;
                        } else {
                            this.SRXP = this.SLXP + mrtx;
                        }
                    } else if (this.SLXP + mrtx <= width - masterMargin.r) {
                        this.SRXP = this.SLXP + mrtx;
                    } else {
                        this.SLXP = this.SRXP - mrtx;
                    }
                }
            },

            makeSureSXPNotEqual: function makeSureSXPNotEqual() {
                var mrtx = this.MRTX,
                    width = this.getWidth();
                if (this.SLXP === this.SRXP) {
                    if (masterSliderClicked) {
                        if (masterSliderClicked === 'L') {
                            this.SLXP -= mrtx;
                        } else {
                            this.SRXP += mrtx;
                        }
                    } else if (this.SRXP + mrtx <= width - masterMargin.r) {
                        this.SRXP += mrtx;
                    } else {
                        this.SLXP -= mrtx;
                    }
                }
            },

            makeSureSliderOnPoint: function makeSureSliderOnPoint() {
                var mrtx = this.MRTX,
                    diff = 0,
                    currStatus = chartStatus[this.chartID];
                ;
                if (masterSliderClicked) {
                    diff = Math.round((this.SRXP - this.SLXP) / mrtx);
                    if (masterSliderClicked === 'L') {
                        this.SLXP = this.SRXP - diff * mrtx;
                    } else if (masterSliderClicked === 'R') {

                        this.SRXP = this.SLXP + diff * mrtx;
                    } else {//(masterSliderClicked === 'MS')
                        this.calculateSXP(currStatus.rns, currStatus.rne, true);
                    }
                }
            },

            /**
             * Overridden to attach an event listener to the scroller for adjusting scroller when
             * scroll event is done.
             * @ignore
             */
            initScroller: function initScroller(scroller) {

                if (!scroller.offset && this.scrollPast) {
                    scroller.offset = {
                        scrollPast: this.scrollPast
                    };
                }

                this._super(scroller);

                var me = this;

                // Attach event listeners.  Call back to listen when scroll is done
                this._scrollDoneListener = this._scroller.attachEventListener('scrollDone', me.id, function (evt) {
                    //Now set the rns and rne accordingly since the scrolling is now finished
                    var m = me.model,
                        currStatus = chartStatus[me.chartID],
                        r = currStatus.rne - currStatus.rns,
                        rns = me.ACrns + parseInt(Math.round(me._scroller.origin.x / me.RTX), 10);
                    if (r === 1) { // adjust rns if difference is only one
                        rns++;
                    }

                    var rne = rns + r;

                    // if and else conditions are to set for the strech effect when streching beyond limits
                    if (rns < 0) {
                        currStatus.rns = 0;
                        currStatus.rne = currStatus.rns + r;
                    } else if (rne > m.series[0].rv.length) {
                        currStatus.rne = m.series[0].rv.length;
                        currStatus.rns = currStatus.rne - r;
                    } else {
                        currStatus.rns = rns;
                        currStatus.rne = rne;
                    }
                    me.updateRnsRne();
                    SWidthChanged = false;

                    //if (m.currentRatio > rangeToSeriesMaxRatio &&(((currStatus.rns - me.ACrns) < r && me.ACrns > 0) || ((me.ACrne - currStatus.rne) < r && me.ACrne < this.windowSize))) {
                    me.incFetchChart();
                    /*}else{
                     //we need to shift our chart a little bit to adjust for the points
                     localUpdateScrollerConfig.call(me);
                     this.removeLabels();
                     this.drawLabels();
                     }
                     */
                });

                // Attach event listeners.  Call back to listen when scroll is moved
                this._scrollMovedListener = this._scroller.attachEventListener('scrollMoved', me.id, function (evt) {
                    if (tooltipShown) {
                        me.hiddenTooltipAndShowTimeSelector();
                    }

                    //compute rns and rne for master scroller
                    var m = me.model,
                        currStatus = chartStatus[me.chartID],
                        sl = m.series[0].rv.length,
                        r = currStatus.rne - currStatus.rns,
                        rns = me.ACrns + Math.round(evt.x / me.RTX),
                        rne = Math.min(rns + r, sl);

                    if (rns < 0) {
                        rns = 0;
                    }

                    if (rne - rns != r) {
                        SWidthChanged = true;
                    }

                    //move the x labels
                    me.utils.translateCSS(-evt.x + me.maxYLblWidth, -evt.y, false, me.xLabelsDiv);

                    me.calculateSXP(rns, rne, SWidthChanged);

                    me.makeSureSXPNotEqual();
                    me.makeSureMasterSliderNoOverlap();
                    me.setMasterSliderLayout();

                });

            },

            initFromVisProps: function (vp) {
                var propValue = vp ? vp : {};

                this.formatProp = {};

                this.formatProp.backgroundClr = propValue.fbg ? $CLR.hex2rgb(propValue.fbg) : [0, 0, 0];

                this.formatProp.textClr = propValue.flt ? $CLR.hex2rgb(propValue.flt) : [255, 255, 255];

                this.formatProp.tooltipClr = propValue.ftt ? $CLR.hex2rgb(propValue.ftt) : [255, 255, 255];

                this.formatProp.backgroundAlpha = propValue.fbt != undefined ? ( 1 - parseInt(propValue.fbt) / 100) : 1;

                var getBool = function (v) {
                    if (v == true || v == "1" || v == 1 || v == "true") {
                        return true;
                    }

                    return false;
                }

                this.formatProp.useCustomAxisScale = propValue.fcas ? getBool(propValue.fcas) : false;

                var numCheck = function (num) {
                    if (num > Number.MAX_VALUE) {
                        num = Number.MAX_VALUE;
                    }
                    if (num < -1 * Number.MAX_VALUE) {
                        num = -1 * Number.MAX_VALUE;
                    }
                    return num;

                }

                this.formatProp.minValue = propValue.fmiav ? numCheck(parseFloat(propValue.fmiav)) : "";

                this.formatProp.maxValue = propValue.fmaav ? numCheck(parseFloat(propValue.fmaav)) : "";

                this.formatProp.condenseLabels = propValue.fcl ? getBool(propValue.fcl) : true;

                this.chartLineColors = ['#16b0ff', '#ff3729', '#04ba22', '#ff960e',
                    '#ae79de', '#cccd25', '#19cee0', '#a9a9a9',
                    '#b3cdef', '#ffa796', '#98df8a', '#ffbf80',
                    '#dac3ec', '#dac3ec', '#a1dfea', '#d6d6d6'];

                for (var i = 0; i < this.chartLineColors.length; i++) {
                    var propName = '' + Math.floor(i / 4) + i % 4;
                    propName = "fs" + propName;

                    var color = propValue[propName];
                    if (color) {
                        this.chartLineColors[i] = "#" + color;
                    }
                }

                //drop shadow/glow base color
                this.glowColor = this.utils.rgb2rgbStr(this.formatProp.tooltipClr);
                //this.glowColor = $CLR.rgbStr2hex(this.formatProp.tooltipClr);
            },

            /*
             * return the max value of all the points on Y axis
             */
            getMaxValue: function getMaxV() {
                if (typeof this.formatProp.maxValue == "number") {
                    return this.formatProp.maxValue;
                } else {
                    return this._super();
                }

            },

            /*
             * return the min value of all the points on Y axis
             */
            getMinValue: function getMinV() {
                if (typeof this.formatProp.minValue == "number") {
                    return this.formatProp.minValue;
                } else {
                    return this._super();
                }
            },

            preBuildRendering: function preBR() {
                if (this._super) {
                    this._super();
                }
                this.masterChartHeight = 90;
                this.slaveChartHeight = this.getHeight() - this.masterChartHeight;
            },

            buildRendering: function () {
                var that = this;
                var backup = mstrmojo.string.apply;
                mstrmojo.string.apply = function (tmpl, obj) {
                    if (!tmpl) {
                        return "";
                    }
                    return tmpl.replace(/\{([^\}]+)\}/gm,
                        function tokenRepl(token, prop) {
                            var s = token.replace(/@/g, 'that.');
                            var res = eval(s);
                            return res === undefined ? '' : res;
                        }
                    );
                };

                if (this._super) {
                    this._super();
                }

                mstrmojo.string.apply = backup;
            },

            /**
             * @ignore
             */
            postBuildRendering: function postBR() {
                var model = this.model;

                this.checkData(model);

                //If error message received just return.
                var err = model.err || model.eg;

                // TQMS 518532 add the prompts to the model in case the document contain prompts
                var xtabModel = this.xtabModel,
                    docModel = (xtabModel && xtabModel.docModel);

                if (err) {
                    // In case of error still need to set the docModel if there are prompts
                    if (docModel && docModel.prompts) {
                        this.model.docModel = docModel;
                    }
                    this.renderErrorMessage(err);
                    return;
                } else {
                    this.errorMsg.style.display = 'none';
                }

                resetLocalVars();
                getUITheme.call(this);

                this.updateSelectionLinkdrillInfo(model);
                // if baseModel is set and Model is derived model than reset the derived model with model
                // TODO fix XML mode which does not send us correct model hence missing vp so nothing change instead of giving an error
                if (this.baseModel && !model.vp) {
                    this.model = this.baseModel;
                }

                this.chartID = this.getChartID(docModel);

                if (!chartStatus[this.chartID]) {
                    addChartStatus(this.chartID);
                }
                // Set the scrolling element.
                this.scrollerConfig.scrollEl = this.animationCanvasDiv;

                // check if device type is Tablet Universal
                this.isAndroidTab = !!mstrApp.isTablet(); //determines if setting is android tablet
                this.masterContext = this.masterCanvas.getContext('2d');

                this.renderVisTooltip();
                //update margin.t so that it can contain two lines of text in tooltip
                this.setMarginTopByTooltipHeight();

                this.renderLegend();

                if (this._super) {
                    this._super();
                }

                this.renderTimeSelector();
                this.setAnimationCanvasContainer();

                // we have now rendered so update the scroller configuration
                localUpdateScrollerConfig.call(this);

                // TQMS 518532 add the prompts to the model in case the document contain prompts
                if (docModel && docModel.prompts) {
                    this.model.docModel = docModel;
                }

                this.drawSliderTooltipPointer();

                /*
                 * clear the selected highlight when all info windows are closed and there are not any other select targets
                 */
                var me = this;
                if (docModel) {
                    this._infoWClosedListener = this.xtabModel.docModel.attachEventListener('infoWindowClosed', this.id, function (evt) {
                        var infoWindowK = evt.psKey;
                        //selection targets are all info window && the closed info window is our target
                        if (!me.hasNonifwTarget && me.selectorTargets && me.selectorTargets[infoWindowK]) {
                            //						delete me.selectorTargets[infoWindowK];

                            //						var count = 0;
                            //						for (var k in me.selectorTargets) {
                            //						    if (me.selectorTargets.hasOwnProperty(k)) {
                            //						       ++count;
                            //						    }
                            //						}
                            //					     if(count <= 0){
                            //last infowindow closed
                            me.lastSelectedPoint = null;
                            me.incFetchChart(true);
                            //					     }
                            return;
                        }

                    });
                }

                this.fullScreenListener = mstrmojo.touchManager.attachEventListener('fullScreenStateChange', this.id, function (evt) {
                    this.adjustWidgetOffsets();
                });

                this.renderLegendTooltip();

                //#652102
                // jren: seems "canvas.width = canvas.width" fixed the canvas clear issue, so we can get rid of this sdk-dependent timeout now.
                /*
                 var sdkVersion = mstrMobileApp.getSDKVersion();
                 if(sdkVersion == 16 && canvasReseted){
                 window.setTimeout(function () {
                 canvasReseted = false;
                 if(me.isTimeSeries && me.canvas){
                 me.incFetchChart(true);
                 }
                 }, 100);
                 } */

                //			this.evalExpr = function(expr) { return eval(expr); }
                //			mstrmojo.VisDebuggerUtils.enable(this);

            },

            //deal with the reprompt. It will set the gridData in answerPrompts
            ongridDataChange: function onGridDataChange(evt) {
                this.model = this.gridData;
            },

            getChartID: function getChartID(docModel) {
                var chartID = "";

                var layoutModel = docModel ? docModel : (this.layoutModel ? this.layoutModel : ( this.model.layoutModel ? this.model.layoutModel : null ));

                if (layoutModel) {
                    chartID = layoutModel.oid + "_" + layoutModel.currlayKey + "_" + this.model.k;
                    //				if(this.model.series.length > 0)
                    //					chartID += "_" + this.model.series[0].rv.length;

                } else if (this.model.mid) {
                    chartID = this.model.mid;
                } else {
                    chartID = widgetCount++;
                }
                // console.log("chartID:" + chartID);
                return chartID;

            },

            checkData: function checkData(model) {
                var colHeaders = model.colHeaders,
                    categories = model.categories;

                if (!colHeaders || (colHeaders && colHeaders.length < 1)) {
                    this.model.err = mstrmojo.desc(8626, "The Time Series widget requires at least one attribute on the row axis and at least one metric on the column axis; optionally, one attribute can be placed above the metrics.");
                }
                if (colHeaders && colHeaders.length >= 1 && !this.isMetric(colHeaders[colHeaders.length - 1].items)) {
                    this.model.err = mstrmojo.desc(8626, "The Time Series widget requires at least one attribute on the row axis and at least one metric on the column axis; optionally, one attribute can be placed above the metrics.");
                }

                if ((categories && (!categories.items || categories.items.length < 2))) {
                    this.model.err = mstrmojo.desc(8475, 'There is not enough data to plot the graph.');
                }

            },

            renderErrorMessage: function renderErrorMessage(msg) {
                this.errorMsg.innerHTML = msg; //"<div class=\"mstrmojo-message\">" + msg + "</div>";
                this.errorMsg.style.display = 'block';
            },

            isMetric: function isMetric(items) {
                if (items && items.length > 0 && items[0].cs != null) {
                    return true;
                }
                return false;
            },

            updateSelectionLinkdrillInfo: function uscld(model) {
                //update selectionOrLinkdrillOnRow
                var rowHeaders = model.rowHeaders,
                    rowHL = rowHeaders.length;
                for (var i = 0; i < rowHL; i++) {
                    var rowH = rowHeaders[i];
                    if (rowH.sc && rowH.sc.tks) {
                        this.selectionOrLinkdrillOnRow = true;
                        return;
                    }
                    if (rowH.lm && rowH.lm[0] && rowH.lm[0].links) {
                        this.selectionOrLinkdrillOnRow = true;
                        return;
                    }
                }
            },

            // TQMS 554932
            hasPageBy: function hasPageBy() {
                if (this.baseModel && this.baseModel.phs && this.baseModel.phs.show) {
                    return true;
                }
                return false;
            },




            setlegendStatus: function setlegendStatus(ilo, lbw) {
                chartStatus[this.chartID].legendBarWidth = lbw;
                chartStatus[this.chartID].isLegendBarOpen = ilo;
            },

            setLegendSelected: function setLegendSelected(ils, lsi) {
                chartStatus[this.chartID].isLegendSelected = ils;
                chartStatus[this.chartID].legendSelectedIndex = lsi;

            },

            getLegendBarDiv: function getLegendBarDiv() {
                return this.domNode.childNodes[6];
            },

            getTimeSelectorDiv: function getTimeSelectorDiv() {
                return this.domNode.childNodes[5];
            },

            renderLegend: function renderLegend() {
                var placeholder = this.legendBarDiv;
                var m = this.margin;
                var chartID = this.chartID;
                var props = {
                    placeholder: placeholder,
                    model: this.model,
                    utils: this.utils,
                    widget: this,
                    isLegendBarOpen: chartStatus[chartID].isLegendBarOpen,
                    isAndroidTab: this.isAndroidTab,
                    isLegendSelected: chartStatus[chartID].isLegendSelected,
                    legendSelectedIndex: chartStatus[chartID].legendSelectedIndex,
                    top: m.t + "px",
                    right: "0px",
                    zIndex: 1
                };

                var w = new mstrmojo.VisTimeSeriesLegend(props);
                w.render();
                this._legend = w;
            },

            renderTimeSelector: function renderTimeSelector() {
                var placeholder = this.timeSelectorDiv;
                var m = this.margin;
                var chartID = this.chartID;
                var props = {
                    placeholder: placeholder,
                    offsetx: this.margin.l,
                    widget: this,
                    chartStatus: chartStatus[this.chartID]
                };

                var w = new mstrmojo.VisTimeSeriesTimeSelector(props);
                w.render();
                this._timeSelector = w;
            },

            renderVisTooltip: function renderVisTooltip() {
                //renderToolip
                var props = {
                    placeholder: this.tooltip,
                    cssClass: 'timeseries-tooltip'
                };
                this._tooltip = new mstrmojo.VisTooltip(props);
                this._tooltip.render();

                this._tooltip.toggle(false);
            },

            renderLegendTooltip: function renderLegendTooltip() {
                var props = {
                    placeholder: this.legendTooltip,
                    boundary: this.domNode
                };
                this._legendTooltip = new mstrmojo.VisTextTooltip(props);
                this._legendTooltip.render();

                this._legendTooltip.toggle(false);
            },

            setAnimationCanvasContainer: function setAnimationCanvasContainer() {
                var currStatus = chartStatus[this.chartID],
                    m = this.margin;
                //this.utils.translateCSS(m.l, 0, false, this.itemsContainerNode);
                this.itemsContainerNode.style.left = m.l + 'px';
                this.xLabelsDivContainer.style.left = (m.l - this.maxYLblWidth) + 'px';
            },

            /**
             * update the rns and rne value in model, as the VisChart using it.
             */
            updateRnsRne: function updateRnsRne(rns, rne) {
                var currStatus = chartStatus[this.chartID],
                    m = this.model;

                if ((rns == 0 || rns) && rne) {
                    currStatus.rns = rns;
                    currStatus.rne = rne;
                }
                m.rns = currStatus.rns;
                m.rne = currStatus.rne;
            },

            /*
             * Called by drawChart and redrawSlaveChart
             * recalculate ACrns and ACrne
             */
            drawPreparation: function drawPreparation(windowSize, rns, rne) {
                var me = this,
                    margin = this.margin,
                    model = me.model,
                    diff = rne - rns,
                    height = me.getHeight() - me.masterChartHeight,
                    ctx = me.animationContext;

                //chartWidth is the width for chart display on screen
                var chartWidth = me.getChartWidthOnScreen();
                //save the chartWidth
                this.chartWidth = chartWidth;

                getACRnsRne.call(this, rns, rne);
                var ACdiff = me.ACrne - me.ACrns;

                //adjust since we have the start and end point both lying on the border
                if (diff < windowSize) {
                    if (diff > 1) {
                        diff--;
                    }
                    if (ACdiff > 1) {
                        ACdiff--;
                    }
                    windowSize--;
                }

                this.itemsContainerNode.style.width = chartWidth + 'px';
                this.itemsContainerNode.style.height = height + 'px';

                this.xLabelsDivContainer.style.width = me.maxYLblWidth + chartWidth + 'px';
                this.xLabelsDivContainer.style.height = height + 'px';

                //totalChartWidth is the width for the total chart at this ratio
                totalChartWidth = (windowSize / diff) * chartWidth;

                me.totalChartWidth = totalChartWidth;
                var acContentWidth = 0;
                if (model.currentRatio > rangeToSeriesMaxRatio) {
                    acContentWidth = (ACdiff / diff) * chartWidth;
                } else {
                    acContentWidth = totalChartWidth;
                }
                this.acContentWidth = acContentWidth;

                var acWidth = rangeToSeriesMaxRatio * this.getWidth();
                if (me.animationCanvas.width !== acWidth) {
                    canvasReseted = true;
                }
                me.animationCanvas.width = acWidth;

                //cache x ratio since the animation canvas width is now changed
                me.RTX = (totalChartWidth - 1) / (this.windowSize - 1);

            },

            /**
             * overwite the draw chart behavior of visChartLine
             */
            drawChart: function drwchrt() {
                var model = this.model;
                if (model.err) {
                    return;
                }

                var me = this,

                    mvalues = model.mvalues,
                    width = me.getWidth(),
                    margin = me.margin,
                    utils = me.utils,
                    values = model.series,
                    ylbls = model.ylbls,
                    windowSize = me.windowSize,
                    currStatus = chartStatus[this.chartID];

                //(!currStatus.rns && currStatus.rns != 0) make the expression false when currStatus.rns has value(specially rns = 0)
                if ((!currStatus.rns && currStatus.rns != 0) || !currStatus.rne || currStatus.rns < 0 || currStatus.rne > windowSize) {
                    currStatus.rns = model.rns;
                    currStatus.rne = model.rne;

                    //adjust the diff of rns and rne to at least 2
                    if ((currStatus.rne - currStatus.rns) < 2) {
                        if (currStatus.rns > 0) {
                            currStatus.rns = currStatus.rne - 2;
                        } else {
                            currStatus.rne = currStatus.rns + 2;
                        }
                    }
                }
                this.updateRnsRne();
                //master chart height
                var mch = me.masterChartHeight;

                var height = me.slaveChartHeight;

                if (!values) {
                    return;
                }

                if (me.isDrawAxis && me.drawYAxisLabels) {
                    margin.l = utils.getLabelWidthForMargin(me, model.mls);
                }

                //set mastercanvas size
                me.masterCanvas.height = mch;
                me.masterCanvas.width = width;
                // fill the background color of master canvas
                utils.fillMasterChartBackground(me, 0, masterMargin.t, width, mch - masterMargin.t - masterMargin.b, masterMargin.b, me.masterContext);

                me.MRTY = (mch - masterMargin.t - masterMargin.b - 1 - 3 ) / (mvalues[mvalues.length - 1] - mvalues[0]);
                me.MRTX = (width - masterMargin.l - masterMargin.r - 1) / (windowSize - 1);

                //draw master chart
                me.drawSeries(0, windowSize, currStatus.rns, currStatus.rne, values, me.masterContext, true);

                me.setMasterSlider();

                this.calculateRnsRneFromSXP();

                if (me.canvas.height != height || me.animationCanvas.height != height || me.highlightCanvas.height != height || me.canvas.width != width) {
                    me.canvas.height = me.animationCanvas.height = me.highlightCanvas.height = height;
                    me.canvas.width = me.highlightCanvas.width = width;
                    canvasReseted = true

                    // since size of canvas is changed need to fill the background color on canvas again
                    utils.fillBackground(me);
                }

                //+5 for ylby padding
                this.maxYLblWidth = this.getMaxTextWidth(ylbls, this.mstrmojo_Chart_lbl_font) + 5;

                this.drawPreparation(windowSize, currStatus.rns, currStatus.rne);
                //cache y ratios, -4 to make the chart not overlap with the x axis
                me.RTY = (height - margin.t - margin.b - 1 - 4) / (mvalues[mvalues.length - 1] - mvalues[0]);

                //#652102
                /*
                 var sdkVersion = mstrMobileApp.getSDKVersion();
                 if(!canvasReseted || sdkVersion != 16){
                 me.drawSeries(me.ACrns, me.ACrne, currStatus.rns, currStatus.rne, values,  context,false);
                 } */

                me.drawSeries(me.ACrns, me.ACrne, currStatus.rns, currStatus.rne, values, me.animationContext, false);

            },

            calculateRnsRneFromSXP: function calrns() {
                var me = this;

                var rne = Math.round((me.SRXP - masterMargin.l) / me.MRTX) + 1; // add 1 extra since last point is on border
                rne = Math.min(rne, me.windowSize); // make sure rne is not greater than the series length
                var rns = Math.round((me.SLXP - masterMargin.l) / me.MRTX);

                this.updateRnsRne(rns, rne);
            },

            // will change acContentWidth and master slider size, rns is decide by this.SLXP
            reDrawSlaveChartImpl: function reDrawSlaveChartImpl() {
                var me = this,
                    model = me.model,
                    currStatus = chartStatus[this.chartID],
                    values = model.series,
                    context = me.animationContext;



                this.drawPreparation(me.windowSize, currStatus.rns, currStatus.rne);

                me.drawSeries(me.ACrns, me.ACrne, currStatus.rns, currStatus.rne, values, context, false);

                // must need the new rns and rne set to model to apply this
                localUpdateScrollerConfig.call(me);
                this.removeLabels();
                itemClicked = true;
                this.drawLabels();
                itemClicked = false;
            },

            //only redraw the animation canvas part,used when series is selected
            redrawSeries: function redrawSeries() {
                var me = this,
                    model = me.model,
                    values = model.series,
                    context = me.animationContext,
                    windowSize = me.windowSize,
                    ht = me.getHeight(),
                    currStatus = chartStatus[this.chartID];

                //context.clearRect(0, 0, me.animationCanvas.width, ht);
                me.animationCanvas.width = me.animationCanvas.width;

                me.drawSeries(me.ACrns, me.ACrne, currStatus.rns, currStatus.rne, values, context, false);

                localUpdateScrollerConfig.call(me);

                this.removeLabels();
                itemClicked = true;
                this.drawLabels();
                itemClicked = false;
            },

            //won't change total canvas size and master slider size, rns is given by model
            incFetchChart: function incFetchChart(mustRedraw) {
                var me = this,
                    model = me.model,
                    currStatus = chartStatus[this.chartID],
                    values = model.series,
                    context = me.animationContext,
                    m = me.margin,
                    utils = me.utils,
                    lines = [],
                    width = me.getWidth(),
                    chartWidth = me.getChartWidthOnScreen(),
                // initially width of the background main canvas
                    h = me.canvas.height,
                // height of the background main canvas
                    windowSize = me.windowSize;

                var v0l = values[0].rv.length;
                var diff = currStatus.rne - currStatus.rns;
                var needRedraw = getACRnsRne.call(this);
                /*
                 * mustRedraw: true when the selected point is changed
                 * needRedraw: true when ACRns or ACRne is changed, or has serie selected and rns or rne changed
                 * me.needRedrawVerticalLine: true when label beyond y-axis is removed
                 */
                var redrawChart = mustRedraw || needRedraw || currStatus.isLegendSelected || me.needRedrawVerticalLine;
                if (redrawChart) {
                    var ACdiff = me.ACrne - me.ACrns;
                    //adjust since we have the start and end point both lying on the border
                    if (diff < v0l) {
                        if (diff > 1) {
                            diff--;
                        }
                        if (ACdiff > 1) {
                            ACdiff--;
                        }
                        v0l--;
                    }

                    //totalChartWidth is the width for the total chart at this ratio
                    totalChartWidth = (v0l / diff) * chartWidth;

                    me.totalChartWidth = totalChartWidth;
                    var acContentWidth = 0;
                    if (model.currentRatio > rangeToSeriesMaxRatio) {
                        acContentWidth = (ACdiff / diff) * chartWidth;
                    } else {
                        acContentWidth = totalChartWidth;
                    }
                    this.acContentWidth = acContentWidth;

                    //context.clearRect(0,0,me.animationCanvas.width,me.animationCanvas.height);
                    me.animationCanvas.width = me.animationCanvas.width;

                    me.drawSeries(me.ACrns, me.ACrne, currStatus.rns, currStatus.rne, values, context, false);

                    // must need the new rns and rne set to model to apply this
                    localUpdateScrollerConfig.call(me);
                }

                this.removeLabels();
                itemClicked = true;
                this.drawLabels(!redrawChart);
                itemClicked = false;
            },

            // called when resize master slider done
            reDrawSlaveChart: function reDrawSlaveChart() {
                var me = this;

                this.calculateRnsRneFromSXP();
                this.reDrawSlaveChartImpl();

                chartSizeChanged = false;
                masterSliderClicked = null;
                this.hideMessage();
            },

            drawSeries: function drawSeries(start, end, rns, rne, values, context, isMasterChart) {
                var me = this,
                    utils = me.utils,
                    lines = [],
                    k = 0,
                    vl = values.length;

                var lineWidth = isMasterChart ? 1 : (rne - rns > 180 ? 1 : 2);
                //        	for (var j = 0; j < vl; j++) {
                for (var j = vl - 1; j >= 0; j--) {
                    lines = [];
                    k = 0;
                    for (var i = start; i < end; i++) {
                        var val = values[j].rv[i];
                        if (val.length === 0) {
                            lines[k++] = null;
                            continue;
                        }

                        lines[k] = {
                            x: isMasterChart ? ((i * me.MRTX) + masterMargin.l + 1) : ((i - start) * me.RTX ),
                            y: isMasterChart ? utils.getMasterYValue(me, val, masterMargin) : utils.getYValue(me, val)
                        };
                        k++;
                    }

                    me.drawChartLine(lines, rns - start, rne - start, j, context, isMasterChart, lineWidth);

                }

                if (!isMasterChart && me.lastSelectedPoint) {
                    me.highlightSelectedPoint();
                }
            },

            getSerieColor: function getSerieColor(serieIndex) {
                var clrLength = this.chartLineColors.length;
                //color of line depends on what color is the attribute here
                return this.chartLineColors[serieIndex % clrLength];
            },

            /**
             * overwite the draw chart line behavior of chartLine
             */
            drawChartLine: function drwcl(lines, rns, rne, si, context, isMasterChart, lw) {

                var me = this,
                    m = me.model,
                    s = m.series[si],
                    utils = this.utils,
                    currStatus = chartStatus[this.chartID];

                context.save();
                context.lineCap = 'round';
                context.lineWidth = lw || 2;
                context.lineJoin = 'round';

                context.beginPath();


                if (this.formatProp && this.formatProp.useCustomAxisScale) {
                    var margin;
                    if (!isMasterChart) {
                        margin = me.margin;
                        context.rect(0, margin.t, me.animationCanvas.width, me.slaveChartHeight - margin.b - margin.t);
                    } else {
                        margin = masterMargin;
                        context.rect(0, margin.t, me.getWidth(), me.masterChartHeight - margin.b - margin.t);
                    }
                    context.clip();
                }


                var clr = this.getSerieColor(si),
                    rgbClr = $CLR.hex2rgb(clr),
                    l = lines.length,
                    dataPointPerScreen = rne - rns;

                context.strokeStyle = clr;

                if (currStatus.isLegendSelected && !isMasterChart) {
                    if (currStatus.legendSelectedIndex === si) {
                        var MaxY = this.canvas.height - this.margin.b;
                        var start = rns, end = rne - 1;
                        for (var i = 0; i < Math.ceil((l - 1 - rns) / (dataPointPerScreen - 1)); i++) {
                            if (mstrmojo.dom.isIE10) {
                                utils.drawLineAreaWithSplit(me, lines, start, end, MaxY, rgbClr, context, MAXPOINTS_PER_DRAW);
                            } else {
                                utils.drawLineArea(me, lines, start, end, MaxY, rgbClr, context);
                            }
                            start = end;
                            end = Math.min(start + dataPointPerScreen - 1, l - 1);
                        }
                        start = Math.max(rns - dataPointPerScreen + 1, 0), end = rns;
                        for (var i = Math.ceil((rns) / (dataPointPerScreen - 1)); i > 0; i--) {
                            if (mstrmojo.dom.isIE10) {
                                utils.drawLineAreaWithSplit(me, lines, start, end, MaxY, rgbClr, context, MAXPOINTS_PER_DRAW);
                            } else {
                                utils.drawLineArea(me, lines, start, end, MaxY, rgbClr, context);
                            }

                            end = start;
                            start = Math.max(start - dataPointPerScreen + 1, 0);
                        }
                        if (mstrmojo.dom.isIE10) {
                            utils.drawLineAreaWithSplit(me, lines, start, end, MaxY, rgbClr, context, MAXPOINTS_PER_DRAW);
                        } else {
                            utils.drawLineArea(me, lines, start, end, MaxY, rgbClr, context);
                        }
                        context.strokeStyle = this.highlightColor;
                        context.globalAlpha = 1;
                        context.lineWidth = 2;
                    } else {
                        context.globalAlpha = 0.3;
                        context.lineWidth = 1;
                    }
                }

                if (mstrmojo.dom.isIE10) {
                    utils.drawLineSetWithSplit(me, lines, false, context, MAXPOINTS_PER_DRAW);
                } else {
                    utils.drawLineSet(me, lines, false, context);
                }

                //TODO don't fill area for now since in slicing the area is not filled properly
                /*if(!this.multiLine || this.model.series.length === 1) {
                 this.fillinColor = context.strokeStyle;
                 utils.fillLinesArea(me,lines.slice(0));
                 }*/

                context.restore();

            },

            /*
             * draw XYAxis and XYLabels
             */
            drawLabels: function drwlbls(needNotDrawVerticalGridLine) {
                /*
                 var sdkVersion = mstrMobileApp.getSDKVersion();
                 if(sdkVersion==16 && canvasReseted){
                 return;
                 }
                 */
                this.drawChartXYAxis();
                if (this._super) {
                    this._super(needNotDrawVerticalGridLine);
                }
            },

            drawSelector: function drwsl(lbl, rl, intervalChanged) {
                var m = this.model,
                    sl = m.series[0].rv.length,
                    rng = sl,
                    bm = this.baseModel,
                    row = bm.rowHeaders,
                    currStatus = chartStatus[this.chartID],
                    rns = currStatus.rns,
                    rne = currStatus.rne;

                if (intervalChanged) {

                    //Compute the slice we need to draw
                    var rs = parseInt(rl.rs, 10);
                    var sr = rl.sr;

                    for (var i = 0; i < row.length; i++) {
                        // Now match which row is it to get the range
                        if (row[i].id === sr) {
                            rng = row[i].l * rs;
                            break;
                        }
                    }

                    //make sure the interval is at least 2
                    if (rng < 2) {
                        rng = 2;
                    }

                    var index = mstrmojo.dom.findAncestorByAttr(lbl, "value", true, this.domNode);

                    /*
                     * PM required, removing the following rules:
                     * When a time interval button is tapped,
                     * 1.	If this interval havent been tapped before, we will locate the widow at the center of current widow ;
                     * 2.	If this interval have been tapped before, we will use the window last time this interval used.
                     */
                    //		     	var savedPosition = currStatus.timeSelectedIntervalPosition[index.value];
                    //		     	if(savedPosition && savedPosition.rns >= 0 && savedPosition.rne <= sl){
                    //		     		currStatus.rns = savedPosition.rns;
                    //		     		currStatus.rne = savedPosition.rne;
                    //		     	}
                    //		     	else
                    //		     	{
                    /*
                     * PM required:
                     * when the user taps on a new time interval, instead of centering the new window around the current range,
                     * we would instead increase or decrease the range by keeping the right most datapoint fixed.
                     * this is similar to what Google Finance does
                     */
                    var right = rne;
                    if (right - rng >= 0) {
                        currStatus.rns = right - rng;
                        currStatus.rne = right;
                    } else {
                        currStatus.rns = 0;
                        currStatus.rne = rng < sl ? rng : sl;
                    }
                    //now compute the current mid point and accordingly set the next start and end points for the series
                    //	                var mid = rne - Math.round((rne - rns) / 2),
                    //	                    // this is the mid point of current screen
                    //	                    hr = Math.round(rng / 2);
                    //
                    //	                if (mid - hr >= 0 && mid + hr <= sl) {
                    //	                	currStatus.rns = mid - hr;
                    //	                	currStatus.rne = mid + hr - rng % 2; // mod it by 2 so if range is not rounded we don't delete 1
                    //	                } else if (mid - hr >= 0) {
                    //	                	currStatus.rne = sl;
                    //	                	currStatus.rns = sl - rng > 0 ? sl - rng : 0;
                    //	                } else {
                    //	                	currStatus.rns = 0;
                    //	                	currStatus.rne = rng < sl ? rng : sl;
                    //	                }

                    this.updateIntervalPosition();
                    //	            }
                    this.updateRnsRne();
                }
                this.refreshChart(true, isDataSetChanged);

                itemClicked = false;
                this.hideMessage();
            },

            /**
             * Returns the index(on screen) of the point that matched the x coordinate (null if nothing is selected) call by the handleTouchMove in VisChart.js
             * @param x the x position of the click event
             * @param y the y position of the click event
             * @return the selected value (null if nothing is selected)
             */
            getTouchValue: function gtvlindx(x, y) {
                var md = this.model,
                    m = this.margin,
                    currStatus = chartStatus[this.chartID];

                //data point count on screen
                var sz = currStatus.rne - currStatus.rns > 0 ? currStatus.rne - currStatus.rns > 1 ? currStatus.rne - currStatus.rns : 2 : this.windowSize;
                var touchVal = Math.round(((x - m.l) * (sz - 1)) / (this.getChartWidthOnScreen() ));
                return (touchVal < sz) ? touchVal : null;
            },

            /*
             * Return the rowIdx, serieIdx, the data point position on widget
             * for the point nearest to the touch point
             */
            getNearestPoint: function getNP(touchX, touchY) {
                var me = this,
                    currStatus = chartStatus[this.chartID],
                    margin = me.margin;

                var touchPointOnWidget = me.utils.getTouchXYOnWidget(touchX, touchY, me);
                touchX = touchPointOnWidget.touchX;
                touchY = touchPointOnWidget.touchY;

                // if we have not touched in the chart area don't do anything
                if (touchX < margin.l || touchY < margin.t || touchY > me.canvas.height - margin.b) {
                    return;
                }

                var xIndexOnScreen = this.getTouchValue(touchX, touchY);

                var rowIdx = xIndexOnScreen + currStatus.rns;
                var pointX = (xIndexOnScreen * me.RTX) + me.margin.l;
                var pointY, serieIdx;

                if (currStatus.isLegendSelected) {
                    serieIdx = currStatus.legendSelectedIndex;
                    pointY = me.utils.getYValue(me, me.model.series[serieIdx].rv[rowIdx]);
                } else {
                    var nearestPoint = me.utils.getSeriesIndexAndYValue(me, rowIdx, touchY);
                    serieIdx = nearestPoint.si;
                    pointY = nearestPoint.y;
                }

                return { rowIdx: rowIdx, serieIdx: serieIdx, point: {x: pointX, y: pointY} };
            },

            /**
             * Called to highlight a single data point
             * @param {Integer} [x] the x axis point index to highlight
             */
            highlightPoint: function hghlghtpnt(x, touchX, touchY) {

                //local vars
                var me = this,
                    ctx = me.highlightContext,
                    height = me.highlightCanvas.height,
                    mg = me.margin,
                    m = me.model,
                    utils = me.utils,
                    currStatus = chartStatus[this.chartID],
                    si = currStatus.isLegendSelected ? currStatus.legendSelectedIndex : me.seriesIndex;

                // clear around the previous highlight
                /*   if (me.prevHighlight >= 0) {
                 var prevx = (me.prevHighlight * me.RTX)+ mg.l;
                 var y = mg.t - TOP_PADDING > 0 ? mg.t - TOP_PADDING : 0; // fix for no margin on top
                 ctx.clearRect(prevx - PADDING, y, prevx + PADDING, height - mg.b);
                 }
                 if (me.prevTouchX >= 0) {
                 var y = mg.t - TOP_PADDING > 0 ? mg.t - TOP_PADDING : 0; // fix for no margin on top
                 ctx.clearRect(me.prevTouchX - PADDING, y, me.prevTouchX + PADDING, height - mg.b);
                 }
                 */
                // ctx.clearRect(0,0,me.getWidth(),me.getHeight());
                this.highlightCanvas.width = this.highlightCanvas.width;
                if (x < 0) {
                    return;
                }

                var xcoord = (x * me.RTX) + mg.l;

                //      ctx.shadowColor = me.highlightColor;
                // set colors
                ctx.strokeStyle = this.utils.rgb2rgbStr(this.formatProp.textClr);

                ctx.lineCap = "round";

                //draw the highlight vertical line
                ctx.lineWidth = 2;
                ctx.globalAlpha = 1;
                utils.drawLineSet(me, [
                    {
                        x: touchX,
                        y: this._tooltip.domNode.offsetHeight//mg.t - 20
                    },
                    {
                        x: touchX,
                        y: height - mg.b
                    }
                ], false, ctx);

                ctx.strokeStyle = me.highlightColor;
                ctx.fillStyle = ctx.strokeStyle;
                //get the series which we want to draw
                var s = m.series,
                    l = s.length,
                    rns = (currStatus.rns === 0 || currStatus.rne - currStatus.rns > 1) ? currStatus.rns : currStatus.rns - 1,
                    rowIdx = rns + x,
                    y = utils.getYValue(me, s[si].rv[rowIdx]); //This is to select the current point based on the start point currently shown
                //position the highlight image
                if (!chartStatus[this.chartID].isLegendSelected) {
                    ctx.strokeStyle = me.getSerieColor(si);
                }
                ctx.fillStyle = ctx.strokeStyle;

                if (y >= mg.t && y <= this.canvas.height - mg.b) {
                    //only draw the cicle when in certain range
                    utils.drawArc(me, xcoord, y, 5, 0, Math.PI * 2, true, true, ctx);
                }

                // update the last highlight point
                this.lastHighlightPoint = {rowIdx: rowIdx, serieIdx: si, point: {x: xcoord, y: y}};

            },

            hideTimeSelectorLabels: function htsl() {
                var lbls = this.domNode.getElementsByClassName('timeseries-intervals');
                for (var i = 0; i < lbls.length; i++) {
                    lbls[i].style.display = 'none';
                }
            },

            showTimeSelectorLabels: function stsl() {
                var lbls = this.domNode.getElementsByClassName('timeseries-intervals');
                for (var i = 0; i < lbls.length; i++) {
                    lbls[i].style.display = 'block';
                }
            },

            /**
             *
             */
            getFormattedDateForTooltip: function getFormattedDateForTooltip(/*date string in milliseconds*/ val, isLongFormat) {
                if (isNaN(val)) {
                    return val;
                }
                var fVal = val;
                try {
                    val = this.utils.convertRawValueToMilliseconds(val);
                    var dt = new Date(Number(val)),
                        $_DT = mstrmojo.locales.datetime;
                    var mn = isLongFormat ? $_DT.MONTHNAME_FULL[dt.getMonth()] : $_DT.MONTHNAME_SHORT[dt.getMonth()];
                    var yr = dt.getFullYear().toString();
                    if (isLongFormat) {
                        fVal = mn + " " + dt.getDate() + ", " + yr;
                    } else {
                        fVal = mn + "-" + dt.getDate() + "-" + yr.substring(2);
                    }
                } catch (e) {
                    // in case of any exception do nothing and will return the actual value that was passed
                }
                return fVal;
            },

            showLegendTooltip: function showLegendTooltip(e) {
                 this._legendTooltip.updateContent(e);
            },

            hiddenLegendTooltip: function hiddenLegendTooltip() {
                this._legendTooltip && this._legendTooltip.toggle(false);
            },

            getLegendName: function getLegendName(colHeaders, series, i) {
                var colHLength = colHeaders.length;
                var hiLength = series[i].hi.length;

                if (colHLength < 1) {
                    return "null";
                }

                if (hiLength == colHLength) {

                    var legendName = "";

                    for (var j = 0; j < hiLength; j++) {
                        var colHeader = colHeaders[j];
                        var colName = "";

                        if (colHeader.es) {//attributes
                            colName = colHeader.es[series[i].hi[j]];
                        } else {//metric
                            colName = colHeader.items[series[i].hi[j]].n;
                        }

                        if (j > 0) {
                            legendName += " ";
                        }
                        if (colName != "") {
                            legendName += colName;
                        }
                    }
                    return legendName;
                } else {
                    var items = colHeaders[0].items
                    legendName = items[i % items.length].n;
                    return legendName;
                }
                return "null";
            },

            /**
             * get Row Header Name and Value
             */
            getRowHeader: function getrh(idx) {
                var me = this,
                    m = me.model,
                    riArray = m.ri,
                    s = m.series,
                    cat = m.categories,
                    tp = cat.tp,
                    currStatus = chartStatus[this.chartID],
                    rowHs = m.rowHeaders,
                    rowHLength = rowHs.length,
                    rowHeader = [];

                //get the row/attribute values
                var rVal = cat.items[idx];

                var ri = riArray && riArray[idx];

                if (!ri) {
                    return rowHeader;
                }

                // check if categories is of format time only than call function
                if (tp.toString() === me.DSS_XML_BASE_FORM_DATE) {
                    rVal = me.getFormattedDateForTooltip(rVal, true);
                    var rowHeaderObj = {};
                    rowHeaderObj.n = rowHs[rowHLength - 1].n;
                    rowHeaderObj.v = rVal;
                    rowHeader.push(rowHeaderObj);
                } else {
                    //if the inner most attribute is not formatted as a Date, display all the row Attribute

                    for (var i = 0; i < rowHLength; i++) {
                        var rowHeaderObj = {}

                        var rowH = rowHs[i];
                        rowHeaderObj.n = rowH.n;
                        rowHeaderObj.v = rowH.es[ri[i]] || "";
                        rowHeader.push(rowHeaderObj);
                    }
                }

                return rowHeader;

            },

            setMarginTopByTooltipHeight: function setMarginTopByTooltipHeight() {
                var me = this,
                    m = me.model,
                    mg = me.margin,
                    s = m.series,
                    colH = m.colHeaders;

                if (this._tooltip) {
                    this._tooltip.displayInfo([
                        {n: 'legendName', v: 'val'},
                        {n: 'rowHeaderName', v: 'rowHeaderValue'}
                    ]);
                    this._tooltip.toggle(true);
                    var height = this._tooltip.domNode.offsetHeight + 10;
                    this._tooltip.toggle(false);

                    if (me.margin.t < height) {
                        me.margin.t = height;
                    }
                }

                // get slider tooltip height
                var stt = me.sliderTooltip,
                    sttF = stt.firstChild,
                    sttP = stt.lastChild;

                sttF.innerHTML = "name: value";
                sttF.style.display = 'block';

                var sliderTooltipHeight = sttF.offsetHeight;

                //-7 for the tooltip pointer
                me.sliderTooltipYPosition = me.getHeight() - me.masterChartHeight - sliderTooltipHeight - 7 + masterMargin.t;
                sttP.style.top = sliderTooltipHeight + 'px';

                sttF.style.display = 'none';

            },

            //render the tooltip for the slave chart
            renderTooltip: function rndrttp(valIndex, touchX, touchY) {
                if (valIndex < 0) {
                    this._tooltip.toggle(false);
                    return;
                }

                var me = this,
                    m = me.model,
                    mg = me.margin,
                    s = m.series,
                    currStatus = chartStatus[this.chartID],
                    si = currStatus.isLegendSelected ? currStatus.legendSelectedIndex : me.seriesIndex,
                    rns = (currStatus.rns === 0 || currStatus.rne - currStatus.rns > 1) ? currStatus.rns : currStatus.rns - 1,
                    colH = m.colHeaders;
                var width = me.getWidth();

                if (!tooltipShown) {
                    me.hideTimeSelectorLabels();
                    tooltipShown = true;

                    var touchManager = mstrmojo.touchManager;
                    this._touchListener = touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                        if (!isTouchedOnWidget.call(me, evt.touch)) {
                            me.hiddenTooltipAndShowTimeSelector();   // hide the tooltips
                        }
                    });
                }
                var vIdx = rns + valIndex;
                var val = s[si].v[vIdx] ? s[si].v[vIdx] : "null";
                var legendName = this.getLegendName(colH, s, si);
                //Set the tooltip text
                var rowHeaders = this.getRowHeader(vIdx),
                    rowHeaderName = "",
                    rowHeaderValue = "";
                for (var i = 0; i < rowHeaders.length; i++) {
                    rowHeaderName += rowHeaders[i].n;
                    rowHeaderValue += rowHeaders[i].v;
                    if (i < rowHeaders.length - 1) {
                        rowHeaderName += " ";
                        rowHeaderValue += " ";
                    }
                }

                this._tooltip.displayInfo([
                    {n: legendName, v: val},
                    {n: rowHeaderName, v: rowHeaderValue}
                ]);
                this._tooltip.toggle(true);

                this._tooltip.doLayout(width - 10);

                //Calculate the position of the highlight tooltip and adjust if necesary
                //get the width of the tooltip div
                var ttw = this._tooltip.domNode.offsetWidth,
                    x = touchX - ttw / 2;

                /**
                 * PM required: let the tooltip expand horizontally as much as needed, leaving at least 5 pixels padding left and right between it and the border.
                 */
                if (x < 5) {
                    x = 5;
                } else if (x > width - 5 - ttw) {
                    x = width - 5 - ttw;
                }

                this._tooltip.posTo({x: x, y: 5});

            },

            /**
             * Handles the touch end event.
             * @private
             */
            handleTouchEnd: function handleTouchEnd() {
                this._super();
                this._tooltip && this._tooltip.toggle(false);
            },

            showMessage: function shmsg(text) {
                var msg = this.loadingMsg,
                    mns = msg.style;

                // Add message text.
                msg.innerHTML = text || mstrmojo.desc(5674, 'Loading...');
                mns.display = 'block';
                mns.opacity = 1;

                // Display message centered within the widget.
                var x = Math.round(this.getWidth() / 2 - msg.offsetWidth / 2);
                var y = Math.round(this.getHeight() / 2 - msg.offsetHeight / 2);

                this.utils.translateCSS(x, y, false, msg);

            },

            hideMessage: function hmsg() {
                this.loadingMsg.style.opacity = 0;
            },

            showMasterSliderTooltip: function showMasterSliderTooltip(item) {
                $CSS.addClass(item.node, 'mstrmojo-timeseries-span-shadow');

                var stt = this.sliderTooltip;
                stt.firstChild.style.display = 'block';
                stt.lastChild.style.display = 'block';
                // show the tooltip
                this.renderSliderTooltip(item.value === 'L' ? this.SLXP : this.SRXP);

            },

            /*
             * called when dimension changed
             */
            //        reRender: function reRender() {
            //            //If error message received just return.
            //            if (this.model.err || this.model.eg) {
            //                // #500786 should not render the error message again just do nothing.
            //                return;
            //            }
            //
            //            this.slaveChartHeight = this.getHeight() - this.masterChartHeight;
            //            //Now resize the other elements on the markup
            //            this.canvas.width = this.animationCanvas.width = this.highlightCanvas.width = this.getWidth();
            //            this.canvas.height = this.animationCanvas.height = this.highlightCanvas.height = this.slaveChartHeight;
            //            this.animationCanvasDiv.height = this.slaveChartHeight;
            //
            //            canvasReseted = true;
            //
            //            //#670831
            //        	this.setMarginTopByTooltipHeight();
            //
            //		    var m = this.margin;
            //		    this.legendBarDiv.style.height = (this.canvas.height-m.t-m.b) + 'px';
            //		    this._legend.reRender();
            //
            //	        this.refreshChart(true, false);
            //	        this.setAnimationCanvasContainer();
            //
            //			this._timeSelector.reRender();
            //
            //			localUpdateScrollerConfig.call(this);
            //			this.drawSliderTooltipPointer();
            //        },


            unrender: function unrender(ignoreDom) {

                if (this._tooltip) {
                    this._tooltip.destroy();
                    delete this._tooltip;
                }
                if (this._legend) {
                    this._legend.destroy();
                    delete this._legend;
                }
                if (this._timeSelector) {
                    this._timeSelector.destroy();
                    delete this._timeSelector;
                }

                if (this._legendTooltip) {
                    this._legendTooltip.destroy();
                    delete this._legendTooltip;
                }

                if (this._super) {
                    this._super(ignoreDom);
                }
            },

            // #507755  refresh is called on slice operation
            refresh: function refresh() {
                var me = this;

                removeLegendAndTimeSelectorChildren.call(this);

                // remove all other labels
                me.removeLabels();

                me.lastSelectedPoint = null;

                me.render();
            },

            /*
             * remove XYAxis and XYLabels
             */
            removeLabels: function rmvlbls() {
                var me = this;

                //clear the background, erase the horizon line for Y-label
                me.canvas.width = me.canvas.width;
                // refill the background color
                me.utils.fillBackground(me);

                //remove XLabels
                me.xLabelsDiv.innerHTML = '';
                //remove YLabels
                var lbls = me.domNode.getElementsByClassName('mstrmojo-chart-ylbl-div')[0];
                if (lbls) {
                    lbls.innerHTML = '';
                }

            },

            refreshChart: function refcht(isMetric, pld) {
                var me = this,
                    wd = me.getWidth(),
                    ht = me.getHeight();
                if (me.model.err) {
                    return;
                }
                //clear animation and highlite canvas
                //me.highlightContext.clearRect(0, 0, wd, ht);
                me.highlightCanvas.width = wd;
                //me.animationContext.clearRect(0, 0, me.animationCanvas.offsetWidth, ht);
                me.animationCanvas.width = me.animationCanvas.width;

                if (isMetric) {
                    me.context.clearRect(0, 0, wd, ht);

                    // remove labels
                    me.removeLabels();

                    if (pld) { //if date set changed
                        me.data.processLinearData(me);
                    }

                }

                // re-draw chart
                me.drawChart();
                this.setAnimationCanvasContainer();
                me.drawLabels();

                //update the scroller config
                localUpdateScrollerConfig.call(me);

                //#652102
                /*
                 var sdkVersion = mstrMobileApp.getSDKVersion();
                 if(sdkVersion == 16 && canvasReseted){
                 window.setTimeout(function () {
                 canvasReseted = false;
                 if(me.isTimeSeries && me.canvas){
                 me.incFetchChart(true);
                 }
                 }, 0);
                 } */
            },

            // handle time selector click
            timeSelectorOnClick: function hoc(item) {
                var currStatus = chartStatus[this.chartID];
                if (!itemClicked) {
                    itemClicked = true;

                    var me = this,
                        v = item.value,
                        node = item.node,
                        intervalChanged = true;

                    // check if we are clicking on already selected selector in that case just return
                    if (node === me.currSelection && !currStatus.usingCustomInterval) {
                        itemClicked = false;
                        return;
                    }

                    if (v === 'S') {
                        if (currStatus.usingCustomInterval) {
                            currStatus.usingCustomInterval = false;
                        } else {
                            me.updateIntervalPosition();
                        }

                        if (me.currSelection) {
                            me._timeSelector.toggleSelected(me.currSelection, false);
                            me._timeSelector.toggleGlowEffect(me.currSelection, false);
                        }

                        me._timeSelector.toggleSelected(node, true);
                        me._timeSelector.toggleGlowEffect(node, true);

                        var bm = me.baseModel, tslIndex = parseInt(node.getAttribute("value"));
                        var tsl = bm.vp.rl[tslIndex];

                        // if the data if from different templates
                        if ((bm.k && bm.k !== tsl.ds) && me.layoutModel) { //#506004 make sure layout level is defined or else it's template level
                            var getData = resetBaseAndDerivedData.call(this, tsl);
                            if (!getData) {
                                return;
                            }
                        } else {
                            isDataSetChanged = false;
                        }

                        intervalChanged = node !== me.currSelection;
                        me.currSelection = node;
                        currStatus.currSelectionIdx = me.currSelection.getAttribute('value');
                        me.showMessage();

                        window.setTimeout(function () {
                            me.drawSelector(node, tsl, intervalChanged);
                        }, 10);

                    }
                }

            },

            moveMasterSlider: function moveMasterSlider(x /*current mouse position*/) {
                var me = this,
                    m = me.model,
                    width = me.getWidth(),
                    delta = Math.round(x - originalTouchPosition),
                    currStatus = chartStatus[this.chartID];

                //            if (delta === 0 || delta + this.SLXP - masterMargin.l < 0 || delta + this.SRXP + MCHW / 2 > width - 1) {
                //                if (this.SLXP + delta - masterMargin.l > -1 && this.SLXP + delta - masterMargin.l < 0) {
                //                    delta -= this.SLXP + delta - masterMargin.l; // adjust to get zero position sigh margin
                //                } else if (delta + this.SRXP + MCHW / 2 < width  && delta + this.SRXP + MCHW / 2 > width - 1) {
                //                    delta -= this.SRXP + delta + MCHW / 2 - width + 1; // adjust to get last position
                //                } else {
                //                    return;
                //                }
                //            }

                //Now calculate if we scroll left or right and based on that update local scroller config
                // add delta to left and right positions
                this.SLXP += delta;
                this.SRXP += delta;

                this.SLXP = Math.round(this.SLXP);
                this.SRXP = Math.round(this.SRXP);

                this.makeSureMasterSliderNotBeyondTheMargin(true);
                this.setMasterSliderLayout();

                this.calculateRnsRneFromSXP();

                //            var rng = currStatus.rne - currStatus.rns;
                //
                //            if (this.SRXP + MCHW / 2 === width) {
                //                currStatus.rne = m.series[0].rv.length;
                //                currStatus.rns = currStatus.rne - rng;
                //            } else if (this.SLXP === MCHW / 2) {
                //                currStatus.rns = 0;
                //                currStatus.rne = rng;
                //            } else {
                //                currStatus.rns = Math.round((this.SLXP - masterMargin.l) / me.MRTX);
                //                if (rng === 1) {
                //                    currStatus.rns += 1;
                //                }
                //                currStatus.rne = currStatus.rns + rng;
                //            }

                //            this.updateRnsRne();
                localUpdateScrollerConfig.call(me);
                /*  if (m.currentRatio < rangeToSeriesMaxRatio) {
                 localUpdateScrollerConfig.call(me);
                 } else {
                 if (((currStatus.rns - me.ACrns) < rng && me.ACrns > 0) || ((me.ACrne - currStatus.rne) < rng && me.ACrne < this.windowSize)) {
                 me.incFetchChart();
                 } else {
                 localUpdateScrollerConfig.call(me);
                 }
                 }*/
                if (!currStatus.usingCustomInterval && this.currSelection) {
                    this.updateIntervalPosition();
                }
            },

            updateIntervalPosition: function updateIntervalPosition() {
                var me = this,
                    m = me.model,
                    currStatus = chartStatus[this.chartID];
                //update timeSelectedIntervalPosition
                if(me.currSelection){
                    var index = me.currSelection.getAttribute("value");
                    currStatus.timeSelectedIntervalPosition[index] = {rns: currStatus.rns, rne: currStatus.rne};
                }

            },

            drawSliderTooltipPointer: function drawSliderTooltipPointer() {
                var canvas = this.sliderTooltip.lastChild,
                    cntx = canvas.getContext('2d'),
                    width = canvas.width,
                    height = canvas.height;
                cntx.fillStyle = '#ffffff';
                cntx.beginPath();
                cntx.moveTo(0, 0);
                cntx.lineTo(width, 0);
                cntx.lineTo(width / 2, height);
                cntx.lineTo(0, 0);
                cntx.closePath();
                cntx.fill();

            },

            renderSliderTooltip: function renderSliderTooltip(sliderTooltipXPosition) {
                var me = this,
                    stt = me.sliderTooltip,
                    sttF = stt.firstChild,
                    sttP = stt.lastChild,
                    width = me.getWidth();

                var pointerPos = sliderTooltipXPosition;

                var content = getFormattedDateForSliderTooltip.call(this, sliderTooltipXPosition);
                if (content == "") {
                    content = "--";
                }

                sttF.innerHTML = content;

                var stWidth = sttF.offsetWidth,
                    stHalfWidth = stWidth / 2;

                if (sliderTooltipXPosition !== this.SLXP) {
                    //right handler
                    sliderTooltipXPosition = this.SRXP - stHalfWidth;
                } else {
                    //left handler
                    sliderTooltipXPosition -= stHalfWidth;
                }

                //make sure tooltip within the widget
                if (sliderTooltipXPosition < 0) {
                    sliderTooltipXPosition = 0;
                } else if (sliderTooltipXPosition + stWidth > width) {
                    sliderTooltipXPosition = width - stWidth;
                }

                //position the pointer offset to the Tooltip
                sttP.style.left = (pointerPos - sliderTooltipXPosition - 3) + 'px';
                //position the tooltip
                me.utils.translateCSS(sliderTooltipXPosition, me.sliderTooltipYPosition, false, stt);
            },

            resizeMasterSlider: function resizeMasterSlider(x /*current mouse position*/) {
                var me = this,
                    width = me.getWidth(),
                    msl = me.masterSlider,
                    msls = msl.style,
                // left cover span
                    lcs = msl.parentNode.firstChild.style,
                // right cover span
                    rcs = msl.parentNode.childNodes[2].style;

                var touchPoint = me.utils.getTouchXYOnWidget(x, 0, me);
                x = touchPoint.touchX;
                var fixWhich;
                if (masterSliderClicked === 'L') {
                    this.SLXP = x;
                    fixWhich = "R";
                } else {
                    this.SRXP = x;
                    fixWhich = "L";
                }

                me.makeSureMasterSliderNotBeyondTheMargin();
                me.makeSureMasterSliderNoOverlap(fixWhich);
                this.setMasterSliderLayout();

                if (masterSliderClicked === 'L') {
                    me.renderSliderTooltip(this.SLXP);
                } else {
                    me.renderSliderTooltip(this.SRXP);
                }

                chartStatus[this.chartID].usingCustomInterval = true;
                chartSizeChanged = true;
            },

            shouldTouchBubble: function shouldTouchBubble(touch) {
                // We will handle all touch with no bubbling.
                return false;
            },

            hiddenTooltipAndShowTimeSelector: function hsctooltip() {
                if (tooltipShown) {	//tooltip will be dismissed when the user taps on the empty space
                    /*
                     * hide highlight point and tooltip
                     * inherit from VisChart
                     */
                    this.handleTouchEnd();
                    tooltipShown = false;
                    this.showTimeSelectorLabels();

                    var touchManager = mstrmojo.touchManager;
                    touchManager.detachEventListener(this._touchListener);
                    delete this._touchListener;
                }
            },

            /*
             * onCrossWidgetMultitouch will be called when cross widget multitouch
             */
            onCrossWidgetMultitouch: function onCrossWidgetMultitouch() {
                this.hiddenTooltipAndShowTimeSelector();
            },

            touchBegin: function touchBegin(touch) {
                // check if we have touched on clickable element if yes call handle on  click ignore otherwise
                this.adjustWidgetOffsets();
                var item = this.isMasterSliderTouched(touch);
                if (item) {
                    this.hiddenTooltipAndShowTimeSelector();
                    var value = item.value;
                    if (value === 'L' || value === 'R' || value === 'MS') {
                        // touched the strechable div in master
                        masterSliderClicked = item.value;
                        originalTouchPosition = touch.pageX; // record the touch position so that the move can be computed
                        if (item.value !== 'MS') {
                            //show tooltip here with date only on top of left or right slider bar
                            this.showMasterSliderTooltip(item);
                        }

                    } else {
                        return false;
                    }
                    // Was a scrollable element NOT clicked?
                } else if (!isScrollableElementTouched.call(this, touch)) {
                    this.hiddenTooltipAndShowTimeSelector();
                    if (this.shouldTouchBubble(touch)) {
                        // Bubble the touch event because we won't handle it.
                        return this.bubbleTouchEvent(touch);
                    }
                    return false;
                }
            },

            isMasterSliderTouched: function isMasterSliderTouched(touch) {
                var item = getTouchedElement.call(this, touch);
                if (item && (item.value === 'L' || item.value === 'R')) {
                    return item;
                }

                //enlarge the master slider range for the XHDPI device
                var touchRadius = 45 * this.utils.getScreenZoomFactor();
                var position = this.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, this);
                var touchX = position.touchX,
                    touchY = position.touchY;

                // y position on master chart
                var height = this.getHeight();
                if (touchY > height || touchY < height - this.masterChartHeight) {
                    return null;
                }

                if (touchX < this.SRXP && touchX > this.SLXP) {
                    return {node: this.masterSlider.childNodes[1], value: "MS"};
                }

                var LDistance = Math.abs(touchX - this.SLXP);
                var RDistance = Math.abs(this.SRXP - touchX);
                var minDistance = Math.min(LDistance, RDistance);

                if (minDistance < touchRadius) {
                    if (LDistance == minDistance) {
                        return {node: this.masterSlider.firstChild, value: "L"};
                    } else if (RDistance == minDistance) {
                        return {node: this.masterSlider.lastChild, value: "R"};
                    }
                } else {
                    return null;
                }

                return null;
            },

            touchSelectBegin: function touchSelectBegin(touch) {

                this.hiddenTooltipAndShowTimeSelector();
                var item = this.isMasterSliderTouched(touch);
                if (item) {
                    if (item.value === 'L' || item.value === 'R' || item.value === 'MS') {
                        //touched the strechable div in master
                        masterSliderClicked = item.value;
                        originalTouchPosition = touch.pageX; // record the touch position so that the mouse move can be computed
                    }
                } else {
                    //show highlight point and tooltip
                    this.handleTouchBegin(touch.pageX, touch.pageY);
                }
            },

            touchSelectMove: function touchSelectMove(touch) {
                if (masterSliderClicked) {
                    if (masterSliderClicked === 'MS') {
                        //if click was made inside the master scroller div than move the master scroller and orig chart accordingly
                        this.moveMasterSlider(touch.pageX);
                    } else {
                        this.resizeMasterSlider(touch.pageX);
                    }
                    originalTouchPosition = touch.pageX; // new original touch position after move occurred
                    return false;
                }
                //show highlight point and tooltip
                this.handleTouchMove(touch.pageX, touch.pageY);
            },

            handleTouchSelectEnd: function handleTouchSelectEnd(touch) {
                if (masterSliderClicked) {
                    if (masterSliderClicked === 'MS') {
                        this.makeSureSliderOnPoint();
                        this.setMasterSliderLayout();
                        this.incFetchChart();
                    } else {
                        resizeMasterSliderDone.call(this);
                    }
                    return false;
                }
                /*
                 * the tooltip and highlight will remain if there are selection or link drilling on the data point
                 */
                var canBeSelected = false;
                if (touch) {
                    var nearestPoint = this.getLastHighlightPoint();
                    canBeSelected = nearestPoint && this.pointCanBeSelected(nearestPoint.rowIdx, nearestPoint.serieIdx);
                }
                if (!canBeSelected) {
                    /*
                     * hide highlight point and tooltip
                     * inherit from VisChart
                     */
                    this.handleTouchEnd();

                    if (tooltipShown) {
                        tooltipShown = false;
                        this.showTimeSelectorLabels();
                    }
                } else {
                    this.seriesIndex = -1;
                }

                this.hiddenLegendTooltip();
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                this.handleTouchSelectEnd(touch);
            },

            touchMultiBegin: function touchMultiBegin(touch) {
                this.handleTouchSelectEnd();
            },

            touchSwipeMove: function touchSwipeMove(touch) {
                //First check if scrollable element is selected if yes call the super to scroll
                if (isScrollableElementTouched.call(this, touch) && this._super) {
                    this._super(touch);
                } else {
                    if (masterSliderClicked) {
                        if (masterSliderClicked === 'MS') {
                            //if click was made inside the master scroller div than move the master scroller and orig chart accordingly
                            this.moveMasterSlider(touch.pageX);
                        } else {
                            this.resizeMasterSlider(touch.pageX);
                        }
                        originalTouchPosition = touch.pageX; // new original touch position after move occurred
                    }
                }
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                if (masterSliderClicked) {
                    if (masterSliderClicked === 'MS') {
                        this.makeSureSliderOnPoint();
                        this.setMasterSliderLayout();
                        this.incFetchChart();
                    } else {
                        resizeMasterSliderDone.call(this);
                    }
                    return false;
                } else if (this._super) {
                    this._super(touch);
                }
            },

            touchSelectCancel: function touchSelectCancel(touch) {
                this.touchCancel(touch);
            },

            touchCancel: function touchCancel(touch) {
                this.touchSelectEnd(touch);
            },

            touchEnd: function touchEnd(touch) {
                if (masterSliderClicked && !chartSizeChanged) {
                    hideMasterSliderTooltip.call(this);
                    masterSliderClicked = null;
                }
                this._legend.hiddenSwitcherArrowGlowEffect();
                return false;
            },

            pointCanBeSelected: function pcbs(rowIdx, serieIdx) {
                if (this.selectionOrLinkdrillOnRow) {
                    return true;
                }

                var me = this,
                    m = me.model,
                    colHeaders = m.colHeaders,
                    colHL = colHeaders.length,
                    hi = m.series[serieIdx].hi,
                    hiLength = hi.length;

                for (var i = 0; i < colHL; i++) {
                    var colH = colHeaders[i];
                    if (colH.es) {
                        //col attributes
                        if (colH.sc && colH.sc.tks) {
                            return true;
                        }
                        if (colH.lm && colH.lm[0] && colH.lm[0].links) {
                            return true;
                        }
                    } else {
                        //metric
                        if (colH.sc && colH.sc.tks) {
                            return true;
                        }
                        var lmArray = colH.lm,
                            lm = lmArray && lmArray[hi[i]];
                        if (lm && lm.links) {
                            return true;
                        }

                    }
                }

                return false;
            },

            getModelK: function getModelK() {
                var k = this.baseModel && this.baseModel.k;

                return k;
            },

            /*
             * For the time series drilling, if more than one attribute has a link drilling property defined, we will follow the priority as:
             * 	The right most link drilling defined category attribute; if not,
             * 	The bottom most link drilling defined colHeader attribute; if not,
             * 	The metric cell that represents the tapped data point
             *
             */
            getActionObjList: function getActionObjList(nearestPoint, selectedAll) {
                var actionObjList = [];

                var scObjList = [];
                var actionType = 0;
                var actionObjList = [];
                var linkDrillNode = null;
                var metricColHIdx = -1;

                var me = this,
                    model = me.model,
                    riArray = model.ri,
                    ri = riArray[nearestPoint.rowIdx],
                    rowHeaders = model.rowHeaders,
                    rowHL = rowHeaders.length;
                for (var i = 0; i < rowHL; i++) {
                    var rowH = rowHeaders[i];
                    if (rowH.sc && rowH.sc.tks) {
                        if (selectedAll && (rowH.sc.all === "false" || rowH.sc.all === false)) {
                            // unselect is true and can't select all, then do nothing
                            return null;
                        }
                        var scObj = {};
                        scObj.sc = rowH.sc;
                        scObj.es = rowH.es[ri[i]];
                        scObj.eid = selectedAll ? "OA:(All)" : rowH.eid[ri[i]];
                        scObjList.push(scObj);
                        actionType = rowH.at || 0;
                    }
                    if (rowH.lm && rowH.lm[0] && rowH.lm[0].links && !linkDrillNode) {
                        // find the right most link drilling on rowHeaders
                        linkDrillNode = {};
                        linkDrillNode.titleInfo = rowH;
                        linkDrillNode._e = {id: rowH.eid[ri[i]], n: rowH.es[ri[i]]};
                    }
                }

                var colHeaders = model.colHeaders,
                    colHL = colHeaders.length,
                    hi = model.series[nearestPoint.serieIdx].hi,
                    hiLength = hi.length;

                for (var i = colHL - 1; i >= 0; i--) {
                    var colH = colHeaders[i];
                    if (colH.es) { //col attributes
                        if (colH.sc && colH.sc.tks) {
                            if (selectedAll && (colH.sc.all === "false" || colH.sc.all === false)) {
                                // unselect is true and can't select all, then do nothing
                                return null;
                            }
                            var scObj = {};
                            scObj.sc = colH.sc;
                            scObj.es = colH.es[hi[i]];
                            scObj.eid = selectedAll ? "OA:(All)" : colH.eid[hi[i]];
                            scObjList.push(scObj);
                            actionType = colH.at || 0;
                        }
                        if (colH.lm && colH.lm[0] && colH.lm[0].links && !linkDrillNode) {
                            //find the lowest link drill on colHeaders
                            linkDrillNode = {};
                            linkDrillNode.titleInfo = colH;
                            linkDrillNode._e = {id: colH.eid[hi[i]], n: colH.es[hi[i]]};
                        }
                    } else {
                        if (colH.sc && colH.sc.tks) {
                            //metric selector
                            if (selectedAll && (colH.sc.all === "false" || colH.sc.all === false)) {
                                // unselect is true and can't select all, then do nothing
                                return null;
                            }
                            var scObj = {};
                            scObj.sc = colH.sc;
                            scObj.es = colH.items[hi[i]].n;
                            scObj.eid = selectedAll ? "OA:(All)" : colH.items[hi[i]].id;
                            scObjList.push(scObj);
                            actionType = colH.at || 0;
                        }
                        //metric link drill
                        metricColHIdx = i;
                    }
                }
                if (scObjList.length > 0) {
                    actionType = actionType | SELECTOR_ACTION;

                    //infoWindowAnchor width and height is 18px, so left and top should - 9
                    this.infoWindowAnchor.style.left = (nearestPoint.point.x - 9) + 'px';
                    this.infoWindowAnchor.style.top = (nearestPoint.point.y - 9) + 'px';

                    //node use as info window anchor

                    actionObjList.push({at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: this.infoWindowAnchor});
                    return actionObjList;
                }

                //no selection trigger, do link drilling
                if (!linkDrillNode) {
                    //find link drill on metric
                    var metricH = colHeaders[metricColHIdx],
                        metric = metricH.items[hi[metricColHIdx]],
                        lm = metricH.lm[hi[metricColHIdx]];
                    if (lm && lm.links) {
                        linkDrillNode = {};
                        linkDrillNode.titleInfo = metricH;
                        linkDrillNode.mix = hi[metricColHIdx];
                        //build node parent
                        var currNode = linkDrillNode;
                        for (var i = 0; i < rowHL; i++) {
                            var rowH = rowHeaders[i];
                            var nodeLP = {};
                            nodeLP.titleInfo = rowH;
                            nodeLP._e = {id: rowH.eid[ri[i]], n: rowH.es[ri[i]]};

                            currNode._lp = nodeLP;
                            currNode.axis = ROW_AXIS;
                            currNode = nodeLP;
                        }

                        currNode = linkDrillNode;
                        for (var i = colHL - 1; i >= 0; i--) {
                            var colH = colHeaders[i];
                            if (colH.es) { //col attributes
                                var nodeTP = {};
                                nodeTP.titleInfo = colH;
                                nodeTP._e = {id: colH.eid[hi[i]], n: colH.es[hi[i]]};

                                currNode._tp = nodeTP;
                                currNode.axis = COL_AXIS;
                                currNode = nodeTP;
                            }
                        }
                    }
                }
                if (linkDrillNode) {
                    actionType = actionType | HYPERLINK_ACTION;

                    actionObjList.push({at: actionType, k: this.getModelK(), node: linkDrillNode});
                    return actionObjList;
                }
                return null;
            },

            getLastHighlightPoint: function gtLstHighlightPnt() {
                // highlight point is the point showing the tooltip
                return this.lastHighlightPoint || null;
            },

            performAction: function performAction(actionObjList) {
                this.hasNonifwTarget = this.hasNoninfowindowTarget(actionObjList[0]);

                if (this._super) {
                    this._super(actionObjList);
                }

            },

            touchTap: function touchTap(touch) {
                var me = this,
                    nearestPoint = this.getLastHighlightPoint(),
                    touchPointOnWidget = me.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, me);
                var touchPointInHighlightArea = tooltipShown && getPointDistanceSquare({x: nearestPoint.point.x, y: nearestPoint.point.y}, {x: touchPointOnWidget.touchX, y: touchPointOnWidget.touchY}) <= 45 * 45;

                if (touchPointInHighlightArea) {
                    /*
                     *If a tooltip is being displayed and an action is associated with the datapoint
                     *then tapping within a 45x45 area around the datapoint will result in the action being triggered
                     */
                    me.hiddenTooltipAndShowTimeSelector();
                    nearestPoint = this.getLastHighlightPoint();
                } else {
                    nearestPoint = this.getNearestPoint(touch.pageX, touch.pageY);
                }
                if (isScrollableElementTouched.call(this, touch)) {
                    var fallInPointArea = getPointDistanceSquare({x: nearestPoint.point.x, y: nearestPoint.point.y}, {x: touchPointOnWidget.touchX, y: touchPointOnWidget.touchY}) <= 45 * 45,
                        canBeSelected = me.pointCanBeSelected(nearestPoint.rowIdx, nearestPoint.serieIdx),
                        sameAsLastSelectedPoint = me.lastSelectedPoint && (nearestPoint.rowIdx == me.lastSelectedPoint.rowIdx && nearestPoint.serieIdx == me.lastSelectedPoint.serieIdx );
                    if (fallInPointArea && canBeSelected && !sameAsLastSelectedPoint) {
                        if (tooltipShown) {
                            me.hiddenTooltipAndShowTimeSelector();
                        }
                        me.lastSelectedPoint = nearestPoint;
                        me.incFetchChart(true);

                        var actionObjList = this.getActionObjList(nearestPoint);

                        me.performAction(actionObjList);

                    }
                    else if (fallInPointArea && !canBeSelected) {
                        /*
                         * PM required:This is true for all mobile Visualizations (phone and tablet):
                         * if the visualization is "not" configured as a selector / link-drill / info-window,
                         * then tapping on a data element should result in the tooltip being displayed.
                         */
                        if (touchPointInHighlightArea) {
                            /*
                             * if the widget is "not" configured as a selector, then tapping on an element that is currently displaying a tooltip
                             * will dismiss the tooltip and its associated highlight
                             * We do nothing here as we have already dismiss the tooltip
                             */
                        } else {
                            this.handleTouchBegin(touch.pageX, touch.pageY);
                        }

                    } else {
                        /*
                         * tapped on empty space:
                         * if a tooltip is being displayed, tapping once on the empty space will dismiss the tooltip but not the highlight (assuming the datapoint has been selected).
                         * With the tooltip dismissed, if the user taps again on the empty space, the clear all command should be triggered
                         * PM requried: tapped on empty space changed to:
                         * should dismiss any tooltip, highlight or selection
                         */
                        if (tooltipShown) {
                            me.hiddenTooltipAndShowTimeSelector();
                        }
                        else if (me.lastSelectedPoint) {
                            /*
                             * if a selector action has been triggered from the visualization
                             * tapping on the empty space will clear the selection and remove the highlight
                             */

                            var actionObjList = this.getActionObjList(nearestPoint, true);
                            /*
                             * if there is attr sc can't select all, actionObj is null
                             */
                            if (actionObjList) {
                                me.performAction(actionObjList);
                                me.lastSelectedPoint = null;
                                me.incFetchChart(true);
                            }
                        }
                    }

                }

            },

            /*
             * draw the highlight for selected Point
             * For LIGHT_THEME,
             */
            highlightSelectedPoint: function highlightSelectedPoint() {

                //local vars
                var me = this,
                    ctx = me.animationContext,
                    utils = me.utils,
                    pointInfo = me.lastSelectedPoint,
                    point = pointInfo.point,
                    currStatus = chartStatus[this.chartID];

                ctx.save();

                if (currStatus.isLegendSelected && currStatus.legendSelectedIndex != pointInfo.serieIdx) {
                    ctx.globalAlpha = 0.3;
                } else {
                    ctx.globalAlpha = 1;
                }
                //recalculate the x coodination, as the point.x is the position when it is selected
                var pointX = (pointInfo.rowIdx - me.ACrns) * me.RTX;
                //            if(currStatus.isLegendSelected && currStatus.legendSelectedIndex == pointInfo.serieIdx){
                //            	ctx.fillStyle = me.highlightColor;
                //            	/*
                //            	 * change to 6 as there are a few background pixels are appearing between the dot and the stroke applied around it
                //            	 */
                //	            utils.drawArc(me, pointX, point.y, 6, 0, Math.PI * 2, true, true, ctx);
                //	            // set colors
                //	            ctx.strokeStyle = me.getSerieColor(pointInfo.serieIdx);
                //	            ctx.lineWidth = 4;
                //	            utils.drawArc(me, pointX, point.y, 7, 0, Math.PI * 2, true, false, ctx);
                //            }else{
                ctx.fillStyle = me.getSerieColor(pointInfo.serieIdx);
                ctx.lineWidth = 1;
                utils.drawArc(me, pointX, point.y, 4, 0, Math.PI * 2, true, true, ctx);

                if (this.theme == LIGHT_THEME) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    utils.drawArc(me, pointX, point.y, 5, 0, Math.PI * 2, true, false, ctx);
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    utils.drawArc(me, pointX, point.y, 7, 0, Math.PI * 2, true, false, ctx);
                } else {
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2;
                    utils.drawArc(me, pointX, point.y, 5, 0, Math.PI * 2, true, false, ctx);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    utils.drawArc(me, pointX, point.y, 7, 0, Math.PI * 2, true, false, ctx);
                }
                //	            ctx.fillStyle = me.getSerieColor(pointInfo.serieIdx);
                //	            utils.drawArc(me, pointX, point.y, 6, 0, Math.PI * 2, true, true, ctx);
                //	            // set colors
                //	            ctx.strokeStyle = me.highlightColor;
                //	            ctx.lineWidth = 4;
                //	            utils.drawArc(me, pointX, point.y, 7, 0, Math.PI * 2, true, false, ctx);
                //            }
                ctx.restore();
            },

            destroy: function destroy() {
                //As currSelection has reference to the Dom node, we have to delete it to prevent mem leak
                if (this.currSelection) {
                    delete this.currSelection;
                }

                // Do we have a touch listener?
                if (this._touchListener) {
                    // Detach event listener and delete listener handle.
                    mstrmojo.touchManager.detachEventListener(this._touchListener);
                    delete this._touchListener;
                }
                // Detach scrolling event listeners
                 if(this._scrollDoneListener){
                    this._scroller.detachEventListener(this._scrollDoneListener);
                    delete this._scrollDoneListener;
                 }
                 if(this._scrollMovedListener){
                    this._scroller.detachEventListener(this._scrollMovedListener);
                    delete this._scrollMovedListener;
                 }

                 if(this._infoWClosedListener){
                    this.xtabModel.docModel.detachEventListener(this._infoWClosedListener);
                    delete this._infoWClosedListener;
                 }



                if (this.fullScreenListener) {
                    mstrmojo.touchManager.detachEventListener(this.fullScreenListener);
                    delete this.fullScreenListener;
                }

                if (this.selectorTargets) {
                    delete this.selectorTargets;
                }

                this._super();

                if (this._tn) {
                    delete this._tn;
                }
            }


        });

})();
/**
 * AndroidDocMap.js
 * Copyright 2012 MicroStrategy Incorporated. All rights reserved.
 * @version 1.0
 * @fileoverview <p>Android wrapper flavour of Map contained in reprots.</p>
 * @author <a href="mailto:bgan@microstrategy.com">Doug Hill</a>
 */

(function () {
    mstrmojo.requiresCls("mstrmojo.maps.jsmap.AndroidRptMap",
                         "mstrmojo.maps.androidmap.AndroidRptMap",
                         "mstrmojo.Obj");

    mstrmojo.maps.AndroidRptMap =  mstrmojo.declare(
            mstrmojo.Obj ,

            null,

            {
            	scriptClass: 'mstrmojo.maps.AndroidRptMap'
            }
    );
    
    if ((typeof(mstrMobileApp) != 'undefined') && (typeof(mstrMobileApp.useNativeMap) != 'undefined') && mstrMobileApp.useNativeMap()) {
		mstrmojo.maps.AndroidRptMap = mstrmojo.maps.androidmap.AndroidRptMap;
	} else {
		mstrmojo.maps.AndroidRptMap = mstrmojo.maps.jsmap.AndroidRptMap;
	}
})();
/**
 * AndroidDocMap.js
 * Copyright 2012 MicroStrategy Incorporated. All rights reserved.
 * @version 1.0
 * @fileoverview <p>Android wrapper flavour of Map contained in RW documents.</p>
 * @author <a href="mailto:bgan@microstrategy.com">Doug Hill</a>
 */

(function () {
    mstrmojo.requiresCls("mstrmojo.maps.jsmap.AndroidDocMap",
                         "mstrmojo.maps.androidmap.AndroidDocMap");
    mstrmojo.maps.AndroidDocMap =  mstrmojo.declare(
            mstrmojo.Obj ,

            null,

            {
            	scriptClass: 'mstrmojo.maps.AndroidDocMap'
            }
    );
    if ((typeof(mstrMobileApp) != 'undefined') && (typeof(mstrMobileApp.useNativeMap) != 'undefined') && mstrMobileApp.useNativeMap()) {
		mstrmojo.maps.AndroidDocMap = mstrmojo.maps.androidmap.AndroidDocMap;
	} else {
		mstrmojo.maps.AndroidDocMap = mstrmojo.maps.jsmap.AndroidDocMap;
	}
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.AndroidXtab",
                         "mstrmojo._IsInteractiveGrid",
                         "mstrmojo._Formattable",
                         "mstrmojo._IsDocXtab");

    /**
     * Standalone class that displays an interactive grid on documents.
     *
     * @class
     * @extends mstrmojo.AndroidXtab
     * @borrows mstrmojo._IsInteractiveGrid
     * @borrows mstrmojo._Formattable
     * @borrows mstrmojo._IsDocXtab
     *
     */
    mstrmojo.DocInteractiveGridXtab = mstrmojo.declare(

        mstrmojo.AndroidXtab,


        [ mstrmojo._IsInteractiveGrid, mstrmojo._Formattable, mstrmojo._IsDocXtab ],

        /**
         * @lends mstrmojo.DocInteractiveGridXtab.prototype
         */
        {
            scriptClass: 'mstrmojo.DocInteractiveGridXtab',

            /**
             * Override the format handlers as we don't care about the background color on the viewport slot.
             *
             * @see mstrmojo._Formattable
             */
            formatHandlers: {
                domNode: [ 'RW', 'T', 'font'],
                msgNode: [ 'D' ],
                viewport: [ 'D', 'B', 'fx' ]
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.AndroidXtab",
                        "mstrmojo._IsInteractiveGrid");

    /**
     * A report based interactive grid visualization for the Android platform.
     *
     * @class
     * @extends mstrmojo.MobileXtab
     * @borrows mstrmojo._IsInteractiveGrid
     */
    mstrmojo.AndroidInteractiveGridXtab = mstrmojo.declare(

        mstrmojo.AndroidXtab,

        [ mstrmojo._IsInteractiveGrid ],

        /**
         * @lends mstrmojo.AndroidInteractiveGridXtab.prototype
         */
        {
            scriptClass: 'mstrmojo.AndroidInteractiveGridXtab'            
        }
    );
}());
/**
 * iPhoneXtabController.js Copyright 2010 MicroStrategy Incorporated. All rights reserved.
 * 
 * @version 1.0
 */

(function() {
    
    var USE_DEFAULT_ANSWER = 8;    

    /**
     * Submits as data request to the app.
     * 
     * @param {Any[]} args An array of arguments to be passed to the method.
     * 
     * @private
     */
    function submitDataRequest (params) {
        mstrApp.serverRequest(params);
    }

    function _cleanup() {
        var a = mstrmojo.all;

        for(var i in a) {
            /*if(a[i].id == 'iToolbar') {
            a[i].set('visible', false);
                if(a[i].isOpen) {
                    a[i].hideToolbar();
                }
                continue;
            }*/
            mstrmojo.registry.remove(a[i]);
        }
    }    

    var xmlencode = function(string) {
        return string.replace(/\&/g,'&'+'amp;').replace(/</g,'&'+'lt;').replace(/>/g,'&'+'gt;').replace(/\'/g,'&'+'apos;').replace(/\"/g,'&'+'quot;');
    };    
    
    var curXtabId = 'iRoot';
    
    var xtabProxy = {
            
        data: null,
        controller: null,
                        
        adjustSize: function() {
            var xt = mstrmojo.all[curXtabId];

            // trigger the FillsBrowswer handler on orientation changed.
            xt && xt._monitorWindow();
        },

        getRWInfo: function() {
            var rw = mstrmojo.all[curXtabId].gridData.rw;
            return '<ifd tr="' + rw.tr + '" wmr="' + rw.wmr + '" tc="' + rw.tc + '" wmc="' + rw.wmc  + '" wsr="' + rw.wsr + '" wsc="' + rw.wsc + '"/>';
        },

        // TODO rename this to getReportInfo
        getPBInfo: function() {
            var str = '',
                gd = mstrmojo.all[curXtabId].gridData,
                phs = gd.ghs.phs,
                ci = gd.ci,
                n = gd.n || "";

            if (phs || ci || n) {
                // switch from <info> to <report_info n="xxx"> once we can determine name
                str = '<report_info n="' + xmlencode(n) + '">';
                if (ci) {
                    str += '<ci cid="' + ci.cid + '" tp="' + ci.tp + '" utm="' + ci.utm + '"/>';
                }
                if (phs) {
                    str += '<pbe>';
                    //<pbe><pb ei="BB:8D679D4B11D3E4981000E787EC6DE8A4:1:2:0:2:1:3:1:Northeast"/><pb ei="BB:8D679D3511D3E4981000E787EC6DE8A4:1:2:0:2:1:3:11:Boston"/></pbe>
                    var cets = phs.cets;
                    for (var i in cets) {
                        str += '<pb ei="' + xmlencode(cets[i].eid) + '"/>';
                    }
                    str += '</pbe>';
                }
                str += '</report_info>';
            }
            return str;
        },

        hasPageBy: function() {
            var phs = mstrmojo.all[curXtabId].gridData.ghs.phs;
            if (phs && phs.cets) {
                return "1";
            }
            return "0";
        },

        /*dataDownloaded: function(jsonStr) {
            var xtab = mstrmojo.all[curXtabId],
                json = eval(jsonStr);

            if(json.eg) {
                return json.eg;
            }
            if(xtab && xtab.dataDownloaded) {
                xtab.dataDownloaded(
                    {
                        data: json
                    }
                );
            }
            return ;
        },*/
        
        render: function(cacheMap) {
            
            var imgCacheMap = cacheMap,
                xTabId = curXtabId,
                json = this.data;

            //get the rendered xtab as the transition curtain
            //var curtain = mstrmojo.all[curXtabId] && mstrmojo.all[curXtabId].domNode;
            _cleanup();

            if(json && json.eg) {
                return json.eg;
            }

            var xtab = new mstrmojo.iXtab({
                id: xTabId,
                placeholder: curXtabId,
                formatResolver:{
                    getFormat:function(/* JSON */ defn) {
                        return defn.fmts;
                    }
                },
                
                defn : new mstrmojo.Model ({
                        fmts:{
                            top: "0",
                            left:"0",
                            // todo0 - use one value for later.
                            scrollarea: {
                             y: 459,
                             x: 319
                            }
                        }
                    }),
                imgCacheMap: imgCacheMap,
                controller: this.controller
            }); 
            
            xtab.model = new mstrmojo.XtabModel({controller: this.controller});
            xtab.update({'data': json});
            xtab.render();
                
            return ;
        },
        
        destroy: function() {
            //we do not need transition curtain for rendering a new xtab
            var w = mstrmojo.all[curXtabId];
            if(w) {
                var d = w.domNode,
                    c = d.lastChild,
                    length = d.childNodes.length,
                    i = 0;

                for (i = 0; i < length; i++) {
                    //if we have some xtab already rendered, we should clean the dom so that it will not be used as a transition curtain.
                    //w.domNode.innerHTML = "";
                    window.setTimeout(function() {
                        d.removeChild(d.lastChild);
                    }, 0);
                }
            }
        }        
    };
    
    function getXtabProxy(controller, data) {
        xtabProxy.controller = controller;
        xtabProxy.data = data;
        return xtabProxy;
    }
    
    
    /**
     * Main Controller class for iPhone applications.
     * 
     * @class
     * @extends mstrmojo.XtabController
     * 
     * @borrows mstrmojo._FillsBrowser
     */
    mstrmojo.iPhoneXtabController = mstrmojo.declare(
        null,
        null,
        /**
         * @lends mstrmojo.iPhoneXtabController.prototype
         */
        {
            scriptClass: "mstrmojo.iPhoneXtabController",
            
            /**
             * Initializer.
             * 
             * @param {String} props.ttl A title of the controllers first view.
             * @param {String} props.did A report ID.
             * @param {int}    props.st A report subtype.
             */
            init: function init(){
            },
            
            setData: function(data) {
                this.data = data;
            },

            getProxy: function(data) {
                return getXtabProxy(this, data);
            },
            
            touchTap: function() {
                var params = {cmd: 'tap'};
                submitDataRequest(params);
            },
            
            swipe: function (params) {
                submitDataRequest(params);
            },
            
            sortGrid: function sortGrid(view, action) {
                var params = {cmd: 'sort', sortKey: action.sortKey, sortOrder: action.sortOrder, clearSort: 1, subtotalPos: action.subTotalsPos};                
                submitDataRequest(params);
            },
            
            pivotGrid: function pivotGrid(view, action) {
                var params = {cmd: 'pivot', pos: action.pos, axis: action.axis, objectType: action.objectType};
                submitDataRequest(params);
            },
            
            onDrill: function onDrill(view, action) {
                var elems = action.drillElements,
                    params = {
                        cmd: 'drl',
                        dk: action.drillPathKey
                    };

                if (elems) {
                  var arr = elems.split("A");
                  params.a = arr[0];
                  params.d = arr[1];
                  params.o = arr[2];
                }                
                submitDataRequest(params);
            },
                        
            onLink: function onLink(view, action) {
                // here we want to send another piece of information besides linkAnswer. We want to pass on
                // the overall answer mode - whether all the links are going to be answered using default answer.
                // this will be used the the native code to cache.
                if ( action.link) {
                    action.linkAnswers = link.toXml();
                    delete action.link;
                }

                // initialize with the the daMode attribute of the link definition.
                var params = mstrmojo.hash.copy(action, {cmd: 'lnk'});
                    linkInfo = action.linkInfo,
                    areAllAnswersDefault = (linkInfo.daMode == USE_DEFAULT_ANSWER);

                // if it has all (remaining) answers set for default answering, then we move on to check individual link answers.
                if(areAllAnswersDefault) {
                    var answers = linkInfo.ans;

                    if(answers) {
                        for (i = 0, cnt = answers.length; i < cnt; ++i){
                            // check the answer mode of each individual answer.Any one without default answers => value of false overall.
                            if(answers[i].m != USE_DEFAULT_ANSWER) {
                                areAllAnswersDefault = false;
                                break;
                            }
                        }
                    }
                }

                // add our computed value for areAllAnswersDefault
                params.areAllAnswersDefault = areAllAnswersDefault ? 1 : 0;
                
                var target = linkInfo.target;
                params.tty = target && target.t;
                
                delete params.linkInfo;
                delete params.linkTarget;
                delete params.srcMsgId;
                // time to submit the form.
                submitDataRequest(params);
           }            
            
        });
})();
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.MetricSlider",
                         "mstrmojo.MetricQualification",
                         "mstrmojo.SearchBoxSelector",
                         "mstrmojo.Label",
                         "mstrmojo.hash",
                         "mstrmojo.array");

    var $HASH = mstrmojo.hash,
        $ARR = mstrmojo.array,
        $FN = mstrmojo.emptyFn;

    var STYLES_PULLDOWN = 0,
        STYLES_SCROLLER = 1,
        STYLES_LIST = 2,
        STYLES_RADIO = 3,
        STYLES_CHECKBOX = 4,
        STYLES_BUTTON = 5,
        STYLES_LINK = 6,
        STYLES_METRIC_SLIDER = 7,
        STYLES_METRIC_QUAL = 8,
        STYLES_SEARCH_BOX = 9;

    var _ST_UC_ON_DS = 2;   //control sub type: CONDITION_SELECTOR_ON_DATASET

    var UNIT_CONDITION = 1,
		SUBTOTAL = 3;
    /**
     * Id for (ALL) element.
     *
     * @const
     * @private
     */
    var ALL_ID = 'u;'; // RWGroupByElements.ALL_ID

    /**
     * JavaScript widget class names for different slider types.
     *
     * @const
     * @private
     */
    var widgetMap = {};
    widgetMap[STYLES_METRIC_SLIDER] = 'MetricSlider';
    widgetMap[STYLES_METRIC_QUAL] = 'MetricQualification';
    widgetMap[STYLES_SEARCH_BOX] = 'SearchBoxSelector';

    /**
     * Updates the selector control with information pertinent to it's operation.
     *
     * @param {mstrmojo.Widget} selectorCtrl The selector control to be updated.
     * @param {Integer} style The style of control.
     * @param {Object} data The data node from the {@link mstrmojo.DocSelector}.
     * @param {Object} idx The selected indices.
     * @param {Object[]} elements The selector elements.
     *
     * @private
     */
    function updateSelectorControl(selectorCtrl, style, data, defn, idx, elements) {
        // Update selector info on control.
        switch (style) {
        case STYLES_PULLDOWN:
            // Update selector info on widget.
            selectorCtrl.idx = $HASH.any(idx, true);

            // TODO: Should we do this elsewhere?
            // Is the selector unset?
            var selectorUnset = (typeof (selectorCtrl.idx) === 'undefined' || selectorCtrl.idx < 0);
            if (selectorUnset) {
                // TQMS 449351: render a blank(dummy) option if the idx is not defined.
                if ($ARR.find(elements, 'v', '-1') < 0) {
                    elements = [{
                        v: '-1',
                        n: ''
                    }].concat(elements);
                }
                selectorCtrl.idx = '0';
            }

            selectorCtrl.unset = !!selectorUnset;
            selectorCtrl.options = elements;
            break;

        case STYLES_METRIC_QUAL:
        case STYLES_METRIC_SLIDER:
            // Refresh the metric selector with new data
            if (selectorCtrl.updateData) {
                selectorCtrl.updateData({
                    low: data.min,
                    high: data.max,
                    cnt: data.cnt,
                    nov: data.nov
                }, {
                    cs: data.cs,
                    f: data.f,
                    ft: data.ft,
                    qua : data.qt
                });
            }

            selectorCtrl.items = elements;
            selectorCtrl.selectedIndices = idx;
            break;

        case STYLES_SEARCH_BOX:

            if (elements && !defn.sos) {
                selectorCtrl.candidates = {
                    isComplete: true,
                    items: defn.srcid ? elements : []
                };
            }
            if (defn.srcid) {
                var ca = [],
                	ces = data.ces;
                if (ces && ces.constructor === Array) {
                	//TQMS 667969, UC SearchBox should not display total
                	if (defn['dfm'] == UNIT_CONDITION) {
                		for (var i = 0; i < ces.length; i++) {
                    		if (ces[i]['t'] != SUBTOTAL) {
                    			ca.push(ces[i]);
                    		}
                    	}
                	} else {
                		ca = ces.concat();
                	}
                }
                
                
              // Show items that don't exist in candidates as blank if not search on server
              if (! defn.sos) {
                  var $ARRAY = mstrmojo.array,
                      new_ca = [];
                  $ARRAY.forEach(ca, function(item){
                      if ($ARRAY.find(selectorCtrl.candidates.items, 'v', item.v) > -1) {
                          new_ca.push(item);
                      }
                  });
                  ca = new_ca;
              }
                
                selectorCtrl.items = ca;
            }
            break;

        default:
            selectorCtrl.items = elements;
            selectorCtrl.selectedIndices = idx;
            break;
        }
    }

    /**
     * <p>A factory for creating Report Services Document selector controls.</p>
     *
     * @class
     * @extends mstrmojo.Obj
     */
    mstrmojo.DocSelectorViewFactory = mstrmojo.declare(

        mstrmojo.Obj,

        null,

        /**
         * @lends mstrmojo.DocSelectorViewFactory.prototype
         */
        {
            scriptClass: 'mstrmojo.DocSelectorViewFactory',

            /**
             * Creates and initializes a pulldown style selector.
             *
             * @param {mstrmojo.DocSelector} selectorContainer The selector container to which the pulldown will be added.
             *
             * @returns mstrmojo.Widget
             */
            newPulldown: $FN,

            attachTargetListeners: $FN,

            getSelectorClass: function getSelectorClass(selectorStyle, isHoriz) {
                // Retrieve script class from widget map.
                var scriptClass = widgetMap[selectorStyle];

                // Is the script class an array?
                if (scriptClass.constructor === Array) {
                    // Orientation is a factor.
                    scriptClass = scriptClass[(isHoriz) ? 0 : 1];
                }

                return scriptClass;
            },

            isSelectorSupported: function isSelectorSupported() {
                // By default, all selectors are supported
                return true;
            },

            /**
             * <p>Creates, initializes and adds a panel selector to the selectorContainer.</p>
             *
             * @param {mstrmojo.DocSelector} selectorContainer The selector container to which the selector GUI will be added.
             */
            newSelector: function newSelector(selectorContainer) {
                var children = selectorContainer.children,
                    selectorCtrl = children && children[0],
                    selectorStyle = selectorContainer.style,
                    selectedIdx = selectorContainer.selIdx,
                    node = selectorContainer.node,
                    defn = node.defn,
                    data = node.data,
                    elements = data.elms,
                    elems;

                if (!this.isSelectorSupported(selectorContainer)) {
                    return null;
                }

                // Does this selector NOT already have a control?
                if (!selectorCtrl) {

                    // Does this selector still NOT have a control?
                    if (!selectorCtrl) {

                        var cekEvtListener = selectorContainer._cekEvtListener,
                            cekContextId = selectorContainer.id,
                            fnCEK;

                        // Do we already have a "CEK" event listener?
                        if (cekEvtListener) {
                            // Detach the old listener.
                            defn.detachEventListener(cekEvtListener);

                            // Remove listener handle.
                            delete selectorContainer._cekEvtListener;
                        }

                        // Is this a pulldown selector (different on every platform so there is no default implementation).
                        if (selectorStyle === STYLES_PULLDOWN) {
                            // Get control from application specific method.
                            selectorCtrl = this.newPulldown(selectorContainer);

                            // Create an event handler to update the selector control with "CEK" changes.
                            fnCEK = function (evt) {
                                // TQMS 484896: Get elements from control options in case the data changed after this control was created.
                                elems = this.options;

                                // TQMS 430786: make sure blank option selected if no option match current selection value.
                                if ($ARR.find(elems, 'v', evt.value) < 0) {
                                    if ($ARR.find(elems, 'v', '-1') < 0) {
                                        // add blank option, if does not exist
                                        elems.unshift({
                                            v: '-1',
                                            n: ''
                                        });
                                    }

                                    selectorCtrl.idx = '0';
                                    selectorCtrl.options = elems;
                                    selectorCtrl.unset = true;

                                    selectorContainer._inSyncPhase = true;
                                    selectorCtrl.refresh();
                                    selectorContainer._inSyncPhase = false;
                                } else {
                                    selectorCtrl.set('value', evt.value);

                                }
                            };

                            // Change context of fnCEK to selector control.
                            cekContextId = selectorCtrl.id;

                        } else {
                            // Get configuration for control.
                            var cfg = this.getSelectorCtrlConfig(selectorContainer, selectorStyle, defn, elements),
                                scriptClass = cfg.scriptClass;

                            // Does the configuration NOT have a scriptClass?
                            if (!scriptClass) {
                                // This selector is not supported so set selectorCtrl to a label.
                                selectorCtrl = new mstrmojo.Label({
                                    cssClass: 'unsupported',
                                    text: 'This selector is not supported.'
                                });

                            } else {
                                // Delete script class because it doesn't have the mstrmojo package in it so it will be invalid.
                                delete cfg.scriptClass;

                                // Walk mstrmojo package to find constructor.
                                var Clazz = $HASH.walk(scriptClass, mstrmojo);

                                // Instantiate widget.
                                selectorCtrl = new Clazz(cfg);

                                // Is this a slider style?
                                if (selectorStyle === STYLES_METRIC_SLIDER) {
                                    // Attach event listener to selector container to hear when the "include" value changes.
                                    selectorContainer.attachEventListener('includeChange', selectorCtrl.id, function (evt) {
                                        // Change local include value.
                                        this.set('include', evt.value);

                                        // Select range.
                                        this.selectRange();
                                    });
                                }

                                // Is this a slider or a metric qualification?
                                if (selectorStyle === STYLES_METRIC_SLIDER || selectorStyle === STYLES_METRIC_QUAL) {
                                    // Attach event listener to selector container to hear when the "qua" value changes.
                                    selectorContainer.attachEventListener('quaChange', selectorCtrl.id, function (evt) {
                                        // Change selector control "qua" value.
                                        this.set('qua', evt.value);
                                    });

                                    // Create an event handler to update the selector control with "CEK" changes.
                                    fnCEK = function (evt) {
                                        // TQMS 467964: update metric sliders/qualifications of other group by elements
                                        if (selectorContainer.id !== evt.value.id) {  // preventing refresh the changed selector itself
                                            selectorContainer._inSyncPhase = true;

                                            selectorCtrl.updateExpr(evt.value);

                                            if (selectorContainer.style === STYLES_METRIC_SLIDER) {
                                                selectorContainer.set('include', evt.value.include);
                                            }

                                            selectorContainer._inSyncPhase = false;
                                        }
                                    };

                                } else {

                                    // Create an event handler to update the selector control with "CEK" changes.
                                    fnCEK = function (evt) {
                                        var idxs = [];
                                        // TQMS 484896: Get elements from data node in case they change after this control was created.
                                        elems = this.node.data.elms;

                                        // Iterate selected values.
                                        $ARR.forEach(evt.value, function (v) {
                                            var idx = $ARR.find(elems, 'v', v);
                                            if (idx > -1) {
                                                idxs.push(idx);
                                            }
                                        });

                                        this._inSyncPhase = true;
                                        selectorCtrl.select(idxs);
                                        this._inSyncPhase = false;
                                    };
                                }
                            }
                        }

                        // Did we create an event handler for "CEK" change events?
                        if (fnCEK) {
                            // Attach event handler.
                            selectorContainer._cekEvtListener = defn.attachEventListener('cekChange', cekContextId, fnCEK);
                        }
                    }

                    // Add selector control as a child of the selectorContainer.
                    selectorContainer.addChildren(selectorCtrl);
                }

                // Update selector info on control (use style from selectorContainer in case it was changed).
                updateSelectorControl(selectorCtrl, selectorContainer.style, data, defn, selectedIdx, elements);

                return selectorCtrl;
            },

            /**
             * Returns a select control configuration to be used for instantiation.
             *
             * @param {mstrmojo.DocSelector} selectorContainer The DocSelector that will host this control.
             * @param {Integer} selectorStyle The style of control.
             * @param {Object} defn The defn node from the {@link mstrmojo.DocSelector}.
             * @param {Object[]} elements The selector elements.
             *
             * @returns Object
             * @private
             */
            getSelectorCtrlConfig: function getSelectorCtrlConfig(selectorContainer, selectorStyle, defn, elements) {
                // Get scriptClass and default configuration.
                var isHoriz = defn.horiz,
                    fmts = selectorContainer.getFormats(),
                    height = fmts && fmts.height,
                    copyProps = $HASH.copyProps,
                    data = selectorContainer.node.data,
                    cfg = {
                        scriptClass: this.getSelectorClass(selectorStyle, isHoriz),
                        multiSelect: defn.multi,
                        isHoriz: isHoriz,
                        include: defn.include,
                        itemWidthMode: defn.iwm,
                        allIdx: $ARR.find(elements, 'v', ALL_ID),
                        noneIdx: defn.include ? -1 : $ARR.find(elements, 'v', ALL_ID),
                        renderAllItems: !height,               // Turn off incremental rendering if we have a fit to content height.
                        onchange: function () {
                            if (!selectorContainer._inSyncPhase) {
                                selectorContainer.selectorControlChange(this);
                            }
                        },
                        makeSelection: function(evt) {
                        	if (!selectorContainer._inSyncPhase) {
                        		selectorContainer.showInfoWin(evt && evt.selItem);
                        	}
                        }
                    };

                // #485009 if All selector is in exclude mode than set the allIdx to -1 and use the noneIdx property to unselect all
                if (cfg.noneIdx !== -1) {
                    cfg.allIdx = -1;
                }

                // Is this a scroller or metric slider?
                if (selectorStyle === STYLES_SCROLLER || selectorStyle === STYLES_METRIC_SLIDER) {
                    // Override the text-align set inline on doc selector node with the 'extSlider' css class.
                    selectorContainer.extCls = 'extSlider';

                    if (defn.cek) {
                        defn.include = defn.cek.include;
                        data.cs = defn.cek.cs;
                        data.f = defn.cek.f;
                        data.ft = defn.cek.ft;
                        selectorContainer.qua = defn.cek.qua;
                    }

                }

                // Is this a scroller?
                if (selectorStyle === STYLES_SCROLLER) {

                    // Add height and width from fmts.
                    copyProps([ 'height', 'width' ], fmts, cfg);

                } else if (selectorStyle === STYLES_METRIC_QUAL || selectorStyle === STYLES_METRIC_SLIDER) {

                    if (selectorStyle === STYLES_METRIC_SLIDER) {
                        cfg.isHoriz = true;
                        cfg.include = defn.include;
                    }

                    copyProps([ 'height', 'width', 'font' ], fmts, cfg);
                    copyProps([ 'cs', 'ft' ], defn, cfg);
                    cfg.fmts = defn.f;
                    cfg.qua = selectorContainer.qua;
                    cfg.numFmts = defn.numFmts;
                }  else if (selectorStyle === STYLES_SEARCH_BOX) {
                	cfg = {
                			scriptClass: cfg.scriptClass,
                			cssText: fmts.height ? 'height: ' + fmts.height : '',
                			emptyText: mstrmojo.desc(4325, 'Search') + ' ' + (defn.ttl || ''),
                			items: defn.srcid ? (data.ces ? data.ces.concat() : []) : [],   // only when it has source (metric and panel type are excluded), we make search box works
                			REQUEST_THRESHOLD: 55, //TBD
                			suggestCount: 50, //TBD
                			srcid: defn.srcid || '',
                			dsrc: defn.dsrc || '',
                			onitemsChange: function () {
                				if (!selectorContainer._inSyncPhase) {
                					//#703233. show info window when items change
                					selectorContainer.showInfoWin();
                					
                					selectorContainer.selectorControlChange(this);
                				}
                			}
                	};

                	if (elements && !defn.sos) { //sos stands for "search on server"
                		cfg.candidates = {
                				isComplete: true,
                				items:  defn.srcid ? elements : []
                		};
                	} else {
                		cfg.useKeyDelay = true;
                		cfg.noCache = true;
                	}

                	if (!defn.multi) {
                		//single select
                		cfg.maxObjectCount = 1;
                	}
                }

                return cfg;
            },

            /**
             * Updates selector control style after control has been added to the {@link mstrmojo.DocSelector}.
             *
             * @param {mstrmojo.DocSelector} selectorContainer The selector container to which the selector GUI will be added.
             */
            updateControlStyles: function updateControlStyles(selectorContainer) {
                // Is the control inside of a filter panel?
                if (selectorContainer.isInFilterPanel() && !selectorContainer.isHorizFP()) {
                    // Is the control a type of scroller?
                    var style = selectorContainer.style;
                    if (style === STYLES_SCROLLER || style === STYLES_METRIC_QUAL || STYLES_METRIC_SLIDER) {
                        // Set width of the scroller control to the contentWidth of the panel.
                        selectorContainer.children[0].width = selectorContainer.parent.parent.contentWidth;
                    }
                }
            }

        }
    );

    var factory = mstrmojo.DocSelectorViewFactory;

    // Store local constants as static field on DocSelectorViewFactory.
    factory.STYLES = {
        PULLDOWN: STYLES_PULLDOWN,
        SCROLLER: STYLES_SCROLLER,
        LIST: STYLES_LIST,
        RADIO: STYLES_RADIO,
        CHECKBOX: STYLES_CHECKBOX,
        BUTTON: STYLES_BUTTON,
        LINK: STYLES_LINK,
        METRIC_SLIDER: STYLES_METRIC_SLIDER,
        METRIC_QUAL: STYLES_METRIC_QUAL,
        SEARCH_BOX: STYLES_SEARCH_BOX

    };

    factory.ELEM_ALL = ALL_ID;

    factory.UC_ON_DS = _ST_UC_ON_DS;

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Container",
                         "mstrmojo._Formattable",
                         "mstrmojo.DocSelectorViewFactory",
                         "mstrmojo.css",
                         "mstrmojo.dom",
                         "mstrmojo.hash",
                         "mstrmojo.array",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo.elementHelper");


    var $ARR = mstrmojo.array,
        $HASH = mstrmojo.hash,
        $D = mstrmojo.dom,
        STYLES = mstrmojo.DocSelectorViewFactory.STYLES,
        ELEM_ALL_ID = mstrmojo.DocSelectorViewFactory.ELEM_ALL,
        _EH = mstrmojo.elementHelper;

    var _ST_UC_ON_DS = mstrmojo.DocSelectorViewFactory.UC_ON_DS;

    /**
     * Create an Event populated with information that is common to all actions.
     *
     * @private
     * @returns Object
     */
    function getEvent() {
        return {
            type: parseInt(this.type, 10),
            src: this.k,
            ck: this.ck,
            ctlKey: this.ckey,      // Control key.
            tks: this.tks,
            include: this.include,
            disablePU: (parseInt(this.defn.subTp, 10) === _ST_UC_ON_DS)  // don't do partial update for UC on dataset selector
        };
    }

    /**
     * <p>A widget for Report Services Selector Controls.</p>
     *
     * @class
     * @extends mstrmojo.Container
     */
    mstrmojo.DocSelector = mstrmojo.declare(

        mstrmojo.Container,


        [mstrmojo._Formattable, mstrmojo._IsSelectorTarget],

        /**
         * @lends mstrmojo.DocSelector.prototype
         */
        {
            scriptClass: 'mstrmojo.DocSelector',

            markupString: '<div id="{@id}" class="mstrmojo-DocSelector {@extCls}" title="{@tooltip}" style="{@domNodeCssText}">' +
                                '<div class="filter" style="{@filterNodeCssText}"></div>' +
                                '<div class="wait" style="display:none;z-index:100; position:absolute; top:0px; left:0px; width:100%; height:100%"></div>' +
                                '<div class="content" style="{@contentNodeCssText}"></div>' +
                    '</div>',

            markupSlots: {
                filterNode: function () { return this.domNode.firstChild; },
                contentNode: function () { return this.domNode.lastChild; },
                dimNode: function () { return this.domNode.lastChild; },           // This nodes contains the dimension information, sub section needs this information to perform auto shrink/grow.
                containerNode: function () { return this.domNode.lastChild; },
                scrollboxNode: function () { return this.domNode.lastChild; },
                wIconNode: function () { return this.domNode.childNodes[1]; }
            },

            markupMethods: {
                onincludeChange: function () { mstrmojo.css.toggleClass(this.domNode, 'strikeout', !this.include); },
                onvisibleChange: mstrmojo.Widget.visibleMarkupMethod,
                onwaitChange: function () { this.wIconNode.style.display = ((this.wait) ? 'block' : 'none'); }
            },

            /**
             * @see mstrmojo._Formattable
             * @ignore
             */
            formatHandlers: {
                domNode: [ 'F', 'text-align', 'vertical-align', 'line-height', 'z-index', 'top', 'left' ],
                contentNode: [ 'width', 'B', 'P' ],
                filterNode: [ 'height', 'width', 'B', 'P', 'fx', 'background-color' ],
                item: [ 'color', 'font', 'text-decoration', 'text-align', 'line-height' ]
            },

            /**
             * Control key.
             */
            ckey: null,

            /**
            * <p>Control key context.</p>
            *
            * <p>This is essentially the control key + some more information needed by event handler so that when we send the selector event, it does not need to load the RWdefinition
            * before submitting the event.</p>
            */
            ck: null,

            /**
            * <p>This is the list of keys for the targets that the the selector controls.</p>
            *
            * @type String
            *
            * @refactoring This is currently a delimited string. Pretty much like control key context, we should just need to pass this string back as it is.
            * if we do need to parse it, we should change the block definition to have this list come as an array instead.
            */
            tks: null,

            /**
            * <p>Control Style.</p>
            *
            * @type Integer
            *
            * @refactoring Not of much use right now.
            */
            style: 0,

            /**
            * <p>Selected Element Index.</p>
            *
            * <p>Since the list of available elements and current elements comes disconnected (todo0 - ), we will figure and store the selected element index on the instance.</p>
            */
            selIdx: null,

            /**
             * Extra css class apply to this doc selector node.
             * For slider, text align in doc selector node can cause trouble.
             * We are seeing issue with IE, when text-align is right, it will push slider to the right.
             * For slider, we will insert an extra css class here and in that css rule, we will override the text-align
             */
            extCls: '',

            /**
             * indicate whether we have already fetch the element list for UC on dataset selector
             */
            bGetElems: false,

            /**
             * Overridden to set a property (spm) to indicate whether the Selector Style supports popup menu.
             *
             * @see mstrmojo.Model
             * @ignore
             */
            init: function init(props) {
                this._super(props);

                // Only Attribute Element Selector (type 1) is supported
                // Scroller Selector (style type 1) is not supported
                var s = this.node.defn.style;
                this.spm = (s === STYLES.METRIC_QUAL || s === STYLES.METRIC_SLIDER);
            },

            /**
             * Initializes instance variables.
             *
             */
            initControlInfo: function initControlInfo() {

                var node = this.node,
                    data = node.data,
                    defn = node.defn,
                    elements = data.elms,
                    currentSelections = data.ces,
                    style = defn.style;

                // Create array of names of propertie that need to be copied from definition node to instance.
                var defnProps = [ 'include', 'ckey', 'ck', 'tks', 'style', 'multi', 'showall' ];

                // For UC on dataset selector,
                // if the elem list is empty, we have to fetch its element list by a separate task call,
                // but for seach box selector, we will postpone the element browsing until user input something.
                if (!this.bGetElems && parseInt(defn.subTp, 10) === _ST_UC_ON_DS && style !== STYLES.SEARCH_BOX) {
                    this._fetchAllElems();
                    elements = data.elms; //reset the local elements variable, necessary
                }

                // Is this a metric slider?
                if (style === STYLES.METRIC_QUAL || style === STYLES.METRIC_SLIDER) {
                    // Add definition properties.
                    defnProps = defnProps.concat([ 'srcid', 'srct' ]);

                    // Add qua and dt
                    this.qua = data.qt;
                    this.dt = data.dt;
                }

                // Add type property from definition.
                this.type = defn.ct;

                // Does the definition have a format node?
                var fmts = defn.fmts;
                if (fmts) {
                    var w = fmts.width;
                    if (!w || parseInt(w, 10) <= 0) {
                        // TQMS 501246: Set default value for IVE compatibility.
                        fmts.width = '95px';
                    }
                }

                // Copy definition properties to instance.
                $HASH.copyProps(defnProps, defn, this);

                // Initialize this instance's selected element index array.
                var selectedIndices = this.selIdx = {},
                    multi = defn.multi;

                // 512275 - Removed this code because we should respect the selection value we get from the server. Not deleting it in case
                // we find a case which needs this.
//                // Do we have cek?
//                if (cek) {
//                    if (multi && $ARR.indexOf(cek, ELEM_ALL_ID) > -1) {
//                        $ARR.forEach(elements, function (el, idx) {
//                            selectedIndices[idx] = true;
//                        });
//
//                    } else if (style === STYLES.PULLDOWN) {
//                        ind = $ARR.find(elements, 'v', cek);
//                        if (ind >= 0) {
//                            selectedIndices[ind] = true;
//                        }
//
//                    } else {
//                        $ARR.forEach(cek, function (cekItem) {
//                            ind = $ARR.find(elements, 'v', cekItem);
//                            if (ind >= 0) {
//                                selectedIndices[ind] = true;
//                            }
//                        });
//                    }
//
//                } else {

                // Look for the presence of the (ALL) element in the current selection.if original selection include (ALL), then current selection is the whole available
                if (this.include && multi && $ARR.find(currentSelections, 'v', ELEM_ALL_ID) > -1) {
                    // If found the current selection should be all available elements.
                    currentSelections = elements;
                }

                // Do we have current selections?
                if (currentSelections) {
                    // Iterate elements.
                    $ARR.forEach(elements, function (el, idx) {
                        // Is this element selected?
                        if ($ARR.find(currentSelections, 'v', el.v) >= 0) {
                            // Add to selected indices.
                            selectedIndices[idx] = true;
                        }
                    });
                }
//                }
            },

            /**
             * <p>Resets the format handlers to the bare minimum needed for an RW unit.</p>
             *
             * <p>This method is intended for situations where the child selector will handle all formatting.</p>
             */
            resetFormatHandlers: function resetFormatHandlers() {
                this.formatHandlers = {
                    contentNode: [ 'RW' ]
                };
            },

            /**
             * This method is called when the
             *
             * @param {String|mstrmojo.Widget} value Either the element ID (for pulldowns) or the widget itself (all others).
             *
             */
            selectorControlChange: function selectorControlChange(widget) {
                // Get generic event.
                var rEvt = getEvent.call(this),
                    elementSeparator = '\u001E',
                    elementIDs = [],
                    style = this.style,
                    showElementCount = this.defn.sec,
                    i;

                switch (style) {
                case STYLES.PULLDOWN:
                    var value = widget.value,
                        n = null;

                    if (widget.selectNode) {
                        var sn = widget.selectNode;
                        n = sn.options[sn.selectedIndex].text;
                    }


                    // Add element ID.
                    rEvt.eid = value;
                    if (parseInt(rEvt.type, 10) === 1 && n !== null) {
                        rEvt.eid = rEvt.eid + ';' + n;   // Element ID, Append "display name" if it has
                    }

                    // Set cek in definition.
                    this.defn.set('cek', value);

                    // Remember the current selected value.
                    this.currSelValue = value;


                    if (showElementCount) {
                        // If the selector is inside the FilterPanel, then add element count on the Portlet title
                        this.parent.set('count', _EH.buildElemsCountStr([value], this.node.data.elms));
                    }

                    break;

                case STYLES.SEARCH_BOX:
                    // Iterate items.
                    $ARR.forEach(widget.items, function (item) {
                        // Push each element ID.
                        elementIDs.push(item.v + ';' + item.n);
                    });

                    // Are there no element IDs AND should we show All?
                    if (!elementIDs.length && this.showall) {
                        // TQMS# 536595
                        elementIDs.push('u;');
                    }

                    // Set the eid to match the elements IDs.
                    rEvt.eid = elementIDs.join(elementSeparator);

                    // TQMS# 618796
                    if (showElementCount) {
                        // If the selector is inside the FilterPanel, then add element count on the Portlet title
                        this.parent.set('count', _EH.buildElemsCountStr(elementIDs, this.node.data.elms));
                    }
                    break;

                case STYLES.METRIC_QUAL:
                case STYLES.METRIC_SLIDER:
                    if(this.srcid === undefined) {
                        return; // #749440 if there is no source configured for metric slider/qual return and don't do anything.
                    }
                    var cs = [];

                    // Iterate widget 'cs' array.
                    $ARR.forEach(widget.cs, function (item) {
                        // Add 'v' property to local cs array.
                        cs.push(item.v);

                        if (rEvt.dtp === undefined) {
                            rEvt.dtp = item.dtp;
                        }
                    });

                    // Did we find any cs values?
                    if (cs.length) {
                        // Add to event.
                        rEvt.cs = cs.join(elementSeparator);
                    }

                    // Copy new function info to event and widget.
                    var fInfo = mstrmojo.MCSUtil.getFuncInfo(widget.opId, widget.qua);
                    rEvt.f = widget.f = fInfo.f;
                    rEvt.ft = widget.ft = fInfo.ft;

                    // Copy include to event and widget.
                    rEvt.include = widget.include = this.include;

                    // Add props to event.
                    rEvt.ckey = this.ckey;
                    rEvt.srcid = this.srcid;
                    rEvt.srct = this.srct;

                    rEvt.unset = widget.unSet;
                    rEvt.onlyInclude = widget.onlyInclude;
                    rEvt.changeQual = widget.changeQual;
                    rEvt.qt = widget.qua;

                    // TQMS 467964: Synchronize the other selectors with the same definition (groupby).
                    this.node.defn.set("cek", {
                        id: this.id,
                        f: widget.f,
                        ft: widget.ft,
                        cs: widget.cs,
                        qua: widget.qua,
                        include: widget.include
                    });
                    break;

                default:
                    var node = this.node,
                        elements = node.data.elms,
                        indices = widget.selectedIndices,
                        allIdx = widget.allIdx,
                        isAll = !!indices[allIdx],
                        eidts = [],     // element id with display text
                        inc = this.include;

                    // Is the ALL case present in the indices?
                    if (isAll) {
                        // Elements should be an array with single ALL element.
                        elementIDs = [ elements[allIdx].v ];
                        eidts = [ elements[allIdx].v ];

                    } else {
                        if (indices[allIdx]) {
                            indices[allIdx] = false;
                        }

                        //#555555  - make the selectedIndices in the same order as in the elements List inspite of the order of selection action
                        var keyArr = $HASH.keyarray(indices, true).sort($ARR.numSorter),
                            sortedIndices  = {};

                        for (i in keyArr) {
                            sortedIndices[keyArr[i]] = indices[keyArr[i]];
                        }
                        indices = sortedIndices;

                        // Iterate indices.
                        $HASH.forEach(indices, function (item, idx) {
                            // Is this index selected?
                            if (item) {
                                // Add element.
                                elementIDs.push(elements[idx].v);
                                eidts.push(elements[idx].v + ';' + elements[idx].n);
                            }
                        });
                    }

                    // Add element IDs to event.
                    rEvt.eid = ((parseInt(rEvt.type, 10) === 1) ? eidts : elementIDs).join(elementSeparator);

                    // TQMS 450995: Get the position of the selector, used for info window.
                    var pos = mstrmojo.dom.position(widget.domNode, true);
                    if (pos) {
                        // Add left and top positions to event.
                        rEvt.left = pos.x;
                        rEvt.top = pos.y;
                    }

                    // Is this the all case and multi select?
                    if (isAll && this.multi && inc) {
                        // Iterate elements.
                        $ARR.forEach(elements, function (elem) {
                            var v = elem.v;

                            // Is this not the ALL element?
                            if (elementIDs[0] !== v) {
                                // Add the element to the collection of ID's.
                                elementIDs.push(v);
                            }
                        });
                    }

                    // Set "cek" value.
                    node.defn.set('cek', elementIDs);

                    if (showElementCount && style !== STYLES.SCROLLER) {
                        // If the selector is inside the FilterPanel, then add element count on the Portlet title
                        this.parent.set('count', _EH.buildElemsCountStr(elementIDs, elements));

                    }
                    break;
                }

                // Submit event to model for slicing within a timeout so the UI can update with the latest selector state.
                var me = this;
                window.setTimeout(function () {
                    me.slice(rEvt);
                }, 0);
            },

            showInfoWin: function showInfoWin(anchor) {
            	var m = this.model,
            		ifws = m.getTargetInfoWin(this.tks);

            	if (ifws && ifws.length) {
            		var horiz = this.defn.horiz,
            			actualAnchor = anchor || this.contentNode,
            			aPos = $D.position(actualAnchor), // anchor position
            			sPos = $D.position(this.contentNode), // selector position
            			// TQMS 678786 : for vertical selectors (execept Scroller),
            			// use selector width instead of item width for IW positioning.
            			position = (horiz || this.defn.style == STYLES.SCROLLER) ? null : {x : sPos.x, y : aPos.y, w : sPos.w, h : aPos.h};


        			for (var i = 0;i < ifws.length; i++) {

            			m.showInfoWin(ifws[i],
            						  actualAnchor,
            						  horiz ? 'v' : 'h', false, $HASH.copy(position));
            		}
            	}
            },

            /**
             * Setup the control info properties, style widget before rendering.
             */
            preBuildRendering: function preBuildRendering() {
                var ret = true,
                    style = this.node.defn.style,
                    formatHandlers = $HASH.clone(this.formatHandlers),
                    contentNodeHandler = formatHandlers.contentNode;

                // For checkbox and radio buttons, when the filter in on content itself, IE can display much nicer shadow.
                // So, we remove filterNode from formatHandlers and add 'fx' and 'background-color' into contentNode.
                // But for other types of selector, they either need scroll bar or need overflow:visible for the overflow pointers.
                // So, for those types, we can not move the filter info into contentNode.
                if (contentNodeHandler) {
                    if ((style === STYLES.RADIO || style === STYLES.CHECKBOX) && formatHandlers.filterNode) {
                        contentNodeHandler.push('fx');
                        contentNodeHandler.push('background-color');

                        delete formatHandlers.filterNode;
                    }

                    if (style === STYLES.LIST) {
                        delete contentNodeHandler.height;
                    }

                    if (style === STYLES.SEARCH_BOX) {
                        //Delete some formats from dom node for search box seletor
                        var domHandler = formatHandlers.domNode;

                        $ARR.removeItem(domHandler, 'color');

                        var idx = $ARR.indexOf(domHandler, 'F');
                        if (idx > -1) {
                            $ARR.removeIndices(domHandler, idx, 1);
                            domHandler.push('font');
                        }
                    }
                }

                // Store modified format handlers back on selector.
                this.formatHandlers = formatHandlers;

                // Call the super.
                ret = this._super();

                // Update selector styles after prebuild rendering.
                this.builder.selectorFactory.updateControlStyles(this);

                return ret;
            },

            /**
             * Overrides parent class implementation to take care of fit to content widget for filter node.
             *
             * @ignore
             */
            postBuildRendering: function postBuildRendering() {
                var style = this.node.defn.style,
                    filterNodeStyle = this.filterNode.style,
                    contentNode = this.contentNode,
                    defn = this.node.defn;

                this._super();

                if (this.formatHandlers.filterNode) {
                    // If this widget does not have fixed width/height, we need to fix filter node to match content node's width/height
                    var f = this.getFormats();

                    if (!f.width) {
                        filterNodeStyle.width = contentNode.clientWidth + 'px';
                    }

                    if (!f.height) {
                        filterNodeStyle.height = contentNode.clientHeight + 'px';
                        if (style === STYLES.METRIC_QUAL || style === STYLES.METRIC_SLIDER) {
                            this.updateHeight();
                        }
                    } else {
                        // TQMS 521125: if height is fixed, need to set it on the content node too.
                        if (style === STYLES.METRIC_QUAL) {
                            contentNode.style.height = f.height;
                        }
                    }

                } else {
                    // If filterNode is not part of the formatHandlers, then we must have merged it into contentNode so we need to hide the filter node.
                    filterNodeStyle.display = 'none';
                }

                if (this.isInFilterPanel() && !this.isHorizFP()) {
                    this.domNode.style.width = this.contentNode.style.width = '100%';
                    if (this.formatHandlers.filterNode) {
                        this.filterNode.style.width = this.contentNode.style.width = '100%';
                    }
                    this.set('visible', parseInt(defn.ds, 10) === 0); // Expanded status.
                }

                //Listen to the changes to control group by map from the server, due to a manipulation.
                this.model.attachEventListener('CGBMapChange', this.id, 'onCGBMapChange');

                // Pass instance to selectorFactory to attach any target event listeners.
                this.builder.selectorFactory.attachTargetListeners(this);

                if($D.isAndroid && style === STYLES.SCROLLER) {
                    contentNode.style.overflow = 'visible';
                }

                return true;
            },

            _fetchAllElems: function _fetchAllElems() {
                var defn = this.node.defn,
                    data = this.node.data;

                var taskParams = {
                    taskId: 'browseElements',
                    styleName: 'MojoAttributeStyle',
                    attributeID: defn.srcid || '',
                    dataSourcesXML: defn.dsrc || '',
                    browseFlags: 1
                };

                var me = this,
                    callbacks = {
                        success: function (res) {
                            me.bGetElems = true;
                            me.set('wait', false);

                            if (res && res.es) {
                                data.elms = (defn.srcid) ? _EH.buildElemsTerseID(res.es, defn.srcid, true) : res.es;

                                var parent = me.parent,
                                    grandParent = parent && parent.parent;

                                if (data.ces && data.elms && data.elms.length > 0 && parent) {
                                    parent.set('count', _EH.buildElemsCountStr(data.ces, data.elms));
                                }

                                if (me.hasRendered) {
                                    me.refresh();
                                    if (me.isInFilterPanel()) {
                                        if (parent && parent.defn.ttl) { // DocPortlet
                                            parent.updateContentHeight();
                                        }
                                        if (grandParent && grandParent.refreshFP) {   // DocPanel
                                            grandParent.refreshFP();
                                        }
                                    }
                                }
                            }
                        },
                        failure: function (res) {
                            mstrmojo.alert(res.getResponseHeader('X-MSTR-TaskFailureMsg'));
                        }
                    };

                this.set('wait', true);
                mstrmojo.xhr.request('POST', mstrConfig.taskURL, callbacks, taskParams, false, null, true);
            },

            //Some styles need to add their height into container after rendered.
            updateHeight: function updateHeight() {
                this.contentNode.style.height = this.filterNode.style.height = this.content.getClientHeight() + 'px';

                var parent = this.parent;
                if (parent && (parent.defn.ttl !== undefined) &&
                		parent.updateContentHeight) {   // DocPortlet. #715775.
                    parent.updateContentHeight();
                }
            },

            /**
             * Updates its 'tks' property based on the the updated values received from the webserver.
             *
             * @param {Object} The evt object that consists of the cgbMap property
             */
            onCGBMapChange: function onCGBMapChange(evt) {
                //Return if we don't have new values
                var cgbMap = evt.cgbMap;
                if (!cgbMap) {
                    return;
                }

                // Get list of target keys.
                var tks = this.tks;

                // Iterate control group bys.
                $HASH.forEach(this.defn.cgb, function (key) {
                    // Was this group by targeted?
                    var targetKey = cgbMap[key];
                    if (targetKey && tks.indexOf(targetKey) < 0) {
                        // Add the target key.
                        tks += '\u001E' + targetKey;
                    }
                });

                // Store new tks back on instance.
                this.tks = tks;
            },

            /**
             * Updates the DocSelector data that may change due to a selector action.
             *
             * @param {Object} node The widget node.
             */
            update: function update(node) {
                // Update node.
                this.node = node;

                var defn = this.node.defn,
                    style = defn.style,
                    elements = this.node.data.elms,
                    parent = this.parent,
                    isScroller = (style === STYLES.SCROLLER);

                // adjust (ALL) for multi version slider.
                if (isScroller && defn.multi) {
                    // for multi version slider, we are not going to include (ALL) as available
                    var allIdx = $ARR.find(elements, 'v', ELEM_ALL_ID);
                    if (allIdx > -1) {
                        $ARR.removeIndices(elements, allIdx, 1);
                    }
                }

                // Is the selector in a filter panel AND is the style NOT a scroller AND NOT a search box selector with search on server?
                if (defn.sec && !isScroller && !defn.sos) {
                    var ces = node.data.ces;
                    // Is the selector contained in a portlet and does it have a count field?
                    if (parent && parent.count) {
                        // Do we have selected elements?
                        if (ces && elements && elements.length) {
                            // Update the element count of the portlet titlebar.
                            parent.set('count', _EH.buildElemsCountStr(ces, elements));
                        }
                    }
                }

                // Set up the control information on the instance.
                this.initControlInfo();

                // Get selector widget.
                var widget = this.content = this.builder.selectorFactory.newSelector(this);

                // Did we NOT get back a widget?
                if (!widget) {
                    // Set visible to false.
                    this.set('visible', false);
                }
            },

            /**
             * Update DocSelector's target widget data when toggling 'include/exclude'.
             *
             * @param {Object} The evt object that consists of the include property
             */
            onincludeChange: function onincludeChange(evt) {
                this.node.defn.include = this.include = evt.value;

                if (this.style !== STYLES.METRIC_SLIDER) {
                    this.include = evt.value;

                    // Update the target widgets
                    var rEvt = getEvent.call(this);
                    rEvt.ckey = this.ckey;
                    this.slice(rEvt);
                }
            },

            /**
             * Submit the slice event through doc model or if it is inside a filter panel and
             * the autoApply is false, buffer the event.
             */
            slice: function slice(rEvt) {
                var m = this.model;
                if (this.isInFilterPanel()) {
                    var fp = this.getFilterPanel();
                    if (fp && !fp.defn.cas) {  //ctl auto submit, if it is set to false, we buffer the user action
                        fp.bufferSlice(rEvt);
                        return;
                    }
                }

                m.slice(rEvt);
            },

            onquaChange: function onquaChange(evt) {
                this.node.data.qt = evt.value;
            },

            isInFilterPanel: function isInFilterPanel() {
                var parent = this.parent;
                return (parent && parent.isInFilterPanel && parent.isInFilterPanel()) || false;
            },

            isHorizFP: function isHorizFP() {
                var parent = this.parent;
                return (parent && parent.isHorizFP && parent.isHorizFP()) || false;
            },

            getFilterPanel: function getFilterPanel() {
                var parent = this.parent;
                return (parent && parent.getFilterPanel && parent.getFilterPanel()) || null;
            }

        }
    );

    // Is this not an IE browser?
    if (!mstrmojo.dom.isIE) {
        // Move the filterNode formatHandlers to the content node and delete filterNode handlers.
        var formatHandlers = mstrmojo.DocSelector.prototype.formatHandlers;
        formatHandlers.contentNode = formatHandlers.filterNode;
        delete formatHandlers.filterNode;
    }

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocSelectorViewFactory",
                         "mstrmojo.android.DropDownList",
                         "mstrmojo.android.selectors.CheckList",
                         "mstrmojo.android.selectors.ListBox",
                         "mstrmojo.android.selectors.LinkBar",
                         "mstrmojo.android.selectors.ButtonBar",
                         "mstrmojo.android.selectors.Slider",
                         "mstrmojo.array");

    var $STYLES = mstrmojo.DocSelectorViewFactory.STYLES;

    /**
     * JavaScript widget class names for different selector types.
     *
     * @const
     * @private
     */
    var widgetMap = {};
    widgetMap[$STYLES.RADIO] = 'CheckList';
    widgetMap[$STYLES.CHECKBOX] = 'CheckList';
    widgetMap[$STYLES.LIST] = 'ListBox';
    widgetMap[$STYLES.LINK] = 'LinkBar';
    widgetMap[$STYLES.BUTTON] = 'ButtonBar';
    widgetMap[$STYLES.SCROLLER] = 'Slider';
    //TQMS 623330. Convert a search selector into a link bar 
    widgetMap['9'] = 'LinkBar';

    /**
     * <p>A factory for creating Report Services Document selector controls for the Android platform.</p>
     *
     * @class
     * @extends mstrmojo.android.DocSelectorViewFactory
     */
    mstrmojo.android.DocSelectorViewFactory = mstrmojo.declare(

        mstrmojo.DocSelectorViewFactory,

        null,

        /**
         * @lends mstrmojo.android.DocSelectorViewFactory.prototype
         */
        {
            scriptClass: 'mstrmojo.android.DocSelectorViewFactory',

            isSelectorSupported: function isSelectorSupported(selectorContainer) {
                // Retrieve the selector definition.
                var defn = selectorContainer.node.defn;

                // Is this a panel stack?
                if (defn.ct === "3") {
                    // Do we have target AND is this panel selector docked to the panel?
                    var targetKey = selectorContainer.tks;
                    if (targetKey && selectorContainer.defn.dk) {
                        // Notify panel stack that it should have a docked selector.
                        selectorContainer.model.getLayoutUnitDefn(targetKey, defn._lkz).dk = true;

                        // Return false to indicate that we don't need a selector.
                        return false;
                    }
                }

                // Return true to indicate that the selector is supported.
                return true;
            },

            /**
             * Creates, initializes and adds a pulldown style selector to the selectorContainer.
             *
             * @param {mstrmojo.DocSelector} selectorContainer The selector container to which the pulldown will be added.
             *
             * @returns mstrmojo.Widget
             */
            newPulldown: function newPulldown(selectorContainer) {
                return new mstrmojo.android.DropDownList({
                    name: selectorContainer.node.defn.n,
                    postvalueChange: function () {
                    	// Is the selector NOT synchronizing?
                    	if (!selectorContainer._inSyncPhase) {
                    		selectorContainer.showInfoWin();
                    		// Tell the selector we've changed the value.
                    		selectorContainer.selectorControlChange(this);
                    	}
                    }
                });
            },

            updateControlStyles: function updateControlStyles(selectorContainer) {
                var fmts = selectorContainer.getFormats(),
                    selectorStyle = selectorContainer.style,
                    ctrl = selectorContainer.children && selectorContainer.children[0];

                if (!ctrl) {
                    return;
                }

                // Do we have formats?
                if (fmts) {

                    // Get height and width from formats.
                    var height = fmts.height,
                        width = fmts.width;

                    // Do we have a fixed height?
                    if (height !== undefined) {
                        // Pass to control.
                        ctrl.height = height;
                    }

                    // Do we have a fixed width?
                    if (width !== undefined) {
                        // Pass to control?
                        ctrl.width = width;
                    }

                    // Is this a link bar?
                    if (selectorStyle === $STYLES.LINK) {
                        // Do we already have a selected color?
                        var selectedColor = selectorContainer.defn.ssc;
                        if (selectedColor) {
                            // Pass the selected color to the control.
                            ctrl.selColor = selectedColor;
                        }
                    }
                }

                this._super(selectorContainer);
            },

            attachTargetListeners: function attachTargetListeners(selectorContainer) {
                this._super(selectorContainer);

                // Is this a supported panel selector?
                if (selectorContainer.defn.ct === '3' && this.isSelectorSupported(selectorContainer)) {
                    // Do we NOT already have a listener?
                    if (!selectorContainer._panelEvtListener) {
                        // Get panel stack instance.
                        var panelStack = selectorContainer.model.getUnitInstance(selectorContainer.tks, 1);
                        if (panelStack) {
                            // Attach event listener to panel stack.
                            selectorContainer._panelEvtListener = panelStack.attachEventListener('panelSelected', selectorContainer.id, function (evt) {
                                // Set synchronization phase flag so we don't send update.
                                this._inSyncPhase = true;

                                // Update selector.
                                this.content.singleSelectByField(evt.key, 'v');

                                // Clear synchronization phase flag.
                                this._inSyncPhase = false;
                            });
                        }
                    }
                }
            },

            getSelectorClass: function getSelectorClass(selectorStyle, isHoriz) {
                // Return the script class name (if found in map) or result of call to super.
                var cls = widgetMap[selectorStyle];
                return (cls && 'android.selectors.' + cls) || this._super(selectorStyle, isHoriz);
            },
            
            getSelectorCtrlConfig: function getSelectorCtrlConfig(selectorContainer, selectorStyle, defn, elements) {
            	//TQMS 623330. Add an all element for empty elements list
            	if ( selectorStyle === 9 ) {
            		if ( elements && elements.length === 0) {
	            		elements.push({
	            			n: "(All)",
	            			t: 14,
	            			v: "u;"
	            		});
                	}
            		//TQMS 650983
            		selectorContainer.style = selectorStyle = $STYLES.LINK;
            	}
            	return this._super(selectorContainer, selectorStyle, defn, elements);
            }            
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.VisTimeSeries");

    /**
     * A report based time series visualization for the Android platform.
     * 
     * @class
     * @extends mstrmojo.VisTimeSeries
     */
    mstrmojo.AndroidVisTimeSeries = mstrmojo.declare(

        mstrmojo.VisTimeSeries,

        null,
        
        {
            scriptClass: 'mstrmojo.AndroidVisTimeSeries'
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.VisTimeSeries");

    /**
     * Standalone class that displays the VisTimeSeries full screen on documents.
     *
     * @class
     * @extends mstrmojo.VisTimeSeries
     */
    mstrmojo.DocVisTimeSeries = mstrmojo.declare(

        mstrmojo.VisTimeSeries,

        null,

        /**
         * @lends mstrmojo.DocVisTimeSeries.prototype
         */
        {
            scriptClass: 'mstrmojo.DocVisTimeSeries'
        }
    );
}());
(function () {
    mstrmojo.requiresCls("mstrmojo.Vis",
        "mstrmojo.VisMicroChartTable",
        "mstrmojo.dom",
        "mstrmojo._TouchGestures",
        "mstrmojo._HasTouchScroller",
        "mstrmojo.VisTextTooltip",
        //                        "mstrmojo.VisDebuggerUtils",
        "mstrmojo.hash",
        "mstrmojo.color",
        "mstrmojo.css");

    var $CLR = mstrmojo.color,
        $CSS = mstrmojo.css,
        $HASH = mstrmojo.hash,
        $forEachHash = $HASH.forEach,
        $M = Math,
        $D = mstrmojo.dom;

    var zf = 1;

    //how many page we render at one time
    var PAGE_COUNT = 5;

    var TRIANGLE_WIDTH = 30;

    //metric columns spacing
    var COMPACT = 0;
    var NORMAL = 1;
    var LARGE = 2;

    var DEFAULT_TH_CSS = "border:none;word-break:break-word;white-space:normal;";
    var DEFAULT_TD_CSS = "border:none;background:transparent;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-top:0px;padding-bottom:0px;";
    var TD_SELECTED_CSS = "border:none;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-top:0px;padding-bottom:0px;";
    var TH_SELECTED_CSS = "border:none;word-break:break-word;white-sapce:normal;";

    var NO_REPLACE = 2;
    var IN_REPLACE = 3;

    var TOP_Z_INDEX = 200;

    var DOCKED_HEADER = 0,
        OTHER_ROW = 1;

    var ROW_AXIS = 1, COL_AXIS = 2;
    var DRILLING_ACTION = 1, SELECTOR_ACTION = 2, HYPERLINK_ACTION = 4;
    var linkCount = 0;
    var attrCount = 0;
    var order = [];
    var ID_NAME = {};
    var METRIC_INDEX = {};
    var METRICS = [];
    var models = [];

    var LEFT_CHART_ROW = 'leftRow';
    var RIGHT_CHART_ROW = 'rightRow';

    // combine the attr with diff form
    var GFL = 1;
    // CG attr count
    var CGL = 0;

    var textAlign = { // xiawang: we must use class for text-align, otherwise
        // there is conflict between inherited format
        left: "microchart-table-text-L",
        center: "microchart-table-text-M",
        right: "microchart-table-text-R"
    };

    function getParentBkgColor() {
        var parentNode = this.domNode.parentNode;
        while (parentNode) {
            var compStyle = mstrmojo.css.getComputedStyle(parentNode);
            var bkgColor = compStyle.backgroundColor;
            if (bkgColor) {
                if (bkgColor.indexOf('rgba') >= 0) {
                    var rgba = this.utils.rgbaStr2rgba(bkgColor);
                    if (rgba && rgba[4]) {
                        return rgba;
                    }
                } else if (bkgColor.indexOf('rgb') >= 0) {
                    var rgb = $CLR.rgbStr2rgb(bkgColor);
                    return rgb;
                }

            }
            parentNode = parentNode.parentNode;
        }

        bkgColor = this.model['background-color'];
        if (bkgColor) {
            return $CLR.hex2rgb(bkgColor);
        }

        //return default value
        return  [255, 255, 255];
    }

    var DEFAULT_DARK_THEME = 1;
    var DEFAULT_LIGHT_THEME = 2;
    var CUSTOM_DARK_THEME = 3;
    var CUSTOM_LIGHT_THEME = 4;

    function getUITheme() {
        var ct = this.model.vp.ct;
        if (!ct || ct == "") {
            //for the old doc which not set custome theme, set it as custom theme
            ct = "0";
        }
        this.theme = parseInt(ct);

        if (this.theme == 0) {
            //custom theme
            var rgb = getParentBkgColor.call(this);

            var opacity = this.otherProps.mfBkgOpacity;
            rgb = this.utils.getRGBWithOpacity(rgb, opacity);

            //			set background color
            this.backgroundColor = this.utils.rgb2rgbStr(rgb);

            var brightness = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
            if (brightness > 150) {
                this.theme = CUSTOM_LIGHT_THEME;
            } else {
                this.theme = CUSTOM_DARK_THEME;
            }
        } else if (this.theme == 1) {
            //default dark theme
            this.backgroundColor = '#333333';
        } else if (this.theme == 2) {
            //default light theme
            this.backgroundColor = '#f9f9f9';
        }

        this.domNode.style.backgroundColor = this.backgroundColor;
    }

    function setDimensionWithDPI() {
        zf = this.utils.getScreenZoomFactor();

        var otherProps = this.otherProps;
        otherProps.mRowHeight = Math.round(zf * otherProps.mRowHeight);
        TRIANGLE_WIDTH = Math.round(zf * 36);

        this.dropShadowWidth = Math.round(zf * 7);

        paddingForSS = [Math.round(5 * zf), Math.round(8 * zf), Math.round(10 * zf)];
        colWidthForChart = [Math.round(100 * zf), Math.round(150 * zf), Math.round(200 * zf)];
        maxColWidthForAttr = [Math.round(120 * zf), Math.round(150 * zf), Math.round(180 * zf)];
        maxColWidthForMetric = [Math.round(100 * zf), Math.round(150 * zf), Math.round(200 * zf)];
        adjustWidthForColumnValue = [Math.round(20 * zf), Math.round(40 * zf), Math.round(80 * zf)];
    }

    function isScrollableElementTouched(touch) {
        if (this.enableSmoothScroll) {
            var touchPointOnWidget = this.utils.getTouchXYOnWidget(touch.pageX, touch.pageY, this);

            var x = touchPointOnWidget.touchX,
                y = touchPointOnWidget.touchY;

            if (x < this.leftWidth) {
                return false;
            }
            return true;
        } else {
            return true;
        }
    }

    // xiawang: this is helper function to set border and background-color while
    // maintain the width and height
    function setNodeCssText(node, cssText) {
        var height = node.style.height;
        var width = node.style.width;
        var textDecoration = node.style.textDecoration;
        var display = node.style.display;
        var fontSize = node.style.fontSize;
        var fontWeight = node.style.fontWeight;
        var paddingLeft = node.style.paddingLeft;
        var paddingRight = node.style.paddingRight;
        var boxShadow = node.style.boxShadow;
        node.style.cssText = cssText;
        node.style.height = height;
        node.style.width = width;
        node.style.textDecoration = textDecoration;
        if (display) {
            node.style.display = display;
        }
        if (fontSize) {
            node.style.fontSize = fontSize;
        }
        if (fontWeight) {
            node.style.fontWeight = fontWeight;
        }
        if (paddingLeft) {
            node.style.paddingLeft = paddingLeft;
        }
        if (paddingRight) {
            node.style.paddingRight = paddingRight;
        }
        if (boxShadow) {
            node.style.boxShadow = boxShadow;
        }
        //		var wordBreak = node.style.wordBreak;
        //		var whiteSpace = node.style.whiteSpace;
        //		if (wordBreak) {
        //			node.style.wordBreak = wordBreak;
        //		}
        //		if (whiteSpace) {
        //			node.style.whiteSpace = whiteSpace;
        //		}
    }

    function init(w) {
        METRICS = [];
        METRIC_INDEX = {};
        ID_NAME = {};
        order = [];
        models = [];
        GFL = 1;
        CGL = 0;
        linkCount = 0;
        attrCount = 0;
    }

    function initProp() {
        // mb:bolean value
        // mw:string value with format like "#FF00CC". It is used to represent color and converted from decimal or hex string from JSON
        // mstr:string value
        // mf:float value
        // mn:int value
        // mp:array value
        var sparklineProps = this.sparklineProps = {};
        sparklineProps.mbShow = true;
        sparklineProps.mbAllPoints = false;
        sparklineProps.mbEndPoints = true;
        sparklineProps.mbRefLine = true;
        sparklineProps.mbRefArea = true;
        sparklineProps.mbAssMetric = true;
        sparklineProps.mbShowTooltip = true;
        sparklineProps.mwSeriesLineCol = "#333333";
        sparklineProps.mwRefLineCol = "#0066FF";
        sparklineProps.mwRefAreaCol = "#DEDEDE";
        sparklineProps.mstrHeader = "[Sparkline]";
        sparklineProps.mstrAssMetric = "";

        var barProps = this.barProps = {};
        barProps.mbShow = false;
        barProps.mbShowLegend = true;
        barProps.mbRefLine = true;
        barProps.mbShowTooltip = true;
        barProps.mwPosCol = "#66CC00";
        barProps.mwNegCol = "#FF0000";
        barProps.mwRefLineCol = "#0066FF";
        barProps.mstrHeader = "[Bar]";

        var bulletProps = this.bulletProps = {};
        bulletProps.mbShow = true;
        bulletProps.mbRefLine = true;
        bulletProps.mbRefBands = true;
        bulletProps.mbShowLegend = true;
        bulletProps.mbAssMetric = true;
        bulletProps.mbInvertAxis = false;
        bulletProps.mbShowTooltip = true;
        bulletProps.mfMinValue = 0;
        bulletProps.mwPosCol = "#000066";
        bulletProps.mwNegCol = "#FF0000";
        bulletProps.mwRefLineCol = "#0066FF";
        bulletProps.mwBand1 = "#999999";
        bulletProps.mwBand2 = "#BBBBBB";
        bulletProps.mwBand3 = "#DEDEDE";
        bulletProps.mstrHeader = "[Bullet]";
        bulletProps.mstrAssMetric = "";
        bulletProps.mstrBand1 = "Low";
        bulletProps.mstrBand2 = "Medium";
        bulletProps.mstrBand3 = "High";

        var otherProps = this.otherProps = {};
        otherProps.mfBkgOpacity = 1.0;
        otherProps.mnMetricsPerKPI = 1;
        otherProps.mbHideColHeaders = false;
        otherProps.mbHideTextColumns = false;
        otherProps.mbLockLayout = false;
        otherProps.mbShowForHiddenGraphs = true;
        otherProps.mbInheritFromGridGraph = false;
        otherProps.mbInSingleColumnMode = false;

        otherProps.mpColumnIDs = [];
        otherProps.mpColumnIDsInTreeMode = [];
        otherProps.mpColumnPositions = null;
        otherProps.mpColumnWidths = null;
        otherProps.mpSortKey = null;

        otherProps.mbSortDescend = true;

        //set default row height
        otherProps.mRowHeight = 36;
        //		if(this.isAndroidTab){
        //			otherProps.mRowHeight = 29;
        //		}else{
        //			otherProps.mRowHeight = 48;
        //		}

    }

    function isTouchedOnWidget(touch) {

        if (!touch) {
            return false;
        }
        var me = this;

        var pos = mstrmojo.dom.position(this.domNode);

        //		var touchPointOnWidget = me.utils.getTouchXYOnWidget(touch.pageX,
        //				touch.pageY, me);
        //		var x = touchPointOnWidget.touchX, y = touchPointOnWidget.touchY;

        var x = touch.pageX - pos.x,
            y = touch.pageY - pos.y;

        if ((x > 0 && x < me.getWidth()) && (y > 0 && y < me.getHeight())) {
            return true;
        }
        return false;
    }

    // xiawang: used to convert decimal or hex strings into color strings like #0000FF
    function convertToColor(intString) {
        var colorString = parseInt(intString).toString(16);
        var len = colorString.length;
        for (var i = len; i < 6; i++) {
            colorString = "0" + colorString;
        }
        colorString = "#" + colorString;
        return colorString;
    }

    function buildNonTreeRows() {
        this.rows = [];
        for (var i = 0; i < models.length; i++) {
            this.rows[i] = {model: models[i],
                rowIdx: i,
                selected: {},
                rowRef: {}};
        }
    }

    function isSubTotal(row, rowTitles) {
        for (var i = 0; i < row.length; i++) {
            if (row[i].etk != undefined && row[i].etk < 0) {
                return true;
            }
        }
        return false;
    }

    /*
     * the ith item in attrIdxArray and attrIDArray, correspond to the attr at
     * tree level i the attrIdxArray[i] store the index of attr in the gts.row
     * the attrIDArray[i] store the attrID of attr at tree level i
     */
    function getAttrIdxArray(w) {

        var attrIDArray = w.attrIDArray;

        var m = w.model, gts = m.gts, rows = gts.row;
        var id = rows[0].id;

        attrIDArray[0] = id;
        for (var i = 1; i < rows.length; i++) {
            if (id == rows[i].id || id == rows[i].id + ":CG") {
                // same attr form, or CG
                // skip
            } else {
                // new attr
                id = rows[i].id;
                attrIDArray[i] = id;
            }
        }
    }

    /*
     * get the treeNode in this.tree according to the tree path
     */
    function getTreeNode(tree, treePath) {
        var treePathArray = treePath.split("_");
        var treeNode = tree;
        for (var i = 0; i < treePathArray.length; i++) {
            var idx = treePathArray[i];
            treeNode = treeNode.childrenTreeNodeList[idx];
        }
        return treeNode;
    }

    function getPreSiblingTreeNode(tree, treePath) {
        var treePathArray = treePath.split("_");
        var lowestLevelIdx = treePathArray[treePathArray.length - 1];
        if (lowestLevelIdx > 0) {
            //has previous siblings
            treePathArray[treePathArray.length - 1] = lowestLevelIdx - 1;
            var treeNode = tree;
            for (var i = 0; i < treePathArray.length; i++) {
                var idx = treePathArray[i];
                treeNode = treeNode.childrenTreeNodeList[idx];
            }
            return treeNode;
        } else {
            return null;
        }
        return null;
    }

    function getParentTreeNodeAtLevel(tree, treePath, level) {
        var treePathArray = treePath.split("_");
        var treeNode = tree;
        for (var i = 0; i <= level; i++) {
            var idx = treePathArray[i];
            treeNode = treeNode.childrenTreeNodeList[idx];
        }
        return treeNode;
    }

    function getBoolValue(value) {
        if (value === true || value === "true") {
            return true;
        }
        return false;
    }

    /*
     * used in expand all and collapse all set needExpand of treeNode according
     * to treeNode level
     */
    function setNeedExpandToLevel(tree, level) {
        if (!tree) {
            return;
        }

        if (tree.level <= level) {
            tree.needExpand = true;
        } else {
            tree.needExpand = false;
        }

        var treeNodeList = tree.childrenTreeNodeList;

        for (var j = 0; j < treeNodeList.length; j++) {
            setNeedExpandToLevel(treeNodeList[j], level);
        }

    }

    function initTree() {

        this.tree = {};
        this.tree.childrenTreeNodeList = [];
        this.tree.needExpand = true;
        //		this.tree.expanded = false;
        this.tree.treePath = "";
        this.tree.level = -1;

        this.attrIDArray = [];

        //selected treenode reference
        this.currSelectedObj = [];
        this.lastSelectedObj = [];

        this.initDockedHeadersDone = false;
    }

    // function printArray(array, arrayname){
    // var result = arrayname+": ";
    // for(var i = 0; i < array.length; i++){
    // result += array[i] + " ";
    // }
    // console.log(result+";");
    // }

    //lastTreePath[attrIdx] != currRow[attrIdx].idx
    function compareTreePath(src, des) {
        var count = src.length;
        if (des.length != count) {
            return false;
        }
        for (var i = 0; i < count - 1; i++) {
            if (src[i] != des[i].idx) {
                return false;
            }
        }
        return true;
    }

    /*
     * process the data model to tree structure For each treeNode, there are
     * following prop:
     * childrenTreeNodeList: an array store the children
     * treeNode level: first level is 0
     * rowIdx:
     * addedToDom: whether this treeNode is add to domNode
     * treePath: used to find this treeNode quickly
     * isLeaf: true or false needExpand: true or false(first set by vp.exps)
     */
    function convertDataToTreeModels(AttrIndexes) {
        var treeNodeList = this.tree.childrenTreeNodeList,
            model = this.model,
            rhs = model.ghs.rhs,
            rowTitles = model.gts.row,
            gvs = model.gvs,
            expsTree = model.vp.exps && model.vp.exps.tree;
        var allExpanded = expsTree && getBoolValue(expsTree.allExpanded);
        //if the mcStatus != undefined, we will use the mcStatus to define the tree expand
        var mcStatus = this.mcStatus;
        var expandToLevel = -1;
        var expandedEntryArray = mcStatus ? mcStatus.expandedEntryArray : expsTree && expsTree.expandedEntry;

        this.attrIDArray = [];

        var attrIdxArray = this.attrMapIdx;

        // attrIdxArray is used to skip the CG attr and multi attr form
        getAttrIdxArray(this);

        var rowAttrCount = rhs.items && rhs.items[0] && rhs.items[0].items
            && rhs.items[0].items.length;
        // level count is count for the tree level, -1 as there ia a dummy one at last position
        var levelCount = attrIdxArray.length - 1;
        this.maxTreeLevel = levelCount - 2;

        expandToLevel = mcStatus ? mcStatus.expandToLevel : allExpanded ? this.maxTreeLevel - 1 : -1;

        var lastTreePath = [];
        // init lastTreePath to all -1
        for (var i = 0; i < rowAttrCount; i++) {
            lastTreePath.push(-1);
        }
        var modelIdx = -1;
        var gridRowCount = rhs.items.length;
        if (this.mcStatus && this.mcStatus.currSelectedObj) {
            this.currSelectedObj = this.mcStatus.currSelectedObj;
        }
        for (var i = 0; i < gridRowCount; i++) {
            var currRow = rhs.items[i].items;
            var sameAsLastRow = compareTreePath(lastTreePath, currRow);
            if (!sameAsLastRow) {
                modelIdx++;
            } else {
                continue;
            }

            // rowAttrCount - 1 for the last is the time attr
            for (var j = 0; j < levelCount - 1; j++) {
                var attrIdx = attrIdxArray[j];
                var currSelectedNodeID = this.currSelectedObj[j];
                if (lastTreePath[attrIdx] != currRow[attrIdx].idx) {
                    var isSubtotal = isSubTotal(currRow);
                    // find the position in the treeList
                    var addToNodeList = treeNodeList;
                    var lastSameNode = null;
                    // construct treePath in this tree structure,like "0_1_1"
                    var treePath = "";
                    for (var k = 1; k <= j; k++) {
                        var treeNodeIdx = addToNodeList.length - 1;
                        if (k == j) {
                            lastSameNode = addToNodeList[treeNodeIdx];
                        }
                        addToNodeList = addToNodeList[treeNodeIdx].childrenTreeNodeList// addToNodeList[currRowIdx[attrIdxArray[k]]].childrenTreeNodeList;
                        treePath += treeNodeIdx;
                        treePath += "_";
                    }

                    if (isSubtotal && lastSameNode) {
                        lastSameNode.model = models[modelIdx];
                        break;
                    } else {

                        // add new treenode to the list
                        var newTreeNode = {};
                        newTreeNode.es = [];
                        //						for ( var l = attrIdxArray[j]; l < attrIdxArray[j + 1]; l++) {
                        newTreeNode.es.push(rowTitles[j].es[currRow[attrIdx].idx]);
                        //						}
                        var elem = rowTitles[j].es[currRow[attrIdx].idx];
                        newTreeNode.id = elem.id;
                        newTreeNode.n = elem.n;

                        newTreeNode.model = models[modelIdx];

                        newTreeNode.selected = false;
                        newTreeNode.childrenTreeNodeList = [];
                        // attr idx in model.gts.row[].es[]
                        newTreeNode.attrElemIdx = currRow[attrIdx].idx;
                        newTreeNode.isLeaf = (j == this.maxTreeLevel);
                        newTreeNode.level = j;

                        var preSiblingCount = addToNodeList.length;
                        newTreeNode.preSiblingCount = preSiblingCount;
                        newTreeNode.preSibling = preSiblingCount > 0 ? addToNodeList[preSiblingCount - 1] : null;

                        treePath += addToNodeList.length;
                        newTreeNode.treePath = treePath;

                        //						newTreeNode.idx = addToNodeList.length;
                        // console.log(treePath+ " ,gridrowidx:"+i);

                        addToNodeList.push(newTreeNode);

                        //						newTreeNode.expanded = false;
                        newTreeNode.needExpand = j <= expandToLevel ? true : false;//newTreeNode.isLeaf ? false : allExpanded;

                        //recalculate the currSelectedObj after on slice
                        if (currSelectedNodeID == newTreeNode.id) {
                            this.currSelectedObj[j] = newTreeNode;
                        }

                    }
                }
            }
            // update lastTreePath
            for (var j = 0; j < rowAttrCount; j++) {
                lastTreePath[j] = currRow[j].idx;
            }
        }

        if (expandToLevel < 0 && expandedEntryArray) {
            // compute the expandedEntry

            for (var i = 0; i < expandedEntryArray.length; i++) {
                var expandedEntry = expandedEntryArray[i];
                var treeNode = this.tree;
                for (var j = 0; j < expandedEntry.length; j++) {
                    var eid = expandedEntry[j].element;
                    var idx = mstrmojo.array.find(
                        treeNode.childrenTreeNodeList, 'id', eid);
                    if (idx < 0) {
                        break;
                    }
                    treeNode = treeNode.childrenTreeNodeList[idx];
                }
                treeNode.needExpand = true;
            }
        }

        //compute the postSiblingCount
        var preOrderTreeNodeQueue = [];
        preOrderTreeNodeQueue.push(this.tree);
        var treeNode = null;
        //pre order travel tree
        while (preOrderTreeNodeQueue.length > 0) {
            treeNode = preOrderTreeNodeQueue.pop();
            var treeNodeList = treeNode.childrenTreeNodeList;
            var childrenCount = treeNodeList.length;
            for (var i = childrenCount - 1; i >= 0; i--) {
                treeNode = treeNodeList[i];
                preOrderTreeNodeQueue.push(treeNode);
                treeNode.postSiblingCount = childrenCount - treeNode.preSiblingCount;
            }

        }

    }

    //column type
    var ATTR_NAME = 0,
        METRIC_NAME = 1,
        METRIC_VALUE = 2,
        CHART = 3,
        TREE_TRIANGLE = 4;
    DROP_SHADOW = 5;

    function scaleColumnWidthToFitWidget(colInfos, fitToWidth) {
        var colLen = colInfos.length;
        var totalWidth = 0;
        for (var i = 0; i < colLen; i++) {
            if (colInfos[i].type == TREE_TRIANGLE) {
                //totalWidth doesn't contains TRIANGLE_WIDTH, so we should minus it from fitToWidth
                fitToWidth -= TRIANGLE_WIDTH;
            } else {
                totalWidth += colInfos[i].colWidth;
            }
        }

        var scaleRatio = fitToWidth / totalWidth;

        for (var i = 0; i < colLen; i++) {
            if (colInfos[i].type == TREE_TRIANGLE) {
                colInfos[i].colWidth = TRIANGLE_WIDTH;
            } else {
                colInfos[i].colWidth = Math.round(colInfos[i].colWidth * scaleRatio);
            }
        }

        return scaleRatio;
    }

    function getContentOffsetWidth(rows, rowIdx, colIdx) {
        var rowInfo = rows[rowIdx],
            curM = rowInfo.model,
            elms = curM.elms,
            treeNode = rowInfo.treeNode,
            colInfos = this.colInfos,
            rowIdx = rowInfo.rowIdx,
            colCount = colInfos.length,
            colInfo = colInfos[colIdx],
            colIdx = colInfo.colIdx;

        if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_NAME) {
            if (this.isTreeMode) {
                var attrName = "";
                for (var k = 0; k < treeNode.es.length; k++) {
                    attrName += treeNode.es[k].n;
                }
                //TQMS 702933:
                if (attrName.indexOf("&lt;") >= 0) {
                    attrName = attrName.replace(/&lt;/g, "<");
                    attrName = attrName.replace(/&gt;/g, ">");
                }

                return this.getTextWidth(attrName, colInfo.valueCssClass, null, null, null, treeNode.level == 0 ? true : false);//, true);

            } else {
                attr = elms[colInfo.order];
                var attrName = attr ? attr.n : "";
                //TQMS 722933:
                if (attrName.indexOf("&lt;") >= 0) {
                    attrName = attrName.replace(/&lt;/g, "<");
                    attrName = attrName.replace(/&gt;/g, ">");
                }
                return this.getTextWidth(attrName, colInfo.valueCssClass, null, null, null, false);//, true);

            }

        }

        if (colInfo.type == METRIC_VALUE) {
            var metricIdx = -1;
            var idx = -1;

            if (this.isKPI) {
                //idx for refv in model
                idx = parseInt(colInfo.order) % this.otherProps.mnMetricsPerKPI;

                //idx for the metric in metric array
                var metricIdx = rowInfo.model.metricIdx + idx;
            } else {
                if (colInfo.type == METRIC_VALUE) {
                    metricIdx = parseInt(colInfo.order);
                    idx = metricIdx;
                }
            }

            var innerHTML = "";
            var cssClass = "";

            if (curM.refv[idx].ti === undefined) { // by defult, use regular value
                if (curM.refv[idx].ts === 4) { // xiawang: For web JSON, ts  === 4 means image
                    innerHTML = "<img src='" + curM.refv[idx].v + "'/>";
                } else {
                    innerHTML = curM.refv[idx].v;
                }
            } else { // there is threshold
                try { // we will try to apply the threshold. But if it fails, we shouldn't just fail the document rendering.
                    // Instead, we show default value;
                    var model = this.model;
                    var th = model.th['' + metricIdx];
                    var ti = curM.refv[idx].ti;

                    if (curM.refv[idx].ty === 4) { // xiawang: This is image type
                        var path;
                        if (th[ti] && th[ti].n) {
                            path = th[ti].n;
                        } else {
                            path = curM.refv[idx].v;
                        }
                        if (path.indexOf(":") >= 0) { // xiawang: Then it is absolute image path like http://.... or ftp://...
                            // do nothing
                        } else { // xiawang: Then it is relative image path like "Images/Arr3_Up.png". We should append base url to the image path
                            var baseURL;
                            try {
                                baseURL = mstrApp.getConfiguration().getHostUrlByProject(mstrApp.getCurrentProjectId());
                            } catch (err) {
                                baseURL = "";
                            }
                            path = baseURL + path;
                        }
                        innerHTML = "<img src='" + path + "'/>";
                    } else {
                        if (th[ti] && th[ti].n && th[ti].cni !== undefined) { // if the threshold text is there, use it
                            innerHTML = th[ti].n;
                        } else {
                            innerHTML = curM.refv[idx].v;
                        }
                        //							tds[j].style.fontSize = this.widget.fontSize; // xiawang: We should keep consistent with Flash and iOS to
                        // NOT inherite font size from Threshold at this time
                    }
                    cssClass = model.css[th[ti].cni].n;
                } catch (err) {
                    if (!innerHTML) { // xiawang: If innerHTML is not finalized yet.
                        innerHTML = curM.refv[idx].v;
                    }
                }
            }

            var className = "";
            if (cssClass) {
                className = colInfo.valueCssClass + " " + cssClass;
            } else if (this.valueCssClass) {
                className = colInfo.valueCssClass + " " + this.valueCssClass;
            } else {
                className = colInfo.valueCssClass;
            }

            return this.getTextWidth(innerHTML, className, null, null, null, this.isTreeMode && treeNode.level == 0 ? true : false);//, true);

        }

        return 0;

    }

    //padding added to column widths when smooth scroll is enable
    var paddingForSS = [5, 8, 10];
    var colWidthForChart = [100, 150, 200];
    var maxColWidthForAttr = [120, 150, 180];
    var maxColWidthForMetric = [100, 150, 200];
    var adjustWidthForColumnValue = [20, 40, 80];

    function updateColumnWidth() {
        var colInfos = this.colInfos,
            width = this.getWidth();

        if (this.enableSmoothScroll) {
            /*
             * sampling the first 50 rows of data( include column header )
             * Include all levels of the tree mode, not just the topmost( expanded level) during this calculation
             */
            var rows = this.isTreeMode ? getTreeNodeRows.call(this, true, 50) : this.rows;
            var rowCount = Math.min(rows.length, 50);
            var mcs = this.metricColumnsSpacing;
            var paddingWidth = paddingForSS[mcs];

            for (var j = 0; j < this.colInfos.length; j++) {
                var colInfo = this.colInfos[j];

                if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_NAME || colInfo.type == METRIC_VALUE) {

                    //calculate space required for longest metric data value
                    var maxColumnValueW = 0;
                    for (var i = 0; i < rowCount; i++) {
                        var columnW = getContentOffsetWidth.call(this, rows, i, j);
                        if (columnW > maxColumnValueW) {
                            maxColumnValueW = columnW;
                        }
                    }

                    //calculate space required for title of the column( 2 rows and word wrap)
                    var headerStr = colInfo.title;
                    var midPos = Math.round(headerStr.length / 2);

                    //						if(headerStr.charAt(midPos) != ' '){
                    //							//find the whitespace on left and right
                    //							var leftWSPos = headerStr.lastIndexOf(' ', midPos);
                    //							var rightWSPos = headerStr.indexOf(' ', midPos);
                    //
                    //							if(midPos - leftWSPos > rightWSPos - midPos){
                    //								midPos = rightWSPos;
                    //							}else{
                    //								midPos = leftWSPos;
                    //							}
                    //						}
                    var leftHalf = headerStr.slice(0, midPos);
                    var rightHalf = headerStr.slice(midPos);

                    var leftW = this.getTextWidth(leftHalf, colInfo.headerCssClass, null, null, null, true, false);
                    var rightW = this.getTextWidth(rightHalf, colInfo.headerCssClass, null, null, null, true, false);
                    var maxColumnHeaderW = Math.max(leftW, rightW);

                    var finalColumnW = 0;
                    if (maxColumnValueW > maxColumnHeaderW) {
                        finalColumnW = Math.min(maxColumnValueW, maxColWidthForMetric[mcs]);
                    } else {
                        finalColumnW = Math.min(maxColumnValueW + adjustWidthForColumnValue[mcs], maxColumnHeaderW, 100);
                    }

                    colInfo.colWidth = Math.round(finalColumnW + paddingWidth);
                    colInfo.padding.l = Math.floor(paddingWidth / 2);
                    colInfo.padding.r = Math.ceil(paddingWidth / 2);
                } else if (colInfo.type == TREE_TRIANGLE) {
                    colInfo.colWidth = Math.round(TRIANGLE_WIDTH);
                } else if (colInfo.type == DROP_SHADOW) {
                    colInfo.colWidth = Math.round(this.dropShadowWidth);
                } else {
                    //chart
                    colInfo.colWidth = Math.round(colWidthForChart[mcs] + paddingWidth);
                    colInfo.padding.l = Math.floor(paddingWidth / 2);
                    colInfo.padding.r = Math.ceil(paddingWidth / 2);
                }
            }

            //recalculate the leftWidth and rightWidth
            this.leftWidth = 0;
            for (var i = 0; i < this.attrColumnCount; i++) {
                this.leftWidth += colInfos[i].colWidth;
            }

            this.rightWidth = 0;
            var maxMetricWidth = 0;
            for (var i = this.attrColumnCount; i < colInfos.length; i++) {
                console.log(i + ": " + colInfos[i].colWidth);
                this.rightWidth += colInfos[i].colWidth;
                if (colInfos[i].colWidth > maxMetricWidth) {
                    maxMetricWidth = colInfos[i].colWidth;
                }
            }

            if (this.leftWidth + this.rightWidth < this.getWidth()) {
                //the default width doesn't fulfill the widget, no need to scroll
                var scaleRatio = scaleColumnWidthToFitWidget(this.colInfos, this.getWidth());

                this.dropShadowDiv.style.display = "none";
                this.enableSmoothScroll = false;
                this.scrollerConfig.hScroll = false;

                this.leftWidth = this.getWidth();
                this.rightWidth = 0;
                this.leftChart.style.width = this.getWidth() + 'px';
            } else {
                //can scroll, add the dropshadow column
                if (this.attrColumnCount >= 0) {
                    //make space for the drop shadow between attributes area and metric area
                    var spaceCol = {order: "",
                        type: DROP_SHADOW,
                        title: "",
                        titleAlign: textAlign.center,
                        colWidth: this.dropShadowWidth,
                        padding: {},
                        headerCssClass: this.headerCssClass,
                        valueCssClass: "",
                        colIdx: this.colInfos.length};
                    this.colInfos.splice(this.attrColumnCount, 0, spaceCol);
                    this.rightWidth += this.dropShadowWidth;
                }

                //all attributes + at least one metric ( the largest metric column )
                var requiredSpace = this.leftWidth + maxMetricWidth + this.dropShadowWidth;
                if (this.getWidth() < requiredSpace) {
                    var rightContainWidth = Math.min(maxMetricWidth + this.dropShadowWidth, 0.75 * this.getWidth());
                    this.leftWidth = this.getWidth() - rightContainWidth;

                    //The remaining space would be used by attributes equally
                    var attrWidth = this.treeColumnIdx > -1 ? (this.leftWidth - TRIANGLE_WIDTH) / (this.attrColumnCount - 1) : this.leftWidth / this.attrColumnCount;
                    for (var i = 0; i < this.attrColumnCount; i++) {
                        colInfos[i].colWidth = colInfos[i].type == TREE_TRIANGLE ? TRIANGLE_WIDTH : attrWidth;
                    }

                }

                this.dropShadowDiv.style.display = "block";
                this.scrollerConfig.hScroll = true;

                this.leftChart.style.width = this.leftWidth + 'px';
                this.rightChart.style.width = this.rightWidth + 'px';
                this.itemsContainerNode.style.width = ( this.getWidth() - this.leftWidth ) + 'px';
                this.itemsContainerNode.style.left = this.leftWidth + 'px';
            }

            for (var i = 0; i < this.colInfos.length; i++) {
                //rebuild the colIdx so that when we handle touch event, we can easily get the coresponding column
                this.colInfos[i].colIdx = i;

                if (this.colInfos[i].type == TREE_TRIANGLE) {
                    this.treeColumnIdx = i;
                }
            }

        } else {
            //not enable smooth scroll
            var colLen = colInfos.length;

            if (this.otherProps.mpColumnWidths.length > 0) {
                //TQMS 702512:When user define column width, we should scale up or scale down the column width, so as to fit the width of widget.
                scaleColumnWidthToFitWidget(this.colInfos, width);
            } else {
                if (this.treeColumnIdx > -1) {
                    colLen--;
                    width -= TRIANGLE_WIDTH;
                }
                var chWidth = Math.round(width / colLen);
                for (var i = 0; i < colInfos.length; i++) {
                    if (colInfos[i].type == TREE_TRIANGLE) {
                        colInfos[i].colWidth = TRIANGLE_WIDTH;
                    } else {
                        colInfos[i].colWidth = chWidth;
                    }

                }
            }
        }

    }

    /*
     * colInfos:
     * order:
     * colIdx: need this as when smooth scroll enable, the colInfos will be split to two part, but the colIdx is continuous
     * title:
     * titleAlign:
     * type:
     * colWidth:
     * padding:{l,r,t,p}
     * headerCssClass: classname templete
     * valueCssClass:
     * associateAttr: attr col index list.( the attr with same id but not same fid, that is the other attr form)
     */
    function buildColInfos(metricColIdx) {
        var m = this.model,
            rows = m.gts.row,
            cols = m.gts.col,
            mes = cols[metricColIdx].es,
            propValue = m.vp ? m.vp : {},
            width = this.getWidth(),
            otherProps = this.otherProps;

        otherProps.mpColumnWidths = propValue.cw ? propValue.cw.split(",") :
            (propValue.tcw ? propValue.tcw.split(",") : [] );

        var columnWidths = otherProps.mpColumnWidths;// as shortcut;
        //check wether columnWidth is invalid
        if (columnWidths.length != order.length) {
            columnWidths = [];
            otherProps.mpColumnWidths = [];
        }

        this.colInfos = [];

        this.showGauge = false;
        for (var i = 0; i < order.length; i++) {
            if (order[i] == "GaugeChart") {
                // xiawang: check if Gauge chart is shown. This will decide whether
                // the order "2" act as associated metric or normal metric
                this.showGauge = true;
            }
        }

        for (var i = 0, colInfoIdx = 0; i < order.length; i++) {
            var orderID = order[i];

            var colInfo = {order: orderID,
                colWidth: 0,
                padding: {},
                headerCssClass: " ",
                valueCssClass: " "};

            if (orderID == "LineChart") {
                colInfo.type = CHART;
                colInfo.title = this.sparklineProps.mstrHeader;
                colInfo.titleAlign = textAlign.center;
                colInfo.padding.l = Math.round(3 * zf);
                colInfo.padding.r = Math.round(3 * zf);
            } else if (orderID == "BarChart") {
                colInfo.type = CHART;
                colInfo.title = this.barProps.mstrHeader;
                colInfo.titleAlign = textAlign.center;
                colInfo.padding.l = Math.round(3 * zf);
                colInfo.padding.r = Math.round(3 * zf);
            } else if (orderID == "GaugeChart") {
                colInfo.type = CHART;
                colInfo.title = this.bulletProps.mstrHeader;
                colInfo.titleAlign = textAlign.center;
                colInfo.padding.l = Math.round(3 * zf);
                colInfo.padding.r = Math.round(3 * zf);
            } else if (orderID == 'Metric') {
                if (otherProps.mbHideTextColumns) {
                    //do not show this attribute
                    //do nothing, and continue
                    this.treeColumnIdx = -1;
                    continue;
                }
                colInfo.type = METRIC_NAME;
                colInfo.title = mstrmojo.desc(1158, 'Metrics');
                colInfo.titleAlign = textAlign.left;
                colInfo.valueCssClass += " " + this.valueCssClass;
                if (cols[metricColIdx].lm && cols[metricColIdx].lm.length > 0) {
                    colInfo.lm = cols[metricColIdx];
                    linkCount++;
                }
            } else if (orderID != parseInt(orderID)) {
                //attribute
                if (otherProps.mbHideTextColumns) {
                    //do not show this attribute
                    //do nothing, and continue
                    this.treeColumnIdx = -1;
                    continue;
                }

                //associate attributes is attributes that will always highlight together with this attributes
                //e.g. different attribute forms or treeNode and the triangle before it
                colInfo.associateAttr = [];

                if (this.isTreeMode) {
                    //show attribute and is tree mode
                    //add triangle column
                    this.treeColumnIdx = colInfoIdx;
                    this.colInfos[colInfoIdx] = {order: orderID,
                        type: TREE_TRIANGLE,
                        title: "",
                        titleAlign: textAlign.center,
                        colWidth: 0,
                        padding: {},
                        headerCssClass: this.headerCssClass,
                        valueCssClass: "",
                        colIdx: this.treeColumnIdx};
                    //set colWidth to 0, and set colWidth to TRIANGLE_WIDTH after updateColumnWidth

                    colInfo.associateAttr.push(colInfoIdx);

                    colInfoIdx++;
                }
                colInfo.type = ATTR_NAME;
                colInfo.title = ID_NAME[orderID];
                colInfo.titleAlign = textAlign.left;
                colInfo.valueCssClass += " " + this.valueCssClass;

                for (var j = 0; j < rows.length; j++) {
                    if (orderID.split(":")[0] == rows[j].id) {
                        //find the row

                        if (otherProps.mbInheritFromGridGraph && rows[j].cni !== undefined && m.css.length > rows[j].cni) {
                            colInfo.titleAlign = m.css[rows[j].cni].n;
                        }

                        var isFirstAttrForm = (orderID == rows[j].id + ":" + rows[j].fid);

                        if (isFirstAttrForm) {
                            //only count the different attribute form for one time
                            attrCount++;
                        }

                        if (rows[j].lm && rows[j].lm.length > 0 && rows[j].lm[0].links) {
                            colInfo.lm = rows[j];
                            if (isFirstAttrForm) {
                                linkCount++;
                            }

                        }

                        //find the associate attributes, which will be highlighed together
                        var fs = rows[j].fs;
                        for (var q = 0; q < fs.length; q++) {
                            var attrID = rows[j].id + ":" + fs[q].id;
                            if (attrID == orderID) {
                                //current attr
                                continue;
                            } else {
                                //different attr form
                                //find its column index
                                for (var n = 0; n < order.length; n++) {
                                    if (order[n] == attrID) {
                                        colInfo.associateAttr.push(n);
                                        break;
                                    }
                                }
                            }
                        }
                        break;
                    }
                }
            } else {
                //metric
                colInfo.type = METRIC_VALUE;
                var index = parseInt(orderID);
                if (index >= mes.length) {
                    continue;
                }
                if (otherProps.mbInheritFromGridGraph && mes[index].cni !== undefined && m.css.length > mes[index].cni) {
                    colInfo.titleAlign = m.css[mes[index].cni].n;
                } else {
                    colInfo.titleAlign = textAlign.right; // default to right
                }
                if (orderID == "0") {
                    if (this.sparklineProps.mstrAssMetric) {
                        // xiawang: add support for Ass Metric name for LineChart and Bar Chart
                        colInfo.title = this.sparklineProps.mstrAssMetric;
                    } else if (this.isKPI) {
                        colInfo.title = "";
                    } else {
                        colInfo.title = mes[index].n;
                    }
                } else if (orderID == "2") {
                    if (this.bulletProps.mstrAssMetric) {
                        // xiawang: add support for Ass Metric name for Bullet Chart
                        colInfo.title = this.bulletProps.mstrAssMetric;
                    } else if (this.isKPI && this.showGauge) {
                        colInfo.title = "";
                    } else {
                        colInfo.title = mes[index].n;
                    }
                } else {
                    colInfo.title = mes[index].n;
                }
                if (cols[metricColIdx].lm[index].links) {
                    colInfo.lm = cols[metricColIdx];
                    linkCount++;
                }

            }

            colInfo.valueCssClass += " microchart-table-text " + colInfo.titleAlign;
            colInfo.headerCssClass += " microchart-table-text " + colInfo.titleAlign + " " + this.headerCssClass;

            if (columnWidths.length > 0) {
                colInfo.colWidth = parseFloat(columnWidths[i]);
            }
            colInfo.colIdx = colInfoIdx;
            this.colInfos[colInfoIdx++] = colInfo;
        }

        if (order.length == 0) {
            colInfos[0].title = rows[0].n;
            for (var i = 1; i < rows.length - GFL; i++) {
                colInfos[i].title = rows[i].n;
            }
        }

        //if enable smooth scroll, make attr on the left
        if (this.enableSmoothScroll) {
            var belongToLeft = function (type) {
                switch (type) {
                case ATTR_NAME:
                    return -1;
                case TREE_TRIANGLE:
                    return -1;
                case METRIC_NAME:
                    return -1;
                default:
                    return 1;
                }
            }

            var sortFunc = function (colInfo1, colInfo2) {
                if (belongToLeft(colInfo1.type) * belongToLeft(colInfo2.type) > 0) {
                    //both in left or both in right
                    return colInfo1.colIdx < colInfo2.colIdx ? -1 : 1;
                } else {
                    return belongToLeft(colInfo1.type);
                }
            }

            this.colInfos.sort(sortFunc);

            for (var i = 0; i < this.colInfos.length; i++) {
                if (belongToLeft(this.colInfos[i].type) > 0) {
                    //none attr column
                    this.attrColumnCount = i;
                    break;
                }
            }

        }

    }

    function convertDataToModels() {
        init(this);

        var m = this.model,
            cols = m.gts.col,
            metricL = m.gts.col[0].es.length,
            rows = m.gts.row,
            rowL = rows.length,
            rl = m.gvs.items.length,
            propValue = m.vp ? m.vp : {};

        if (rowL === 0 || metricL === 0 || cols.length > 1) {
            var errmsg = "The widget requires at least two attributes on row axis and one metrics in column axis OR exactly one attribute on row axis and at least one metric on column axis for KPI List mode.";
            m.err = mstrmojo.desc(8424, errmsg);
            return;
        }

        //show it as non-treemode, if the attr is less than 3
        if (this.isTreeMode) {
            var row = this.model.gts.row;
            if (row.length < 3) {
                this.isTreeMode = false;
            }

        }

        var len = rows.length;
        var gfid = rows[len - 1].id;
        len = len - 2;
        while (len >= 0) {
            if (gfid == rows[len].id) {
                GFL++;
                len--;
            } else {
                break;
            }
        }

        if (rowL <= GFL) {
            this.isKPI = true;
        }
        for (var i = 0; i < rows.length; i++) {
            if (rows[i].otp == 1) {
                //is Custom Group
                rows[i].otp = -1;
                while (++i < rows.length && rows[i].otp == 1) {
                    rows[i].id += ":CG";
                    rows[i].n = " ";
                    rows[i].otp = -1;
                }
            }
        }

        for (var i = 0; i < rows.length; i++) {
            if (rows[i].fs && rows[i].fs.length > 0) {
                for (var q = 0; q < rows[i].fs.length; q++) {
                    // only the first one display the name
                    if (q == 0) {
                        ID_NAME[rows[i].id + ":" + rows[i].fs[q].id] = rows[i].n;
                    } else {
                        ID_NAME[rows[i].id + ":" + rows[i].fs[q].id] = " ";
                    }
                }
            }
            if (rows[i].fid && rows[i].fid.length > 0) {
                /*
                 *  in multi form case, .dn = "Region" while .n = "Region DESC" or "Region ID"
                 *  we only need to display a single title if .dn is used. Otherwise, if .n is used, we display both
                 */
                // xiawang: TQMS 532304 update: we should follow web behavior
                // rather than iOS behavior. So we should always use .n
                var headerTitle;
                headerTitle = rows[i].n; // rows[i].dn || rows[i].n;
                ID_NAME[rows[i].id] = headerTitle;
                ID_NAME[rows[i].id + ":" + rows[i].fid] = headerTitle;
            } else {
                ID_NAME[rows[i].id] = rows[i].n;
            }
        }

        /*
         * build METRIC_INDEX map
         * key:metric name or metric ID
         * value:metric index
         */
        var metricIdx = -1;
        for (var i = 0; i < cols.length; i++) {
            if (cols[i].n = "Metrics") {
                metricIdx = i;
                var mes = cols[i].es;
                for (var j = 0; j < mes.length; j++) {
                    ID_NAME[mes[j].oid] = mes[j].n;
                    METRIC_INDEX[mes[j].n] = j;
                    METRIC_INDEX[mes[j].oid] = j;
                    METRICS[j] = mes[j].n;
                }
            }
        }

        var orderValid = true;
        if (!propValue.co && !propValue.tco) {
            orderValid = false;
        } else {
            order = propValue.tco ? propValue.tco.split(",") : propValue.co.split(",");
            orderValid = processAndCheckOrderValid.call(this);
            if (!orderValid) {
                //do not use the column width too
                propValue.cw = null;
                propValue.tcw = null;
            }
        }

        if (!orderValid) {
            order = [];

            if (!this.isKPI) {
                createNonKPIDefaultCol.call(this);
            } else {
                createKPIDefaultCol.call(this);

            }
        }

        var otherProps = this.otherProps;
        // Set the background opacity TQMS 531313
        //		this.domNode.style.background = "rgba(255, 255, 255," + otherProps.mfBkgOpacity + ")";

        if (otherProps.mpSortKey && otherProps.mpSortKey.length > 0) {
            var tempSortKey = "";
            for (var i = 0; i < otherProps.mpSortKey.length; i++) {
                if (otherProps.mpSortKey[i] == '_') {
                    break;
                }
                tempSortKey += otherProps.mpSortKey[i];
            }

            var mIdx = METRIC_INDEX[tempSortKey];
            if (mIdx >= 0) {
                //sort by metric value
                otherProps.mpSortKey = mIdx
            } else {
                //sort by attr, find attr id
                for (var id in ID_NAME) {
                    if (ID_NAME[id] == tempSortKey) {
                        otherProps.mpSortKey = id;
                        break;
                    }
                }

                if (!ID_NAME[otherProps.mpSortKey]) {
                    //not found this sort key
                    otherProps.mpSortKey = null;
                }
            }
        } else {
            otherProps.mpSortKey = null;
        }

        // xiawang: Inherit from GridGraph. We should assign headerCssClass and valueCssClass
        // TQMS 723274: disable 'Inherit grid formatting' when use dark theme or light theme
        if (otherProps.mbInheritFromGridGraph && (this.theme == CUSTOM_DARK_THEME || this.theme == CUSTOM_LIGHT_THEME)) {
            try {
                var headerIndex = m.headercni ? m.headercni : 0;
                var valueIndex = m.valuecni ? m.valuecni : (m.css.length - 1);

                var getCssClass = function (name) {
                    if (name) {
                        //!= undefined && != null
                        return name;
                    }

                    return "";

                }

                this.headerCssClass = getCssClass(m.css[headerIndex].n);
                this.valueCssClass = getCssClass(m.css[valueIndex].n);

                //get the default fontSize from valueCssClass
                if (this.valueCssClass && this.valueCssClass.length > 0) {
                    var textSpan = this.textSpan;
                    textSpan.className = this.valueCssClass;
                    textSpan.style.font = "";

                    this.fontSize = mstrmojo.css.getStyleValue(textSpan, 'fontSize');

                }

                //TQMS 712632: if the text height is larger than the rowHeight, change the rowHeight to hold the text
                var fontHeight = this.getTextHeight("a", this.valueCssClass, true);
                if (fontHeight > otherProps.mRowHeight) {
                    otherProps.mRowHeight = fontHeight;
                }
            } catch (err) {
                // do nothing if error happens
            }
        }

        // xiawang: The header of each chart and lengend should follow locale specific settings.
        var applyLocale = function (proOwner, proName, dftStr, hasBracket, descID) {
            var compareStr = dftStr;
            var returnStr;
            if (hasBracket) {
                compareStr = "[" + dftStr + "]";
            }

            if (proOwner[proName] === compareStr) {
                // need replacement
                returnStr = mstrmojo.desc(descID, dftStr);
                if (hasBracket) {
                    returnStr = "[" + returnStr + "]";
                }
                proOwner[proName] = returnStr;
            }
        };

        buildColInfos.call(this, metricIdx);

        if (!this.isKPI) {
            convertAttributeDrivenData(this);
        } else {

            convert(this);
        }

        // if no data, display the error message
        var kpi = otherProps.mnMetricsPerKPI;
        var m = this.model;

        if (this.isKPI && metricL < kpi) {
            var errmsg = "Metric per KPI should be at least 1 or less than or equal to the total number of Metrics in the widget";
            m.err = errmsg;
            return;
        }

        if (models.length == 0) {
            var errmsg = "No data returned for this view, this might be because the applied filter excludes all data";
            m.err = errmsg;
            return;
        }

        this.buildRows();

        updateColumnWidth.call(this);

        this.showMinLabel = bulletShowMinLabel.call(this);

    }

    /*
     * xiawang: other than check the order valid, we may also convert the order into expected order
     */
    function processAndCheckOrderValid() {

        for (var i = 0; i < order.length; i++) {
            if (order[i] == "LineChart" || order[i] == "BarChart"
                || order[i] == "GaugeChart" || order[i] == "Metric") {
                // xiawang: Metric is also a valid string
                continue;
            }
            if (order[i].length < 3) {
                return false;
            }
            var tstStr = order[i];
            var len = tstStr.length;

            if (tstStr[len - 2] == '|') {
                order[i] = tstStr = tstStr.substring(0, len - 2);
            }
            if (!ID_NAME[tstStr]) {
                return false;
            } else if (METRIC_INDEX[tstStr] !== undefined) {
                // xiawang: we should make sure that every order is string
                order[i] = METRIC_INDEX[tstStr] + "";
            } else if (this.isKPI) {
                order[i] = "0";
            }
        }

        if (this.enableSmoothScroll) {
            return false;
        }

        var m = this.model,
            metricES = m.gts.col[0].es;
        var columnIDs = [],
            cIDs = [];
        if (this.isTreeMode) {
            columnIDs = this.otherProps.mpColumnIDsInTreeMode;
            if (columnIDs.length == 1) {
                return false;
            }

            for (var i = 0; i < metricES.length; i++) {
                var metricID = metricES[i].oid;
                cIDs.push(metricID);
            }
        } else {
            //non tree mode
            columnIDs = this.otherProps.mpColumnIDs;
            if (this.isKPI) {
                if (columnIDs.length <= 1) {
                    // TQMS 538305
                    // xiawang: For some old document, the cid length is less than 1. We then should not rely on .co property
                    return false;
                }

                cIDs.push("Metric");
                var metricPerKPI = this.otherProps.mnMetricsPerKPI;
                if (metricPerKPI > 2) {
                    for (var i = 0; i < metricPerKPI; i++) {
                        if (i % metricPerKPI <= 1) {
                            //exclude the first and second attribute
                            continue;
                        }
                        var metricID = metricES[i].oid;
                        cIDs.push(metricID);
                    }
                }

            } else {// no KPI
                if (columnIDs.length == 1) {
                    return false;
                }
                var rows = m.gts.row,
                    attrCnt = rows.length - 1,
                    rowHeaderCnt = 0;

                for (var i = 0; i < attrCnt; i++) {
                    var attr = rows[i],
                        attrFormCnt = attr.fs && attr.fs.length;
                    cIDs.push(attr.id);

                    for (var j = 1; j < attrFormCnt; j++) {
                        cIDs.push(attr.fs[j].id);
                    }
                    rowHeaderCnt += attrFormCnt;
                }

                for (var i = 0; i < metricES.length; i++) {
                    var metricID = metricES[i].oid;
                    cIDs.push(metricID);
                }

            }

        }

        if (cIDs.length != columnIDs.length) {
            return false;
        }
        for (var i = 0; i < cIDs.length; i++) {
            var metricID = cIDs[i];
            if (mstrmojo.array.indexOf(columnIDs, metricID) == -1) {
                //can't find this metric
                return false;
            }
        }

        return true;
    }

    function createKPIDefaultCol() {
        var ind = 0;
        var otherProps = this.otherProps,
            sparklineProps = this.sparklineProps,
            barProps = this.barProps,
            bulletProps = this.bulletProps;

        order[ind++] = "Metric";
        var kpi = otherProps.mnMetricsPerKPI;
        if (isNaN(kpi)) {
            kpi = 1;
        }
        var firstChartShow = false;
        if (sparklineProps.mbShow) {
            firstChartShow = true;
            order[ind++] = "LineChart";
        }
        if (barProps.mbShow) {
            firstChartShow = true;
            order[ind++] = "BarChart";
        }
        if ((!firstChartShow && otherProps.mbShowForHiddenGraphs)
            || (firstChartShow && sparklineProps.mbAssMetric)) {
            // xiawang: TQMS533526 the associated metric should only show if at
            // least one of line chart and bar chart is shown
            order[ind++] = "0";
        }

        if (kpi >= 7) {
            if (bulletProps.mbShow) {
                if (bulletProps.mbAssMetric) {
                    order[ind++] = "2";
                }
                order[ind++] = "GaugeChart";
            } else if (otherProps.mbShowForHiddenGraphs) {
                for (var i = 3; i <= kpi && i <= 7; i++) {
                    order[ind++] = "" + (i - 1);
                }
            }
            for (var i = 8; i <= kpi; i++) {
                order[ind++] = "" + (i - 1);
            }
        } else {
            for (var i = 3; i <= kpi; i++) {
                order[ind++] = "" + (i - 1);
            }
        }
    }

    function createNonKPIDefaultCol() {
        var ind = 0;
        var m = this.model,
            rows = m.gts.row,
            cols = m.gts.col;
        var mtrcNum = 0;

        if (this.isTreeMode) {
            order[ind++] = rows[0].id;
        } else {

            for (var i = 0; i < rows.length - GFL; i++) {
                if (rows[i].fs && rows[i].fs.length > 0) {
                    for (var q = 0; q < rows[i].fs.length; q++) {
                        order[ind++] = rows[i].id + ":" + rows[i].fs[q].id;
                    }
                } else {
                    if (rows[i].fid && rows[i].fid.length > 0) {
                        order[ind++] = rows[i].id + ":" + rows[i].fid;
                    } else {
                        order[ind++] = rows[i].id;
                    }
                }
            }
        }

        for (var i = 0; i < cols.length; i++) {
            if (cols[i].n = "Metrics") {
                mtrcNum = cols[i].es.length;
            }
        }

        var firstChartShow = false;
        if (this.sparklineProps.mbShow) {
            firstChartShow = true;
            order[ind++] = "LineChart";
        }
        if (this.barProps.mbShow) {
            firstChartShow = true;
            order[ind++] = "BarChart";
        }
        if ((!firstChartShow && this.otherProps.mbShowForHiddenGraphs)
            || (firstChartShow && this.sparklineProps.mbAssMetric)) {
            // xiawang: TQMS533526 the associated metric should only show if at
            // least one of line chart and bar chart is shown
            order[ind++] = "0";
        }

        if (mtrcNum >= 7) {
            if (this.bulletProps.mbShow) {
                if (this.bulletProps.mbAssMetric) {
                    order[ind++] = "2";
                }
                order[ind++] = "GaugeChart";
            } else if (this.otherProps.mbShowForHiddenGraphs) {
                for (var i = 3; i <= 7 && i <= mtrcNum; i++) {
                    order[ind++] = "" + (i - 1);
                }
            }
            for (var i = 8; i <= mtrcNum; i++) {
                order[ind++] = "" + (i - 1);
            }
        } else {
            for (var i = 3; i <= mtrcNum; i++) {
                order[ind++] = "" + (i - 1);
            }
        }
    }

    function convertAttributeDrivenData(w) {
        var m = w.model,
            metricES = m.gts.col[0].es,
            rows = m.gts.row,
            gvsRows = m.gvs.items,
            rl = m.gvs.items.length,
            rhs = m.ghs.rhs.items;

        var rowsLen = rows.length;
        //last attr idx
        var lai = rows.length - GFL;
        //second last attr idx
        var slai = lai - 1;

        var idxPos = 0;
        w.attrMapIdx = []; // xiawang: the attrMapIdx key is attr index.
        // value is the starting idx position of that attr
        var attrMapIdx = w.attrMapIdx;
        for (var q = 0; q < rowsLen; q++) {
            attrMapIdx[q] = idxPos;
            if (!rows[q].fs || rows[q].fs.length == 0) {
                idxPos++;
            } else {
                idxPos += rows[q].fs.length;
            }
        }

        // this last is dummy one but it is helpful if we want to find the last idx pos of (attLen - 1)th attribute
        attrMapIdx[rowsLen] = idxPos;

        var attrName = rows[lai].dn || rows[lai].n;

        var fnCopyArray = function (src, isIdx) {
            var dest = [];
            for (var i = 0; i < src.length; i++) {
                dest[i] = src[i];
            }
            return dest;
        };

        /**
         * xiawang: the ctlMatrix is instance level object and it use attribute
         * ID as key for each controlInfo object the controlInfo object has
         * following object
         *
         * es: linked to attribute.es to store the attribute elements
         * sc: linked to attribute.sc to store the control info
         * map: this is an array to map from row column into corresponding idx
         * selectedIdx: attr idx for which is selected
         */
        w.ctlMatrix = {};
        w.isAllAttrSelectable = true;
        for (var i = 0; i < lai; i++) {
            var attribute = rows[i];
            if (!attribute.sc || !attribute.sc.tks || attribute.sc.tks == "") {
                w.isAllAttrSelectable = false;
                continue;
            }

            w.ctlMatrix[attribute.id] = {
                es: attribute.es,
                sc: attribute.sc,
                map: [],
                selectedIdx: {},
                colIdx: w.getColIdx(attribute.id)
            };

            //TQMS 568704: if all is selected, it should be initially highlighted
            if (attribute.sc.all && attribute.sc.allSelected) {
                w.ctlMatrix[attribute.id].selectedIdx["-1"] = true;
            }
        }

        /*
         * xiawang: process RHS into AttrIndexes array. The reason is to handle
         * special case for un-merged row header grid {0, 0}, {1}, {2}, {1, 0},
         * {1}, {2}
         */
        var AttrIndexes = [];
        var i = 0, j = 0;
        var template = [];
        var tempLen = 0;
        for (i = 0; i < rhs.length; i++) {
            if (i === 0) {
                // For the first row, set up the template
                AttrIndexes[0] = [];
                for (j = 0; j < rhs[i].items.length; j++) {
                    AttrIndexes[0][j] = rhs[0].items[j].idx;
                    if (AttrIndexes[0][j] < 0 && rows[j].otp == -1) {
                        /*
                         * for the CG attr, the " " attr idx is set to
                         * e.g. Category Sales " "			0	4
                         *      Category Sales Books		0	0
                         *      Category Sales Electronics	0	1
                         *      Category Sales Movies		0	2
                         *      Category Sales Music		0	3
                         *      Top 5 Items by Revenue " "	1	5
                         *      Bottom 3 Suppliers	   " "	2	6
                         */
                        AttrIndexes[0][j] = rows[j].es.length + AttrIndexes[0][j - 1];
                    }
                    // cet -- default highlight
                    if (rhs[0].items[j].cet) {
                        var id = rhs[0].items[j].cet;
                        if (order[j] == id + ":CG") {
                            // for custom group, we use seperate control matrix
                            id += ":CG";
                        }
                        var controlMatrix = w.ctlMatrix[id];
                        if (controlMatrix && !controlMatrix.selectedIdx[-1]) {
                            //if it exist and "All" is not selected
                            controlMatrix.selectedIdx[AttrIndexes[0][j]] = true;
                        }
                    }
                }
                template = fnCopyArray(AttrIndexes[0]);
                tempLen = template.length;
                continue;
            }
            var rhsRow = rhs[i].items;
            var rhsRowLen = rhsRow.length;
            for (j = 1; j <= rhsRowLen; j++) {
                template[tempLen - j] = rhsRow[rhsRowLen - j].idx;

                if (template[tempLen - j] < 0) {
                    //find the attribute index
                    var k = 0;
                    for (; k < attrMapIdx.length; k++) {
                        if (tempLen - j < attrMapIdx[k]) {
                            break;
                        }
                    }
                    template[tempLen - j] = rows[k - 1].es.length + rhsRow[rhsRowLen - j - 1].idx;
                }
                if (rhsRow[rhsRowLen - j].cet) {
                    var id = rhsRow[rhsRowLen - j].cet;
                    if (order[rhsRowLen - j] == id + ":CG") {
                        // for custom group, we use seperate control matrix
                        id += ":CG";
                    }
                    var controlMatrix = w.ctlMatrix[id];
                    if (controlMatrix) {
                        delete controlMatrix.selectedIdx[-1];
                        controlMatrix.selectedIdx[template[tempLen - j]] = true;
                    }
                }
            }
            AttrIndexes[i] = fnCopyArray(template);
        }

        var fnBEL = function (index) {
            var elms = {};
            var ind = 0;
            for (var i = 0; i < rows.length - GFL; i++) {
                var fL = rows[i].fs.length;
                if (fL < 1) {
                    fL = 1;
                }
                var attId = rows[i].id;
                if (AttrIndexes[index][ind] < 0) {
                    elms[attId] = "";
                } else {
                    elms[attId] = rows[i].es[AttrIndexes[index][ind]];
                }

                if (elms[attId] == undefined) {
                    elms[attId] = {n: ""};
                }

                var fidId = rows[i].fid;
                if (fidId && fidId.length > 0) {
                    elms[attId + ":" + fidId] = rows[i].es[AttrIndexes[index][ind]];
                }
                for (var j = 0; j < fL; j++) {
                    var formId = "";
                    if (rows[i].fs && rows[i].fs[j]) {
                        formId = rows[i].fs[j].id;
                    }
                    if (formId && formId.length > 0) {
                        var afID = attId + ":" + formId;
                        elms[afID] = rows[i].es[AttrIndexes[index][ind]];
                    }
                    ind++;
                }
            }

            return elms;
        };

        var s = {
            v: [],
            rv: [],
            thClr: [],
            hi: [ 0 ]
        };
        var referValue = [];
        var sortValue = 0;
        var attrElems = null;
        var ch = [
            {
                items: [
                    {
                        n: metricES[0].n
                    }
                ]
            }
        ];

        var c = [],
            baseRow = [],
            j = 0, si = 0,
            isTotal = false,
            compareResult = false;

        function indexChanged(baseRow, newRow) {
            // xiawang: we should compare all the idx from index 0 to idxPos - 1 to determine if row changed
            if (baseRow.length != newRow.length) {
                return true;
            }
            var endIndex = attrMapIdx[lai] - 1;
            if (endIndex >= baseRow.length) {
                endIndex = baseRow.length - 1;
            }
            for (var i = endIndex; i >= 0; i--) {
                // xiawang: There are more chances for the end to be different
                if (baseRow[i] != newRow[i]) {
                    return true;
                }
            }
            return false;
        }

        for (var i = 0; i <= rl; i++) {
            if (i === 0) {
                baseRow = AttrIndexes[i];
            } else if ((compareResult = (i === rl || indexChanged(baseRow,
                AttrIndexes[i])))
                || isTotal) {
                if (isTotal && !compareResult) {
                    // xiawang: we only post the changed one last data for the total case.
                    // so we skip if index not changed or not the last row
                } else {
                    // xiawang: start to update the map of ctlMatrix
                    for (var x = 0; x < lai; x++) {
                        var controlMatrix = w.ctlMatrix[rows[x].id];
                        if (controlMatrix) {
                            controlMatrix.map[si] = AttrIndexes[i - 1][x];
                        }
                    }
                    models[si] = {
                        sortV: sortValue,
                        isTotal: isTotal,
                        refv: referValue,
                        elms: attrElems,
                        tr: s.v[s.v.length - 1],
                        model: {
                            categories: {
                                items: c,
                                tn: attrName
                            },
                            mtrcs: {
                                items: METRICS
                            },
                            colHeaders: ch,
                            series: [ s ],
                            rowHeaders: [
                                {
                                    n: rows[lai].n
                                }
                            ]
                        }
                    };
                    si++;
                    if (i === rl) {
                        break; // xiawang: i == rl is the ending signal
                    }
                }
                //TQMS 702277:add threshold for bar chart
                s = {
                    v: [],
                    rv: [],
                    thClr: [],
                    hi: [ 0 ]
                };
                referValue = [];

                c = [];

                baseRow = AttrIndexes[i];
                j = 0;
                isTotal = false;
            }

            var otherProps = w.otherProps;

            // xiawang: TQMS 531618;When subtotal is enabled in the grid the
            // value of reference line in sparkline and bar graph should be the
            // total value of the second metric
            for (var p = 0; p < gvsRows[i].items.length; p++) {
                if (!referValue[p]) {
                    referValue[p] = {};
                }
                referValue[p] = gvsRows[i].items[p];
            }

            attrElems = fnBEL(i);

            if (otherProps.mpSortKey != null) {
                var sortByAttr = ( otherProps.mpSortKey != parseInt(otherProps.mpSortKey) );
                if (sortByAttr) {
                    sortValue = attrElems[otherProps.mpSortKey].n;
                } else {
                    //sort by metric value
                    sortValue = parseFloat(referValue[otherProps.mpSortKey].rv);
                }

            }

            if (!w.isTreeMode) { //TODO: test this issue
                // xianzhang: for none tree mode
                // xiawang: TQMS 531936: If the slai attribute is a subtotal value,
                // we should not show charts for this graph
                var isSubTotal = function (attr) {
                    return (attr.id && attr.id.substring(0, 1) === "D")
                        || (attr.id === undefined && attr.n === "Total")
                }
                var attrSlai = rows[slai].es[AttrIndexes[i][attrMapIdx[slai]]];
                if (attrSlai && isSubTotal(attrSlai)) {
                    // The second last attribute is a subtotal value
                    isTotal = true;
                    continue;
                }

                var attr = rows[lai].es[AttrIndexes[i][attrMapIdx[lai]]];
                if (attr && isSubTotal(attr)) {
                    // xiawang: TQMS 531573 The subtotal value should not be
                    // displayed in the sparkline and bar graph
                    continue;
                }
            }

            var attrElement = "";
            var attIdxPos = attrMapIdx[lai];
            var thisAtt = null;
            var thisAttFormLen = 1;
            try {
                for (var p = 0; p < GFL; p++) {
                    thisAtt = rows[lai + p];
                    if (thisAtt.fs && thisAtt.fs.length > 0) {
                        // sometimes thisAtt.fs is an empty array, this should go to default case
                        thisAttFormLen = thisAtt.fs.length;
                    } else {
                        thisAttFormLen = 1;
                    }
                    for (var pp = 0; pp < thisAttFormLen; pp++) {
                        attrElement += " " + thisAtt.es[AttrIndexes[i][attIdxPos]].n;
                        attIdxPos++;
                    }
                }
            } catch (err) {
                // just to keep it working if error happens;
            }

            c[j] = attrElement;

            var item = gvsRows[i].items[0];
            s.v[j] = item.v;
            s.rv[j] = item.rv;

            var th = m.th && m.th['0'];
            var ti = item.ti;
            /*
             * threshold color for bar chart is apply under following conditions:
             * 1. inherit from grid and graph
             * 2. threshold not apply to chart == false
             */
            if (ti != undefined && item.ty == 2 && th[ti].cni != undefined && otherProps.mbInheritFromGridGraph) {
                this.textSpan.className = m.css[th[ti].cni].n;
                var compStyle = mstrmojo.css.getComputedStyle(this.textSpan);
                s.thClr[j] = compStyle.backgroundColor;
                if (s.thClr[j] == "rgba(0, 0, 0, 0)") {
                    s.thClr[j] = null;
                }
            } else {
                s.thClr[j] = null;
            }

            j++;
        }

        // sort the models with the sort key
        //		var sortFunc = function(m1, m2){
        //			var sortV1 = m1.sortV,
        //				sortV2 = m2.sortV;
        //			if (otherProps.mbSortDescend){
        //				if(sortV1 > sortV2) {
        //					return -1;
        //				}else if(sortV1 > sortV2){
        //					return 1;
        //				}else{
        //					return 0;
        //				}
        //			}else{
        //				if(sortV1 > sortV2) {
        //					return 1;
        //				}else if(sortV1 > sortV2){
        //					return -1;
        //				}else{
        //					return 0;
        //				}
        //			}
        //		};

        //		models.sort(sortFunc);

        if (!w.isTreeMode && otherProps.mpSortKey != null) {
            var rowCount = models.length;
            for (var i = 0; i < rowCount; i++) {
                for (var j = 0; j < rowCount - 1; j++) {
                    if ((otherProps.mbSortDescend && models[j].sortV < models[j + 1].sortV)
                        || (!otherProps.mbSortDescend && models[j].sortV > models[j + 1].sortV)) {
                        var temp = models[j];
                        models[j] = models[j + 1];
                        models[j + 1] = temp;
                    }
                }
            }
        }

        if (w.isTreeMode) {
            // is tree display
            convertDataToTreeModels.call(w, AttrIndexes);

        }

    }

    function convert(w) {
        var m = w.model,
            rows = m.gts.row,
            cols = m.gts.col,
            cs = rows[rows.length - 1].es,
            sn = cols[0].es,
            idxItems = m.ghs.rhs.items,
            csl = idxItems.length,
            v = m.gvs.items,
            ch = [];

        for (var i = 0; i < sn.length; i++) {
            if (!ch[0]) {
                ch[0] = {
                    items: []
                };
            }
            ch[0].items[i] = [
                {
                    n: sn[i].n
                }
            ];
        }

        var vl = v[0].items.length;

        var series = [];
        var c = [];
        var attrName = m.gts.row[0].dn || m.gts.row[0].n;

        var referValue = [];
        var kpi = w.otherProps.mnMetricsPerKPI;
        if (isNaN(kpi)) {
            kpi = 1;
        }
        var sNum = 0;
        var metrixIdxArray = [];
        for (var i = 0; i + kpi <= vl; i = i + kpi) {
            var fv = [];
            var rv = [];
            series[sNum] = {
                v: fv,
                rv: rv,
                hi: [ 0 ]
            };
            var refV = [];
            referValue[sNum] = {
                refv: refV
            };
            for (var j = 0; j < kpi; j++) {
                referValue[sNum].refv[j] = v[csl - 1].items[i + j];
            }
            metrixIdxArray[sNum] = i;
            sNum++;
        }

        for (var i = 0; i < csl; i++) {
            var idxItemsItems = idxItems[i].items;
            //in the case if we have CG, the idx might not be equal to row index
            var idx = idxItemsItems[idxItemsItems.length - 1].idx;
            if (isNaN(idx)) {
                console.log("idx is not a number!" + idx);
                // this is unexpected. However, if it happens, we should still be able to handle it
                c[i] = cs[i].n;
            } else {
                if (idx < 0) {
                    c[i] = "";
                } else {
                    c[i] = cs[idx].n;
                }
                // so we should always use the last idx of any row
                for (var k = 2; k <= idxItemsItems.length && k <= rows.length; k++) {
                    // in case of CG and in KPI,then all idx referes to CG
                    var anotherIdx = idxItemsItems[idxItemsItems.length - k].idx;
                    if (!isNaN(anotherIdx)) {
                        // if previous idx is different as current idx, we should show both string
                        c[i] = rows[rows.length - k].es[anotherIdx].n + " " + c[i];
                    }
                }

            }
            var ind = 0;
            for (var j = 0; j + kpi <= vl; j = j + kpi) {
                series[ind].v[i] = v[i].items[j].v;
                series[ind].rv[i] = v[i].items[j].rv;
                ind++;
            }
        }

        var sl = series.length;
        for (var i = 0; i < sl; i++) {
            var elmsValue = {};
            elmsValue[m.gts.row[0].id] = ch[0].items[i * kpi][0];
            if (m.gts.row[0].fid) {
                elmsValue[m.gts.row[0].id + ":" + m.gts.row[0].fid] = ch[0].items[i * kpi][0];
            }
            elmsValue["Metric"] = ch[0].items[i * kpi][0];
            models[i] = {
                refv: referValue[i].refv,
                elms: elmsValue,
                tr: series[i].v[series[i].v.length - 1],
                model: {
                    categories: {
                        items: c,
                        tn: attrName
                    },
                    mtrcs: {
                        items: METRICS
                    },
                    series: [ series[i] ],
                    colHeaders: [
                        {
                            items: ch[0].items[i]
                        }
                    ],
                    rowHeaders: [
                        {
                            n: rows[0].n
                        }
                    ]
                },
                metricIdx: metrixIdxArray[i]
            };
        }
    }

    function bulletShowMinLabel() {
        var showMinLabel = false;
        var otherProps = this.otherProps;
        if (this.showGauge) {
            var minValue = this.bulletProps.mfMinValue;
            var count = models.length;
            for (var i = 0; i < count; i++) {
                var v = models[i].refv[2];
                if (v && v.rv < minValue) {
                    showMinLabel = true;
                    otherProps.mRowHeight = otherProps.mRowHeight > 36 ? otherProps.mRowHeight : 36;
                    break;
                }

            }

        }

        return showMinLabel;
    }

    function getFirstRowUnderDockedHeader(yPos) {
        var scl = this.getChartWithScrollBar()._scroller;
        var y = yPos || scl && scl.origin && scl.origin.y;
        var rowOffsetHeight = this.rowOffsetHeight;

        var rowIdx = this.startCnt + parseInt(y / rowOffsetHeight) + this.dockedHeaderRows.length;//this.dockedHeaderCount;
        var rowPast = y % rowOffsetHeight;

        var rowInfo = getRowAtIdx.call(this, rowIdx);

        return{rowInfo: rowInfo, treeNode: rowInfo.treeNode, pastOffset: rowPast, rowIdx: rowIdx};
    }

    function getRowAtIdx(rowIdx) {
        if (rowIdx < 0) {
            rowIdx = 0;
        }
        var maxRowIdx = this.rows.length - 1;
        if (rowIdx > maxRowIdx) {
            rowIdx = maxRowIdx;
        }

        return this.rows[rowIdx];
    }

    /*
     * generate all the rows shown under current expand status
     * allExpand: if true, we get all rows no matter if the treeNode is expanded
     * rowCnt: only get the first rowCnt rows
     */
    function getTreeNodeRows(allExpand, rowCnt) {
        var preOrderTreeNodeQueue = [];
        var treeNode = null;
        var rows = [];

        //init the queue
        var treeNodeList = this.tree.childrenTreeNodeList;
        var childrenCount = treeNodeList.length;
        for (var i = childrenCount - 1; i >= 0; i--) {
            preOrderTreeNodeQueue.push(treeNodeList[i]);
        }

        var rowCount = 0;
        //pre order travel tree to find the first row node
        while (preOrderTreeNodeQueue.length > 0) {
            treeNode = preOrderTreeNodeQueue.pop();
            var row = {treeNode: treeNode,
                model: treeNode.model,
                rowIdx: rowCount,
                selected: treeNode.selected,
                rowRef: {}};
            rows.push(row);
            if (!allExpand) {
                treeNode.rowIdx = rowCount++;
            }

            if (rowCnt && rowCount >= rowCnt) {
                break;
            }
            if (treeNode.needExpand || allExpand) {
                treeNodeList = treeNode.childrenTreeNodeList;
                childrenCount = treeNodeList.length;
                for (var i = childrenCount - 1; i >= 0; i--) {
                    preOrderTreeNodeQueue.push(treeNodeList[i]);
                }
            }
        }

        return rows;

    }

    function getLowestLevelOnScreen() {
        var scl = this.getChartWithScrollBar()._scroller;
        var y = scl && scl.origin && scl.origin.y;
        var rowOffsetHeight = this.rowOffsetHeight;

        var firstRowIdx = this.startCnt + parseInt(y / rowOffsetHeight);//+ this.dockedHeaderCount;
        var chartHeight = Math.min(this.chartTableMaxHeight, parseInt(this._leftChart.itemsContainerNode.style.height));
        var lastRowIdx = this.startCnt + parseInt((y + chartHeight) / rowOffsetHeight);

        if (firstRowIdx < 0) {
            firstRowIdx = 0;
        }
        if (lastRowIdx >= this.rows.length) {
            lastRowIdx = this.rows.length - 1;
        }

        var lowestLevel = -1;
        for (var i = firstRowIdx; i <= lastRowIdx; i++) {
            var currLevel = this.rows[i].treeNode.level;
            if (currLevel > lowestLevel) {
                lowestLevel = currLevel;
            }
        }

        return lowestLevel;
    }

    function removeChildren(container) {
        var count = container && container.childNodes && container.childNodes.length;
        for (var i = 0; i < count; ++i) {
            container.removeChild(container.firstChild);
        }

    }

    function hasScrollDownPast(yPos) {
        return yPos < 0;
    }

    function expandOrCollapseTreeAndSetScrlPos(levelToExpand, anchorRowTreeNode, anchorRowIdxOnScrn) {

        if (this.expandToLevel == levelToExpand) {
            //do nothing
            return;
        }

        setNeedExpandToLevel(this.tree, levelToExpand);

        this.expandToLevel = levelToExpand;

        this.rowsNeedRebuild = true;

        this.reRenderChartWithAnchor(anchorRowTreeNode, anchorRowIdxOnScrn);

        setChartTableHeight.call(this);

        this.reBuildDH(levelToExpand);

    }

    function expandTreeNodeAndSetScrlPos(rowInfo, rowType) {
        var treeNode = rowInfo.treeNode;

        treeNode.needExpand = true;

        this.expandToLevel = -1;

        var scl = this.getChartWithScrollBar()._scroller;

        var currRowIdx = rowInfo.rowIdx;

        this.reRenderChart(scl.origin);

        setChartTableHeight.call(this);

        if (currRowIdx == this.startCnt + parseInt(scl.origin.y / this.rowOffsetHeight) + this.dockedHeaderRows.length) {
            //add this row to dockedHeader

            var rowIdxList = [];
            var currRowTreeNode = rowInfo.treeNode;
            while (currRowTreeNode.needExpand) {
                //first row lower than last docked header
                //add to dockedHeaders, dockedHeaderCount++
                rowIdxList.push(currRowIdx);
                currRowTreeNode = getRowAtIdx.call(this, ++currRowIdx).treeNode;
            }
            this.addRowsToDH(rowIdxList);

            //			this.dockedHeaderCount = this.dockedHeaderRows.length;
        }

        /*
         * PM required:
         * When the last row is expanded, there is not indication to the user apart from the triangle changing its orientation
         * To combat this, along with changing the triangle's orientation, we will also automatically scroll up by 2 rows worth of pixels,
         * so that two child rows wil be visible.
         */
        var rowOffsetHeight = this.rowOffsetHeight;
        var lastRowOnScrnIdx = this.startCnt + Math.round((scl.origin.y + this.chartTableHeight) / rowOffsetHeight) - 1;
        if (currRowIdx == lastRowOnScrnIdx) {
            var scroller = scl;
            var maxYPos = Math.min(scl.origin.y + 2 * rowOffsetHeight, scl.offset.y.end);
            scl.origin.y = maxYPos;

            $D.translate(scroller.scrollEl, -scroller.origin.x, -scroller.origin.y, 0, scroller.transform, scroller.useTranslate3d);

            //TODO: for the right chart

            this.onScrollMoved({y: maxYPos});
        }

    }

    function getIdxByRowIdx(rows, targetIdx) {
        var rowCount = rows.length;
        for (var i = 0; i < rowCount; i++) {
            var rowInfoDH = rows[i];
            if (rowInfoDH.rowIdx == targetIdx) {
                return i;
            }
        }
        return -1;
    }

    function collapseTreeNodeAndSetScrlPos(rowInfo, rowType) {
        var treeNode = rowInfo.treeNode;
        treeNode.needExpand = false;

        this.expandToLevel = -1;

        var scl = this.getChartWithScrollBar()._scroller;

        if (rowType == DOCKED_HEADER) {

            var adjustOffset = 0;
            //find this docked header in dockedHeaderRows
            var rowCount = this.dockedHeaderRows.length;
            var dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderRows, rowInfo.rowIdx);

            if (dockedHeaderIdx >= 0) {
                this.removeRowsFromDH(rowCount - dockedHeaderIdx);
                //				this.dockedHeaderCount  = this.dockedHeaderRows.length;
                this.removeChildrenForDHReplaceTable();
                this.dockedHeaderStatus = NO_REPLACE;

            } else {
                //find this docked header in dockedHeaderReplaceRows
                dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderReplaceRows, rowInfo.rowIdx);

                if (dockedHeaderIdx < 0) {
                    //should not occur
                    return;
                }
                dockedHeaderIdx += rowCount;
                adjustOffset = scl.origin.y % this.rowOffsetHeight;
                this.removeChildrenForDHReplaceTable();
                this.dockedHeaderStatus = NO_REPLACE;
                //				this.dockedHeaderCount  = this.dockedHeaderRows.length;
            }

            var rowCount = this.startCnt + parseInt(scl.origin.y / this.rowOffsetHeight) + dockedHeaderIdx - rowInfo.rowIdx;
            this.reRenderChart(scl.origin, rowCount, adjustOffset);
        } else if (rowType == OTHER_ROW) {

            this.reRenderChart(scl.origin);
        }

        setChartTableHeight.call(this);

    }

    var hideTooltipGlobal = function () {
        if (this.tooltip.style["display"] === "block") {
            var highLightCav = document.getElementById("highLightCav"
                + this.domNode.id);
            if (highLightCav) {
                highLightCav.id = "";
                //				highLightCav.height = highLightCav.height;
                //clear canvas
                var context = highLightCav.getContext('2d');
                context.clearRect(0, 0, highLightCav.width, highLightCav.height);
            }
            // here, this referes to domNode
            this.tooltip.style.display = "none";
            this.tooltipShow = false;

            if (this._touchListener) {
                var touchManager = mstrmojo.touchManager;
                touchManager.detachEventListener(this._touchListener);
                delete this._touchListener;
            }

        }
    };

    function setChartTableHeight() {
        if (!this._leftChart) {
            return;
        }

        var chartTableOffsetHeight = (this.otherProps.mbHideTextColumns && this.enableSmoothScroll) ? this._rightChart.chartTableOffsetHeight : this._leftChart.chartTableOffsetHeight;
        var headerTableOffsetHeight = (this.otherProps.mbHideTextColumns && this.enableSmoothScroll) ? this._rightChart.headerTableOffsetHeight : this._leftChart.headerTableOffsetHeight;

        var chartTableHeight = 0;
        if (chartTableOffsetHeight >= this.chartTableMaxHeight) {
            chartTableHeight = this.chartTableMaxHeight;
        } else {
            chartTableHeight = chartTableOffsetHeight;
        }

        this._leftChart.itemsContainerNode.style.height = chartTableHeight + "px";
        if (this._rightChart) {
            this._rightChart.itemsContainerNode.style.height = chartTableHeight + "px";
        }

        this.legend.style.top = (headerTableOffsetHeight + chartTableHeight) + "px";
        this.dropShadowDiv.style.height = (headerTableOffsetHeight + chartTableHeight) + "px";

        this.indicatorEl.parentNode.style.top = headerTableOffsetHeight + "px";
        this.indicatorEl.parentNode.style.height = chartTableHeight + "px";

        this.chartTableHeight = chartTableHeight;

        //test if the chart is scroll beyond the position it should be
        //this happend when collapse the treeNode at the end, or rotate
        var scl = this.getChartWithScrollBar()._scroller;
        var yPos = scl.origin.y;
        var maxYPos = chartTableOffsetHeight - chartTableHeight + 2;
        if (yPos > maxYPos) {
            if (scl.vScroll) {
                scl.origin.y = maxYPos;
                this._leftChart.scrollTo(scl.origin);
                if (this._rightChart) {
                    this._rightChart.scrollTo(scl.origin);
                }

                var rowOffsetHeight = this.rowOffsetHeight;

                while ((yPos = yPos - rowOffsetHeight) > maxYPos) {
                    this.updateDockedHeadersByOneRow(yPos, true);
                }
                this.updateDockedHeadersByOneRow(maxYPos);

                this.firstRowIdxOnScrn = parseInt(this.startCnt + scl.origin.y / rowOffsetHeight);
            } else {
                scl.origin.y = 0;
                this._leftChart.scrollTo(scl.origin);
                if (this._rightChart) {
                    this._rightChart.scrollTo(scl.origin);
                }
                this.firstRowIdxOnScrn = parseInt(this.startCnt + scl.origin.y / rowOffsetHeight)
            }

        }

        this.updateWindowRatio();
        this.updateScrollBarPosition();
    }

    function setScrollerPosition(scrollTo) {

        var scl = this._scroller,
            icn = this.rightChart,
            offsetEnd = this.rightChart.offsetWidth - ( this.getWidth() - this.leftWidth );

        scl.origin = {
            x: scrollTo && scrollTo.x || 0,
            y: scrollTo && scrollTo.y || 0
        };

        scl.showScrollbars = true;
        scl.hScroll = (offsetEnd !== 0 && scl.noHScroll !== true) || this.scrollPast;

        if (scl.hScroll) {

            scl.offset = {
                x: {
                    start: 0,
                    end: offsetEnd
                },
                scrollPast: this.scrollPast
            };
        }

        this.utils.translateCSS(-scl.origin.x, -scl.origin.y, false, icn);
    }

    mstrmojo.VisMicroChart = mstrmojo.declare(

        mstrmojo.Vis,

        [ mstrmojo._TouchGestures, mstrmojo._HasTouchScroller ],

        {

            scriptClass: 'mstrmojo.VisMicroChart',

            utils: mstrmojo.VisChartUtils,

            scrollerConfig: {
                bounces: false,
                showScrollbars: true,
                vScroll: false,
                hScroll: true,
                useTranslate3d: false
            },

            scrollPast: false,

            legendHeight: 30,

            //PM require: do not need gradient
            selectedStyle: "background-color:#015DE6;color:#FFFFFF;",

            //						selectedStyle : "background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #058CF5), color-stop(1, #015DE6));color:#FFFFFF;",

            selectedClass: "",

            isAllAttrSelectable: false,

            // -2 for default, -1 for header total, 0, 1, 2 for concrete row
            prevSelected: {
                mrow: -2,
                mcol: -1
            },

            rows: [],

            dockedHeaderRows: [],

            dockedHeaderReplaceRows: [],

            rowsReusePool: [],

            unselectedRemainCells: [],

            isTreeMode: false,

            isKPI: false,

            showMinLabel: false,

            rowsNeedRebuild: true,

            lastScrollPosition: {y: 0},

            /*
             * start and end idx for the rows curr rendered
             */
            startCnt: -1,

            endCnt: -1,

            /*
             * the row index for the first row on screen
             * the index in this.rows array
             * used to decide startCnt and end Cnt
             */
            firstRowIdxOnScrn: 0,

            pageSize: 10,

            mcStatus: null,

            //default font size
            fontSize: '10pt',

            headerCssClass: '',

            valueCssClass: '',

            //smooth scroll setting:
            enableSmoothScroll: false,

            metricColumnsSpacing: NORMAL,

            attrColumnCount: 0,

            dropShadowWidth: 7,

            markupString: '<div id="{@id}-microchart" class="mstrmojo-Chart {@cssClass}" style="width:{@width};height:{@height};left:{@left};top:{@top};z-index:{@zIndex};position:absolute" '
                + ' mstrAttach:mousedown,mouseup,mousemove,click >'
                +
                '<div id="{@id}-microchart-left" style="width:{@leftWidth+"px"};height:{@height};left:0px;right:0px;position:absolute;z-index:1;" > </div>'
                +
                '<div id="{@id}-microchart-smoothscroll-container" class="mstrmojo-Chart {@cssClass}" style="width:{@rightWidth+"px"};height:{@height};left:{@leftWidth+"px"};top:0;position:absolute;overflow:hidden;">'
                + '<div id="{@id}-microchart-right" style="width:{@rightWidth};position:absolute;" > </div>'
                + '<div id="{@id}-drop-shadow-ss" style="position:absolute;left:0px;width:{@dropShadowWidth+"px"}" > </div>'
                + '</div>'
                +
                '<div style="display:none;position:absolute;right:0;z-index:5;height:{@legendHeight + "px"};width:{@width};border:none;background:transparent;text-decoration:none;" class="microchart-lengend-text">'
                + '<div style="position:absolute;right:0;top:0;padding-bottom:7px">'
                + '<div style="float:left;padding-top:7px;">'
                + '<div class="microchart-legend-band" ></div>'
                + '<div style="float:right;margin-right:10px;margin-left:10px;">Low</div>'
                + '</div>'
                + '<div style="float:left;padding-top:7px;">'
                + '<div class="microchart-legend-band"></div>'
                + '<div style="float:right;margin-right:10px;margin-left:10px;">Mid</div>'
                + '</div>'
                + '<div style="float:left;padding-top:7px;">'
                + '<div class="microchart-legend-band"></div>'
                + '<div style="float:right;margin-right:10px;margin-left:10px;">High</div>'
                + '</div>'
                + '</div>'
                + '</div>'
                +
                '<span id="textSpan" style="z-index:-10;visibility:hidden;-webkit-text-size-adjust: none;"></span>'
                +
                '<div id="{@id}-loading-msg" class="mstrmojo-loading-msg" style="display:none;z-index:10"></div>'
                +
                '<canvas id="textCanvas" width="900" height="500" style="z-index:-11;visibility:hidden;-webkit-text-size-adjust: none;"></canvas>'
                +
                '<div id="{@id}-tooltip" class="mstrmojo-MicroChart-tooltip" style="z-index:10;opacity: 0.9;"></div>'
                +
                '<div id="{@id}-text-tooltip" class="mstrmojo-Chart-tooltip timeseries-legend-tooltip" style="z-index:10"></div>'
                +
                '<div id="{@id}-errMsg" class="mstrmojo-message" style="width:{@width};height:{@height};top:0px;left:0px;position:absolute; display:none; z-index:30;"><div style="width:{@width};position:absolute;top:50%;text-align:center"></div></div>'
                +
                '<div id="{@id}-indicatorEl-container"  style="width:{@width};height:{@height};top:0px;left:0px;position:absolute;z-index:-5"><div></div></div>'
                +
                '</div>',

            markupSlots: {
                leftChart: function () {
                    return this.domNode.childNodes[0];
                },

                rightChart: function () {
                    return this.domNode.childNodes[1].firstChild;
                },

                dropShadowDiv: function () {
                    return this.domNode.childNodes[1].childNodes[1];
                },

                itemsContainerNode: function () {
                    return this.domNode.childNodes[1];
                },

                textSpan: function () {
                    return this.domNode.childNodes[3];
                },

                loadingMsg: function () {
                    return this.domNode.childNodes[4];
                },

                textCanvas: function () {
                    return this.domNode.childNodes[5];
                },

                tooltip: function () {
                    return this.domNode.childNodes[6];
                },

                textTooltip: function () {
                    return this.domNode.childNodes[7];
                },

                // for displaying error message
                errorMsg: function () {
                    return this.domNode.childNodes[8];
                },

                indicatorEl: function () {
                    return this.domNode.childNodes[9].firstChild;
                },

                legend: function () {
                    return this.domNode.childNodes[2];
                },

                legendLow: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[0];
                },

                legendLowFont: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[0].childNodes[1];
                },

                legendLowBand: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[0].childNodes[0];
                },

                legendMid: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[1];
                },

                legendMidFont: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[1].childNodes[1];
                },

                legendMidBand: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[1].childNodes[0];
                },

                legendHigh: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[2];
                },

                legendHighFont: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[2].childNodes[1];
                },

                legendHighBand: function () {
                    return this.domNode.childNodes[2].childNodes[0].childNodes[2].childNodes[0];
                }
            },

            //						showLoadingMsg: function shmsg(text) {
            //				            var msg = this.loadingMsg,
            //				                mns = msg.style;
            //
            //				            // Add message text.
            //				            msg.innerHTML = text || mstrmojo.desc(5674, 'Loading...');
            //				            mns.display = 'block';
            //				            mns.opacity = 1;
            //
            //				            // Display message centered within the widget.
            //				            var x = Math.round(this.getWidth() / 2 - msg.offsetWidth / 2);
            //				            var y = Math.round(this.getHeight() / 2 - msg.offsetHeight / 2);
            //
            //				            this.utils.translateCSS(x, y, false, msg);
            //				            console.log("show loading message");
            //
            //				        },
            //
            //				        hideLoadingMsg: function hmsg() {
            //				        	this.loadingMsg.style.display = 'none';
            //				            this.loadingMsg.style.opacity = 0;
            //				            console.log("hide loading message");
            //				        },

            renderErrorMessage: function renderErrorMessage(msg) {
                var contentDiv = this.errorMsg.firstChild;
                contentDiv.innerHTML = msg; //"<div class=\"mstrmojo-message\">" + msg + "</div>";
                this.errorMsg.style.display = 'block';
                var contentHeight = contentDiv.offsetHeight;
                contentDiv.style.marginTop = -0.5 * contentHeight;
            },

            /**
             *
             * @param text the string to meature
             * @param elem the element which provide the computed style used to meatrue text width
             * @returns
             */
            getTextWidthByCanvas: function gtwCvs(text, elem, withPadding) {
                var canvas = this.textCanvas;

                var context = canvas.getContext('2d');

                var computedStyle = mstrmojo.css.getComputedStyle(elem);
                var fontStyle = computedStyle.fontStyle + " "
                    + computedStyle.fontWeight + " "
                    + computedStyle.fontSize + "/"
                    + computedStyle.fontVariant
                    + " " + computedStyle.fontFamily;

                context.font = fontStyle;

                context.textAlign = 'center';
                context.fillStyle = 'blue';

                // get text metrics
                var metrics = context.measureText(text);

                var result = metrics.width;

                if (withPadding) {
                    var addPadding = function (padding) {
                        if (computedStyle[padding]) {
                            result += parseInt(computedStyle[padding]);
                        }
                    }

                    addPadding("paddingLeft");
                    addPadding("paddingRight");
                }

                return result;
            },

            getTextWidth: function gtw(str, className, fontName, fontSize, fontSizeUnit, bold, withoutPadding) {
                var selfTextSpan = this.textSpan;
                if (selfTextSpan.className !== className || "") {
                    selfTextSpan.className = className || "";
                }
                if (selfTextSpan.style.fontFamily !== fontName || "") {
                    selfTextSpan.style.fontFamily = fontName || "";
                }

                var fsUnit = fontSizeUnit || "pt"

                if (fontSize) {
                    selfTextSpan.style.fontSize = fontSize + fsUnit;
                } else {
                    selfTextSpan.style.fontSize = '';
                }

                if (bold) {
                    if (selfTextSpan.style.fontWeight !== 'bold') {
                        selfTextSpan.style.fontWeight = 'bold';
                    }
                } else {
                    if (selfTextSpan.style.fontWeight !== '') {
                        selfTextSpan.style.fontWeight = '';
                    }
                }
                if (withoutPadding) {
                    selfTextSpan.style.padding = "0px 0px";
                } else {
                    selfTextSpan.style.padding = "";
                }

                selfTextSpan.innerHTML = str;
                var ret = selfTextSpan.offsetWidth;
                return ret;
            },

            getTextHeight: function gth(str, className, bold, fontFamily, fontSize) {
                //clear the style
                this.textSpan.style.fontFamily = fontFamily || "";
                this.textSpan.style.fontSize = fontSize || "";
                if (bold) {
                    this.textSpan.style.fontWeight = 'bold';
                } else {
                    this.textSpan.style.fontWeight = '';
                }
                //set the className
                this.textSpan.className = className;
                //set content string
                this.textSpan.innerHTML = str;

                return this.textSpan.offsetHeight;
            },

            /**
             * remove this.mcStatus and mcStatus in docModel as we will recreate them in unrender
             *
             */
            removeMCStatus: function removeMCStatus() {
                this.mcStatus = null;
                if (this.controller && this.controller.view && this.controller.view.model) {
                    this.controller.view.model.mcStatus = null;
                }
            },

            restoreMCStatus: function restoreMCStatus() {
                /*
                 * restore the mcStatus
                 */
                if (this.isTreeMode && this.mcStatus && this.mcStatus.currSelectedObj && this.mcStatus.currSelectedObj.length > 0) {
                    this.lastSelectedObj = $HASH.clone(this.currSelectedObj);

                }
                if (this.mcStatus && this.mcStatus.startCnt != undefined && this.mcStatus.endCnt != undefined) {
                    this.startCnt = this.mcStatus.startCnt;
                    this.firstRowIdxOnScrn = this.mcStatus.firstRowIdxOnScrn;

                    var minRowCntToCoverScreen = Math.max(this.mcStatus.endCnt - this.mcStatus.firstRowIdxOnScrn, this.minPageSize);
                    this.endCnt = Math.min(this.mcStatus.firstRowIdxOnScrn + minRowCntToCoverScreen, this.rows.length);
                }

                if (this.isTreeMode && this.mcStatus) {
                    this.replacingStartRowIdx = this.mcStatus.replacingStartRowIdx;
                    this.needReplaceCount = this.mcStatus.needReplaceCount;
                    this.lastFirstRowIdxOnScrn = this.mcStatus.lastFirstRowIdxOnScrn;
                    this.dockedHeaderStatus = this.mcStatus.dockedHeaderStatus;
                    this.lastScrollPosition = this.mcStatus.lastScrollPosition;
                }
            },

            storeMCStatus: function storeMCStatus(noNeedToStoreScrollInfo) {
                this.mcStatus = {};
                if (this.isTreeMode) {
                    this.mcStatus.expandToLevel = this.expandToLevel || -1;
                    this.mcStatus.expandedEntryArray = [];
                    if (this.mcStatus.expandToLevel < 0) {
                        //we are not expanded to certain level, so store the expanded tree node one by one
                        this.addTreeNodeToExpanedEntry(this.tree.childrenTreeNodeList, []);
                    }

                    this.mcStatus.currSelectedObj = [];

                    /*
                     * store the currSelectedObj for tree mode
                     * change from treepath to treenode id
                     * as after slice, the treepath idx may be changed
                     */
                    for (var i = 0; i < this.currSelectedObj.length; i++) {
                        //if this.currselectedObj[i] is not in the curr data model, it will not be converted to treeNodeIdx
                        //so keep the treeNode id
                        var treeNode = this.currSelectedObj[i];
                        this.mcStatus.currSelectedObj[i] = treeNode && treeNode.id;
                    }

                    /*
                     * for some case, we do not store the scroll position and dockedheader info
                     * e.g. after slice
                     */
                    if (!noNeedToStoreScrollInfo) {
                        this.mcStatus.dHRowIdxList = [];
                        var dHRows = this.dockedHeaderRows;
                        for (var i = 0; i < dHRows.length; i++) {
                            this.mcStatus.dHRowIdxList.push(dHRows[i].rowIdx);
                        }
                        this.mcStatus.dHReplaceRowIdxList = [];
                        var dHRows = this.dockedHeaderReplaceRows;
                        for (var i = 0; i < dHRows.length; i++) {
                            this.mcStatus.dHReplaceRowIdxList.push(dHRows[i].rowIdx);
                        }

                        this.mcStatus.replacingStartRowIdx = this.replacingStartRowIdx;
                        this.mcStatus.needReplaceCount = this.needReplaceCount;
                        this.mcStatus.lastFirstRowIdxOnScrn = this.lastFirstRowIdxOnScrn;
                        this.mcStatus.dockedHeaderStatus = this.dockedHeaderStatus;
                        this.mcStatus.lastScrollPosition = this.lastScrollPosition;
                    }

                }

                if (!noNeedToStoreScrollInfo) {
                    this.mcStatus.startCnt = this.startCnt;
                    this.mcStatus.endCnt = this.endCnt;
                    this.mcStatus.firstRowIdxOnScrn = this.firstRowIdxOnScrn;
                    var chart = this.getChartWithScrollBar()
                    this.mcStatus.scrollTo = chart && chart._scroller.origin || {x: 0, y: 0};
                }

                if (this.enableSmoothScroll && this._scroller && this._scroller.origin) {
                    //store hscroll position, use percent position
                    this.mcStatus.hScrollPos = this._scroller.origin.x / this.rightWidth;
                }

                /*
                 * stort status in docModel
                 * This is used in case that there are two layouts, one for landscape and one for portrait,
                 *
                 */
                if (this.controller && this.controller.view && this.controller.view.model) {
                    this.controller.view.model.mcStatus = this.mcStatus;
                }

            },

            addTreeNodeToExpanedEntry: function addExpanedEntry(treeNodeList, parentEntry) {
                var expEntryArray = this.mcStatus.expandedEntryArray;
                var treeNodeCount = treeNodeList.length;
                for (var i = 0; i < treeNodeCount; i++) {
                    var treeNode = treeNodeList[i];
                    if (treeNode.needExpand) {
                        //clone parentEntry
                        var expandedEntry = $HASH.clone(parentEntry)
                        expandedEntry.push({element: treeNode.id});
                        expEntryArray.push(expandedEntry);
                        //recur
                        this.addTreeNodeToExpanedEntry(treeNode.childrenTreeNodeList, expandedEntry);
                    }
                }

            },

            unrender: function unrender(ignoreDom, noNeedToStoreScrollInfo) {
                console.log("in unrender");
                if (!this.mcStatus) {
                    // only update mcStatus for the first time we call unrender
                    // As we will also call unrender in destroy for several times, and the mcStatus may be uncorrect
                    this.storeMCStatus(noNeedToStoreScrollInfo);
                }

                this.destroyChartWidget();
                if (this._super) {
                    this._super(ignoreDom);
                }
            },

            //refresh is called on slice operation
            refresh: function refresh() {
                this.unrender(null, true);
                this.render();
            },

            initScroller: function initScroller(scroller) {
                if (this._super) {
                    this._super(scroller);
                }

                if (this.enableSmoothScroll) {
                    // Attach event listeners.  Call back to listen when scroll is done
                    // update the vertical scrollbar position
                    this._scrollDoneListener = this._scroller.attachEventListener('scrollDone', this.id, function () {
                        this.updateScrollBarPosition();
                        var scrl = this._scroller;
                        if (scrl) {
                            scrl.toggleScrollBars(false);
                        }

                    });

                }

            },

            updateScrollBarPosition: function updateScrollBarPosition() {
                var scroller = this._rightChart && this._rightChart._scroller;
                var scrollBar = scroller && scroller._scrollBarEls && scroller._scrollBarEls.y;

                if (scrollBar) {
                    scrollBar.style.left = (this._scroller.origin.x + this.getWidth() - this.leftWidth - 9) + "px";
                }

                scroller = this._scroller;
                scrollBar = scroller && scroller._scrollBarEls && scroller._scrollBarEls.x;

                if (scrollBar) {
                    scrollBar.style.top = (this.chartTableHeight + this._leftChart.headerTableOffsetHeight - 9) + "px";
                }
            },

            onScrollDone: function onScrollDone(evt) {
                var scrl = this.getChartWithScrollBar()._scroller;
                scrl.toggleScrollBars(false);
                if (this.partialRender) {
                    this.firstRowIdxOnScrn = parseInt(this.startCnt + evt.y / this.rowOffsetHeight);
                    if ((this.firstRowIdxOnScrn - this.startCnt <= this.pageSize && this.firstRowIdxOnScrn >= this.pageSize)
                        || this.endCnt - 1 - this.firstRowIdxOnScrn <= this.pageSize && this.endCnt != this.rows.length) {
                        //									console.log("reRenderChartWhenScrollDone");
                        this.reRenderChartWhenScrollDone(scrl.origin);
                        setChartTableHeight.call(this);
                    }
                }
            },

            onScrollMoved: function onScrollMoved(evt) {
                hideTooltipGlobal.call(this);
                if (this.isTreeMode) {
                    //TQMS 703260:we should remove the docked headers when scroll past.
                    if (hasScrollDownPast(evt.y)) {
                        this._leftChart.hideDockedHeader();
                        if (this._rightChart) {
                            this._rightChart.hideDockedHeader();
                        }
                    } else {
                        this._leftChart.showDockedHeader();
                        if (this._rightChart) {
                            this._rightChart.showDockedHeader();
                        }
                    }

                    var rowOffsetHeight = this.rowOffsetHeight;
                    this.firstRowIdxOnScrn = this.startCnt + parseInt(evt.y / rowOffsetHeight);

                    var currPos = evt.y;
                    var lastPos = this.lastScrollPosition.y;
                    if (lastPos > currPos) {
                        while ((lastPos -= rowOffsetHeight) > currPos) {
                            this.updateDockedHeadersByOneRow(lastPos, true);
                        }
                        this.updateDockedHeadersByOneRow(currPos);
                    } else {
                        while ((lastPos += rowOffsetHeight) < currPos) {
                            this.updateDockedHeadersByOneRow(lastPos, true);
                        }
                        this.updateDockedHeadersByOneRow(currPos);
                    }

                    /*
                     var scrollPastRowCount = this.firstRowIdxOnScrn - this.lastFirstRowIdxOnScrn;

                     console.log("scrollPastRowCount:"+scrollPastRowCount);
                     if(scrollPastRowCount > 1){

                     for(var i = 1; i < scrollPastRowCount; i++){
                     this.updateDockedHeadersByOneRow(this.lastScrollPosition.y + rowOffsetHeight, true);
                     }
                     //									while(scrollPastRowCount > 1){
                     //										if(this.dockedHeaderStatus == NO_REPLACE && !this.lastFirstRow.treeNode.needExpand){
                     //
                     //											var remainRowCount = this.lastFirstRow.treeNode.postSiblingCount;
                     //											if(scrollPastRowCount > remainRowCount){
                     //												this.updateDockedHeadersByOneRow(this.lastScrollPosition.y + remainRowCount*this.rowOffsetHeight, true);
                     //												scrollPastRowCount -= remainRowCount;
                     //											}else{
                     //												this.updateDockedHeadersByOneRow(this.lastScrollPosition.y + (scrollPastRowCount - 1)*this.rowOffsetHeight, true);
                     //												scrollPastRowCount = 1;
                     //											}
                     //											console.log("update at row:"+ this.lastFirstRow.rowIdx);
                     //
                     //										}else{
                     //											this.updateDockedHeadersByOneRow(this.lastScrollPosition.y + this.rowOffsetHeight, true);
                     //											scrollPastRowCount--;
                     //										}
                     //									}

                     }else if(scrollPastRowCount < -1){
                     for(var i = -1; i > scrollPastRowCount; i--){
                     this.updateDockedHeadersByOneRow(this.lastScrollPosition.y - rowOffsetHeight, true);
                     }
                     }
                     this.updateDockedHeadersByOneRow(evt.y);
                     */
                }
            },

            initDockedHeaders: function initDockedHeaders() {
                this._leftChart.initDHs();
                if (this._rightChart) {
                    this._rightChart.initDHs();
                }

                this.clearDockedHeader();

                var rowIdx = 0;
                var rowIdxList = [];

                var currRow = getRowAtIdx.call(this, rowIdx);
                while (currRow && currRow.treeNode.needExpand) {
                    rowIdxList.push(rowIdx);
                    currRow = getRowAtIdx.call(this, ++rowIdx);
                }

                this.addRowsToDH(rowIdxList);

                //					   		this.dockedHeaderCount =  this.dockedHeaderRows.length;
                this.lastFirstRowIdxOnScrn = rowIdx;
                this.lastScrollPosition = {x: 0, y: 0};
                this.dockedHeaderStatus = NO_REPLACE;
            },

            clearDockedHeader: function clearDockedHeader() {
                this.removeRowsFromDH(this.dockedHeaderRows.length);
                this.removeChildrenForDHReplaceTable();
            },

            reBuildDH: function reBuildDH(level) {
                this.clearDockedHeader();

                var rows = this.rows;
                var rowIdxToCheck = this.firstRowIdxOnScrn + level;
                if (rowIdxToCheck < 0 || rowIdxToCheck >= rows.length) {
                    return;
                }
                var treeNodeToCheck = rows[rowIdxToCheck].treeNode;

                if (treeNodeToCheck.level > level) {
                    var rowIdxList = [];
                    for (var i = 0; i <= level; i++) {
                        var treeNode = getParentTreeNodeAtLevel(this.tree, treeNodeToCheck.treePath, i);
                        rowIdxList.push(treeNode.rowIdx);
                    }
                    this.addRowsToDH(rowIdxList);
                } else if (treeNodeToCheck.level == level) {
                    var rowIdxList = [];
                    for (var i = 0; i < level; i++) {
                        var treeNode = getParentTreeNodeAtLevel(this.tree, treeNodeToCheck.treePath, i);
                        rowIdxList.push(treeNode.rowIdx);
                    }
                    rowIdxList.push(treeNodeToCheck.rowIdx);
                    this.addRowsToDH(rowIdxList);
                } else if (treeNodeToCheck.level < level) {
                    var preSiblingTreeNode = getPreSiblingTreeNode(this.tree, treeNodeToCheck.treePath);
                    while (!preSiblingTreeNode) {
                        rowIdxToCheck--;
                        var treeNodeToCheck = rows[rowIdxToCheck].treeNode;
                        preSiblingTreeNode = getPreSiblingTreeNode(this.tree, treeNodeToCheck.treePath);
                    }
                    var rowIdxList = [];
                    for (var i = 0; i < treeNodeToCheck.level; i++) {
                        var treeNode = getParentTreeNodeAtLevel(this.tree, treeNodeToCheck.treePath, i);
                        rowIdxList.push(treeNode.rowIdx);
                    }
                    rowIdxList.push(preSiblingTreeNode.rowIdx);

                    var dHCount = treeNodeToCheck.rowIdx - this.firstRowIdxOnScrn;
                    rowIdxToCheck--;
                    var treeNodeToCheck = rows[rowIdxToCheck].treeNode;
                    for (var i = rowIdxList.length; i < dHCount; i++) {
                        var treeNode = getParentTreeNodeAtLevel(this.tree, treeNodeToCheck.treePath, i);
                        rowIdxList.push(treeNode.rowIdx);
                    }
                    this.addRowsToDH(rowIdxList);
                }

                this.dockedHeaderStatus = NO_REPLACE;
            },

            updateDockedHeadersByOneRow: function updateDHBOR(yPos, onlyUpdateStatus) {
                var scroller = this.getChartWithScrollBar()._scroller;
                if (!scroller.vScroll || yPos > scroller.offset.y.end || yPos < 0) {
                    //if not scrollable, or beyond the scroller offset, we will do nothing
                    return;
                }

                var lastDockedHeaderRow;

                var currFirstRow = getFirstRowUnderDockedHeader.call(this, yPos);

                this.firstRowIdxOnScrn = currFirstRow.rowIdx - this.dockedHeaderRows.length;//this.dockedHeaderCount;
                //							console.log("firstRowOnScrn:"+this.firstRowIdxOnScrn);

                if (this.dockedHeaderStatus == IN_REPLACE) {
                    var hasReplacedRowCount = this.firstRowIdxOnScrn - this.replacingStartRowIdx;
                    if (hasReplacedRowCount >= 0) {
                        if (hasReplacedRowCount < this.needReplaceCount) {
                            lastDockedHeaderRow = this.dockedHeaderRows[this.dockedHeaderRows.length - 1];
                            if (this.firstRowIdxOnScrn > this.lastFirstRowIdxOnScrn) {
                                //row changed when scroll up

                                //clear the dockedHeaderReplaceTable
                                this.removeChildrenForDHReplaceTable();
                                this.shiftDockedHeaderWithRow(0, onlyUpdateStatus);

                                if (lastDockedHeaderRow) {
                                    this.removeRowsFromDH(1, true);
                                }
                            } else if (this.firstRowIdxOnScrn < this.lastFirstRowIdxOnScrn) {
                                //row changed when scroll down
                                //finish the IN_REPLACE mode
                                this.dockedHeaderStatus = NO_REPLACE;

                                this.moveRowFromDHRplcTableToDH();

                                //											this.dockedHeaderCount  = this.dockedHeaderRows.length;
                                currFirstRow = getFirstRowUnderDockedHeader.call(this, yPos);

                            }
                            this.shiftDockedHeaderWithRow(-currFirstRow.pastOffset, onlyUpdateStatus);
                        } else {
                            //scroll up replace finish
                            this.dockedHeaderStatus = NO_REPLACE;

                            //clear the dockedHeaderReplaceTable
                            this.removeChildrenForDHReplaceTable();
                            this.shiftDockedHeaderWithRow(0, onlyUpdateStatus);

                            //										this.dockedHeaderCount = this.dockedHeaderRows.length;
                            currFirstRow = getFirstRowUnderDockedHeader.call(this, yPos);

                        }
                    } else {
                        //scroll down finish
                        this.dockedHeaderStatus = NO_REPLACE;

                        //clear the dockedHeaderReplaceTable
                        this.moveRowFromDHRplcTableToDH();

                        //									this.dockedHeaderCount  = this.dockedHeaderRows.length;
                        currFirstRow = getFirstRowUnderDockedHeader.call(this, yPos);

                    }

                }

                if (this.dockedHeaderStatus == NO_REPLACE && currFirstRow.treeNode) {
                    var currLevel = currFirstRow.treeNode.level;
                    lastDockedHeaderRow = this.dockedHeaderRows[this.dockedHeaderRows.length - 1];
                    var lastLevel = lastDockedHeaderRow ? lastDockedHeaderRow.treeNode.level : -1;
                    if (yPos > this.lastScrollPosition.y) {
                        //scroll up
                        if (currLevel <= lastLevel) {
                            //first row has same or higher level than last docked heaker
                            if (lastDockedHeaderRow) {
                                this.removeRowsFromDH(1, true);
                            }
                            this.replacingRowTreeNode = currFirstRow.treeNode;
                            this.replacingStartRowIdx = this.firstRowIdxOnScrn;
                            this.needReplaceCount = lastLevel - currLevel + 1;
                            this.dockedHeaderStatus = IN_REPLACE;
                            //shite the two row
                            this.shiftDockedHeaderWithRow(-currFirstRow.pastOffset, onlyUpdateStatus);
                        } else if (currLevel > lastLevel) {
                            var currRowIdx = currFirstRow.rowIdx;
                            var rowIdxList = [];
                            var currRowTreeNode = currFirstRow.treeNode;
                            while (currRowTreeNode.needExpand) {
                                //first row lower than last docked header
                                //add to dockedHeaders, dockedHeaderCount++
                                rowIdxList.push(currRowIdx);
                                //											this.dockedHeaderCount++;
                                currRowTreeNode = getRowAtIdx.call(this, ++currRowIdx).treeNode;
                            }
                            this.addRowsToDH(rowIdxList);

                            //TODO: if

                        }
                    } else if (yPos < this.lastScrollPosition.y) {
                        //scroll down
                        if (currLevel == lastLevel) {

                            var addedTreeNode = currFirstRow.treeNode.preSibling;
                            var currRowIdx = currFirstRow.rowIdx;
                            var rowCount = 0;
                            while (!addedTreeNode) {
                                //remove the last docked header, which will be replaced
                                rowCount++;
                                //											this.dockedHeaderCount--;
                                currFirstRow = getRowAtIdx.call(this, --currRowIdx);//getFirstRowUnderDockedHeader.call(this, yPos);
                                addedTreeNode = currFirstRow && currFirstRow.treeNode.preSibling;
                            }
                            this.removeRowsFromDH(rowCount);

                            //remove the last docked header, which will be replaced
                            lastDockedHeaderRow = this.dockedHeaderRows[this.dockedHeaderRows.length - 1];
                            if (lastDockedHeaderRow) {
                                this.removeRowsFromDH(1);
                            }

                            if (addedTreeNode.needExpand) {
                                var rowIdxList = [addedTreeNode.rowIdx];
                                this.addRowsToDH(rowIdxList, true);
                            } else {
                                //no need to add to replaceTable, as the row is just there
                            }

                            this.replacingStartRowIdx = this.firstRowIdxOnScrn;//currFirstRow.rowIdx ;
                            this.replacingRowTreeNode = addedTreeNode;

                            this.needReplaceCount = 1;
                            this.dockedHeaderStatus = IN_REPLACE;
                            var pastOffset = yPos % this.rowOffsetHeight;
                            //shite the row
                            this.shiftDockedHeaderWithRow(-pastOffset, onlyUpdateStatus);

                        } else if (currLevel > lastLevel + 1) {
                            var addedTreeNode = getParentTreeNodeAtLevel(this.tree, currFirstRow.treeNode.treePath, lastLevel + 1);

                            var rowIdxList = [addedTreeNode.rowIdx];
                            this.addRowsToDH(rowIdxList, true);

                            this.replacingStartRowIdx = this.firstRowIdxOnScrn;
                            this.replacingRowTreeNode = addedTreeNode;
                            this.needReplaceCount = currLevel - lastLevel - 1;
                            this.dockedHeaderStatus = IN_REPLACE;
                            //shift the two row
                            this.shiftDockedHeaderWithRow(-currFirstRow.pastOffset, onlyUpdateStatus);
                        }

                    }
                }
                this.lastScrollPosition.y = yPos;
                this.lastFirstRowIdxOnScrn = this.firstRowIdxOnScrn;
            },

            checkParentBeforeAddToDH: function checkParentBeforeAddToDH(addedRowIdx) {
                var rowInfo = this.rows[addedRowIdx];
                var treeNode = rowInfo && rowInfo.treeNode;

                var rowCount = this.dockedHeaderRows.length;
                if (rowCount != treeNode.level) {
                    //								this.removeRowsFromDH(rowCount);
                    //
                    //								var treePath = treeNode.treePath.split('_');
                    //								var rowIdxList = [];
                    //								var treeNode = this.tree;
                    //								for(var i = 0; i < rowCount; i++){
                    //									treeNode = treeNode.childrenTreeNodeList[treePath[i]];
                    //									rowIdxList.push(treeNode.rowIdx);
                    //								}
                    //								this.addRowsToDH(rowIdxList);
                }

            },

            addRowsToDH: function addRowsToDH(rowIdxList, toDHReplacingTable) {
                var rows = this.rows;
                var rowCount = rowIdxList.length;
                if (rowCount <= 0) {
                    return;
                }

                var addTo = null;
                if (toDHReplacingTable) {
                    addTo = this.dockedHeaderReplaceRows;
                } else {
                    addTo = this.dockedHeaderRows;
                    //								this.checkParentBeforeAddToDH(rowIdxList[0]);
                }

                for (var i = 0; i < rowCount; i++) {
                    var rowIdx = rowIdxList[i];
                    var rowInfo = rows[rowIdx];
                    addTo.push({rowIdx: rowIdx, treeNode: rowInfo.treeNode, rowRef: this.popFromReusePool()});
                }

                this._leftChart.addRowsToDH(rowCount, toDHReplacingTable);
                if (this._rightChart) {
                    this._rightChart.addRowsToDH(rowCount, toDHReplacingTable);
                }
            },

            removeRowsFromDH: function removeRowsFromDH(rowCount, moveToReplacingTable) {
                //move TR
                if (this._leftChart) {
                    this._leftChart.removeRowsFromDH(rowCount, moveToReplacingTable);
                }

                if (this._rightChart) {
                    this._rightChart.removeRowsFromDH(rowCount, moveToReplacingTable);
                }

                if (rowCount > this.dockedHeaderRows.length) {
                    //there are not enough rows to remove
                    rowCount = this.dockedHeaderRows.length;
                }
                //move rows
                for (; rowCount > 0; rowCount--) {
                    var row = this.dockedHeaderRows.pop();
                    if (!moveToReplacingTable) {
                        this.pushRowRefToReusePool(row);
                    } else {
                        //destroy later, when they are removed from dockedHeaderReplacingTable
                        this.dockedHeaderReplaceRows.push(row);
                    }

                }
            },

            moveRowFromDHRplcTableToDH: function moveRowFromDHRplcTableToDH() {
                this._leftChart.moveRowFromDHRplcTableToDH();
                if (this._rightChart) {
                    this._rightChart.moveRowFromDHRplcTableToDH();
                }
                this.shiftDockedHeaderWithRow(0);
                //							for(; rowCount > 0; rowCount--){
                var row = this.dockedHeaderReplaceRows.pop();
                //								if(!moveToDHTable){
                //									this.pushRowRefToReusePool(row);
                //								}else{
                //destroy later, when they are removed from dockedHeaderReplacingTable
                if (row) {
                    this.dockedHeaderRows.push(row);
                }

                //								}

                //							}
            },

            removeChildrenForDHReplaceTable: function removeChildrenForDHReplaceTable() {
                if (this._leftChart) {
                    this._leftChart.removeChildrenForDHReplaceTable();
                }
                if (this._rightChart) {
                    this._rightChart.removeChildrenForDHReplaceTable();
                }

                var rowCount = this.dockedHeaderReplaceRows.length;
                for (; rowCount > 0; rowCount--) {
                    var row = this.dockedHeaderReplaceRows.pop();
                    this.pushRowRefToReusePool(row);
                }
            },

            pushRowRefToReusePool: function pushRowRefToReusePool(row) {
                if (!row) {
                    return;
                }
                var rowRef = row.rowRef;
                this.rowsReusePool.push(rowRef);
                row.rowRef = {};
            },

            shiftDockedHeaderWithRow: function shiftDockedHeaderWithRow(pastOffset, onlyUpdateStatus) {

                if (onlyUpdateStatus) {
                    return;
                }
                if (this._leftChart) {
                    this.utils.translateCSS(0, pastOffset, 0, this._leftChart.dockedHeaderReplaceDiv.firstChild);
                }
                if (this._rightChart) {
                    this.utils.translateCSS(0, pastOffset, 0, this._rightChart.dockedHeaderReplaceDiv.firstChild);
                }

            },

            init: function init(props) {
                this._super(props);
            },

            initFromVisProps: function (vp) {
                initProp.call(this);
                var propValue = vp ? vp : {},
                    sparklineProps = this.sparklineProps,
                    barProps = this.barProps,
                    bulletProps = this.bulletProps,
                    otherProps = this.otherProps;

                this.isTreeMode = getBoolValue(propValue.itd);

                if (propValue.lsh) {
                    sparklineProps.mbShow = (propValue.lsh === "true");
                }
                if (propValue.lap) {
                    sparklineProps.mbAllPoints = (propValue.lap === "true");
                }
                if (propValue.lep) {
                    sparklineProps.mbEndPoints = (propValue.lep === "true");
                }
                if (propValue.lrl) {
                    sparklineProps.mbRefLine = (propValue.lrl === "true");
                }
                if (propValue.lra) {
                    sparklineProps.mbRefArea = (propValue.lra === "true");
                }
                if (propValue.lmsh) {
                    sparklineProps.mbAssMetric = (propValue.lmsh === "true");
                }
                if (propValue.let) {
                    sparklineProps.mbShowTooltip = (propValue.let === "true");
                }
                if (propValue.llsc) {
                    sparklineProps.mwSeriesLineCol = convertToColor(propValue.llsc);
                }
                if (propValue.lrlc) {
                    sparklineProps.mwRefLineCol = convertToColor(propValue.lrlc);
                }
                if (propValue.lrac) {
                    sparklineProps.mwRefAreaCol = convertToColor(propValue.lrac);
                }
                if (propValue.lh) {
                    sparklineProps.mstrHeader = propValue.lh;
                }
                if (propValue.lam) {
                    sparklineProps.mstrAssMetric = propValue.lam;
                }

                if (propValue.bsg) {
                    barProps.mbShow = (propValue.bsg === "true");
                }
                if (propValue.bl) {
                    barProps.mbShowLegend = (propValue.bl === "true");
                }
                if (propValue.brl) {
                    barProps.mbRefLine = (propValue.brl === "true");
                }
                if (propValue.bet) {
                    barProps.mbShowTooltip = (propValue.bet === "true");
                }
                if (propValue.bpv) {
                    barProps.mwPosCol = convertToColor(propValue.bpv);
                }
                if (propValue.bnv) {
                    barProps.mwNegCol = convertToColor(propValue.bnv);
                }
                if (propValue.brlc) {
                    barProps.mwRefLineCol = convertToColor(propValue.brlc);
                }
                if (propValue.bh) {
                    barProps.mstrHeader = propValue.bh;
                }

                if (propValue.gsh) {
                    bulletProps.mbShow = (propValue.gsh === "true");
                }
                if (propValue.grl) {
                    bulletProps.mbRefLine = (propValue.grl === "true");
                }
                if (propValue.gra) {
                    bulletProps.mbRefBands = (propValue.gra === "true");
                }
                if (propValue.gl) {
                    bulletProps.mbShowLegend = (propValue.gl === "true");
                }
                if (propValue.gmsh) {
                    bulletProps.mbAssMetric = (propValue.gmsh === "true");
                }
                if (propValue.gia) {
                    bulletProps.mbInvertAxis = (propValue.gia === "true");
                }
                if (propValue.get) {
                    bulletProps.mbShowTooltip = (propValue.get === "true");
                }
                if (propValue.gmm) {
                    bulletProps.mfMinValue = parseFloat(propValue.gmm);
                }

                if (propValue.ggc) {
                    bulletProps.mwPosCol = convertToColor(propValue.ggc);
                }
                if (propValue.gnv) {
                    bulletProps.mwNegCol = convertToColor(propValue.gnv);
                }
                if (propValue.grlc) {
                    bulletProps.mwRefLineCol = convertToColor(propValue.grlc);
                }
                if (propValue.gpc) {
                    bulletProps.mwBand1 = convertToColor(propValue.gpc);
                }
                if (propValue.grc) {
                    bulletProps.mwBand2 = convertToColor(propValue.grc);
                }
                if (propValue.gsc) {
                    bulletProps.mwBand3 = convertToColor(propValue.gsc);
                }
                if (propValue.gh) {
                    bulletProps.mstrHeader = propValue.gh;
                }
                if (propValue.gtam) {
                    bulletProps.mstrAssMetric = propValue.gtam;
                }
                if (propValue.glt) {
                    bulletProps.mstrBand1 = propValue.glt;
                }
                if (propValue.gmt) {
                    bulletProps.mstrBand2 = propValue.gmt;
                }
                if (propValue.ght) {
                    bulletProps.mstrBand3 = propValue.ght;
                }

                // xiawang: the propValue.wa could be something like "83%" and after
                // parseFloat it became 83 rather than 0.83. So we add code to detect
                // the value format
                if (propValue.wa) {
                    var value = parseFloat(propValue.wa);
                    if (propValue.wa.indexOf("%")) {
                        value /= 100; // for percent value, divided by 100
                    }
                    otherProps.mfBkgOpacity = value;
                }
                if (propValue.metkpi) {
                    otherProps.mnMetricsPerKPI = parseInt(propValue.metkpi);
                }
                if (propValue.hch) {
                    otherProps.mbHideColHeaders = (propValue.hch === "true");
                }
                if (propValue.htc) {
                    otherProps.mbHideTextColumns = (propValue.htc === "true");
                }
                if (propValue.ll) {
                    otherProps.mbLockLayout = (propValue.ll === "true");
                }
                if (propValue.gam) {
                    otherProps.mbShowForHiddenGraphs = (propValue.gam === "true");
                }
                if (propValue.igf) {
                    otherProps.mbInheritFromGridGraph = (propValue.igf === "true");
                }
                if (propValue.scm) {
                    otherProps.mbInSingleColumnMode = (propValue.scm === "true");
                }
                if (propValue.cid) {
                    otherProps.mpColumnIDs = propValue.cid.split(",");
                }
                if (propValue.tcid) {
                    otherProps.mpColumnIDsInTreeMode = propValue.tcid.split(",");
                }
                // xiawang: otherProps.mpColumnWidths = propValue.cw we delay the
                // process to see if the order is valid. If not valid, we will not use
                // user settings for column width
                if (propValue.co) {
                    otherProps.mpColumnPositions = propValue.co.split(",");
                }
                if (propValue.sc) {
                    otherProps.mpSortKey = propValue.sc;
                }
                if (propValue.so) {
                    otherProps.mbSortDescend = (propValue.so !== "false");
                }

                if (propValue.rh) {
                    otherProps.mRowHeight = parseFloat(propValue.rh);
                }

                // 27 is the minimum Row height. This logic is copied from Flash behavior
                otherProps.mRowHeight = otherProps.mRowHeight > 27 ? otherProps.mRowHeight : 27;

                setDimensionWithDPI.call(this);

            },

            preBuildRendering: function preBR() {
                console.log("in preb in MC");
                if (this._super) {
                    this._super();
                }

                var m = this.model;

                if (!m) {
                    m.err = mstrmojo.desc(8426, 'No model provided');
                    return;
                }

                // check if device type is Tablet Universal
                this.isAndroidTab = $D.isAndroid ? !!mstrApp.isTablet() : false;

                this.isAndroidPhone = $D.isAndroid && !this.isAndroidTab;

                var propValue = m.vp || {};

                var isReport = this.controller && (this.controller instanceof mstrmojo.android.controllers.XtabController);
                var fullScreen = this.isFullScreenWidget || isReport;
                //enable smooth scroll automatically when for the phone in full screen mode
                this.enableSmoothScroll = ( this.isAndroidPhone && fullScreen) ? true : getBoolValue(propValue.ss);

                //							console.log("isAndroid:"+$D.isAndroid+", isPhone:"+!this.isAndroidTab+", fullscreen:"+fullScreen);

                if (propValue.mcs) {
                    this.metricColumnsSpacing = parseInt(propValue.mcs);
                } else {
                    this.metricColumnsSpacing = this.isAndroidPhone ? (mstrApp.isLandscape() ? NORMAL : COMPACT) : -1;
                }

                if (this.enableSmoothScroll) {
                    this.leftWidth = this.getWidth() / 3;
                    this.rightWidth = this.getWidth() / 3 * 2;
                } else {
                    this.leftWidth = this.getWidth();
                    this.rightWidth = 0;
                    this.scrollerConfig.hScroll = false;
                }
            },

            buildRendering: function () {
                var that = this;
                var backup = mstrmojo.string.apply;
                mstrmojo.string.apply = function (tmpl, obj) {
                    if (!tmpl) {
                        return "";
                    }
                    return tmpl.replace(/\{([^\}]+)\}/gm,
                        function tokenRepl(token, prop) {
                            var s = token.replace(/@/g, 'that.');
                            var res = eval(s);
                            return res === undefined ? '' : res;
                        }
                    );
                };

                if (this._super) {
                    this._super();
                }

                mstrmojo.string.apply = backup;
            },

            /*
             * build this.rows[];
             * for TreeMode:
             * this.rows[] need to rebuild once there is treeNode expand or collapse
             * for None-TreeMode:
             * this.rows[] only need to build once.
             */
            buildRows: function buildRows() {
                if (this.rowsNeedRebuild) {
                    if (this.isTreeMode) {
                        // is tree display
                        this.rows = getTreeNodeRows.call(this);
                    } else {
                        buildNonTreeRows.call(this);
                    }

                    this.rowsNeedRebuild = false;
                }
            },

            pushToReusePool: function pushToReusePool(beginCnt, endCnt) {
                var bCnt = beginCnt != undefined ? beginCnt : this.startCnt;
                var eCnt = endCnt != undefined ? endCnt : this.endCnt;

                var rowInfo = null;
                for (var i = bCnt; i < eCnt; i++) {
                    rowInfo = this.rows[i];
                    this.rowsReusePool.push(rowInfo.rowRef);
                    rowInfo.rowRef = {};
                }
            },

            popFromReusePool: function popFromReusePool() {
                var rowRef = this.rowsReusePool.pop();
                return rowRef || {};
            },

            /*
             * rowCount is used for scroll back x rows, used when collapse on docked header
             * adjustOffsetY is used when we collapse a docked header which is in replacing
             */
            reRenderChart: function reRenderChart(scrollTo, rowCount, adjustOffsetY) {

                this.pushToReusePool();

                this.buildRows();

                var rowOffsetHeight = this.rowOffsetHeight;

                if (!rowCount) {
                    rowCount = 0;
                }

                this.firstRowIdxOnScrn = parseInt(this.startCnt + scrollTo.y / rowOffsetHeight) - rowCount;
                this.getCurrRenderRowCount();

                if (adjustOffsetY == undefined) {
                    adjustOffsetY = scrollTo.y % rowOffsetHeight;
                }
                scrollTo.y = (this.firstRowIdxOnScrn - this.startCnt) * rowOffsetHeight + adjustOffsetY;

                //update the lastScrollPosition, used to calculate dockedheader
                this.lastScrollPosition.y = scrollTo.y;
                this.lastFirstRowIdxOnScrn = this.firstRowIdxOnScrn;

                //assign rowRef to the row which will be rendered.
                var rows = this.rows;
                for (var i = this.startCnt; i < this.endCnt; i++) {
                    rows[i].rowRef = this.popFromReusePool();
                }

                if (!this.enableSmoothScroll) {
                    this._leftChart.reRenderRows(scrollTo);
                } else {
                    this._leftChart.reRenderRows(scrollTo);
                    this._rightChart.reRenderRows(scrollTo);
                }
            },

            reRenderChartWhenScrollDone: function reRenderChartwsd(scrollTo) {

                var oldStartCnt = this.startCnt;
                var oldEndCnt = this.endCnt;

                var rowOffsetHeight = this.rowOffsetHeight;
                this.firstRowIdxOnScrn = parseInt(this.startCnt + scrollTo.y / rowOffsetHeight);
                this.getCurrRenderRowCount();

                var firstRowToRemove, lastRowToRemove, firstRowToRender, lastRowToRender;
                if (this.startCnt < oldEndCnt && this.startCnt > oldStartCnt) {
                    firstRowToRemove = oldStartCnt;
                    lastRowToRemove = this.startCnt;
                    firstRowRemain = this.startCnt;
                    lastRowRemain = oldEndCnt;
                    firstRowToRender = oldEndCnt;
                    lastRowToRender = this.endCnt;

                } else if (oldStartCnt < this.endCnt && oldStartCnt > this.startCnt) {
                    firstRowToRemove = this.endCnt;
                    lastRowToRemove = oldEndCnt;
                    firstRowRemain = oldStartCnt;
                    lastRowRemain = this.endCnt;
                    firstRowToRender = this.startCnt;
                    lastRowToRender = oldStartCnt;
                } else {
                    firstRowToRemove = oldStartCnt;
                    lastRowToRemove = oldEndCnt;
                    firstRowRemain = 0;
                    lastRowRemain = 0;
                    firstRowToRender = this.startCnt;
                    lastRowToRender = this.endCnt;
                }

                //							console.log("firstRowToRemove: "+firstRowToRemove+", lastRowToRemove: "+lastRowToRemove);
                //							console.log("firstRowRemain: "+firstRowRemain+", lastRowRemain: "+lastRowRemain);
                //							console.log("firstRowToRender: "+firstRowToRender+", lastRowToRender: "+lastRowToRender);
                //							console.log("....");

                this.pushToReusePool(firstRowToRemove, lastRowToRemove);

                scrollTo.y = (this.firstRowIdxOnScrn - this.startCnt) * rowOffsetHeight + scrollTo.y % rowOffsetHeight;

                //update the lastScrollPosition, used to calculate dockedheader
                this.lastScrollPosition.y = scrollTo.y;
                this.lastFirstRowIdxOnScrn = this.firstRowIdxOnScrn;

                //assign rowRef to the row which will be rendered.
                var rows = this.rows;
                for (var i = firstRowToRender; i < lastRowToRender; i++) {
                    rows[i].rowRef = this.popFromReusePool();
                }

                if (!this.enableSmoothScroll) {
                    this._leftChart.reRenderRows(scrollTo, firstRowRemain, lastRowRemain, firstRowToRender, lastRowToRender);
                } else {
                    this._leftChart.reRenderRows(scrollTo, firstRowRemain, lastRowRemain, firstRowToRender, lastRowToRender);
                    this._rightChart.reRenderRows(scrollTo, firstRowRemain, lastRowRemain, firstRowToRender, lastRowToRender);
                }
            },

            reRenderChartWithAnchor: function reRenderChartWithAnchor(anchorRowTreeNode, anchorRowIdxOnScrn) {

                this.pushToReusePool();

                this.buildRows();

                var rowOffsetHeight = this.rowOffsetHeight;

                var anchorRowIdx = -1;
                for (var i = 0; i < this.rows.length; i++) {
                    if (this.rows[i].treeNode.treePath == anchorRowTreeNode.treePath) {
                        anchorRowIdx = i;
                        break;
                    }
                }

                this.firstRowIdxOnScrn = anchorRowIdx - anchorRowIdxOnScrn;
                if (this.firstRowIdxOnScrn < 0) {
                    this.firstRowIdxOnScrn = 0;
                }

                this.getCurrRenderRowCount();

                scrollTo.y = (this.firstRowIdxOnScrn - this.startCnt) * rowOffsetHeight;

                //update the lastScrollPosition, used to calculate dockedheader
                this.lastScrollPosition.y = scrollTo.y;
                this.lastFirstRowIdxOnScrn = this.firstRowIdxOnScrn;

                //assign rowRef to the row which will be rendered.
                var rows = this.rows;
                for (var i = this.startCnt; i < this.endCnt; i++) {
                    rows[i].rowRef = this.popFromReusePool();
                }

                if (!this.enableSmoothScroll) {
                    this._leftChart.reRenderRows(scrollTo);
                } else {
                    this._leftChart.reRenderRows(scrollTo);
                    this._rightChart.reRenderRows(scrollTo);
                }
            },

            supportsIncFetch: false,

            pageSize: 0,

            getCurrRenderRowCount: function getCRRC() {

                var maxRenderRowCount = this.pageSize * PAGE_COUNT;

                if (this.rows.length <= maxRenderRowCount) {
                    this.partialRender = false;
                    this.startCnt = 0;
                    this.endCnt = this.rows.length;
                } else {
                    this.partialRender = true;
                    this.startCnt = Math.round(this.firstRowIdxOnScrn - this.pageSize * (PAGE_COUNT - 1) / 2)
                    if (this.startCnt < 0) {
                        this.startCnt = 0;
                    }
                    this.endCnt = this.startCnt + maxRenderRowCount;
                    if (this.endCnt > this.rows.length) {
                        this.endCnt = this.rows.length;
                    }
                }
                //							console.log("startCnt, endCnt: "+this.startCnt+" ,"+this.endCnt);
            },

            getChartWithScrollBar: function () {
                if (this.enableSmoothScroll) {
                    return this._rightChart;
                } else {
                    return this._leftChart;
                }
            },

            updateWindowRatio: function updateWindowRatio() {
                /*
                 * every time we change the startCnt and endCnt, we have to recalculate the ratio used for scrollbar
                 */
                var chart = this.getChartWithScrollBar(),
                    scroller = chart._scroller;

                scroller.chartTableRenderRatio = (this.endCnt - this.startCnt) / this.rows.length;
                scroller.topUnRenderedRatio = this.startCnt / this.rows.length;
                //TODO: TQMS 537570
                chart.updateScroller();

            },

            initValues: function initValues() {
                //							if(!this.isTreeMode){
                //								PAGE_COUNT = 7;
                //							}

                this.prevSelected = {
                    mrow: -2,
                    mcol: -1
                };

                if (this.isTreeMode) {
                    initTree.call(this);
                }

                this.treeColumnIdx = -1;

                //minPageSize make sure we render at least three page, when the widget height is quite large
                this.minPageSize = Math.ceil((this.getHeight() / this.otherProps.mRowHeight) * 3 / PAGE_COUNT);
                this.pageSize = this.minPageSize;

                this.rowsNeedRebuild = true;
                this.rows = [];
                this.dockedHeaderRows = [];
                this.dockedHeaderReplaceRows = [];
                this.rowsReusePool = [];
                this.unselectedRemainCells = [];

                this.errorMsg.style.display = 'none';

                //							this.isTreeMode = false;
                //
                //							this.isKPI = false;
                //
                //							this.showMinLabel= false;
            },

            postBuildRendering: function postBR() {

                var me = this,
                    model = me.model;
                var err = model.err || model.eg;

                if (err) {
                    me.renderErrorMessage(err);
                    return;
                }

                if (me.controller && me.controller.view && me.controller.view.model) {
                    if (!me.mcStatus && me.controller.view.model.mcStatus) {
                        //me is newly created
                        me.mcStatus = me.controller.view.model.mcStatus;
                    }
                }

                me.initValues();

                me.highlightEntireRow = me.isTreeMode || me.isAllAttrSelectable;

                getUITheme.call(me);

                convertDataToModels.call(me);

                if (me.otherProps.mbInheritFromGridGraph) {
                    me.selectedClass = "sc_" + me.model.k; // xiawang: this css class name is fixed
                } else {
                    me.selectedClass = "";
                }

                err = model.err || model.eg;

                if (err) {
                    me.renderErrorMessage(err);
                    return;
                }

                if (this._super) {
                    this._super();
                }

                //render legend before render table, so that we know the legend offsetHeight
                me.renderLegend();

                me.getCurrRenderRowCount();

                me.restoreMCStatus();

                if (!me.enableSmoothScroll) {
                    me.itemsContainerNode.style.display = 'none';
                    var props = {
                        placeholder: me.leftChart,
                        colInfos: me.colInfos,
                        theme: me.theme,
                        isTreeMode: me.isTreeMode,
                        showMinLabel: me.showMinLabel,
                        width: me.leftWidth + "px",
                        height: (me.getHeight() - me.legendHeight) + "px",
                        textSpan: me.textSpan,
                        textCanvas: me.textCanvas,
                        headerCssClass: me.headerCssClass,
                        valueCssClass: me.valueCssClass,
                        isAndroidTab: me.isAndroidTab,
                        widget: me,
                        treeColumnIdx: me.treeColumnIdx,
                        backgroundColor: me.backgroundColor,
                        domRefName: LEFT_CHART_ROW,
                        showScrollbars: true
                    };
                    var w = new mstrmojo.VisMicroChartTable(props);
                    w.render();
                    me._leftChart = w;
                    w.parent = me;

                    me.replaceScrollerUpdate(w);
                } else {
                    var props = {
                        placeholder: me.leftChart,
                        colInfos: me.colInfos.slice(0, this.attrColumnCount),
                        theme: me.theme,
                        isTreeMode: me.isTreeMode,
                        showMinLabel: me.showMinLabel,
                        width: me.leftWidth + "px",
                        height: (me.getHeight() - me.legendHeight) + "px",
                        textSpan: me.textSpan,
                        textCanvas: me.textCanvas,
                        headerCssClass: me.headerCssClass,
                        valueCssClass: me.valueCssClass,
                        isAndroidTab: me.isAndroidTab,
                        widget: me,
                        treeColumnIdx: me.treeColumnIdx,
                        backgroundColor: me.backgroundColor,
                        domRefName: LEFT_CHART_ROW,
                        showScrollbars: false,
                        zIndex: 1
                    };
                    var w = new mstrmojo.VisMicroChartTable(props);
                    w.render();
                    me._leftChart = w;
                    w.parent = me;
                    me.leftChart = w.domNode;

                    //								$CSS.applyShadow(me.leftChart, this.dropShadowWidth, 0, this.dropShadowWidth, '#888');

                    var props = {
                        placeholder: me.rightChart,
                        colInfos: me.colInfos.slice(this.attrColumnCount),
                        theme: me.theme,
                        isTreeMode: me.isTreeMode,
                        showMinLabel: me.showMinLabel,
                        width: me.rightWidth + "px",
                        height: (me.getHeight() - me.legendHeight) + "px",
                        textSpan: me.textSpan,
                        textCanvas: me.textCanvas,
                        headerCssClass: me.headerCssClass,
                        valueCssClass: me.valueCssClass,
                        isAndroidTab: me.isAndroidTab,
                        widget: me,
                        treeColumnIdx: me.treeColumnIdx,
                        backgroundColor: me.backgroundColor,
                        domRefName: RIGHT_CHART_ROW,
                        showScrollbars: true
                    };
                    var w2 = new mstrmojo.VisMicroChartTable(props);
                    w2.render();
                    me._rightChart = w2;
                    w2.parent = me;
                    me.rightChart = w2.domNode;

                    me.replaceScrollerUpdate(w2);

                    if (this.theme == DEFAULT_LIGHT_THEME || this.theme == CUSTOM_LIGHT_THEME) {
                        me.dropShadowDiv.style.backgroundImage = "-webkit-gradient(linear, left top, right top, color-stop(0, rgba(0,0,0,0.25)), color-stop(1, rgba(0,0,0,0)))";
                    } else {
                        me.dropShadowDiv.style.backgroundImage = "-webkit-gradient(linear, left top, right top, color-stop(0, rgba(0,0,0,0.5)), color-stop(1, rgba(0,0,0,0)))";
                    }

                    w2.addSyncScroller(w);
                    w.addSyncScroller(w2);

                    me.scrollerConfig.scrollEl = me.rightChart;
                    me.updateScroller();

                    var scrollTo = null;
                    if (this.mcStatus && this.mcStatus.hScrollPos != undefined) {
                        var xPos = Math.min(this.mcStatus.hScrollPos * this.rightWidth, this.rightWidth + this.leftWidth - this.getWidth());
                        scrollTo = this._scroller.origin = {
                            x: xPos,
                            y: 0
                        }
                    }
                    setScrollerPosition.call(me, scrollTo);

                    //make sure the header table in left chart and right chart have the same height
                    var headerHeight = Math.max(me._leftChart.headerTableOffsetHeight, me._rightChart.headerTableOffsetHeight);
                    me._leftChart.headerTable.style.height = headerHeight + "px";
                    me._rightChart.headerTable.style.height = headerHeight + "px";
                    me._leftChart.updateHeaderTableOffsetH();
                    me._rightChart.updateHeaderTableOffsetH();

                }
                me.rowOffsetHeight = (me.otherProps.mbHideTextColumns && this.enableSmoothScroll) ? w2.rowOffsetHeight : w.rowOffsetHeight;

                if (me.isTreeMode) {
                    if (me.mcStatus && me.mcStatus.dHRowIdxList) {
                        //restore the dockedHeaders
                        me._leftChart.initDHs();
                        if (me._rightChart) {
                            me._rightChart.initDHs();
                        }
                        me.addRowsToDH(me.mcStatus.dHRowIdxList);
                        if (me.mcStatus.dHReplaceRowIdxList.length > 0) {
                            me.addRowsToDH(me.mcStatus.dHReplaceRowIdxList, true);
                            var pastOffset = me.mcStatus.scrollTo.y % me.rowOffsetHeight;
                            //shite the row
                            me.shiftDockedHeaderWithRow(-pastOffset);
                        }

                    } else {
                        me.initDockedHeaders();
                    }
                }

                /*
                 * remove the mcStatus after all the mcStatus are restored
                 * as we will recreate it in unrender accoring to whether it is null
                 */
                me.removeMCStatus();

                me.getDefaultHighlightRow();
                me.updateSelectedStatus(me.tree);
                me.updateHighlightForCurrRenderRows();

                me.chartTableMaxHeight = me.getHeight() - me._leftChart.headerTableOffsetHeight;
                if (me.legendDis) {
                    me.chartTableMaxHeight -= me.legendHeight;
                }

                //if the height of widget is to large, make it to 20, so that won't take to much memory.
                //but make sure pageSize not smaller than the minPageSize.
                me.pageSize = Math.max(Math.min(parseInt(me.chartTableMaxHeight / me.rowOffsetHeight) + 1, 20), me.minPageSize);
                setChartTableHeight.call(me);

                /*
                 * clear the selected highlight when all info windows are closed and there are not any other select targets
                 */
                var xtabModel = me.xtabModel,
                    docModel = (xtabModel && xtabModel.docModel);
                if (docModel) {
                    me._infoWClosedListener = me.xtabModel.docModel.attachEventListener('infoWindowClosed', this.id, function (evt) {
                        var infoWindowK = evt.psKey;
                        //selection targets are all info window && the closed info window is our target
                        if (!me.hasNonifwTarget && me.selectorTargets && me.selectorTargets[infoWindowK]) {

                            window.setTimeout(function () {
                                if (me.isTreeMode) {
                                    var treeNode = me.lastSelectedObj[me.lastSelectedObj.length - 1];
                                    if(treeNode && treeNode.treePath){
                                        //store the attr info for the infoWindow, so when tap on this attr again will not trigger infow
                                        me.closedIfwAttr = treeNode.treePath;
                                        me.currSelectedObj = [];
                                        // update the highlight
                                        me.updateSelectedStatus(me.tree);
                                        me.updateHighlightForCurrRenderRows();
                                        me.lastSelectedObj = [];
                                    }
                                } else {
                                    if (me.isAllAttrSelectable) {
                                        //store the attr info for the infoWindow, so when tap on this attr again will not trigger infow
                                        me.closedIfwAttr = me.prevSelected.mrow;

                                        me.clearPreHighlightRowStatus();
                                        //			        								me.prevSelected = {mrow:-2,mcol:-1};
                                        me.updateUnselectedRemainCells();

                                        // update the highlight
                                        me.updateSelectedStatus(me.tree);
                                        me.updateHighlightForCurrRenderRows();
                                    } else {
                                        var mcol = me.prevSelected && me.prevSelected.mcol;
                                        var id = me.colInfos[mcol] && me.colInfos[mcol].order;
                                        id = id.split(":")[0];

                                        //store the attr info for the infoWindow, so when tap on this attr again will not trigger infow
                                        me.closedIfwAttr = id;

                                        var ctlMatrix = me.ctlMatrix[id];
                                        var ctlMatrixCG = me.ctlMatrix[id + ":CG"];
                                        var selectedIdxBackup = ctlMatrix.selectedIdx;
                                        var selectedIdxCGBackup = ctlMatrixCG && ctlMatrixCG.selectedIdx;
                                        ctlMatrix.selectedIdx = {};
                                        if (ctlMatrixCG) {
                                            ctlMatrixCG.selectedIdx = {};
                                        }

                                        // update the highlight
                                        me.updateSelectedStatus();
                                        me.updateHighlightForCurrRenderRows();

                                        ctlMatrix.selectedIdx = selectedIdxBackup;
                                        if (ctlMatrixCG) {
                                            ctlMatrixCG.selectedIdx = selectedIdxCGBackup;
                                        }
                                    }

                                }
                            }, 10);

                        }
                    });
                }

                this.renderTextTooltip();

                //		        			this.evalExpr = function(expr) { return eval(expr); }
                //		        			mstrmojo.VisDebuggerUtils.enable(this);
            },

            renderTextTooltip: function renderTextTooltip() {
                //renderToolip
                var props = {
                    placeholder: this.textTooltip,
                    boundary: this.domNode
                };
                this._textTooltip = new mstrmojo.VisTextTooltip(props);
                this._textTooltip.render();

                this._textTooltip.toggle(false);
            },

            /*
             * As we are using windowing algorithm, we only render part of the rows and when we scroll to the boundary,
             * we will render the following part of rows. The scroll bar can only indicate the position relative to the current rendered rows,
             * but not to the whole rows.
             * So we rewrite the updateScrollBars function
             */
            replaceScrollerUpdate: function replaceScrollerUpdate(chartTable) {

                chartTable._scroller.updateScrollBars = function updateScrollBars(viewportCoords, scrollBarContainerElement) {
                    var scrollEl = this.scrollEl;

                    // Are we not showing scrollbars, or do we not have a scroll element yet?
                    if (!this.showScrollbars || !scrollEl) {
                        // Nothing to do here.
                        return;
                    }

                    var bars = this._scrollBarEls;

                    var chartTableRenderRatio = this.chartTableRenderRatio || 1;
                    var topUnRenderedRatio = this.topUnRenderedRatio || 0;

                    // Have we NOT created the scroll bar DOM elements yet?
                    if (!bars) {
                        var me = this;
                        bars = this._scrollBarEls = {
                            x: 'hScroll',
                            y: 'vScroll'
                        };

                        // Iterate the axes...
                        $forEachHash(bars, function (scroll, axis) {
                            // Do we support scrolling for this axis?
                            if (me[scroll]) {
                                // YES, then create the scroll bar element...
                                var bar = document.createElement('div');
                                bar.className = 'mstrmojo-touch-scrollBar ' + axis + 'Axis';

                                // and insert into DOM and scrollBars collection.
                                (scrollBarContainerElement || scrollEl.parentNode).appendChild(bar);
                                bars[axis] = bar;
                            } else {
                                // NO, so remove this axis from the collection of bars.
                                delete bars[axis];
                            }
                        });
                    }

                    // Did the consumer not supply viewportCoords?
                    if (!viewportCoords) {
                        // Create viewportCoords based on the scoll elements parent node.
                        var parentNode = this.scrollEl.parentNode;
                        viewportCoords = {
                            top: 0,
                            right: parentNode.clientWidth,
                            bottom: parentNode.clientHeight,
                            left: 0
                        };
                    }

                    // Convert the viewportCoords into position (and length) coordinates for the scrollbars.
                    var offset = 9,
                        scrollBarCoords = {
                            x: {
                                left: viewportCoords.left,
                                top: viewportCoords.bottom - offset,
                                x: viewportCoords.right - viewportCoords.left,
                                d: 'Width'
                            },
                            y: {
                                left: viewportCoords.right - offset,
                                top: viewportCoords.top,
                                x: viewportCoords.bottom - viewportCoords.top,
                                d: 'Height'
                            }
                        };

                    var me = this;
                    // Size the scrollbars.
                    $forEachHash(bars, function (bar, axis) {
                        var barStyle = bar.style,
                            coords = scrollBarCoords[axis],
                            dimension = coords.d,
                            parentNode = bar.parentNode,
                            x = coords.x;

                        // Calculate position...
                        var left = coords.left,
                            top = coords.top + x * topUnRenderedRatio,
                            ratio = x / scrollEl['offset' + dimension] * chartTableRenderRatio,
                            length = Math.min(Math.round(x * ratio), x);

                        // cache on bar for scrolling...
                        bar.baseLeft = left;
                        bar.baseTop = top;
                        bar.ratio = ratio;
                        bar.viewportSize = $M.round(x * chartTableRenderRatio);
                        bar.length = length;

                        // position and size bar.
                        barStyle.left = left + 'px';
                        barStyle.top = top + 'px';
                        barStyle[dimension.toLowerCase()] = length + 'px';

                        var isX = (axis === 'x'),
                            direction = isX ? 'hScroll' : 'vScroll';
                        if (me[direction]) {
                            //update the scrollbar pos in its viewport
                            var origin = me.origin,
                                position = origin && origin[axis] || 0,
                                viewportSize = bar.viewportSize,
                                minScale = 6 / length,
                                minPosition = bar['base' + ((isX) ? 'Left' : 'Top')],
                                maxPosition = minPosition + viewportSize - length,
                                newPosition = $M.round(minPosition + (ratio * position));

                            // Adjust position and bar length for scroll out cases.
                            if (newPosition < minPosition) {
                                newPosition = minPosition - position;
                                length += position;
                            } else if (newPosition > maxPosition) {
                                var delta = (position - me.offset[axis].end) * ratio;
                                newPosition = $M.min(maxPosition + delta, viewportSize + minPosition - 6) - 1;
                                length -= delta;
                            }

                            // Move and size the bar.  Use webkitTransform for better performance.
                            var v = 0,
                                translate = [v, v, v],
                                scale = [1, 1, 1],
                                idx = (isX) ? 0 : 1;

                            translate[idx] = (newPosition - minPosition);
                            scale[idx] = $M.min($M.max(length / bar.length, minScale), 1);

                            $D.translate(bar, translate[0], translate[1], translate[2], ' scale3d(' + scale.join(',') + ')');
                            //				                    $D.translate(bar, translate[0], translate[1], translate[2], me.transform, me.useTranslate3d);

                        }
                    });
                }

            },

            setElementDimension: function setElementDimension(e, width) {
                var paddingWidth = 0;

                var compStyle = mstrmojo.css.getComputedStyle(e);
                if (compStyle.paddingLeft) {
                    paddingWidth += parseFloat(compStyle.paddingLeft);
                }
                if (compStyle.paddingRight) {
                    paddingWidth += parseFloat(compStyle.paddingRight);
                }

                e.style.width = (width - paddingWidth) + 'px';

            },

            setColorByTheme: function setColorByTheme() {
                var bulletProps = this.bulletProps;
                if (this.theme == DEFAULT_DARK_THEME) {
                    this.bandColor1 = "#494949";
                    this.bandColor2 = "#595959";
                    this.bandColor3 = "#727272";

                    this.refLinePosColor = "#FF781D";
                    this.refLineNegColor = "#FF781D";
                    this.refLineWidth = 2;
                    this.blueBarPosColor = "#00BDFF";
                    this.blueBarNegColor = "#00BDFF";
                } else if (this.theme == DEFAULT_LIGHT_THEME) {
                    this.bandColor1 = "#A5A5A5";
                    this.bandColor2 = "#B3B3B3";
                    this.bandColor3 = "#C4C4C4";

                    this.refLinePosColor = "#FF781D";
                    this.refLineNegColor = "#FF781D";
                    this.refLineWidth = 2;
                    this.blueBarPosColor = "#00BDFF";
                    this.blueBarNegColor = "#00BDFF";
                } else {
                    this.bandColor1 = bulletProps.mwBand1 || "#999999";
                    this.bandColor2 = bulletProps.mwBand2 || "#BBBBBB";
                    this.bandColor3 = bulletProps.mwBand3 || "#DEDEDE";

                    this.refLinePosColor = bulletProps.mwRefLineCol;
                    this.refLineNegColor = bulletProps.mwRefLineCol;
                    this.blueBarPosColor = bulletProps.mwPosCol;
                    this.blueBarNegColor = bulletProps.mwNegCol;
                }
            },

            renderLegend: function renderLgd() {
                var bulletProps = this.bulletProps;

                this.setColorByTheme();

                this.legendDis = this.showGauge && this.bulletProps.mbShowLegend;
                if (this.legendDis) {
                    this.legend.className += " " + this.valueCssClass;

                    /*
                     * set chartTable max-height, so that the legend will not be covered
                     * max-height not work well on all the device, so that we call setChartTableHeight  manually
                     */
                    //								var chartTableContainer = this.chartTable.parentNode;
                    //								chartTableContainer.style.maxHeight = this.getHeight() - 30 - ht.offsetHeight;

                    this.legend.style.display = "block";
                    this.legend.style.fontSize = Math.round(11 * zf) + "pt";
                    this.setElementDimension(this.legend, this.getWidth());

                    if (bulletProps.mstrBand1) {
                        this.legendLowFont.innerHTML = bulletProps.mstrBand1;
                    }
                    this.legendLowBand.style.backgroundColor = this.bandColor1;

                    if (bulletProps.mstrBand2) {
                        this.legendMidFont.innerHTML = bulletProps.mstrBand2;
                    }
                    this.legendMidBand.style.backgroundColor = this.bandColor2;

                    if (bulletProps.mstrBand3) {
                        this.legendHighFont.innerHTML = bulletProps.mstrBand3;
                    }
                    this.legendHighBand.style.backgroundColor = this.bandColor3;

                    var lowWidth = this.legendLow.offsetWidth,
                        midWidth = this.legendMid.offsetWidth,
                        highWidth = this.legendHigh.offsetWidth;

                    if (lowWidth + midWidth + highWidth > this.getWidth()) {
                        //legend will be shown in more than one row
                        if (lowWidth + midWidth > this.getWidth()) {
                            this.legendLow.style.width = this.width;
                            if (midWidth + highWidth > this.getWidth()) {
                                this.legendMid.style.width = this.width;
                                this.legendHigh.style.width = this.width;
                            } else {
                                this.legendMid.style.width = (this.getWidth() - highWidth) + "px";
                            }
                        } else {
                            this.legendLow.style.width = (this.getWidth() - midWidth) + "px";
                            this.legendHigh.style.width = this.width;
                        }
                    }
                    this.legendHeight = this.legend.firstChild.offsetHeight;
                    this.legend.style.height = this.legendHeight + "px";

                } else {
                    this.legend.style.display = "none";
                    this.legendHeight = 0;
                }
            },

            showChartTooltip: function showChartTooltip(touchedChart, touch) {
                var me = this;
                var wasNoTooltip = this.tooltip.style["display"] === "none" || !(this.tooltip.style["display"]);
                touchedChart.showTooltip(touch.pageX, touch.pageY);
                var nowHasTooltip = this.tooltip.style["display"] === "block";
                this.tooltipShow = nowHasTooltip;
                // if the tooltip's style is block, add
                if (wasNoTooltip && nowHasTooltip) {
                    var touchManager = mstrmojo.touchManager;
                    this._touchListener = touchManager.attachEventListener('touchesBegin', this.id, function (evt) {
                        if (!isTouchedOnWidget.call(me, evt.touch)) {
                            hideTooltipGlobal.call(me, evt.touch); // hide the tooltip
                        }
                    });
                }

            },

            touchSelectBegin: function touchSelectBegin(touch) {
                if (touch.evt.ctrlKey) { // if ctrl Key is pressed
                    this.touchMultiBegin(touch);
                    return;
                }

                var me = this;

                hideTooltipGlobal.call(me);

                var td = mstrmojo.dom.findAncestorByAttr(touch.target, "mcol", true, this.domNode);
                if (td && td.node) {
                    var mrow = td.node.getAttribute("mrow");
                    var mcol = td.node.getAttribute("mcol");

                    if (mrow == -1) {
                        //on table header
                        this.showTextTooltip(td.node, mcol, true);

                    } else {
                        var tr = td.node.parentNode;
                        var rowInfo = null;
                        if (tr.getAttribute("rowType") == DOCKED_HEADER) {
                            var dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderRows, mrow);
                            if (dockedHeaderIdx >= 0) {
                                rowInfo = this.dockedHeaderRows[dockedHeaderIdx];
                            } else {
                                dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderReplaceRows, mrow);
                                rowInfo = this.dockedHeaderReplaceRows[dockedHeaderIdx];
                            }
                        } else {
                            rowInfo = this.rows[mrow];
                        }

                        var colInfo = this.colInfos[mcol];
                        if (colInfo.type == CHART) {
                            var touchedChart = rowInfo && rowInfo.rowRef && rowInfo.rowRef[mcol];
                            if (touchedChart) {
                                this.showChartTooltip(touchedChart, touch);
                                this.currSelectedWidget = { mrow: mrow, mcol: mcol };
                            }
                        } else if (colInfo.type == ATTR_NAME || colInfo.type == METRIC_VALUE || colInfo.type == METRIC_NAME) {
                            this.showTextTooltip(td.node, mcol);
                        }
                    }

                }
            },

            showTextTooltip: function showTextTooltip(e, mcol, onHeader) {
                if (onHeader) {
                    var colInfo = this.colInfos[mcol],
                        text = colInfo.title;
                    if (colInfo.titleOverflow && this._textTooltip) {
                        this._textTooltip.updateContent(e, onHeader ? 'title' : 'content', text);

                    }
                } else {
                    var text = e.innerText;
                    var tmpLength = this.getTextWidthByCanvas(text, e, true);
                    if (tmpLength > e.offsetWidth && this._textTooltip) {
                        this._textTooltip.updateContent(e, onHeader ? 'title' : 'content', text);

                    }
                }

            },

            hideTextTooltip: function hideTextTooltip() {
                if (this._textTooltip) {
                    this._textTooltip.toggle(false);
                }
            },

            touchSelectEnd: function touchSelectEnd(touch) {
                if (touch.evt.ctrlKey) {
                    this.touchMultiEnd(touch);
                    return;
                }
                this.currSelectedWidget = null;
                this.hideTextTooltip();
            },

            touchSelectMove: function touchSelectMove(touch) {
                if (touch.evt.ctrlKey) {
                    this.touchMultiMove(touch);
                    return;
                }

                if (!this.currSelectedWidget) {
                    return;
                }

                // first hide tooltip. So it will not block the chart that underneith it
                this.tooltip.style.display = "none";

                var target = touch.target;

                var mcol = -1,
                    colInfo = null;

                var targetFound = true;
                var td = mstrmojo.dom.findAncestorByAttr(target, "mcol", true, this.domNode);
                td = td && td.node;
                if (td) {
                    mcol = td.getAttribute("mcol");
                    colInfo = this.colInfos[mcol];
                    //if it is bullet, we need to recalculate the target
                    if (colInfo.order == "GaugeChart") {
                        //why not just use touch.target? The tooltip for bullet is not correct cross rows and docked header on device, if we use touch.target.
                        // use this way, we don't need to calculate object by ourselves
                        targetFound = false;
                    }
                } else {
                    //tap on tooltip
                    targetFound = false;
                }

                if (targetFound === false) {
                    target = document.elementFromPoint(touch.pageX, touch.pageY);
                    //find the td and mrow again, as target update
                    td = mstrmojo.dom.findAncestorByAttr(target, "mcol", true, this.domNode);
                    td = td && td.node;
                    if (!td) {
                        return;
                    }
                    mcol = td.getAttribute("mcol");
                    colInfo = this.colInfos[mcol];
                }

                var mrow = td.getAttribute("mrow");
                var tr = td.parentNode;

                //find rowInfo
                var rowInfo = null;
                if (tr.getAttribute("rowType") == DOCKED_HEADER) {
                    var dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderRows, mrow);
                    if (dockedHeaderIdx >= 0) {
                        rowInfo = this.dockedHeaderRows[dockedHeaderIdx];
                    } else {
                        dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderReplaceRows, mrow);
                        rowInfo = this.dockedHeaderReplaceRows[dockedHeaderIdx];
                    }
                } else {
                    rowInfo = this.rows[mrow];
                }

                var touchedChart = rowInfo && rowInfo.rowRef && rowInfo.rowRef[mcol];
                var tooltipShown;
                if (touchedChart) {
                    if (colInfo.order == "LineChart" || colInfo.order == "BarChart") {
                        if (mrow == this.currSelectedWidget.mrow && mcol == this.currSelectedWidget.mcol) {
                            tooltipShown = touchedChart.showTooltip(touch.pageX, touch.pageY);
                            this.currSelectedWidget = { mrow: mrow, mcol: mcol };
                        }
                    } else {
                        if (mcol == this.currSelectedWidget.mcol && mrow != this.currSelectedWidget.mrow) {
                            tooltipShown = touchedChart.showTooltip(touch.pageX, touch.pageY);
                            this.currSelectedWidget = { mrow: mrow, mcol: mcol };
                        }
                    }
                }

                if (tooltipShown) {
                    this.tooltipShow = true;
                }
                console.log("tooltip show:" + this.tooltipShow);
                if (this.tooltipShow) {
                    this.tooltip.style.display = "block";
                }

            },

            touchSwipeBegin: function touchSwipeBegin(touch) {
                hideTooltipGlobal.call(this);
                //First check if scrollable element is selected if yes call the super to scroll
                if (isScrollableElementTouched.call(this, touch) && this._super) {
                    this._super(touch);
                } else {
                    this._touchCanceled = true;
                }

            },

            touchSwipeMove: function touchSwipeMove(touch) {
                //First check if scrollable element is selected if yes call the super to scroll
                if (!this._touchCanceled && this._super) {
                    this._super(touch);
                }
            },

            touchSwipeEnd: function touchSwipeEnd(touch) {
                //First check if scrollable element is selected if yes call the super to scroll
                if (!this._touchCanceled && this._super) {
                    this._super(touch);
                }
            },

            getColIdx: function getColIdx(order) {
                var colInfos = this.colInfos,
                    colCount = colInfos.length;
                for (var i = 0; i < colCount; i++) {
                    var target = colInfos[i].order.split(":")[0];
                    if (target + ":CG" == colInfos[i].order) {
                        target = target + ":CG";
                    }
                    if (order == target) {
                        return colInfos[i].colIdx || i;
                    }
                }
                return -1;
            },

            buildLeftParent: function buildLeftParent(node, mrow, mcol) {
                var colInfos = this.colInfos,
                    colCount = colInfos.length;

                if (!this.isKPI) {
                    // non KPI mode
                    if (mrow == -1) { // select all
                        var gts = this.model.gts;
                        var metricIndex = mstrmojo.array.find(gts.col, 'n', 'Metrics');
                        node._e = gts.col[metricIndex].es[colInfos[mcol].order] || {id: "", n: ""};
                        node.v = node._e.n;
                    } else {
                        var rows = this.model.gts.row;
                        var currNode = node;

                        for (var i = colCount - 1; i >= 0; i--) {
                            var colInfo = colInfos[i];
                            if (colInfo.type == CHART) {
                                continue;
                            }
                            if (colInfo.type == ATTR_NAME) {
                                var nodeLP = {};
                                var index = mstrmojo.array.find(rows, 'id', colInfo.order.split(":")[0]);
                                nodeLP.titleInfo = rows[index];
                                nodeLP._e = this.rows[mrow].model.elms[colInfo.order] || {id: "", n: ""};
                                nodeLP.v = nodeLP._e.n;
                                nodeLP.axis = ROW_AXIS;

                                currNode._lp = nodeLP;
                                currNode = nodeLP;
                            }
                        }
                    }
                } else {
                    // KPI mode
                    if (mcol == 0) {
                        // metric name, select all
                        var gts = this.model.gts;
                        var metricIndex = mstrmojo.array.find(gts.col, 'n', 'Metrics');
                        node._e = gts.col[metricIndex].es[mrow] || {id: "", n: ""};
                        node.v = node._e.n;
                    } else {
                        var rows = this.model.gts.row;
                        var currNode = node;
                        for (var i = 0; i < rows.length; i++) {
                            var nodeLP = {};
                            nodeLP.titleInfo = rows[i];
                            var idx = rows[i].es.length;
                            nodeLP._e = rows[i].es[idx - 1] || {id: "", n: ""};
                            nodeLP.v = nodeLP._e.n;
                            nodeLP.axis = ROW_AXIS;

                            currNode._lp = nodeLP;
                            currNode = nodeLP;
                        }
                    }
                }
            },

            getModelK: function getModelK() {
                var k = this.model && this.model.k;

                return k;
            },

            addSCObjToList: function addSCObjToList(scObjList, rowH, n, id) {
                var scObj = {};
                scObj.sc = rowH.sc;
                scObj.es = n;
                scObj.eid = id;
                scObjList.push(scObj);
            },

            getSelectionObjForTreeMode: function getSelectionObjForTreeMode(touchedObj) {
                var attrIdxArray = this.attrMapIdx;
                var me = this,
                    model = me.model,
                    gts = model.gts,
                    rows = gts.row;

                var scObjList = [];
                var actionType = 0;
                var selectedAll = false;

                var treeNode = touchedObj.treeNode;
                var treePath = treeNode.treePath;
                var treePathArray = treePath.split("_");
                var treeLevel = treePathArray.length - 1;
                var isAttrSelectable = this.isAttrSelectable(treeLevel);

                if (this.closedIfwAttr == treePath) {
                    /*
                     * tapped on the attr which has show its infowindow and the ifw is the only target for this attr,
                     * the highlight will be clear and we do nothing here
                     */
                    return null;
                }

                if (isAttrSelectable) {
                    // tapped attr is selectable
                    var isTappedNodeSelected = this.lastSelectedObj && this.lastSelectedObj[treeLevel] && (this.lastSelectedObj[treeLevel].treePath == treePath);

                    if (!isTappedNodeSelected) {
                        //try to do selection
                        this.currSelectedObj = this.getSelectedTreeNodeListFromTreePath(treePathArray);

                        var useFirstAttr = false;
                        var parentTreeNode = this.currSelectedObj[treeLevel];
                        for (var i = treeLevel + 1; i < this.lastSelectedObj.length; i++) {
                            var thisLevelSelectable = this.isAttrSelectable(i);
                            var thisLevelSelected = !!this.lastSelectedObj[i];

                            if (!thisLevelSelectable || !thisLevelSelected) {
                                /*
                                 * this level is not selectable, or this level is selectable but currently not selected
                                 * we will also not select it, so currSelectedObj[i] is null
                                 * for the furture children nodes, useFirstAttr will be true
                                 * update the parentTreeNode to its first child
                                 */
                                useFirstAttr = true;
                                this.currSelectedObj[i] = null;
                                parentTreeNode = parentTreeNode.childrenTreeNodeList[0];
                                continue;
                            }

                            /*
                             * for this level, we will find one node to select
                             * if useFirstAttr == false, we will try to find the same node in last selection
                             * else use the first node
                             */
                            if (!useFirstAttr) {
                                //find the same Attr
                                var attrID = this.lastSelectedObj[i].id;
                                var treeNodeList = parentTreeNode.childrenTreeNodeList;
                                for (var j = 0; j < treeNodeList.length; j++) {
                                    if (attrID == treeNodeList[j].id) {
                                        //find the attr
                                        this.currSelectedObj[i] = treeNodeList[j];
                                        break;
                                    }
                                }
                                if (j == treeNodeList.length) {
                                    //not find
                                    useFirstAttr = true;
                                }
                            }

                            if (useFirstAttr) {
                                this.currSelectedObj[i] = parentTreeNode.childrenTreeNodeList[0];
                            }

                            //update parentTreeNode for next level
                            parentTreeNode = this.currSelectedObj[i];
                        }

                        selectedAll = false;
                        //build scObj from this.currSelectedObj
                        for (var i = 0; i < this.currSelectedObj.length; i++) {
                            var treeNode = this.currSelectedObj[i];
                            if (treeNode) {
                                var attrIdx = attrIdxArray[i];
                                rowH = rows[attrIdx];

                                this.addSCObjToList(scObjList, rowH, treeNode.n, treeNode.id);
                            } else {
                                //treeNode not select
                                continue;
                            }
                        }
                    } else {
                        //try to do unselection
                        for (var i = treeLevel; i < this.lastSelectedObj.length; i++) {
                            var treeNode = this.currSelectedObj[i];

                            if (!treeNode) {
                                continue;
                            }

                            var attrIdx = attrIdxArray[i];
                            rowH = rows[attrIdx];

                            var unselectable = rowH.sc && !(rowH.sc.all === "false" || rowH.sc.all === false);

                            if (treeNode && !unselectable) {
                                //selectable && not unselectable
                                //if the child is not select all enabled, stop here and do not check any further
                                break;

                            } else {
                                //do unselect
                                this.addSCObjToList(scObjList, rowH, treeNode.n, "OA:(All)");
                                this.currSelectedObj[i] = null;
                            }
                        }

                        //if the level tapped is unselectable, so nothing is changed
                        if (i == treeLevel) {
                            return {at: 0};
                        }

                        //remove all the null at last
                        while (this.currSelectedObj.length > 0 && !this.currSelectedObj[this.currSelectedObj.length - 1]) {
                            this.currSelectedObj.pop();
                        }

                        //build scObj for the unselected nodes
                        for (; i < this.currSelectedObj.length; i++) {
                            var treeNode = this.currSelectedObj[i];
                            if (treeNode) {
                                var attrIdx = attrIdxArray[i];
                                rowH = rows[attrIdx];

                                this.addSCObjToList(scObjList, rowH, treeNode.n, treeNode.id);
                            } else {
                                //treeNode not select
                                continue;
                            }
                        }
                        //									/*
                        //									 * If the children node is unselectable, we will stop unselect further children
                        //									 * So we need to retain the highlight for them.
                        //									 * So here we clear the retain selected rows  in lastSelectedObj, whose highlight will be clear
                        //									 */
                        //									for(;i < this.lastSelectedObj.length; i++){
                        //										this.lastSelectedObj[i] = null;
                        //									}

                        selectedAll = true;

                    }
                }

                if (scObjList.length > 0) {
                    actionType = actionType | SELECTOR_ACTION;

                    var hasInfoWOnNode = this.hasInfoWOnNode(rows[attrIdxArray[treeLevel]]);
                    //node use as info window anchor
                    var anchorNode = selectedAll ? null : hasInfoWOnNode ? touchedObj.node : null;

                    return {at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: anchorNode};
                }

                return null;

            },

            /*
             * return whether the selection target contain infoWindow on the rowH
             * onlyIfW: if true means the target only contain infoWindow
             */
            hasInfoWOnNode: function hasInfoWOnNode(rowH, onlyIfW) {
                var xtabModel = this.xtabModel,
                    docModel = (xtabModel && xtabModel.docModel);
                if (docModel) {
                    var layouts = docModel.defn && docModel.defn.layouts,
                        layout = null;
                    var i;
                    // for document which has multiple layouts
                    if (layouts) {
                        for (i in layouts) {
                            if (layouts[i].loaded) {
                                layout = layouts[i];
                                break;
                            }
                        }
                    }
                    var units = layout && layout.units;
                    if (units && rowH) {
                        var tksList = rowH.sc.tks.split("\x1E");
                        for (var j = 0; j < tksList.length; j++) {
                            var unit = units[tksList[j]];
                            if (unit) {
                                if (this.isChildOfIfw(units, unit)) {
                                    if (!onlyIfW) {
                                        return true;
                                    }
                                } else {
                                    if (onlyIfW) {
                                        return false;
                                    }
                                }
                            }
                        }

                    }
                }

                return onlyIfW ? true : false;
            },

            getSelectionObjForNonTreeMode: function getSelectionObjForNonTreeMode(touchedObj) {
                var mcol = touchedObj.mcol,
                    mrow = touchedObj.mrow,
                    colInfos = this.colInfos;
                var attrIdxArray = this.attrMapIdx;
                var me = this,
                    model = me.model,
                    gts = model.gts,
                    rows = gts.row;

                var scObjList = [];
                var actionType = 0;
                var selectedAll = false;

                var id = colInfos[mcol].order;

                if (this.isAllAttrSelectable) {
                    // entire row mode

                    //								if(this.closedIfwAttr == mrow){
                    //									/*
                    //									 * tapped on the attr which has show its infowindow and the ifw is the only target for this attr,
                    //									 * the highlight will be clear and we do nothing here
                    //									 */
                    //									return null;
                    //								}

                    id = id.split(":")[0];

                    var hasTapRemainCell = this.updateUnselectedRemainCells({mrow: mrow, mcol: mcol});
                    if (hasTapRemainCell) {
                        return null;
                    }

                    if (mrow == this.prevSelected.mrow) { // xiawang: if current click and previous click is on the same row
                        //do unselection
                        if (mrow >= 0) {
                            // xiawang: if they are both on the normal row, unselected
                            for (var key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                if (!obj.sc || !obj.sc.tks) { // just to next object
                                    continue;
                                }
                                /*
                                 * a.	if the "select all" has been set for all attributes, then the highlight is removed and the selection is cleared
                                 * b.	if the "select all" has not be set on any attributes, then the tap is ignored
                                 * c.	if the "select all" has been set on some but not all of the attributes, then the highlight and selection is removed only from those attributes that support the select all
                                 */
                                if (obj.sc.all === "false" || obj.sc.all === false) {
                                    var i = 0;
                                    var colInfos = this.colInfos;
                                    var colCount = colInfos.length;
                                    for (; i < colCount; i++) {
                                        if (key == colInfos[i].order.split(":")[0]) {
                                            break;
                                        }
                                    }
                                    this.unselectedRemainCells.push({mrow: mrow, mcol: i});
                                    continue;
                                }

                                var selectedIdx = obj.map[mrow];
                                var elementId = obj.es[selectedIdx].id;
                                if (!elementId || elementId.substring(0, 1) === "D") {
                                    // xiawang: jump for subtotal and empty ID;
                                    continue;
                                }
                                ;
                                selectedAll = true;
                                this.addSCObjToList(scObjList, obj, "", "OA:(All)");
                            }
                            if (scObjList.length > 0) {
                                this.clearPreHighlightRowStatus();
                                this.prevSelected = {mrow: -2, mcol: -1};
                                this.updateUnselectedRemainCells();

                                actionType = actionType | SELECTOR_ACTION;
                                //node use as info window anchor
                                var anchorNode = selectedAll ? null : touchedObj.node;
                                return {at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: anchorNode};
                            } else {
                                this.unselectedRemainCells = [];
                            }

                            //do nothing, return actionObj with actionType = 0;
                            return {at: actionType};
                        }
                    } else {// return if tap on the remainCell, otherwise clean the unselectedRemainCells
                        this.updateUnselectedRemainCells();
                        this.unselectedRemainCells = [];
                    }

                    if (touchedObj.mrow == -1) {
                        //PM required: remove the selection and link drilling on header
                        // if click on the header, set all element for that attribute
                        //									if (this.ctlMatrix && this.ctlMatrix[id]) {
                        //										var obj = this.ctlMatrix[id];
                        //										if (obj.sc && obj.sc.tks) {
                        //											if(this.prevSelected.mrow != -1){
                        //												//if preSelected is also header, no need to hidden the highlight
                        //												this.clearPreHighlightRowStatus();
                        //											}
                        //
                        //											var scObj = {};
                        //											scObj.sc = obj.sc;
                        //											scObj.es = "";
                        //											scObj.eid = "OA:(All)";
                        //											scObjList.push(scObj);
                        //											if(scObjList.length > 0){
                        //												colInfos[mcol].selected = true;
                        //												this.prevSelected = {mrow:mrow,mcol:mcol};
                        //
                        //												actionType = actionType | SELECTOR_ACTION;
                        //												//node use as info window anchor
                        //												return {at:actionType, k:this.getModelK(), scObjList:scObjList, anchor:touchedObj.node};
                        //											}
                        //
                        //										}
                        //
                        //									}
                    } else {
                        if (this.ctlMatrix) {
                            this.clearPreHighlightRowStatus();

                            for (var key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                if (!obj.sc) { // just to next object
                                    continue;
                                }
                                if (!obj.sc.tks || (obj.sc.tks == "")) {
                                    //if no targets, ignore the selector
                                    continue;
                                }
                                var selectedIdx = obj.map[mrow];
                                if (obj.es[selectedIdx]) {
                                    var elementId = obj.es[selectedIdx].id;
                                    if (!elementId || elementId.substring(0, 1) === "D") {
                                        // xiawang: jump for subtotal and empty ID;
                                        continue;
                                    }
                                    ;

                                    this.addSCObjToList(scObjList, obj, "", elementId);
                                }

                            }
                            if (scObjList.length > 0) {
                                this.rows[mrow].selected[-1] = true;
                                this.prevSelected = {mrow: mrow, mcol: -1};

                                actionType = actionType | SELECTOR_ACTION;
                                //node use as info window anchor
                                var anchorNode = selectedAll ? null : touchedObj.node;
                                return {at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: anchorNode };
                            }
                        }
                    }

                } else {
                    //not entire row mode
                    var isCG = false;
                    if (id.indexOf(":CG") === id.length - 3 && id.length >= 3) {
                        isCG = true;
                    }
                    id = id.split(":")[0];

                    //								if(this.closedIfwAttr == id){
                    //									/*
                    //									 * tapped on the attr which has show its infowindow and the ifw is the only target for this attr,
                    //									 * the highlight will be clear and we do nothing here
                    //									 */
                    //									return null;
                    //								}

                    if (this.ctlMatrix && this.ctlMatrix[id]) {
                        var ctlMatrix = this.ctlMatrix[id];
                        var ctlMatrixCG = this.ctlMatrix[id + ":CG"];

                        if (ctlMatrix.sc && ctlMatrix.sc.tks != "") {
                            // selectable
                            var elementId = "";
                            var isAll = false;

                            if (mrow == -1) {
                                //PM required: remove the selection and link drilling on header
                                // select all
                                //											elementId = "OA:(All)"; // OA:(All)
                                //											isAll = true;
                                //											//only need to update ctlMatrix,
                                //											//as we will highlight header table according to ctlMatrix
                                //											ctlMatrix.selectedIdx = {};
                                //											ctlMatrix.selectedIdx[-1] = true;
                            } else {
                                var selectedIdx = ctlMatrix.map[mrow];
                                if (ctlMatrix.es[selectedIdx]) {
                                    elementId = ctlMatrix.es[selectedIdx].id;
                                    if (!elementId || elementId.substring(0, 1) === "D") {
                                        // xiawang: jump for subtotal and empty ID;
                                        return;
                                    }
                                }

                                var sameAsLastSelected = function () {
                                    var result = ctlMatrix.selectedIdx[selectedIdx];
                                    if (ctlMatrixCG) {
                                        //is CG
                                        if (ctlMatrixCG.selectedIdx[-1]) {
                                            //all the CG node selected
                                            return result;
                                        } else {
                                            return result && ctlMatrixCG.selectedIdx[ctlMatrixCG.map[mrow]];
                                        }
                                    }
                                    return result;
                                }
                                if (sameAsLastSelected()) {
                                    //do unselect
                                    var canSelectAll = !(ctlMatrix.sc.all === "false" || ctlMatrix.sc.all === false);
                                    if (canSelectAll) {
                                        elementId = "OA:(All)";
                                        selectedAll = true;
                                        ctlMatrix.selectedIdx = {};
                                        if (ctlMatrixCG) {
                                            ctlMatrixCG.selectedIdx = {};
                                        }
                                        this.prevSelected = {mrow: -2, mcol: -1};
                                    } else {
                                        return null;
                                    }

                                } else {
                                    //do select
                                    ctlMatrix.selectedIdx = {};
                                    ctlMatrix.selectedIdx[selectedIdx] = true;

                                    if (ctlMatrixCG) {
                                        ctlMatrixCG.selectedIdx = {};
                                        if (isCG) {
                                            //click on CG children node
                                            //select this node and this parent
                                            ctlMatrixCG.selectedIdx[ctlMatrixCG.map[mrow]] = true;
                                            if (ctlMatrixCG.map[mrow] < ctlMatrixCG.es.length) {
                                                //if has children node, get its element id
                                                elementId = ctlMatrixCG.es[ctlMatrixCG.map[mrow]].id;
                                            }
                                        } else {
                                            //click on CG parent node
                                            //select all the CG node

                                            ctlMatrixCG.selectedIdx[-1] = true;
                                        }
                                    }

                                    //used to decide the selected attr after infow closed
                                    this.prevSelected = {mrow: mrow, mcol: mcol};
                                }
                            }
                            var scObj = {};
                            scObj.sc = ctlMatrix.sc;
                            scObj.eid = elementId;
                            scObjList.push(scObj);
                        }
                    }

                    if (scObjList.length > 0) {
                        actionType = actionType | SELECTOR_ACTION;
                        //node use as info window anchor
                        var anchorNode = selectedAll ? null : touchedObj.node;
                        return {at: actionType, k: this.getModelK(), scObjList: scObjList, anchor: anchorNode};
                    }
                }

                return null;

            },

            getLinkDrillObjForTreeMode: function getLinkDrillObjForTreeMode(touchedObj) {

                var actionType = 0;
                var linkDrillNode = null;

                var model = this.model,
                    gts = model.gts,
                    rowHs = gts.row;
                var mcol = touchedObj.mcol,
                    mrow = touchedObj.mrow,
                    colInfos = this.colInfos;

                var treeNode = touchedObj.treeNode;
                var treePath = treeNode.treePath;
                var treePathArray = treePath.split("_");
                var treeLevel = treePathArray.length - 1;
                var attrIdxArray = this.attrMapIdx;

                //find col index
                var id = null;
                var colInfo = colInfos[mcol];
                var colType = colInfo && colInfo.type;
                if (colType == ATTR_NAME) {
                    if (mrow == -1) {
                        /*
                         * PM required: remove selection and link drill on header from 931
                         */
                        //tapped on header
                        //									var rowH = rowHs[0];
                        //									if(rowH.lm && rowH.lm[0] && rowH.lm[0].links){
                        //										linkDrillNode = {};
                        //										linkDrillNode.titleInfo = rowH;
                        //					            		linkDrillNode._e = {n:"", id:""};
                        //					            		linkDrillNode.v = linkDrillNode._e.n;
                        //									}
                    } else {
                        //tapped on treeNode
                        var rowH = rowHs[attrIdxArray[treeLevel]];
                        if (rowH.lm && rowH.lm[0] && rowH.lm[0].links) {
                            linkDrillNode = {};
                            linkDrillNode.titleInfo = rowH;
                            var treeNode = getTreeNode(this.tree, treePath);
                            linkDrillNode._e = treeNode.es[0] || {n: "", id: ""};
                            linkDrillNode.v = linkDrillNode._e.n;
                        }
                    }

                } else if (colType == METRIC_VALUE) {
                    if (colInfo.lm) {
                        //has link drill on this metric

                        id = colInfo.order;
                        //tapped on metric
                        var mix = parseInt(id); //metric idx

                        var metricH = gts.col[0];//metric Header in gts

                        if (metricH) {
                            //this metric has defined link drill
                            linkDrillNode = {};
                            linkDrillNode.mix = mix;
                            linkDrillNode.titleInfo = metricH;

                            if (mrow == -1) {
                                // tapped on metric header
                                linkDrillNode._e = metricH.es[mix] || {n: "", id: ""};
                                linkDrillNode.v = linkDrillNode._e.n;
                            } else {
                                // tapped on metric vaule
                                //build TreeNode Parent Attr
                                var currNode = linkDrillNode;
                                var treeNode = this.tree;
                                for (var i = 0; i < treePathArray.length; i++) {
                                    var idx = treePathArray[i];
                                    treeNode = treeNode.childrenTreeNodeList[idx];

                                    var attrIdx = attrIdxArray[i];
                                    rowH = rowHs[attrIdx];

                                    var nodeLP = {};
                                    nodeLP.titleInfo = rowH;
                                    nodeLP._e = treeNode.es[0] || {n: "", id: ""};
                                    nodeLP.v = nodeLP._e.n;

                                    currNode._lp = nodeLP;
                                    currNode.axis = ROW_AXIS;
                                    currNode = nodeLP;
                                }
                            }
                        }
                    }

                }

                if (linkDrillNode) {
                    this.highlightEntireRow = false;
                    actionType = actionType | HYPERLINK_ACTION;
                    return {at: actionType, k: this.getModelK(), node: linkDrillNode};
                }
            },

            getLinkDrillObjForNonTreeMode: function getLinkDrillObjForNonTreeMode(touchedObj) {
                var actionType = 0;

                var model = this.model,
                    gts = model.gts,
                    rowHs = gts.row;
                var mcol = touchedObj.mcol,
                    mrow = touchedObj.mrow,
                    colInfos = this.colInfos;

                var node = touchedObj.node, titleInfo;
                this.highlightEntireRow = false;
                var attrIdxArray = this.attrMapIdx;
                var colInfo = colInfos[mcol];

                if (!this.isKPI) {
                    // non-KPI mode
                    if (linkCount === 1 && attrCount === 1 && mrow != -1) {
                        //only one link drill, check whether the link drill is on attr
                        for (var key in colInfos) {
                            var colInf = colInfos[key];
                            if (colInf.lm && colInf.type == ATTR_NAME) {
                                // if there is only one attr and there is one link drill on it
                                // entire row mode
                                this.highlightEntireRow = true;
                                var titleInfo = colInf.lm;
                                actionType = titleInfo && titleInfo.at || HYPERLINK_ACTION;
                                node._e = this.rows[mrow].model.elms[colInf.order] || { id: "", n: "" };
                                node.v = node._e.n;
                                break;
                            }
                        }

                    }

                    if (!this.highlightEntireRow) {

                        if (colInfo.type == CHART) {
                            return null;
                        }

                        var titleInfo = colInfo.lm;
                        if (titleInfo) {
                            actionType = titleInfo && titleInfo.at;

                            if (colInfo.type == ATTR_NAME) {
                                // attribute
                                if (mrow === -1) { // attribute
                                    // header
                                    node._e = {};
                                    node._e.onTitle = true;
                                    node._e.id = titleInfo.id;
                                    node._e.n = titleInfo.n;
                                    node.v = titleInfo.n;
                                } else { // attribute element
                                    node._e = this.rows[mrow].model.elms[colInfo.order] || { id: "", n: "" };
                                    node.v = node._e.n;
                                }
                            } else if (colInfo.type == METRIC_VALUE) { // metric
                                node.mix = colInfo.order;
                                node.axis = ROW_AXIS;

                                this.buildLeftParent(node, mrow, mcol);
                                actionType = this.rows[mrow == -1 ? 0 : mrow].model.refv[colInfo.order].at || HYPERLINK_ACTION;
                            }
                        }
                    }
                } else {
                    //KPI mode
                    if (colInfo.type == CHART) {
                        return null;
                    }
                    var titleInfo = colInfo.lm;
                    var metricIdx = this.rows[mrow].model.metricIdx;
                    if (titleInfo && titleInfo.lm && titleInfo.lm[metricIdx] && titleInfo.lm[metricIdx].links) {

                        node.mix = "" + metricIdx;
                        node.axis = ROW_AXIS;

                        this.buildLeftParent(node, metricIdx, mcol);
                        actionType = this.rows[mrow].model.refv[0].at || HYPERLINK_ACTION;
                    } else {
                        titleInfo = null;
                    }

                }

                if (titleInfo) {
                    node.titleInfo = titleInfo;
                    actionType = actionType | HYPERLINK_ACTION;

                    return {at: actionType, mcol: mcol, mrow: mrow, k: this.getModelK(), node: node};
                }

                return null;
            },

            getActionObj: function getActionObj(touchedObj) {
                var actionObjList = [];

                if (touchedObj.mrow == -1) {
                    //PM required: remove the selection and link drilling on header
                    return null;
                }

                var actionObj = null;

                //first try to do selection
                if (this.isTreeMode) {
                    actionObj = this.getSelectionObjForTreeMode(touchedObj);
                } else {
                    actionObj = this.getSelectionObjForNonTreeMode(touchedObj);
                }

                if (actionObj) {
                    actionObjList.push(actionObj);
                    return actionObjList;
                } else {
                    //if no selection try to do link drill
                    if (this.isTreeMode) {
                        actionObj = this.getLinkDrillObjForTreeMode(touchedObj);
                    } else {
                        actionObj = this.getLinkDrillObjForNonTreeMode(touchedObj);
                    }
                    actionObjList.push(actionObj);
                }
                return actionObjList;
            },

            /*
             * find the default highlight row for treemode and entire row mode in non-treemode
             * if the highlight targets only contains infowindow, then don't show the highlight
             */
            getDefaultHighlightRow: function getDHR() {
                var attrIdxArray = this.attrMapIdx;
                var rows = this.model.gts.row;

                if (!this.isTreeMode) {

                    if (this.isAllAttrSelectable) {
                        //for entire row mode
                        //only useful for the find the default highlight

                        var isAllSelected = false;
                        var resultSet = null,
                            controlMatrix = null;
                        var hasOnlyIfwTarget = true;
                        var colInfos = this.colInfos,
                            colCount = colInfos.length;

                        for (var i = 0; i < colCount; i++) {
                            var colInfo = colInfos[i],
                                id = colInfo.order;
                            var trueId = id.split(":")[0];
                            if (id != trueId + ":CG") {
                                // for Custom Group, We should use CG control matrix, not default control matrix
                                id = trueId;
                            }
                            controlMatrix = this.ctlMatrix[id];
                            if (controlMatrix) {
                                if (!this.hasInfoWOnNode(controlMatrix, true)) {
                                    hasOnlyIfwTarget = false;
                                }
                                //PM require: remove all the selection and link drill for header
                                // update header;
                                if (controlMatrix.selectedIdx[-1]) {
                                    // add style
                                    isAllSelected = true;
                                    this.prevSelected = {
                                        mrow: -1,
                                        mcol: i
                                    };
                                    //											colInfo.selected = true;
                                } else {
                                    colInfo.selected = false;
                                }

                                if (!isAllSelected) {
                                    if (!resultSet) {
                                        // for the first time, we need to set result set
                                        resultSet = {};
                                        for (var j = 0; j < controlMatrix.map.length; j++) {
                                            if (controlMatrix.selectedIdx[controlMatrix.map[j]]) {
                                                resultSet[j] = true;
                                            }
                                            ;
                                        }
                                        ;
                                    } else { // we remove result set from existing set
                                        for (var j in resultSet) {
                                            if (!controlMatrix.selectedIdx[controlMatrix.map[j]]) { // if row
                                                delete resultSet[j];
                                            }
                                            ;
                                        }
                                        ;
                                    }
                                    ;
                                }
                                ;
                            }
                        }

                        if (hasOnlyIfwTarget) {
                            //remove the selectedIdx in controlMatrix
                            for (key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                obj.selectedIdx = {};
                            }
                        }
                        if (hasOnlyIfwTarget || isAllSelected || !resultSet || Object.keys(resultSet).length !== 1) {
                            // do nothing, will go to default mode
                        } else {
                            console.log("xiawang: The selected row is:" + JSON.stringify(resultSet));
                            var selectedRow = parseInt(Object.keys(resultSet)[0]);
                            this.prevSelected = {
                                mrow: selectedRow,
                                mcol: -1
                            };

                            if (this.rows[selectedRow]) {
                                this.rows[selectedRow].selected[-1] = true;
                            }

                            //remove the selectedIdx in controlMatrix
                            for (key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                obj.selectedIdx = {};
                            }
                        }
                    } else {
                        //none treemode, not entire row mode
                        var hasOnlyIfwTarget = true;
                        for (key in this.ctlMatrix) {
                            var controlMatrix = this.ctlMatrix[key];
                            var checkThisAttr = false;
                            for (var sIdx in controlMatrix.selectedIdx) {
                                checkThisAttr = true;
                            }
                            if (checkThisAttr && !this.hasInfoWOnNode(controlMatrix, true)) {
                                hasOnlyIfwTarget = false;
                                break;
                            }
                        }

                        if (hasOnlyIfwTarget) {
                            //remove the selectedIdx in controlMatrix
                            for (key in this.ctlMatrix) {
                                var obj = this.ctlMatrix[key];
                                obj.selectedIdx = {};
                            }
                        }
                    }

                } else {
                    //Treemode
                    //use the default highlight when the this.currSelectedObj is not set
                    if (this.currSelectedObj && this.currSelectedObj.length <= 0) {
                        var resultSet = null,
                            controlMatrix = null;

                        this.currSelectedObj = [];

                        var findTreeNodeByAttrElemIdx = function (treeNodeList, attrElemIdx) {
                            var treeNodeCount = treeNodeList.length;
                            for (var i = 0; i < treeNodeCount; i++) {
                                var treeNode = treeNodeList[i];
                                if (treeNode.attrElemIdx == attrElemIdx) {
                                    return treeNode;
                                }
                            }
                            return null;
                        };

                        var me = this;

                        var findCurrSelectedObjByAttrElemIdx = function (tree, level) {
                            var id = me.attrIDArray[level];
                            controlMatrix = me.ctlMatrix[id];

                            var treeNodeList = tree.childrenTreeNodeList;
                            var treeNodeCount = treeNodeList.length;
                            if (treeNodeCount <= 0) {
                                return;
                            }

                            var treeNode = null;
                            if (controlMatrix) {
                                for (var key in controlMatrix.selectedIdx) {
                                    treeNode = findTreeNodeByAttrElemIdx(treeNodeList, key);
                                }

                                if (treeNode) {
                                    me.currSelectedObj[level] = treeNode;
                                    findCurrSelectedObjByAttrElemIdx(treeNode, level + 1);

                                    return true;
                                }

                            } else {
                                //do not care
                                me.currSelectedObj[level] = null;
                                for (var i = 0; i < treeNodeCount; i++) {
                                    var find = findCurrSelectedObjByAttrElemIdx(treeNodeList[i], level + 1);
                                    if (find) {
                                        return true;
                                    }
                                }

                            }

                            return false;

                        };

                        findCurrSelectedObjByAttrElemIdx(this.tree, 0);

                        //remove all the null at last
                        while (this.currSelectedObj.length > 0 && !this.currSelectedObj[this.currSelectedObj.length - 1]) {
                            this.currSelectedObj.pop();
                        }

                        //if the target for the default highlight contains only infowindow, then do not show the highlight
                        var hasOnlyIfwTarget = true;
                        for (var i = 0; i < this.currSelectedObj.length; i++) {
                            var treeNode = this.currSelectedObj[i];
                            if (treeNode) {
                                var attrIdx = attrIdxArray[i];
                                rowH = rows[attrIdx];
                                if (!this.hasInfoWOnNode(rowH, true)) {
                                    hasOnlyIfwTarget = false;
                                    break;
                                }
                            } else {
                                //treeNode not select
                                continue;
                            }
                        }
                        if (hasOnlyIfwTarget) {
                            this.currSelectedObj = [];
                        }

                        this.lastSelectedObj = $HASH.clone(this.currSelectedObj);
                        return;

                    }
                }
            },

            /*
             * update rowInfos:
             * rowInfo.selected[-1] = true; --- highlight the row
             * rowInfo.selected[i] = true; --- highlight the cell with column idx i
             */
            updateSelectedStatus: function updateSS(tree) {
                if (this.isTreeMode) {
                    this.updateTreeSelection(tree);
                } else if (!this.isAllAttrSelectable || this.unselectedRemainCells.length > 0) {

                    if (!this.ctlMatrix) {
                        return;
                    }
                    //for not entire row mode
                    var update = function (key) {
                        var pureId = key.split(":")[0],
                            ctlMatrix = this.ctlMatrix[pureId],
                            ctlMatrixCG = this.ctlMatrix[pureId + ":CG"];

                        // work for header table
                        // use ctlMatrix
                        var colInfos = this.colInfos,
                            selectedIdx = ctlMatrix.selectedIdx,
                            colIdx = ctlMatrix.colIdx;
                        //PM required: remove the selection and link drilling on header
                        //									if(selectedIdx[-1]){
                        //										//selected header
                        //										colInfos[colIdx].selected = true;
                        //									}else{
                        //										colInfos[colIdx].selected = false;
                        //									}

                        // now work for body
                        if (ctlMatrixCG && !ctlMatrixCG.selectedIdx[-1]) {
                            //has CG
                            //select all the CG attr, according to ctlMatrix
                            //select CG attr according to ctlMatrixCG
                            ctlMatrix = ctlMatrixCG;
                        }
                        var map = ctlMatrix.map,
                            rows = this.rows,
                            rowCount = rows.length,
                            selectedIdx = ctlMatrix.selectedIdx,
                            colIdx = this.ctlMatrix[key].colIdx,
                            assAttr = colInfos[colIdx].associateAttr;

                        for (var i = 0; i < rowCount; i++) {
                            var rowInfo = rows[i];
                            if (selectedIdx[map[i]]) {
                                rowInfo.selected[colIdx] = true;
                                //TQMS 734480: When there are multi attribute forms are displayed in Microchart, these forms should work as one attribute.
                                for (var idx in assAttr) {
                                    rowInfo.selected[assAttr[idx]] = true;
                                }
                            } else {
                                rowInfo.selected[colIdx] = false;
                                for (var idx in assAttr) {
                                    rowInfo.selected[assAttr[idx]] = false;
                                }
                            }
                        }
                    }

                    for (var key in this.ctlMatrix) {

                        update.call(this, key);
                    }
                }

            },

            hasOnlyInfoWindowTarget: function hasOnlyInfoWindowTarget() {

            },

            performAction: function performAction(actionObjList) {
                this.hasNonifwTarget = this.hasNoninfowindowTarget(actionObjList[0]);

                if (this._super) {
                    this._super(actionObjList);
                }

            },

            //only used when entire row mode for non tree mode
            clearPreHighlightRowStatus: function clearPreHighlightRowStatus(pass) {
                var mrow = this.prevSelected.mrow,
                    mcol = this.prevSelected.mcol;

                if (mrow == -2) {
                    //no prev highlight
                    return;
                }
                if (mcol == -1) {
                    // remove entire row
                    this.rows[mrow].selected[-1] = false;
                } else {
                    // remove cell highlight
                    if (mrow == -1) {
                        // clear all table header, as there may be more than one header selected
                        for (var i = 0; i < this.colInfos.length; i++) {
                            var colInfo = this.colInfos[i];
                            if (colInfo.selected) {
                                colInfo.selected = false;
                            }
                        }
                        //									this.colInfos[mcol].selected = false;
                    } else {
                        this.rows[mrow].selected[mcol] = false;
                    }

                }

            },

            updateUnselectedRemainCells: function uurc(tappedCell) {
                var hasTapRemainCell = false;

                for (var i = this.unselectedRemainCells.length - 1; i >= 0; i--) {
                    cell = this.unselectedRemainCells[i];

                    var id = order[cell.mcol];

                    var isCG = false;
                    if (id.indexOf(":CG") === id.length - 3
                        && id.length >= 3) {
                        isCG = true;
                    } else {
                        id = id.split(":")[0];
                    }

                    var obj = this.ctlMatrix[id];
                    // xiawang: We also need to update CG ctlMatrix. This follows Flash behavior
                    var anotherObj = undefined;
                    if (isCG) {
                        anotherObj = this.ctlMatrix[id.split(":")[0]];
                    } else {
                        anotherObj = this.ctlMatrix[id + ":CG"];
                    }
                    if (obj.sc && obj.sc.tks != "") {

                        if (anotherObj && !anotherObj.sc) {
                            anotherObj = undefined;
                        }

                        var selectedIdx = obj.map[cell.mrow];
                        elementId = obj.es[selectedIdx].id;
                        if (!elementId || elementId.substring(0, 1) === "D") {
                            // xiawang: jump for subtotal and empty ID;
                            // return;
                            continue;
                        } else {
                            if (obj.selectedIdx[selectedIdx]) {
                                if (tappedCell) {
                                    if (cell.mcol == tappedCell.mcol) {
                                        // tapped on remain cell
                                        var tappedID = order[cell.mcol].split(":")[0];
                                        var tappedCtlMatrix = this.ctlMatrix[tappedID];
                                        var tappedIdx = tappedCtlMatrix.sc && tappedCtlMatrix.map[tappedCell.mrow];
                                        if (tappedIdx == selectedIdx) {
                                            hasTapRemainCell = true;
                                        }
                                    }
                                    continue;

                                }
                                // clear the unselected remain cell before we selected others
                                obj.selectedIdx = {};

                            } else {
                                obj.selectedIdx = {};
                                // set selectedIdx for the unselectedRemainCell, so that the remain cell can be highlight after the unselected
                                obj.selectedIdx[selectedIdx] = true;
                                if (anotherObj) {
                                    if (elementId.indexOf("BE") === 0 || elementId.indexOf("Z") === 0) {
                                        // if click on concrete element, do nothing
                                    } else {
                                        // if click on other element, copy idx
                                        anotherObj.selectedIdx = {};
                                        anotherObj.selectedIdx[selectedIdx] = true;
                                    }
                                }
                            }

                        }
                    }

                }

                return hasTapRemainCell;

            },

            highlightCellsByRowInfo: function highlightCellsByRowInfo(rowInfo) {
                var rowRef = rowInfo.rowRef;
                if (!rowRef) {
                    return;
                }

                var trL = rowRef[LEFT_CHART_ROW];
                var trR = rowRef[RIGHT_CHART_ROW];

                var tdsL = trL && trL.childNodes;
                var tdsR = trR && trR.childNodes;
                var tdsLLen = tdsL && tdsL.length || 0,
                    tdsRLen = tdsR && tdsR.length || 0;

                var colCount = tdsLLen + tdsRLen;

                for (var i = 0; i < colCount; i++) {
                    var td = i < tdsLLen ? tdsL[i] : tdsR[i - tdsLLen];
                    if (rowInfo.selected[i]) {
                        this.highlightCell(td);
                    } else {
                        this.unHighlightCell(td);
                    }
                }
            },

            setSelectedStyle: function setSelectedStyle(level) {
                if (level == 0) {
                    this.selectedStyle = "background-color:#015DE6;color:#FFFFFF;";
                } else if (level == 1) {
                    this.selectedStyle = "background-color:rgba(1,93,230, 0.7);color:#FFFFFF;";
                } else {
                    this.selectedStyle = "background-color:rgba(1,93,230, 0.5);color:#FFFFFF;";
                }

            },

            highlightTreeArrow: function highlightTreeArrow(rowInfo) {
                if (this.treeColumnIdx > -1 && this._leftChart) {
                    this._leftChart.setTreeArrow(rowInfo, 'white');
                }
            },

            unHighlightTreeArrow: function unHighlightTreeArrow(rowInfo) {
                if (this.treeColumnIdx > -1 && this._leftChart) {
                    this._leftChart.setTreeArrow(rowInfo);
                }
            },

            highlightCell: function highlightCell(td, isHeaderTable) {
                // add style
                if (isHeaderTable) {
                    setNodeCssText(td, TH_SELECTED_CSS + this.selectedStyle);
                } else {
                    setNodeCssText(td, TD_SELECTED_CSS + this.selectedStyle);
                }
                if (this.selectedClass && this.selectedClass.length > 0) {
                    $CSS.addClass(td, this.selectedClass);
                }

            },

            unHighlightCell: function unHighlightCell(td, isHeaderTable) {
                // remove style
                if (isHeaderTable) {
                    setNodeCssText(td, DEFAULT_TH_CSS);
                } else {
                    setNodeCssText(td, DEFAULT_TD_CSS);
                }
                if (this.selectedClass && this.selectedClass.length > 0) {
                    $CSS.removeClass(td, this.selectedClass);
                }
            },

            highlightForLD: function highlightForLD(mrow, mcol, node) {
                if (this.highlightEntireRow && !this.isTreeMode) {
                    this.highlightRowByRowInfo(this.rows[mrow]);
                } else {
                    if (node) {
                        this.highlightCell(node);
                    }

                    var colInfo = this.colInfos[mcol],
                        aAttr = colInfo.associateAttr;
                    var siblings = node.parentNode.childNodes;
                    for (var idx in aAttr) {
                        this.highlightCell(siblings[aAttr[idx]]);

                        if (this.treeColumnIdx == idx) {
                            this.highlightTreeArrow(this.rows[mrow]);
                        }
                    }
                }

            },

            highlightRowByRowInfo: function highlightRowByRowInfo(rowInfo) {
                var rowRef = rowInfo.rowRef;
                if (!rowRef) {
                    return;
                }
                var level = rowInfo.treeNode ? rowInfo.treeNode.level : 0;
                this.setSelectedStyle(level);
                if (rowRef[LEFT_CHART_ROW]) {
                    this.highlightRow(rowRef[LEFT_CHART_ROW]);
                }
                if (rowRef[RIGHT_CHART_ROW]) {
                    this.highlightRow(rowRef[RIGHT_CHART_ROW]);
                }

                /*
                 * PM required: Once a row is selected, the color of the arrow should also be changed along with the text
                 */
                this.highlightTreeArrow(rowInfo);

            },

            highlightRow: function highlightRow(tr) {
                var tds = tr.childNodes;
                for (var i = 0; i < tds.length; i++) {
                    // add style
                    setNodeCssText(tds[i], TD_SELECTED_CSS + this.selectedStyle);

                    if (this.selectedClass && this.selectedClass.length > 0) {
                        $CSS.addClass(tds[i], this.selectedClass);
                    }
                }
            },

            unHighlightRowByRowInfo: function unHighlightRowByRowInfo(rowInfo) {
                var rowRef = rowInfo.rowRef;
                if (!rowRef) {
                    return;
                }
                if (rowRef[LEFT_CHART_ROW]) {
                    this.unHighlightRow(rowRef[LEFT_CHART_ROW]);
                }
                if (rowRef[RIGHT_CHART_ROW]) {
                    this.unHighlightRow(rowRef[RIGHT_CHART_ROW]);
                }

                /*
                 * PM required: Once a row is selected, the color of the arrow should also be changed along with the text
                 */
                this.unHighlightTreeArrow(rowInfo);

            },

            unHighlightRow: function unHighlightRow(tr) {
                var tds = tr.childNodes;
                for (var i = 0; i < tds.length; i++) {
                    // remove style
                    setNodeCssText(tds[i], DEFAULT_TD_CSS);
                    if (this.selectedClass && this.selectedClass.length > 0) {
                        $CSS.removeClass(tds[i], this.selectedClass);
                    }
                }
            },

            /*
             * return whether the attr at tree level ? is selectable
             */
            isAttrSelectable: function isAttrSelectable(treeLevel) {
                var attrID = this.attrIDArray[treeLevel];
                var ctlMatrix = this.ctlMatrix[attrID];
                if (ctlMatrix) {
                    return true;
                }
                return false;
            },

            /*
             * update selected var in this.tree
             */
            updateTreeSelection: function updateTreeSelection(tree) {
                //clear last selected
                this.selectOrClearTreeNodes(tree, true, 0);
                //highlight curr selected
                this.selectOrClearTreeNodes(tree, false, 0);
            },

            findTheTreeNodeWithSameID: function findTheTreeNodeWithSameID(treeNodeList, id) {
                var treeNodeCount = treeNodeList.length;
                for (var i = 0; i < treeNodeCount; i++) {
                    var treeNode = treeNodeList[i];
                    if (treeNode.id == id) {
                        return treeNode;
                    }
                }
                return null;
            },

            //						selectOrClearTreeNodes : function selectOrClearTreeNodes( treeNode, clear, treeLevel) {
            //							if (clear && this.lastSelectedObj.length <= treeLevel) {
            //								// nothing to clear
            //								return;
            //							}
            //							if (!clear && this.currSelectedObj.length <= treeLevel) {
            //								// nothing to highlight
            //								return;
            //							}
            //
            //							// treeLevel for the treeNode in treeNodeList
            //							var isAttrSelectable = this.isAttrSelectable(treeLevel);
            //							if (isAttrSelectable) {
            //
            //								var tappedTreeNode = null;
            //
            //								if(clear){
            //									tappedTreeNode = this.lastSelectedObj[treeLevel];
            //								}else{
            //									tappedTreeNode = this.currSelectedObj[treeLevel];
            //								}
            //
            //								if(tappedTreeNode){
            //
            //									if(treeNode){
            //										treeNode = this.findTheTreeNodeWithSameID(treeNode.childrenTreeNodeList, tappedTreeNode.id);
            //									}else{
            //										treeNode = tappedTreeNode;
            //									}
            //									if (treeNode) {
            //										// same as selected node
            //										treeNode.selected = clear ? false : true;
            //										this.selectOrClearTreeNodes( treeNode, clear, treeLevel + 1);
            //									}
            //								}else{
            //									this.selectOrClearTreeNodes( null, clear, treeLevel + 1);
            //								}
            //
            //							} else {
            //								// attr not selectable
            //								if(treeNode){
            //									var treeNodeList = treeNode.childrenTreeNodeList,
            //										treeNodeCount = treeNodeList.length;
            //									for ( var i = 0; i < treeNodeCount; i++) {
            //										this.selectOrClearTreeNodes( treeNodeList[i], clear, treeLevel + 1);
            //									}
            //								}
            //
            //
            //							}
            //
            //						},

            selectOrClearTreeNodes: function selectOrClearTreeNodes(treeNode, clear, treeLevel) {
                if (!treeNode) {
                    return;
                }
                if (clear && this.lastSelectedObj.length <= treeLevel) {
                    // nothing to clear
                    return;
                }
                if (!clear && this.currSelectedObj.length <= treeLevel) {
                    // nothing to highlight
                    return;
                }

                var tappedTreeNode = null;

                if (clear) {
                    tappedTreeNode = this.lastSelectedObj[treeLevel];
                } else {
                    tappedTreeNode = this.currSelectedObj[treeLevel];
                }

                var treeNodeList = treeNode.childrenTreeNodeList,
                    treeNodeCount = treeNodeList.length;

                if (tappedTreeNode) {

                    treeNode = this.findTheTreeNodeWithSameID(treeNodeList, tappedTreeNode.id);

                    if (treeNode) {
                        // same as selected node
                        treeNode.selected = clear ? false : true;
                        this.selectOrClearTreeNodes(treeNode, clear, treeLevel + 1);
                    }
                } else {
                    for (var i = 0; i < treeNodeCount; i++) {
                        this.selectOrClearTreeNodes(treeNodeList[i], clear, treeLevel + 1);
                    }
                }

            },

            //PM required: remove the selection and link drilling on header
            //						updateHighlightForHeader: function updateHighlightForHeader(){
            //							var tr = this._leftChart.headerTable.firstChild.firstChild;
            //							var colInfos = this.colInfos;
            //							if(tr){
            //								var tds = tr.childNodes;
            //								for(var i = 0; i < tds.length; i++){
            //									if(colInfos[i].selected){
            //										this.highlightCell(tds[i], true);
            //									}else{
            //										this.unHighlightCell(tds[i], true);
            //									}
            //								}
            //
            //							}
            //						},

            updateHighlightForCurrRenderRows: function updateHighlightForCurrRenderRows() {
                //							this.updateHighlightForHeader();
                var rows = this.rows;
                var rowCount = rows.length,
                    rowInfo = null;
                for (var i = this.startCnt; i < this.endCnt; i++) {
                    rowInfo = rows[i];
                    if (this.isTreeMode) {
                        //tree mode
                        if (rowInfo.treeNode.selected) {
                            this.highlightRowByRowInfo(rowInfo);
                        } else {
                            this.unHighlightRowByRowInfo(rowInfo);
                        }
                    } else {
                        //non-tree mode
                        if (this.isAllAttrSelectable) {
                            if (rowInfo.selected[-1]) {
                                //highlight entire row
                                this.highlightRowByRowInfo(rowInfo);
                            } else {
                                this.unHighlightRowByRowInfo(rowInfo);
                            }
                        } else {
                            this.highlightCellsByRowInfo(rowInfo);
                        }

                        if (this.unselectedRemainCells.length > 0) {
                            this.highlightCellsByRowInfo(rowInfo);
                        }
                    }
                }

                if (this.isTreeMode) {
                    //update highlight for docked headers
                    rows = this.dockedHeaderRows;
                    rowCount = rows.length;
                    for (var i = 0; i < rowCount; i++) {
                        rowInfo = rows[i];
                        if (rowInfo.treeNode.selected) {
                            this.highlightRowByRowInfo(rowInfo);
                        } else {
                            this.unHighlightRowByRowInfo(rowInfo);
                        }
                    }
                    rows = this.dockedHeaderReplaceRows;
                    rowCount = rows.length;
                    for (var i = 0; i < rowCount; i++) {
                        rowInfo = rows[i];
                        if (rowInfo.treeNode.selected) {
                            this.highlightRowByRowInfo(rowInfo);
                        } else {
                            this.unHighlightRowByRowInfo(rowInfo);
                        }
                    }
                }

            },

            /*
             * travel from top to bottom use the treePathArray and return a treeNode array on the treePath
             * if the treeNode is not selected, then use null instead
             */
            getSelectedTreeNodeListFromTreePath: function getSelectedTreeNodeListFromTreePath(treePathArray) {
                if (!treePathArray) {
                    return [];
                }
                var treeNodeList = [];
                var treeNode = this.tree;
                for (var i = 0; i < treePathArray.length; i++) {
                    var treeNodeIdx = treePathArray[i];
                    treeNode = treeNode.childrenTreeNodeList[treeNodeIdx];
                    if (!treeNode) {
                        break;
                    }
                    if (this.isAttrSelectable(i)) {
                        treeNodeList[i] = treeNode;
                    } else {
                        treeNodeList[i] = null;
                    }

                }
                return treeNodeList;
            },

            multiTap: true,

            touchTap: function (touch) {
                var widget = this;

                if (widget.tooltip.style["display"] === "block") {
                    hideTooltipGlobal.call(this);
                    return;
                }

                var td = mstrmojo.dom.findAncestorByAttr(touch.target, "mcol", true, this.domNode);
                if (!td) {
                    this._leftChart.dockedHeaderReplaceDiv.style.display = 'none';
                    touch.target = document.elementFromPoint(touch.pageX, touch.pageY);
                    td = mstrmojo.dom.findAncestorByAttr(touch.target, "mcol", true, this.domNode);
                    this._leftChart.dockedHeaderReplaceDiv.style.display = '';
                }
                if (td && td.node) {
                    //find the node
                    var mrow = parseInt(td.node.getAttribute("mrow"));
                    var mcol = parseInt(td.node.getAttribute("mcol"));

                    if (mrow == -1) {
                        //PM required:Starting with 9.3.1, we decided to disable selections by tapping on the header
                        //they seem to be counter-intuitive.  As such, we could disable selection at the top for link-drill as well.
                        return;
                    }

                    if (this.isTreeMode) {

                        if (mrow >= 0) {
                            //tap on body
                            var rowInfo = this.rows[mrow];
                            var treeNode = rowInfo && rowInfo.treeNode;
                            if (touch.count == 2 || ( touch.count == 1 && mcol == this.treeColumnIdx)) {
                                // double tap on any node || single tap on triangle

                                // do collapse and expand one row
                                if (!treeNode.isLeaf) {

                                    this.rowsNeedRebuild = true;

                                    var rowType = td.node.parentNode.getAttribute("rowType");

                                    if (treeNode.needExpand) {
                                        // do collapse
                                        collapseTreeNodeAndSetScrlPos.call(this, rowInfo, rowType);
                                    } else {
                                        // do expand
                                        expandTreeNodeAndSetScrlPos.call(this, rowInfo, rowType);
                                    }
                                }
                                return;
                            }
                        }

                        // do selection and link drilling for treemode
                        var touchedObj = {node: td.node, treeNode: treeNode, mcol: mcol, mrow: mrow};
                        var actionObjList = this.getActionObj(touchedObj);
                        var actionObj = actionObjList && actionObjList[0];
                        if (actionObj) {

                            if (actionObj.at & SELECTOR_ACTION) {
                                // update the highlight

                                //do not need to highlight for infowindow on phone
                                var doHighlight = !(this.isAndroidPhone && actionObj.anchor);
                                if (doHighlight) {
                                    this.updateSelectedStatus(this.tree);
                                    this.updateHighlightForCurrRenderRows();

                                    this.lastSelectedObj = $HASH.clone(this.currSelectedObj);
                                }

                            } else if (actionObj.at & HYPERLINK_ACTION) {
                                //do link drill
                                this.highlightForLD(mrow, mcol, td.node);
                            }

                            this.performAction(actionObjList);
                            //TODO: clear link drill highlight
                            return;
                        }

                    } else {
                        // none tree mode
                        var actionObjList = this.getActionObj({mcol: mcol, mrow: mrow, node: td.node});
                        var actionObj = actionObjList && actionObjList[0];
                        if (actionObj) {

                            if (actionObj.at & SELECTOR_ACTION) {
                                //do not need to highlight for infowindow on phone
                                var doHighlight = !(this.isAndroidPhone && actionObj.anchor);
                                if (doHighlight) {
                                    this.updateSelectedStatus();
                                    this.updateHighlightForCurrRenderRows();
                                }

                            } else if (actionObj.at & HYPERLINK_ACTION) {
                                this.highlightForLD(mrow, mcol, td.node);
                            }

                            this.performAction(actionObjList);
                            return;
                        }

                    }

                    /*
                     * PM required:
                     * TQMS 720655:
                     * If the Visualization is "not" configured as a selector,
                     * then tapping on the sparkline or the bullet graph should also trigger the tooltip.
                     */
                    var me = this;
                    var tr = td.node.parentNode;
                    var rowInfo = null;
                    if (tr.getAttribute("rowType") == DOCKED_HEADER) {
                        var dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderRows, mrow);
                        if (dockedHeaderIdx >= 0) {
                            rowInfo = this.dockedHeaderRows[dockedHeaderIdx];
                        } else {
                            dockedHeaderIdx = getIdxByRowIdx(this.dockedHeaderReplaceRows, mrow);
                            rowInfo = this.dockedHeaderReplaceRows[dockedHeaderIdx];
                        }
                    } else {
                        rowInfo = this.rows[mrow];
                    }

                    var touchedChart = rowInfo && rowInfo.rowRef && rowInfo.rowRef[mcol];
                    if (touchedChart) {
                        this.showChartTooltip(touchedChart, touch);
                    }

                }

            },

            /**
             * Returns true if the touch event should be bubbled
             * When user scroll horizonally:
             *    If enable smooth scroll, not bubble
             *    else bubble
             * @type Boolean
             */
            shouldTouchBubble: function shouldTouchBubble(touch) {
                var isVertical = touch.isVertical;
                return isVertical ? this._super(touch) : this.enableSmoothScroll && isScrollableElementTouched.call(this, touch) ? false : true;
            },
            //						shouldTouchBubble: function shouldTouchBubble(touch) {
            //
            //			                // Default to horizontal.
            //			                var scroller = this.enableSmoothScroll ? this._rightChart._scroller : this._leftChart._scroller,
            //			                    isVertical = touch.isVertical;
            //
            //			                return isVertical ? !scroller.vScroll : (this.enableSmoothScroll ? false : true);
            //			            },

            multiTouch: true,

            touchMultiBegin: function (touch) {
                // we have two mode. First is using single touch or
                // mouse event for simpler debug. Second is really
                // multi touch
                // hide tooltip anyway
                hideTooltipGlobal.call(this);
                this.initTouchObj = touch;
                var touch1;
                var touch2;
                if (touch.evt.touches
                    && touch.evt.touches.length == 2) {
                    touch1 = touch.evt.touches[0];
                    touch2 = touch.evt.touches[1];
                } else {
                    touch1 = touch;
                    touch2 = {
                        pageX: 100,
                        pageY: 100,
                        target: touch.target
                    };
                }
                var xDiff = touch1.pageX - touch2.pageX;
                var yDiff = touch1.pageY - touch2.pageY;
                this.initDiffDiff = xDiff * xDiff + yDiff * yDiff;

                this.relScaleFactor = 1;

                var td1 = mstrmojo.dom.findAncestorByAttr(touch1.target, "mrow", true, this.domNode);
                var td2 = mstrmojo.dom.findAncestorByAttr(touch2.target, "mrow", true, this.domNode);
                if (td1 && td1.value && td2 && td2.value) {
                    this.centerRowIdx = Math.round(( parseInt(td1.value) + parseInt(td2.value) ) / 2);
                } else {
                    this.centerRowIdx = this.firstRowIdxOnScrn;//Math.round( this.firstRowIdxOnScrn + this.pageSize/2 );
                }

                // console.log("initDiffDiff:" + this.initDiffDiff +
                // ", with init center:" + this.initCenterX + "," +
                // this.initCenterY);
            },

            touchMultiMove: function (touch) {
                // we have two mode. First is using single touch or
                // mouse event for simpler debug. Second is really
                // multi touch
                var touch1;
                var touch2;
                if (touch.evt.touches
                    && touch.evt.touches.length == 2) {
                    touch1 = touch.evt.touches[0];
                    touch2 = touch.evt.touches[1];
                } else {
                    touch1 = touch;
                    touch2 = {
                        pageX: 100,
                        pageY: 100
                    };
                }
                var xDiff = touch1.pageX - touch2.pageX;
                var yDiff = touch1.pageY - touch2.pageY;
                this.curDiffDiff = xDiff * xDiff + yDiff * yDiff;
            },

            touchMultiEnd: function (touch) {
                if (this.isTreeMode) {
                    if (this.curDiffDiff > this.initDiffDiff) {
                        this.onPinchOpen();
                    } else if (this.curDiffDiff < this.initDiffDiff) {
                        this.onPinchClose();
                    }
                }

            },

            onPinchOpen: function onPinchOpen() {
                var currLowestLevel = getLowestLevelOnScreen.call(this);
                var levelToExpand = currLowestLevel;
                if (levelToExpand >= this.maxTreeLevel) {
                    //for the leaf node, do not set it as needExpand
                    levelToExpand = this.maxTreeLevel - 1;
                }

                var anchorRowTreeNode = this.rows[this.centerRowIdx].treeNode;
                var anchorRowIdxOnScrn = this.centerRowIdx - this.firstRowIdxOnScrn;

                expandOrCollapseTreeAndSetScrlPos.call(this, levelToExpand, anchorRowTreeNode, anchorRowIdxOnScrn);
            },

            onPinchClose: function onPinchClose() {
                var currLowestLevel = getLowestLevelOnScreen.call(this);
                var levelToExpand = currLowestLevel - 2;
                if (levelToExpand < -1) {
                    // needExpand of the highest level(-1)
                    // must be true
                    levelToExpand = -1;
                }

                var anchorRowTreeNode = this.rows[this.centerRowIdx].treeNode;

                if (anchorRowTreeNode.level > levelToExpand + 1) {
                    //the anchor row will be collapsed
                    anchorRowTreeNode = getParentTreeNodeAtLevel(this.tree, anchorRowTreeNode.treePath, levelToExpand + 1);
                }
                var anchorRowIdxOnScrn = this.centerRowIdx - this.firstRowIdxOnScrn;

                expandOrCollapseTreeAndSetScrlPos.call(this, levelToExpand, anchorRowTreeNode, anchorRowIdxOnScrn);

            },

            /*
             * remove the domRef in rowInfo to the domNode
             * call the destroy func of each chart widget
             */
            destroyChartWidget: function destroyChartWidget() {

                if (this.rows && this.rows.length > 0 && this.rowsReusePool) {
                    this.pushToReusePool();
                }

                if (this.dockedHeaderRows && this.dockedHeaderReplaceRows) {
                    this.clearDockedHeader();
                }

                if (this.rowsReusePool && this.rowsReusePool.length > 0) {
                    var rows = this.rowsReusePool,
                        rowCount = rows.length,
                        colInfos = this.colInfos,
                        colCount = colInfos.length;

                    for (var i = 0; i < rowCount; i++) {
                        var rowRef = rows[i];

                        if (rowRef[LEFT_CHART_ROW]) {
                            delete rowRef[LEFT_CHART_ROW];
                        }
                        if (rowRef[RIGHT_CHART_ROW]) {
                            delete rowRef[RIGHT_CHART_ROW];
                        }

                        for (var j = 0; j < colCount; j++) {
                            var w = rowRef[colInfos[j].colIdx];
                            if (w && w.destroy) {
                                w.destroy();
                                delete rowRef[colInfos[j].colIdx];
                            }
                        }
                    }
                    this.rowsReusePool = [];
                }

            },

            destroy: function destroy() {
                console.log("in destroy");
                // Do we have a touch listener?
                var listener = this._touchListener;
                if (listener) {
                    // Detach event listener and delete listener handle.
                    mstrmojo.touchManager.detachEventListener(listener);
                    delete this._touchListener;
                }

                if (this._infoWClosedListener) {
                    mstrmojo.touchManager.detachEventListener(this._infoWClosedListener);
                    delete this._infoWClosedListener;
                }

                this.destroyChartWidget();

                if (this._leftChart) {
                    this._leftChart.destroy();
                    delete this._leftChart;
                }

                if (this._rightChart) {
                    this._rightChart.destroy();
                    delete this._rightChart;
                }

                if (this.rows) {
                    delete this.rows;
                }

                if (this.rowsReusePool) {
                    delete this.rowsReusePool;
                }

                if (this.selectorTargets) {
                    delete this.selectorTargets;
                }

                this._super();
            }



        });

})();
(function () {

    mstrmojo.requiresCls("mstrmojo.DynamicClassFactory",
                         "mstrmojo._CanSupportTransaction",
                         "mstrmojo._IsEditableXtab",
                         "mstrmojo.AndroidInteractiveGridXtab",
                         "mstrmojo.DocXtabModel",
                         "mstrmojo.DocInteractiveGridXtab",
                         "mstrmojo.AndroidVisTimeSeries",
                         "mstrmojo.DocVisTimeSeries",
                         "mstrmojo.VisMicroChart",
                         "mstrmojo.maps.AndroidRptMap",
                         "mstrmojo.maps.AndroidMapModel",
                         "mstrmojo.maps.AndroidDocMap",
                         "mstrmojo.ImageCarousel",
                         "mstrmojo.PhotoUploader",
                         "mstrmojo.AndroidVisMap",
                         "mstrmojo.VisHeatMap");

    var VIS_LIST = {'AndroidImageMapStyle':{'s':'ImageMapVisualizationDataStyle','c':'AndroidVisMap'},'MicroChartsVisualizationStyle':{'s':'MicroChartVisualizationDataStyle','c':'VisMicroChart'},'TimeSeriesAjaxVisualizationStyle':{'dc':'DocVisTimeSeries','s':'TimeSeriesVisualizationDataStyle','c':'AndroidVisTimeSeries'},'ImageViewerVisualizationStyle':{'s':'VisualizationDataStyle','c':'ImageCarousel'},'AndroidPhotoUploaderStyle':{'s':'VisualizationDataStyle','c':'PhotoUploader'},'HeatMapVisualizationStyle':{'s':'HeatMapVisualizationDataStyle','c':'VisHeatMap'},'AndroidMapStyle':{'dc':'maps.AndroidDocMap','s':'MapVisualizationDataStyle','c':'maps.AndroidRptMap','m':'maps.AndroidMapModel'},'InteractiveGridAjaxVisualizationStyle':{'dc':'DocInteractiveGridXtab','s':'InteractiveGridDataStyle','c':'AndroidInteractiveGridXtab','m':'DocXtabModel'}};

    mstrmojo.AndroidVisList = mstrmojo.provide(

        'mstrmojo.AndroidVisList',

        {
            getVis: function getVis(styleName) {
                return VIS_LIST[styleName] || null;
            },

            getVisClass: function getVisClass(cls, defn) {
                // Is this an interactive grid?
                if (defn.txi && defn.t === 115) {
                    cls = mstrmojo.DynamicClassFactory.newComponent(cls, [ mstrmojo._CanSupportTransaction, mstrmojo._IsEditableXtab ]);
                }

                return cls;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.DocSelector",
                         "mstrmojo.Button",
                         "mstrmojo.base64",
                         "mstrmojo.Dialog");

    mstrmojo.requiresDescs(1442, 2140, 5369, 8233, 8232, 8313, 8322);

    var SUBMIT = 8,
        RECALCULATE = 16,
        DISCARD = 4,
        //subsequent actions, refer to EnumDSSXMLRWControlSubsequentAction
        DISPLAY_MSG = 1,
//        DISPLAY_TXREPORT = 2,
//        REFRESH_GRID = 4,
        REEXECUTE_DOCUMENT = 8,
        EXECUTE_OBJECT = 16,
        FORCE_LIVE_EXECUTION = 0x10000000,
        INVALID_CLIENT_CACHE = 0x20000000,
        AUTO_ANSWER_PROMPT = 0x40000000,
        useMojoDialog = window.mstrConfig && !window.mstrConfig.simpleDialog,
        SUBMIT_ERROR_VALIDATION_FAILURE = 0x800424E3,
        SUBMIT_ERROR_NO_CHANGE = 0x800424E4;

    var $NIB = mstrmojo.Button.newInteractiveButton;
   
    function confirmMsg(msg, okFn, cancelFn, okText, cancelText) {
        if (useMojoDialog) {
            var buttons = [$NIB(
                    okText || mstrmojo.desc(1442),
                    okFn || null,
                    null
                ), $NIB(
                    cancelText || mstrmojo.desc(2140),
                    cancelFn || null,
                    null
                )];
            // reverse the button orders for Android
            mstrmojo.confirm(msg, mstrApp.useBinaryFormat ? buttons.reverse() : buttons);
        } else {
            // For the browser native confirmation dialog, check the return value to decide which function to execute.
            if (mstrmojo.confirm(msg)) {
                if (okFn) {
                    okFn();
                }
            } else if (cancelFn) {
                cancelFn();
            }
        }
    }

    function alertMsg(msg, okFn) {
        if (useMojoDialog) {
            mstrmojo.alert(msg, okFn);
        } else {
            mstrmojo.alert(msg);
            if (okFn) {
                okFn();
            }
        }
    }

    /**
     * The Action Selector Widget.
     * 
     * @class
     * @extends mstrmojo.DocSelector
     */
    mstrmojo.DocActionSelector = mstrmojo.declare(

        mstrmojo.DocSelector,

        null,

        /**
         * @lends mstrmojo.ActionSelector.prototype
         */
        {
            scriptClass: 'mstrmojo.DocActionSelector',

            extCls: 'mstrmojo-ActionSelector',

            /**
             * Action selector type, can be SUBMIT, RECALCULATE, and DISCARD
             */
            type: SUBMIT,

            /**
             * An array of the key of the target widgets
             */
            targets: null,

            initControlInfo: function initControlInfo() {
                var defn = this.node.defn;
                this.aa = parseInt(defn.aa, 10);
                this.dpTxt = defn.dpTxt || {8: mstrmojo.desc(5369), 4: mstrmojo.desc(8233), 16: mstrmojo.desc(8232)}[this.aa] || '';
                this.dpCfm = defn.dpCfm;
                this.sac = parseInt(defn.sac, 10);
                this.msg = defn.msg;
                this.rsid = defn.rsid;
                this.rst = defn.rst;

                this.node.data.elms = [{
                    n: this.dpTxt,
                    v: this.dpTxt
                }];

                this._super();
            },

            selectorControlChange: function selectorControlChange(w) {
                //Since we use the same selector code for the button/link rendering, the button/link cannot behavior as a single selection buttons
                //So we need to clear the selected item immediately
                //As we clear selections will trigger onselectionChange, and it will come to this function again
                //To prevent the tasks triggered twice, we should terminate it when we know this is a clear selection action.
                if (w.selectedIndex !== 0) {
                    return;
                }
                this.executeAction();
                w.select([]);
            },

            executeAction: function executeAction() {
                var aa = this.aa,
                    me = this;

                if (aa === SUBMIT) {
                    if (this.dpCfm) {
                        confirmMsg(mstrmojo.desc(8313), function () {
                            me.onControllerCheck();
                        });
                    } else {
                        me.onControllerCheck();
                    }
                } else if (aa === DISCARD) {
                    if (this.dpCfm) {
                        confirmMsg(mstrmojo.desc(8322), function () {
                            me.onDiscard();
                        });
                    } else {
                        me.onDiscard();
                    }
                } else {
                    this.onRecalculate();
                }
            },

            onControllerCheck: function onControllerCheck() {
                //TQMS: do not show any message from controller as we are going to use toast message
                this.onCommit();
            },

            /**
             * Commits all the changes
             */
            onCommit: function onCommit() {
                var me = this,
                    md = this.model,
                    ctl = me.controller,
                    useBinaryMode = mstrApp.useBinaryFormat;

                // For non-binary mode, run the required validation first before submission
                if (!useBinaryMode && !this.validateRequiredObjects()) {
                    alertMsg(mstrmojo.desc(9200)); //'You have some required input that are not modified.'
                    return;
                }

                //execute the subsequent actions
                var executeActions = function (res) {
                    if ((me.sac & INVALID_CLIENT_CACHE) > 0) {
                        ctl.invalidClientCache();
                    }

                    if ((me.sac & EXECUTE_OBJECT) > 0) {
                        var params = {
                            did: me.rsid,
                            objType: me.rst,
                            forceExec: (me.sac & FORCE_LIVE_EXECUTION) > 0
                        };

                        if ((me.sac & AUTO_ANSWER_PROMPT) > 0) {
                            params.linkAnswers = '<hl mid="' + md.mid + '" srct="2" aopam="1"><prms></prms></hl>';
                        }

                        ctl.onExecuteNewObject(me, params);

                    } else if ((me.sac & REEXECUTE_DOCUMENT) > 0) {
                        ctl.onReExecute(me);

                    } else {
                    	// Are we on a mobile device?
                        if (mstrApp.isMobile) {
                            // Make sure the menu is up to date.
                            ctl.generateActionToolbar();
                        }
                    	
                        // Refresh the document to clear all the flags.
                        md.transactionUpdate(res);
                    }
                };

                // show the processing icon
                mstrmojo.mask.show('Running');
                
                md.sendTransactionActions(this.ck, SUBMIT, md.newCallback({
                    success: function (res) {
                        // hide process icon
                        mstrmojo.mask.hide();
                    	
                        //XZ: if the submission is successful from offline tx record
                        if(md.txrcd || res.offln) {
                            ctl.offlineTransactionsSubmitted(me.ck);
                        }
                        
                        if (res.offln) {
                            if(useBinaryMode && !me.networkToastShowed) {
                                me.networkToastShowed = true;
                                mstrmojo.toast(mstrmojo.desc(9258, 'No Network Connectivity') + '. ' + mstrmojo.desc(9259, 'Transaction will be submitted when connectivity is resumed.'));
                            }
                            md.transactionUpdate(res);
                        } else {
                            //if there is display message, we will display confirm dialog first, then execute the subsequent actions
                            if ((me.sac & DISPLAY_MSG) > 0 && me.msg) {
                                // if on device, we use native toast message.
                            	if (useBinaryMode) {
                                    mstrmojo.toast(me.msg);
                                    // TQMS 691289: Decrease the subsequent invocation timeout interval from 3.5 seconds to 100 milliseconds 
                                    window.setTimeout(function () {
                                        executeActions(res);
                                    }, 100);
                                } else {
                                    alertMsg(me.msg, function () {
                                        executeActions(res);
                                    });
                                }
                            } else {
                                executeActions(res);
                            }
                        }
                    },

                    failure: function (res) {
                        var alertDialog = mstrmojo.all.mojoAlertx9;
                        if (alertDialog) {
                            alertDialog.destroy();
                        }
                        // hide process icon
                        mstrmojo.mask.hide();
                    	
                        //XZ: if the submission is failed and the failed transaction is edited from offline tx queue, refresh the tx queue
                        if(md.txrcd) {
                            ctl.offlineTransactionsSubmitted(me.ck);
                        }
                        
                        var errCode = 0x100000000 + parseInt(res.code, 10);
                        if (errCode === SUBMIT_ERROR_VALIDATION_FAILURE) {
                            // When we get this error in binary mode, call the method below to highlight the error field/object
                            if (useBinaryMode) {
                                me.validateRequiredObjects();
                            }
                            alertMsg(mstrmojo.desc(9200, 'You have some required inputs that are not modified.'));

                        } else if (errCode === SUBMIT_ERROR_NO_CHANGE) {
                            var msg = mstrmojo.desc(9201, "You haven't made any changes to submit.");
                            if (useBinaryMode) {
                                mstrmojo.toast(msg);
                            } else {
                                alertMsg(msg);
                            }

                        } else {
                            // Currently we only refresh the document if error happens.
                            alertMsg(mstrmojo.base64.decodeHttpHeader(res.message), function () {
                                // TQMS #524013: Do not refresh the document on android.
                                if (!useBinaryMode) {
                                    me.controller.onReExecute(me, true);
                                }
                            });
                        }
                    }
                }));
            },

            /**
             * Executes the clear all action once the discard button is clicked
             */
            onDiscard: function onDiscard() {
                var me = this,
                    md = this.model,
                    ctl = me.controller;

                md.txDiscardTargets = this.getTxTargets();

                md.sendTransactionActions(this.ck, DISCARD, {
                    success: function (res) {
                        md.transactionUpdate(res);
                        ctl.transactionDiscarded(me.ck);
                    },

                    // Ensure it will be cleared after the discard action is completed.
                    complete: function () {
                        delete md.txDiscardTargets;
                        
                        // Are we on a mobile device?
                        if (mstrApp.isMobile) {
                            // Regenerate menu. 
                            ctl.generateActionToolbar();
                        }
                    }
                });
            },

            /**
             * Submits recalculate action
             */
            onRecalculate: function onRecalculate() {
                this.model.sendTransactionActions(this.ck, RECALCULATE);
            },

            /**
             * @return hashmap of editable widgets which are targeted by this action selector
             */
            getTxTargets: function getTxTargets() {
                var keys = this.tks.split('\u001E'),
                    i,
                    len,
                    key,
                    wid,
                    w,
                    j,
                    res = {};

                for (i = 0, len = keys.length; i < len; i++) {
                    // get the node key
                    key = keys[i];

                    // always start from slice id = 1
                    wid = 1;

                    do {
                        // find (all slices of) the widget instance by node key
                        w = this.model.getUnitInstance(key, wid++);
                        // if exists and can be validated (effectively means it's a panelstack or an editableXtab)
                        if (w && w.checkRequiredObjects) {
                            if (w.isPanelStack) {
                                // add all editable textfields/xtabs on this PS
                                for (j in w.txWidgets) {
                                    res[w.txWidgets[j].id] = 1;
                                }
                            } else { // editable xtab
                                res[w.id] = 1;
                            }
                        } else {
                            break;
                        }
                    } while (true);
                }
                return res;
            },

            /**
             * Validate all the editable widgets associated with this action selector.
             * @return flag {Boolean} validation results
             */
            validateRequiredObjects: function validateRequiredObjects() {
                var flag = true,
                    id;

                for (id in this.getTxTargets()) {
                    flag = mstrmojo.all[id].checkRequiredObjects() && flag;
                }

                return flag;
            }
        }
    );
}());
(function () {

    mstrmojo.requiresCls("mstrmojo.EnumRWUnitType",
                         "mstrmojo.DocLayout",
                         "mstrmojo.DocLayoutHoriz",
                         "mstrmojo.DocSection",
                         "mstrmojo.DocSubsection",
                         "mstrmojo.DocTextfield",
                         "mstrmojo.DocXtabModel",
                         "mstrmojo.DocVisModel",
                         "mstrmojo.XtabBase",
                         "mstrmojo.DocPortlet",
                         "mstrmojo.DocResizablePortlet",
                         "mstrmojo.DocXtabGraph",                        
                         "mstrmojo.DocGridGraph",
                         "mstrmojo.DocLine",
                         "mstrmojo.DocImage",
                         "mstrmojo.DocHTMLContainer",
                         "mstrmojo.DocRectangle",
                         "mstrmojo.DocRoundRectangle",
                         "mstrmojo.DocPanel",
                         "mstrmojo.DocSelector",
                         "mstrmojo.DocActionSelector",
                         "mstrmojo._HasDocLink",
                         "mstrmojo.DocVisualization",
                         "mstrmojo.DynamicClassFactory",
                         "mstrmojo._Formattable",
                         "mstrmojo._IsDocXtab",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo.DocInfoWindow",
                         "mstrmojo._CanSupportTransaction",
                         "mstrmojo._IsEditableXtab",
                         "mstrmojo._IsEditableTextfield",
                         "mstrmojo.DocSelectorViewFactory",
                         "mstrmojo._HasHoverButton",
                         "mstrmojo.hash");

    var $HASH = mstrmojo.hash;

    /**
     * <p>Define the clsMap property here (so we can use the enumeration for object types).</p>
     *
     * @type Object
     * @private
     * @ignore
     */
    var en = mstrmojo.EnumRWUnitType,
        clsMap = {};

    clsMap[en.LAYOUT] = {n: "Layout"};
    clsMap[en.HEADER] =
        clsMap[en.FOOTER] =
        clsMap[en.PAGEHEADER] =
        clsMap[en.PAGEFOOTER] =
        clsMap[en.DETAILS] =        { n: "Section", scriptClass: "mstrmojo.DocSection" };
    clsMap[en.SUBSECTION] =         { n: "SubSection", scriptClass: "mstrmojo.DocSubsection" };
    clsMap[en.TEXTFIELD] =          { n: "Textfield", scriptClass: "mstrmojo.DocTextfield" };
    clsMap[en.GRID] =               { n: "Xtab", scriptClass: "mstrmojo.DocXtab" };
    clsMap[en.GRAPH] =              { n: "XtabGraph", scriptClass: "mstrmojo.DocXtabGraph" };
    clsMap[en.GRIDGRAPH] =          { n: "GridGraph", scriptClass: "mstrmojo.DocGridGraph" };
    clsMap[en.SELECTOR] =           { n: "Selector", scriptClass: "mstrmojo.DocSelector" };
    clsMap[en.LINE] =               { n: "Line", scriptClass: "mstrmojo.DocLine" };
    clsMap[en.IMAGE] =              { n: "Image", scriptClass: "mstrmojo.DocImage" };
    clsMap[en.HTMLCONTAINER] =      { n: "HTMLContainer", scriptClass: "mstrmojo.HTMLContainer" };
    clsMap[en.RECTANGLE] =          { n: "Rectangle", scriptClass: "mstrmojo.DocRectangle" };
    clsMap[en.ROUNDEDRECTANGLE] =   { n: "RoundedRectangle", scriptClass: "mstrmojo.DocRoundRectangle" };
    clsMap[en.PANEL] =              { n: "Panel", scriptClass: "mstrmojo.DocPanel" };
    clsMap[en.VISUALIZATION] =      { n: "Visualization", scriptClass: "mstrmojo.DocVisualization" };
    clsMap[en.MOJOVISUALIZATION] =   {n: "MojoVisualization"};

    // Map to hold dynamically created link class constructors.
    var linkClsMap = {};

    var $CFC = mstrmojo.DynamicClassFactory.newComponent;

    var _EH = mstrmojo.elementHelper;

    /**
     * Utility function for creating portlet button handler functions.
     *
     * @private
     */
    function getPortletButtonHandler(action) {
        return function () {
            return this.parent.parent['on' + action]();
        };
    }

    /**
     * Function used by maximize button in portlet to handle onclick event on it,
     * which basically call portlet's onmaximize() method.
     */
    var fMx = getPortletButtonHandler('maximize'),
        /**
         * Function used by restore button in portlet to handle onclick event on it,
         * which basically call portlet's onrestore() method.
         */
        fRs = getPortletButtonHandler('restore'),
        /**
         * Function used by minimize button in portlet to handle onclick event on it.
         * which basically call portlet's onminimize() method.
         */
        fMn = getPortletButtonHandler('minimize'),
        /**
         * Function used by collapse button in portlet to handle onclick event on it.
         * which basically call portlet's oncollapse() method.
         */
        fCo = getPortletButtonHandler('collapse'),
        /**
         * Function used by expand button in portlet to handle onclick event on it.
         * which basically call portlet's onexpand() method.
         */
        fEx = getPortletButtonHandler('expand');

    // Create dynamic DocXtab class.
    mstrmojo.DocXtab = $CFC(mstrmojo.XtabBase, [mstrmojo._Formattable, mstrmojo._IsDocXtab], {
        scriptClass: 'mstrmojo.DocXtab'
    });

    /**
     *  helper function to find out which widget can open specific Menu
     */
    var getPopupDelegate = function (widget, openMenu) {
        var w = widget && widget.parent;
        while (w) {
            if (w[openMenu]) {
                return w;
            }
            w = w.parent;
        }
        return null;
    };

    /**
     * Create a button for resizing portlet.
     *
     * @param {String} t The tooltip text to display in the button.
     * @param {String} c The css class(es) used to display the button image.
     * @param {Function} fn The function to execute when the button is clicked.
     * @param {Integer} bds The display state for the button.
     * @param {Boolean} cds The current display state of the portal.
     *
     * @returns {Object} The button config.
     * @private
     *
     * @refactoring Could we tie the visibility to bindings?
     */
    function createResizeButton(t, c, fn, bds, cds) {
        return mstrmojo.Button.newIconButton(t, c, fn, null, {
            ds: bds,
            visible: (cds !== bds)
        });
    }

    /**
     * Returns a dynamic class to handle links.
     *
     * @param {mstrmojo.Widget} clazz The base constructor on which to amend mixins.
     * @param {Integer} type The type of document object being amended.
     * @param {Boolean} useHover Whether the linkable object should support a hover menu for multiple links.
     *
     * @type mstrmojo.Widget
     */
    function getLinkDrillingClass(clazz, type, useHover) {
        var className = clsMap[type].n + (useHover ? 'Hover' : ''),
            Cls = linkClsMap[className];

        // Have we NOT previously created this dynamic class?
        if (!Cls) {
            // Create and cache dynamic class constructor.
            Cls = linkClsMap[className] = $CFC(clazz, [ mstrmojo._HasDocLink ].concat(this.getLinkDrillMixins(useHover)));
        }

        // Return constructor.
        return Cls;
    }


    /**
     * <p>Builds the document object model based on the supplied {@link mstrmojo.DocModel}.</p>
     *
     * <p>DocBuilder dynamically instantiates DocLayout widgets and their descendant widgets, based upon
     * given data model.  The data model (typically an mstrmojo.DocModel) is assumed to expose the following methods:</p>
     *
     * <dl>
     *     <dt>getChildren(node, onComplete)</dt>
     *     <dl>Fetches the child data nodes of a given data node from the model.  If node is given as null, then the model is assumed to retrieve the
     *         highest-level child nodes, which typically means the list of layouts in a DocModel.  This call may be asynchronous, and so the
     *         caller provides callbacks for the results rather than expecting an immediate synchronous return value. The callbacks are assumed
     *         to be optional.</dl>
     *     <dt>type(node)</dt>
     *     <dd>Returns the type of the given data node; assumed to be a value from the enumeration mstrmojo.EnumRWUnitType, or possibly null.</dd>
     *     <dt>getCurrentLayoutKey()</dt>
     *     <dd>Returns the key of the current layout (if any) in the model.  Assumed to be synchronous.</dd>
     * </dl>
     *
     * @class
     */
    mstrmojo.DocBuilder = mstrmojo.declare(
        // superclass
        mstrmojo.Obj,

        // mixins,
        null,

        /**
         * @lends mstrmojo.DocBuilder.prototype
         */
        {
            /**
             * @ignore
             */
            scriptClass: "mstrmojo.DocBuilder",

            /**
             * A reference to the dynamically server generated list of visualizations that can be used for this document.
             *
             * @type Object
             */
            visList: null,

            destroy: function destroy() {
                var selectorFactory = this.selectorFactory;
                if (selectorFactory) {
                    selectorFactory.destroy();
                }

                this._super();
            },

            /**
             * <p>A hash map of classes to instantiate for each view type.</p>
             *
             * <p>Items are keyed by the DSSXMLObjectType value.  The value for each item will be an object with the following optional properties:</p>
             *
             *  <dl>
             *      <dt>n</dt>
             *      <dd>The name of a custom method on the builder to call for this object type.  The methods are prefixed with "new" but the property value should not
             *          contain the prefix, e.g., to build a layout the property name would be "Layout" but the method name would be "newLayout".</dd>
             *      <dt>sc</dt>
             *      <dd>A string containing the name of the script class to use for this object type.  This property will only be used if the "n" property is not present
             *          or if the method identified in the "n" property is not present on the builder.</dd>
             *  </dl>
             *
             *  <p>Subclasses can either overwrite this map all together, or modify if during construction.</p>
             */
            classMap: clsMap,

            /**
             * Instantiates widgets for a given array of DocModel data nodes (which may each represent either a
             * layout, section, subsection, control, or even the entire DocModel).
             *
             * @param {Object[]} nodes The nodes to build.
             * @param {mstrmojo.DocModel} model The object model for the document.
             */
            build: function build(nodes, model) {
                var arr = [],
                    mthMap = this.classMap,
                    len = ((nodes && nodes.length) || 0),
                    i;

                for (i = 0; i < len; i++) {
                    // Determine which function to call to construct a widget for the given node.
                    var node = nodes[i],
                        nodeDefn = node && node.defn,
                        nodeData = node && node.data,
                        t = (nodeDefn && nodeDefn.t) || mstrmojo.EnumRWUnitType.LAYOUT,       // RWUnit Type.
                        config = mthMap[t];                                                   // Scriptclass configuration.

                    // Is this a document button?
                    var isDocButton = (t === en.TEXTFIELD && ((nodeDefn && nodeDefn.dpst)));
                    if (isDocButton) {
                        // Reset configuration to button.
                        config = mthMap[t + 'B'];
                    }

                    // Get build method from configuration name.
                    var fn = (config && config.n) ? 'new' + config.n : '',
                        w;

                    // Do we have a build method?
                    if (this[fn]) {
                        // The build method is defined, so call it to do the construction.
                        w = this[fn](model, node);

                    } else if (config && config.scriptClass) {

                        // No such method; but we do have a constructor name; so call the constructor directly.
                        var Cls = config.cls;
                        if (!Cls) {
                            // Walk the script class (starting at window) to get the constructor.
                            Cls = $HASH.walk(config.scriptClass, window);
                        }

                        // Is this a text field OR an image?
                        if (t === en.TEXTFIELD || t === en.IMAGE) {

                            // Check for links.
                            var dataDlRef = nodeData.dl,
                                defnDlRef = nodeDefn.dl,
                                hasLinks = (dataDlRef && dataDlRef.items && dataDlRef.items.length) || (defnDlRef && defnDlRef.items && defnDlRef.items.length > 0);

                            // Does the item have links OR a default link OR an info window target?
                            if (hasLinks || nodeData.url || nodeDefn.url || nodeDefn.ifw) {
                                // Get dynamic class with links code mixed in.
                                // Button's type is still 106, but to distinct with Textfield, use "106B" instead.
                                Cls = getLinkDrillingClass.call(this, Cls, t + (isDocButton ? "B" : ""), hasLinks);

                            } else if ((t === en.TEXTFIELD) && nodeDefn.txi) {
                                Cls = $CFC(Cls, [ mstrmojo._CanSupportTransaction, mstrmojo._IsEditableTextfield ]);

                            }
                        }

                        // Do we have a class constructor?
                        if (Cls) {
                            // Uncomment to log which widgets are being created during document construction
                            // mstrmojo.dbg("DocBuilder: class="+Cls.prototype.scriptClass + ", id="+node.id);

                            // Instantiate new Widget.
                            w = new Cls({
                                id: node.id,
                                node: node,
                                controller: this.parent.controller,
                                model: model
                            });
                        }
                    }

                    // Did we successfully construct a widget?
                    if (w) {
                        // Set common properties.
                        w.k = node.k;
                        w.formatResolver = model.formatResolver;
                        w.builder = this;
                        w.tooltip = nodeData.tooltip || nodeDefn.tooltip || '';

                        // Does the widget not already have a definition node?
                        if (!w.defn) {
                            // Use defn from node.
                            w.defn = nodeDefn;
                        }

                        w.disposables.push(w.defn);

                        // Call wiget's update method (if any) to handle widget-specific properties.
                        if (w.update) {
                            w.update(node);
                        }

                        // create portlet if necessary
                        if ((nodeDefn.ttl !== undefined && t !== en.PANEL) || nodeDefn.qsm) {
                            w = this.createPortlet(t, node, w);
                        }

                        arr.push(w);
                    }
                }
                return arr;
            },

            /**
             * Wraps a supplied {@link mstrmojo.Widget} within a portlet control, that may be interactive through buttons.
             *
             * @param {Integer} t The type of widget as defined in {@link mstrmojo.EnumRWUnitType}.
             * @param {Object} node The data node as sent down in the JSON definition of the document.
             * @param {mstrmojo.Widget} w The Widget that will be contained within the returned portlet.
             *
             * @returns {mstrmojo.DocResizablePortlet|mstrmojo.DocPortlet}
             */
            createPortlet: function createPortlet(t, node, w) {
                var defn = node.defn,
                    ds = defn.ds,
                    resizable = (defn.iifp || !(t === en.PANELSTACK || (defn.ttl === undefined && defn.qsm) || t === en.SELECTOR)),
                    hasGraph = (t === en.GRAPH || t === en.GRIDGRAPH),
                    children = [],
                    $NIB = mstrmojo.Button.newIconButton,
                    leftToolbarNodeCssClass = '',
                    toolbarNodeCssClass = '',
                    buttonbarNodeClass = '',
                    isExportGrid = (t === en.GRID || hasGraph || t === en.VISUALIZATION) && parseInt(defn.eo, 10) !== 2,
                    toolbarNode = [],
                    tbCssClass = 'mstrmojo-oivmSprite ',
                    hasTitlebarMenuButton = false; //flag to indicate whether this portlet titlebar has a menu button

                // Does the widget support quick switch?
                if (defn.qsm) {
                    leftToolbarNodeCssClass = 'qks';

                    // Create common button properties for quick switch.
                    var fnQuickSwitchBtn = function (title, css, qsm) {
                        return $NIB(title, tbCssClass + css, function () {
                            return this.parent.parent.content.quickSwitch();
                        }, {
                            visible: 'this.parent.parent.defn.qsm !== this.qsm'
                        }, {
                            qsm : qsm
                        });
                    };

                    // Add the left toolbar with quick switch view buttons.
                    children.push({
                        scriptClass: 'mstrmojo.ToolBar',
                        slot: 'leftToolbarNode',
                        alias: 'leftToolbar',
                        cssClass: (!resizable) ? 'grouped' : '',
                        children: [ fnQuickSwitchBtn(mstrmojo.desc(3547, 'View: Grid'), 'tbGrid', 1), fnQuickSwitchBtn(mstrmojo.desc(3548, 'View: Graph'), 'tbGraph', 2) ]
                    });
                }

                if (isExportGrid) {
                    var tb = this.getPortletExportGridToolbar(w.k);
                    if (tb) {
                        toolbarNodeCssClass = tb.css;

                        toolbarNode = tb.node;

                        children.push(toolbarNode);
                    }
                }

                // Does the widget support resizing?
                if (resizable) {
                    if (defn.iifp) {
                        leftToolbarNodeCssClass = 'wrap';

                        // Add the left toolbar with collapse/expand buttons.
                        children.push({
                            scriptClass: 'mstrmojo.ToolBar',
                            slot: 'leftToolbarNode',
                            alias: 'leftToolbar',
                            children: [ createResizeButton(mstrmojo.desc(8973, 'Collapse'), 'co', fCo, 1, ds),
                                        createResizeButton(mstrmojo.desc(8972, 'Expand'), 'ex', fEx, 0, ds) ]
                        });
                    } else {
                        var btns = [ createResizeButton(mstrmojo.desc(4539, 'Minimize'), 'mn', fMn, 1, ds),
                                     createResizeButton(mstrmojo.desc(4540, 'Restore'), 'rs', fRs, 0, ds),
                                     createResizeButton(mstrmojo.desc(4541, 'Maximize'), 'mx', fMx, 2, ds) ];

                        if (isExportGrid) {
                            toolbarNode.children = (toolbarNode.children || []).concat(btns);

                        } else {
                            toolbarNodeCssClass = 'resize';

                            // Add the right toolbar with min/max/restor buttons.
                            children.push({
                                scriptClass: 'mstrmojo.ToolBar',
                                slot: 'toolbarNode',
                                alias: 'rightToolbar',
                                children: btns
                            });
                        }
                    }
                }

                // Set the slot on the contained widget.
                w.slot = 'contentNode';
                w.alias = 'content';
                w.title = defn.ttl || '';

                // Is 'show element count' enabled for this selector?
                if (defn.sec) {
                    // Is this selector NOT a slider selector AND NOT a search box selector with search on server?
                    if (defn.style !== mstrmojo.DocSelectorViewFactory.STYLES.SCROLLER && !defn.sos) {
                        var nodeData = node.data,
                            es = nodeData.elms,
                            ces = nodeData.ces;

                        // Do we have selected elements?
                        if (ces && es && es.length) {
                            // Add selected element count to portlet.
                            w.count = _EH.buildElemsCountStr(ces, es);
                        }
                    }
                }

                // Add the contained widget to the children.
                children.push(w);

                // PanelStack - build panel switching toolbar into slot 'leftToolbar'
                if (t === en.PANELSTACK) {
                    var fnNewNavButton = function (title, css, binding, dir) {
                            return $NIB(title, tbCssClass + css, function () {
                                // call PanelStack widget's method.
                                return this.parent.parent.content.switchToPanel(dir);
                            }, {
                                enabled: 'this.parent.parent.' + binding
                            });
                        },
                        rTb = [],
                        lTb = [],
                        hasPanelNav = !!node.sw,
                        isInfoWindow = !!defn.ifw,
                        isFilterPanel = !!defn.ifp;

                    if (hasPanelNav) {
                        // Add previous panel button to left toolbar.
                        lTb.push(fnNewNavButton(mstrmojo.desc(1058, 'Previous'), 'tbPrev', 'prevEnabled', -1));   // Go to previous panel.

                        // Add next panel button to right toolbar.
                        rTb.push(fnNewNavButton(mstrmojo.desc(2917, 'Next'), 'tbNext', 'nextEnabled', 1));   // Go to next panel.
                    }

                    // Is this an info window?
                    if (isInfoWindow) {
                        // Add close button to right toolbar.
                        rTb.push($NIB(mstrmojo.desc(2102, 'Close'), tbCssClass + 'mstrmojo-DocInfoWindow-close', function () {
                            this.parent.parent.parent.close();
                        }));
                    }

                    if (isFilterPanel) { // Filter Panel also need to popup the menu
                        buttonbarNodeClass = 'ifp';

                        children.push({
                            scriptClass: 'mstrmojo.HBox',
                            slot: 'buttonbarNode',
                            alias: 'buttonbar',
                            cssClass: 'buttonBox',
                            children: [{
                                scriptClass: 'mstrmojo.Button',
                                alias: 'applyNow',
                                title: mstrmojo.desc(2164, 'Apply'),
                                text: mstrmojo.desc(2164, 'Apply'),
                                cssClass: 'mstrmojo-FilterPanel-Btn apply',
                                bindings: {
                                    visible: function () {
                                        return !defn.cas;
                                    },
                                    enabled: function () {
                                        return this.parent.parent.applyEnabled;
                                    }
                                },
                                onclick: function onclick() {
                                    if (w && w.applyBufferedSlices) {
                                        w.applyBufferedSlices();
                                    }
                                }
                            }]
                        });

                        rTb.push({
                            scriptClass: 'mstrmojo.Button',
                            cssClass: 'mstrmojo-oivmSprite tbDown',
                            alias: 'btnMenu',
                            onclick: function onclick() {
                                this.openPopupMenu();
                            },
                            openPopupMenu: function () {
                                var dl = getPopupDelegate(this, 'openPopupMenu');
                                if (dl) {
                                    dl.openPopupMenu('mstrmojo.FilterPanelMenu', {
                                        openerButton: this,
                                        fps: w,
                                        cmPos: this.cmPos
                                    });
                                }
                            }
                        });
                        hasTitlebarMenuButton = true;
                    }

                    // TQMS 648403: If the panel stack is info window or filter panel, adding a dummy to left toolbar so as to center the title.
                    if (isInfoWindow || isFilterPanel) {
                        var boxCss = [];
                        if (hasPanelNav) {
                            boxCss[0] = 'pst-l';
                        }

                        if (isFilterPanel) {
                            boxCss.push('ifp');
                        }

                        lTb.push({
                            scriptClass: 'mstrmojo.Box',
                            cssClass: boxCss.join(' ')
                        });
                    }

                    if (isInfoWindow || hasPanelNav || isFilterPanel) {
                        var ifwCss = isInfoWindow ? 'ifw ' : '',
                            ifpCss = isFilterPanel ? 'ifp ' : '',
                            casCss = !defn.cas ? 'cas ' : '';

                        toolbarNodeCssClass = (hasPanelNav ? 'pst-r ' : '') + ifwCss + ifpCss + casCss;
                        leftToolbarNodeCssClass = (hasPanelNav ? 'pst-l ' : '') + ifwCss + ifpCss + casCss;
                        children.push({
                            scriptClass: 'mstrmojo.ToolBar',
                            slot: 'leftToolbarNode',
                            alias: 'leftToolbar',
                            children: lTb
                        });
                        children.push({
                            scriptClass: 'mstrmojo.ToolBar',
                            slot: 'toolbarNode',
                            alias: 'rightToolbar',
                            children: rTb
                        });
                    }
                }

                // Selector Control - build pulldown button into slot 'rightToolbar'
                if (t === en.SELECTOR && w.spm) { //if this Selector style supports popup menu
                    toolbarNodeCssClass = 'spm';

                    //create a toolbar to contain the pulldown button
                    children.push({
                        scriptClass: 'mstrmojo.ToolBar',
                        slot: 'toolbarNode',   //right toolbar node
                        alias: 'rightToolbar',
                        children: [{
                            scriptClass: 'mstrmojo.Button',
                            cssClass: 'mstrmojo-oivmSprite tbDown',
                            alias: 'btnMenu',
                            onclick: function onclick() {
                                this.openPopupMenu();
                            },
                            openPopupMenu: function () {
                                var dl = getPopupDelegate(this, 'openPopupMenu');
                                if (dl) {
                                    dl.openPopupMenu('mstrmojo.SelectorMenu', {
                                        openerButton: this,
                                        selector: w,
                                        cmPos: this.cmPos
                                    });
                                }
                            }
                        }]
                    });
                    hasTitlebarMenuButton = true;
                }

                // Create the portlet.
                var Cls = 'Doc' + (resizable ? 'Resizable' : '') + 'Portlet',
                    props = {
                        defn: w.defn,
                        model: w.model,
                        children: children,
                        title: w.title,
                        count: w.count,
                        floatingTitle: (defn.ttl === undefined && defn.qsm),
                        leftToolbarNodeClass: leftToolbarNodeCssClass,
                        loadDataOnResize: hasGraph,
                        toolbarNodeClass: toolbarNodeCssClass,
                        buttonbarNodeClass: buttonbarNodeClass,
                        attachContextMenuEvent: hasTitlebarMenuButton
                    };

                if (t === en.PANELSTACK) {
                    props.bindings = {
                        title: 'this.children[0].title' //'this.content.title' TODO use alias when the alias + binding issue fixed.
                    };

                    //If panel switching toolbar is rendered, setup two binidings to help update the buttons status.
                    //These two properties work as connector between the PanelStack widget and the toolbar widget since
                    // the PanelStack's instance is not available yet when settting up toolbar's bindings.
                    if (node.sw) {
                        props.bindings.prevEnabled = function () {
                            return this.children[0].hasPreviousPanel;
                        };
                        props.bindings.nextEnabled = function () {
                            return this.children[0].hasNextPanel;
                        };
                    }

                    // add another property binding to control the apply button enable/disbale
                    if (defn.ifp) {
                        props.bindings.applyEnabled = function () {
                            return this.children[0].applyEnabled;
                        };
                    }
                }

                return new mstrmojo[Cls](props);
            },

            getPortletExportGridToolbar: mstrmojo.emptyFn,

            /**
             * Returns the constructor to be used for document layout viewers.
             *
             * @param {Object} node The node for this control.
             *
             * @returns Object The constructor of the class to use for document layout viewers.
             */
            getLayoutViewerClass: function getLayoutViewerClass(node) {
                return mstrmojo.DocLayoutViewer;
            },

            /**
             * <p>Instantiates and returns a DocLayout widget.</p>
             *
             * @param {mstrmojo.DocModel} model The DocModel the child and container belong to.
             * @param {Object} node The data node for the child widget.
             *
             * @returns {mstrmojo.DocLayoutViewer}
             */
            newLayout: function newLayout(model, node) {

                // Create the layout viewer.
                var chs = [],
                    nodeData = node.data,
                    nodeDefn = node.defn,
                    LayoutViewerCls = this.getLayoutViewerClass(node),
                    dlv = new LayoutViewerCls({
                        n: nodeDefn.title,    // If title is missing, don't use the key; leave it null, thus hiding the GUI tab for it.
                        model: model,
                        node: node,
                        controller: this.parent.controller,
                        tbc: nodeDefn.tbc,
                        slot: 'containerNode',
                        visible: false,        // Assumes stack container will unhide the current layout when selected.
                        ifs: nodeData.ifs,    // Incremental fetch settings.
                        gb: nodeData.gbys     // Groupd by info.
                    });

                // Create a modified defn node for the DocLayoutViewer based on the node.defn.
                var defn = dlv.defn = $HASH.copy(nodeDefn);
                defn.fmts = $HASH.copy(nodeDefn.fmts);

                //Override the DocLayout class to be a incrementally rendering class
//                mstrmojo.DocLayout = $CFC(mstrmojo.DocLayout, [mstrmojo._CanRenderDocOnScroll], {
//                    scriptClass: 'mstrmojo.DocLayout'
//                });
                var fnHeaders = function (headers, slot) {
                    var cnt = headers.length;
                    if (cnt) {
                        var h, f;
                        for (h = 0; h < cnt; h++) {
                            f = this.build([headers[h]], model)[0];
                            f.slot = slot;
                            chs.push(f);
                        }
                    }
                };

                fnHeaders.call(this, model.getFixedHeaders(node), 'fixedHeaderNode');

                // Resolve whether the layout should be vertical or horizontal layout.
                var LayoutCls = mstrmojo['DocLayout' + ((nodeDefn.horiz) ? 'Horiz' : '')];

                // Add layout child.
                chs.push(new LayoutCls({
                    slot: "layout",
                    id: node.id,
                    k: node.k,
                    minHeight: nodeData.mh,
                    formatResolver: model.formatResolver,
                    rules: nodeDefn.rules,
                    builder: this,
                    node: node,
                    defn: nodeDefn,
                    model: model
                }));

                // Add fixed footer as child
                fnHeaders.call(this, model.getFixedFooters(node), 'fixedFooterNode');

                // Finally add into viewer
                dlv.addChildren(chs);

                return dlv;
            },

            newSection: function (model, node) {
                // If the section is horizontal and it has more than one subsection  use a horizontal section (extends HBox).
                var cls = (node.defn.horiz && node.data.subsections.length > 1) ? 'DocSectionHoriz' : 'DocSection';
                return new mstrmojo[cls]({
                    id: node.id,
                    node: node,
                    model: model
                });
            },

            newHTMLContainer: function (model, node) {
                // Is the HTMLContainer an iframe or just html?
                var cls = (node.defn.ht === 0) ? 'DocHTMLContainer' : 'DocTextfield';
                return new mstrmojo[cls]({
                    id: node.id,
                    node: node,
                    model: model
                });
            },

            adjustMojoVisualizationClass: function adjustMojoVisualizationClass(className) {
                // No adjustment necessary.
                return className;
            },

            newMojoVisualization: function (model, node) {
                var visList = this.visList,
                    nodeData = node.data,
                    visInfo = visList.getVis(nodeData.visName);

                // Do we NOT have a visualization to display?
                if (!visInfo) {
                    // Do we NOT have a class name?
                    var className = nodeData.className;
                    if (!className) {
                        // TQMS #499518: Don't know what visualization to use so default to a cross tab.
                        return this.newXtab(model, node);
                    }

                    // Update visInfo with retrieved class name.
                    visInfo = {
                        dc: className
                    };
                }

                // Retrieve the view class name from the vis object.
                var viewClassName = (visInfo.dc !== undefined) ? visInfo.dc : visInfo.c;

                // Adjust the view class name.
                viewClassName = this.adjustMojoVisualizationClass(viewClassName);

                // Make sure the view is loaded.
                mstrmojo.requiresCls('mstrmojo.' + viewClassName);

                var ViewClass = $HASH.walk(viewClassName, mstrmojo),                 // Vis class constructor.
                    ModelClass = $HASH.walk(visInfo.m || "DocVisModel", mstrmojo);  // Model class constructor.

                // Are we missing the view class or model class?
                if (!ViewClass || !ModelClass) {
                    throw new Error('Missing visualization class.');
                }

                // Give the vis list a chance to change the view class.
                ViewClass = visList.getVisClass(ViewClass, node.defn);

                // Instantiate view class with standard and extra properties.
                var vis = new ViewClass($HASH.copy(nodeData.extProps, {
                    id: node.id,
                    node: node,
                    n: node.defn.title,    // Copy the layout title to the visualization.
                    controller: this.parent.controller,
                    gb: nodeData.gbys                       // Group by info.
                }));

                // Create (and set) the data model for the visualization/grid.
                vis.setModel(new ModelClass({
                    xtab: vis,
                    controller: this.parent.controller,
                    docModel: model
                }));

                // Set the data as a setter so that the event handlers listen to it.
                vis.model.set('data', nodeData);

                // Now if the visualization has secondary data providers then create the
                // Xtab widget for each of these secondary data provider but do not render them
                // we need this in order to support link drilling on them.
                if (!!node.data.sdp) {
                    var sdpKey;
                    for (sdpKey in node.data.sdp) {
                        node.data.sdp[sdpKey].defn = {}; //dummy defn .. since defn is referenced inside newXtab method
                        var obj = this.newXtab(model, node.data.sdp[sdpKey]);

                        // TODO: below piece of code is not tested i.e setModel call
                        obj.setModel(new ModelClass({
                            xtab: obj,
                            controller: this.parent.controller,
                            docModel: model,
                            data: node.data.sdp[sdpKey]
                        }));
                        obj.k = sdpKey; //assign the node key
                    }
                }

                // Return visualization instance.
                return vis;
            },

            newInfoWindow: function newInfoWindow(cfg) {
                return new mstrmojo.DocInfoWindow(cfg);
            },

            newRoundedRectangle: function newRoundedRectangle(model, node) {
                var $D = mstrmojo.dom,
                    cls = ($D.supports($D.cssFeatures.ROUND_CORNERS)) ? 'DocRectangle' : 'DocRoundRectangle';

                return new mstrmojo[cls]({
                    id: node.id,
                    node: node,
                    model: model
                });
            },

            newSelector: function newSelector(model, node) {
                var cls = (node.defn.ct === '4' ? 'DocActionSelector' : 'DocSelector');
                return new mstrmojo[cls]({
                    id: node.id,
                    node: node,
                    controller: this.parent.controller,
                    model: model
                });
            },

            newXtab: function newXtab(model, node) {
                var txi = node.defn.txi, xtab,
                    Cls = mstrmojo.DocXtab;

                if (txi) {
                    Cls = $CFC(mstrmojo.DocXtab, [ mstrmojo._CanSupportTransaction, mstrmojo._IsEditableXtab ], {
                        scriptClass: 'mstrmojo.DocXtab'
                    });
                }

                xtab = new Cls({
                    id: node.id,
                    node: node,
                    controller: this.parent.controller
                });

                xtab.model = new mstrmojo.DocXtabModel({
                    xtab: xtab,
                    docModel: model
                });

                return xtab;
            },

            getLinkDrillMixins: function getLinkDrillMixins(useHover) {
                return useHover ? [ mstrmojo._HasHoverButton ] : [];
            }
        }
    );

}());
(function () {

    mstrmojo.requiresCls("mstrmojo.Obj",
                         "mstrmojo.DocBuilder",
                         "mstrmojo.MobileDocLayoutViewer",
                         "mstrmojo.MobileDocXtabGraph",
                         "mstrmojo._XtabSeamlessIncrementalFetch",
                         "mstrmojo._HasScrollbox",
                         "mstrmojo.MobileXtab",
                         "mstrmojo.graph.MobileDocXtabCanvasGraph",
                         "mstrmojo.DynamicClassFactory",
                         "mstrmojo.android.DocSelectorViewFactory",
                         "mstrmojo.android.DocPanelStack",
                         "mstrmojo.android.AndroidDocPanel",
                         "mstrmojo.android.ui.DocButton",
                         "mstrmojo.android.HTMLContainer",
                         "mstrmojo._HasRelativeUrls",
                         "mstrmojo._Formattable",
                         "mstrmojo._IsDocXtab",
                         "mstrmojo._IsSelectorTarget",
                         "mstrmojo._IsInteractiveGrid",
                         "mstrmojo.android.AndroidDICConfig",
                         "mstrmojo.AndroidVisList",
                         "mstrmojo.array",
                         "mstrmojo.hash",
                         "mstrmojo.maps.AndroidDocMap",
                         "mstrmojo.maps.MapInfoWindowLayoutViewer",
                         "mstrmojo.android.ui._IsTouchLink",
                         "mstrmojo._HasDrillLinks");


    var $CFC = mstrmojo.DynamicClassFactory.newComponent,
        $HRU = mstrmojo._HasRelativeUrls,
        $FREE = mstrmojo.Obj.free,
        $EN = mstrmojo.EnumRWUnitType,
        $ARR = mstrmojo.array,
        $HASH = mstrmojo.hash;

    // Create dynamic DocXtab class.
    mstrmojo.DocXtab = $CFC(mstrmojo.MobileXtab, [ mstrmojo._Formattable, mstrmojo._IsSelectorTarget, mstrmojo._IsDocXtab ], {
        scriptClass: 'mstrmojo.DocXtab',
        /**
         * Overwrite the scrollerConfig property to ensure we can't scrollPast.
         */
        scrollerConfig: {
            scrollPast: false
        }
    });

    // Create dynamic document full screen map visualization class.
    var mapSuperPkg = (!!mstrMobileApp && !!mstrMobileApp.useNativeMap && mstrMobileApp.useNativeMap()) ? 'androidmap' : 'jsmap';
    mstrmojo.maps.AndroidDocLayoutMap = $CFC(mstrmojo.maps[mapSuperPkg].AndroidDocMap, null, {
        scriptClass: 'mstrmojo.maps.AndroidDocLayoutMap'
    });

    // Create dynamic MobileDocImage class to update image src url for mobile.
    mstrmojo.MobileDocImage = $CFC(mstrmojo.DocImage, [ $HRU ], {
        scriptClass: 'mstrmojo.MobileDocImage',
        relativeUrls: [ 'v' ]
    });

    mstrmojo.MobileDocHTMLContainer = $CFC(mstrmojo.DocHTMLContainer, [ $HRU ], {
        scriptClass: 'mstrmojo.MobileDocHTMLContainer',
        relativeUrls: [ 'v' ]
    });

    // Remove border and background color from DocLayout format handlers.
    var fh = mstrmojo.DocLayout.prototype.formatHandlers.domNode;
    $ARR.removeItem(fh, 'border');
    $ARR.removeItem(fh, 'background-color');

    /**
     * <p>Builds the document object model based on the supplied {@link mstrmojo.DocModel} for Mobile devices.</p>
     *
     * @class
     * @extends mstrmojo.DocBuilder
     */
    mstrmojo.MobileDocBuilder = mstrmojo.declare(
        // superclass
        mstrmojo.DocBuilder,

        // mixins,
        null,

        /**
         * @lends mstrmojo.MobileDocBuilder.prototype
         */
        {
            scriptClass: "mstrmojo.MobileDocBuilder",

            init: function init(props) {
                this._super(props);

                if (!this.destroyObjects) {
                    this.destroyObjects = [];
                }

                // Initialize the selector factory.
                this.selectorFactory = new mstrmojo.android.DocSelectorViewFactory();

                var clsMap = this.classMap;

                // Overwrite graph to use MobileDocXtabGraph.
                clsMap[$EN.GRAPH] = (mstrApp.onMobileDevice() && mstrApp.useBinaryFormat) ? {
                    n: 'graph.MobileDocXtabCanvasGraph',
                    scriptClass: 'mstrmojo.graph.MobileDocXtabCanvasGraph'
                } : {
                    n: 'MobileDocXtabGraph',
                    scriptClass: 'mstrmojo.MobileDocXtabGraph'
                };

                // Overwrite graph to use MobileDocXtabGraph.
                clsMap[$EN.IMAGE] = {
                    n: 'MobileDocImage',
                    scriptClass: 'mstrmojo.MobileDocImage'
                };

                // Add DocPanelStack using mobile version.
                clsMap[$EN.PANELSTACK] = {
                    n: 'PanelStack',
                    scriptClass: 'mstrmojo.android.DocPanelStack'
                };

                // Add Android DocPanel class.
                clsMap[$EN.PANEL] = {
                    n: 'Panel',
                    scriptClass: 'mstrmojo.android.AndroidDocPanel'
                };

                // Add Android document button class.
                clsMap[$EN.TEXTFIELD + 'B'] = {
                    n: 'Button',
                    scriptClass: 'mstrmojo.android.ui.DocButton'
                };
            },

            visList: mstrmojo.AndroidVisList,

            /**
             * Overridden to handle map info window case.
             *
             * @ignore
             */
            getLayoutViewerClass: function getLayoutViewerClass(node) {
                // Is this layout an info window?
                if (node.defn.iw) {
                    // Default to hosted version.
                    var className = 'MapInfoWindowLayoutViewer';

                    // Is the app running on the device?
                    if (mstrApp.onMobileDevice()) {
                        // Change to device version.
                        className = 'Mobile' + className;
                    }

                    // Return maps info window constructor.
                    return mstrmojo.maps[className];
                }

                // Return mobile layout viewer constructor.
                return mstrmojo.MobileDocLayoutViewer;
            },

            /**
             * <p>Checks if the layout has a visualization property set and creates the visualization
             * as the only element on that layout. If not, instantiates and returns a DocLayout widget.</p>
             *
             *
             * @param {mstrmojo.DocModel} model The DocModel the child and container belong to.
             * @param {Object} node The data node for the child widget.
             *
             */
            newLayout: function newLayout(model, node) {
                var vis = node.defn.visName;

                //Does the layout have the interactive grid visualization property set?
                if (vis) {
                    // Get only the Visualization Grid node from the layout and cache the group by node from the original node.
                    var groupByInfo = node.data.gbys;

                    // Since the Doc is tightly coupled to the layout, we let it remain a layout node but change it's
                    // data to point to the Visualization Grid's data and render it as a visualization...
                    // - cache layout data
                    var layoutModel = model,
                        layoutNode = $HASH.clone(node);

                    // - reset data to point to the grid's data
                    var visGrid = mstrmojo.Vis.getVisGrid(model, node, node.defn.visGK);
                    if (visGrid) {
                        node.data = visGrid.data;

                        if (node.defn.vp && Object.keys(node.defn.vp).length > 0) { // copy them to template
                            visGrid.data.vp = node.defn.vp;
                        }

                        // - add a reference to the original data Model so the visualization can find other objects (i.e. grids, panel stacks)
                        node.data.layoutModel = layoutModel;
                        node.data.layoutNode = layoutNode;

                        // - add group by info.
                        node.data.gbys = groupByInfo;
                    }

                    // Make the node definition observable.
                    node.defn = model.makeObservable(node.defn);

                    this.destroyObjects.push(node.defn);

                    // Get Vis Object to find out the visualization's view and model classes
                    var visObj = this.visList.getVis(vis),
                        viewClassName = (visObj.dc !== undefined) ? visObj.dc : visObj.c,
                        xtab,
                        xtabModel;

                    // create the view and model objects.  Errors building or rendering the view and/or creating
                    // the data model object are caught here so we can clean up any allocated objects before
                    // passing the error up.
                    try {

                        // Is this a map visualization?
                        if (/AndroidDocMap/.test(viewClassName)) {
                            // Change view class name to the full screen layout map visualization.
                            viewClassName = 'maps.AndroidDocLayoutMap';
                        }

                        var ViewClass = $HASH.walk(viewClassName, mstrmojo),                // Vis class constructor.
                            ModelClass = $HASH.walk(visObj.m || "DocVisModel", mstrmojo),  // Model class constructor.
                            controller = this.parent.controller;                            // controller.

                        // Create the view that to display our data.
                        xtab = new ViewClass({
                            id: (visGrid && visGrid.id) || node.id,
                            node: node,
                            n: node.defn.title,             // Copy the layout title to the visualization.
                            controller: controller,
                            gb: node.data.gbys,             // Group by info.
                            isFullScreenWidget: true        // Since this is a layout it's always full screen.
                        });

                        // Create the data model for the visualization/grid.
                        xtabModel = new ModelClass({
                            xtab: xtab,
                            controller: controller,
                            docModel: model
                        });

                        //Set the model
                        xtab.setModel(xtabModel);

                    } catch (e) {
                        // Destroy the view and model if we encounter problems.
                        xtab = $FREE(xtab);
                        xtabModel = $FREE(xtabModel);

                        throw e;
                    }

                    return xtab;
                }

                return this._super(model, node);
            },

            /**
             * Overridden to use composite HTML Container that will adjust relative iframe URLs.
             *
             * @ignore
             */
            newHTMLContainer: function (model, node) {
                // Get constructor based on html container type (iFrame versus static html.
                var clsName = (node.defn.ht === 0) ? 'MobileDocHTMLContainer' : 'android.HTMLContainer',
                    Cls = mstrmojo.hash.walk(clsName, mstrmojo);

                // Return instance.
                return new Cls({
                    id: node.id,
                    node: node,
                    model: model
                });
            },

            getLinkDrillMixins: function getLinkDrillMixins(useHover) {
                // Don't support hover menu in Mobile but do support touch events.
                return [ mstrmojo.android.ui._IsTouchLink, mstrmojo._HasDrillLinks ];
            },

            createPortlet: function createPortlet(t, node, w) {
                // Are we NOT on a tablet and IS the node an info window?
                if (node.defn.ifw) {
                    // Find the selected panel's definition
                    var selPanelKey = w.selectedKey,
                        selPanelDef = (w.model.getUnitDefinitions(selPanelKey) || {})[selPanelKey],
                        selPanelTitle = selPanelDef && selPanelDef.ttl;

                    w.defn.ttl = ((w.titleSrc === w.TTL_SRC_PANEL) ? selPanelTitle : w.defn.ttl) || '';

                    if (!mstrApp.isTablet()) {
                        // Set the title on the widget and...
                        w.title = w.defn.ttl;

                        // return the widget instead of a portlet.
                        return w;
                    }
                }

                return this._super(t, node, w);
            },

            destroy: function destroy() {
                var destroyObjects = this.destroyObjects,
                    i;
                if (destroyObjects) {
                    for (i = 0; i < destroyObjects.length; i++) {
                        if (destroyObjects[i].destroy) {
                            destroyObjects[i].destroy();
                        }
                    }
                }
                this._super();
            }
        }
    );

}());
(function(){
    
    mstrmojo.requiresCls("mstrmojo.MobileDocBuilder");
        
    /**
     * <p>Builds the document object model based on the supplied {@link mstrmojo.DocModel} for iPhone devices.</p>
     * 
     * @class
     * @extends mstrmojo.MobileDocBuilder
     */
    mstrmojo.iPhoneDocBuilder = mstrmojo.declare(
            // superclass
            mstrmojo.MobileDocBuilder,
            
            // mixins,
            null,
            
            /**
             * @lends mstrmojo.iPhoneDocBuilder.prototype
             */
            {
                scriptClass: "mstrmojo.iPhoneDocBuilder",
 
                /**
                 * <p>Creates and returns a mstrmojo.DocLayout widget. It does not render the layout incrementally.</p>
                 * 
                 * @param {mstrmojo.DocModel} model The DocModel the child and container belong to.
                 * @param {Object} node The data node for the child widget.
                 */
                newLayout: function newLayout(model, node) {
                        // Resolve whether the layout should be vertical or horizontal layout.
                    var LayoutCls = mstrmojo['DocLayout' + ((node.defn.horiz) ? 'Horiz' : '')];
                    
                    return new LayoutCls({ 
                            slot: "containerNode",
                            id: node.k,
                            k: node.k,
                            minHeight: node.data.mh,
                            formatResolver: model.formatResolver,
                            rules: node.defn.rules,
                            builder: this,
                            node: node,
                            defn: node.defn,
                            model: model
                        });
                }
            }
    );
    
})();
/**
 * iPhoneDocController.js Copyright 2010 MicroStrategy Incorporated. All rights
 * reserved.
 * 
 * @version 1.0
 */
( function() {
    mstrmojo.requiresCls("mstrmojo.registry", 
                         "mstrmojo.iPhoneDoc",
                         "mstrmojo.iPhoneDocBuilder", 
                         "mstrmojo.iPhoneDocDataService",
                         "mstrmojo.DocModel");

    /**
     * Submits as data request to the app.
     * 
     * @param {Any[]} args An array of arguments to be passed to the method.
     * 
     * @private
     */
    function submitDataRequest(params) {
        mstrApp.serverRequest(params);
    }

    function _cleanup() {
        var a = mstrmojo.all, i;

        for (i in a) {
            if (a.hasOwnProperty(i)) {
                mstrmojo.registry.remove(a[i]);
            }
        }
    }

    var docLayout = 'iRoot';

    var docProxy = {

        data : null,
        controller : null,

        render : function(imgCache) {
            //Create the iPhone Doc.
            var doc = new mstrmojo.iPhoneDoc( {
                id : docLayout,
                placeholder : docLayout,
                controller : this.controller,
                renderMode : null
            });

            // Add builder with parent reference to the doc.
            doc.builder = new mstrmojo.iPhoneDocBuilder( {
                parent : doc
            });

            if (!this.error) {

                var docModel = doc.model = new mstrmojo.DocModel(this.data);
                docModel.controller = this.controller;

                docModel.dataService = new mstrmojo.iPhoneDocDataService( {
                    rwb : docModel.bs,
                    msgId : docModel.mid,
                    imgCache : imgCache
                });

                doc.buildChildren();
            }
            doc.render();

            window.setTimeout( function() {
                var keys = [], 
                urls = [], 
                key,
                unc = imgCache.unCachedImg;
                if (unc) {
                    for (key in unc) {
                        if (unc.hasOwnProperty(key)) {
                            keys.push(key);
                            urls.push(unc[key]);
                        }
                    }
                    if(keys.length>0) {
                        submitDataRequest( {
                            cmd : 'cim',
                            imgs : urls.join(',,,'),
                            imgKeys : keys.join(',,,')
                        });
                    }
                }
            }, 100);
        },

        destroy : function() {
            //we do not need transition curtain for rendering a new xtab
            var w = mstrmojo.all[docLayout];
            if (w) {
                var d = w.domNode, 
                    c = d.lastChild, 
                    length = d.childNodes.length, 
                    i;

                for (i = 0; i < length; i++) {
                    //if we have some xtab already rendered, we should clean the dom so that it will not be used as a transition curtain.
                    // w.domNode.innerHTML = "";
                    // window.setTimeout(function() {
                    d.removeChild(d.lastChild);
                    // }, 0);
                }
            }
            _cleanup();
        },

        adjustSize : function() {
            var xt = mstrmojo.all[docLayout];

            // trigger the FillsBrowswer handler on orientation changed.
        xt && xt.monitorWindow();
    }

    };

    function getDocProxy(controller, data) {
        docProxy.controller = controller;
        docProxy.data = data;
        return docProxy;
    }

    /**
     * Main Controller class for iPhone Doc viewer.
     * 
     * @class
     */
    mstrmojo.iPhoneDocController = mstrmojo.declare(
            null, 
            null,
    /**
     * @lends mstrmojo.iPhoneDocController.prototype
     */
    {
        scriptClass : "mstrmojo.iPhoneDocController",

        /**
         * Initializer.
         * 
         * @param {String} props.ttl A title of the controllers first view.
         * @param {String} props.did A report ID.
         * @param {int}    props.st A report subtype.
         */
        init : function init() {
        },

        setData : function(data) {
            this.data = data;
        },

        getProxy : function(data) {
            return getDocProxy(this, data);
        },

        onDrill : function(view, params) {
            submitDataRequest(params);
        },

        onLink : function(view, params) {
            if (params.link) {
                params.linkAnswers = link.toXml();
                delete params.link;
            }
            params.cmd = 'lnk';
            submitDataRequest(params);
        }
    });
})();
/**
 * OIVMApp.js Copyright 2010 MicroStrategy Incorporated. All rights reserved.
 * 
 * @version 1.0
 */
/*
 * @fileoverview Widget that contains the entire application UI on Mobile devices.
 */

(function() {

    mstrmojo.requiresCls("mstrmojo.func",
                         "mstrmojo.form",
                         "mstrmojo.ServerProxy");

    /**
     * The iPhone server transport.
     * 
     * @type Object
     */
    mstrmojo.iPhoneServerTransport = {            
        serverRequest: function serverRequest(id, requestId, request) {
            mstrmojo.form.send(request.params, null, "POST");
        }
    };
    
    /**
     * A singleton class representing mobile application. It provides application entry point as
     * well as a bunch of application-level services. Any code within the application can access the
     * instance of this class via mstrApp global variable.
     * 
     * @class
     * @extends mstrmojo.Obj
     * 
     */
    mstrmojo.iPhoneApp = mstrmojo.declare(

        mstrmojo.Obj,
        
        null,

        /**
         * @lends mstrmojo.iPhoneApp.prototype
         */
        {
            scriptClass: "mstrmojo.iPhoneApp",
            
            /**
             * The instance of {@link mstrmojo.ServerProxy} to use for communication with the server.
             * 
             *  @type mstrmojo.ServerProxy
             */
            serverProxy: null,
            
            init: function init(props) {
                this._super(props);
                
                if (!this.serverProxy) {
                    this.serverProxy = new mstrmojo.ServerProxy({
                        transport: mstrmojo.iPhoneServerTransport,
                        _sessions: {}
                    });
                }
            },
            
            setTarget: function setTarget(target) {                
                this.data = target;                
            },            
            
            setSessionState: function(sessionState, projectId, _hostUrl, taskBaseUrl) {                                                                                                        
                this.serverProxy._sessions[projectId] = this.sessionState = sessionState;
                this.baseTaskUrl = taskBaseUrl;
                this.projectId = projectId;
                this.hostUrl = _hostUrl + "/";
            },
            
            getXtabProxy: function getXtabProxy() {
                if(this.controller) {
                    return this.controller.getProxy(this.data);
                } else {
                    var c = this.controller = new mstrmojo.iPhoneXtabController();
                    return c.getProxy(this.data);
                }
            },
            
            getDocProxy: function getDocProxy() {
                if(this.controller) {
                    return this.controller.getProxy(this.data);
                } else {
                    var c = this.controller = new mstrmojo.iPhoneDocController();
                    return c.getProxy(this.data);
                }
            },
                        
            serverRequest: function serverRequest(params) {
                try {                    
                    var app = this;
                    
                    window.setTimeout(function () {
                        app.serverProxy.request({}, params);
                    }, 0);
                    
                } catch (ex) {
                    mstrmojo.err(ex);
                }                
            }
        });
    
})();
